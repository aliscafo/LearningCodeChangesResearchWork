83
#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    // Get the LDAP authentication username and password
    // from the user's input.
    // 
    final String authUsername = who.getLocalUser();
    final String authPassword = who.getPassword();
    // 
    if (this.username == null) {
        this.username = authUsername;
        this.password = authPassword;
    }
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, authUsername);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), authPassword);
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(authUsername)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(authUsername));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(authUsername, queryForGroups(ctx, authUsername, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = authenticate(username, who.getPassword());
        } else {
            ctx = open();
        }
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private void authenticate(String dn, String password) throws AccountException {
    final Properties env = createContextProperties();
    env.put(Context.SECURITY_AUTHENTICATION, "simple");
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        new InitialDirContext(env).close();
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#method_after
private DirContext authenticate(String dn, String password) throws AccountException {
    final Properties env = createContextProperties();
    env.put(Context.SECURITY_AUTHENTICATION, "simple");
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        return new InitialDirContext(env);
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#end_block

#method_before
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#method_after
private void dependencyError(final CodeReviewCommit commit) {
    final Change c = commit.change;
    if (commit.missing == null) {
        commit.missing = new ArrayList<CodeReviewCommit>();
    }
    boolean submitStillPossible = commit.missing.size() > 0;
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // The commit doesn't have a patch set, so it cannot be
            // submitted to the branch.
            // 
            submitStillPossible = false;
            break;
        }
        if (!missingCommit.change.currentPatchSetId().equals(missingCommit.patchsetId)) {
            // If the missing commit is not the current patch set,
            // the change must be rebased to use the proper parent.
            // 
            submitStillPossible = false;
            break;
        }
    }
    final long now = System.currentTimeMillis();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        String txt = "Change could not be merged because of a missing dependency.";
        if (!isAlreadySent(c, txt)) {
            StringBuilder m = new StringBuilder();
            m.append(txt);
            m.append("\n");
            m.append("\n");
            m.append("The following changes must also be submitted:\n");
            m.append("\n");
            for (CodeReviewCommit missingCommit : commit.missing) {
                m.append("* ");
                m.append(missingCommit.change.getKey().get());
                m.append("\n");
            }
            txt = m.toString();
        }
        sendMergeFail(c, message(c, txt), false, false);
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due" + " to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.change.getKey().abbreviate());
                m.append(", however the current patch set is ");
                m.append(missingCommit.change.currentPatchSetId().get());
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        setNew(c, message(c, m.toString()));
    }
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) {
    final PatchSet.Id merged = c.currentPatchSetId();
    PatchSetApproval submitter = null;
    for (int attempts = 0; attempts < 10; attempts++) {
        c.setStatus(Change.Status.MERGED);
        ChangeUtil.updated(c);
        try {
            final Transaction txn = schema.beginTransaction();
            // Flatten out all existing approvals based upon the current
            // permissions. Once the change is closed the approvals are
            // not updated at presentation view time, so we need to make.
            // sure they are accurate now. This way if permissions get
            // modified in the future, historical records stay accurate.
            // 
            final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(c.getId()).toList();
            final FunctionState fs = functionState.create(c, merged, approvals);
            for (ApprovalType at : approvalTypes.getApprovalTypes()) {
                CategoryFunction.forCategory(at.getCategory()).run(at, fs);
            }
            for (PatchSetApproval a : approvals) {
                if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                    if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                        submitter = a;
                    }
                }
                a.cache(c);
            }
            schema.patchSetApprovals().update(approvals, txn);
            if (msg != null) {
                if (submitter != null && msg.getAuthor() == null) {
                    msg.setAuthor(submitter.getAccountId());
                }
                schema.changeMessages().insert(Collections.singleton(msg), txn);
            }
            schema.changes().update(Collections.singleton(c), txn);
            txn.commit();
            break;
        } catch (OrmException e) {
            final Change.Id id = c.getId();
            try {
                c = schema.changes().get(id);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
            } catch (OrmException e2) {
                log.error("Cannot set change " + id + " to merged " + merged, e2);
            }
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        ChangeHookRunner.get().doChangeMergedHook(c, schema.accounts().get(submitter.getAccountId()), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg) {
    final Change.Id changeId = c.getId();
    final PatchSet.Id merged = c.currentPatchSetId();
    try {
        schema.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                c.setStatus(Change.Status.MERGED);
                if (!merged.equals(c.currentPatchSetId())) {
                    // 
                    try {
                        c.setCurrentPatchSet(patchSetInfoFactory.get(merged));
                    } catch (PatchSetInfoNotAvailableException e1) {
                        log.error("Cannot read merged patch set " + merged, e1);
                    }
                }
                ChangeUtil.updated(c);
                return c;
            }
        });
    } catch (OrmConcurrencyException err) {
    } catch (OrmException err) {
        log.warn("Cannot update change status", err);
    }
    // Flatten out all existing approvals based upon the current
    // permissions. Once the change is closed the approvals are
    // not updated at presentation view time, so we need to make.
    // sure they are accurate now. This way if permissions get
    // modified in the future, historical records stay accurate.
    // 
    PatchSetApproval submitter = null;
    try {
        c.setStatus(Change.Status.MERGED);
        final List<PatchSetApproval> approvals = schema.patchSetApprovals().byChange(changeId).toList();
        final FunctionState fs = functionState.create(c, merged, approvals);
        for (ApprovalType at : approvalTypes.getApprovalTypes()) {
            CategoryFunction.forCategory(at.getCategory()).run(at, fs);
        }
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId()) && a.getPatchSetId().equals(merged)) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
            a.cache(c);
        }
        schema.patchSetApprovals().update(approvals);
    } catch (OrmException err) {
        log.warn("Cannot normalize approvals for change " + changeId, err);
    }
    if (msg != null) {
        if (submitter != null && msg.getAuthor() == null) {
            msg.setAuthor(submitter.getAccountId());
        }
        try {
            schema.changeMessages().insert(Collections.singleton(msg));
        } catch (OrmException err) {
            log.warn("Cannot store message on change", err);
        }
    }
    try {
        final MergedSender cm = mergedSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    } catch (EmailException e) {
        log.error("Cannot send email for submitted patch set " + c.getId(), e);
    }
    try {
        hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), schema.patchSets().get(c.currentPatchSetId()));
    } catch (OrmException ex) {
        log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
    }
}
#end_block

#method_before
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true);
}
#method_after
private void setNew(Change c, ChangeMessage msg) {
    sendMergeFail(c, msg, true, true);
}
#end_block

#method_before
private void sendMergeFail(Change c, ChangeMessage msg, boolean makeNew) {
    for (int attempts = 0; attempts < 10; attempts++) {
        if (makeNew) {
            c.setStatus(Change.Status.NEW);
        }
        ChangeUtil.updated(c);
        try {
            final Transaction txn = schema.beginTransaction();
            schema.changes().update(Collections.singleton(c), txn);
            if (msg != null) {
                schema.changeMessages().insert(Collections.singleton(msg), txn);
            }
            txn.commit();
            break;
        } catch (OrmException e) {
            try {
                c = schema.changes().get(c.getId());
                if (c.getStatus().isClosed()) {
                    // 
                    break;
                }
            } catch (OrmException e2) {
            }
        }
    }
    try {
        final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (submitter != null) {
            cm.setFrom(submitter.getAccountId());
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#method_after
private void sendMergeFail(Change c, ChangeMessage msg, final boolean makeNew, final boolean useSubmitter) {
    try {
        schema.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            schema.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, schema);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    try {
        final MergeFailSender cm = mergeFailSenderFactory.create(c);
        if (useSubmitter) {
            final PatchSetApproval submitter = getSubmitter(c.currentPatchSetId());
            if (submitter != null) {
                cm.setFrom(submitter.getAccountId());
            }
        }
        cm.setReviewDb(schema);
        cm.setPatchSet(schema.patchSets().get(c.currentPatchSetId()));
        cm.setChangeMessage(msg);
        cm.send();
    } catch (OrmException e) {
        log.error("Cannot send email notifications about merge failure", e);
    } catch (EmailException e) {
        log.error("Cannot send email notifications about merge failure", e);
    }
}
#end_block

#method_before
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Transaction txn = db.beginTransaction();
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    final PatchSet ps = new PatchSet(change.newPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    final PatchSetImporter imp = importFactory.create(db, c, ps, true);
    imp.setTransaction(txn);
    imp.run();
    change.setCurrentPatchSet(imp.getPatchSetInfo());
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change), txn);
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = imp.getPatchSetInfo().getAuthor() != null ? imp.getPatchSetInfo().getAuthor().getAccount() : null;
        final Account.Id committerId = imp.getPatchSetInfo().getCommitter() != null ? imp.getPatchSetInfo().getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db, txn);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db, txn);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db, txn);
            }
        }
    }
    txn.commit();
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, imp.getPatchSetInfo());
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    ChangeHookRunner.get().doPatchsetCreatedHook(change, ps);
}
#method_after
private void createChange(final RevWalk walk, final RevCommit c) throws OrmException, IOException {
    walk.parseBody(c);
    final Account.Id me = currentUser.getAccountId();
    Change.Key changeKey = new Change.Key("I" + c.name());
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (footerLine.matches(CHANGE_ID)) {
                final String v = footerLine.getValue().trim();
                if (v.matches("^I[0-9a-f]{8,}.*$")) {
                    changeKey = new Change.Key(v);
                }
            } else if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), me, destBranch);
    change.nextPatchSetId();
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(change.getCreatedOn());
    ps.setUploader(me);
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final PatchSetInfo info = patchSetInfoFactory.get(c, ps.getId());
    change.setCurrentPatchSet(info);
    ChangeUtil.updated(change);
    db.changes().insert(Collections.singleton(change));
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    haveApprovals.add(me);
    if (allTypes.size() > 0) {
        final Account.Id authorId = info.getAuthor() != null ? info.getAuthor().getAccount() : null;
        final Account.Id committerId = info.getCommitter() != null ? info.getCommitter().getAccount() : null;
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(change, ps.getId(), authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(change, ps.getId(), committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(change, ps.getId(), reviewer, catId, db);
            }
        }
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(walk) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    allNewChanges.add(change.getId());
    try {
        final CreateChangeSender cm;
        cm = createChangeSenderFactory.create(change);
        cm.setFrom(me);
        cm.setPatchSet(ps, info);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new change " + change.getId(), e);
    }
    hooks.doPatchsetCreatedHook(change, ps);
}
#end_block

#method_before
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    if (!validCommitter(request.cmd, c)) {
        return null;
    }
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result;
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    result = db.run(new OrmRunnable<ReplaceResult, ReviewDb>() {

        public ReplaceResult run(final ReviewDb db, final Transaction txn, final boolean isRetry) throws OrmException {
            final Change change = db.changes().get(request.ontoChange);
            if (change == null) {
                reject(request.cmd, "change " + request.ontoChange + " not found");
                return null;
            }
            if (change.getStatus().isClosed()) {
                reject(request.cmd, "change " + request.ontoChange + " closed");
                return null;
            }
            final PatchSet.Id priorPatchSet = change.currentPatchSetId();
            for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
                if (ps.getRevision() == null) {
                    reject(request.cmd, "change state corrupt");
                    return null;
                }
                final String revIdStr = ps.getRevision().get();
                final ObjectId commitId;
                try {
                    commitId = ObjectId.fromString(revIdStr);
                } catch (IllegalArgumentException e) {
                    log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
                    reject(request.cmd, "change state corrupt");
                    return null;
                }
                try {
                    final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
                    // 
                    if (rp.getRevWalk().isMergedInto(prior, c)) {
                        reject(request.cmd, "squash commits first");
                        return null;
                    }
                    // 
                    if (c == prior) {
                        reject(request.cmd, "commit already exists");
                        return null;
                    }
                    // 
                    if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                        rp.getRevWalk().parseBody(prior);
                        final boolean messageEq = c.getFullMessage().equals(prior.getFullMessage());
                        final boolean parentsEq = parentsEqual(c, prior);
                        if (messageEq && parentsEq) {
                            reject(request.cmd, "no changes made");
                            return null;
                        } else {
                            err.write(Constants.encode(// 
                            "warning: " + change.getKey().abbreviate() + // 
                            ": " + // 
                            " no files changed, but" + // 
                            (!messageEq ? " message updated" : "") + // 
                            (!messageEq && !parentsEq ? " and" : "") + // 
                            (!parentsEq ? " was rebased" : "") + // 
                            "\n"));
                        }
                    }
                } catch (IOException e) {
                    log.error("Change " + change.getId() + " missing " + revIdStr, e);
                    reject(request.cmd, "change state corrupt");
                    return null;
                }
            }
            final PatchSet ps = new PatchSet(change.newPatchSetId());
            ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
            ps.setUploader(currentUser.getAccountId());
            final PatchSetImporter imp = importFactory.create(db, c, ps, true);
            imp.setTransaction(txn);
            imp.run();
            final Ref mergedInto = findMergedInto(change.getDest().get(), c);
            final ReplaceResult result = new ReplaceResult();
            result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
            result.change = change;
            result.patchSet = ps;
            result.info = imp.getPatchSetInfo();
            final Account.Id authorId = imp.getPatchSetInfo().getAuthor() != null ? imp.getPatchSetInfo().getAuthor().getAccount() : null;
            final Account.Id committerId = imp.getPatchSetInfo().getCommitter() != null ? imp.getPatchSetInfo().getCommitter().getAccount() : null;
            boolean haveAuthor = false;
            boolean haveCommitter = false;
            final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
            oldReviewers.clear();
            oldCC.clear();
            for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
                haveApprovals.add(a.getAccountId());
                if (a.getValue() != 0) {
                    oldReviewers.add(a.getAccountId());
                } else {
                    oldCC.add(a.getAccountId());
                }
                final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
                if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
                    // If there was a negative vote on the prior patch set, carry it
                    // into this patch set.
                    // 
                    db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)), txn);
                }
                if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
                    haveAuthor = true;
                }
                if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
                    haveCommitter = true;
                }
            }
            final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
            msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
            db.changeMessages().insert(Collections.singleton(msg), txn);
            result.msg = msg;
            if (result.mergedIntoRef != null) {
                // Change was already submitted to a branch, close it.
                // 
                markChangeMergedByPush(db, txn, result);
            } else {
                // Change should be new, so it can go through review again.
                // 
                change.setStatus(Change.Status.NEW);
                change.setCurrentPatchSet(imp.getPatchSetInfo());
                ChangeUtil.updated(change);
                db.changes().update(Collections.singleton(change), txn);
            }
            final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
            if (allTypes.size() > 0) {
                final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
                if (authorId != null && haveApprovals.add(authorId)) {
                    insertDummyApproval(result, authorId, catId, db, txn);
                }
                if (committerId != null && haveApprovals.add(committerId)) {
                    insertDummyApproval(result, committerId, catId, db, txn);
                }
                for (final Account.Id reviewer : reviewers) {
                    if (haveApprovals.add(reviewer)) {
                        insertDummyApproval(result, reviewer, catId, db, txn);
                    }
                }
            }
            return result;
        }
    });
    if (result != null) {
        final PatchSet ps = result.patchSet;
        final RefUpdate ru = repo.updateRef(ps.getRefName());
        ru.setNewObjectId(c);
        ru.disableRefLog();
        if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
            throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
        }
        replication.scheduleUpdate(project.getNameKey(), ru.getName());
        request.cmd.setResult(ReceiveCommand.Result.OK);
        try {
            final ReplacePatchSetSender cm;
            cm = replacePatchSetFactory.create(result.change);
            cm.setFrom(me);
            cm.setPatchSet(ps, result.info);
            cm.setChangeMessage(result.msg);
            cm.setReviewDb(db);
            cm.addReviewers(reviewers);
            cm.addExtraCC(cc);
            cm.addReviewers(oldReviewers);
            cm.addExtraCC(oldCC);
            cm.send();
        } catch (EmailException e) {
            log.error("Cannot send email for new patch set " + ps.getId(), e);
        }
        ChangeHookRunner.get().doPatchsetCreatedHook(result.change, ps);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#method_after
private PatchSet.Id doReplace(final ReplaceRequest request) throws IOException, OrmException {
    final RevCommit c = request.newCommit;
    rp.getRevWalk().parseBody(c);
    if (!validCommitter(request.cmd, c)) {
        return null;
    }
    final Account.Id me = currentUser.getAccountId();
    final Set<Account.Id> reviewers = new HashSet<Account.Id>(reviewerId);
    final Set<Account.Id> cc = new HashSet<Account.Id>(ccId);
    for (final FooterLine footerLine : c.getFooterLines()) {
        try {
            if (isReviewer(footerLine)) {
                reviewers.add(toAccountId(footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                cc.add(toAccountId(footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    reviewers.remove(me);
    cc.remove(me);
    cc.removeAll(reviewers);
    final ReplaceResult result = new ReplaceResult();
    final Set<Account.Id> oldReviewers = new HashSet<Account.Id>();
    final Set<Account.Id> oldCC = new HashSet<Account.Id>();
    Change change = db.changes().get(request.ontoChange);
    if (change == null) {
        reject(request.cmd, "change " + request.ontoChange + " not found");
        return null;
    }
    if (change.getStatus().isClosed()) {
        reject(request.cmd, "change " + request.ontoChange + " closed");
        return null;
    }
    final PatchSet.Id priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : db.patchSets().byChange(request.ontoChange)) {
        if (ps.getRevision() == null) {
            reject(request.cmd, "change state corrupt");
            return null;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(request.cmd, "change state corrupt");
            return null;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, c)) {
                reject(request.cmd, "squash commits first");
                return null;
            }
            // 
            if (c == prior) {
                reject(request.cmd, "commit already exists");
                return null;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && c.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = c.getFullMessage().equals(prior.getFullMessage());
                final boolean parentsEq = parentsEqual(c, prior);
                if (messageEq && parentsEq) {
                    reject(request.cmd, "no changes made");
                    return null;
                } else {
                    err.write(Constants.encode(// 
                    "warning: " + change.getKey().abbreviate() + // 
                    ": " + // 
                    " no files changed, but" + // 
                    (!messageEq ? " message updated" : "") + // 
                    (!messageEq && !parentsEq ? " and" : "") + // 
                    (!parentsEq ? " was rebased" : "") + // 
                    "\n"));
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(request.cmd, "change state corrupt");
            return null;
        }
    }
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.nextPatchSetId();
                return change;
            } else {
                return null;
            }
        }
    });
    if (change == null) {
        reject(request.cmd, "change is closed");
        return null;
    }
    final PatchSet ps = new PatchSet(change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(currentUser.getAccountId());
    ps.setRevision(toRevId(c));
    insertAncestors(ps.getId(), c);
    db.patchSets().insert(Collections.singleton(ps));
    final Ref mergedInto = findMergedInto(change.getDest().get(), c);
    result.mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(c, ps.getId());
    final Account.Id authorId = result.info.getAuthor() != null ? result.info.getAuthor().getAccount() : null;
    final Account.Id committerId = result.info.getCommitter() != null ? result.info.getCommitter().getAccount() : null;
    boolean haveAuthor = false;
    boolean haveCommitter = false;
    final Set<Account.Id> haveApprovals = new HashSet<Account.Id>();
    oldReviewers.clear();
    oldCC.clear();
    for (PatchSetApproval a : db.patchSetApprovals().byChange(change.getId())) {
        haveApprovals.add(a.getAccountId());
        if (a.getValue() != 0) {
            oldReviewers.add(a.getAccountId());
        } else {
            oldCC.add(a.getAccountId());
        }
        final ApprovalType type = approvalTypes.getApprovalType(a.getCategoryId());
        if (a.getPatchSetId().equals(priorPatchSet) && type.getCategory().isCopyMinScore() && type.isMaxNegative(a)) {
            // If there was a negative vote on the prior patch set, carry it
            // into this patch set.
            // 
            db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
        }
        if (!haveAuthor && authorId != null && a.getAccountId().equals(authorId)) {
            haveAuthor = true;
        }
        if (!haveCommitter && committerId != null && a.getAccountId().equals(committerId)) {
            haveCommitter = true;
        }
    }
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    db.changeMessages().insert(Collections.singleton(msg));
    result.msg = msg;
    if (result.mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, result);
    } else {
        // Change should be new, so it can go through review again.
        // 
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.NEW);
                    change.setCurrentPatchSet(result.info);
                    ChangeUtil.updated(change);
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (change == null) {
            db.patchSets().delete(Collections.singleton(ps));
            db.changeMessages().delete(Collections.singleton(msg));
            reject(request.cmd, "change is closed");
            return null;
        }
    }
    final List<ApprovalType> allTypes = approvalTypes.getApprovalTypes();
    if (allTypes.size() > 0) {
        final ApprovalCategory.Id catId = allTypes.get(allTypes.size() - 1).getCategory().getId();
        if (authorId != null && haveApprovals.add(authorId)) {
            insertDummyApproval(result, authorId, catId, db);
        }
        if (committerId != null && haveApprovals.add(committerId)) {
            insertDummyApproval(result, committerId, catId, db);
        }
        for (final Account.Id reviewer : reviewers) {
            if (haveApprovals.add(reviewer)) {
                insertDummyApproval(result, reviewer, catId, db);
            }
        }
        hooks.doPatchsetCreatedHook(result.change, ps);
    }
    final RefUpdate ru = repo.updateRef(ps.getRefName());
    ru.setNewObjectId(c);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + ps.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.scheduleUpdate(project.getNameKey(), ru.getName());
    request.cmd.setResult(ReceiveCommand.Result.OK);
    try {
        final ReplacePatchSetSender cm;
        cm = replacePatchSetFactory.create(result.change);
        cm.setFrom(me);
        cm.setPatchSet(ps, result.info);
        cm.setChangeMessage(result.msg);
        cm.setReviewDb(db);
        cm.addReviewers(reviewers);
        cm.addExtraCC(cc);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
    } catch (EmailException e) {
        log.error("Cannot send email for new patch set " + ps.getId(), e);
    }
    sendMergedEmail(result);
    return result != null ? result.info.getKey() : null;
}
#end_block

#method_before
private void insertDummyApproval(final Change change, final PatchSet.Id psId, final Account.Id forAccount, final ApprovalCategory.Id catId, final ReviewDb db, final Transaction txn) throws OrmException {
    final PatchSetApproval ca = new PatchSetApproval(new PatchSetApproval.Key(psId, forAccount, catId), (short) 0);
    ca.cache(change);
    db.patchSetApprovals().insert(Collections.singleton(ca), txn);
}
#method_after
private void insertDummyApproval(final ReplaceResult result, final Account.Id forAccount, final ApprovalCategory.Id catId, final ReviewDb db) throws OrmException {
    insertDummyApproval(result.change, result.patchSet.getId(), forAccount, catId, db);
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final ReplaceResult result = db.run(new OrmRunnable<ReplaceResult, ReviewDb>() {

        @Override
        public ReplaceResult run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
            final Change change = db.changes().get(cid);
            final PatchSet ps = db.patchSets().get(psi);
            if (change == null || ps == null) {
                log.warn(project.getName() + " " + psi + " is missing");
                return null;
            }
            if (change.getStatus() == Change.Status.MERGED) {
                // 
                return null;
            }
            final ReplaceResult result = new ReplaceResult();
            result.change = change;
            result.patchSet = ps;
            result.info = patchSetInfoFactory.get(commit, psi);
            result.mergedIntoRef = refName;
            markChangeMergedByPush(db, txn, result);
            return result;
        }
    });
    sendMergedEmail(result);
}
#method_after
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final Transaction txn, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.patchSetApprovals().update(approvals, txn);
    db.changeMessages().insert(Collections.singleton(msg), txn);
    db.changes().update(Collections.singleton(change), txn);
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList();
    for (PatchSetApproval a : approvals) {
        a.cache(change);
    }
    db.patchSetApprovals().update(approvals);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(repo.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setReviewDb(db);
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        ChangeHookRunner.get().doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#method_after
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        try {
            final MergedSender cm = mergedSenderFactory.create(result.change);
            cm.setFrom(currentUser.getAccountId());
            cm.setReviewDb(db);
            cm.setPatchSet(result.patchSet, result.info);
            cm.setDest(new Branch.NameKey(project.getNameKey(), result.mergedIntoRef));
            cm.send();
        } catch (EmailException e) {
            final PatchSet.Id psi = result.patchSet.getId();
            log.error("Cannot send email for submitted patch set " + psi, e);
        }
        hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet);
    }
}
#end_block

#method_before
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, PatchSetInfoNotAvailableException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    final Change change = changeControl.getChange();
    if (change.getStatus().isClosed()) {
        throw error("change " + changeId + " is closed");
    }
    final Transaction txn = db.beginTransaction();
    final StringBuffer msgBuf = new StringBuffer();
    msgBuf.append("Patch Set ");
    msgBuf.append(patchSetId.get());
    msgBuf.append(": ");
    String verified = "";
    String approved = "";
    for (ApproveOption co : optionList) {
        final ApprovalCategory.Id category = co.getCategoryId();
        PatchSetApproval.Key psaKey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), category);
        PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
        Short score = co.value();
        if (score != null) {
            addApproval(psaKey, score, change, co, txn);
        } else {
            if (psa == null) {
                score = 0;
                addApproval(psaKey, score, change, co, txn);
            } else {
                score = psa.getValue();
            }
        }
        String message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
        msgBuf.append(" " + message + ";");
        if (category.get().equalsIgnoreCase("VRIF")) {
            verified = Short.toString(score);
        } else if (category.get().equalsIgnoreCase("CVRW")) {
            approved = Short.toString(score);
        }
    }
    msgBuf.deleteCharAt(msgBuf.length() - 1);
    msgBuf.append("\n\n");
    if (changeComment != null) {
        msgBuf.append(changeComment);
    }
    String uuid = ChangeUtil.messageUUID(db);
    ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(changeId, uuid), currentUser.getAccountId());
    cm.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(cm), txn);
    ChangeUtil.updated(change);
    db.changes().update(Collections.singleton(change), txn);
    txn.commit();
    ChangeHookRunner.get().doCommentAddedHook(change, currentUser.getAccount(), verified, approved, changeComment);
    sendMail(change, change.currentPatchSetId(), cm);
}
#method_after
private void approveOne(final PatchSet.Id patchSetId) throws NoSuchChangeException, UnloggedFailure, OrmException, PatchSetInfoNotAvailableException, EmailException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    final Change change = changeControl.getChange();
    if (change.getStatus().isClosed()) {
        throw error("change " + changeId + " is closed");
    }
    final StringBuffer msgBuf = new StringBuffer();
    msgBuf.append("Patch Set ");
    msgBuf.append(patchSetId.get());
    msgBuf.append(": ");
    final Map<ApprovalCategory.Id, ApprovalCategoryValue.Id> approvalsMap = new HashMap<ApprovalCategory.Id, ApprovalCategoryValue.Id>();
    for (ApproveOption co : optionList) {
        final ApprovalCategory.Id category = co.getCategoryId();
        PatchSetApproval.Key psaKey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), category);
        PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
        Short score = co.value();
        if (score != null) {
            addApproval(psaKey, score, change, co);
        } else {
            if (psa == null) {
                score = 0;
                addApproval(psaKey, score, change, co);
            } else {
                score = psa.getValue();
            }
        }
        final ApprovalCategoryValue.Id val = new ApprovalCategoryValue.Id(category, score);
        String message = db.approvalCategoryValues().get(val).getName();
        msgBuf.append(" " + message + ";");
        approvalsMap.put(category, val);
    }
    msgBuf.deleteCharAt(msgBuf.length() - 1);
    msgBuf.append("\n\n");
    if (changeComment != null) {
        msgBuf.append(changeComment);
    }
    String uuid = ChangeUtil.messageUUID(db);
    ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(changeId, uuid), currentUser.getAccountId());
    cm.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(cm));
    ChangeUtil.touch(change, db);
    sendMail(change, change.currentPatchSetId(), cm);
    hooks.doCommentAddedHook(change, currentUser.getAccount(), changeComment, approvalsMap);
}
#end_block

#method_before
private void addApproval(final PatchSetApproval.Key psaKey, final Short score, final Change c, final ApproveOption co, final Transaction txn) throws OrmException, UnloggedFailure {
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    boolean insert = false;
    if (psa == null) {
        insert = true;
        psa = new PatchSetApproval(psaKey, score);
    }
    final List<PatchSetApproval> approvals = Collections.emptyList();
    final FunctionState fs = functionStateFactory.create(c, psaKey.getParentKey(), approvals);
    psa.setValue(score);
    fs.normalize(approvalTypes.getApprovalType(psa.getCategoryId()), psa);
    if (score != psa.getValue()) {
        throw error(co.name() + "=" + co.value() + " not permitted");
    }
    psa.setGranted();
    if (insert) {
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#method_after
private void addApproval(final PatchSetApproval.Key psaKey, final Short score, final Change c, final ApproveOption co) throws OrmException, UnloggedFailure {
    final PatchSetApproval psa = new PatchSetApproval(psaKey, score);
    final List<PatchSetApproval> approvals = Collections.emptyList();
    final FunctionState fs = functionStateFactory.create(c, psaKey.getParentKey(), approvals);
    psa.setValue(score);
    fs.normalize(approvalTypes.getApprovalType(psa.getCategoryId()), psa);
    if (score != psa.getValue()) {
        throw error(co.name() + "=" + co.value() + " not permitted");
    }
    psa.setGranted();
    db.patchSetApprovals().upsert(Collections.singleton(psa));
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    final Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    Boolean dbSuccess = db.run(new OrmRunnable<Boolean, ReviewDb>() {

        public Boolean run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
            return doAbandonChange(message, change, patchSetId, cmsg, db, txn);
        }
    });
    if (dbSuccess) {
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(currentUser.getAccountId());
        cm.setReviewDb(db);
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    ChangeHookRunner.get().doChangeAbandonedHook(change, currentUser.getAccount(), message);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAbandon()) {
        throw new NoSuchChangeException(changeId);
    }
    Change change = control.getChange();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), currentUser.getAccountId());
    final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Abandoned");
    if (message != null && message.length() > 0) {
        msgBuf.append("\n\n");
        msgBuf.append(message);
    }
    cmsg.setMessage(msgBuf.toString());
    change = db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen() && change.currentPatchSetId().equals(patchSetId)) {
                change.setStatus(Change.Status.ABANDONED);
                ChangeUtil.updated(change);
                return change;
            } else {
                return null;
            }
        }
    });
    if (change != null) {
        db.changeMessages().insert(Collections.singleton(cmsg));
        final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList();
        for (PatchSetApproval a : approvals) {
            a.cache(change);
        }
        db.patchSetApprovals().update(approvals);
        // Email the reviewers
        final AbandonedSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(currentUser.getAccountId());
        cm.setReviewDb(db);
        cm.setChangeMessage(cmsg);
        cm.send();
    }
    hooks.doChangeAbandonedHook(change, currentUser.getAccount(), message);
    return changeDetailFactory.create(changeId).call();
}
#end_block

#method_before
private void generateProxyCallCreator(final TreeLogger logger, final SourceWriter w) throws UnableToCompleteException {
    // TODO: implement annotation for json-rpc versions selection
    String callName = getJsonCallClassName(logger);
    w.println();
    w.println("@Override");
    w.print("protected <T> ");
    w.print(callName);
    w.print("<T> newJsonCall(final AbstractJsonProxy proxy, ");
    w.print("final String methodName, final String reqData, ");
    w.println("final ResultDeserializer<T> ser, final AsyncCallback<T> cb) {");
    w.indent();
    w.print("return new ");
    w.print(callName);
    w.println("<T>(proxy, methodName, reqData, ser, cb);");
    w.outdent();
    w.println("}");
}
#method_after
private void generateProxyCallCreator(final TreeLogger logger, final SourceWriter w) throws UnableToCompleteException {
    String callName = getJsonCallClassName(logger);
    w.println();
    w.println("@Override");
    w.print("protected <T> ");
    w.print(callName);
    w.print("<T> newJsonCall(final AbstractJsonProxy proxy, ");
    w.print("final String methodName, final String reqData, ");
    w.println("final ResultDeserializer<T> ser, final AsyncCallback<T> cb) {");
    w.indent();
    w.print("return new ");
    w.print(callName);
    w.println("<T>(proxy, methodName, reqData, ser, cb);");
    w.outdent();
    w.println("}");
}
#end_block

#method_before
private void generateProxyMethod(final TreeLogger logger, final JMethod method, final SourceWriter w) {
    final JParameter[] params = method.getParameters();
    final JParameter callback = params[params.length - 1];
    final JClassType resultType = callback.getType().isParameterized().getTypeArgs()[0];
    final String[] serializerFields = new String[params.length];
    final HostPageCache hpc = method.getAnnotation(HostPageCache.class);
    w.println();
    for (int i = 0; i < params.length - 1; i++) {
        final JType pType = params[i].getType();
        if (SerializerCreator.needsTypeParameter(pType)) {
            serializerFields[i] = "serializer_" + instanceField++;
            w.print("private static final ");
            if (pType.isArray() != null)
                w.print(serializerCreator.serializerFor(pType));
            else
                w.print(JsonSerializer.class.getName());
            w.print(" ");
            w.print(serializerFields[i]);
            w.print(" = ");
            serializerCreator.generateSerializerReference(pType, w);
            w.println(";");
        }
    }
    if (resultType.isParameterized() != null) {
        serializerFields[params.length - 1] = "serializer_" + instanceField++;
        w.print("private static final ");
        w.print(ResultDeserializer.class.getName());
        w.print(" ");
        w.print(serializerFields[params.length - 1]);
        w.print(" = ");
        serializerCreator.generateSerializerReference(resultType, w);
        w.println(";");
    }
    w.print("public ");
    w.print(method.getReturnType().getQualifiedSourceName());
    w.print(" ");
    w.print(method.getName());
    w.print("(");
    boolean needsComma = false;
    final NameFactory nameFactory = new NameFactory();
    for (int i = 0; i < params.length; i++) {
        final JParameter param = params[i];
        if (needsComma) {
            w.print(", ");
        } else {
            needsComma = true;
        }
        final JType paramType = param.getType().getErasedType();
        w.print(paramType.getQualifiedSourceName());
        w.print(" ");
        nameFactory.addName(param.getName());
        w.print(param.getName());
    }
    w.println(") {");
    w.indent();
    if (returnsCallbackHandle(method)) {
        w.print("return new ");
        w.print(CallbackHandle.class.getName());
        w.print("(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.println(");");
        w.outdent();
        w.println("}");
        return;
    }
    if (hpc != null) {
        final String objName = nameFactory.createName("cached");
        w.print("final JavaScriptObject " + objName + " = ");
        w.print(AbstractJsonProxy.class.getName());
        w.print(".");
        w.print(hpc.once() ? "hostPageCacheGetOnce" : "hostPageCacheGetMany");
        w.println("(\"" + hpc.name() + "\");");
        w.println("if (" + objName + " != null) {");
        w.indent();
        w.print(JsonUtil.class.getName());
        w.print(".invoke(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.print(", " + objName);
        w.println(");");
        w.println("return;");
        w.outdent();
        w.println("}");
    }
    final String reqDataStr;
    if (params.length == 1) {
        reqDataStr = "\"\"";
    } else {
        final String reqData = nameFactory.createName("reqData");
        w.println("final StringBuilder " + reqData + " = new StringBuilder();");
        needsComma = false;
        for (int i = 0; i < params.length - 1; i++) {
            if (needsComma) {
                w.println(reqData + ".append(\",\");");
            } else {
                needsComma = true;
            }
            final JType pType = params[i].getType();
            final String pName = params[i].getName();
            if (pType == JPrimitiveType.CHAR || SerializerCreator.isBoxedCharacter(pType)) {
                w.println(reqData + ".append(\"\\\"\");");
                w.println(reqData + ".append(" + JsonSerializer.class.getSimpleName() + ".escapeChar(" + pName + "));");
                w.println(reqData + ".append(\"\\\"\");");
            } else if ((SerializerCreator.isJsonPrimitive(pType) || SerializerCreator.isBoxedPrimitive(pType)) && !SerializerCreator.isJsonString(pType)) {
                w.println(reqData + ".append(" + pName + ");");
            } else {
                w.println("if (" + pName + " != null) {");
                w.indent();
                if (SerializerCreator.needsTypeParameter(pType)) {
                    w.print(serializerFields[i]);
                } else {
                    serializerCreator.generateSerializerReference(pType, w);
                }
                w.println(".printJson(" + reqData + ", " + pName + ");");
                w.outdent();
                w.println("} else {");
                w.indent();
                w.println(reqData + ".append(" + JsonSerializer.class.getName() + ".JS_NULL);");
                w.outdent();
                w.println("}");
            }
        }
        reqDataStr = reqData + ".toString()";
    }
    w.print("doInvoke(");
    w.print("\"" + method.getName() + "\"");
    w.print(", " + reqDataStr);
    w.print(", ");
    if (resultType.isParameterized() != null) {
        w.print(serializerFields[params.length - 1]);
    } else {
        deserializerCreator.generateDeserializerReference(resultType, w);
    }
    w.print(", " + callback.getName());
    w.println(");");
    w.outdent();
    w.println("}");
}
#method_after
private void generateProxyMethod(final TreeLogger logger, final JMethod method, final SourceWriter w) {
    final JParameter[] params = method.getParameters();
    final JParameter callback = params[params.length - 1];
    final JClassType resultType = callback.getType().isParameterized().getTypeArgs()[0];
    final String[] serializerFields = new String[params.length];
    final HostPageCache hpc = method.getAnnotation(HostPageCache.class);
    w.println();
    for (int i = 0; i < params.length - 1; i++) {
        final JType pType = params[i].getType();
        if (SerializerCreator.needsTypeParameter(pType)) {
            serializerFields[i] = "serializer_" + instanceField++;
            w.print("private static final ");
            if (pType.isArray() != null)
                w.print(serializerCreator.serializerFor(pType));
            else
                w.print(JsonSerializer.class.getName());
            w.print(" ");
            w.print(serializerFields[i]);
            w.print(" = ");
            serializerCreator.generateSerializerReference(pType, w);
            w.println(";");
        }
    }
    if (resultType.isParameterized() != null) {
        serializerFields[params.length - 1] = "serializer_" + instanceField++;
        w.print("private static final ");
        w.print(ResultDeserializer.class.getName());
        w.print(" ");
        w.print(serializerFields[params.length - 1]);
        w.print(" = ");
        serializerCreator.generateSerializerReference(resultType, w);
        w.println(";");
    }
    w.print("public ");
    w.print(method.getReturnType().getQualifiedSourceName());
    w.print(" ");
    w.print(method.getName());
    w.print("(");
    boolean needsComma = false;
    final NameFactory nameFactory = new NameFactory();
    for (int i = 0; i < params.length; i++) {
        final JParameter param = params[i];
        if (needsComma) {
            w.print(", ");
        } else {
            needsComma = true;
        }
        final JType paramType = param.getType().getErasedType();
        w.print(paramType.getQualifiedSourceName());
        w.print(" ");
        nameFactory.addName(param.getName());
        w.print(param.getName());
    }
    w.println(") {");
    w.indent();
    if (returnsCallbackHandle(method)) {
        w.print("return new ");
        w.print(CallbackHandle.class.getName());
        w.print("(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.println(");");
        w.outdent();
        w.println("}");
        return;
    }
    if (hpc != null) {
        final String objName = nameFactory.createName("cached");
        w.print("final JavaScriptObject " + objName + " = ");
        w.print(AbstractJsonProxy.class.getName());
        w.print(".");
        w.print(hpc.once() ? "hostPageCacheGetOnce" : "hostPageCacheGetMany");
        w.println("(\"" + hpc.name() + "\");");
        w.println("if (" + objName + " != null) {");
        w.indent();
        w.print(JsonUtil.class.getName());
        w.print(".invoke(");
        if (SerializerCreator.needsTypeParameter(resultType)) {
            w.print(serializerFields[params.length - 1]);
        } else {
            deserializerCreator.generateDeserializerReference(resultType, w);
        }
        w.print(", " + callback.getName());
        w.print(", " + objName);
        w.println(");");
        w.println("return;");
        w.outdent();
        w.println("}");
    }
    final String reqDataStr;
    if (params.length == 1) {
        reqDataStr = "\"[]\"";
    } else {
        final String reqData = nameFactory.createName("reqData");
        w.println("final StringBuilder " + reqData + " = new StringBuilder();");
        needsComma = false;
        w.println(reqData + ".append('[');");
        for (int i = 0; i < params.length - 1; i++) {
            if (needsComma) {
                w.println(reqData + ".append(\",\");");
            } else {
                needsComma = true;
            }
            final JType pType = params[i].getType();
            final String pName = params[i].getName();
            if (pType == JPrimitiveType.CHAR || SerializerCreator.isBoxedCharacter(pType)) {
                w.println(reqData + ".append(\"\\\"\");");
                w.println(reqData + ".append(" + JsonSerializer.class.getSimpleName() + ".escapeChar(" + pName + "));");
                w.println(reqData + ".append(\"\\\"\");");
            } else if ((SerializerCreator.isJsonPrimitive(pType) || SerializerCreator.isBoxedPrimitive(pType)) && !SerializerCreator.isJsonString(pType)) {
                w.println(reqData + ".append(" + pName + ");");
            } else {
                w.println("if (" + pName + " != null) {");
                w.indent();
                if (SerializerCreator.needsTypeParameter(pType)) {
                    w.print(serializerFields[i]);
                } else {
                    serializerCreator.generateSerializerReference(pType, w);
                }
                w.println(".printJson(" + reqData + ", " + pName + ");");
                w.outdent();
                w.println("} else {");
                w.indent();
                w.println(reqData + ".append(" + JsonSerializer.class.getName() + ".JS_NULL);");
                w.outdent();
                w.println("}");
            }
        }
        w.println(reqData + ".append(']');");
        reqDataStr = reqData + ".toString()";
    }
    w.print("doInvoke(");
    w.print("\"" + method.getName() + "\"");
    w.print(", " + reqDataStr);
    w.print(", ");
    if (resultType.isParameterized() != null) {
        w.print(serializerFields[params.length - 1]);
    } else {
        deserializerCreator.generateDeserializerReference(resultType, w);
    }
    w.print(", " + callback.getName());
    w.println(");");
    w.outdent();
    w.println("}");
}
#end_block

#method_before
@Override
void send() {
    final StringBuilder body = new StringBuilder();
    body.append("{\"version\":\"1.1\",\"method\":\"");
    body.append(methodName);
    body.append("\",\"params\":[");
    body.append(requestParams);
    body.append("]");
    final String xsrfKey = proxy.getXsrfManager().getToken(proxy);
    if (xsrfKey != null) {
        body.append(",\"xsrfKey\":");
        body.append(JsonSerializer.escapeString(xsrfKey));
    }
    body.append("}");
    final RequestBuilder rb;
    rb = new RequestBuilder(RequestBuilder.POST, proxy.url);
    rb.setHeader("Content-Type", JsonUtil.JSON_REQ_CT);
    rb.setHeader("Accept", JsonUtil.JSON_TYPE);
    rb.setCallback(this);
    rb.setRequestData(body.toString());
    send(rb);
}
#method_after
@Override
void send() {
    final StringBuilder body = new StringBuilder();
    body.append("{\"version\":\"1.1\",\"method\":\"");
    body.append(methodName);
    body.append("\",\"params\":");
    body.append(requestParams);
    final String xsrfKey = proxy.getXsrfManager().getToken(proxy);
    if (xsrfKey != null) {
        body.append(",\"xsrfKey\":");
        body.append(JsonSerializer.escapeString(xsrfKey));
    }
    body.append("}");
    final RequestBuilder rb;
    rb = new RequestBuilder(RequestBuilder.POST, proxy.url);
    rb.setHeader("Content-Type", JsonUtil.JSON_REQ_CT);
    rb.setHeader("Accept", JsonUtil.JSON_TYPE);
    rb.setCallback(this);
    rb.setRequestData(body.toString());
    send(rb);
}
#end_block

#method_before
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (rsp.getStatusCode() == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(rsp.getStatusCode(), rsp.getStatusText()));
    }
}
#method_after
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#end_block

#method_before
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    // FIXME: implement version 2.0
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (rsp.getStatusCode() == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(rsp.getStatusCode(), rsp.getStatusText()));
    }
}
#method_after
@Override
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            // TODO: define status code for the invalid XSRF msg for 2.0 (-32099 ?)
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("data")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#end_block

#method_before
private List<ReplicationConfig> allConfigs(final File path) throws ConfigInvalidException, IOException {
    final File cfgFile = new File(path, "replication.config");
    final FileBasedConfig cfg = new FileBasedConfig(cfgFile);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException("Config file " + cfg.getFile() + " is invalid: " + e.getMessage(), e);
    } catch (IOException e) {
        throw new IOException("Cannot read " + cfgFile + ": " + e.getMessage(), e);
    }
    final List<ReplicationConfig> r = new ArrayList<ReplicationConfig>();
    for (final RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (final URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException("remote." + c.getName() + ".url" + " \"" + u + "\" lacks ${name} placeholder in " + cfg.getFile());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            RefSpec spec = new RefSpec();
            spec = spec.setSourceDestination("refs/*", "refs/*");
            spec = spec.setForceUpdate(true);
            c.addPushRefSpec(spec);
        }
        r.add(new ReplicationConfig(injector, workQueue, c, cfg));
    }
    return Collections.unmodifiableList(r);
}
#method_after
private List<ReplicationConfig> allConfigs(final File path) throws ConfigInvalidException, IOException {
    final File cfgFile = new File(path, "replication.config");
    final FileBasedConfig cfg = new FileBasedConfig(cfgFile);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException("Config file " + cfg.getFile() + " is invalid: " + e.getMessage(), e);
    } catch (IOException e) {
        throw new IOException("Cannot read " + cfgFile + ": " + e.getMessage(), e);
    }
    final List<ReplicationConfig> r = new ArrayList<ReplicationConfig>();
    for (final RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (final URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException("remote." + c.getName() + ".url" + " \"" + u + "\" lacks ${name} placeholder in " + cfg.getFile());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            RefSpec spec = new RefSpec();
            spec = spec.setSourceDestination("refs/*", "refs/*");
            spec = spec.setForceUpdate(true);
            c.addPushRefSpec(spec);
        }
        r.add(new ReplicationConfig(injector, workQueue, c, cfg, database, replicationUserFactory));
    }
    return Collections.unmodifiableList(r);
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri) {
    try {
        if (!projectControlFactory.controlFor(project).isVisible()) {
            return;
        }
    } catch (NoSuchProjectException e1) {
        log.error("Internal error: project " + project + " not found during replication");
        return;
    }
    synchronized (pending) {
        PushOp e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project.get(), uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri) {
    try {
        if (authEnabled && !projectControlFactory.controlFor(project).isVisible()) {
            return;
        }
    } catch (NoSuchProjectException e1) {
        log.error("Internal error: project " + project + " not found during replication");
        return;
    }
    synchronized (pending) {
        PushOp e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project.get(), uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
    }
}
#end_block

#method_before
@Override
public Set<Id> getEffectiveGroups() {
    if (effectiveGroups == null) {
        effectiveGroups = new HashSet<Id>();
        if (authGroupNames == null) {
            effectiveGroups.addAll(authConfig.getAnonymousGroups());
        } else {
            effectiveGroups.addAll(authConfig.getRegisteredGroups());
            for (String authGroupName : authGroupNames) {
                AccountGroup group = groupCache.lookup(authGroupName);
                if (group != null) {
                    effectiveGroups.add(group.getId());
                }
            }
        }
    }
    return effectiveGroups;
}
#method_after
@Override
public Set<AccountGroup.Id> getEffectiveGroups() {
    return Collections.unmodifiableSet(effectiveGroups);
}
#end_block

#method_before
@Override
public Set<Change.Id> getStarredChanges() {
    return null;
}
#method_after
@Override
public Set<Change.Id> getStarredChanges() {
    return Collections.emptySet();
}
#end_block

#method_before
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    SafeHtml msg = new SafeHtmlBuilder().append(info.getMessage());
    msg = msg.linkify();
    msg.setFindReplaceList(Gerrit.getConfig().getCommentLinks());
    msg = msg.runFindReplaceList();
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#method_after
public void display(final Change chg, final PatchSetInfo info, final AccountInfoCache acc) {
    infoBlock.display(chg, acc);
    SafeHtml msg = new SafeHtmlBuilder().append(info.getMessage());
    msg = msg.linkify();
    msg = msg.replaceAll(Gerrit.getConfig().getCommentLinks());
    msg = new SafeHtmlBuilder().openElement("p").append(msg).closeElement("p");
    msg = msg.replaceAll("\n\n", "</p><p>");
    msg = msg.replaceAll("\n", "<br />");
    SafeHtml.set(description, msg);
}
#end_block

#method_before
protected void setMessageText(String message) {
    if (message == null) {
        message = "";
    } else {
        message = message.trim();
    }
    messageSummary.setText(summarize(message));
    SafeHtml msg = new SafeHtmlBuilder().append(message);
    msg.setFindReplaceList(Gerrit.getConfig().getCommentLinks());
    SafeHtml.set(messageText, msg.wikify().runFindReplaceList());
}
#method_after
protected void setMessageText(String message) {
    if (message == null) {
        message = "";
    } else {
        message = message.trim();
    }
    messageSummary.setText(summarize(message));
    SafeHtml.set(messageText, new SafeHtmlBuilder().append(message).wikify().replaceAll(Gerrit.getConfig().getCommentLinks()));
}
#end_block

#method_before
private GerritConfig create() {
    final GerritConfig config = new GerritConfig();
    config.setCanonicalUrl(canonicalWebUrl);
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setUseRepoDownload(cfg.getBoolean("repo", null, "showdownloadcommand", false));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setApprovalTypes(approvalTypes);
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled()) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    final String gitwebUrl = cfg.getString("gitweb", null, "url");
    if (gitwebUrl != null) {
        config.setGitwebLink(new GitwebLink(gitwebUrl));
    }
    config.setSshdAddress(sshInfo != null ? sshInfo.getSshdAddress() : null);
    ArrayList<String> commentLinkNames = new ArrayList<String>(cfg.getSubsections("CommentLink"));
    ArrayList<RegexFindReplace> commentLinks = new ArrayList<RegexFindReplace>(commentLinkNames.size());
    for (String commentLinkName : commentLinkNames) {
        String match = cfg.getString("CommentLink", commentLinkName, "match");
        String link = cfg.getString("CommentLink", commentLinkName, "link");
        commentLinks.add(new RegexFindReplace(match, link));
    }
    config.setCommentLinks(commentLinks);
    return config;
}
#method_after
private GerritConfig create() {
    final GerritConfig config = new GerritConfig();
    config.setCanonicalUrl(canonicalWebUrl);
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setUseRepoDownload(cfg.getBoolean("repo", null, "showdownloadcommand", false));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setApprovalTypes(approvalTypes);
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled()) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    final String gitwebUrl = cfg.getString("gitweb", null, "url");
    if (gitwebUrl != null) {
        config.setGitwebLink(new GitwebLink(gitwebUrl));
    }
    config.setSshdAddress(sshInfo != null ? sshInfo.getSshdAddress() : null);
    ArrayList<String> commentLinkNames = new ArrayList<String>(cfg.getSubsections("CommentLink"));
    ArrayList<RegexFindReplace> commentLinks = new ArrayList<RegexFindReplace>(commentLinkNames.size());
    for (String commentLinkName : commentLinkNames) {
        String match = cfg.getString("commentlink", commentLinkName, "match");
        String link = "<a href=\"" + cfg.getString("commentlink", commentLinkName, "link") + "\">$&</a>";
        commentLinks.add(new RegexFindReplace(match, link));
    }
    config.setCommentLinks(commentLinks);
    return config;
}
#end_block

#method_before
public SafeHtml replaceAll(final String regex, final String repl) {
    return new SafeHtmlString(asString().replaceAll(regex, repl));
}
#method_after
public SafeHtml replaceAll(final List<RegexFindReplace> findReplaceList) {
    if (findReplaceList == null) {
        return this;
    }
    String html = this.asString();
    for (RegexFindReplace findReplace : findReplaceList) {
        html = html.replaceAll(findReplace.find(), findReplace.replace());
    }
    return new SafeHtmlString(html);
}
#end_block

#method_before
private void initReadCategory(final ReviewDb c, final SystemConfig sConfig) throws OrmException {
    final Transaction txn = c.beginTransaction();
    final ApprovalCategory cat;
    final ArrayList<ApprovalCategoryValue> vals;
    cat = new ApprovalCategory(ApprovalCategory.READ, "Read Access");
    cat.setPosition((short) -1);
    cat.setFunctionName(NoOpFunction.NAME);
    vals = new ArrayList<ApprovalCategoryValue>();
    vals.add(value(cat, 2, "Upload permission"));
    vals.add(value(cat, 1, "Read access"));
    vals.add(value(cat, -1, "No access"));
    c.approvalCategories().insert(Collections.singleton(cat), txn);
    c.approvalCategoryValues().insert(vals, txn);
    txn.commit();
    {
        final ProjectRight read = new ProjectRight(new ProjectRight.Key(DEFAULT_WILD_NAME, cat.getId(), sConfig.anonymousGroupId));
        read.setMaxValue((short) 1);
        read.setMinValue((short) 1);
        c.projectRights().insert(Collections.singleton(read));
    }
    {
        final ProjectRight read = new ProjectRight(new ProjectRight.Key(DEFAULT_WILD_NAME, cat.getId(), sConfig.adminGroupId));
        read.setMaxValue((short) 1);
        read.setMinValue((short) 1);
        c.projectRights().insert(Collections.singleton(read));
    }
}
#method_after
private void initReadCategory(final ReviewDb c, final SystemConfig sConfig) throws OrmException {
    final Transaction txn = c.beginTransaction();
    final ApprovalCategory cat;
    final ArrayList<ApprovalCategoryValue> vals;
    cat = new ApprovalCategory(ApprovalCategory.READ, "Read Access");
    cat.setPosition((short) -1);
    cat.setFunctionName(NoOpFunction.NAME);
    vals = new ArrayList<ApprovalCategoryValue>();
    vals.add(value(cat, 2, "Upload permission"));
    vals.add(value(cat, 1, "Read access"));
    vals.add(value(cat, -1, "No access"));
    c.approvalCategories().insert(Collections.singleton(cat), txn);
    c.approvalCategoryValues().insert(vals, txn);
    txn.commit();
    {
        final ProjectRight read = new ProjectRight(new ProjectRight.Key(DEFAULT_WILD_NAME, cat.getId(), sConfig.anonymousGroupId));
        read.setMaxValue((short) 2);
        read.setMinValue((short) 1);
        c.projectRights().insert(Collections.singleton(read));
    }
    {
        final ProjectRight read = new ProjectRight(new ProjectRight.Key(DEFAULT_WILD_NAME, cat.getId(), sConfig.adminGroupId));
        read.setMaxValue((short) 1);
        read.setMinValue((short) 1);
        c.projectRights().insert(Collections.singleton(read));
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    final String reqName = project.getName();
    if (!canUpload()) {
        throw new Failure(1, "fatal: Upload denied for project '" + reqName + "'", new SecurityException("Account lacks Upload permission"));
    }
    if (project.isUseContributorAgreements()) {
        verifyActiveContributorAgreement();
    }
    refLogIdent = currentUser.newPersonIdent();
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    rp = new ReceivePack(repo);
    rp.setAllowCreates(true);
    rp.setAllowDeletes(true);
    rp.setAllowNonFastForwards(true);
    rp.setCheckReceivedObjects(true);
    rp.setRefLogIdent(refLogIdent);
    rp.setPreReceiveHook(new PreReceiveHook() {

        public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
            parseCommands(commands);
            if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
                createNewChanges();
            }
            doReplaces();
        }
    });
    rp.setPostReceiveHook(new PostReceiveHook() {

        public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
            for (final ReceiveCommand c : commands) {
                if (c.getResult() == Result.OK) {
                    if (isHead(c)) {
                        switch(c.getType()) {
                            case CREATE:
                                insertBranchEntity(c);
                                autoCloseChanges(c);
                                break;
                            case DELETE:
                                deleteBranchEntity(c);
                                break;
                            case UPDATE:
                            case UPDATE_NONFASTFORWARD:
                                autoCloseChanges(c);
                                break;
                        }
                    }
                    if (isHead(c) || isTag(c)) {
                        // We only schedule heads and tags for replication.
                        // Change refs are scheduled when they are created.
                        // 
                        replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                    }
                }
            }
        }
    });
    rp.receive(in, out, err);
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        // Make sure there isn't anything buffered; we want to give the
        // push client a chance to display its status report before we
        // show our own messages on standard error.
        // 
        out.flush();
        final String url = canonicalWebUrl;
        final PrintWriter msg = toPrintWriter(err);
        msg.write("\nNew Changes:\n");
        for (final Change.Id c : allNewChanges) {
            msg.write("  " + url + c.get() + "\n");
        }
        msg.write('\n');
        msg.flush();
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!canUpload()) {
        final String reqName = project.getName();
        throw new Failure(1, "fatal: Upload denied for project '" + reqName + "'", new SecurityException("Account lacks Upload permission"));
    }
    if (project.isUseContributorAgreements()) {
        verifyActiveContributorAgreement();
    }
    refLogIdent = currentUser.newPersonIdent();
    verifyProjectVisible("reviewer", reviewerId);
    verifyProjectVisible("CC", ccId);
    rp = new ReceivePack(repo);
    rp.setAllowCreates(true);
    rp.setAllowDeletes(true);
    rp.setAllowNonFastForwards(true);
    rp.setCheckReceivedObjects(true);
    rp.setRefLogIdent(refLogIdent);
    rp.setPreReceiveHook(new PreReceiveHook() {

        public void onPreReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
            parseCommands(commands);
            if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
                createNewChanges();
            }
            doReplaces();
        }
    });
    rp.setPostReceiveHook(new PostReceiveHook() {

        public void onPostReceive(final ReceivePack arg0, final Collection<ReceiveCommand> commands) {
            for (final ReceiveCommand c : commands) {
                if (c.getResult() == Result.OK) {
                    if (isHead(c)) {
                        switch(c.getType()) {
                            case CREATE:
                                insertBranchEntity(c);
                                autoCloseChanges(c);
                                break;
                            case DELETE:
                                deleteBranchEntity(c);
                                break;
                            case UPDATE:
                            case UPDATE_NONFASTFORWARD:
                                autoCloseChanges(c);
                                break;
                        }
                    }
                    if (isHead(c) || isTag(c)) {
                        // We only schedule heads and tags for replication.
                        // Change refs are scheduled when they are created.
                        // 
                        replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                    }
                }
            }
        }
    });
    rp.receive(in, out, err);
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        // Make sure there isn't anything buffered; we want to give the
        // push client a chance to display its status report before we
        // show our own messages on standard error.
        // 
        out.flush();
        final String url = canonicalWebUrl;
        final PrintWriter msg = toPrintWriter(err);
        msg.write("\nNew Changes:\n");
        for (final Change.Id c : allNewChanges) {
            msg.write("  " + url + c.get() + "\n");
        }
        msg.write('\n');
        msg.flush();
    }
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            who.setDisplayName(m.get(accountFullName));
            who.setSshUserName(m.get(accountSshUserName));
            if (accountEmailAddress != null) {
                who.setEmailAddress(m.get(accountEmailAddress));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                authenticate(m.getDN(), who.getPassword());
            }
            who.setDisplayName(apply(accountFullName, m));
            who.setSshUserName(apply(accountSshUserName, m));
            if (accountEmailAddress != null) {
                who.setEmailAddress(apply(accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to autenticate user", e);
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    final HashMap<String, String> params = new HashMap<String, String>();
    params.put(USERNAME, username);
    if (groupNeedsAccount) {
        if (account == null) {
            account = findAccount(ctx, username);
        }
        for (final String name : groupMemberQueryList.get(0).getParameters()) {
            params.put(name, account.get(name));
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (LdapQuery groupMemberQuery : groupMemberQueryList) {
        for (LdapQuery.Result r : groupMemberQuery.query(ctx, params)) {
            NamingEnumeration groups = r.getAll(memberField).getAll();
            while (groups.hasMore()) {
                final String name = String.valueOf(groups.next());
                final AccountGroup group = groupCache.lookup(name);
                if (group != null && isLdapGroup(group)) {
                    actual.add(group.getId());
                }
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#method_after
private Set<AccountGroup.Id> queryForGroups(final DirContext ctx, final String username, LdapQuery.Result account) throws NamingException, AccountException {
    if (account == null) {
        account = findAccount(ctx, username);
    }
    final HashMap<String, String> params = new HashMap<String, String>();
    params.put(USERNAME, username);
    if (groupNeedsAccount) {
        for (final String name : groupMemberQueryList.get(0).getParameters()) {
            params.put(name, account.get(name));
        }
    }
    final Set<AccountGroup.Id> actual = new HashSet<AccountGroup.Id>();
    for (LdapQuery groupMemberQuery : groupMemberQueryList) {
        for (LdapQuery.Result r : groupMemberQuery.query(ctx, params)) {
            final String name = r.get(groupName);
            final AccountGroup group = groupCache.lookup(name);
            if (group != null && isLdapGroup(group)) {
                actual.add(group.getId());
            }
        }
    }
    NamingEnumeration groups = account.getAll(accountMemberField).getAll();
    while (groups.hasMore()) {
        final String dn = (String) groups.next();
        for (String cn : groupsFor(ctx, dn)) {
            AccountGroup group = groupCache.lookup(cn);
            if (null != group && isLdapGroup(group)) {
                actual.add(group.getId());
            }
        }
    }
    if (actual.isEmpty()) {
        return Collections.emptySet();
    } else {
        return Collections.unmodifiableSet(actual);
    }
}
#end_block

#method_before
@Override
public List<RealmProperty> getProperties(final AccountGroup group) {
    if (!isLdapGroup(group)) {
        return Collections.emptyList();
    }
    try {
        final DirContext ctx = open();
        try {
            final Map<String, String> params = new HashMap<String, String>();
            params.put(GROUPNAME, group.getName());
            final List<RealmProperty> props = new ArrayList<RealmProperty>();
            final List<LdapQuery.Result> q = new ArrayList<LdapQuery.Result>();
            for (LdapQuery groupByNameQuery : groupByNameQueryList) {
                q.addAll(groupByNameQuery.query(ctx, params));
            }
            switch(q.size()) {
                case 0:
                    log.warn("Group \"" + group.getName() + "\" not found in LDAP.");
                    props.add(new RealmProperty("error", "NOT FOUND"));
                    break;
                case 1:
                    for (final String name : q.get(0).keySet()) {
                        props.add(new RealmProperty(name, q.get(0).get(name)));
                    }
                    Collections.sort(props, new Comparator<RealmProperty>() {

                        @Override
                        public int compare(final RealmProperty a, final RealmProperty b) {
                            int sort = classOf(a) - classOf(b);
                            if (sort == 0)
                                sort = a.getName().compareTo(b.getName());
                            return sort;
                        }

                        private int classOf(final RealmProperty p) {
                            final String n = p.getName();
                            if ("dn".equals(n) || "distinguishedName".equals(n))
                                return 0;
                            if ("cn".equals(n))
                                return 1;
                            return 5000;
                        }
                    });
                    break;
                default:
                    log.warn("Group \"" + group.getName() + "\" has multiple matches in LDAP: " + q);
                    props.add(new RealmProperty("error", "MULTIPLE MATCHES"));
                    break;
            }
            return props;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP directory for group " + group.getName(), e);
        return Collections.emptyList();
    }
}
#method_after
@Override
public List<RealmProperty> getProperties(final AccountGroup group) {
    if (!isLdapGroup(group)) {
        return Collections.emptyList();
    }
    try {
        final DirContext ctx = open();
        try {
            final Map<String, String> params = new HashMap<String, String>();
            params.put(GROUPNAME, group.getName());
            final List<RealmProperty> props = new ArrayList<RealmProperty>();
            final List<LdapQuery.Result> q = new ArrayList<LdapQuery.Result>();
            for (LdapQuery groupByNameQuery : groupByNameQueryList) {
                q.addAll(groupByNameQuery.query(ctx, params));
            }
            switch(q.size()) {
                case 0:
                    log.warn("Group \"" + group.getName() + "\" not found in LDAP.");
                    props.add(new RealmProperty("error", "NOT FOUND"));
                    break;
                case 1:
                    for (final String name : q.get(0).map().keySet()) {
                        props.add(new RealmProperty(name, q.get(0).get(name)));
                    }
                    Collections.sort(props, new Comparator<RealmProperty>() {

                        @Override
                        public int compare(final RealmProperty a, final RealmProperty b) {
                            int sort = classOf(a) - classOf(b);
                            if (sort == 0)
                                sort = a.getName().compareTo(b.getName());
                            return sort;
                        }

                        private int classOf(final RealmProperty p) {
                            final String n = p.getName();
                            if ("dn".equals(n) || "distinguishedName".equals(n))
                                return 0;
                            if ("cn".equals(n))
                                return 1;
                            return 5000;
                        }
                    });
                    break;
                default:
                    log.warn("Group \"" + group.getName() + "\" has multiple matches in LDAP: " + q);
                    props.add(new RealmProperty("error", "MULTIPLE MATCHES"));
                    break;
            }
            return props;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP directory for group " + group.getName(), e);
        return Collections.emptyList();
    }
}
#end_block

#method_before
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    final String username = who.getLocalUser();
    try {
        final DirContext ctx = open();
        try {
            final LdapQuery.Result m = findAccount(ctx, username);
            who.setDisplayName(m.get(accountFullName));
            who.setSshUserName(m.get(accountSshUserName));
            if (accountEmailAddress != null) {
                who.setEmailAddress(m.get(accountEmailAddress));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // Fill the cache with the user's current groups. We've already
            // spent the cost to open the LDAP connection, we might as well
            // do one more call to get their group membership. Since we are
            // in the middle of authenticating the user, its likely we will
            // need to know what access rights they have soon.
            // 
            membershipCache.put(username, queryForGroups(ctx, username, m));
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        throw new AccountException("Cannot query LDAP for account", e);
    }
}
#method_after
private void authenticate(String dn, String password) throws AccountException {
    final Properties env = new Properties();
    env.put(Context.INITIAL_CONTEXT_FACTORY, LDAP);
    env.put(Context.PROVIDER_URL, server);
    env.put(Context.SECURITY_PRINCIPAL, dn);
    env.put(Context.SECURITY_CREDENTIALS, password != null ? password : "");
    try {
        new InitialDirContext(env).close();
    } catch (NamingException e) {
        throw new AccountException("Incorrect username or password", e);
    }
}
#end_block

#method_before
@Override
public String toString() {
    String data = "";
    try {
        String.valueOf(atts.get("dn").get(0));
    } catch (NamingException e) {
    }
    return data;
}
#method_after
@Override
public String toString() {
    try {
        return getDN();
    } catch (NamingException e) {
        return "";
    }
}
#end_block

#method_before
public static String toProject(final Project.NameKey proj, Status status) {
    switch(status) {
        case ABANDONED:
            return "project,abandoned," + proj.toString() + ",n,z";
        case MERGED:
            return "project,merged," + proj.toString() + ",n,z";
        default:
            return "project,open," + proj.toString() + ",n,z";
    }
}
#method_after
public static String toProject(final Project.NameKey proj, Status status) {
    switch(status) {
        case ABANDONED:
            return "project,abandoned," + proj.toString() + ",n,z";
        case MERGED:
            return "project,merged," + proj.toString() + ",n,z";
        case NEW:
        case SUBMITTED:
        default:
            return "project,open," + proj.toString() + ",n,z";
    }
}
#end_block

#method_before
@Override
protected Screen createScreen() {
    switch(status) {
        case ABANDONED:
            return new ByProjectAbandonedChangesScreen(project, "n,z");
        case MERGED:
            return new ByProjectMergedChangesScreen(project, "n,z");
        default:
            return new ByProjectOpenChangesScreen(project, "n,z");
    }
}
#method_after
@Override
protected Screen createScreen() {
    switch(status) {
        case ABANDONED:
            return new ByProjectAbandonedChangesScreen(project, "n,z");
        case MERGED:
            return new ByProjectMergedChangesScreen(project, "n,z");
        case NEW:
        case SUBMITTED:
        default:
            return new ByProjectOpenChangesScreen(project, "n,z");
    }
}
#end_block

#method_before
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#method_after
public void onResponseReceived(final Request req, final Response rsp) {
    final int sc = rsp.getStatusCode();
    if (isJsonBody(rsp)) {
        final RpcResult r;
        try {
            r = parse(jsonParser, rsp.getText());
        } catch (RuntimeException e) {
            fireEvent(RpcCompleteEvent.e);
            callback.onFailure(new InvocationException("Bad JSON response: " + e));
            return;
        }
        if (r.xsrfKey() != null) {
            proxy.getXsrfManager().setToken(proxy, r.xsrfKey());
        }
        if (r.error() != null) {
            final String errmsg = r.error().message();
            if (JsonUtil.ERROR_INVALID_XSRF.equals(errmsg)) {
                if (attempts < 2) {
                    // The XSRF cookie was invalidated (or didn't exist) and the
                    // service demands we have one in place to make calls to it.
                    // A new token was returned to us, so start the request over.
                    // 
                    send();
                } else {
                    fireEvent(RpcCompleteEvent.e);
                    callback.onFailure(new InvocationException(errmsg));
                }
            } else {
                fireEvent(RpcCompleteEvent.e);
                callback.onFailure(new RemoteJsonException(errmsg, r.error().code(), new JSONObject(r.error()).get("error")));
            }
            return;
        }
        if (sc == Response.SC_OK) {
            fireEvent(RpcCompleteEvent.e);
            JsonUtil.invoke(resultDeserializer, callback, r);
            return;
        }
    }
    if (sc == Response.SC_OK) {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new InvocationException("No JSON response"));
    } else {
        fireEvent(RpcCompleteEvent.e);
        callback.onFailure(new StatusCodeException(sc, rsp.getStatusText()));
    }
}
#end_block

#method_before
public void strongestApprovals(final Change.Id id, final AsyncCallback<ApprovalDetail> callback) {
    run(callback, new Action<ApprovalDetail>() {

        public ApprovalDetail run(ReviewDb db) throws OrmException {
            final List<PatchSet> last_pset = db.patchSets().lastChange(id).toList();
            if (last_pset.isEmpty()) {
                return null;
            }
            final PatchSet.Id ps_id = last_pset.get(0).getId();
            final Map<ApprovalCategory.Id, PatchSetApproval> have = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
            for (PatchSetApproval a : db.patchSetApprovals().byPatchSet(ps_id)) {
                boolean keep = true;
                if (have.containsKey(a.getCategoryId())) {
                    final short oldValue = have.get(a.getCategoryId()).getValue();
                    final short newValue = a.getValue();
                    keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                }
                if (keep) {
                    have.put(a.getCategoryId(), a);
                }
            }
            final ApprovalDetail ad = new ApprovalDetail(getAccountId());
            for (PatchSetApproval a : have.values()) {
                ad.add(a);
            }
            return ad;
        }
    });
}
#method_after
public void strongestApprovals(final Set<Change.Id> cids, final AsyncCallback<ApprovalSummarySet> callback) {
    run(callback, new Action<ApprovalSummarySet>() {

        public ApprovalSummarySet run(ReviewDb db) throws OrmException {
            final Map<Change.Id, ApprovalSummary> approvals = new HashMap<Change.Id, ApprovalSummary>();
            final AccountInfoCacheFactory aicFactory = accountInfoCacheFactory.create();
            for (final Change.Id id : cids) {
                try {
                    final ChangeControl cc = changeControlFactory.validateFor(id);
                    final Change change = cc.getChange();
                    final PatchSet.Id ps_id = change.currentPatchSetId();
                    final Map<ApprovalCategory.Id, PatchSetApproval> psas = new HashMap<ApprovalCategory.Id, PatchSetApproval>();
                    final FunctionState fs = functionStateFactory.create(change, ps_id, psas.values());
                    for (PatchSetApproval ca : db.patchSetApprovals().byPatchSet(ps_id)) {
                        fs.normalize(approvalTypes.getApprovalType(ca.getCategoryId()), ca);
                        boolean keep = true;
                        if (psas.containsKey(ca.getCategoryId())) {
                            final short oldValue = psas.get(ca.getCategoryId()).getValue();
                            final short newValue = ca.getValue();
                            keep = (Math.abs(oldValue) < Math.abs(newValue)) || ((Math.abs(oldValue) == Math.abs(newValue) && (newValue < oldValue)));
                        }
                        if (keep) {
                            aicFactory.want(ca.getAccountId());
                            psas.put(ca.getCategoryId(), ca);
                        }
                    }
                    approvals.put(id, new ApprovalSummary(psas.values()));
                } catch (NoSuchChangeException nsce) {
                /* The user has no access to see this change, so we
             * simply do not provide any details about it.
             */
                }
            }
            return new ApprovalSummarySet(aicFactory.create(), approvals);
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable(true);
    byOwner = new ChangeTable.Section("", ChangeTable.ApprovalViewType.STRONGEST);
    forReview = new ChangeTable.Section("", ChangeTable.ApprovalViewType.MINE);
    closed = new ChangeTable.Section("", ChangeTable.ApprovalViewType.STRONGEST);
    table.addSection(byOwner);
    table.addSection(forReview);
    table.addSection(closed);
    add(table);
    table.setSavePointerId(Link.toAccountDashboard(ownerId));
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable(true);
    byOwner = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null);
    forReview = new ChangeTable.Section("", ApprovalViewType.USER, ownerId);
    closed = new ChangeTable.Section("", ApprovalViewType.STRONGEST, null);
    table.addSection(byOwner);
    table.addSection(forReview);
    table.addSection(closed);
    add(table);
    table.setSavePointerId(Link.toAccountDashboard(ownerId));
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, S_ICON_CELL);
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, S_DATA_CELL);
    }
    fmt.addStyleName(row, C_ID, S_C_ID);
    fmt.addStyleName(row, C_SUBJECT, S_C_SUBJECT);
    fmt.addStyleName(row, C_PROJECT, S_C_PROJECT);
    fmt.addStyleName(row, C_BRANCH, S_C_PROJECT);
    fmt.addStyleName(row, C_LAST_UPDATE, S_C_LAST_UPDATE);
    for (int i = BASE_COLUMNS; i < columns; i++) {
        fmt.addStyleName(row, i, "approvalscore");
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, S_ICON_CELL);
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, S_DATA_CELL);
    }
    fmt.addStyleName(row, C_ID, S_C_ID);
    fmt.addStyleName(row, C_SUBJECT, S_C_SUBJECT);
    fmt.addStyleName(row, C_PROJECT, S_C_PROJECT);
    fmt.addStyleName(row, C_BRANCH, S_C_PROJECT);
    fmt.addStyleName(row, C_LAST_UPDATE, S_C_LAST_UPDATE);
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, final ApprovalViewType viewType) {
    final String idstr = c.getKey().abbreviate();
    table.setWidget(row, C_ARROW, null);
    if (Gerrit.isSignedIn()) {
        setStar(row, c);
    }
    table.setWidget(row, C_ID, new TableChangeLink(idstr, c));
    String s = c.getSubject();
    if (s.length() > 80) {
        s = s.substring(0, 80);
    }
    if (c.getStatus() != null && c.getStatus() != Change.Status.NEW) {
        s += " (" + c.getStatus().name() + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(s, c));
    table.setWidget(row, C_OWNER, link(c.getOwner()));
    table.setWidget(row, C_PROJECT, new ProjectOpenLink(c.getProject().getKey()));
    table.setText(row, C_BRANCH, c.getBranch());
    table.setText(row, C_LAST_UPDATE, mediumFormat(c.getLastUpdatedOn()));
    switch(viewType) {
        case NONE:
            break;
        case MINE:
            PatchUtil.DETAIL_SVC.myApprovals(c.getId(), approvalFormatter(row));
            break;
        case STRONGEST:
            PatchUtil.DETAIL_SVC.strongestApprovals(c.getId(), approvalFormatter(row));
            break;
    }
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c) {
    final String idstr = c.getKey().abbreviate();
    table.setWidget(row, C_ARROW, null);
    if (Gerrit.isSignedIn()) {
        setStar(row, c);
    }
    table.setWidget(row, C_ID, new TableChangeLink(idstr, c));
    String s = c.getSubject();
    if (s.length() > 80) {
        s = s.substring(0, 80);
    }
    if (c.getStatus() != null && c.getStatus() != Change.Status.NEW) {
        s += " (" + c.getStatus().name() + ")";
    }
    table.setWidget(row, C_SUBJECT, new TableChangeLink(s, c));
    table.setWidget(row, C_OWNER, link(c.getOwner()));
    table.setWidget(row, C_PROJECT, new ProjectOpenLink(c.getProject().getKey()));
    table.setText(row, C_BRANCH, c.getBranch());
    table.setText(row, C_LAST_UPDATE, mediumFormat(c.getLastUpdatedOn()));
    setRowItem(row, c);
}
#end_block

#method_before
GerritCallback<ApprovalDetail> approvalFormatter(final int row) {
    return new GerritCallback<ApprovalDetail>() {

        @Override
        public void onSuccess(final ApprovalDetail detail) {
            final CellFormatter fmt = table.getCellFormatter();
            final Map<ApprovalCategory.Id, PatchSetApproval> am = detail.getApprovalMap();
            int col = BASE_COLUMNS;
            for (final ApprovalType type : approvalTypes) {
                final PatchSetApproval ca = am.get(type.getCategory().getId());
                if (ca == null || ca.getValue() == 0) {
                    table.clearCell(row, col);
                } else if (type.isMaxNegative(ca)) {
                    table.setWidget(row, col, Gerrit.ICONS.redNot().createImage());
                } else if (type.isMaxPositive(ca)) {
                    table.setWidget(row, col, Gerrit.ICONS.greenCheck().createImage());
                } else {
                    String vstr = String.valueOf(ca.getValue());
                    if (ca.getValue() > 0) {
                        vstr = "+" + vstr;
                        fmt.removeStyleName(row, col, "negscore");
                        fmt.addStyleName(row, col, "posscore");
                    } else {
                        fmt.addStyleName(row, col, "negscore");
                        fmt.removeStyleName(row, col, "posscore");
                    }
                    table.setText(row, col, vstr);
                }
                col++;
            }
        }
    };
}
#method_after
GerritCallback<ApprovalSummarySet> approvalFormatter(final int dataBegin, final int rows) {
    return new GerritCallback<ApprovalSummarySet>() {

        @Override
        public void onSuccess(final ApprovalSummarySet as) {
            Map<Change.Id, ApprovalSummary> ids = as.getSummaryMap();
            AccountInfoCache aic = as.getAccountInfoCache();
            for (int row = dataBegin; row < dataBegin + rows; row++) {
                final ChangeInfo c = getRowItem(row);
                if (ids.containsKey(c.getId())) {
                    displayApprovals(row, ids.get(c.getId()), aic);
                }
            }
        }
    };
}
#end_block

#method_before
public void display(final List<ChangeInfo> changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    }
    if (sz == 0) {
        if (hadData) {
            parent.insertNoneRow(dataBegin);
        }
    } else {
        if (!hadData) {
            parent.removeRow(dataBegin);
        }
        while (rows < sz) {
            parent.insertChangeRow(dataBegin + rows);
            rows++;
        }
        for (int i = 0; i < sz; i++) {
            parent.populateChangeRow(dataBegin + i, changeList.get(i), viewType);
        }
    }
}
#method_after
public void display(final List<ChangeInfo> changeList) {
    final int sz = changeList != null ? changeList.size() : 0;
    final boolean hadData = rows > 0;
    if (hadData) {
        while (sz < rows) {
            parent.removeRow(dataBegin);
            rows--;
        }
    }
    if (sz == 0) {
        if (hadData) {
            parent.insertNoneRow(dataBegin);
        }
    } else {
        Set<Change.Id> cids = new HashSet<Change.Id>();
        if (!hadData) {
            parent.removeRow(dataBegin);
        }
        while (rows < sz) {
            parent.insertChangeRow(dataBegin + rows);
            rows++;
        }
        for (int i = 0; i < sz; i++) {
            ChangeInfo c = changeList.get(i);
            parent.populateChangeRow(dataBegin + i, c);
            cids.add(c.getId());
        }
        switch(viewType) {
            case NONE:
                break;
            case USER:
                PatchUtil.DETAIL_SVC.userApprovals(cids, ownerId, parent.approvalFormatter(dataBegin, rows));
                break;
            case STRONGEST:
                PatchUtil.DETAIL_SVC.strongestApprovals(cids, parent.approvalFormatter(dataBegin, rows));
                break;
        }
    }
}
#end_block

#method_before
protected final CmdLineParser newCmdLineParserInstance(final Object bean) {
    Field f = null;
    ApproveCmdLineParser parser = new ApproveCmdLineParser(bean);
    try {
        f = CmdOption.class.getField("value");
        for (CmdOption c : optionList) {
            parser.addOption(new FieldSetter(c, f), c);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return parser;
}
#method_after
protected final CmdLineParser newCmdLineParserInstance(final Object bean) {
    CmdLineParser parser = new CmdLineParser(bean);
    for (CmdOption c : optionList) {
        parser.addOption(c, c);
    }
    return parser;
}
#end_block

#method_before
@Override
public final void start() throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            getApprovalNames();
            parseCommandLine();
            PrintWriter p = toPrintWriter(out);
            validateParameters();
            try {
                final Transaction txn = db.beginTransaction();
                final Change.Id cid = new Change.Id(changeId);
                final Change c = db.changes().get(cid);
                StringBuffer sb = new StringBuffer();
                sb.append("Patch Set: ");
                sb.append(c.currentPatchSetId().get());
                sb.append(" ");
                for (CmdOption co : optionList) {
                    String message = "";
                    Short score = co.value();
                    ApprovalCategory.Id category = new ApprovalCategory.Id(co.approvalKey());
                    if (co.value() != null) {
                        addApproval(c, category, co.value(), txn);
                    } else {
                        PatchSetApproval.Key psaKey = new PatchSetApproval.Key(c.currentPatchSetId(), currentUser.getAccountId(), category);
                        PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
                        if (psa == null) {
                            score = null;
                        } else {
                            score = psa.getValue();
                        }
                    }
                    if (score != null) {
                        message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
                    }
                    sb.append(" " + message + ";");
                }
                sb.deleteCharAt(sb.length() - 1);
                sb.append("\n\n");
                if (changeComment != null) {
                    sb.append(changeComment);
                }
                String uuid = ChangeUtil.messageUUID(db);
                ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(cid, uuid), currentUser.getAccountId());
                cm.setMessage(sb.toString());
                db.changeMessages().insert(Collections.singleton(cm), txn);
                ChangeUtil.updated(c);
                db.changes().update(Collections.singleton(c), txn);
                txn.commit();
                sendMail(c, c.currentPatchSetId(), cm);
                p.print(sb.toString() + "\n");
                p.flush();
            } catch (OrmException e) {
                throw new Failure(CMD_ERR, "Error accessing the database\n" + "Detailed message:\n" + e.getMessage());
            } catch (EmailException e) {
                throw new Failure(CMD_ERR, "Error when trying to send email\n" + "Detailed message:\n" + e.getMessage());
            } catch (Exception e) {
                throw new Failure(CMD_ERR, "Received an error\n" + "Detailed message:\n" + e.getMessage());
            }
        }
    });
}
#method_after
@Override
public final void start() throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            getApprovalNames();
            parseCommandLine();
            final Transaction txn = db.beginTransaction();
            final PatchSet ps = db.patchSets().get(patchSetId);
            if (ps == null) {
                throw new UnloggedFailure(CMD_ERR, "Invalid patchset id");
            }
            final Change.Id cid = ps.getId().getParentKey();
            final ChangeControl control = changeControlFactory.validateFor(cid);
            final Change c = control.getChange();
            if (c.getStatus().isClosed()) {
                throw new UnloggedFailure(CMD_ERR, "Change is closed.");
            }
            StringBuffer sb = new StringBuffer();
            sb.append("Patch Set ");
            sb.append(patchSetId.get());
            sb.append(": ");
            for (CmdOption co : optionList) {
                ApprovalCategory.Id category = new ApprovalCategory.Id(co.approvalKey());
                PatchSetApproval.Key psaKey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), category);
                PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
                Short score = co.value();
                if (score != null) {
                    addApproval(psaKey, score, c, co, txn);
                } else {
                    if (psa == null) {
                        score = 0;
                        addApproval(psaKey, score, c, co, txn);
                    } else {
                        score = psa.getValue();
                    }
                }
                String message = db.approvalCategoryValues().get(new ApprovalCategoryValue.Id(category, score)).getName();
                sb.append(" " + message + ";");
            }
            sb.deleteCharAt(sb.length() - 1);
            sb.append("\n\n");
            if (changeComment != null) {
                sb.append(changeComment);
            }
            String uuid = ChangeUtil.messageUUID(db);
            ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(cid, uuid), currentUser.getAccountId());
            cm.setMessage(sb.toString());
            db.changeMessages().insert(Collections.singleton(cm), txn);
            ChangeUtil.updated(c);
            db.changes().update(Collections.singleton(c), txn);
            txn.commit();
            sendMail(c, c.currentPatchSetId(), cm);
        }
    });
}
#end_block

#method_before
private void addApproval(final Change c, final ApprovalCategory.Id cat, final short score, final Transaction txn) throws OrmException {
    PatchSetApproval.Key psaKey = new PatchSetApproval.Key(c.currentPatchSetId(), currentUser.getAccountId(), cat);
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    if (psa == null) {
        psa = new PatchSetApproval(psaKey, score);
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        psa.setGranted();
        psa.setValue(score);
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#method_after
private void addApproval(final PatchSetApproval.Key psaKey, final Short score, final Change c, final CmdOption co, final Transaction txn) throws OrmException, UnloggedFailure {
    PatchSetApproval psa = db.patchSetApprovals().get(psaKey);
    boolean insert = false;
    if (psa == null) {
        insert = true;
        psa = new PatchSetApproval(psaKey, score);
    }
    final List<PatchSetApproval> approvals = Collections.emptyList();
    final FunctionState fs = functionStateFactory.create(c, patchSetId, approvals);
    psa.setValue(score);
    fs.normalize(approvalTypes.getApprovalType(psa.getCategoryId()), psa);
    if (score != psa.getValue()) {
        throw new UnloggedFailure(CMD_ERR, co.name() + "=" + co.value() + " not permitted");
    }
    psa.setGranted();
    if (insert) {
        db.patchSetApprovals().insert(Collections.singleton(psa), txn);
    } else {
        db.patchSetApprovals().update(Collections.singleton(psa), txn);
    }
}
#end_block

#method_before
private void getApprovalNames() throws OrmException {
    SortedMap<Short, String> acvMap = new TreeMap<Short, String>();
    optionList = new ArrayList<CmdOption>();
    ResultSet<ApprovalCategory> rs = db.approvalCategories().all();
    for (ApprovalCategory c : rs) {
        if (c.getFunctionName().equals("MaxWithBlock")) {
            ResultSet<ApprovalCategoryValue> acvrs = db.approvalCategoryValues().byCategory(c.getId());
            short min = Short.MAX_VALUE;
            short max = Short.MIN_VALUE;
            String usage = "";
            for (ApprovalCategoryValue acv : acvrs) {
                if (min > acv.getValue()) {
                    min = acv.getValue();
                }
                if (max < acv.getValue()) {
                    max = acv.getValue();
                }
                acvMap.put(acv.getValue(), acv.getName());
            }
            usage += "Score for " + c.getName() + "\n";
            // This is to make sure that the values are in sorted order.
            Iterator<Short> i = acvMap.keySet().iterator();
            while (i.hasNext()) {
                Short key = i.next();
                usage += String.format("%4d", key) + "  -  " + acvMap.get(key) + "\n";
            }
            optionList.add(new CmdOption("--" + c.getName().toLowerCase().replace(' ', '-'), usage, c.getId().get(), min, max, c.getName()));
            usage = "";
            acvMap.clear();
        }
    }
}
#method_after
private void getApprovalNames() throws OrmException {
    optionList = new ArrayList<CmdOption>();
    for (ApprovalType type : approvalTypes.getApprovalTypes()) {
        String usage = "";
        final ApprovalCategory category = type.getCategory();
        usage = "Score for " + category.getName() + "\n";
        for (ApprovalCategoryValue v : type.getValues()) {
            usage += String.format("%4d", v.getValue()) + "  -  " + v.getName() + "\n";
        }
        optionList.add(new CmdOption("--" + category.getName().toLowerCase().replace(' ', '-'), usage, category.getId().get(), type.getMin().getValue(), type.getMax().getValue(), category.getName()));
    }
}
#end_block

#method_before
private void createContext(final Grid parent, final int row, final int col) {
    parent.resizeRows(row + 1);
    // Show full files
    final CheckBox cb = new CheckBox(PatchUtil.C.showFullFiles());
    cb.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (event.getValue()) {
                // Show a diff of the full files
                scriptSettings.setContext(WHOLE_FILE_CONTEXT);
            } else {
                // Restore the context lines to the user's preference
                initContextLines();
            }
            refresh(false);
        }
    });
    parent.setWidget(row, col + 1, cb);
    // Keep unreviewed
    if (Gerrit.isSignedIn()) {
        final CheckBox ku = new CheckBox(PatchUtil.C.keepUnreviewed());
        ku.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

            @Override
            public void onValueChange(ValueChangeEvent<Boolean> event) {
                updateReviewedStatus(event.getValue() ? 0 : 1);
            }
        });
        parent.setWidget(row, col + 2, ku);
    }
}
#method_after
private void createContext(final Grid parent, final int row, final int col) {
    parent.resizeRows(row + 1);
    // Show full files
    final CheckBox cb = new CheckBox(PatchUtil.C.showFullFiles());
    cb.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (event.getValue()) {
                // Show a diff of the full files
                scriptSettings.setContext(WHOLE_FILE_CONTEXT);
            } else {
                // Restore the context lines to the user's preference
                initContextLines();
            }
            refresh(false);
        }
    });
    parent.setWidget(row, col + 1, cb);
    // "Reviewed" check box
    if (Gerrit.isSignedIn()) {
        final CheckBox ku = new CheckBox(PatchUtil.C.reviewed());
        ku.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

            @Override
            public void onValueChange(ValueChangeEvent<Boolean> event) {
                setReviewedByCurrentUser(event.getValue());
            }
        });
        // Checked by default
        ku.setValue(true);
        parent.setWidget(row, col + 2, ku);
    }
}
#end_block

#method_before
private Widget createNextPrevLinks() {
    final Grid table = new Grid(1, 3);
    final CellFormatter fmt = table.getCellFormatter();
    table.setStyleName("gerrit-SideBySideScreen-LinkTable");
    fmt.setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT);
    fmt.setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_CENTER);
    fmt.setHorizontalAlignment(0, 2, HasHorizontalAlignment.ALIGN_RIGHT);
    // Next and previous
    if (fileList != null) {
        previousFileLink = fileList.getPreviousPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 0, previousFileLink);
        nextFileLink = fileList.getNextPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 2, nextFileLink);
    }
    // Keep unreviewed
    // Up
    final ChangeLink up = new ChangeLink("", patchKey.getParentKey().getParentKey());
    SafeHtml.set(up, SafeHtml.asis(Util.C.upToChangeIconLink()));
    table.setWidget(0, 1, up);
    return table;
}
#method_after
private Widget createNextPrevLinks() {
    final Grid table = new Grid(1, 3);
    final CellFormatter fmt = table.getCellFormatter();
    table.setStyleName("gerrit-SideBySideScreen-LinkTable");
    fmt.setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT);
    fmt.setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_CENTER);
    fmt.setHorizontalAlignment(0, 2, HasHorizontalAlignment.ALIGN_RIGHT);
    if (fileList != null) {
        previousFileLink = fileList.getPreviousPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 0, previousFileLink);
        nextFileLink = fileList.getNextPatchLink(patchIndex, getPatchScreenType());
        table.setWidget(0, 2, nextFileLink);
    }
    final ChangeLink up = new ChangeLink("", patchKey.getParentKey().getParentKey());
    SafeHtml.set(up, SafeHtml.asis(Util.C.upToChangeIconLink()));
    table.setWidget(0, 1, up);
    return table;
}
#end_block

#method_before
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    // Mark this file reviewed
    if (Gerrit.isSignedIn()) {
        updateReviewedStatus(1);
    }
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                if (isNoDifferences(caught) && !isFirst) {
                    historyTable.enableAll(true);
                    showPatch(false);
                } else {
                    super.onFailure(caught);
                }
            }
        }

        private boolean isNoDifferences(final Throwable caught) {
            if (caught instanceof NoDifferencesException) {
                return true;
            }
            return caught instanceof RemoteJsonException && caught.getMessage().equals(NoDifferencesException.MESSAGE);
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#method_after
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    // Mark this file reviewed as soon we display the diff screen
    if (Gerrit.isSignedIn() && isFirst) {
        setReviewedByCurrentUser(true);
    }
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#end_block

#method_before
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        if (contentTable instanceof SideBySideTable && script.getEdits().isEmpty() && !script.getPatchHeader().isEmpty()) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#method_after
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        // True if there are differences between the two patch sets
        boolean hasEdits = !script.getEdits().isEmpty();
        // True if this change is a mode change or a pure rename/copy
        boolean hasMeta = !script.getPatchHeader().isEmpty();
        boolean hasDifferences = hasEdits || hasMeta;
        boolean pureMetaChange = !hasEdits && hasMeta;
        if (contentTable instanceof SideBySideTable && pureMetaChange) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        if (hasDifferences) {
            contentTable.display(patchKey, idSideA, idSideB, script);
            contentTable.display(comments);
            contentTable.finishDisplay();
        }
        showPatch(hasDifferences);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#end_block

#method_before
public void saveDraft(final PatchLineComment comment, final AsyncCallback<PatchLineComment> callback) {
    run(callback, new Action<PatchLineComment>() {

        public PatchLineComment run(ReviewDb db) throws OrmException, Failure {
            if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                throw new Failure(new IllegalStateException("Comment published"));
            }
            final Patch patch = db.patches().get(comment.getKey().getParentKey());
            final Change change;
            if (patch == null) {
                throw new Failure(new NoSuchEntityException());
            }
            change = db.changes().get(patch.getKey().getParentKey().getParentKey());
            assertCanRead(change);
            final Account.Id me = Common.getAccountId();
            if (comment.getKey().get() == null) {
                final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patch.getKey(), ChangeUtil.messageUUID(db)), comment.getLine(), me);
                nc.setSide(comment.getSide());
                nc.setMessage(comment.getMessage());
                db.patchComments().insert(Collections.singleton(nc));
                return nc;
            } else {
                if (!me.equals(comment.getAuthor())) {
                    throw new Failure(new NoSuchEntityException());
                }
                comment.updated();
                db.patchComments().update(Collections.singleton(comment));
                return comment;
            }
        }
    });
}
#method_after
public void saveDraft(final PatchLineComment comment, final AsyncCallback<PatchLineComment> callback) {
    run(callback, new Action<PatchLineComment>() {

        public PatchLineComment run(ReviewDb db) throws OrmException, Failure {
            if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
                throw new Failure(new IllegalStateException("Comment published"));
            }
            final Patch patch = db.patches().get(comment.getKey().getParentKey());
            final Change change;
            if (patch == null) {
                throw new Failure(new NoSuchEntityException());
            }
            change = db.changes().get(patch.getKey().getParentKey().getParentKey());
            assertCanRead(change);
            final Account.Id me = Common.getAccountId();
            if (comment.getKey().get() == null) {
                final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patch.getKey(), ChangeUtil.messageUUID(db)), comment.getLine(), me, comment.getParentUuid());
                nc.setSide(comment.getSide());
                nc.setMessage(comment.getMessage());
                db.patchComments().insert(Collections.singleton(nc));
                return nc;
            } else {
                if (!me.equals(comment.getAuthor())) {
                    throw new Failure(new NoSuchEntityException());
                }
                comment.updated();
                db.patchComments().update(Collections.singleton(comment));
                return comment;
            }
        }
    });
}
#end_block

#method_before
void appendRow(final SafeHtmlBuilder m, final Patch p) {
    m.openTr();
    m.openTd();
    m.addStyleName(S_ICON_CELL);
    m.addStyleName("LeftMostCell");
    m.nbsp();
    m.closeTd();
    m.openTd();
    m.setStyleName("ChangeTypeCell");
    m.append(p.getChangeType().getCode());
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("FilePathCell");
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("CommentCell");
    appendCommentCount(m, p);
    m.closeTd();
    switch(p.getPatchType()) {
        case UNIFIED:
            openlink(m, 2);
            m.closeTd();
            break;
        case BINARY:
            {
                String base = GWT.getHostPageBaseURL();
                base += "cat/" + KeyUtil.encode(p.getKey().toString());
                switch(p.getChangeType()) {
                    case DELETED:
                    case MODIFIED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^1");
                        m.append(Util.C.patchTableDownloadPreImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                switch(p.getChangeType()) {
                    case MODIFIED:
                    case ADDED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^0");
                        m.append(Util.C.patchTableDownloadPostImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                break;
            }
        default:
            emptycell(m, 2);
            break;
    }
    openlink(m, 1);
    m.closeTd();
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(S_DATA_CELL);
        if (Gerrit.isSignedIn() && p.hasBeenReviewedBy(Gerrit.getUserAccount().getSshUserName())) {
            m.append(SafeHtml.asis(Gerrit.ICONS.greenCheck().getHTML()));
        } else {
            m.nbsp();
        }
        m.closeTd();
    }
    m.closeTr();
}
#method_after
void appendRow(final SafeHtmlBuilder m, final Patch p) {
    m.openTr();
    m.openTd();
    m.addStyleName(S_ICON_CELL);
    m.addStyleName("LeftMostCell");
    m.nbsp();
    m.closeTd();
    m.openTd();
    m.setStyleName("ChangeTypeCell");
    m.append(p.getChangeType().getCode());
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("FilePathCell");
    m.closeTd();
    m.openTd();
    m.addStyleName(S_DATA_CELL);
    m.addStyleName("CommentCell");
    appendCommentCount(m, p);
    m.closeTd();
    switch(p.getPatchType()) {
        case UNIFIED:
            openlink(m, 2);
            m.closeTd();
            break;
        case BINARY:
            {
                String base = GWT.getHostPageBaseURL();
                base += "cat/" + KeyUtil.encode(p.getKey().toString());
                switch(p.getChangeType()) {
                    case DELETED:
                    case MODIFIED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^1");
                        m.append(Util.C.patchTableDownloadPreImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                switch(p.getChangeType()) {
                    case MODIFIED:
                    case ADDED:
                        openlink(m, 1);
                        m.openAnchor();
                        m.setAttribute("href", base + "^0");
                        m.append(Util.C.patchTableDownloadPostImage());
                        closelink(m);
                        break;
                    default:
                        emptycell(m, 1);
                        break;
                }
                break;
            }
        default:
            emptycell(m, 2);
            break;
    }
    openlink(m, 1);
    m.closeTd();
    // Green check mark if the user is logged in and they reviewed that file
    if (Gerrit.isSignedIn()) {
        m.openTd();
        m.setStyleName(S_DATA_CELL);
        if (p.isReviewedByCurrentUser()) {
            m.append(SafeHtml.asis(Gerrit.ICONS.greenCheck().getHTML()));
        } else {
            m.nbsp();
        }
        m.closeTd();
    }
    m.closeTr();
}
#end_block

#method_before
@Override
protected void render(final PatchScript script) {
    final SparseFileContent a = script.getA();
    final SparseFileContent b = script.getB();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    if (directUrlLeft != null || directUrlRight != null) {
        // The left url can be null if a file is being added and the right url can be null if a
        // file is being deleted. They will both be non-null if this change is modifying an existing
        // file.
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("halign", "center");
        nc.openTd();
        maybeAppendImgTag(nc, directUrlLeft);
        nc.closeTd();
        nc.openTd();
        maybeAppendImgTag(nc, directUrlRight);
        nc.closeTd();
        nc.closeTr();
    } else {
        // result
        for (final String line : script.getPatchHeader()) {
            appendFileHeader(nc, line);
        }
    }
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final PatchScript.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.hasNextLine()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                padLineNumber(nc);
                appendLineText(nc, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                if (a.size() == hunk.getCurA() && a.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumber(nc);
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && b.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            }
            hunk.next();
        }
    }
    resetHtml(nc);
    onlyOneHunk = script.getEdits().size() == 1;
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n = "DiffText-" + l.getType().name();
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#method_after
@Override
protected void render(final PatchScript script) {
    final SparseFileContent a = script.getA();
    final SparseFileContent b = script.getB();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    // Display the patch header
    for (final String line : script.getPatchHeader()) {
        appendFileHeader(nc, line);
    }
    if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String rawBase = GWT.getHostPageBaseURL() + "cat/";
        nc.openTr();
        nc.setAttribute("valign", "center");
        nc.setAttribute("align", "center");
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        nc.nbsp();
        nc.closeTd();
        nc.openTd();
        if (script.getDisplayMethodA() == DisplayMethod.IMG) {
            if (idSideA == null) {
                Patch.Key k = new Patch.Key(idSideA, patchKey.get());
                appendImgTag(nc, rawBase + KeyUtil.encode(k.toString()) + "^0");
            } else {
                appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^1");
            }
        }
        if (script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImgTag(nc, rawBase + KeyUtil.encode(patchKey.toString()) + "^0");
        }
        nc.closeTd();
        nc.closeTr();
    }
    final ArrayList<PatchLine> lines = new ArrayList<PatchLine>();
    for (final PatchScript.Hunk hunk : script.getHunks()) {
        appendHunkHeader(nc, hunk);
        while (hunk.hasNextLine()) {
            if (hunk.isContextLine()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, CONTEXT, a, hunk.getCurA());
                closeLine(nc);
                hunk.incBoth();
                lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
            } else if (hunk.isDeletedA()) {
                openLine(nc);
                appendLineNumber(nc, hunk.getCurA());
                padLineNumber(nc);
                appendLineText(nc, DELETE, a, hunk.getCurA());
                closeLine(nc);
                hunk.incA();
                lines.add(new PatchLine(DELETE, hunk.getCurA(), 0));
                if (a.size() == hunk.getCurA() && a.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            } else if (hunk.isInsertedB()) {
                openLine(nc);
                padLineNumber(nc);
                appendLineNumber(nc, hunk.getCurB());
                appendLineText(nc, INSERT, b, hunk.getCurB());
                closeLine(nc);
                hunk.incB();
                lines.add(new PatchLine(INSERT, 0, hunk.getCurB()));
                if (b.size() == hunk.getCurB() && b.isMissingNewlineAtEnd())
                    appendNoLF(nc);
            }
            hunk.next();
        }
    }
    resetHtml(nc);
    initScript(script);
    int row = script.getPatchHeader().size();
    final CellFormatter fmt = table.getCellFormatter();
    final Iterator<PatchLine> iLine = lines.iterator();
    while (iLine.hasNext()) {
        final PatchLine l = iLine.next();
        final String n = "DiffText-" + l.getType().name();
        while (!fmt.getStyleName(row, PC).contains(n)) {
            row++;
        }
        setRowItem(row++, l);
    }
}
#end_block

#method_before
private void appendLineText(final SafeHtmlBuilder m, final PatchLine.Type type, final SparseFileContent src, final int i) {
    final int len = PatchUtil.DEFAULT_LINE_LENGTH;
    final String text = src.get(i);
    m.openTd();
    m.addStyleName("DiffText");
    m.addStyleName("DiffText-" + type.name());
    switch(type) {
        case CONTEXT:
            if ("".equals(text)) {
                m.nbsp();
            } else {
                m.append(" ");
                m.append(PatchUtil.lineToSafeHtml(text, len, false));
            }
            break;
        case DELETE:
            m.append("-");
            m.append(PatchUtil.lineToSafeHtml(text, len, false));
            break;
        case INSERT:
            m.append("+");
            m.append(PatchUtil.lineToSafeHtml(text, len, true));
            break;
    }
    m.closeTd();
}
#method_after
private void appendLineText(final SafeHtmlBuilder m, final PatchLine.Type type, final SparseFileContent src, final int i) {
    final int len = PatchUtil.DEFAULT_LINE_LENGTH;
    final String text = src.get(i);
    m.openTd();
    m.addStyleName("DiffText");
    m.addStyleName("DiffText-" + type.name());
    switch(type) {
        case CONTEXT:
            m.nbsp();
            break;
        case DELETE:
            m.append("-");
            break;
        case INSERT:
            m.append("+");
            break;
    }
    m.append(PatchUtil.lineToSafeHtml(text, len, false));
    m.closeTd();
}
#end_block

#method_before
private void openLine(final SafeHtmlBuilder m) {
    m.openTr();
    m.setAttribute("valign", "top");
    m.openTd();
    m.setStyleName(S_ICON_CELL);
    m.nbsp();
    m.closeTd();
}
#method_after
private void openLine(final SafeHtmlBuilder m) {
    m.openTr();
    m.setAttribute("valign", "top");
    m.openTd();
    m.setStyleName(S_ICON_CELL);
    m.closeTd();
}
#end_block

#method_before
private void padLineNumber(final SafeHtmlBuilder m) {
    m.openTd();
    m.setStyleName("LineNumber");
    m.nbsp();
    m.closeTd();
}
#method_after
private void padLineNumber(final SafeHtmlBuilder m) {
    m.openTd();
    m.setStyleName("LineNumber");
    m.closeTd();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either side,
    // expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null);
    add(historyPanel);
    initDisplayControls();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    contentPanel = new FlowPanel();
    contentPanel.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(createNextPrevLinks());
    // This must be done after calling createNextPrevLinks(), which initializes these fields
    if (previousFileLink != null) {
        installLinkShortCut(previousFileLink, SHORTCUT_PREVIOUS_FILE, PatchUtil.C.previousFileHelp());
    }
    if (nextFileLink != null) {
        installLinkShortCut(nextFileLink, SHORTCUT_NEXT_FILE, PatchUtil.C.nextFileHelp());
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new FileListCmd(0, 'f', PatchUtil.C.fileList()));
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    // If the user selected a different patch set than the default for either side,
    // expand the history panel
    historyPanel.setOpen(diffSideA != null || diffSideB != null);
    add(historyPanel);
    initDisplayControls();
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    contentPanel = new FlowPanel();
    contentPanel.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    contentPanel.add(noDifference);
    contentPanel.add(contentTable);
    add(contentPanel);
    add(createNextPrevLinks());
    // This must be done after calling createNextPrevLinks(), which initializes these fields
    if (previousFileLink != null) {
        installLinkShortCut(previousFileLink, SHORTCUT_PREVIOUS_FILE, PatchUtil.C.previousFileHelp());
    }
    if (nextFileLink != null) {
        installLinkShortCut(nextFileLink, SHORTCUT_NEXT_FILE, PatchUtil.C.nextFileHelp());
    }
}
#end_block

#method_before
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                if (caught instanceof RemoteJsonException && !isFirst) {
                    historyTable.enableAll(true);
                    showPatch(false);
                } else {
                    super.onFailure(caught);
                }
            }
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#method_after
protected void refresh(final boolean isFirst) {
    final int rpcseq = ++rpcSequence;
    script = null;
    comments = null;
    PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new GerritCallback<PatchScript>() {

        public void onSuccess(final PatchScript result) {
            if (rpcSequence == rpcseq) {
                script = result;
                onResult();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
    PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new GerritCallback<CommentDetail>() {

        public void onSuccess(final CommentDetail result) {
            if (rpcSequence == rpcseq) {
                comments = result;
                onResult();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // 
            if (!isNoSuchEntity(caught) && rpcSequence == rpcseq) {
                super.onFailure(caught);
            }
        }
    });
}
#end_block

#method_before
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        if (contentTable instanceof SideBySideTable && script.getEdits().isEmpty() && !script.getPatchHeader().isEmpty()) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#method_after
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        // True if there are differences between the two patch sets
        boolean hasEdits = !script.getEdits().isEmpty();
        // True if this change is a mode change or a pure rename/copy
        boolean hasMeta = !script.getPatchHeader().isEmpty();
        boolean hasDifferences = hasEdits || hasMeta;
        boolean pureMetaChange = !hasEdits && hasMeta;
        if (contentTable instanceof SideBySideTable && pureMetaChange) {
            // User asked for SideBySide (or a link guessed, wrong) and we can't
            // show a binary or pure-rename change there accurately. Switch to
            // the unified view instead.
            // 
            contentTable.removeFromParent();
            contentTable = new UnifiedDiffTable();
            contentTable.fileList = fileList;
            contentPanel.add(contentTable);
            History.newItem(Link.toPatchUnified(patchKey), false);
        }
        if (hasDifferences) {
            contentTable.display(patchKey, idSideA, idSideB, script);
            contentTable.display(comments);
            contentTable.finishDisplay();
        }
        showPatch(hasDifferences);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#end_block

#method_before
private ResultSet<Change> searchQuery(final ReviewDb db, String query, final int limit, final String key, final Comparator<Change> cmp) throws OrmException {
    final HashSet<Change.Id> want = new HashSet<Change.Id>();
    query = query.trim();
    if (query.matches("^[1-9][0-9]*$")) {
        want.add(Change.Id.parse(query));
    } else if (query.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        final RevId id = new RevId(query);
        final ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        for (PatchSet p : patches) {
            want.add(p.getId().getParentKey());
        }
    }
    if (want.isEmpty()) {
        return new ListResultSet<Change>(Collections.<Change>emptyList());
    }
    List<Change> result = new ArrayList<Change>();
    final ResultSet<Change> rs = db.changes().get(want);
    if (cmp == QUERY_PREV) {
        for (Change c : rs) {
            if (c.getSortKey().compareTo(key) > 0) {
                result.add(c);
            }
        }
    } else /* cmp == QUERY_NEXT */
    {
        for (Change c : rs) {
            if (c.getSortKey().compareTo(key) < 0) {
                result.add(c);
            }
        }
    }
    Collections.sort(result, cmp);
    if (limit < result.size()) {
        // GWT emulation unfortunately lacks subList(int,int).
        // 
        final List<Change> r = new ArrayList<Change>(limit);
        for (int i = 0; i < limit; i++) {
            r.add(result.get(i));
        }
        result = r;
    }
    return new ListResultSet<Change>(result);
}
#method_after
private ResultSet<Change> searchQuery(final ReviewDb db, String query, final int limit, final String key, final Comparator<Change> cmp) throws OrmException {
    List<Change> result = new ArrayList<Change>();
    final HashSet<Change.Id> want = new HashSet<Change.Id>();
    query = query.trim();
    if (query.matches("^[1-9][0-9]*$")) {
        want.add(Change.Id.parse(query));
    } else if (query.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        final RevId id = new RevId(query);
        final ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        for (PatchSet p : patches) {
            want.add(p.getId().getParentKey());
        }
    } else if (query.contains("owner:")) {
        String[] parsedQuery = query.split(":");
        if (parsedQuery.length > 1) {
            filterBySortKey(result, changesCreatedBy(db, parsedQuery[1]), cmp, key);
        }
    } else if (query.contains("reviewer:")) {
        String[] parsedQuery = query.split(":");
        if (parsedQuery.length > 1) {
            want.addAll(changesReviewedBy(db, parsedQuery[1]));
        }
    }
    if (result.isEmpty() && want.isEmpty()) {
        return new ListResultSet<Change>(Collections.<Change>emptyList());
    }
    filterBySortKey(result, db.changes().get(want), cmp, key);
    Collections.sort(result, cmp);
    if (limit < result.size()) {
        // GWT emulation unfortunately lacks subList(int,int).
        // 
        final List<Change> r = new ArrayList<Change>(limit);
        for (int i = 0; i < limit; i++) {
            r.add(result.get(i));
        }
        result = r;
    }
    return new ListResultSet<Change>(result);
}
#end_block

#method_before
public void changesCreatedBy(final String userName, final AsyncCallback<SingleListChangeInfo> callback) {
    run(callback, new UserNameAction(userName) {

        @Override
        void process(ReviewDb db, AccountInfoCacheFactory ac, Account account, Map<Id, Change> resultChanges) throws OrmException {
            final Set<Change> changes = createdBy(db, account.getId());
            ac.want(account.getId());
            for (Change change : changes) {
                resultChanges.put(change.getId(), change);
            }
        }
    });
}
#method_after
private List<Change> changesCreatedBy(final ReviewDb db, final String userName) throws OrmException {
    final List<Change> resultChanges = new ArrayList<Change>();
    for (Account.Id account : getAccountSources(db, userName)) {
        for (Change change : db.changes().byOwnerOpen(account)) {
            resultChanges.add(change);
        }
        for (Change change : db.changes().byOwnerClosedAll(account)) {
            resultChanges.add(change);
        }
    }
    return resultChanges;
}
#end_block

#method_before
// 
// UserNameAction
// ///
public void changesReviewedBy(final String userName, final AsyncCallback<SingleListChangeInfo> callback) {
    run(callback, new UserNameAction(userName) {

        @Override
        void process(ReviewDb db, AccountInfoCacheFactory ac, Account account, Map<Id, Change> outResultChanges) throws OrmException {
            ChangeApprovalAccess changes = db.changeApprovals();
            ChangeAccess changeAccess = db.changes();
            Iterator<ChangeApproval> changeIterator = changes.reviewedByUser(account.getId()).iterator();
            while (changeIterator.hasNext()) {
                ChangeApproval approval = changeIterator.next();
                Change change = changeAccess.get(approval.getChangeId());
                // This will return null if the change was submitted
                if (change != null) {
                    outResultChanges.put(change.getId(), change);
                }
            }
        }
    });
}
#method_after
private Set<Change.Id> changesReviewedBy(final ReviewDb db, final String userName) throws OrmException {
    final Set<Change.Id> resultChanges = new HashSet<Change.Id>();
    for (Account.Id account : getAccountSources(db, userName)) {
        for (ChangeApproval a : db.changeApprovals().openByUser(account)) {
            resultChanges.add(a.getChangeId());
        }
        for (ChangeApproval a : db.changeApprovals().closedByUserAll(account)) {
            resultChanges.add(a.getChangeId());
        }
    }
    return resultChanges;
}
#end_block

#method_before
public void display(final PatchSet.Id id, final List<Patch> list) {
    psid = id;
    myTable = null;
    final DisplayCommand cmd = new DisplayCommand(list);
    if (cmd.execute()) {
        cmd.initMeter();
        DeferredCommand.addCommand(cmd);
    } else {
        cmd.showTable();
    }
}
#method_after
public void display(final PatchSet.Id id, final List<Patch> list) {
    psid = id;
    myTable = null;
    patchList = list;
    final DisplayCommand cmd = new DisplayCommand(list);
    if (cmd.execute()) {
        cmd.initMeter();
        DeferredCommand.addCommand(cmd);
    } else {
        cmd.showTable();
    }
}
#end_block

#method_before
void initializeRow(List<Patch> patches, int row) {
    Patch patch = patches.get(row - 1);
    PatchSetKeys psk = new PatchSetKeys(patchesToKeys(patches), row - 1, PatchTable.this.psid.getParentKey());
    setRowItem(row, patch);
    Widget nameCol;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        nameCol = new PatchLink.SideBySide(patch.getFileName(), psk);
    } else {
        nameCol = new PatchLink.Unified(patch.getFileName(), psk);
    }
    if (patch.getSourceFileName() != null) {
        final String text;
        if (patch.getChangeType() == Patch.ChangeType.RENAMED) {
            text = Util.M.renamedFrom(patch.getSourceFileName());
        } else if (patch.getChangeType() == Patch.ChangeType.COPIED) {
            text = Util.M.copiedFrom(patch.getSourceFileName());
        } else {
            text = Util.M.otherFrom(patch.getSourceFileName());
        }
        final Label line = new Label(text);
        line.setStyleName("SourceFilePath");
        final FlowPanel cell = new FlowPanel();
        cell.add(nameCol);
        cell.add(line);
        nameCol = cell;
    }
    table.setWidget(row, C_PATH, nameCol);
    int C_UNIFIED = C_SIDEBYSIDE + 1;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        table.setWidget(row, C_SIDEBYSIDE, new PatchLink.SideBySide(Util.C.patchTableDiffSideBySide(), psk));
    } else if (patch.getPatchType() == Patch.PatchType.BINARY) {
        C_UNIFIED = C_SIDEBYSIDE + 2;
    }
    table.setWidget(row, C_UNIFIED, new PatchLink.Unified(Util.C.patchTableDiffUnified(), psk));
}
#method_after
void initializeRow(int row) {
    Patch patch = PatchTable.this.patchList.get(row - 1);
    setRowItem(row, patch);
    Widget nameCol;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        nameCol = new PatchLink.SideBySide(patch.getFileName(), patch.getKey(), row - 1, PatchTable.this);
    } else {
        nameCol = new PatchLink.Unified(patch.getFileName(), patch.getKey(), row - 1, PatchTable.this);
    }
    if (patch.getSourceFileName() != null) {
        final String text;
        if (patch.getChangeType() == Patch.ChangeType.RENAMED) {
            text = Util.M.renamedFrom(patch.getSourceFileName());
        } else if (patch.getChangeType() == Patch.ChangeType.COPIED) {
            text = Util.M.copiedFrom(patch.getSourceFileName());
        } else {
            text = Util.M.otherFrom(patch.getSourceFileName());
        }
        final Label line = new Label(text);
        line.setStyleName("SourceFilePath");
        final FlowPanel cell = new FlowPanel();
        cell.add(nameCol);
        cell.add(line);
        nameCol = cell;
    }
    table.setWidget(row, C_PATH, nameCol);
    int C_UNIFIED = C_SIDEBYSIDE + 1;
    if (patch.getPatchType() == Patch.PatchType.UNIFIED) {
        table.setWidget(row, C_SIDEBYSIDE, new PatchLink.SideBySide(Util.C.patchTableDiffSideBySide(), patch.getKey(), row - 1, PatchTable.this));
    } else if (patch.getPatchType() == Patch.PatchType.BINARY) {
        C_UNIFIED = C_SIDEBYSIDE + 2;
    }
    table.setWidget(row, C_UNIFIED, new PatchLink.Unified(Util.C.patchTableDiffUnified(), patch.getKey(), row - 1, PatchTable.this));
}
#end_block

#method_before
@SuppressWarnings("fallthrough")
public boolean execute() {
    final boolean attachedNow = isAttached();
    if (!attached && attachedNow) {
        // Remember that we have been attached at least once. If
        // later we find we aren't attached we should stop running.
        // 
        attached = true;
    } else if (attached && !attachedNow) {
        // 
        return false;
    }
    start = System.currentTimeMillis();
    switch(stage) {
        case 0:
            if (row == 0) {
                table.appendHeader(nc);
            }
            while (row < list.size()) {
                table.appendRow(nc, list.get(row));
                if ((++row % 10) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            table.resetHtml(nc);
            nc = null;
            stage = 1;
            row = 0;
        case 1:
            while (row < list.size()) {
                table.initializeRow(list, row + 1);
                if ((++row % 50) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            updateMeter();
            showTable();
    }
    return false;
}
#method_after
@SuppressWarnings("fallthrough")
public boolean execute() {
    final boolean attachedNow = isAttached();
    if (!attached && attachedNow) {
        // Remember that we have been attached at least once. If
        // later we find we aren't attached we should stop running.
        // 
        attached = true;
    } else if (attached && !attachedNow) {
        // 
        return false;
    }
    start = System.currentTimeMillis();
    switch(stage) {
        case 0:
            if (row == 0) {
                table.appendHeader(nc);
            }
            while (row < list.size()) {
                table.appendRow(nc, list.get(row));
                if ((++row % 10) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            table.resetHtml(nc);
            nc = null;
            stage = 1;
            row = 0;
        case 1:
            while (row < list.size()) {
                table.initializeRow(row + 1);
                if ((++row % 50) == 0 && longRunning()) {
                    updateMeter();
                    return true;
                }
            }
            updateMeter();
            showTable();
    }
    return false;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    add(historyPanel);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    fileList = null;
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    fp.add(noDifference);
    fp.add(contentTable);
    add(fp);
    // Links to the next/previous file
    FlexTable dp = new FlexTable();
    dp.setStyleName("gerrit-SideBySideScreen-LinkTable");
    dp.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT);
    dp.getFlexCellFormatter().setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_RIGHT);
    if (previousPatchLink != null)
        dp.setWidget(0, 0, previousPatchLink);
    if (nextPatchLink != null)
        dp.setWidget(0, 1, nextPatchLink);
    add(dp);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    final String path = patchKey.get();
    String fileName = path;
    final int last = fileName.lastIndexOf('/');
    if (last >= 0) {
        fileName = fileName.substring(last + 1);
    }
    setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName));
    setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path));
    historyTable = new HistoryTable(this);
    historyPanel = new DisclosurePanel(PatchUtil.C.patchHistoryTitle());
    historyPanel.setContent(historyTable);
    historyPanel.setOpen(false);
    historyPanel.setVisible(false);
    add(historyPanel);
    noDifference = new Label(PatchUtil.C.noDifference());
    noDifference.setStyleName("gerrit-PatchNoDifference");
    noDifference.setVisible(false);
    contentTable = createContentTable();
    contentTable.fileList = fileList;
    add(createNextPrevLinks());
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName("gerrit-SideBySideScreen-SideBySideTable");
    fp.add(noDifference);
    fp.add(contentTable);
    add(fp);
    add(createNextPrevLinks());
}
#end_block

#method_before
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        display();
    }
}
#method_after
private void onResult() {
    if (script != null && comments != null) {
        if (comments.getHistory().size() > 1) {
            historyTable.display(comments.getHistory());
            historyPanel.setVisible(true);
        } else {
            historyPanel.setVisible(false);
        }
        contentTable.display(patchKey, idSideA, idSideB, script);
        contentTable.display(comments);
        contentTable.finishDisplay();
        showPatch(true);
        script = null;
        comments = null;
        if (!isCurrentView()) {
            display();
        }
    }
}
#end_block

#method_before
@Override
protected Screen createScreen() {
    return new PatchScreen.SideBySide(patch.getKey(), patch, parentPatchTable());
}
#method_after
@Override
protected Screen createScreen() {
    return new PatchScreen.SideBySide(patchKey, patchIndex, parentPatchTable);
}
#end_block

#method_before
@Override
protected Screen createScreen() {
    return new PatchScreen.Unified(patch.getKey(), patch, parentPatchTable());
}
#method_after
@Override
protected Screen createScreen() {
    return new PatchScreen.Unified(patchKey, patchIndex, parentPatchTable);
}
#end_block

#method_before
private void display(final PatchSetPublishDetail r) {
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName("gerrit-PatchComments");
                draftsPanel.add(panel);
                panel.add(new PatchLink.SideBySide(fn, new PatchSetKeys(patchKey)));
                priorFile = fn;
            }
            Label m;
            m = new DoubleClickLinkLabel(patchKey);
            m.setText(Util.M.lineHeader(c.getLine()));
            m.setStyleName("gerrit-LineHeader");
            panel.add(m);
            m = new DoubleClickLinkLabel(patchKey);
            SafeHtml.set(m.getElement(), LineCommentPanel.toSafeHtml(c));
            m.setStyleName("gerrit-PatchLineComment");
            panel.add(m);
        }
    }
}
#method_after
private void display(final PatchSetPublishDetail r) {
    descBlock.display(r.getChange(), r.getPatchSetInfo(), r.getAccounts());
    if (r.getChange().getStatus().isOpen()) {
        initApprovals(r, approvalPanel);
    }
    if (lastState != null && patchSetId.equals(lastState.patchSetId)) {
        message.setText(lastState.message);
    }
    draftsPanel.clear();
    if (!r.getDrafts().isEmpty()) {
        draftsPanel.add(new SmallHeading(Util.C.headingPatchComments()));
        Panel panel = null;
        String priorFile = "";
        for (final PatchLineComment c : r.getDrafts()) {
            final Patch.Key patchKey = c.getKey().getParentKey();
            final String fn = patchKey.get();
            if (!fn.equals(priorFile)) {
                panel = new FlowPanel();
                panel.addStyleName("gerrit-PatchComments");
                draftsPanel.add(panel);
                // Parent table can be null here since we are not showing any next/previous links
                panel.add(new PatchLink.SideBySide(fn, patchKey, 0, null));
                priorFile = fn;
            }
            Label m;
            m = new DoubleClickLinkLabel(patchKey);
            m.setText(Util.M.lineHeader(c.getLine()));
            m.setStyleName("gerrit-LineHeader");
            panel.add(m);
            m = new DoubleClickLinkLabel(patchKey);
            SafeHtml.set(m.getElement(), LineCommentPanel.toSafeHtml(c));
            m.setStyleName("gerrit-PatchLineComment");
            panel.add(m);
        }
    }
}
#end_block

#method_before
private Screen select(final String token) {
    String p;
    if (token == null) {
        return null;
    }
    if (SETTINGS.equals(token) || token.startsWith("settings,")) {
        if (SETTINGS_NEW_AGREEMENT.equals(token)) {
            return new NewAgreementScreen();
        }
        return new AccountSettings(token);
    }
    if (MINE.equals(token)) {
        return new AccountDashboardScreen(Common.getAccountId());
    }
    if (token.startsWith("mine,")) {
        if (MINE_STARRED.equals(token)) {
            return new MineStarredScreen();
        }
        if (MINE_DRAFTS.equals(token)) {
            return new MineDraftsScreen();
        }
    }
    if (token.startsWith("all,")) {
        p = "all,abandoned,";
        if (token.startsWith(p)) {
            return new AllAbandonedChangesScreen(skip(p, token));
        }
        p = "all,merged,";
        if (token.startsWith(p)) {
            return new AllMergedChangesScreen(skip(p, token));
        }
        p = "all,open,";
        if (token.startsWith(p)) {
            return new AllOpenChangesScreen(skip(p, token));
        }
    }
    if (token.startsWith("project,")) {
        p = "project,open,";
        if (token.startsWith(p)) {
            final String s = skip(p, token);
            final int c = s.indexOf(',');
            return new ByProjectOpenChangesScreen(Project.NameKey.parse(s.substring(0, c)), s.substring(c + 1));
        }
    }
    if (token.startsWith("patch,")) {
        p = "patch,sidebyside,";
        if (token.startsWith(p))
            return new PatchScreen.SideBySide(Patch.Key.parse(skip(p, token)), null, /* patch */
            null);
        p = "patch,unified,";
        if (token.startsWith(p))
            return new PatchScreen.Unified(Patch.Key.parse(skip(p, token)), null, /* patch */
            null);
    }
    p = "change,publish,";
    if (token.startsWith(p))
        return new PublishCommentScreen(PatchSet.Id.parse(skip(p, token)));
    p = "change,";
    if (token.startsWith(p))
        return new ChangeScreen(Change.Id.parse(skip(p, token)));
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    if (token.startsWith("admin,")) {
        p = "admin,group,";
        if (token.startsWith(p))
            return new AccountGroupScreen(AccountGroup.Id.parse(skip(p, token)));
        p = "admin,project,";
        if (token.startsWith(p)) {
            p = skip(p, token);
            final int c = p.indexOf(',');
            final String idstr = p.substring(0, c);
            return new ProjectAdminScreen(Project.Id.parse(idstr), token);
        }
        if (ADMIN_GROUPS.equals(token)) {
            return new GroupListScreen();
        }
        if (ADMIN_PROJECTS.equals(token)) {
            return new ProjectListScreen();
        }
    }
    p = "VE,";
    if (token.startsWith(p)) {
        return new ValidateEmailScreen(skip(p, token));
    }
    return null;
}
#method_after
private Screen select(final String token) {
    String p;
    if (token == null) {
        return null;
    }
    if (SETTINGS.equals(token) || token.startsWith("settings,")) {
        if (SETTINGS_NEW_AGREEMENT.equals(token)) {
            return new NewAgreementScreen();
        }
        return new AccountSettings(token);
    }
    if (MINE.equals(token)) {
        return new AccountDashboardScreen(Common.getAccountId());
    }
    if (token.startsWith("mine,")) {
        if (MINE_STARRED.equals(token)) {
            return new MineStarredScreen();
        }
        if (MINE_DRAFTS.equals(token)) {
            return new MineDraftsScreen();
        }
    }
    if (token.startsWith("all,")) {
        p = "all,abandoned,";
        if (token.startsWith(p)) {
            return new AllAbandonedChangesScreen(skip(p, token));
        }
        p = "all,merged,";
        if (token.startsWith(p)) {
            return new AllMergedChangesScreen(skip(p, token));
        }
        p = "all,open,";
        if (token.startsWith(p)) {
            return new AllOpenChangesScreen(skip(p, token));
        }
    }
    if (token.startsWith("project,")) {
        p = "project,open,";
        if (token.startsWith(p)) {
            final String s = skip(p, token);
            final int c = s.indexOf(',');
            return new ByProjectOpenChangesScreen(Project.NameKey.parse(s.substring(0, c)), s.substring(c + 1));
        }
    }
    if (token.startsWith("patch,")) {
        p = "patch,sidebyside,";
        if (token.startsWith(p))
            return new PatchScreen.SideBySide(Patch.Key.parse(skip(p, token)), 0, /* patchIndex */
            null);
        p = "patch,unified,";
        if (token.startsWith(p))
            return new PatchScreen.Unified(Patch.Key.parse(skip(p, token)), 0, /* patchIndex */
            null);
    }
    p = "change,publish,";
    if (token.startsWith(p))
        return new PublishCommentScreen(PatchSet.Id.parse(skip(p, token)));
    p = "change,";
    if (token.startsWith(p))
        return new ChangeScreen(Change.Id.parse(skip(p, token)));
    p = "dashboard,";
    if (token.startsWith(p))
        return new AccountDashboardScreen(Account.Id.parse(skip(p, token)));
    if (token.startsWith("admin,")) {
        p = "admin,group,";
        if (token.startsWith(p))
            return new AccountGroupScreen(AccountGroup.Id.parse(skip(p, token)));
        p = "admin,project,";
        if (token.startsWith(p)) {
            p = skip(p, token);
            final int c = p.indexOf(',');
            final String idstr = p.substring(0, c);
            return new ProjectAdminScreen(Project.Id.parse(idstr), token);
        }
        if (ADMIN_GROUPS.equals(token)) {
            return new GroupListScreen();
        }
        if (ADMIN_PROJECTS.equals(token)) {
            return new ProjectListScreen();
        }
    }
    p = "VE,";
    if (token.startsWith(p)) {
        return new ValidateEmailScreen(skip(p, token));
    }
    return null;
}
#end_block

#method_before
private void populateAbandonAction() {
    final Button b = new Button(Util.C.buttonAbandonChangeBegin());
    b.addClickListener(new ClickListener() {

        public void onClick(Widget sender) {
            b.setEnabled(false);
            new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<Object>() {

                public void onSuccess(Object result) {
                    actionsPanel.remove(b);
                    fireOnSuggestRefresh();
                }

                public void onFailure(Throwable caught) {
                    b.setEnabled(true);
                }
            }).center();
        }
    });
    actionsPanel.add(b);
}
#method_after
private void populateAbandonAction() {
    final Button b = new Button(Util.C.buttonAbandonChangeBegin());
    b.addClickListener(new ClickListener() {

        public void onClick(Widget sender) {
            new AbandonChangeDialog(patchSet.getId(), new AsyncCallback<Object>() {

                public void onSuccess(Object result) {
                    actionsPanel.remove(b);
                    fireOnSuggestRefresh();
                }

                public void onFailure(Throwable caught) {
                }
            }).center();
        }
    });
    actionsPanel.add(b);
}
#end_block

#method_before
public void changeDetail(final Change.Id id, final AsyncCallback<ChangeDetail> callback) {
    run(callback, new Action<ChangeDetail>() {

        public ChangeDetail run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(id);
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final Project proj = db.projects().get(change.getDest().getParentKey());
            if (change == null || patch == null || proj == null) {
                throw new Failure(new NoSuchEntityException());
            }
            assertCanRead(change);
            final boolean anon;
            boolean canAbandon = false;
            if (me == null) {
                // Safe assumption, this wouldn't be allowed if it wasn't.
                // 
                anon = true;
            } else {
                // Ask if the anonymous user can read this project; even if
                // we can that doesn't mean the anonymous user could.
                // 
                anon = canRead(null, change.getDest().getParentKey());
                // The change owner, current patchset uploader, Gerrit administrator,
                // and project administrator can mark the change as abandoned.
                // 
                canAbandon = me.equals(change.getOwner()) || me.equals(patch.getUploader()) || Common.getGroupCache().isAdministrator(me) || Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId());
            }
            final ChangeDetail d = new ChangeDetail();
            d.load(db, new AccountInfoCacheFactory(db), change, anon, canAbandon);
            return d;
        }
    });
}
#method_after
public void changeDetail(final Change.Id id, final AsyncCallback<ChangeDetail> callback) {
    run(callback, new Action<ChangeDetail>() {

        public ChangeDetail run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(id);
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey());
            if (patch == null || projEnt == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final Project proj = projEnt.getProject();
            assertCanRead(change);
            final boolean anon;
            boolean canAbandon = false;
            if (me == null) {
                // Safe assumption, this wouldn't be allowed if it wasn't.
                // 
                anon = true;
            } else {
                // Ask if the anonymous user can read this project; even if
                // we can that doesn't mean the anonymous user could.
                // 
                anon = canRead(null, change.getDest().getParentKey());
                // The change owner, current patchset uploader, Gerrit administrator,
                // and project administrator can mark the change as abandoned.
                // 
                canAbandon = me.equals(change.getOwner()) || me.equals(patch.getUploader()) || Common.getGroupCache().isAdministrator(me) || Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId());
            }
            final ChangeDetail d = new ChangeDetail();
            d.load(db, new AccountInfoCacheFactory(db), change, anon, canAbandon);
            return d;
        }
    });
}
#end_block

#method_before
public void abandonChange(final String message, final PatchSet.Id patchSetId, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(patchSetId.getParentKey());
            final PatchSet patch = db.patchSets().get(change.currentPatchSetId());
            final Project proj = db.projects().get(change.getDest().getParentKey());
            if (me == null || change == null || patch == null || proj == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (!me.equals(change.getOwner()) && !me.equals(patch.getUploader()) && !Common.getGroupCache().isAdministrator(me) && !Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId())) {
                // The user doesn't have permission to abandon the change
                throw new Failure(new NoSuchEntityException());
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me);
            final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
            if (message != null && message.length() > 0) {
                msgBuf.append("\n\n");
                msgBuf.append(message);
            }
            cmsg.setMessage(msgBuf.toString());
            db.run(new OrmRunnable<VoidResult, ReviewDb>() {

                public VoidResult run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAbandonChange(message, change, cmsg, db, txn);
                }
            });
            // Email the reviewers
            try {
                final ChangeMail cm = new ChangeMail(server, change);
                cm.setFrom(Common.getAccountId());
                cm.setReviewDb(db);
                cm.setChangeMessage(cmsg);
                cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                cm.sendAbandoned();
            } catch (MessagingException e) {
                log.error("Cannot send abandon change email for change " + change.getChangeId(), e);
                throw new Failure(e);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void abandonChange(final PatchSet.Id patchSetId, final String message, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final Account.Id me = Common.getAccountId();
            final Change change = db.changes().get(patchSetId.getParentKey());
            if (change == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final PatchSet patch = db.patchSets().get(patchSetId);
            final ProjectCache.Entry projEnt = Common.getProjectCache().get(change.getDest().getParentKey());
            if (me == null || patch == null || projEnt == null) {
                throw new Failure(new NoSuchEntityException());
            }
            final Project proj = projEnt.getProject();
            if (!me.equals(change.getOwner()) && !me.equals(patch.getUploader()) && !Common.getGroupCache().isAdministrator(me) && !Common.getGroupCache().isInGroup(me, proj.getOwnerGroupId())) {
                // The user doesn't have permission to abandon the change
                throw new Failure(new NoSuchEntityException());
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me);
            final StringBuilder msgBuf = new StringBuilder("Patch Set " + change.currentPatchSetId().get() + ": Abandoned");
            if (message != null && message.length() > 0) {
                msgBuf.append("\n\n");
                msgBuf.append(message);
            }
            cmsg.setMessage(msgBuf.toString());
            Boolean dbSuccess = db.run(new OrmRunnable<Boolean, ReviewDb>() {

                public Boolean run(ReviewDb db, Transaction txn, boolean retry) throws OrmException {
                    return doAbandonChange(message, change, patchSetId, cmsg, db, txn);
                }
            });
            if (dbSuccess) {
                // Email the reviewers
                try {
                    final ChangeMail cm = new ChangeMail(server, change);
                    cm.setFrom(me);
                    cm.setReviewDb(db);
                    cm.setChangeMessage(cmsg);
                    cm.setHttpServletRequest(GerritJsonServlet.getCurrentCall().getHttpServletRequest());
                    cm.sendAbandoned();
                } catch (MessagingException e) {
                    log.error("Cannot send abandon change email for change " + change.getChangeId(), e);
                    throw new Failure(e);
                }
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
private VoidResult doAbandonChange(final String message, final Change change, final ChangeMessage cm, final ReviewDb db, final Transaction txn) throws OrmException {
    if (change.getStatus() == Change.Status.NEW) {
        change.setStatus(Change.Status.ABANDONED);
        ChangeUtil.updated(change);
    }
    db.changeMessages().insert(Collections.singleton(cm), txn);
    db.changes().update(Collections.singleton(change), txn);
    return VoidResult.INSTANCE;
}
#method_after
private Boolean doAbandonChange(final String message, final Change change, final PatchSet.Id psid, final ChangeMessage cm, final ReviewDb db, final Transaction txn) throws OrmException {
    // changed while the user was typing an abandon message
    if (change.getStatus() == Change.Status.NEW && change.currentPatchSetId().equals(psid)) {
        change.setStatus(Change.Status.ABANDONED);
        ChangeUtil.updated(change);
        final List<ChangeApproval> approvals = db.changeApprovals().byChange(change.getId()).toList();
        for (ChangeApproval a : approvals) {
            a.cache(change);
        }
        db.changeApprovals().update(approvals, txn);
        db.changeMessages().insert(Collections.singleton(cm), txn);
        db.changes().update(Collections.singleton(change), txn);
        return Boolean.TRUE;
    }
    return Boolean.FALSE;
}
#end_block

#method_before
private void initUI() {
    addStyleName("gerrit-ChangeScreen");
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    dependencies = new ChangeTable();
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    approvals = new ApprovalTable(changeId);
    approvalsPanel = new DisclosurePanel(Util.C.changeScreenApprovals());
    approvalsPanel.setContent(wrap(approvals));
    dependenciesPanel.setWidth("95%");
    add(approvalsPanel);
    patchSetPanels = new FlowPanel();
    add(patchSetPanels);
    messagesContent = new FlowPanel();
    messagesContent.setStyleName("gerrit-ChangeMessages");
    messagesPanel = new DisclosurePanel(Util.C.changeScreenMessages());
    messagesPanel.setContent(messagesContent);
    add(messagesPanel);
}
#method_after
private void initUI() {
    addStyleName("gerrit-ChangeScreen");
    descriptionBlock = new ChangeDescriptionBlock();
    add(descriptionBlock);
    dependencies = new ChangeTable();
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new DisclosurePanel(Util.C.changeScreenDependencies());
    dependenciesPanel.setContent(dependencies);
    dependenciesPanel.setWidth("95%");
    add(dependenciesPanel);
    approvals = new ApprovalTable();
    approvalsPanel = new DisclosurePanel(Util.C.changeScreenApprovals());
    approvalsPanel.setContent(wrap(approvals));
    dependenciesPanel.setWidth("95%");
    add(approvalsPanel);
    patchSetPanels = new FlowPanel();
    add(patchSetPanels);
    messagesContent = new FlowPanel();
    messagesContent.setStyleName("gerrit-ChangeMessages");
    messagesPanel = new DisclosurePanel(Util.C.changeScreenMessages());
    messagesPanel.setContent(messagesContent);
    add(messagesPanel);
}
#end_block

#method_before
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getSubject());
    refreshOnSignIn = !detail.getChange().getStatus().isClosed();
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getMissingApprovals(), detail.getApprovals());
    addPatchSets(detail);
    addMessages(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    approvalsPanel.setOpen(true);
}
#method_after
private void display(final ChangeDetail detail) {
    displayTitle(detail.getChange().getSubject());
    refreshOnSignIn = !detail.getChange().getStatus().isClosed();
    dependencies.setAccountInfoCache(detail.getAccounts());
    approvals.setAccountInfoCache(detail.getAccounts());
    descriptionBlock.display(detail.getChange(), detail.getCurrentPatchSetDetail().getInfo(), detail.getAccounts());
    dependsOn.display(detail.getDependsOn());
    neededBy.display(detail.getNeededBy());
    approvals.display(detail.getChange(), detail.getMissingApprovals(), detail.getApprovals());
    addPatchSets(detail);
    addMessages(detail);
    // If any dependency change is still open, show our dependency list.
    // 
    boolean depsOpen = false;
    if (!detail.getChange().getStatus().isClosed() && detail.getDependsOn() != null) {
        for (final ChangeInfo ci : detail.getDependsOn()) {
            if (ci.getStatus() != Change.Status.MERGED) {
                depsOpen = true;
                break;
            }
        }
    }
    dependenciesPanel.setOpen(depsOpen);
    approvalsPanel.setOpen(true);
}
#end_block

#method_before
public void sendRequestReview() throws MessagingException {
    if (begin("requestReview")) {
        final Account a = Common.getAccountCache().get(fromId);
        if (a == null) {
            body.append("A Gerrit user");
        } else {
            final String e = a.getFullName();
            body.append(e);
        }
        body.append(" has requested that you review a change\n\n");
        if (changeUrl() != null) {
            openFooter();
            body.append("To respond visit ");
            body.append(changeUrl());
            body.append("\n");
        }
        initInReplyToChange();
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
        if (fromId != null) {
            add(RecipientType.CC, fromId);
        }
        send();
    }
}
#method_after
public void sendRequestReview() throws MessagingException {
    if (begin("requestReview")) {
        final Account a = Common.getAccountCache().get(fromId);
        if (a == null || a.getFullName() == null || a.getFullName().length() == 0) {
            body.append("A Gerrit user");
        } else {
            body.append(a.getFullName());
        }
        body.append(" has requested that you review a change:\n\n");
        body.append(change.getChangeId());
        body.append(" - ");
        body.append(change.getSubject());
        body.append("\n\n");
        if (changeUrl() != null) {
            openFooter();
            body.append("To respond visit ");
            body.append(changeUrl());
            body.append("\n");
        }
        initInReplyToChange();
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
        if (fromId != null) {
            add(RecipientType.CC, fromId);
        }
        send();
    }
}
#end_block

#method_before
private String changeMessageThreadId() {
    final StringBuilder r = new StringBuilder();
    r.append('<');
    r.append("gerrit");
    r.append('.');
    r.append(change.getCreatedOn().getTime());
    r.append('.');
    r.append(change.getChangeId());
    if (fromId != null) {
        r.append('.');
        r.append(fromId.get());
    }
    r.append('@');
    r.append(gerritHost());
    r.append('>');
    return r.toString();
}
#method_after
private String changeMessageThreadId() {
    final StringBuilder r = new StringBuilder();
    r.append('<');
    r.append("gerrit");
    r.append('.');
    r.append(change.getCreatedOn().getTime());
    r.append('.');
    r.append(change.getChangeId());
    r.append('@');
    r.append(gerritHost());
    r.append('>');
    return r.toString();
}
#end_block

#method_before
public void display(final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    final int oldcnt = table.getRowCount();
    table.resizeRows(1 + rows.size());
    if (oldcnt < 1 + rows.size()) {
        for (int row = oldcnt; row < 1 + rows.size(); row++) {
            applyEdgeStyles(row);
            applyScoreStyles(row);
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.setVisible(true);
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i));
        }
    }
    missing.clear();
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Label l = new Label(Util.M.needApproval(at.getCategory().getName()));
                l.setStyleName("gerrit-Change-MissingApproval");
                missing.add(l);
                missing.setVisible(true);
            }
        }
    }
    addReviewer.clear();
    if (need != null && Gerrit.isSignedIn()) {
        final Label l = new Label(Util.C.approvalTableAddReviewer());
        l.setStyleName("gerrit-Change-AddReviewer");
        addReviewer.add(l);
        addReviewer.add(addMemberBox);
    }
}
#method_after
public void display(final Change change, final Set<ApprovalCategory.Id> need, final List<ApprovalDetail> rows) {
    changeId = change.getId();
    final int oldcnt = table.getRowCount();
    table.resizeRows(1 + rows.size());
    if (oldcnt < 1 + rows.size()) {
        for (int row = oldcnt; row < 1 + rows.size(); row++) {
            applyEdgeStyles(row);
            applyScoreStyles(row);
        }
    }
    if (rows.isEmpty()) {
        table.setVisible(false);
    } else {
        table.setVisible(true);
        for (int i = 0; i < rows.size(); i++) {
            displayRow(i + 1, rows.get(i));
        }
    }
    missing.clear();
    missing.setVisible(false);
    if (need != null) {
        for (final ApprovalType at : types) {
            if (need.contains(at.getCategory().getId())) {
                final Label l = new Label(Util.M.needApproval(at.getCategory().getName()));
                l.setStyleName("gerrit-Change-MissingApproval");
                missing.add(l);
                missing.setVisible(true);
            }
        }
    }
    changeIsOpen = change.getStatus().isOpen();
    addReviewer.setVisible(Gerrit.isSignedIn() && changeIsOpen);
}
#end_block

#method_before
private void doAddReviewer() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail == null || nameEmail.length() == 0 || com.google.gerrit.client.admin.Util.C.defaultAccountName().equals(nameEmail)) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = Arrays.asList(nameEmail.split(";"));
    Util.DETAIL_SVC.addReviewers(reviewers, changeId, new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doAddReviewer() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    final List<String> reviewers = new ArrayList<String>();
    reviewers.add(nameEmail);
    PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, new GerritCallback<VoidResult>() {

        public void onSuccess(final VoidResult result) {
            addMemberBox.setEnabled(true);
            addMemberBox.setText("");
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

