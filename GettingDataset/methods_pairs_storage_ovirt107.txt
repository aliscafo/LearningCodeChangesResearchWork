682
#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && !validate(IconUtils.validateIconId(getSmallIconId(), "Small", getVmIconDao()))) {
        return false;
    }
    if (getLargeIconId() != null && !validate(IconUtils.validateIconId(getLargeIconId(), "Large", getVmIconDao()))) {
        return false;
    }
    // validate NUMA nodes count not more than CPUs
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    // validate NUMA nodes count not more than CPUs
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    // Checking if a desktop with same name already exists
    if (isVmWithSameNameExists(name)) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED.name());
        return false;
    }
    if (!verifyAddVM(reasons, vmPriority)) {
        return false;
    }
    if (!checkTemplateImages(reasons)) {
        return false;
    }
    return true;
}
#method_after
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    // Checking if a desktop with same name already exists
    if (isVmWithSameNameExists(name, storagePoolId)) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED.name());
        return false;
    }
    if (!verifyAddVM(reasons, vmPriority)) {
        return false;
    }
    if (!checkTemplateImages(reasons)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getVdsGroup() == null && !(isInstanceType || isBlankTemplate)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType && !isBlankTemplate) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getSmallIconId() != null && !validate(IconUtils.validateIconId(getParameters().getVmTemplateData().getSmallIconId(), "Small", getVmIconDao()))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getLargeIconId() != null && !validate(IconUtils.validateIconId(getParameters().getVmTemplateData().getLargeIconId(), "Large", getVmIconDao()))) {
        return false;
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getVdsGroup() == null && !(isInstanceType || isBlankTemplate)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType && !isBlankTemplate) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else {
            // must be unique also across datacenters.
            if (isInstanceType) {
                if (isInstanceWithSameNameExists(getVmTemplateName())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            } else {
                if (isVmTemlateWithSameNameExist(getVmTemplateName(), isBlankTemplate ? null : getVdsGroup().getStoragePoolId())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            }
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getSmallIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getLargeIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    int memSizeMb = newVmStatic.getMemSizeMb();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
        hotSetMemory(memSizeMb);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && !validate(IconUtils.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small", getVmIconDao()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && !validate(IconUtils.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large", getVmIconDao()))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDAO().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDAO().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDAO().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        // check if pool vm - if not, the field is not legal and command will fail later on
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        }
    }
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isTemplateVersion() && getBaseTemplate().isBlank()) {
        return failCanDoAction(VdcBllMessages.BLANK_TEMPLATE_CANT_HAVE_SUBTEMPLATES);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getMasterVm().getSmallIconId() != null && !validate(IconUtils.validateIconId(getParameters().getMasterVm().getSmallIconId(), "Small", getVmIconDao()))) {
        return false;
    }
    if (getParameters().getMasterVm().getLargeIconId() != null && !validate(IconUtils.validateIconId(getParameters().getMasterVm().getLargeIconId(), "Large", getVmIconDao()))) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    // be unique also across datacenters.
    if (!isTemplateVersion()) {
        if (isInstanceType) {
            if (isInstanceWithSameNameExists(getVmTemplateName())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        } else {
            if (isVmTemlateWithSameNameExist(getVmTemplateName(), getVdsGroup().getStoragePoolId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        }
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isTemplateVersion() && getBaseTemplate().isBlank()) {
        return failCanDoAction(VdcBllMessages.BLANK_TEMPLATE_CANT_HAVE_SUBTEMPLATES);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getMasterVm().getSmallIconId() != null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getMasterVm().getLargeIconId() != null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getLargeIconId(), "Large"))) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#end_block

#method_before
@Test
public void test1() throws Exception {
    KeyStore.PrivateKeyEntry entry = getPrivateKeyEntry(getKeyStore("PKCS12", "key.p12", "NoSoup4U"), "1", "NoSoup4U");
    byte[] test = "testing 1 2 3 4".getBytes(Charset.forName("UTF-8"));
    assertArrayEquals(test, EnvelopeEncryptDecrypt.Decrypt(entry, EnvelopeEncryptDecrypt.Encrypt("AES/OFB/PKCS5Padding", 256, entry.getCertificate(), 100, test)));
}
#method_after
@Test
public void test1() throws Exception {
    KeyStore.PrivateKeyEntry entry = getPrivateKeyEntry(getKeyStore("PKCS12", "key.p12", "NoSoup4U"), "1", "NoSoup4U");
    byte[] test = "testing 1 2 3 4".getBytes(Charset.forName("UTF-8"));
    assertArrayEquals(test, EnvelopeEncryptDecrypt.decrypt(entry, EnvelopeEncryptDecrypt.encrypt("AES/OFB/PKCS5Padding", 256, entry.getCertificate(), 100, test)));
}
#end_block

#method_before
@Test
public void test2() throws Exception {
    KeyStore.PrivateKeyEntry entry = getPrivateKeyEntry(getKeyStore("PKCS12", "key.p12", "NoSoup4U"), "1", "NoSoup4U");
    byte[] test = "testing 1 2 3 4".getBytes(Charset.forName("UTF-8"));
    String blob = "eyJjaXBoZXJBbGdvIjoiQUVTL09GQi9QS0NTNVBhZGRpbmciLCJpdiI6Im01aDgxYUxmdkNycXZtS3R3L290SFE9PSIsIndyYXBLZXlEaWdlc3QiOiJXNkdCbHFrRUlwbUx2aE94VFlybHpwV1JrQjg9Iiwid3JhcHBlZEtleSI6ImE1TXhCWFFBY25kZi95U2J4YWRMdWwySWxHNFpkTWgzOHlUdE9HLzI2MDBHR204ZHRudklpSSsxakE3c0k4cDI1VVAwbWFBL29KdG9xTUVHd0Fhc3VNdkxhVEFPbHJId1RwM2ROaWlWSUFlNmREY21WVTYrd0JLNEljMjBNdjluKzQrRVExUTZ6OXBWSldXQjEzNXk4TEM3NlUzK2czVnBkVm5SWFNGTllpUjR3L2xGMFllVVFxR1J1RnlVRzJLUEV1RzFZTjl5amZjeDB1RWxKb1VYRGNoUDlOY3VqaE9pUHcvTUJ0YzRzSjNjTVZobFh1ZXFtTG85ZE1KWngzS2wzWkNFQTlrMS9Md2wvRzZwNXlsc2gxeWwxSmhwL2M3RmRDRjRJcWt6cFZVejZsZXd4cktnZFhlSG1oOE1CWk5BdkJIK2plYmZrRitlcHZ0c0t0SWJBZz09IiwiZW5jcnlwdGVkQ29udGVudCI6IlhJajluaTFQL1VVZUptOUhYc0orYWIvSkxGS1p1ZnRlM0c1TkFIME0xbkFUR3VtMEwweEhNKzhSYUY0aHZ6dFJ1S3FZb0cxYytmR3dVTG9rRW1pejczZzRmQzZhUTBWL3BManNray81eW43OEZQYVpOQU9oM1ByNmFOemNGbkR0NVBnOVJiK3h5TzIzM0ZlTGw4bWMvOFVRSUEzUURQT1pvbmlxWVdEOXM5VEhYbG56Z1dUSE5GY2g3U0VSZHZqOUtRdHcvUkxPMS9sTVMybmtONUJUZHozYkx2ZXY5YjNWMWdrY1ZKRDRpams9Iiwid3JhcEtleURpZ2VzdEFsZ28iOiJTSEEtMSIsIndyYXBBbGdvIjoiUlNBL0VDQi9QS0NTMVBhZGRpbmcifQ==";
    assertArrayEquals(test, EnvelopeEncryptDecrypt.Decrypt(entry, blob));
}
#method_after
@Test
public void test2() throws Exception {
    KeyStore.PrivateKeyEntry entry = getPrivateKeyEntry(getKeyStore("PKCS12", "key.p12", "NoSoup4U"), "1", "NoSoup4U");
    byte[] test = "testing 1 2 3 4".getBytes(Charset.forName("UTF-8"));
    String blob = "eyJjaXBoZXJBbGdvIjoiQUVTL09GQi9QS0NTNVBhZGRpbmciLCJpdiI6Im01aDgxYUxmdkNycXZtS3R3L290SFE9PSIsIndyYXBLZXlEaWdlc3QiOiJXNkdCbHFrRUlwbUx2aE94VFlybHpwV1JrQjg9Iiwid3JhcHBlZEtleSI6ImE1TXhCWFFBY25kZi95U2J4YWRMdWwySWxHNFpkTWgzOHlUdE9HLzI2MDBHR204ZHRudklpSSsxakE3c0k4cDI1VVAwbWFBL29KdG9xTUVHd0Fhc3VNdkxhVEFPbHJId1RwM2ROaWlWSUFlNmREY21WVTYrd0JLNEljMjBNdjluKzQrRVExUTZ6OXBWSldXQjEzNXk4TEM3NlUzK2czVnBkVm5SWFNGTllpUjR3L2xGMFllVVFxR1J1RnlVRzJLUEV1RzFZTjl5amZjeDB1RWxKb1VYRGNoUDlOY3VqaE9pUHcvTUJ0YzRzSjNjTVZobFh1ZXFtTG85ZE1KWngzS2wzWkNFQTlrMS9Md2wvRzZwNXlsc2gxeWwxSmhwL2M3RmRDRjRJcWt6cFZVejZsZXd4cktnZFhlSG1oOE1CWk5BdkJIK2plYmZrRitlcHZ0c0t0SWJBZz09IiwiZW5jcnlwdGVkQ29udGVudCI6IlhJajluaTFQL1VVZUptOUhYc0orYWIvSkxGS1p1ZnRlM0c1TkFIME0xbkFUR3VtMEwweEhNKzhSYUY0aHZ6dFJ1S3FZb0cxYytmR3dVTG9rRW1pejczZzRmQzZhUTBWL3BManNray81eW43OEZQYVpOQU9oM1ByNmFOemNGbkR0NVBnOVJiK3h5TzIzM0ZlTGw4bWMvOFVRSUEzUURQT1pvbmlxWVdEOXM5VEhYbG56Z1dUSE5GY2g3U0VSZHZqOUtRdHcvUkxPMS9sTVMybmtONUJUZHozYkx2ZXY5YjNWMWdrY1ZKRDRpams9Iiwid3JhcEtleURpZ2VzdEFsZ28iOiJTSEEtMSIsIndyYXBBbGdvIjoiUlNBL0VDQi9QS0NTMVBhZGRpbmcifQ==";
    assertArrayEquals(test, EnvelopeEncryptDecrypt.decrypt(entry, blob));
}
#end_block

#method_before
@Test(expected = KeyException.class)
public void testInvalidKey() throws Exception {
    KeyStore.PrivateKeyEntry entry1 = getPrivateKeyEntry(getKeyStore("PKCS12", "key.p12", "NoSoup4U"), "1", "NoSoup4U");
    KeyStore.PrivateKeyEntry entry2 = getPrivateKeyEntry(getKeyStore("PKCS12", "key2.p12", "mypass"), "1", "mypass");
    byte[] test = "testing 1 2 3 4".getBytes(Charset.forName("UTF-8"));
    assertArrayEquals(test, EnvelopeEncryptDecrypt.Decrypt(entry2, EnvelopeEncryptDecrypt.Encrypt("AES/OFB/PKCS5Padding", 256, entry1.getCertificate(), 100, test)));
}
#method_after
@Test(expected = KeyException.class)
public void testInvalidKey() throws Exception {
    KeyStore.PrivateKeyEntry entry1 = getPrivateKeyEntry(getKeyStore("PKCS12", "key.p12", "NoSoup4U"), "1", "NoSoup4U");
    KeyStore.PrivateKeyEntry entry2 = getPrivateKeyEntry(getKeyStore("PKCS12", "key2.p12", "mypass"), "1", "mypass");
    byte[] test = "testing 1 2 3 4".getBytes(Charset.forName("UTF-8"));
    assertArrayEquals(test, EnvelopeEncryptDecrypt.decrypt(entry2, EnvelopeEncryptDecrypt.encrypt("AES/OFB/PKCS5Padding", 256, entry1.getCertificate(), 100, test)));
}
#end_block

#method_before
protected VmDevice addManagedDeviceForDisk(Guid diskId, Boolean isUsingScsiReservation) {
    return VmDeviceUtils.addManagedDevice(new VmDeviceId(diskId, getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), null, Boolean.TRUE.equals(isUsingScsiReservation));
}
#method_after
protected VmDevice addManagedDeviceForDisk(Guid diskId, Boolean isUsingScsiReservation) {
    return VmDeviceUtils.addDiskDevice(getVmId(), diskId, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), Boolean.TRUE.equals(isUsingScsiReservation));
}
#end_block

#method_before
private VdcActionParametersBase buildAddCinderDiskParameters() {
    AddDiskParameters parameters = new AddDiskParameters();
    parameters.setDiskInfo(getParameters().getDiskInfo());
    parameters.setPlugDiskToVm(getParameters().getPlugDiskToVm());
    parameters.setVmId(getParameters().getVmId());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    return parameters;
}
#method_after
private VdcActionParametersBase buildAddCinderDiskParameters() {
    AddDiskParameters parameters = new AddDiskParameters();
    parameters.setDiskInfo(getParameters().getDiskInfo());
    parameters.setPlugDiskToVm(getParameters().getPlugDiskToVm());
    parameters.setVmId(getParameters().getVmId());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    if (getVm() != null) {
        parameters.setVmSnapshotId(getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE));
    }
    return parameters;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    if (getParameters().getVmId() != null && !Guid.Empty.equals(getParameters().getVmId())) {
        return Collections.singletonMap(getParameters().getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    if (getParameters().getVmId() != null && !Guid.Empty.equals(getParameters().getVmId()) && getParameters().getParentCommand() != VdcActionType.ImportVmFromExternalProvider) {
        return Collections.singletonMap(getParameters().getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return null;
}
#end_block

#method_before
public ValidationResult validateCinderDiskLimits() {
    return validate(new Callable<ValidationResult>() {

        @Override
        public ValidationResult call() {
            int diskIndex = 0;
            for (CinderDisk disk : cinderDisks) {
                OpenStackVolumeProviderProxy proxy = diskProxyMap.get(disk.getId());
                Limits limits = proxy.getLimits();
                if (limits.getAbsolute().getTotalVolumesUsed() + diskIndex >= limits.getAbsolute().getMaxTotalVolumes()) {
                    return new ValidationResult(VdcBllMessages.CANNOT_ADD_CINDER_DISK_VOLUME_LIMIT_EXCEEDED, String.format("$maxTotalVolumes %d", limits.getAbsolute().getMaxTotalVolumes()), String.format("$diskAlias %s", disk.getDiskAlias()));
                }
                diskIndex++;
            }
            return ValidationResult.VALID;
        }
    });
}
#method_after
public ValidationResult validateCinderDiskLimits() {
    return validate(new Callable<ValidationResult>() {

        @Override
        public ValidationResult call() {
            Map<Guid, CinderStorageRelatedDisksAndProxy> relatedCinderDisksByStorageMap = getRelatedCinderDisksToStorageDomainMap();
            Collection<CinderStorageRelatedDisksAndProxy> relatedCinderDisksByStorageCollection = relatedCinderDisksByStorageMap.values();
            for (CinderStorageRelatedDisksAndProxy relatedCinderDisksByStorage : relatedCinderDisksByStorageCollection) {
                Limits limits = relatedCinderDisksByStorage.getProxy().getLimits();
                int numOfDisks = relatedCinderDisksByStorage.getCinderDisks().size();
                if (isLimitExceeded(limits, VolumeClassification.Volume, numOfDisks)) {
                    String storageName = getStorageDomainDao().get(relatedCinderDisksByStorage.getStorageDomainId()).getStorageName();
                    return new ValidationResult(VdcBllMessages.CANNOT_ADD_CINDER_DISK_VOLUME_LIMIT_EXCEEDED, String.format("$maxTotalVolumes %d", limits.getAbsolute().getMaxTotalVolumes()), String.format("$storageName %s", storageName));
                }
            }
            return ValidationResult.VALID;
        }
    });
}
#end_block

#method_before
public ValidationResult validateCinderVolumeTypesExist() {
    return validate(new Callable<ValidationResult>() {

        @Override
        public ValidationResult call() {
            for (final CinderDisk disk : cinderDisks) {
                if (StringUtils.isEmpty(disk.getCinderVolumeType())) {
                    // Specifying a volume type is not mandatory as Cinder can auto-select it.
                    continue;
                }
                OpenStackVolumeProviderProxy proxy = diskProxyMap.get(disk.getId());
                List<CinderVolumeType> volumeTypes = proxy.getVolumeTypes();
                boolean volumeTypeExists = CollectionUtils.exists(volumeTypes, new Predicate() {

                    @Override
                    public boolean evaluate(Object o) {
                        return ((CinderVolumeType) o).getName().equals(disk.getCinderVolumeType());
                    }
                });
                if (!volumeTypeExists) {
                    return new ValidationResult(VdcBllMessages.CINDER_VOLUME_TYPE_NOT_EXISTS, String.format("$cinderVolumeType %s", disk.getCinderVolumeType()));
                }
            }
            return ValidationResult.VALID;
        }
    });
}
#method_after
public ValidationResult validateCinderVolumeTypesExist() {
    return validate(new Callable<ValidationResult>() {

        @Override
        public ValidationResult call() {
            final CinderDisk disk = cinderDisks.iterator().next();
            OpenStackVolumeProviderProxy proxy = diskProxyMap.get(disk.getId());
            List<CinderVolumeType> volumeTypes = proxy.getVolumeTypes();
            boolean volumeTypeExists = CollectionUtils.exists(volumeTypes, new Predicate() {

                @Override
                public boolean evaluate(Object o) {
                    return ((CinderVolumeType) o).getName().equals(disk.getCinderVolumeType());
                }
            });
            if (!volumeTypeExists) {
                return new ValidationResult(VdcBllMessages.CINDER_VOLUME_TYPE_NOT_EXISTS, String.format("$cinderVolumeType %s", disk.getCinderVolumeType()));
            }
            return ValidationResult.VALID;
        }
    });
}
#end_block

#method_before
@Override
public boolean exists(Guid id) {
    return getCallsHandler().executeRead("ExistsVmIconByVmIconId", new RowMapper<Boolean>() {

        @Override
        public Boolean mapRow(ResultSet rs, int rowNum) throws SQLException {
            return rs.getBoolean(1);
        }
    }, getCustomMapSqlParameterSource().addValue(ID_COLUMN, id));
}
#method_after
@Override
public boolean exists(Guid id) {
    return getCallsHandler().executeRead("IsVmIconExist", new RowMapper<Boolean>() {

        @Override
        public Boolean mapRow(ResultSet rs, int rowNum) throws SQLException {
            return rs.getBoolean(1);
        }
    }, getCustomMapSqlParameterSource().addValue(ID_COLUMN, id));
}
#end_block

#method_before
@Override
public void startMonitoring() {
    super.startMonitoring();
    this.resourceManager.subscribe(new EventSubscriber(manager.getVdsHostname() + "|*|VM_status|*") {

        @Override
        public void onSubscribe(Subscription sub) {
            subscription = sub;
            subscription.request(1);
        }

        @Override
        public void onNext(Map<String, Object> map) {
            try {
                List<Pair<VM, VmInternalData>> changedVms = new ArrayList<>();
                List<Pair<VM, VmInternalData>> devicesChangedVms = new ArrayList<>();
                List<VmInternalData> vms = convertEvent(map);
                prepareChanges(vms, changedVms, devicesChangedVms, map);
                new VmsMonitoring(manager, changedVms, devicesChangedVms, auditLogDirector).perform();
            } finally {
                subscription.request(1);
            }
        }

        @SuppressWarnings("unchecked")
        private List<VmInternalData> convertEvent(Map<String, Object> map) {
            List<VmInternalData> returnVMs = new ArrayList<VmInternalData>();
            for (Map.Entry<String, Object> entry : map.entrySet()) {
                VmDynamic vmdynamic = new VmDynamic();
                vmdynamic.setId(new Guid((String) entry.getKey()));
                Map<String, Object> attributes = (Map<String, Object>) map.get(entry.getKey());
                vmdynamic.setStatus(convertToVmStatus((String) attributes.get("status")));
                VmInternalData vmData = new VmInternalData(vmdynamic, null, null, null);
                returnVMs.add(vmData);
            }
            return returnVMs;
        }

        @SuppressWarnings("unchecked")
        private void prepareChanges(List<VmInternalData> vms, List<Pair<VM, VmInternalData>> changedVms, List<Pair<VM, VmInternalData>> devicesChangedVms, Map<String, Object> map) {
            Map<Guid, VM> dbVms = dbFacade.getVmDao().getAllRunningByVds(manager.getVdsId());
            for (VmInternalData vdsmVm : vms) {
                Guid vmid = vdsmVm.getVmDynamic().getId();
                VM dbVm = dbVms.get(vmid);
                VDS host = dbFacade.getVdsDao().get(manager.getVdsId());
                Map<String, Object> attributes = (Map<String, Object>) map.get(vmid.toString());
                VmInternalData vmData = VmStatsVdsBrokerCommand.createVmInternalData((Map<String, Object>) attributes.get("stats"), host);
                if (vmData != null) {
                    changedVms.add(new Pair<>(dbVm, vmData));
                }
                if (isDevicesChanged(dbVm, vdsmVm)) {
                    devicesChangedVms.add(new Pair<>(dbVm, vdsmVm));
                }
            }
        }

        @Override
        public void onError(Throwable t) {
        }

        @Override
        public void onComplete() {
        }
    });
}
#method_after
@Override
public void startMonitoring() {
    super.startMonitoring();
    this.resourceManager.subscribe(new EventSubscriber(manager.getVdsHostname() + "|*|VM_status|*") {

        @Override
        public void onSubscribe(Subscription sub) {
            subscription = sub;
            subscription.request(1);
        }

        @Override
        public void onNext(Map<String, Object> map) {
            try {
                List<Pair<VM, VmInternalData>> changedVms = new ArrayList<>();
                List<Pair<VM, VmInternalData>> devicesChangedVms = new ArrayList<>();
                convertEvent(changedVms, devicesChangedVms, map);
                if (!changedVms.isEmpty() || !devicesChangedVms.isEmpty()) {
                    new VmsMonitoring(manager, changedVms, devicesChangedVms, auditLogDirector, System.nanoTime()).perform();
                }
            } finally {
                subscription.request(1);
            }
        }

        @SuppressWarnings("unchecked")
        private void convertEvent(List<Pair<VM, VmInternalData>> changedVms, List<Pair<VM, VmInternalData>> devicesChangedVms, Map<String, Object> map) {
            Double notifyTime = parseDouble(map.remove(VdsProperties.notify_time));
            for (Map.Entry<String, Object> entry : map.entrySet()) {
                Guid vmid = new Guid((String) entry.getKey());
                VM dbVm = dbFacade.getVmDao().get(vmid);
                if (dbVm == null) {
                    log.error("failed to fetch VM '{}' from db. Status remain unchanged", vmid);
                    return;
                }
                VmInternalData vdsmVm = createVmInternalData(dbVm, (Map<String, Object>) map.get(vmid.toString()), notifyTime);
                // and process once the migration is done
                if (dbVm.getRunOnVds() == null || dbVm.getRunOnVds().equals(manager.getVdsId()) || (!dbVm.getRunOnVds().equals(manager.getVdsId()) && vdsmVm.getVmDynamic().getStatus() == VMStatus.Up)) {
                    if (vdsmVm != null) {
                        changedVms.add(new Pair<>(dbVm, vdsmVm));
                    }
                    if (isDevicesChanged(dbVm, vdsmVm)) {
                        devicesChangedVms.add(new Pair<>(dbVm, vdsmVm));
                    }
                }
            }
        }

        private VmInternalData createVmInternalData(VM dbVm, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            VmDynamic vmDynamic = new VmDynamic(dbVm.getDynamicData());
            vmDynamic.setId(dbVm.getId());
            vmDynamic.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
            if (xmlRpcStruct.containsKey(VdsProperties.status)) {
                vmDynamic.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
            }
            vmDynamic.setStatusUpdatedTime(notifyTime);
            if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
                vmDynamic.setHash((String) xmlRpcStruct.get(VdsProperties.hash));
            }
            if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
                String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
                vmDynamic.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
            }
            if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
                String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
                vmDynamic.setExitMessage(exitMsg);
            }
            if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
                String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
                vmDynamic.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
            } else {
                vmDynamic.setExitReason(VmExitReason.Unknown);
            }
            return new VmInternalData(vmDynamic, dbVm.getStatisticsData(), null, new HashMap<String, LUNs>());
        }

        private Double parseDouble(Object value) {
            if (Long.class.isInstance(value)) {
                return ((Long) value).doubleValue();
            }
            return null;
        }

        @Override
        public void onError(Throwable t) {
        }

        @Override
        public void onComplete() {
        }
    });
}
#end_block

#method_before
@Override
@OnTimerMethodAnnotation("perform")
public void perform() {
    // we still want to fetch GetAllVmStats as we did before
    if (this.manager.isMonitoringNeeded() && getRefreshStatistics()) {
        VmsListFetcher fetcher = new VmsStatisticsFetcher(this.manager);
        fetcher.fetch();
        new VmsMonitoring(this.manager, fetcher.getChangedVms(), fetcher.getVmsWithChangedDevices(), this.auditLogDirector).perform();
    }
}
#method_after
@Override
@OnTimerMethodAnnotation("perform")
public void perform() {
    // we still want to fetch GetAllVmStats as we did before
    if (this.manager.isMonitoringNeeded() && getRefreshStatistics()) {
        VmsListFetcher fetcher = new VmsStatisticsFetcher(this.manager);
        fetcher.fetch();
        new VmsMonitoring(this.manager, fetcher.getChangedVms(), fetcher.getVmsWithChangedDevices(), this.auditLogDirector, System.nanoTime()).perform();
    }
}
#end_block

#method_before
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair) {
    Guid vmId = getVmId(pair);
    if (vmId != null) {
        VmManager vmManager = getResourceManager().getVmManager(vmId);
        if (vmManager.trylock()) {
            if (vmManager.getLastUpdateDate().compareTo(fetchTime) > 0) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - the VM data has changed since fetching the data", vmId);
                vmManager.unlock();
            } else {
                // store the locked managers to finally release them at the end of the cycle
                vmManagers.put(vmId, vmManager);
                return true;
            }
        } else {
            log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", getVmId(pair));
        }
    }
    return false;
}
#method_after
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair) {
    Guid vmId = getVmId(pair);
    if (vmId != null) {
        VmManager vmManager = getResourceManager().getVmManager(vmId);
        if (vmManager.trylock()) {
            if (fetchTime - vmManager.getVmDataChangedTime() <= 0) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - the VM data has changed since fetching the data", vmId);
                vmManager.unlock();
            } else {
                // store the locked managers to finally release them at the end of the cycle
                vmManagers.put(vmId, vmManager);
                return true;
            }
        } else {
            log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", getVmId(pair));
        }
    }
    return false;
}
#end_block

#method_before
private void unlockVmsManager() {
    Date updateTime = Calendar.getInstance().getTime();
    for (VmManager vmManager : vmManagers.values()) {
        vmManager.setLastUpdateDate(updateTime);
        vmManager.unlock();
    }
}
#method_after
private void unlockVmsManager() {
    for (VmManager vmManager : vmManagers.values()) {
        vmManager.updateVmDataChangedTime();
        vmManager.unlock();
    }
}
#end_block

#method_before
protected void executeVDSCommand() {
    vmManager.lock();
    try {
        executeVmCommand();
        vmManager.setLastUpdateDate(Calendar.getInstance().getTime());
    } finally {
        vmManager.unlock();
    }
}
#method_after
protected void executeVDSCommand() {
    vmManager.lock();
    try {
        executeVmCommand();
        updateVmDataChangedTime();
    } finally {
        vmManager.unlock();
    }
}
#end_block

#method_before
private void initVdsBroker() {
    log.info("Initialize vdsBroker '{}:{}'", cachedVds.getHostName(), cachedVds.getPort());
    // Get the values of the timeouts:
    int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
    int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
    int heartbeat = Config.<Integer>getValue(ConfigValues.vdsHeartbeatInSeconds) * 1000;
    int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
    vdsProxy = TransportFactory.createVdsServer(cachedVds.getProtocol(), cachedVds.getHostName(), cachedVds.getPort(), clientTimeOut, connectionTimeOut, clientRetries, heartbeat);
}
#method_after
private void initVdsBroker() {
    log.info("Initialize vdsBroker '{}:{}'", cachedVds.getHostName(), cachedVds.getPort());
    // Get the values of the timeouts:
    int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
    int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
    int heartbeat = Config.<Integer>getValue(ConfigValues.vdsHeartbeatInSeconds) * 1000;
    int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
    vdsProxy = TransportFactory.createVdsServer(cachedVds.getProtocol(), cachedVds.getVdsGroupCompatibilityVersion(), cachedVds.getHostName(), cachedVds.getPort(), clientTimeOut, connectionTimeOut, clientRetries, heartbeat);
}
#end_block

#method_before
@OnTimerMethodAnnotation("vmsMonitoring")
public void vmsMonitoring() {
    if (isMonitoringNeeded()) {
        VmsListFetcher fetcher = getRefreshStatistics() ? new VmsStatisticsFetcher(this) : new VmsListFetcher(this);
        fetcher.fetch();
        new VmsMonitoring(this, fetcher.getChangedVms(), fetcher.getVmsWithChangedDevices(), auditLogDirector, fetcher.getFetchTime()).perform();
    }
}
#method_after
@OnTimerMethodAnnotation("vmsMonitoring")
public void vmsMonitoring() {
    if (isMonitoringNeeded()) {
        VmsListFetcher fetcher = getRefreshStatistics() ? new VmsStatisticsFetcher(this) : new VmsListFetcher(this);
        long fetchTime = System.nanoTime();
        fetcher.fetch();
        new VmsMonitoring(this, fetcher.getChangedVms(), fetcher.getVmsWithChangedDevices(), auditLogDirector, fetchTime).perform();
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", cachedVds.getName());
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", e.getMessage());
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (getLockObj()) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            dbFacade.getVdsDynamicDao().updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", cachedVds.getName());
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (getLockObj()) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            dbFacade.getVdsDynamicDao().updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
    if (updateAvailable) {
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLogDirector.log(auditLog, AuditLogType.HOST_UPDATES_ARE_AVAILABLE);
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = resourceManager.runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    if (caps.getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                auditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED)) {
            auditLogDirector.log(new AuditLogableBase(vds.getId()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warn("Host '{}' is running with disabled SELinux.", vds.getName());
            } else {
                log.warn("Host '{}' does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = getHostNetworkTopologyPersister().persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debug("monitoring: vds '{}' networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            dbFacade.getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            processHostFeaturesReported(vds);
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (caps.getExceptionObject() != null) {
        throw caps.getExceptionObject();
    } else {
        log.error("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(caps.getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = resourceManager.runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    if (caps.getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                auditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        // hence warning in case of permissive as well.
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED) || (vds.getVdsGroupSupportsGlusterService() && vds.getSELinuxEnforceMode().equals(SELinuxMode.PERMISSIVE))) {
            auditLogDirector.log(new AuditLogableBase(vds.getId()).addCustomValue("Mode", vds.getSELinuxEnforceMode() == null ? "UNKNOWN" : vds.getSELinuxEnforceMode().name()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warn("Host '{}' is running with SELinux in '{}' mode", vds.getName(), vds.getSELinuxEnforceMode());
            } else {
                log.warn("Host '{}' does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = getHostNetworkTopologyPersister().persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debug("monitoring: vds '{}' networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            dbFacade.getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            processHostFeaturesReported(vds);
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (caps.getExceptionObject() != null) {
        throw caps.getExceptionObject();
    } else {
        log.error("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(caps.getExceptionString());
    }
}
#end_block

#method_before
private void logChangeStatusToConnecting(long timeoutToFence) {
    log.warn("Host '{}' is not responding. It will stay in Connecting state for a grace period " + "of {} seconds and after that an attempt to fence the host will be issued.", cachedVds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
    AuditLogableBase logable = new AuditLogableBase();
    logable.setVdsId(cachedVds.getId());
    logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
    auditLogDirector.log(logable, AuditLogType.VDS_HOST_NOT_RESPONDING_CONNECTING);
}
#method_after
private void logChangeStatusToConnecting(long timeoutToFence) {
    String msg;
    AuditLogType auditLogType;
    if (cachedVds.isPmEnabled()) {
        msg = "Host '{}' is not responding. It will stay in Connecting state for a grace period " + "of {} seconds and after that an attempt to fence the host will be issued.";
        auditLogType = AuditLogType.VDS_HOST_NOT_RESPONDING_CONNECTING;
        log.warn(msg, cachedVds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
    } else {
        msg = "Host '{}' is not responding.";
        auditLogType = AuditLogType.VDS_HOST_NOT_RESPONDING;
        log.warn(msg, cachedVds.getName());
    }
    AuditLogableBase logable = new AuditLogableBase();
    logable.setVdsId(cachedVds.getId());
    logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
    auditLogDirector.log(logable, auditLogType);
}
#end_block

#method_before
@Before
public void setup() {
    initVds();
    initConditions();
    when(vdsManager.getRefreshStatistics()).thenReturn(false);
    vmsMonitoring = Mockito.spy(new VmsMonitoring(vdsManager, Arrays.asList(VmTestPairs.MIGRATION_DONE.build()), Collections.<Pair<VM, VmInternalData>>emptyList(), auditLogDirector, Calendar.getInstance().getTime()) {

        @Override
        public DbFacade getDbFacade() {
            return dbFacade;
        }

        @Override
        protected Map[] getVmInfo(List<String> vmsToUpdate) {
            return vmInfo;
        }

        @Override
        protected List<VmDynamic> getPoweringUpVms() {
            return poweringUpVms;
        }
    });
}
#method_after
@Before
public void setup() {
    initVds();
    initConditions();
    when(vdsManager.getRefreshStatistics()).thenReturn(false);
    vmsMonitoring = Mockito.spy(new VmsMonitoring(vdsManager, Arrays.asList(VmTestPairs.MIGRATION_DONE.build()), Collections.<Pair<VM, VmInternalData>>emptyList(), auditLogDirector, System.nanoTime()) {

        @Override
        public DbFacade getDbFacade() {
            return dbFacade;
        }

        @Override
        protected Map[] getVmInfo(List<String> vmsToUpdate) {
            return vmInfo;
        }

        @Override
        protected List<VmDynamic> getPoweringUpVms() {
            return poweringUpVms;
        }
    });
}
#end_block

#method_before
public void handleSecureSetup() {
    // if ssl is on and no certificate file
    if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
        if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.InstallFailed) {
            setStatus(VDSStatus.NonResponsive, cachedVds);
            updateDynamicData(cachedVds.getDynamicData());
        }
        log.error("Could not find VDC Certificate file.");
        AuditLogableBase logable = new AuditLogableBase(vdsId);
        AuditLogDirector.log(logable, AuditLogType.CERTIFICATE_FILE_NOT_FOUND);
    }
}
#method_after
public void handleSecureSetup() {
    // if ssl is on and no certificate file
    if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
        if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.InstallFailed) {
            setStatus(VDSStatus.NonResponsive, cachedVds);
            updateDynamicData(cachedVds.getDynamicData());
        }
        log.error("Could not find VDC Certificate file.");
        AuditLogableBase logable = new AuditLogableBase(vdsId);
        auditLogDirector.log(logable, AuditLogType.CERTIFICATE_FILE_NOT_FOUND);
    }
}
#end_block

#method_before
private void initVdsBroker() {
    log.info("Initialize vdsBroker '{}:{}'", cachedVds.getHostName(), cachedVds.getPort());
    // Get the values of the timeouts:
    int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
    int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
    int heartbeat = Config.<Integer>getValue(ConfigValues.vdsHeartbeatInSeconds) * 1000;
    int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
    vdsProxy = TransportFactory.createVdsServer(cachedVds.getProtocol(), cachedVds.getHostName(), cachedVds.getPort(), clientTimeOut, connectionTimeOut, clientRetries, heartbeat);
}
#method_after
private void initVdsBroker() {
    log.info("Initialize vdsBroker '{}:{}'", cachedVds.getHostName(), cachedVds.getPort());
    // Get the values of the timeouts:
    int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
    int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
    int heartbeat = Config.<Integer>getValue(ConfigValues.vdsHeartbeatInSeconds) * 1000;
    int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
    vdsProxy = TransportFactory.createVdsServer(cachedVds.getProtocol(), cachedVds.getVdsGroupCompatibilityVersion(), cachedVds.getHostName(), cachedVds.getPort(), clientTimeOut, connectionTimeOut, clientRetries, heartbeat);
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            synchronized (getLockObj()) {
                refreshCachedVds();
                if (cachedVds == null) {
                    log.error("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for '{}'", getVdsId());
                    return;
                }
                try {
                    if (refreshIteration == numberRefreshesBeforeSave) {
                        refreshIteration = 1;
                    } else {
                        refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(VdsManager.this, cachedVds, monitoringStrategy);
                        hostMonitoring.refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!isInitialized() && cachedVds.getStatus() != VDSStatus.NonResponsive && cachedVds.getStatus() != VDSStatus.PendingApproval && cachedVds.getStatus() != VDSStatus.InstallingOS) {
                        log.info("Initializing Host: '{}'", cachedVds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(cachedVds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = cachedVds.getStoragePoolId();
                            domainsList = cachedVds.getDomains();
                        }
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            synchronized (getLockObj()) {
                refreshCachedVds();
                if (cachedVds == null) {
                    log.error("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for '{}'", getVdsId());
                    return;
                }
                try {
                    if (refreshIteration == numberRefreshesBeforeSave) {
                        refreshIteration = 1;
                    } else {
                        refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(this, cachedVds, monitoringStrategy, resourceManager, dbFacade, auditLogDirector);
                        hostMonitoring.refresh();
                        mUnrespondedAttempts.set(0);
                        setLastUpdate();
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = cachedVds.getStoragePoolId();
                            domainsList = cachedVds.getDomains();
                        }
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtime info failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#end_block

#method_before
private void refreshCachedVds() {
    cachedVds = DbFacade.getInstance().getVdsDao().get(getVdsId());
    setMonitoringNeeded();
}
#method_after
private void refreshCachedVds() {
    cachedVds = dbFacade.getVdsDao().get(getVdsId());
    setMonitoringNeeded();
}
#end_block

#method_before
@OnTimerMethodAnnotation("vmsMonitoring")
public void vmsMonitoring() {
    if (isMonitoringNeeded()) {
        VmsListFetcher fetcher = getRefreshStatistics() ? new VmsStatisticsFetcher(this) : new VmsListFetcher(this);
        fetcher.fetch();
        new VmsMonitoring(this, fetcher.getChangedVms(), fetcher.getVmsWithChangedDevices()).perform();
    }
}
#method_after
@OnTimerMethodAnnotation("vmsMonitoring")
public void vmsMonitoring() {
    if (isMonitoringNeeded()) {
        VmsListFetcher fetcher = getRefreshStatistics() ? new VmsStatisticsFetcher(this) : new VmsListFetcher(this);
        fetcher.fetch();
        new VmsMonitoring(this, fetcher.getChangedVms(), fetcher.getVmsWithChangedDevices(), auditLogDirector).perform();
    }
}
#end_block

#method_before
private static void logException(final RuntimeException ex) {
    log.error("ResourceManager::refreshVdsRunTimeInfo", ex);
}
#method_after
private void logException(final RuntimeException ex) {
    log.error("ResourceManager::refreshVdsRunTimeInfo", ex);
}
#end_block

#method_before
private void handleVdsRecoveringException(VDSRecoveringException ex) {
    if (cachedVds.getStatus() != VDSStatus.Initializing && cachedVds.getStatus() != VDSStatus.NonOperational) {
        setStatus(VDSStatus.Initializing, cachedVds);
        DbFacade.getInstance().getVdsDynamicDao().updateStatus(cachedVds.getId(), VDSStatus.Initializing);
        AuditLogableBase logable = new AuditLogableBase(cachedVds.getId());
        logable.addCustomValue("ErrorMessage", ex.getMessage());
        logable.updateCallStackFromThrowable(ex);
        AuditLogDirector.log(logable, AuditLogType.VDS_INITIALIZING);
        log.warn("Failed to refresh VDS, continuing, vds='{}'({}): {}", cachedVds.getName(), cachedVds.getId(), ex.getMessage());
        log.debug("Exception", ex);
        final int VDS_RECOVERY_TIMEOUT_IN_MINUTES = Config.<Integer>getValue(ConfigValues.VdsRecoveryTimeoutInMinutes);
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], VDS_RECOVERY_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        recoveringJobIdMap.put(cachedVds.getId(), jobId);
    }
}
#method_after
private void handleVdsRecoveringException(VDSRecoveringException ex) {
    if (cachedVds.getStatus() != VDSStatus.Initializing && cachedVds.getStatus() != VDSStatus.NonOperational) {
        setStatus(VDSStatus.Initializing, cachedVds);
        dbFacade.getVdsDynamicDao().updateStatus(cachedVds.getId(), VDSStatus.Initializing);
        AuditLogableBase logable = new AuditLogableBase(cachedVds.getId());
        logable.addCustomValue("ErrorMessage", ex.getMessage());
        logable.updateCallStackFromThrowable(ex);
        auditLogDirector.log(logable, AuditLogType.VDS_INITIALIZING);
        log.warn("Failed to refresh VDS, continuing, vds='{}'({}): {}", cachedVds.getName(), cachedVds.getId(), ex.getMessage());
        log.debug("Exception", ex);
        final int VDS_RECOVERY_TIMEOUT_IN_MINUTES = Config.<Integer>getValue(ConfigValues.VdsRecoveryTimeoutInMinutes);
        String jobId = getSchedulUtil().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], VDS_RECOVERY_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        recoveringJobIdMap.put(cachedVds.getId(), jobId);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimerHandleVdsRecovering")
public void onTimerHandleVdsRecovering() {
    recoveringJobIdMap.remove(getVdsId());
    VDS vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
    if (vds.getStatus() == VDSStatus.Initializing) {
        try {
            ResourceManager.getInstance().getEventListener().vdsNonOperational(vds.getId(), NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH, true, Guid.Empty);
            setIsSetNonOperationalExecuted(true);
        } catch (RuntimeException exp) {
            log.error("HandleVdsRecoveringException::Error in recovery timer treatment, vds='{}'({}): {}", vds.getName(), vds.getId(), exp.getMessage());
            log.debug("Exception", exp);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimerHandleVdsRecovering")
public void onTimerHandleVdsRecovering() {
    recoveringJobIdMap.remove(getVdsId());
    VDS vds = dbFacade.getVdsDao().get(getVdsId());
    if (vds.getStatus() == VDSStatus.Initializing) {
        try {
            resourceManager.getEventListener().vdsNonOperational(vds.getId(), NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH, true, Guid.Empty);
            setIsSetNonOperationalExecuted(true);
        } catch (RuntimeException exp) {
            log.error("HandleVdsRecoveringException::Error in recovery timer treatment, vds='{}'({}): {}", vds.getName(), vds.getId(), exp.getMessage());
            log.debug("Exception", exp);
        }
    }
}
#end_block

#method_before
public void updateDynamicData(VdsDynamic dynamicData) {
    DbFacade.getInstance().getVdsDynamicDao().updateIfNeeded(dynamicData);
    cachedVds.setDynamicData(dynamicData);
}
#method_after
public void updateDynamicData(VdsDynamic dynamicData) {
    dbFacade.getVdsDynamicDao().updateIfNeeded(dynamicData);
    cachedVds.setDynamicData(dynamicData);
}
#end_block

#method_before
public void updateStatisticsData(VdsStatistics statisticsData) {
    DbFacade.getInstance().getVdsStatisticsDao().update(statisticsData);
    cachedVds.setStatisticsData(statisticsData);
}
#method_after
public void updateStatisticsData(VdsStatistics statisticsData) {
    dbFacade.getVdsStatisticsDao().update(statisticsData);
    cachedVds.setStatisticsData(statisticsData);
}
#end_block

#method_before
public void updateNumaData(final VDS vds) {
    if (vds.getNumaNodeList() == null || vds.getNumaNodeList().isEmpty()) {
        return;
    }
    final List<VdsNumaNode> numaNodesToSave = new ArrayList<>();
    final List<VdsNumaNode> numaNodesToUpdate = new ArrayList<>();
    final List<Guid> numaNodesToRemove = new ArrayList<>();
    List<VdsNumaNode> dbVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vds.getId());
    for (VdsNumaNode node : vds.getNumaNodeList()) {
        VdsNumaNode searchNode = NumaUtils.getVdsNumaNodeByIndex(dbVdsNumaNodes, node.getIndex());
        if (searchNode != null) {
            node.setId(searchNode.getId());
            numaNodesToUpdate.add(node);
            dbVdsNumaNodes.remove(searchNode);
        } else {
            node.setId(Guid.newGuid());
            numaNodesToSave.add(node);
        }
    }
    for (VdsNumaNode node : dbVdsNumaNodes) {
        numaNodesToRemove.add(node.getId());
    }
    // The database operation should be in one transaction
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            if (!numaNodesToRemove.isEmpty()) {
                DbFacade.getInstance().getVdsNumaNodeDAO().massRemoveNumaNodeByNumaNodeId(numaNodesToRemove);
            }
            if (!numaNodesToUpdate.isEmpty()) {
                DbFacade.getInstance().getVdsNumaNodeDAO().massUpdateNumaNode(numaNodesToUpdate);
            }
            if (!numaNodesToSave.isEmpty()) {
                DbFacade.getInstance().getVdsNumaNodeDAO().massSaveNumaNode(numaNodesToSave, vds.getId(), null);
            }
            return null;
        }
    });
}
#method_after
public void updateNumaData(final VDS vds) {
    if (vds.getNumaNodeList() == null || vds.getNumaNodeList().isEmpty()) {
        return;
    }
    final List<VdsNumaNode> numaNodesToSave = new ArrayList<>();
    final List<VdsNumaNode> numaNodesToUpdate = new ArrayList<>();
    final List<Guid> numaNodesToRemove = new ArrayList<>();
    List<VdsNumaNode> dbVdsNumaNodes = dbFacade.getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vds.getId());
    for (VdsNumaNode node : vds.getNumaNodeList()) {
        VdsNumaNode searchNode = NumaUtils.getVdsNumaNodeByIndex(dbVdsNumaNodes, node.getIndex());
        if (searchNode != null) {
            node.setId(searchNode.getId());
            numaNodesToUpdate.add(node);
            dbVdsNumaNodes.remove(searchNode);
        } else {
            node.setId(Guid.newGuid());
            numaNodesToSave.add(node);
        }
    }
    for (VdsNumaNode node : dbVdsNumaNodes) {
        numaNodesToRemove.add(node.getId());
    }
    // The database operation should be in one transaction
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            if (!numaNodesToRemove.isEmpty()) {
                dbFacade.getVdsNumaNodeDAO().massRemoveNumaNodeByNumaNodeId(numaNodesToRemove);
            }
            if (!numaNodesToUpdate.isEmpty()) {
                dbFacade.getVdsNumaNodeDAO().massUpdateNumaNode(numaNodesToUpdate);
            }
            if (!numaNodesToSave.isEmpty()) {
                dbFacade.getVdsNumaNodeDAO().massSaveNumaNode(numaNodesToSave, vds.getId(), null);
            }
            return null;
        }
    });
}
#end_block

#method_before
public void refreshHost(VDS vds) {
    try {
        refreshCapabilities(new AtomicBoolean(), vds);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#method_after
public void refreshHost(VDS vds) {
    try {
        refreshCapabilities(new AtomicBoolean(), vds);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            resourceManager.getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#end_block

#method_before
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        }
        if (vds.getStatus() != status) {
            if (status == VDSStatus.PreparingForMaintenance) {
                calculateNextMaintenanceAttemptTime();
            }
            vds.setPreviousStatus(vds.getStatus());
            if (this.cachedVds != null) {
                this.cachedVds.setPreviousStatus(vds.getStatus());
            }
        }
        // update to new status
        vds.setStatus(status);
        if (this.cachedVds != null) {
            this.cachedVds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (this.cachedVds != null) {
                    this.cachedVds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (this.cachedVds != null) {
                    this.cachedVds.setCpuSys(Double.valueOf(0));
                    this.cachedVds.setCpuUser(Double.valueOf(0));
                    this.cachedVds.setCpuIdle(Double.valueOf(0));
                    this.cachedVds.setCpuLoad(Double.valueOf(0));
                    this.cachedVds.setUsageCpuPercent(0);
                    this.cachedVds.setUsageMemPercent(0);
                    this.cachedVds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#method_after
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        if (vds == null) {
            vds = dbFacade.getVdsDao().get(getVdsId());
        }
        if (vds.getStatus() != status) {
            if (status == VDSStatus.PreparingForMaintenance) {
                calculateNextMaintenanceAttemptTime();
            }
            vds.setPreviousStatus(vds.getStatus());
            if (this.cachedVds != null) {
                this.cachedVds.setPreviousStatus(vds.getStatus());
            }
        }
        // update to new status
        vds.setStatus(status);
        if (this.cachedVds != null) {
            this.cachedVds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (this.cachedVds != null) {
                    this.cachedVds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (this.cachedVds != null) {
                    this.cachedVds.setCpuSys(Double.valueOf(0));
                    this.cachedVds.setCpuUser(Double.valueOf(0));
                    this.cachedVds.setCpuIdle(Double.valueOf(0));
                    this.cachedVds.setCpuLoad(Double.valueOf(0));
                    this.cachedVds.setUsageCpuPercent(0);
                    this.cachedVds.setUsageMemPercent(0);
                    this.cachedVds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("recoverFromError")
public void recoverFromError() {
    VDS vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
    /**
     * Move cachedVds to Up status from error
     */
    if (vds != null && vds.getStatus() == VDSStatus.Error) {
        setStatus(VDSStatus.Up, vds);
        DbFacade.getInstance().getVdsDynamicDao().updateStatus(getVdsId(), VDSStatus.Up);
        log.info("Settings host '{}' to up after {} failed attempts to run a VM", vds.getName(), mFailedToRunVmAttempts);
        mFailedToRunVmAttempts.set(0);
    }
}
#method_after
@OnTimerMethodAnnotation("recoverFromError")
public void recoverFromError() {
    VDS vds = dbFacade.getVdsDao().get(getVdsId());
    /**
     * Move cachedVds to Up status from error
     */
    if (vds != null && vds.getStatus() == VDSStatus.Error) {
        setStatus(VDSStatus.Up, vds);
        dbFacade.getVdsDynamicDao().updateStatus(getVdsId(), VDSStatus.Up);
        log.info("Settings host '{}' to up after {} failed attempts to run a VM", vds.getName(), mFailedToRunVmAttempts);
        mFailedToRunVmAttempts.set(0);
    }
}
#end_block

#method_before
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes), TimeUnit.MINUTES);
        AuditLogDirector.log(new AuditLogableBase(vds.getId()).addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString()), AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.info("Vds '{}' moved to Error mode after {} attempts. Time: {}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#method_after
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        resourceManager.runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = getSchedulUtil();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes), TimeUnit.MINUTES);
        auditLogDirector.log(new AuditLogableBase(vds.getId()).addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString()), AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.info("Vds '{}' moved to Error mode after {} attempts. Time: {}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    if (caps.getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED)) {
            AuditLogDirector.log(new AuditLogableBase(vds.getId()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warn("Host '{}' is running with disabled SELinux.", vds.getName());
            } else {
                log.warn("Host '{}' does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = hostNetworkTopologyPersister.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debug("monitoring: vds '{}' networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            DbFacade.getInstance().getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (caps.getExceptionObject() != null) {
        throw caps.getExceptionObject();
    } else {
        log.error("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(caps.getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = resourceManager.runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    if (caps.getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                auditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        // hence warning in case of permissive as well.
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED) || (vds.getVdsGroupSupportsGlusterService() && vds.getSELinuxEnforceMode().equals(SELinuxMode.PERMISSIVE))) {
            auditLogDirector.log(new AuditLogableBase(vds.getId()).addCustomValue("Mode", vds.getSELinuxEnforceMode() == null ? "UNKNOWN" : vds.getSELinuxEnforceMode().name()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warn("Host '{}' is running with SELinux in '{}' mode", vds.getName(), vds.getSELinuxEnforceMode());
            } else {
                log.warn("Host '{}' does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = getHostNetworkTopologyPersister().persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debug("monitoring: vds '{}' networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            dbFacade.getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            processHostFeaturesReported(vds);
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (caps.getExceptionObject() != null) {
        throw caps.getExceptionObject();
    } else {
        log.error("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(caps.getExceptionString());
    }
}
#end_block

#method_before
private long calcTimeoutToFence(int vmCount, VdsSpmStatus spmStatus) {
    int spmIndicator = 0;
    if (spmStatus != VdsSpmStatus.None) {
        spmIndicator = 1;
    }
    int secToFence = (int) (// delay time can be fracture number, casting it to int should be enough
    Config.<Integer>getValue(ConfigValues.TimeoutToResetVdsInSeconds) + (Config.<Double>getValue(ConfigValues.DelayResetForSpmInSeconds) * spmIndicator) + (Config.<Double>getValue(ConfigValues.DelayResetPerVmInSeconds) * vmCount));
    if (sshSoftFencingExecuted.get()) {
        // VDSM restart by SSH has been executed, wait more to see if host is OK
        secToFence = 2 * secToFence;
    }
    return TimeUnit.SECONDS.toMillis(secToFence);
}
#method_after
private long calcTimeoutToFence(int vmCount, VdsSpmStatus spmStatus) {
    int spmIndicator = spmStatus == VdsSpmStatus.None ? 0 : 1;
    int secToFence = (int) (// delay time can be fracture number, casting it to int should be enough
    Config.<Integer>getValue(ConfigValues.TimeoutToResetVdsInSeconds) + Config.<Double>getValue(ConfigValues.DelayResetForSpmInSeconds) * spmIndicator + Config.<Double>getValue(ConfigValues.DelayResetPerVmInSeconds) * vmCount);
    return TimeUnit.SECONDS.toMillis(secToFence);
}
#end_block

#method_before
public void handleNetworkException(VDSNetworkException ex) {
    boolean saveToDb = true;
    if (cachedVds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(cachedVds.getVmCount(), cachedVds.getSpmStatus());
        logHostNonResponding(timeoutToFence, cachedVds);
        if (inGracePeriod(timeoutToFence)) {
            if (cachedVds.getStatus() != VDSStatus.Connecting && cachedVds.getStatus() != VDSStatus.PreparingForMaintenance && cachedVds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, cachedVds);
            } else {
                saveToDb = false;
            }
            mUnrespondedAttempts.incrementAndGet();
        } else {
            if (cachedVds.getStatus() == VDSStatus.Maintenance) {
                saveToDb = false;
            } else {
                if (cachedVds.getStatus() != VDSStatus.NonResponsive) {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                    moveVMsToUnknown();
                    logHostFailToResponde(ex, timeoutToFence);
                    ResourceManager.getInstance().getEventListener().vdsNotResponding(cachedVds, !sshSoftFencingExecuted.getAndSet(true), lastUpdate);
                } else {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                }
            }
        }
    }
    if (saveToDb) {
        updateDynamicData(cachedVds.getDynamicData());
        updateStatisticsData(cachedVds.getStatisticsData());
    }
}
#method_after
public void handleNetworkException(VDSNetworkException ex) {
    boolean saveToDb = true;
    if (cachedVds.getStatus() != VDSStatus.Down) {
        long timeoutToFence = calcTimeoutToFence(cachedVds.getVmCount(), cachedVds.getSpmStatus());
        if (isHostInGracePeriod(false)) {
            if (cachedVds.getStatus() != VDSStatus.Connecting && cachedVds.getStatus() != VDSStatus.PreparingForMaintenance && cachedVds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, cachedVds);
                logChangeStatusToConnecting(timeoutToFence);
            } else {
                saveToDb = false;
            }
            mUnrespondedAttempts.incrementAndGet();
        } else {
            if (cachedVds.getStatus() == VDSStatus.Maintenance) {
                saveToDb = false;
            } else {
                if (cachedVds.getStatus() != VDSStatus.NonResponsive) {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                    moveVMsToUnknown();
                    logHostFailToRespond(ex, timeoutToFence);
                    resourceManager.getEventListener().vdsNotResponding(cachedVds);
                } else {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                }
            }
        }
    }
    if (saveToDb) {
        updateDynamicData(cachedVds.getDynamicData());
        updateStatisticsData(cachedVds.getStatisticsData());
    }
}
#end_block

#method_before
public void dispose() {
    log.info("vdsManager::disposing");
    SchedulerUtilQuartzImpl.getInstance().deleteJob(onTimerJobId);
    SchedulerUtilQuartzImpl.getInstance().deleteJob(vmsMonitoringJobId);
    vdsProxy.close();
}
#method_after
public void dispose() {
    log.info("vdsManager::disposing");
    for (String jobId : registeredJobs) {
        getSchedulUtil().deleteJob(jobId);
    }
    vdsProxy.close();
}
#end_block

#method_before
private void moveVMsToUnknown() {
    List<VM> vmList = getVmsToMoveToUnknown();
    for (VM vm : vmList) {
        destroyVmOnDestination(vm);
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Unknown));
        // log VM transition to unknown status
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVmId(vm.getId());
        AuditLogDirector.log(logable, AuditLogType.VM_SET_TO_UNKNOWN_STATUS);
    }
}
#method_after
private void moveVMsToUnknown() {
    List<VM> vmList = getVmsToMoveToUnknown();
    for (VM vm : vmList) {
        destroyVmOnDestination(vm);
        resourceManager.runVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Unknown));
        // log VM transition to unknown status
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVmId(vm.getId());
        auditLogDirector.log(logable, AuditLogType.VM_SET_TO_UNKNOWN_STATUS);
    }
}
#end_block

#method_before
private void destroyVmOnDestination(final VM vm) {
    if (vm.getStatus() != VMStatus.MigratingFrom || vm.getMigratingToVds() == null) {
        return;
    }
    // avoid nested locks by doing this in a separate thread
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            VDSReturnValue returnValue = null;
            returnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(vm.getMigratingToVds(), vm.getId(), true, false, 0));
            if (returnValue != null && returnValue.getSucceeded()) {
                log.info("Stopped migrating VM: '{}' on VDS: '{}'", vm.getName(), vm.getMigratingToVds());
            } else {
                log.info("Could not stop migrating VM: '{}' on VDS: '{}'", vm.getName(), vm.getMigratingToVds());
            }
        }
    });
}
#method_after
private void destroyVmOnDestination(final VM vm) {
    if (vm.getStatus() != VMStatus.MigratingFrom || vm.getMigratingToVds() == null) {
        return;
    }
    // avoid nested locks by doing this in a separate thread
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            VDSReturnValue returnValue = null;
            returnValue = resourceManager.runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(vm.getMigratingToVds(), vm.getId(), true, false, 0));
            if (returnValue != null && returnValue.getSucceeded()) {
                log.info("Stopped migrating VM: '{}' on VDS: '{}'", vm.getName(), vm.getMigratingToVds());
            } else {
                log.info("Could not stop migrating VM: '{}' on VDS: '{}'", vm.getName(), vm.getMigratingToVds());
            }
        }
    });
}
#end_block

#method_before
private List<VM> getVmsToMoveToUnknown() {
    List<VM> vmList = DbFacade.getInstance().getVmDao().getAllRunningForVds(getVdsId());
    List<VM> migratingVms = DbFacade.getInstance().getVmDao().getAllMigratingToHost(getVdsId());
    for (VM incomingVm : migratingVms) {
        if (incomingVm.getStatus() == VMStatus.MigratingTo) {
            // this VM is finished the migration handover and is running on this host now
            // and should be treated as well.
            vmList.add(incomingVm);
        }
    }
    return vmList;
}
#method_after
private List<VM> getVmsToMoveToUnknown() {
    List<VM> vmList = dbFacade.getVmDao().getAllRunningForVds(getVdsId());
    List<VM> migratingVms = dbFacade.getVmDao().getAllMigratingToHost(getVdsId());
    for (VM incomingVm : migratingVms) {
        if (incomingVm.getStatus() == VMStatus.MigratingTo) {
            // this VM is finished the migration handover and is running on this host now
            // and should be treated as well.
            vmList.add(incomingVm);
        }
    }
    return vmList;
}
#end_block

#method_before
public static void cancelRecoveryJob(Guid vdsId) {
    String jobId = recoveringJobIdMap.remove(vdsId);
    if (jobId != null) {
        log.info("Cancelling the recovery from crash timer for VDS '{}' because vds started initializing", vdsId);
        try {
            SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
        } catch (Exception e) {
            log.warn("Failed deleting job '{}' at cancelRecoveryJob: {}", jobId, e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#method_after
public void cancelRecoveryJob() {
    String jobId = recoveringJobIdMap.remove(vdsId);
    if (jobId != null) {
        log.info("Cancelling the recovery from crash timer for VDS '{}' because vds started initializing", vdsId);
        try {
            Injector.get(SchedulerUtilQuartzImpl.class).deleteJob(jobId);
        } catch (Exception e) {
            log.warn("Failed deleting job '{}' at cancelRecoveryJob: {}", jobId, e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
public List<Pair<VM, VmInternalData>> getLastVmsList() {
    return lastVmsList;
}
#method_after
public List<VM> getLastVmsList() {
    return lastVmsList;
}
#end_block

#method_before
public void setLastVmsList(List<Pair<VM, VmInternalData>> lastVmsList) {
    this.lastVmsList = lastVmsList;
}
#method_after
public void setLastVmsList(List<VM> lastVmsList) {
    this.lastVmsList = lastVmsList;
}
#end_block

#method_before
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
        if (!validateAndSetVmFromExportDomain())
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND_ON_EXPORT_DOMAIN);
    }
    if (!validateImages(domainsMap)) {
        return false;
    }
    return true;
}
#method_after
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
        if (!validateAndSetVmFromExportDomain()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND_ON_EXPORT_DOMAIN);
        }
    }
    if (!validateImages(domainsMap)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void verify(Cluster model, Cluster transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertNotNull(transform.getCpu());
    assertEquals(model.getCpu().getId(), transform.getCpu().getId());
    assertNotNull(transform.getDataCenter());
    assertEquals(model.getDataCenter().getId(), transform.getDataCenter().getId());
    assertNotNull(transform.getSchedulingPolicy());
    assertEquals(model.getSchedulingPolicy().getId(), transform.getSchedulingPolicy().getId());
    assertEquals(model.getErrorHandling().getOnError(), transform.getErrorHandling().getOnError());
    assertNotNull(transform.getMemoryPolicy());
    assertNotNull(transform.getMemoryPolicy().getTransparentHugepages());
    assertEquals(transform.getMemoryPolicy().getTransparentHugepages().isEnabled(), transform.getMemoryPolicy().getTransparentHugepages().isEnabled());
    assertEquals(model.isVirtService(), transform.isVirtService());
    assertEquals(model.isGlusterService(), transform.isGlusterService());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.isTrustedService(), transform.isTrustedService());
    assertEquals(model.isBallooningEnabled(), transform.isBallooningEnabled());
    assertEquals(model.getKsm().isEnabled(), transform.getKsm().isEnabled());
    assertEquals(model.getKsmMergeAcrossNodes().isEnabled(), transform.getKsmMergeAcrossNodes().isEnabled());
    assertEquals(model.getDisplay().getProxy(), transform.getDisplay().getProxy());
    assertEquals(model.getSerialNumber().getPolicy(), transform.getSerialNumber().getPolicy());
    assertEquals(model.getSerialNumber().getValue(), transform.getSerialNumber().getValue());
}
#method_after
@Override
protected void verify(Cluster model, Cluster transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertNotNull(transform.getCpu());
    assertEquals(model.getCpu().getId(), transform.getCpu().getId());
    assertNotNull(transform.getDataCenter());
    assertEquals(model.getDataCenter().getId(), transform.getDataCenter().getId());
    assertNotNull(transform.getSchedulingPolicy());
    assertEquals(model.getSchedulingPolicy().getId(), transform.getSchedulingPolicy().getId());
    assertEquals(model.getErrorHandling().getOnError(), transform.getErrorHandling().getOnError());
    assertNotNull(transform.getMemoryPolicy());
    assertNotNull(transform.getMemoryPolicy().getTransparentHugepages());
    assertEquals(transform.getMemoryPolicy().getTransparentHugepages().isEnabled(), transform.getMemoryPolicy().getTransparentHugepages().isEnabled());
    assertEquals(model.isVirtService(), transform.isVirtService());
    assertEquals(model.isGlusterService(), transform.isGlusterService());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.isTrustedService(), transform.isTrustedService());
    assertEquals(model.isBallooningEnabled(), transform.isBallooningEnabled());
    assertEquals(model.getKsm().isEnabled(), transform.getKsm().isEnabled());
    assertEquals(model.getKsm().isMergeAcrossNodes(), transform.getKsm().isMergeAcrossNodes());
    assertEquals(model.getDisplay().getProxy(), transform.getDisplay().getProxy());
    assertEquals(model.getSerialNumber().getPolicy(), transform.getSerialNumber().getPolicy());
    assertEquals(model.getSerialNumber().getValue(), transform.getSerialNumber().getValue());
}
#end_block

#method_before
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setCpuName(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setCompatibilityVersion(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetOptionalReason()) {
        entity.setOptionalReasonRequired(model.isOptionalReason());
    }
    if (model.isSetMaintenanceReasonRequired()) {
        entity.setMaintenanceReasonRequired(model.isMaintenanceReasonRequired());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm() && model.getKsm().isSetEnabled()) {
        entity.setEnableKsm(model.getKsm().isEnabled());
    }
    if (model.isSetKsmMergeAcrossNodes() && model.getKsmMergeAcrossNodes().isSetEnabled()) {
        entity.setKsmMergeAcrossNumaNodes(model.getKsmMergeAcrossNodes().isEnabled());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetRequiredRngSources()) {
        entity.getRequiredRngSources().clear();
        entity.getRequiredRngSources().addAll(RngDeviceMapper.mapRngSources(model.getRequiredRngSources(), null));
    }
    if (model.isSetFencingPolicy()) {
        entity.setFencingPolicy(FencingPolicyMapper.map(model.getFencingPolicy(), null));
    }
    if (model.isSetMigration()) {
        MigrationOptionsMapper.copyMigrationOptions(model.getMigration(), entity);
    }
    return entity;
}
#method_after
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setCpuName(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setCompatibilityVersion(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetOptionalReason()) {
        entity.setOptionalReasonRequired(model.isOptionalReason());
    }
    if (model.isSetMaintenanceReasonRequired()) {
        entity.setMaintenanceReasonRequired(model.isMaintenanceReasonRequired());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm()) {
        if (model.getKsm().isSetEnabled()) {
            entity.setEnableKsm(model.getKsm().isEnabled());
        }
        if (model.getKsm().isSetMergeAcrossNodes()) {
            entity.setKsmMergeAcrossNumaNodes(model.getKsm().isMergeAcrossNodes());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetRequiredRngSources()) {
        entity.getRequiredRngSources().clear();
        entity.getRequiredRngSources().addAll(RngDeviceMapper.mapRngSources(model.getRequiredRngSources(), null));
    }
    if (model.isSetFencingPolicy()) {
        entity.setFencingPolicy(FencingPolicyMapper.map(model.getFencingPolicy(), null));
    }
    if (model.isSetMigration()) {
        MigrationOptionsMapper.copyMigrationOptions(model.getMigration(), entity);
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    if (entity.getCpuName() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getCpuName());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getCompatibilityVersion() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getCompatibilityVersion().getMajor());
        model.getVersion().setMinor(entity.getCompatibilityVersion().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setOptionalReason(entity.isOptionalReasonRequired());
    model.setMaintenanceReasonRequired(entity.isMaintenanceReasonRequired());
    model.setBallooningEnabled(entity.isEnableBallooning());
    model.setKsm(new KSM());
    model.getKsm().setEnabled(entity.isEnableKsm());
    model.setKsmMergeAcrossNodes(new KSMMergeAcrossNodes());
    model.getKsmMergeAcrossNodes().setEnabled(entity.isKsmMergeAcrossNumaNodes());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    if (entity.getRequiredRngSources() != null) {
        model.setRequiredRngSources(RngDeviceMapper.mapRngSources(entity.getRequiredRngSources(), null));
    }
    model.setMigration(MigrationOptionsMapper.map(entity, null));
    if (entity.getFencingPolicy() != null) {
        model.setFencingPolicy(FencingPolicyMapper.map(entity.getFencingPolicy(), null));
    }
    return model;
}
#method_after
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    if (entity.getCpuName() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getCpuName());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getCompatibilityVersion() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getCompatibilityVersion().getMajor());
        model.getVersion().setMinor(entity.getCompatibilityVersion().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setOptionalReason(entity.isOptionalReasonRequired());
    model.setMaintenanceReasonRequired(entity.isMaintenanceReasonRequired());
    model.setBallooningEnabled(entity.isEnableBallooning());
    model.setKsm(new KSM());
    model.getKsm().setEnabled(entity.isEnableKsm());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    if (entity.getRequiredRngSources() != null) {
        model.setRequiredRngSources(RngDeviceMapper.mapRngSources(entity.getRequiredRngSources(), null));
    }
    model.setMigration(MigrationOptionsMapper.map(entity, null));
    if (entity.getFencingPolicy() != null) {
        model.setFencingPolicy(FencingPolicyMapper.map(entity.getFencingPolicy(), null));
    }
    return model;
}
#end_block

#method_before
private void updateClusterPolicyProperties(VDSGroup cluster, ClusterPolicy clusterPolicy, Map<String, String> customPropertiesRegexMap) {
    if (cluster.getClusterPolicyProperties() == null) {
        cluster.setClusterPolicyProperties(new LinkedHashMap<String, String>());
    }
    Map<String, String> clusterPolicyProperties = cluster.getClusterPolicyProperties();
    List<String> toRemoveKeysList = new ArrayList<String>();
    if (clusterPolicy.getParameterMap() != null) {
        for (Entry<String, String> entry : clusterPolicy.getParameterMap().entrySet()) {
            if (!clusterPolicyProperties.containsKey(entry.getKey())) {
                clusterPolicyProperties.put(entry.getKey(), entry.getValue());
            }
        }
        for (String key : clusterPolicyProperties.keySet()) {
            if (!customPropertiesRegexMap.containsKey(key)) {
                toRemoveKeysList.add(key);
            }
        }
        for (String key : toRemoveKeysList) {
            clusterPolicyProperties.remove(key);
        }
    }
}
#method_after
private void updateClusterPolicyProperties(VDSGroup cluster, ClusterPolicy clusterPolicy, Map<String, String> customPropertiesRegexMap) {
    if (cluster.getClusterPolicyProperties() == null) {
        cluster.setClusterPolicyProperties(new LinkedHashMap<String, String>());
    }
    Map<String, String> clusterPolicyProperties = cluster.getClusterPolicyProperties();
    List<String> toRemoveKeysList = new ArrayList<>();
    if (clusterPolicy.getParameterMap() != null) {
        for (Entry<String, String> entry : clusterPolicy.getParameterMap().entrySet()) {
            if (!clusterPolicyProperties.containsKey(entry.getKey())) {
                clusterPolicyProperties.put(entry.getKey(), entry.getValue());
            }
        }
        for (String key : clusterPolicyProperties.keySet()) {
            if (!customPropertiesRegexMap.containsKey(key)) {
                toRemoveKeysList.add(key);
            }
        }
        for (String key : toRemoveKeysList) {
            clusterPolicyProperties.remove(key);
        }
    }
}
#end_block

#method_before
private boolean initTrustedService() {
    List<String> hosts = new ArrayList<String>();
    if (AttestThread.isTrustedVds(getVds().getId())) {
        return true;
    }
    hosts.add(getVds().getHostName());
    List<AttestationValue> value = new ArrayList<AttestationValue>();
    try {
        value = AttestationService.getInstance().attestHosts(hosts);
    } catch (Exception e) {
        log.error("Encounter an exception while attesting host's trustworthiness for Host '{}': {}", hosts, e.getMessage());
        log.debug("Exception", e);
    }
    if (value.size() > 0 && value.get(0).getTrustLevel() == AttestationResultEnum.TRUSTED) {
        return true;
    } else {
        setNonOperational(NonOperationalReason.UNTRUSTED, null);
        return false;
    }
}
#method_after
private boolean initTrustedService() {
    List<String> hosts = new ArrayList<>();
    if (AttestThread.isTrustedVds(getVds().getId())) {
        return true;
    }
    hosts.add(getVds().getHostName());
    List<AttestationValue> value = new ArrayList<>();
    try {
        value = AttestationService.getInstance().attestHosts(hosts);
    } catch (Exception e) {
        log.error("Encounter an exception while attesting host's trustworthiness for Host '{}': {}", hosts, e.getMessage());
        log.debug("Exception", e);
    }
    if (value.size() > 0 && value.get(0).getTrustLevel() == AttestationResultEnum.TRUSTED) {
        return true;
    } else {
        setNonOperational(NonOperationalReason.UNTRUSTED, null);
        return false;
    }
}
#end_block

#method_before
private void refreshHostDeviceList() {
    if (FeatureSupported.hostDevicePassthrough(getVds().getVdsGroupCompatibilityVersion())) {
        try {
            runInternalAction(VdcActionType.RefreshHostDevices, new VdsActionParameters(getVdsId()));
        } catch (VdcBLLException e) {
            log.error("Could not refresh host devices for host '{}'", getVds().getName());
        }
    }
}
#method_after
private void refreshHostDeviceList() {
    try {
        runInternalAction(VdcActionType.RefreshHostDevices, new VdsActionParameters(getVdsId()));
    } catch (VdcBLLException e) {
        log.error("Could not refresh host devices for host '{}'", getVds().getName());
    }
}
#end_block

#method_before
private EventResult connectHostToPool() {
    final VDS vds = getVds();
    EventResult result = ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getStoragePool().getId(), null, vds.getId(), EventType.VDSCONNECTTOPOOL, "Trying to connect host " + vds.getHostName() + " with id " + vds.getId() + " to the pool " + getStoragePool().getId()), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            return runConnectHostToPoolEvent(getStoragePool().getId(), vds);
        }
    });
    return result;
}
#method_after
private EventResult connectHostToPool() {
    final VDS vds = getVds();
    EventResult result = eventQueue.submitEventSync(new Event(getStoragePool().getId(), null, vds.getId(), EventType.VDSCONNECTTOPOOL, "Trying to connect host " + vds.getHostName() + " with id " + vds.getId() + " to the pool " + getStoragePool().getId()), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            return runConnectHostToPoolEvent(getStoragePool().getId(), vds);
        }
    });
    return result;
}
#end_block

#method_before
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!getGlusterUtil().isHostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < getMaxRetriesGlusterProbeStatus()) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!getGlusterUtil().isHostExists(newGlusterServers, getVds())) {
                            log.info("Failed to find host '{}' in gluster peer list from '{}' on attempt {}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == getMaxRetriesGlusterProbeStatus()) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#method_after
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!getGlusterUtil().isHostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < getMaxRetriesGlusterProbeStatus()) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!getGlusterUtil().isHostExists(newGlusterServers, getVds())) {
                            log.info("Failed to find host '{}' in gluster peer list from '{}' on attempt {}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == getMaxRetriesGlusterProbeStatus()) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private List<GlusterServerInfo> getGlusterPeers(Guid upServerId) {
    List<GlusterServerInfo> glusterServers = new ArrayList<GlusterServerInfo>();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServerId));
    if (!returnValue.getSucceeded()) {
        getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
        getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
        AuditLogableBase logable = new AuditLogableBase(upServerId);
        logable.updateCallStackFromThrowable(returnValue.getExceptionObject());
        auditLogDirector.log(logable, AuditLogType.GLUSTER_SERVERS_LIST_FAILED);
        glusterPeerListSucceeded = false;
    } else {
        glusterServers = (List<GlusterServerInfo>) returnValue.getReturnValue();
    }
    return glusterServers;
}
#method_after
@SuppressWarnings("unchecked")
private List<GlusterServerInfo> getGlusterPeers(Guid upServerId) {
    List<GlusterServerInfo> glusterServers = new ArrayList<>();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServerId));
    if (!returnValue.getSucceeded()) {
        getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
        getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
        AuditLogableBase logable = new AuditLogableBase(upServerId);
        logable.updateCallStackFromThrowable(returnValue.getExceptionObject());
        auditLogDirector.log(logable, AuditLogType.GLUSTER_SERVERS_LIST_FAILED);
        glusterPeerListSucceeded = false;
    } else {
        glusterServers = (List<GlusterServerInfo>) returnValue.getReturnValue();
    }
    return glusterServers;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getCompatibilityVersion(), getParameters().getVdsGroup().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getCompatibilityVersion().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
        // create default CPU profile for cluster that is being upgraded.
        // and set all attached vms and templates with cpu profile
        Guid clusterId = getParameters().getVdsGroupId();
        if (!FeatureSupported.cpuQoS(oldGroup.getCompatibilityVersion()) && FeatureSupported.cpuQoS(getParameters().getVdsGroup().getCompatibilityVersion()) && getCpuProfileDao().getAllForCluster(clusterId).isEmpty()) {
            CpuProfile cpuProfile = CpuProfileHelper.createCpuProfile(clusterId, getParameters().getVdsGroup().getName());
            getCpuProfileDao().save(cpuProfile);
            getVmStaticDAO().updateVmCpuProfileIdForClusterId(clusterId, cpuProfile.getId());
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    // if ksm-enabled updated or ksm-merge-across-nodes updated
    if ((getVdsGroup().isKsmMergeAcrossNumaNodes() != getPrevVdsGroup().isKsmMergeAcrossNumaNodes()) || (getVdsGroup().isEnableKsm() != getPrevVdsGroup().isEnableKsm()))
        publishMomPolicyOnKsmPolicyChange();
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (isAddedToStoragePool) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        getNetworkClusterDAO().save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getCompatibilityVersion(), getParameters().getVdsGroup().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getCompatibilityVersion().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
        // create default CPU profile for cluster that is being upgraded.
        // and set all attached vms and templates with cpu profile
        Guid clusterId = getParameters().getVdsGroupId();
        if (!FeatureSupported.cpuQoS(oldGroup.getCompatibilityVersion()) && FeatureSupported.cpuQoS(getParameters().getVdsGroup().getCompatibilityVersion()) && getCpuProfileDao().getAllForCluster(clusterId).isEmpty()) {
            CpuProfile cpuProfile = CpuProfileHelper.createCpuProfile(clusterId, getParameters().getVdsGroup().getName());
            getCpuProfileDao().save(cpuProfile);
            getVmStaticDAO().updateVmCpuProfileIdForClusterId(clusterId, cpuProfile.getId());
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getVdsGroup().isKsmMergeAcrossNumaNodes() != getPrevVdsGroup().isKsmMergeAcrossNumaNodes()) || (getVdsGroup().isEnableKsm() != getPrevVdsGroup().isEnableKsm());
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    addOrUpdateAddtionalClusterFeatures();
    if (isAddedToStoragePool) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        getNetworkClusterDAO().save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getVdsGroup());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            StoragePool storagePool = getStoragePoolDAO().get(oldGroup.getStoragePoolId());
            if (storagePool != null && getVdsGroup().getCompatibilityVersion().compareTo(storagePool.getCompatibilityVersion()) < 0) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getCpuName() != null || getVdsGroup().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getVdsGroup().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getCompatibilityVersion(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getCompatibilityVersion() != null && Version.v3_3.compareTo(getVdsGroup().getCompatibilityVersion()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getCompatibilityVersion().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getVdsGroup().getCompatibilityVersion()) && getVdsGroup().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failCanDoAction(VdcBllMessages.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            StoragePool storagePool = getStoragePoolDAO().get(oldGroup.getStoragePoolId());
            if (storagePool != null && getVdsGroup().getCompatibilityVersion().compareTo(storagePool.getCompatibilityVersion()) < 0) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getCpuName() != null || getVdsGroup().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getVdsGroup().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getCompatibilityVersion(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getCompatibilityVersion() != null && Version.v3_3.compareTo(getVdsGroup().getCompatibilityVersion()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getCompatibilityVersion().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getVdsGroup().getCompatibilityVersion()) && getVdsGroup().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failCanDoAction(VdcBllMessages.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    return result;
}
#end_block

#method_before
private MapSqlParameterSource getVdsGroupParamSource(VDSGroup group) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", group.getDescription()).addValue("name", group.getName()).addValue("free_text_comment", group.getComment()).addValue("vds_group_id", group.getId()).addValue("cpu_name", group.getCpuName()).addValue("storage_pool_id", group.getStoragePoolId()).addValue("max_vds_memory_over_commit", group.getMaxVdsMemoryOverCommit()).addValue("count_threads_as_cores", group.getCountThreadsAsCores()).addValue("transparent_hugepages", group.getTransparentHugepages()).addValue("compatibility_version", group.getCompatibilityVersion()).addValue("migrate_on_error", group.getMigrateOnError()).addValue("virt_service", group.supportsVirtService()).addValue("gluster_service", group.supportsGlusterService()).addValue("gluster_cli_based_snapshot_scheduled", group.getGlusterCliBasedScheduling()).addValue("tunnel_migration", group.isTunnelMigration()).addValue("required_rng_sources", VmRngDevice.sourcesToCsv(group.getRequiredRngSources())).addValue("emulated_machine", group.getEmulatedMachine()).addValue("detect_emulated_machine", group.isDetectEmulatedMachine()).addValue("trusted_service", group.supportsTrustedService()).addValue("ha_reservation", group.supportsHaReservation()).addValue("optional_reason", group.isOptionalReasonRequired()).addValue("maintenance_reason_required", group.isMaintenanceReasonRequired()).addValue("cluster_policy_id", group.getClusterPolicyId()).addValue("cluster_policy_custom_properties", SerializationFactory.getSerializer().serialize(group.getClusterPolicyProperties())).addValue("architecture", group.getArchitecture()).addValue("enable_balloon", group.isEnableBallooning()).addValue("optimization_type", group.getOptimizationType()).addValue("enable_ksm", group.isEnableKsm()).addValue("spice_proxy", group.getSpiceProxy()).addValue("serial_number_policy", group.getSerialNumberPolicy() == null ? null : group.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", group.getCustomSerialNumber()).addValue("skip_fencing_if_sd_active", group.getFencingPolicy().isSkipFencingIfSDActive()).addValue("skip_fencing_if_connectivity_broken", group.getFencingPolicy().isSkipFencingIfConnectivityBroken()).addValue("hosts_with_broken_connectivity_threshold", group.getFencingPolicy().getHostsWithBrokenConnectivityThreshold()).addValue("fencing_enabled", group.getFencingPolicy().isFencingEnabled()).addValue("is_auto_converge", group.getAutoConverge()).addValue("is_migrate_compressed", group.getMigrateCompressed()).addValue("gluster_tuned_profile", group.getGlusterTunedProfile());
    return parameterSource;
}
#method_after
private MapSqlParameterSource getVdsGroupParamSource(VDSGroup group) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", group.getDescription()).addValue("name", group.getName()).addValue("free_text_comment", group.getComment()).addValue("vds_group_id", group.getId()).addValue("cpu_name", group.getCpuName()).addValue("storage_pool_id", group.getStoragePoolId()).addValue("max_vds_memory_over_commit", group.getMaxVdsMemoryOverCommit()).addValue("count_threads_as_cores", group.getCountThreadsAsCores()).addValue("transparent_hugepages", group.getTransparentHugepages()).addValue("compatibility_version", group.getCompatibilityVersion()).addValue("migrate_on_error", group.getMigrateOnError()).addValue("virt_service", group.supportsVirtService()).addValue("gluster_service", group.supportsGlusterService()).addValue("gluster_cli_based_snapshot_scheduled", group.isGlusterCliBasedSchedulingOn()).addValue("tunnel_migration", group.isTunnelMigration()).addValue("required_rng_sources", VmRngDevice.sourcesToCsv(group.getRequiredRngSources())).addValue("emulated_machine", group.getEmulatedMachine()).addValue("detect_emulated_machine", group.isDetectEmulatedMachine()).addValue("trusted_service", group.supportsTrustedService()).addValue("ha_reservation", group.supportsHaReservation()).addValue("optional_reason", group.isOptionalReasonRequired()).addValue("maintenance_reason_required", group.isMaintenanceReasonRequired()).addValue("cluster_policy_id", group.getClusterPolicyId()).addValue("cluster_policy_custom_properties", SerializationFactory.getSerializer().serialize(group.getClusterPolicyProperties())).addValue("architecture", group.getArchitecture()).addValue("enable_balloon", group.isEnableBallooning()).addValue("optimization_type", group.getOptimizationType()).addValue("enable_ksm", group.isEnableKsm()).addValue("spice_proxy", group.getSpiceProxy()).addValue("serial_number_policy", group.getSerialNumberPolicy() == null ? null : group.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", group.getCustomSerialNumber()).addValue("skip_fencing_if_sd_active", group.getFencingPolicy().isSkipFencingIfSDActive()).addValue("skip_fencing_if_connectivity_broken", group.getFencingPolicy().isSkipFencingIfConnectivityBroken()).addValue("hosts_with_broken_connectivity_threshold", group.getFencingPolicy().getHostsWithBrokenConnectivityThreshold()).addValue("fencing_enabled", group.getFencingPolicy().isFencingEnabled()).addValue("is_auto_converge", group.getAutoConverge()).addValue("is_migrate_compressed", group.getMigrateCompressed()).addValue("gluster_tuned_profile", group.getGlusterTunedProfile()).addValue("ksm_merge_across_nodes", group.isKsmMergeAcrossNumaNodes());
    return parameterSource;
}
#end_block

#method_before
@Override
public VDSGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
    VDSGroup entity = new VDSGroup();
    entity.setDescription(rs.getString("description"));
    entity.setName(rs.getString("name"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    entity.setTransparentHugepages(rs.getBoolean("transparent_hugepages"));
    entity.setCompatibilityVersion(new Version(rs.getString("compatibility_version")));
    entity.setMigrateOnError(MigrateOnErrorOptions.forValue(rs.getInt("migrate_on_error")));
    entity.setVirtService(rs.getBoolean("virt_service"));
    entity.setGlusterService(rs.getBoolean("gluster_service"));
    entity.setGlusterCliBasedScheduling(rs.getBoolean("gluster_cli_based_snapshot_scheduled"));
    entity.setTunnelMigration(rs.getBoolean("tunnel_migration"));
    entity.getRequiredRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("required_rng_sources")));
    entity.setEmulatedMachine(rs.getString("emulated_machine"));
    entity.setDetectEmulatedMachine(rs.getBoolean("detect_emulated_machine"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setHaReservation(rs.getBoolean("ha_reservation"));
    entity.setOptionalReasonRequired(rs.getBoolean("optional_reason"));
    entity.setMaintenanceReasonRequired(rs.getBoolean("maintenance_reason_required"));
    entity.setClusterPolicyId(Guid.createGuidFromString(rs.getString("cluster_policy_id")));
    entity.setClusterPolicyName(rs.getString("cluster_policy_name"));
    entity.setClusterPolicyProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("cluster_policy_custom_properties"), LinkedHashMap.class));
    entity.setEnableBallooning(rs.getBoolean("enable_balloon"));
    entity.setEnableKsm(rs.getBoolean("enable_ksm"));
    entity.setArchitecture(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOptimizationType(OptimizationType.from(rs.getInt("optimization_type")));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.getFencingPolicy().setSkipFencingIfSDActive(rs.getBoolean("skip_fencing_if_sd_active"));
    entity.getFencingPolicy().setSkipFencingIfConnectivityBroken(rs.getBoolean("skip_fencing_if_connectivity_broken"));
    entity.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(rs.getInt("hosts_with_broken_connectivity_threshold"));
    entity.getFencingPolicy().setFencingEnabled(rs.getBoolean("fencing_enabled"));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    entity.setGlusterTunedProfile(rs.getString("gluster_tuned_profile"));
    return entity;
}
#method_after
@Override
public VDSGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
    VDSGroup entity = new VDSGroup();
    entity.setDescription(rs.getString("description"));
    entity.setName(rs.getString("name"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    entity.setTransparentHugepages(rs.getBoolean("transparent_hugepages"));
    entity.setCompatibilityVersion(new Version(rs.getString("compatibility_version")));
    entity.setMigrateOnError(MigrateOnErrorOptions.forValue(rs.getInt("migrate_on_error")));
    entity.setVirtService(rs.getBoolean("virt_service"));
    entity.setGlusterService(rs.getBoolean("gluster_service"));
    entity.setGlusterCliBasedSchedulingOn(rs.getBoolean("gluster_cli_based_snapshot_scheduled"));
    entity.setTunnelMigration(rs.getBoolean("tunnel_migration"));
    entity.getRequiredRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("required_rng_sources")));
    entity.setEmulatedMachine(rs.getString("emulated_machine"));
    entity.setDetectEmulatedMachine(rs.getBoolean("detect_emulated_machine"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setHaReservation(rs.getBoolean("ha_reservation"));
    entity.setOptionalReasonRequired(rs.getBoolean("optional_reason"));
    entity.setMaintenanceReasonRequired(rs.getBoolean("maintenance_reason_required"));
    entity.setClusterPolicyId(Guid.createGuidFromString(rs.getString("cluster_policy_id")));
    entity.setClusterPolicyName(rs.getString("cluster_policy_name"));
    entity.setClusterPolicyProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("cluster_policy_custom_properties"), LinkedHashMap.class));
    entity.setEnableBallooning(rs.getBoolean("enable_balloon"));
    entity.setEnableKsm(rs.getBoolean("enable_ksm"));
    entity.setArchitecture(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOptimizationType(OptimizationType.from(rs.getInt("optimization_type")));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.getFencingPolicy().setSkipFencingIfSDActive(rs.getBoolean("skip_fencing_if_sd_active"));
    entity.getFencingPolicy().setSkipFencingIfConnectivityBroken(rs.getBoolean("skip_fencing_if_connectivity_broken"));
    entity.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(rs.getInt("hosts_with_broken_connectivity_threshold"));
    entity.getFencingPolicy().setFencingEnabled(rs.getBoolean("fencing_enabled"));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    entity.setGlusterTunedProfile(rs.getString("gluster_tuned_profile"));
    entity.setKsmMergeAcrossNumaNodes(rs.getBoolean("ksm_merge_across_nodes"));
    return entity;
}
#end_block

#method_before
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = getEntity();
    boolean allowRemove = true;
    boolean allowReplace = true;
    boolean allowAdvanced = true;
    if (volumeEntity == null || getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowRemove = false;
        allowReplace = false;
        allowAdvanced = false;
    } else {
        GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
        if (volumeTask != null && (volumeTask.getStatus() == JobExecutionStatus.STARTED || volumeTask.getType() == GlusterTaskType.REMOVE_BRICK && volumeTask.getStatus() == JobExecutionStatus.FINISHED)) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems().size() == volumeEntity.getBricks().size()) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && (volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT || getSelectedItems().size() > 1)) {
            allowRemove = false;
        }
        if (getSelectedItems().size() == 1) {
            allowReplace = true;
            allowAdvanced = volumeEntity.isOnline() && getSelectedItems().get(0).isOnline();
        } else {
            allowReplace = false;
            allowAdvanced = false;
        }
    }
    getRemoveBricksCommand().setIsExecutionAllowed(allowRemove);
    getReplaceBrickCommand().setIsExecutionAllowed(allowReplace);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(allowAdvanced);
}
#method_after
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = getEntity();
    boolean allowRemove = true;
    boolean allowReplace = true;
    boolean allowAdvanced = true;
    boolean allowAdd = true;
    if (volumeEntity == null || volumeEntity.getVolumeType().isDispersedType()) {
        allowRemove = false;
        allowAdd = false;
    }
    if (volumeEntity == null || getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowRemove = false;
        allowReplace = false;
        allowAdvanced = false;
    } else {
        GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
        if (volumeTask != null && (volumeTask.getStatus() == JobExecutionStatus.STARTED || volumeTask.getType() == GlusterTaskType.REMOVE_BRICK && volumeTask.getStatus() == JobExecutionStatus.FINISHED)) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems().size() == volumeEntity.getBricks().size()) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && (volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT || getSelectedItems().size() > 1)) {
            allowRemove = false;
        }
        if (getSelectedItems().size() == 1) {
            allowReplace = true;
            allowAdvanced = volumeEntity.isOnline() && getSelectedItems().get(0).isOnline();
        } else {
            allowReplace = false;
            allowAdvanced = false;
        }
    }
    getRemoveBricksCommand().setIsExecutionAllowed(allowRemove);
    getReplaceBrickCommand().setIsExecutionAllowed(allowReplace);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(allowAdvanced);
    getAddBricksCommand().setIsExecutionAllowed(allowAdd);
}
#end_block

#method_before
private void addBricks(GlusterVolumeEntity volumeEntity) {
    final VolumeBrickModel volumeBrickModel = new VolumeBrickModel();
    volumeBrickModel.getReplicaCount().setEntity(volumeEntity.getReplicaCount());
    volumeBrickModel.getReplicaCount().setIsChangable(true);
    volumeBrickModel.getReplicaCount().setIsAvailable(volumeEntity.getVolumeType().isReplicatedType());
    volumeBrickModel.getStripeCount().setEntity(volumeEntity.getStripeCount());
    volumeBrickModel.getStripeCount().setIsChangable(true);
    volumeBrickModel.getStripeCount().setIsAvailable(volumeEntity.getVolumeType().isStripedType());
    volumeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksTitle());
    volumeBrickModel.setHelpTag(HelpTag.add_bricks);
    // $NON-NLS-1$
    volumeBrickModel.setHashName("add_bricks");
    volumeBrickModel.getVolumeType().setEntity(volumeEntity.getVolumeType());
    setWindow(volumeBrickModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(volumeBrickModel);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VDSGroup cluster = (VDSGroup) result;
            volumeBrickModel.getForce().setIsAvailable(GlusterFeaturesUtil.isGlusterForceAddBricksSupported(cluster.getCompatibilityVersion()));
            volumeBrickModel.setIsBrickProvisioningSupported(GlusterFeaturesUtil.isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion()));
            AsyncQuery _asyncQueryInner = new AsyncQuery();
            _asyncQueryInner.setModel(model);
            _asyncQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) model;
                    ArrayList<VDS> hostList = (ArrayList<VDS>) result;
                    Iterator<VDS> iterator = hostList.iterator();
                    while (iterator.hasNext()) {
                        if (iterator.next().getStatus() != VDSStatus.Up) {
                            iterator.remove();
                        }
                    }
                    volumeBrickModel.setHostList(hostList);
                }
            };
            AsyncDataProvider.getInstance().getHostListByCluster(_asyncQueryInner, cluster.getName());
        }
    };
    AsyncDataProvider.getInstance().getClusterById(_asyncQuery, volumeEntity.getClusterId());
    // TODO: fetch the mount points to display
    volumeBrickModel.getBricks().setItems(new ArrayList<EntityModel<GlusterBrickEntity>>());
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("OnAddBricks", this);
    volumeBrickModel.getCommands().add(command);
    // $NON-NLS-1$
    volumeBrickModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#method_after
private void addBricks(GlusterVolumeEntity volumeEntity) {
    final VolumeBrickModel volumeBrickModel = new VolumeBrickModel();
    volumeBrickModel.getReplicaCount().setEntity(volumeEntity.getReplicaCount());
    volumeBrickModel.getReplicaCount().setIsChangeable(true);
    volumeBrickModel.getReplicaCount().setIsAvailable(volumeEntity.getVolumeType().isReplicatedType());
    volumeBrickModel.getStripeCount().setEntity(volumeEntity.getStripeCount());
    volumeBrickModel.getStripeCount().setIsChangeable(true);
    volumeBrickModel.getStripeCount().setIsAvailable(volumeEntity.getVolumeType().isStripedType());
    volumeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksTitle());
    volumeBrickModel.setHelpTag(HelpTag.add_bricks);
    // $NON-NLS-1$
    volumeBrickModel.setHashName("add_bricks");
    volumeBrickModel.getVolumeType().setEntity(volumeEntity.getVolumeType());
    setWindow(volumeBrickModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(volumeBrickModel);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VDSGroup cluster = (VDSGroup) result;
            volumeBrickModel.getForce().setIsAvailable(GlusterFeaturesUtil.isGlusterForceAddBricksSupported(cluster.getCompatibilityVersion()));
            volumeBrickModel.setIsBrickProvisioningSupported(GlusterFeaturesUtil.isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion()));
            AsyncQuery _asyncQueryInner = new AsyncQuery();
            _asyncQueryInner.setModel(model);
            _asyncQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) model;
                    ArrayList<VDS> hostList = (ArrayList<VDS>) result;
                    Iterator<VDS> iterator = hostList.iterator();
                    while (iterator.hasNext()) {
                        if (iterator.next().getStatus() != VDSStatus.Up) {
                            iterator.remove();
                        }
                    }
                    volumeBrickModel.setHostList(hostList);
                }
            };
            AsyncDataProvider.getInstance().getHostListByCluster(_asyncQueryInner, cluster.getName());
        }
    };
    AsyncDataProvider.getInstance().getClusterById(_asyncQuery, volumeEntity.getClusterId());
    // TODO: fetch the mount points to display
    volumeBrickModel.getBricks().setItems(new ArrayList<EntityModel<GlusterBrickEntity>>());
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("OnAddBricks", this);
    volumeBrickModel.getCommands().add(command);
    // $NON-NLS-1$
    volumeBrickModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
private void removeBricks() {
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    RemoveBrickModel removeBrickModel = new RemoveBrickModel();
    removeBrickModel.setHelpTag(HelpTag.volume_remove_bricks);
    // $NON-NLS-1$
    removeBrickModel.setHashName("volume_remove_bricks");
    removeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksTitle());
    setWindow(removeBrickModel);
    removeBrickModel.setReplicaCount(volumeEntity.getReplicaCount());
    removeBrickModel.setStripeCount(volumeEntity.getStripeCount());
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity item : Linq.<GlusterBrickEntity>cast(getSelectedItems())) {
        list.add(item.getQualifiedName());
    }
    removeBrickModel.setItems(list);
    if (!validateRemoveBricks(volumeEntity.getVolumeType(), Linq.<GlusterBrickEntity>cast(getSelectedItems()), volumeEntity.getBricks(), removeBrickModel)) {
        removeBrickModel.setMigrationSupported(false);
        removeBrickModel.setMessage(removeBrickModel.getValidationMessage());
    } else {
        removeBrickModel.setMigrationSupported(volumeEntity.getVolumeType().isDistributedType());
        removeBrickModel.getMigrateData().setEntity(removeBrickModel.isMigrationSupported());
        if (removeBrickModel.isReduceReplica()) {
            removeBrickModel.setMessage(ConstantsManager.getInstance().getMessages().removeBricksReplicateVolumeMessage(volumeEntity.getReplicaCount(), volumeEntity.getReplicaCount() - 1));
            removeBrickModel.setMigrationSupported(false);
            removeBrickModel.getMigrateData().setEntity(false);
        } else if (volumeEntity.getName().equals(GlusterConstants.GLUSTER_META_VOLUME_NAME)) {
            removeBrickModel.setMessage(ConstantsManager.getInstance().getConstants().removeMetaVolumeBricksMessage());
            removeBrickModel.setNote(ConstantsManager.getInstance().getConstants().removeMetaVolumeBricksWarning());
        } else {
            removeBrickModel.setMessage(ConstantsManager.getInstance().getConstants().removeBricksMessage());
        }
        // $NON-NLS-1$
        UICommand command = UICommand.createDefaultOkUiCommand("OnRemove", this);
        removeBrickModel.getCommands().add(command);
    }
    // $NON-NLS-1$
    removeBrickModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#method_after
private void removeBricks() {
    if (getSelectedItems() == null || getSelectedItems().isEmpty()) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    RemoveBrickModel removeBrickModel = new RemoveBrickModel();
    removeBrickModel.setHelpTag(HelpTag.volume_remove_bricks);
    // $NON-NLS-1$
    removeBrickModel.setHashName("volume_remove_bricks");
    removeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().removeBricksTitle());
    setWindow(removeBrickModel);
    removeBrickModel.setReplicaCount(volumeEntity.getReplicaCount());
    removeBrickModel.setStripeCount(volumeEntity.getStripeCount());
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterBrickEntity item : Linq.<GlusterBrickEntity>cast(getSelectedItems())) {
        list.add(item.getQualifiedName());
    }
    removeBrickModel.setItems(list);
    if (!validateRemoveBricks(volumeEntity.getVolumeType(), Linq.<GlusterBrickEntity>cast(getSelectedItems()), volumeEntity.getBricks(), removeBrickModel)) {
        removeBrickModel.setMigrationSupported(false);
        removeBrickModel.setMessage(removeBrickModel.getValidationMessage());
    } else {
        removeBrickModel.setMigrationSupported(volumeEntity.getVolumeType().isDistributedType());
        removeBrickModel.getMigrateData().setEntity(removeBrickModel.isMigrationSupported());
        if (removeBrickModel.isReduceReplica()) {
            if (volumeEntity.getName().equals(glusterMetaVolumeName) && volumeEntity.getReplicaCount() <= 3) {
                removeBrickModel.setMessage(ConstantsManager.getInstance().getConstants().removeMetaVolumeBricksMessage());
                removeBrickModel.setNote(ConstantsManager.getInstance().getConstants().removeMetaVolumeBricksWarning());
            } else {
                removeBrickModel.setMessage(ConstantsManager.getInstance().getMessages().removeBricksReplicateVolumeMessage(volumeEntity.getReplicaCount(), volumeEntity.getReplicaCount() - 1));
                removeBrickModel.setMigrationSupported(false);
                removeBrickModel.getMigrateData().setEntity(false);
            }
        } else {
            removeBrickModel.setMessage(ConstantsManager.getInstance().getConstants().removeBricksMessage());
        }
        // $NON-NLS-1$
        UICommand command = UICommand.createDefaultOkUiCommand("OnRemove", this);
        removeBrickModel.getCommands().add(command);
    }
    // $NON-NLS-1$
    removeBrickModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (id == null ? 0 : id.hashCode());
    result = prime * result + (compatVersion == null ? 0 : compatVersion.hashCode());
    result = prime * result + (compatibilityVersion == null ? 0 : compatibilityVersion.hashCode());
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (description == null ? 0 : description.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + (countThreadsAsCores ? 1231 : 1237);
    result = prime * result + (migrateOnError == null ? 0 : migrateOnError.hashCode());
    result = prime * result + (name == null ? 0 : name.hashCode());
    result = prime * result + (storagePoolId == null ? 0 : storagePoolId.hashCode());
    result = prime * result + (storagePoolName == null ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugepages ? 1231 : 1237);
    result = prime * result + (virtService ? 1231 : 1237);
    result = prime * result + (glusterService ? 1231 : 1237);
    result = prime * result + (glusterCliBasedScheduling ? 1231 : 1237);
    result = prime * result + (tunnelMigration ? 1231 : 1237);
    result = prime * result + (emulatedMachine == null ? 0 : emulatedMachine.hashCode());
    result = prime * result + (trustedService ? 1231 : 1237);
    result = prime * result + (haReservation ? 1231 : 1237);
    result = prime * result + (clusterPolicyName == null ? 0 : clusterPolicyName.hashCode());
    result = prime * result + (clusterPolicyProperties == null ? 0 : clusterPolicyProperties.hashCode());
    result = prime * result + (requiredRngSources == null ? 0 : requiredRngSources.hashCode());
    result = prime * result + (enableKsm ? 1231 : 1237);
    result = prime * result + (enableBallooning ? 1231 : 1237);
    result = prime * result + (optimizationType == null ? 0 : optimizationType.hashCode());
    result = prime * result + (serialNumberPolicy == null ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + (customSerialNumber == null ? 0 : customSerialNumber.hashCode());
    result = prime * result + (fencingPolicy == null ? 0 : fencingPolicy.hashCode());
    result = prime * result + (autoConverge == null ? 0 : autoConverge.hashCode());
    result = prime * result + (migrateCompressed == null ? 0 : migrateCompressed.hashCode());
    result = prime * result + (glusterTunedProfile == null ? 0 : glusterTunedProfile.hashCode());
    result = prime * result + (maintenanceReasonRequired ? 1231 : 1237);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (id == null ? 0 : id.hashCode());
    result = prime * result + (compatVersion == null ? 0 : compatVersion.hashCode());
    result = prime * result + (compatibilityVersion == null ? 0 : compatibilityVersion.hashCode());
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (description == null ? 0 : description.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + (countThreadsAsCores ? 1231 : 1237);
    result = prime * result + (migrateOnError == null ? 0 : migrateOnError.hashCode());
    result = prime * result + (name == null ? 0 : name.hashCode());
    result = prime * result + (storagePoolId == null ? 0 : storagePoolId.hashCode());
    result = prime * result + (storagePoolName == null ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugepages ? 1231 : 1237);
    result = prime * result + (virtService ? 1231 : 1237);
    result = prime * result + (glusterService ? 1231 : 1237);
    result = prime * result + (glusterCliBasedSchedulingOn ? 1231 : 1237);
    result = prime * result + (tunnelMigration ? 1231 : 1237);
    result = prime * result + (emulatedMachine == null ? 0 : emulatedMachine.hashCode());
    result = prime * result + (trustedService ? 1231 : 1237);
    result = prime * result + (haReservation ? 1231 : 1237);
    result = prime * result + (clusterPolicyName == null ? 0 : clusterPolicyName.hashCode());
    result = prime * result + (clusterPolicyProperties == null ? 0 : clusterPolicyProperties.hashCode());
    result = prime * result + (requiredRngSources == null ? 0 : requiredRngSources.hashCode());
    result = prime * result + (enableKsm ? 1231 : 1237);
    result = prime * result + (enableBallooning ? 1231 : 1237);
    result = prime * result + (optimizationType == null ? 0 : optimizationType.hashCode());
    result = prime * result + (serialNumberPolicy == null ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + (customSerialNumber == null ? 0 : customSerialNumber.hashCode());
    result = prime * result + (groupHostsAndVms == null ? 0 : groupHostsAndVms.hashCode());
    result = prime * result + (fencingPolicy == null ? 0 : fencingPolicy.hashCode());
    result = prime * result + (autoConverge == null ? 0 : autoConverge.hashCode());
    result = prime * result + (migrateCompressed == null ? 0 : migrateCompressed.hashCode());
    result = prime * result + (glusterTunedProfile == null ? 0 : glusterTunedProfile.hashCode());
    result = prime * result + (addtionalFeaturesSupported == null ? 0 : addtionalFeaturesSupported.hashCode());
    result = prime * result + (maintenanceReasonRequired ? 1231 : 1237);
    result = prime * result + (ksmMergeAcrossNumaNodes ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VDSGroup)) {
        return false;
    }
    VDSGroup other = (VDSGroup) obj;
    // cause all kinds of havoc in the UI when clusters are refreshed.
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(compatVersion, other.compatVersion) && ObjectUtils.objectsEqual(compatibilityVersion, other.compatibilityVersion) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(description, other.description) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && glusterCliBasedScheduling == other.glusterCliBasedScheduling && tunnelMigration == other.tunnelMigration && ObjectUtils.objectsEqual(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && ObjectUtils.objectsEqual(clusterPolicyId, other.clusterPolicyId) && ObjectUtils.objectsEqual(clusterPolicyName, other.clusterPolicyName) && ObjectUtils.objectsEqual(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && ObjectUtils.objectsEqual(requiredRngSources, other.requiredRngSources) && ObjectUtils.objectsEqual(fencingPolicy, other.fencingPolicy) && ObjectUtils.objectsEqual(autoConverge, other.autoConverge) && ObjectUtils.objectsEqual(migrateCompressed, other.migrateCompressed) && ObjectUtils.objectsEqual(glusterTunedProfile, other.glusterTunedProfile) && ObjectUtils.objectsEqual(maintenanceReasonRequired, other.maintenanceReasonRequired);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VDSGroup)) {
        return false;
    }
    VDSGroup other = (VDSGroup) obj;
    // cause all kinds of havoc in the UI when clusters are refreshed.
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(compatVersion, other.compatVersion) && ObjectUtils.objectsEqual(compatibilityVersion, other.compatibilityVersion) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(description, other.description) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && glusterCliBasedSchedulingOn == other.glusterCliBasedSchedulingOn && tunnelMigration == other.tunnelMigration && ObjectUtils.objectsEqual(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && ObjectUtils.objectsEqual(clusterPolicyId, other.clusterPolicyId) && ObjectUtils.objectsEqual(clusterPolicyName, other.clusterPolicyName) && ObjectUtils.objectsEqual(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && ObjectUtils.objectsEqual(groupHostsAndVms, other.groupHostsAndVms) && ObjectUtils.objectsEqual(requiredRngSources, other.requiredRngSources) && ObjectUtils.objectsEqual(fencingPolicy, other.fencingPolicy) && ObjectUtils.objectsEqual(autoConverge, other.autoConverge) && ObjectUtils.objectsEqual(migrateCompressed, other.migrateCompressed) && ObjectUtils.objectsEqual(glusterTunedProfile, other.glusterTunedProfile) && ksmMergeAcrossNumaNodes == other.ksmMergeAcrossNumaNodes && ObjectUtils.objectsEqual(maintenanceReasonRequired, other.maintenanceReasonRequired) && ObjectUtils.objectsEqual(addtionalFeaturesSupported, other.addtionalFeaturesSupported);
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    VdsDAO vdsDAO = dbFacade.getVdsDao();
    existingVds = vdsDAO.get(FixturesTool.VDS_RHEL6_NFS_SPM);
    StoragePoolDAO storagePoolDAO = dbFacade.getStoragePoolDao();
    storagePool = storagePoolDAO.get(FixturesTool.STORAGE_POOL_RHEL6_ISCSI_OTHER);
    dao = dbFacade.getVdsGroupDao();
    existingVdsGroup = dao.get(existingVds.getVdsGroupId());
    groupWithNoRunningVms = dbFacade.getVdsGroupDao().get(FixturesTool.VDS_GROUP_NO_RUNNING_VMS);
    newGroup = new VDSGroup();
    newGroup.setName("New VDS Group");
    newGroup.setCompatibilityVersion(new Version("3.0"));
    newGroup.setVirtService(true);
    newGroup.setGlusterService(false);
    newGroup.setClusterPolicyId(existingVdsGroup.getClusterPolicyId());
    clusterPolicyDao = dbFacade.getClusterPolicyDao();
    // set cluster policy name to allow equals method to succeed
    newGroup.setClusterPolicyName(clusterPolicyDao.get(existingVdsGroup.getClusterPolicyId()).getName());
    newGroup.setClusterPolicyProperties(new LinkedHashMap<String, String>());
    newGroup.setDetectEmulatedMachine(true);
    newGroup.setEmulatedMachine("rhel6.4.0");
    newGroup.setArchitecture(ArchitectureType.x86_64);
    newGroup.setGlusterCliBasedScheduling(true);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    VdsDAO vdsDAO = dbFacade.getVdsDao();
    existingVds = vdsDAO.get(FixturesTool.VDS_RHEL6_NFS_SPM);
    StoragePoolDAO storagePoolDAO = dbFacade.getStoragePoolDao();
    storagePool = storagePoolDAO.get(FixturesTool.STORAGE_POOL_RHEL6_ISCSI_OTHER);
    dao = dbFacade.getVdsGroupDao();
    existingVdsGroup = dao.get(existingVds.getVdsGroupId());
    groupWithNoRunningVms = dbFacade.getVdsGroupDao().get(FixturesTool.VDS_GROUP_NO_RUNNING_VMS);
    newGroup = new VDSGroup();
    newGroup.setName("New VDS Group");
    newGroup.setCompatibilityVersion(new Version("3.0"));
    newGroup.setVirtService(true);
    newGroup.setGlusterService(false);
    newGroup.setClusterPolicyId(existingVdsGroup.getClusterPolicyId());
    clusterPolicyDao = dbFacade.getClusterPolicyDao();
    // set cluster policy name to allow equals method to succeed
    newGroup.setClusterPolicyName(clusterPolicyDao.get(existingVdsGroup.getClusterPolicyId()).getName());
    newGroup.setClusterPolicyProperties(new LinkedHashMap<String, String>());
    newGroup.setDetectEmulatedMachine(true);
    newGroup.setEmulatedMachine("rhel6.4.0");
    newGroup.setArchitecture(ArchitectureType.x86_64);
    newGroup.setGlusterCliBasedSchedulingOn(true);
}
#end_block

#method_before
private void initEditors() {
    snapshotNameInfoIcon = new InfoIcon(templates.italicText(constants.snapshotNameInfo()));
    startAtEditor = new EntityModelDateTimeBoxEditor();
    startAtEditor.getContentWidget().setDateTimeFormat(GwtBootstrapDateTimePicker.DEFAULT_DATE_TIME_FORMAT);
    startAtEditor.getContentWidget().showDateAndTime();
    daysOfWeekEditor = new ListModelCheckBoxGroupEditor<>(new AbstractRenderer<DayOfWeek>() {

        @Override
        public String render(DayOfWeek object) {
            return object.toString().substring(0, 3);
        }
    });
    endDate = new EntityModelDateTimeBoxEditor();
    endDate.getContentWidget().setDateTimeFormat(GwtBootstrapDateTimePicker.DEFAULT_DATE_TIME_FORMAT);
    endDate.getContentWidget().showDateAndTime();
    executionTimeEditor = new EntityModelDateTimeBoxEditor();
    // $NON-NLS-1$
    executionTimeEditor.getContentWidget().setDateTimeFormat("hh:ii");
    executionTimeEditor.getContentWidget().showTimeOnly();
    recurrenceEditor = new ListModelListBoxEditor<>(new AbstractRenderer<GlusterVolumeSnapshotScheduleRecurrence>() {

        @Override
        public String render(GlusterVolumeSnapshotScheduleRecurrence object) {
            return ConstantsManager.getInstance().getMessages().recurrenceType(object);
        }
    });
    disableCliScheduleEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
}
#method_after
private void initEditors() {
    snapshotNameInfoIcon = new InfoIcon(templates.italicText(constants.snapshotNameInfo()));
    startAtEditor = new EntityModelDateTimeBoxEditor();
    startAtEditor.getContentWidget().setDateTimeFormat(GwtBootstrapDateTimePicker.DEFAULT_DATE_TIME_FORMAT);
    startAtEditor.getContentWidget().showDateAndTime();
    daysOfWeekEditor = new ListModelCheckBoxGroupEditor<>(new AbstractRenderer<DayOfWeek>() {

        @Override
        public String render(DayOfWeek object) {
            return object.toString().substring(0, 3);
        }
    });
    endDate = new EntityModelDateTimeBoxEditor();
    endDate.getContentWidget().setDateTimeFormat(GwtBootstrapDateTimePicker.DEFAULT_DATE_TIME_FORMAT);
    endDate.getContentWidget().showDateAndTime();
    executionTimeEditor = new EntityModelDateTimeBoxEditor();
    // $NON-NLS-1$
    executionTimeEditor.getContentWidget().setDateTimeFormat("hh:ii");
    executionTimeEditor.getContentWidget().showTimeOnly();
    recurrenceEditor = new ListModelListBoxEditor<>(new AbstractRenderer<GlusterVolumeSnapshotScheduleRecurrence>() {

        @Override
        public String render(GlusterVolumeSnapshotScheduleRecurrence object) {
            return ConstantsManager.getInstance().getMessages().recurrenceType(object);
        }
    });
}
#end_block

#method_before
private void localize() {
    generalTab.setLabel(constants.generalLabel());
    clusterNameEditor.setLabel(constants.volumeClusterLabel());
    volumeNameEditor.setLabel(constants.volumeNameLabel());
    snapshotNameEditor.setLabel(constants.volumeSnapshotNamePrefixLabel());
    snapshotDescriptionEditor.setLabel(constants.volumeSnapshotDescriptionLabel());
    scheduleTab.setLabel(constants.scheduleLabel());
    recurrenceEditor.setLabel(constants.recurrenceLabel());
    intervalEditor.setLabel(constants.intervalLabel());
    endByOptionsEditor.setLabel(constants.endByLabel());
    timeZoneEditor.setLabel(constants.timeZoneLabel());
    daysOfMonthEditor.setLabel(constants.daysOfMonthLabel());
    daysOfWeekEditor.setLabel(constants.daysOfWeekLabel());
    startAtEditor.setLabel(constants.startAtLabel());
    endDate.setLabel(constants.endByDateLabel());
    executionTimeEditor.setLabel(constants.executionTimeLabel());
    disableCliScheduleEditor.setLabel(constants.glusterCliSchedulingEnabled());
    criticalIntervalLabel.setText(constants.criticalSnapshotIntervalNote());
}
#method_after
private void localize() {
    generalTab.setLabel(constants.generalLabel());
    clusterNameEditor.setLabel(constants.volumeClusterLabel());
    volumeNameEditor.setLabel(constants.volumeNameLabel());
    snapshotNameEditor.setLabel(constants.volumeSnapshotNamePrefixLabel());
    snapshotDescriptionEditor.setLabel(constants.volumeSnapshotDescriptionLabel());
    scheduleTab.setLabel(constants.scheduleLabel());
    recurrenceEditor.setLabel(constants.recurrenceLabel());
    intervalEditor.setLabel(constants.intervalLabel());
    endByOptionsEditor.setLabel(constants.endByLabel());
    timeZoneEditor.setLabel(constants.timeZoneLabel());
    daysOfMonthEditor.setLabel(constants.daysOfMonthLabel());
    daysOfWeekEditor.setLabel(constants.daysOfWeekLabel());
    startAtEditor.setLabel(constants.startAtLabel());
    endDate.setLabel(constants.endByDateLabel());
    executionTimeEditor.setLabel(constants.executionTimeLabel());
    criticalIntervalLabel.setText(constants.criticalSnapshotIntervalNote());
    disableCliScheduleMessageLabel.setText(constants.glusterCliSchedulingEnabled());
}
#end_block

#method_before
private void setVisibilities() {
    criticalIntervalLabel.setVisible(false);
}
#method_after
private void setVisibilities() {
    criticalIntervalLabel.setVisible(false);
    disableCliScheduleMessageLabel.setVisible(false);
}
#end_block

#method_before
@Override
public void edit(final GlusterVolumeSnapshotModel object) {
    driver.edit(object);
    disableCliScheduleEditor.setVisible(false);
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            GlusterVolumeSnapshotModel model = (GlusterVolumeSnapshotModel) sender;
            if ("disableCliScheduleChkBox".equals(args.propertyName)) {
                // $NON-NLS-1$
                disableCliScheduleEditor.setVisible(model.isDisableCliScheduleChkBoxVisible());
            }
        }
    });
    updateVisibilities(object);
    updateTabVisibilities(object);
}
#method_after
@Override
public void edit(final GlusterVolumeSnapshotModel object) {
    driver.edit(object);
    updateVisibilities(object);
    updateTabVisibilities(object);
}
#end_block

#method_before
@Override
public void updateVisibilities(GlusterVolumeSnapshotModel object) {
    GlusterVolumeSnapshotScheduleRecurrence recurrenceOption = object.getRecurrence().getSelectedItem();
    intervalEditor.setVisible(recurrenceOption == GlusterVolumeSnapshotScheduleRecurrence.INTERVAL);
    endByOptionsEditor.setVisible(recurrenceOption != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN);
    timeZoneEditor.setVisible(recurrenceOption != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN);
    daysOfWeekEditor.setVisible(recurrenceOption == GlusterVolumeSnapshotScheduleRecurrence.WEEKLY);
    daysOfMonthEditor.setVisible(recurrenceOption == GlusterVolumeSnapshotScheduleRecurrence.MONTHLY);
    startAtEditor.setVisible(recurrenceOption != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN);
    executionTimeEditor.setVisible(recurrenceOption == GlusterVolumeSnapshotScheduleRecurrence.DAILY || recurrenceOption == GlusterVolumeSnapshotScheduleRecurrence.WEEKLY || recurrenceOption == GlusterVolumeSnapshotScheduleRecurrence.MONTHLY);
    setEndDateVisibility(object);
}
#method_after
@Override
public void updateVisibilities(GlusterVolumeSnapshotModel object) {
    GlusterVolumeSnapshotScheduleRecurrence recurrenceOption = object.getRecurrence().getSelectedItem();
    intervalEditor.setVisible(recurrenceOption == GlusterVolumeSnapshotScheduleRecurrence.INTERVAL);
    endByOptionsEditor.setVisible(recurrenceOption != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN);
    timeZoneEditor.setVisible(recurrenceOption != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN);
    daysOfWeekEditor.setVisible(recurrenceOption == GlusterVolumeSnapshotScheduleRecurrence.WEEKLY);
    daysOfMonthEditor.setVisible(recurrenceOption == GlusterVolumeSnapshotScheduleRecurrence.MONTHLY);
    startAtEditor.setVisible(recurrenceOption != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN);
    executionTimeEditor.setVisible(recurrenceOption == GlusterVolumeSnapshotScheduleRecurrence.DAILY || recurrenceOption == GlusterVolumeSnapshotScheduleRecurrence.WEEKLY || recurrenceOption == GlusterVolumeSnapshotScheduleRecurrence.MONTHLY);
    disableCliScheduleMessageLabel.setVisible(object.getDisableCliSchedule().getEntity() && recurrenceOption != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN);
    setEndDateVisibility(object);
}
#end_block

#method_before
@Override
public void setMessage(String msg) {
    super.setMessage(msg);
    errorMsgLabel.setText(msg);
}
#method_after
public void setMessage(String msg, Label errorLabel) {
    errorLabel.setText(msg);
    errorLabel.setVisible(!msg.isEmpty());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getRestoreSnapshotCommand())) {
        restoreSnapshot();
    } else if (command.equals(getDeleteSnapshotCommand())) {
        deleteSnapshot();
    } else if (command.equals(getDeleteAllSnapshotsCommand())) {
        deleteAllSnapshots();
    } else if (command.equals(getActivateSnapshotCommand())) {
        activateSnapshot();
    } else if (command.equals(getDeactivateSnapshotCommand())) {
        deactivateSnapshot();
    } else if (command.getName().equals("onRestoreSnapshot")) {
        // $NON-NLS-1$
        onRestoreSnapshot();
    } else if (command.getName().equals("onDeleteSnapshot")) {
        // $NON-NLS-1$
        onDeleteSnapshot();
    } else if (command.getName().equals("onDeleteAllSnapshots")) {
        // $NON-NLS-1$
        onDeleteAllSnapshots();
    } else if (command.getName().equals("onActivateSnapshot")) {
        // $NON-NLS-1$
        onActivateSnapshot();
    } else if (command.getName().equals("onDeactivateSnapshot")) {
        // $NON-NLS-1$
        onDeactivateSnapshot();
    } else if (command.getName().equals("cancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.equals(getCreateSnapshotCommand())) {
        createSnapshot();
    } else if (command.getName().equalsIgnoreCase("onCreateSnapshot")) {
        // $NON-NLS-1$
        onCreateSnapshot();
    } else if (command.getName().equalsIgnoreCase("cancel")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.equals(getEditSnapshotScheduleCommand())) {
        editSnapshotSchedule();
    } else if (command.getName().equalsIgnoreCase("onEditSnapshotSchedule")) {
        // $NON-NLS-1$
        onEditSnapshotSchedule();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getRestoreSnapshotCommand())) {
        restoreSnapshot();
    } else if (command.equals(getDeleteSnapshotCommand())) {
        deleteSnapshot();
    } else if (command.equals(getDeleteAllSnapshotsCommand())) {
        deleteAllSnapshots();
    } else if (command.equals(getActivateSnapshotCommand())) {
        activateSnapshot();
    } else if (command.equals(getDeactivateSnapshotCommand())) {
        deactivateSnapshot();
    } else if (command.getName().equals("onRestoreSnapshot")) {
        // $NON-NLS-1$
        onRestoreSnapshot();
    } else if (command.getName().equals("onDeleteSnapshot")) {
        // $NON-NLS-1$
        onDeleteSnapshot();
    } else if (command.getName().equals("onDeleteAllSnapshots")) {
        // $NON-NLS-1$
        onDeleteAllSnapshots();
    } else if (command.getName().equals("onActivateSnapshot")) {
        // $NON-NLS-1$
        onActivateSnapshot();
    } else if (command.getName().equals("onDeactivateSnapshot")) {
        // $NON-NLS-1$
        onDeactivateSnapshot();
    } else if (command.getName().equals("cancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.equals(getCreateSnapshotCommand())) {
        createSnapshot();
    } else if (command.getName().equalsIgnoreCase("onCreateSnapshot")) {
        // $NON-NLS-1$
        onCreateSnapshot();
    } else if (command.getName().equalsIgnoreCase("cancel")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.equals(getEditSnapshotScheduleCommand())) {
        editSnapshotSchedule();
    } else if (command.getName().equalsIgnoreCase("onEditSnapshotSchedule")) {
        // $NON-NLS-1$
        onEditSnapshotSchedule();
    } else if (command.getName().equalsIgnoreCase("onEditSnapshotScheduleInternal")) {
        // $NON-NLS-1$
        onEditSnapshotScheduleInternal();
    }
}
#end_block

#method_before
private void createSnapshot() {
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    GlusterVolumeSnapshotModel snapshotModel = new GlusterVolumeSnapshotModel(true, !volumeEntity.getSnapshotScheduled());
    snapshotModel.setHelpTag(HelpTag.new_volume_snapshot);
    // $NON-NLS-1$
    snapshotModel.setHashName("new_volume_snapshot");
    snapshotModel.setTitle(ConstantsManager.getInstance().getConstants().createScheduleVolumeSnapshotTitle());
    setWindow(snapshotModel);
    snapshotModel.getClusterName().setEntity(volumeEntity.getVdsGroupName());
    snapshotModel.getVolumeName().setEntity(volumeEntity.getName());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onCreateSnapshot", this);
    snapshotModel.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("cancel", this);
    snapshotModel.getCommands().add(cancelCommand);
}
#method_after
private void createSnapshot() {
    if (getWindow() != null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = getEntity();
    final GlusterVolumeSnapshotModel snapshotModel = new GlusterVolumeSnapshotModel(true, !volumeEntity.getSnapshotScheduled());
    snapshotModel.setHelpTag(HelpTag.new_volume_snapshot);
    // $NON-NLS-1$
    snapshotModel.setHashName("new_volume_snapshot");
    snapshotModel.setTitle(ConstantsManager.getInstance().getConstants().createScheduleVolumeSnapshotTitle());
    setWindow(snapshotModel);
    snapshotModel.startProgress(null);
    snapshotModel.getClusterName().setEntity(volumeEntity.getVdsGroupName());
    snapshotModel.getVolumeName().setEntity(volumeEntity.getName());
    AsyncDataProvider.getInstance().getIsGlusterVolumeSnapshotCliScheduleEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Boolean isCliScheduleEnabled = (Boolean) returnValue;
            snapshotModel.getDisableCliSchedule().setEntity(isCliScheduleEnabled);
            snapshotModel.stopProgress();
        }
    }), volumeEntity.getClusterId());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onCreateSnapshot", this);
    snapshotModel.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("cancel", this);
    snapshotModel.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onCreateSnapshot() {
    final GlusterVolumeSnapshotModel snapshotModel = (GlusterVolumeSnapshotModel) getWindow();
    if (!snapshotModel.validate()) {
        return;
    }
    if (!snapshotModel.isScheduleTabVisible() || snapshotModel.getRecurrence().getSelectedItem() == GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN) {
        createNewSnapshot(snapshotModel);
    } else {
        scheduleSnapshot(snapshotModel, false);
    }
}
#method_after
private void onCreateSnapshot() {
    final GlusterVolumeSnapshotModel snapshotModel = (GlusterVolumeSnapshotModel) getWindow();
    if (!snapshotModel.validate(false)) {
        return;
    }
    if (!snapshotModel.isScheduleTabVisible() || snapshotModel.getRecurrence().getSelectedItem() == GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN) {
        createNewSnapshot(snapshotModel);
    } else {
        scheduleSnapshot(snapshotModel, false);
    }
}
#end_block

#method_before
private void scheduleSnapshot(final GlusterVolumeSnapshotModel snapshotModel, boolean reschedule) {
    GlusterVolumeEntity volumeEntity = getEntity();
    final GlusterVolumeSnapshotSchedule schedule = new GlusterVolumeSnapshotSchedule();
    schedule.setSnapshotNamePrefix(snapshotModel.getSnapshotName().getEntity());
    schedule.setSnapshotDescription(snapshotModel.getDescription().getEntity());
    schedule.setClusterId(volumeEntity.getClusterId());
    schedule.setVolumeId(volumeEntity.getId());
    switch(snapshotModel.getRecurrence().getSelectedItem()) {
        case INTERVAL:
            schedule.setRecurrence(GlusterVolumeSnapshotScheduleRecurrence.INTERVAL);
            schedule.setInterval(Integer.valueOf(snapshotModel.getInterval().getSelectedItem()));
            break;
        case HOURLY:
            schedule.setRecurrence(GlusterVolumeSnapshotScheduleRecurrence.HOURLY);
            break;
        case DAILY:
            schedule.setRecurrence(GlusterVolumeSnapshotScheduleRecurrence.DAILY);
            schedule.setExecutionTime(getExecutionTime(snapshotModel));
            break;
        case WEEKLY:
            schedule.setRecurrence(GlusterVolumeSnapshotScheduleRecurrence.WEEKLY);
            schedule.setExecutionTime(getExecutionTime(snapshotModel));
            StringBuilder sb = new StringBuilder();
            for (DayOfWeek day : snapshotModel.getDaysOfTheWeek().getSelectedItem()) {
                sb.append(day.name().substring(0, 3));
                // $NON-NLS-1$
                sb.append(',');
            }
            schedule.setDays(sb.toString());
            break;
        case MONTHLY:
            schedule.setRecurrence(GlusterVolumeSnapshotScheduleRecurrence.MONTHLY);
            schedule.setExecutionTime(getExecutionTime(snapshotModel));
            schedule.setDays(snapshotModel.getDaysOfMonth().getSelectedItem());
            break;
    }
    Date startAt = snapshotModel.getStartAt().getEntity();
    schedule.setStartDate(startAt);
    schedule.setTimeZone(snapshotModel.getTimeZones().getSelectedItem());
    if (snapshotModel.getEndByOptions().getSelectedItem() == EndDateOptions.NoEndDate) {
        schedule.setEndByDate(null);
    } else {
        schedule.setEndByDate(snapshotModel.getEndDate().getEntity());
    }
    ScheduleGlusterVolumeSnapshotParameters params = new ScheduleGlusterVolumeSnapshotParameters(schedule, snapshotModel.getDisableCliSchedule().getEntity());
    snapshotModel.startProgress(null);
    VdcActionType actionType = null;
    if (reschedule) {
        actionType = VdcActionType.RescheduleGlusterVolumeSnapshot;
    } else {
        actionType = VdcActionType.ScheduleGlusterVolumeSnapshot;
    }
    Frontend.getInstance().runAction(actionType, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            GlusterVolumeSnapshotListModel localModel = (GlusterVolumeSnapshotListModel) result.getState();
            if (!result.getReturnValue().getCanDoAction()) {
                for (String entry : result.getReturnValue().getCanDoActionMessages()) {
                    if (entry.contains("Gluster CLI based scheduling is enabled")) {
                        // /$NON-NLS-1$
                        snapshotModel.setDisableCliScheduleChkBoxVisible(true);
                        break;
                    }
                }
                snapshotModel.stopProgress();
            } else {
                snapshotModel.stopProgress();
                localModel.postSnapshotAction(result.getReturnValue());
            }
        }
    }, this, snapshotModel.getDisableCliSchedule().getEntity());
}
#method_after
private void scheduleSnapshot(final GlusterVolumeSnapshotModel snapshotModel, boolean reschedule) {
    GlusterVolumeEntity volumeEntity = getEntity();
    final GlusterVolumeSnapshotSchedule schedule = new GlusterVolumeSnapshotSchedule();
    schedule.setSnapshotNamePrefix(snapshotModel.getSnapshotName().getEntity());
    schedule.setSnapshotDescription(snapshotModel.getDescription().getEntity());
    schedule.setClusterId(volumeEntity.getClusterId());
    schedule.setVolumeId(volumeEntity.getId());
    switch(snapshotModel.getRecurrence().getSelectedItem()) {
        case INTERVAL:
            schedule.setRecurrence(GlusterVolumeSnapshotScheduleRecurrence.INTERVAL);
            schedule.setInterval(Integer.valueOf(snapshotModel.getInterval().getSelectedItem()));
            break;
        case HOURLY:
            schedule.setRecurrence(GlusterVolumeSnapshotScheduleRecurrence.HOURLY);
            break;
        case DAILY:
            schedule.setRecurrence(GlusterVolumeSnapshotScheduleRecurrence.DAILY);
            schedule.setExecutionTime(getExecutionTime(snapshotModel));
            break;
        case WEEKLY:
            schedule.setRecurrence(GlusterVolumeSnapshotScheduleRecurrence.WEEKLY);
            schedule.setExecutionTime(getExecutionTime(snapshotModel));
            StringBuilder sb = new StringBuilder();
            for (DayOfWeek day : snapshotModel.getDaysOfTheWeek().getSelectedItem()) {
                sb.append(day.name().substring(0, 3));
                // $NON-NLS-1$
                sb.append(',');
            }
            schedule.setDays(sb.toString());
            break;
        case MONTHLY:
            schedule.setRecurrence(GlusterVolumeSnapshotScheduleRecurrence.MONTHLY);
            schedule.setExecutionTime(getExecutionTime(snapshotModel));
            schedule.setDays(snapshotModel.getDaysOfMonth().getSelectedItem());
            break;
    }
    Date startAt = snapshotModel.getStartAt().getEntity();
    schedule.setStartDate(startAt);
    schedule.setTimeZone(snapshotModel.getTimeZones().getSelectedItem().getKey());
    if (snapshotModel.getEndByOptions().getSelectedItem() == EndDateOptions.NoEndDate) {
        schedule.setEndByDate(null);
    } else {
        schedule.setEndByDate(snapshotModel.getEndDate().getEntity());
    }
    ScheduleGlusterVolumeSnapshotParameters params = new ScheduleGlusterVolumeSnapshotParameters(schedule, snapshotModel.getDisableCliSchedule().getEntity());
    snapshotModel.startProgress(null);
    VdcActionType actionType = null;
    if (reschedule) {
        actionType = VdcActionType.RescheduleGlusterVolumeSnapshot;
    } else {
        actionType = VdcActionType.ScheduleGlusterVolumeSnapshot;
    }
    Frontend.getInstance().runAction(actionType, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            GlusterVolumeSnapshotListModel localModel = (GlusterVolumeSnapshotListModel) result.getState();
            snapshotModel.stopProgress();
            localModel.postSnapshotAction(result.getReturnValue());
        }
    }, this, snapshotModel.getDisableCliSchedule().getEntity());
}
#end_block

#method_before
private void createNewSnapshot(final GlusterVolumeSnapshotModel snapshotModel) {
    GlusterVolumeEntity volumeEntity = getEntity();
    final GlusterVolumeSnapshotEntity snapshot = new GlusterVolumeSnapshotEntity();
    snapshot.setClusterId(volumeEntity.getClusterId());
    snapshot.setSnapshotName(snapshotModel.getSnapshotName().getEntity());
    snapshot.setVolumeId(volumeEntity.getId());
    snapshot.setDescription(snapshotModel.getDescription().getEntity());
    CreateGlusterVolumeSnapshotParameters parameter = new CreateGlusterVolumeSnapshotParameters(snapshot, true);
    snapshotModel.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.CreateGlusterVolumeSnapshot, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            GlusterVolumeSnapshotListModel localModel = (GlusterVolumeSnapshotListModel) result.getState();
            snapshotModel.stopProgress();
            localModel.postSnapshotAction(result.getReturnValue());
        }
    }, this);
}
#method_after
private void createNewSnapshot(final GlusterVolumeSnapshotModel snapshotModel) {
    GlusterVolumeEntity volumeEntity = getEntity();
    final GlusterVolumeSnapshotEntity snapshot = new GlusterVolumeSnapshotEntity();
    snapshot.setClusterId(volumeEntity.getClusterId());
    snapshot.setSnapshotName(snapshotModel.getSnapshotName().getEntity());
    snapshot.setVolumeId(volumeEntity.getId());
    snapshot.setDescription(snapshotModel.getDescription().getEntity());
    CreateGlusterVolumeSnapshotParameters parameter = new CreateGlusterVolumeSnapshotParameters(snapshot, false);
    snapshotModel.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.CreateGlusterVolumeSnapshot, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            GlusterVolumeSnapshotListModel localModel = (GlusterVolumeSnapshotListModel) result.getState();
            snapshotModel.stopProgress();
            localModel.postSnapshotAction(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
public void editSnapshotSchedule() {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final GlusterVolumeSnapshotModel snapshotModel = new GlusterVolumeSnapshotModel(true, true);
    snapshotModel.setHelpTag(HelpTag.edit_volume_snapshot_schedule);
    // $NON-NLS-1$
    snapshotModel.setHashName("edit_volume_snapshot_schedule");
    snapshotModel.setTitle(constants.editVolumeSnapshotScheduleTitle());
    setWindow(snapshotModel);
    snapshotModel.startProgress(null);
    AsyncDataProvider.getInstance().getVolumeSnapshotSchedule(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue == null) {
                snapshotModel.setMessage(ConstantsManager.getInstance().getConstants().unableToFetchVolumeSnapshotSchedule());
                return;
            }
            GlusterVolumeSnapshotSchedule schedule = (GlusterVolumeSnapshotSchedule) returnValue;
            snapshotModel.getSnapshotName().setEntity(schedule.getSnapshotNamePrefix());
            snapshotModel.getDescription().setEntity(schedule.getSnapshotDescription());
            snapshotModel.getRecurrence().setSelectedItem(schedule.getRecurrence());
            if (schedule.getEndByDate() == null) {
                snapshotModel.getEndByOptions().setSelectedItem(EndDateOptions.NoEndDate);
            } else {
                snapshotModel.getEndByOptions().setSelectedItem(EndDateOptions.HasEndDate);
                snapshotModel.getEndDate().setEntity(schedule.getEndByDate());
            }
            if (schedule.getRecurrence() != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN) {
                snapshotModel.getTimeZones().setSelectedItem(schedule.getTimeZone());
            }
            switch(schedule.getRecurrence()) {
                case INTERVAL:
                    snapshotModel.getInterval().setSelectedItem(String.valueOf(schedule.getInterval()));
                    break;
                case HOURLY:
                    break;
                case DAILY:
                    snapshotModel.getExecutionTime().setEntity(getExecutionTimeValue(schedule));
                    break;
                case WEEKLY:
                    List<DayOfWeek> daysList = new ArrayList<>();
                    for (String day : schedule.getDays().split(",")) {
                        // $NON-NLS-1$
                        daysList.add(getDayOfWeek(day));
                    }
                    snapshotModel.getDaysOfTheWeek().setSelectedItem(daysList);
                    snapshotModel.getExecutionTime().setEntity(getExecutionTimeValue(schedule));
                    break;
                case MONTHLY:
                    snapshotModel.getDaysOfMonth().setSelectedItem(schedule.getDays());
                    snapshotModel.getExecutionTime().setEntity(getExecutionTimeValue(schedule));
                    break;
            }
            snapshotModel.getStartAt().setEntity(schedule.getStartDate());
            snapshotModel.stopProgress();
        }

        private DayOfWeek getDayOfWeek(String day) {
            switch(day) {
                case // $NON-NLS-1$
                "Sun":
                    return DayOfWeek.Sunday;
                case // $NON-NLS-1$
                "Mon":
                    return DayOfWeek.Monday;
                case // $NON-NLS-1$
                "Tue":
                    return DayOfWeek.Tuesday;
                case // $NON-NLS-1$
                "Wed":
                    return DayOfWeek.Wednesday;
                case // $NON-NLS-1$
                "Thu":
                    return DayOfWeek.Thursday;
                case // $NON-NLS-1$
                "Fri":
                    return DayOfWeek.Friday;
                case // $NON-NLS-1$
                "Sat":
                    return DayOfWeek.Saturday;
                default:
                    return null;
            }
        }

        private Date getExecutionTimeValue(GlusterVolumeSnapshotSchedule schedule) {
            Date dt = new Date();
            dt.setHours(schedule.getExecutionTime().getHours());
            dt.setMinutes(schedule.getExecutionTime().getMinutes());
            return dt;
        }
    }), getEntity().getId());
    snapshotModel.getClusterName().setEntity(getEntity().getVdsGroupName());
    snapshotModel.getVolumeName().setEntity(getEntity().getName());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onEditSnapshotSchedule", this);
    snapshotModel.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("cancel", this);
    snapshotModel.getCommands().add(cancelCommand);
}
#method_after
public void editSnapshotSchedule() {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final GlusterVolumeSnapshotModel snapshotModel = new GlusterVolumeSnapshotModel(true, true);
    snapshotModel.setHelpTag(HelpTag.edit_volume_snapshot_schedule);
    // $NON-NLS-1$
    snapshotModel.setHashName("edit_volume_snapshot_schedule");
    snapshotModel.setTitle(constants.editVolumeSnapshotScheduleTitle());
    setWindow(snapshotModel);
    snapshotModel.startProgress(null);
    AsyncDataProvider.getInstance().getVolumeSnapshotSchedule(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue == null) {
                snapshotModel.setMessage(ConstantsManager.getInstance().getConstants().unableToFetchVolumeSnapshotSchedule());
                return;
            }
            final GlusterVolumeSnapshotSchedule schedule = (GlusterVolumeSnapshotSchedule) returnValue;
            snapshotModel.getSnapshotName().setEntity(schedule.getSnapshotNamePrefix());
            snapshotModel.getDescription().setEntity(schedule.getSnapshotDescription());
            snapshotModel.getRecurrence().setSelectedItem(schedule.getRecurrence());
            if (schedule.getEndByDate() == null) {
                snapshotModel.getEndByOptions().setSelectedItem(EndDateOptions.NoEndDate);
            } else {
                snapshotModel.getEndByOptions().setSelectedItem(EndDateOptions.HasEndDate);
                snapshotModel.getEndDate().setEntity(schedule.getEndByDate());
            }
            if (schedule.getRecurrence() != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN) {
                Map<String, String> timeZones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
                snapshotModel.getTimeZones().setSelectedItem(Linq.firstOrDefault(timeZones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

                    @Override
                    public boolean match(Map.Entry<String, String> item) {
                        // $NON-NLS-1$
                        return item.getKey().startsWith(schedule.getTimeZone());
                    }
                }));
            }
            switch(schedule.getRecurrence()) {
                case INTERVAL:
                    snapshotModel.getInterval().setSelectedItem(String.valueOf(schedule.getInterval()));
                    break;
                case HOURLY:
                    break;
                case DAILY:
                    snapshotModel.getExecutionTime().setEntity(getExecutionTimeValue(schedule));
                    break;
                case WEEKLY:
                    List<DayOfWeek> daysList = new ArrayList<>();
                    for (String day : schedule.getDays().split(",")) {
                        // $NON-NLS-1$
                        daysList.add(getDayOfWeek(day));
                    }
                    snapshotModel.getDaysOfTheWeek().setSelectedItem(daysList);
                    snapshotModel.getExecutionTime().setEntity(getExecutionTimeValue(schedule));
                    break;
                case MONTHLY:
                    snapshotModel.getDaysOfMonth().setSelectedItem(schedule.getDays());
                    snapshotModel.getExecutionTime().setEntity(getExecutionTimeValue(schedule));
                    break;
            }
            snapshotModel.getStartAt().setEntity(schedule.getStartDate());
            snapshotModel.stopProgress();
        }

        private DayOfWeek getDayOfWeek(String day) {
            switch(day) {
                case // $NON-NLS-1$
                "Sun":
                    return DayOfWeek.Sunday;
                case // $NON-NLS-1$
                "Mon":
                    return DayOfWeek.Monday;
                case // $NON-NLS-1$
                "Tue":
                    return DayOfWeek.Tuesday;
                case // $NON-NLS-1$
                "Wed":
                    return DayOfWeek.Wednesday;
                case // $NON-NLS-1$
                "Thu":
                    return DayOfWeek.Thursday;
                case // $NON-NLS-1$
                "Fri":
                    return DayOfWeek.Friday;
                case // $NON-NLS-1$
                "Sat":
                    return DayOfWeek.Saturday;
                default:
                    return null;
            }
        }

        private Date getExecutionTimeValue(GlusterVolumeSnapshotSchedule schedule) {
            Date dt = new Date();
            dt.setHours(schedule.getExecutionTime().getHours());
            dt.setMinutes(schedule.getExecutionTime().getMinutes());
            return dt;
        }
    }), getEntity().getId());
    snapshotModel.getClusterName().setEntity(getEntity().getVdsGroupName());
    snapshotModel.getVolumeName().setEntity(getEntity().getName());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onEditSnapshotSchedule", this);
    snapshotModel.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("cancel", this);
    snapshotModel.getCommands().add(cancelCommand);
}
#end_block

#method_before
public void onEditSnapshotSchedule() {
    final GlusterVolumeSnapshotModel snapshotModel = (GlusterVolumeSnapshotModel) getWindow();
    if (!snapshotModel.validate()) {
        return;
    }
    scheduleSnapshot(snapshotModel, true);
}
#method_after
public void onEditSnapshotSchedule() {
    final GlusterVolumeSnapshotModel snapshotModel = (GlusterVolumeSnapshotModel) getWindow();
    if (snapshotModel.getRecurrence().getSelectedItem() == GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN) {
        confirmDeleteVolumeSnapshotSchedule();
    } else {
        onEditSnapshotScheduleInternal();
    }
}
#end_block

#method_before
private void newVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    volumeModel.setHelpTag(HelpTag.new_volume);
    // $NON-NLS-1$
    volumeModel.setHashName("new_volume");
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().newVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangable(false);
                        innerVolumeModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = UICommand.createDefaultOkUiCommand("onCreateVolume", volumeListModel);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            innerVolumeModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", volumeListModel));
        }
    };
    AsyncDataProvider.getInstance().getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#method_after
private void newVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    volumeModel.setHelpTag(HelpTag.new_volume);
    // $NON-NLS-1$
    volumeModel.setHashName("new_volume");
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().newVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangeable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangeable(false);
                        innerVolumeModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangeable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = UICommand.createDefaultOkUiCommand("onCreateVolume", volumeListModel);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            innerVolumeModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", volumeListModel));
        }
    };
    AsyncDataProvider.getInstance().getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#end_block

#method_before
private boolean isMetaVolumeInList(List<GlusterVolumeEntity> volumes) {
    for (GlusterVolumeEntity volume : volumes) {
        if (volume.getName().equals(GlusterConstants.GLUSTER_META_VOLUME_NAME)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isMetaVolumeInList(List<GlusterVolumeEntity> volumes) {
    for (GlusterVolumeEntity volume : volumes) {
        if (volume.getName().equals(glusterMetaVolumeName)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    boolean allowStartProfiling = false;
    boolean allowStopProfiling = false;
    boolean allowProfileStatisticsDetails = false;
    boolean allowConfigureClusterSnapshotOptions = true;
    boolean allowConfigureVolumeSnapshotOptions = false;
    boolean allowCreateSnapshot = false;
    boolean allowEditSnapshotSchedule = false;
    boolean allowCreateGeoRepSession = false;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        List<GlusterVolumeEntity> list = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
        allowStartProfiling = isStartProfileAvailable(list);
        allowStopProfiling = isStopProfileAvailable(list);
        for (GlusterVolumeEntity volume : list) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            GlusterAsyncTask asyncTask = volume.getAsyncTask();
            if (asyncTask != null) {
                allowStartRebalance = allowStartRebalance && asyncTask.getStatus() == null ? asyncTask.getJobStatus() != JobExecutionStatus.STARTED : asyncTask.getStatus() != JobExecutionStatus.STARTED;
            }
        }
        if (list.size() == 1) {
            GlusterVolumeEntity volumeEntity = list.get(0);
            GlusterAsyncTask asyncTask = volumeEntity.getAsyncTask();
            allowStopRebalance = volumeEntity.getStatus() == GlusterStatus.UP && asyncTask != null && asyncTask.getType() == GlusterTaskType.REBALANCE && asyncTask.getStatus() == JobExecutionStatus.STARTED;
            allowConfigureVolumeSnapshotOptions = volumeEntity.getStatus() == GlusterStatus.UP;
            allowCreateGeoRepSession = volumeEntity.getStatus() == GlusterStatus.UP;
        } else {
            allowStopRebalance = false;
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
        allowProfileStatisticsDetails = getProfileStatisticsAvailability(list);
        allowCreateSnapshot = isCreateSnapshotAvailable(list);
        allowEditSnapshotSchedule = isEditSnapshotScheduleAvailable(list);
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    getConfigureClusterSnapshotOptionsCommand().setIsExecutionAllowed(allowConfigureClusterSnapshotOptions);
    getConfigureVolumeSnapshotOptionsCommand().setIsExecutionAllowed(allowConfigureVolumeSnapshotOptions);
    getCreateSnapshotCommand().setIsExecutionAllowed(allowCreateSnapshot);
    getEditSnapshotScheduleCommand().setIsExecutionAllowed(allowEditSnapshotSchedule);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
    getStartVolumeProfilingCommand().setIsExecutionAllowed(allowStartProfiling);
    getStopVolumeProfilingCommand().setIsExecutionAllowed(allowStopProfiling);
    getShowVolumeProfileDetailsCommand().setIsExecutionAllowed(allowProfileStatisticsDetails);
    getNewGeoRepSessionCommand().setIsExecutionAllowed(allowCreateGeoRepSession);
}
#method_after
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    boolean allowStartProfiling = false;
    boolean allowStopProfiling = false;
    boolean allowProfileStatisticsDetails = false;
    boolean allowConfigureClusterSnapshotOptions = true;
    boolean allowConfigureVolumeSnapshotOptions = false;
    boolean allowCreateSnapshot = false;
    boolean allowEditSnapshotSchedule = false;
    boolean allowCreateGeoRepSession = false;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        List<GlusterVolumeEntity> list = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
        allowStartProfiling = isStartProfileAvailable(list);
        allowStopProfiling = isStopProfileAvailable(list);
        for (GlusterVolumeEntity volume : list) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            GlusterAsyncTask asyncTask = volume.getAsyncTask();
            if (asyncTask != null) {
                allowStartRebalance = allowStartRebalance && asyncTask.getStatus() == null ? asyncTask.getJobStatus() != JobExecutionStatus.STARTED : asyncTask.getStatus() != JobExecutionStatus.STARTED;
            }
        }
        if (list.size() == 1) {
            GlusterVolumeEntity volumeEntity = list.get(0);
            GlusterAsyncTask asyncTask = volumeEntity.getAsyncTask();
            allowStopRebalance = volumeEntity.getStatus() == GlusterStatus.UP && asyncTask != null && asyncTask.getType() == GlusterTaskType.REBALANCE && asyncTask.getStatus() == JobExecutionStatus.STARTED;
            allowConfigureVolumeSnapshotOptions = volumeEntity.getStatus() == GlusterStatus.UP;
            allowCreateGeoRepSession = volumeEntity.getStatus() == GlusterStatus.UP;
            allowCreateSnapshot = isCreateSnapshotAvailable(volumeEntity);
        } else {
            allowStopRebalance = false;
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
        allowProfileStatisticsDetails = getProfileStatisticsAvailability(list);
        allowEditSnapshotSchedule = isEditSnapshotScheduleAvailable(list);
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    getConfigureClusterSnapshotOptionsCommand().setIsExecutionAllowed(allowConfigureClusterSnapshotOptions);
    getConfigureVolumeSnapshotOptionsCommand().setIsExecutionAllowed(allowConfigureVolumeSnapshotOptions);
    getCreateSnapshotCommand().setIsExecutionAllowed(allowCreateSnapshot);
    getEditSnapshotScheduleCommand().setIsExecutionAllowed(allowEditSnapshotSchedule);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
    getStartVolumeProfilingCommand().setIsExecutionAllowed(allowStartProfiling);
    getStopVolumeProfilingCommand().setIsExecutionAllowed(allowStopProfiling);
    getShowVolumeProfileDetailsCommand().setIsExecutionAllowed(allowProfileStatisticsDetails);
    getNewGeoRepSessionCommand().setIsExecutionAllowed(allowCreateGeoRepSession);
}
#end_block

#method_before
private boolean isCreateSnapshotAvailable(List<GlusterVolumeEntity> list) {
    return ((list.size() == 1) && (list.get(0).getStatus() == GlusterStatus.UP));
}
#method_after
private boolean isCreateSnapshotAvailable(GlusterVolumeEntity volume) {
    if (volume.getStatus() == GlusterStatus.UP) {
        List<GlusterBrickEntity> bricks = volume.getBricks();
        for (GlusterBrickEntity brick : bricks) {
            if (brick.getStatus() != GlusterStatus.UP) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
public void configureClusterSnapshotOptions() {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final GlusterClusterSnapshotConfigModel clusterSnapshotConfigModel = new GlusterClusterSnapshotConfigModel();
    clusterSnapshotConfigModel.setHelpTag(HelpTag.configure_volume_snapshot);
    // $NON-NLS-1$
    clusterSnapshotConfigModel.setHashName("configure_volume_snapshot");
    clusterSnapshotConfigModel.setTitle(ConstantsManager.getInstance().getConstants().configureClusterSnapshotOptionsTitle());
    setWindow(clusterSnapshotConfigModel);
    AsyncDataProvider.getInstance().getClusterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object returnValue) {
            if (getSystemTreeSelectedItem() != null) {
                VDSGroup selectedCluster = (VDSGroup) getSystemTreeSelectedItem().getEntity();
                clusterSnapshotConfigModel.getClusters().setItems((List<VDSGroup>) returnValue, selectedCluster);
            } else {
                if (getSelectedItems() != null) {
                    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItems().get(0);
                    if (volumeEntity != null) {
                        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue1) {
                                clusterSnapshotConfigModel.getClusters().setItems((List<VDSGroup>) returnValue, (VDSGroup) returnValue1);
                            }
                        }), volumeEntity.getClusterId());
                    }
                } else {
                    clusterSnapshotConfigModel.getClusters().setItems((List<VDSGroup>) returnValue);
                }
            }
        }
    }));
    clusterSnapshotConfigModel.getClusterConfigOptions().setTitle(ConstantsManager.getInstance().getConstants().configureClusterSnapshotOptionsTitle());
    // $NON-NLS-1$
    UICommand updateCommand = new UICommand("confirmConfigureClusterSnapshotOptions", this);
    updateCommand.setTitle(constants.snapshotConfigUpdateButtonLabel());
    updateCommand.setIsDefault(true);
    clusterSnapshotConfigModel.getCommands().add(updateCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(constants.cancel());
    cancelCommand.setIsCancel(true);
    clusterSnapshotConfigModel.getCommands().add(cancelCommand);
}
#method_after
public void configureClusterSnapshotOptions() {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final GlusterClusterSnapshotConfigModel clusterSnapshotConfigModel = new GlusterClusterSnapshotConfigModel();
    clusterSnapshotConfigModel.setHelpTag(HelpTag.configure_volume_snapshot);
    // $NON-NLS-1$
    clusterSnapshotConfigModel.setHashName("configure_volume_snapshot");
    clusterSnapshotConfigModel.setTitle(ConstantsManager.getInstance().getConstants().configureClusterSnapshotOptionsTitle());
    setWindow(clusterSnapshotConfigModel);
    AsyncDataProvider.getInstance().getClustersHavingHosts(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object returnValue) {
            if (getSystemTreeSelectedItem() != null) {
                VDSGroup selectedCluster = (VDSGroup) getSystemTreeSelectedItem().getEntity();
                clusterSnapshotConfigModel.getClusters().setItems((List<VDSGroup>) returnValue, selectedCluster);
            } else {
                if (getSelectedItems() != null) {
                    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItems().get(0);
                    if (volumeEntity != null) {
                        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue1) {
                                clusterSnapshotConfigModel.getClusters().setItems((List<VDSGroup>) returnValue, (VDSGroup) returnValue1);
                            }
                        }), volumeEntity.getClusterId());
                    }
                } else {
                    clusterSnapshotConfigModel.getClusters().setItems((List<VDSGroup>) returnValue);
                }
            }
        }
    }));
    clusterSnapshotConfigModel.getClusterConfigOptions().setTitle(ConstantsManager.getInstance().getConstants().configureClusterSnapshotOptionsTitle());
    // $NON-NLS-1$
    UICommand updateCommand = new UICommand("confirmConfigureClusterSnapshotOptions", this);
    updateCommand.setTitle(constants.snapshotConfigUpdateButtonLabel());
    updateCommand.setIsDefault(true);
    clusterSnapshotConfigModel.getCommands().add(updateCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(constants.cancel());
    cancelCommand.setIsCancel(true);
    clusterSnapshotConfigModel.getCommands().add(cancelCommand);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Check and disable the gluster CLI based snapshot scheduling first
    if (!checkAndDisableCLIScheduler()) {
        return;
    }
    // Keep a copy of the execution time before conversion to engine time zone during scheduling
    Time originalExecutionTime = getSchedule().getExecutionTime();
    // schedule the snapshot creation task
    String jobId = scheduleJob();
    if (jobId != null) {
        setSucceeded(true);
        getSchedule().setJobId(jobId);
        // reverting to original execution time in UI populated time zone
        getSchedule().setExecutionTime(originalExecutionTime);
        getGlusterVolumeSnapshotScheduleDao().save(getSchedule());
    } else {
        setSucceeded(false);
    }
}
#method_after
@Override
protected void executeCommand() {
    // Check and disable the gluster CLI based snapshot scheduling first
    if (!checkAndDisableCliScheduler()) {
        setSucceeded(false);
        return;
    }
    // Keep a copy of the execution time before conversion to engine time zone during scheduling
    Time originalExecutionTime = getSchedule().getExecutionTime();
    // schedule the snapshot creation task
    try {
        String jobId = scheduleJob();
        setSucceeded(true);
        getSchedule().setJobId(jobId);
        // reverting to original execution time in UI populated time zone
        getSchedule().setExecutionTime(originalExecutionTime);
        getGlusterVolumeSnapshotScheduleDao().save(getSchedule());
    } catch (Exception ex) {
        setSucceeded(false);
        handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SCHEDULE_FAILED, ex.getMessage());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeSnapshotSchedule fetchedSchedule = getGlusterVolumeSnapshotScheduleDao().getByVolumeId(getGlusterVolumeId());
    if (fetchedSchedule != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SNAPSHOT_ALREADY_SCHEDULED);
    }
    if (!getParameters().getForce()) {
        if (getGlusterVolumeDao().getByName(getVdsGroupId(), GlusterConstants.GLUSTER_META_VOLUME_NAME) != null && getVdsGroup().getGlusterCliBasedScheduling()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_CLI_SCHEDULING_ENABLED);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeSnapshotSchedule fetchedSchedule = getGlusterVolumeSnapshotScheduleDao().getByVolumeId(getGlusterVolumeId());
    if (fetchedSchedule != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SNAPSHOT_ALREADY_SCHEDULED);
    }
    if (!getParameters().getForce()) {
        if (getGlusterVolumeDao().getByName(getVdsGroupId(), Config.<String>getValue(ConfigValues.GlusterMetaVolumeName)) != null && getVdsGroup().isGlusterCliBasedSchedulingOn()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_CLI_SCHEDULING_ENABLED);
        }
    }
    return true;
}
#end_block

#method_before
private void createCluster(Version version) {
    existingCluster = new VDSGroup();
    existingCluster.setId(CLUSTER_ID);
    existingCluster.setName("cluster");
    existingCluster.setGlusterService(true);
    existingCluster.setVirtService(false);
    existingCluster.setCompatibilityVersion(version);
    existingCluster.setGlusterCliBasedScheduling(true);
    createObjects(version);
}
#method_after
private void createCluster(Version version) {
    existingCluster = new VDSGroup();
    existingCluster.setId(CLUSTER_ID);
    existingCluster.setName("cluster");
    existingCluster.setGlusterService(true);
    existingCluster.setVirtService(false);
    existingCluster.setCompatibilityVersion(version);
    existingCluster.setGlusterCliBasedSchedulingOn(true);
    createObjects(version);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void setupMocks() throws Exception {
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    glusterManager = Mockito.spy(GlusterSyncJob.getInstance());
    glusterManager.setLogUtil(logUtil);
    mockDaos();
    doReturn(clusterUtils).when(glusterManager).getClusterUtils();
    doReturn(existingServer1).when(clusterUtils).getUpServer(any(Guid.class));
    doReturn(existingServer1).when(clusterUtils).getRandomUpServer(any(Guid.class));
    doNothing().when(logUtil).logServerMessage(any(VDS.class), any(AuditLogType.class));
    doNothing().when(logUtil).logVolumeMessage(any(GlusterVolumeEntity.class), any(AuditLogType.class));
    doNothing().when(logUtil).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(HashMap.class));
    doReturn(getFetchedServersList()).when(glusterManager).fetchServers(any(VDS.class));
    doReturn(getFetchedVolumesList()).when(glusterManager).fetchVolumes(any(VDS.class));
    doReturn(getVolumeAdvancedDetails(existingDistVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    doReturn(getVolumeAdvancedDetails(existingReplVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    doReturn(new VDSReturnValue()).when(glusterManager).runVdsCommand(eq(VDSCommandType.RemoveVds), argThat(isRemovedServer()));
    doReturn(new VDSReturnValue()).when(glusterManager).runVdsCommand(eq(VDSCommandType.EnableGlusterVolumeSnapshotScheduling), argThat(isSnapshotSchedulingParameter()));
    doNothing().when(glusterManager).acquireLock(CLUSTER_ID);
    doNothing().when(glusterManager).releaseLock(CLUSTER_ID);
    doReturn(glusterUtil).when(glusterManager).getGlusterUtil();
}
#method_after
@SuppressWarnings("unchecked")
private void setupMocks() throws Exception {
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    glusterManager = Mockito.spy(GlusterSyncJob.getInstance());
    glusterManager.setLogUtil(logUtil);
    mockDaos();
    doReturn(clusterUtils).when(glusterManager).getClusterUtils();
    doReturn(existingServer1).when(clusterUtils).getUpServer(any(Guid.class));
    doReturn(existingServer1).when(clusterUtils).getRandomUpServer(any(Guid.class));
    doNothing().when(logUtil).logServerMessage(any(VDS.class), any(AuditLogType.class));
    doNothing().when(logUtil).logVolumeMessage(any(GlusterVolumeEntity.class), any(AuditLogType.class));
    doNothing().when(logUtil).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(HashMap.class));
    doNothing().when(logUtil).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(Guid.class), any(String.class));
    doReturn(getFetchedServersList()).when(glusterManager).fetchServers(any(VDS.class));
    doReturn(getFetchedVolumesList()).when(glusterManager).fetchVolumes(any(VDS.class));
    doReturn(getVolumeAdvancedDetails(existingDistVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    doReturn(getVolumeAdvancedDetails(existingReplVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    doReturn(new VDSReturnValue()).when(glusterManager).runVdsCommand(eq(VDSCommandType.RemoveVds), argThat(isRemovedServer()));
    doReturn(mockVdcReturn()).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class), any(CommandContext.class));
    doNothing().when(glusterManager).acquireLock(CLUSTER_ID);
    doNothing().when(glusterManager).releaseLock(CLUSTER_ID);
    doReturn(glusterUtil).when(glusterManager).getGlusterUtil();
}
#end_block

#method_before
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeGeoRepSessionStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeGeoRepSessionPauseFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailedException:
        case GlusterHostIsNotPartOfCluster:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeEmptyCheckFailed:
        case GlusterGeoRepPublicKeyFileCreateFailed:
        case GlusterGeoRepPublicKeyFileReadError:
        case GlusterGeoRepUserNotFound:
        case GlusterGeoRepPublicKeyWriteFailed:
        case GlusterGeoRepExecuteMountBrokerOptFailed:
        case GlusterGeoRepExecuteMountBrokerUserAddFailed:
        case GlusterMountBrokerRootCreateFailed:
        case GlusterGeoRepSessionCreateFailed:
        case GlusterVolumeGeoRepSessionResumeFailed:
        case GlusterGeoRepException:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
        case GlusterVolumeGeoRepStatusFailed:
        case GlusterGeoRepConfigFailed:
        case GlusterLibgfapiException:
        case GlfsStatvfsException:
        case GlfsInitException:
        case GlfsFiniException:
        case GlusterGeoRepSessionDeleteFailedException:
        case GlusterVolumeGeoRepSessionStopFailed:
        case GlusterSnapshotException:
        case GlusterSnapshotInfoFailedException:
        case GlusterSnapshotDeleteFailedException:
        case GlusterSnapshotActivateFailedException:
        case GlusterSnapshotDeactivateFailedException:
        case GlusterSnapshotRestoreFailedException:
        case GlusterSnapshotCreateFailedException:
        case GlusterSnapshotConfigFailedException:
        case GlusterSnapshotConfigSetFailedException:
        case GlusterSnapshotConfigGetFailedException:
        case GlusterHostStorageDeviceNotFoundException:
        case GlusterHostStorageDeviceInUseException:
        case GlusterHostStorageDeviceMountFailedException:
        case GlusterHostStorageDeviceMkfsFailedException:
        case GlusterHostStorageDeviceFsTabFoundException:
        case GlusterHostStorageDevicePVCreateFailedException:
        case GlusterHostStorageDeviceLVConvertFailedException:
        case GlusterHostStorageDeviceLVChangeFailedException:
        case GlusterEngineSnapshotScheduleFlagSetFailedException:
        case GlusterCliSnapshotSchedulingDisableFailedException:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeGeoRepSessionStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeGeoRepSessionPauseFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailedException:
        case GlusterHostIsNotPartOfCluster:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeEmptyCheckFailed:
        case GlusterGeoRepPublicKeyFileCreateFailed:
        case GlusterGeoRepPublicKeyFileReadError:
        case GlusterGeoRepUserNotFound:
        case GlusterGeoRepPublicKeyWriteFailed:
        case GlusterGeoRepExecuteMountBrokerOptFailed:
        case GlusterGeoRepExecuteMountBrokerUserAddFailed:
        case GlusterMountBrokerRootCreateFailed:
        case GlusterGeoRepSessionCreateFailed:
        case GlusterVolumeGeoRepSessionResumeFailed:
        case GlusterGeoRepException:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
        case GlusterVolumeGeoRepStatusFailed:
        case GlusterGeoRepConfigFailed:
        case GlusterLibgfapiException:
        case GlfsStatvfsException:
        case GlfsInitException:
        case GlfsFiniException:
        case GlusterGeoRepSessionDeleteFailedException:
        case GlusterVolumeGeoRepSessionStopFailed:
        case GlusterSnapshotException:
        case GlusterSnapshotInfoFailedException:
        case GlusterSnapshotDeleteFailedException:
        case GlusterSnapshotActivateFailedException:
        case GlusterSnapshotDeactivateFailedException:
        case GlusterSnapshotRestoreFailedException:
        case GlusterSnapshotCreateFailedException:
        case GlusterSnapshotConfigFailedException:
        case GlusterSnapshotConfigSetFailedException:
        case GlusterSnapshotConfigGetFailedException:
        case GlusterHostStorageDeviceNotFoundException:
        case GlusterHostStorageDeviceInUseException:
        case GlusterHostStorageDeviceMountFailedException:
        case GlusterHostStorageDeviceMkfsFailedException:
        case GlusterHostStorageDeviceFsTabFoundException:
        case GlusterHostStorageDevicePVCreateFailedException:
        case GlusterHostStorageDeviceLVConvertFailedException:
        case GlusterHostStorageDeviceLVChangeFailedException:
        case GlusterSnapshotScheduleFlagUpdateFailedException:
        case GlusterDisableSnapshotScheduleFailedException:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc migrateStatus(String vmId) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.migrateStatus(vmId);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public MigrateStatusReturnForXmlRpc migrateStatus(String vmId) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.migrateStatus(vmId);
        return new MigrateStatusReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(userName, remoteGroupName, remoteVolumeName);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(userName, remoteGroupName, remoteVolumeName, partial);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc migrateStatus(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getMigrationStatus").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public MigrateStatusReturnForXmlRpc migrateStatus(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getMigrationStatus").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("response").withResponseType(Long.class);
    return new MigrateStatusReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withParameter("partial", partial).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public OneStorageDeviceReturnForXmlRpc glusterCreateBrick(String lvName, String mountPoint, Map<String, Object> raidParams, String fsType, String[] storageDevices) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.createBrick").withParameter("brickName", lvName).withParameter("mountPoint", mountPoint).withParameter("devices", storageDevices).withParameter("fsType", fsType).withOptionalParameterAsMap("raidParams", raidParams).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneStorageDeviceReturnForXmlRpc(response);
}
#method_after
@Override
public OneStorageDeviceReturnForXmlRpc glusterCreateBrick(String lvName, String mountPoint, Map<String, Object> raidParams, String fsType, String[] storageDevices) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.createBrick").withParameter("name", lvName).withParameter("mountPoint", mountPoint).withParameter("devList", storageDevices).withParameter("fsType", fsType).withOptionalParameterAsMap("raidParams", raidParams).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneStorageDeviceReturnForXmlRpc(response);
}
#end_block

#method_before
private void init() {
    setDataCenter(new EntityModel<String>());
    setClusterName(new EntityModel<String>());
    setVolumeName(new EntityModel<String>());
    setSnapshotName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setRecurrence(new ListModel<GlusterVolumeSnapshotScheduleRecurrence>());
    setInterval(new ListModel<String>());
    setEndByOptions(new ListModel<EndDateOptions>());
    setTimeZones(new ListModel<String>());
    setDaysOfMonth(new ListModel<String>());
    setStartAt(new EntityModel<>(new Date()));
    setEndDate(new EntityModel<>(new Date()));
    setExecutionTime(new EntityModel<>(new Date()));
    setDisableCliSchedule(new EntityModel<>(false));
    initIntervals();
    initTimeZones();
    recurrence.setItems(Arrays.asList(GlusterVolumeSnapshotScheduleRecurrence.values()), GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN);
    endByOptions.setItems(Arrays.asList(EndDateOptions.values()));
    List<String> values = new ArrayList<>();
    for (DayOfWeek day : DayOfWeek.values()) {
        values.add(day.toString().substring(0, 3));
    }
    daysOfWeek = new ListModel<>();
    List<DayOfWeek> daysList = Arrays.asList(DayOfWeek.values());
    List<List<DayOfWeek>> list = new ArrayList<>();
    list.add(daysList);
    daysOfWeek.setItems(list, new ArrayList<DayOfWeek>());
}
#method_after
private void init() {
    setDataCenter(new EntityModel<String>());
    setClusterName(new EntityModel<String>());
    setVolumeName(new EntityModel<String>());
    setSnapshotName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setRecurrence(new ListModel<GlusterVolumeSnapshotScheduleRecurrence>());
    setInterval(new ListModel<String>());
    setEndByOptions(new ListModel<EndDateOptions>());
    setTimeZones(new ListModel<Map.Entry<String, String>>());
    setDaysOfMonth(new ListModel<String>());
    setStartAt(new EntityModel<>(new Date()));
    setEndDate(new EntityModel<>(new Date()));
    setExecutionTime(new EntityModel<>(new Date()));
    setDisableCliSchedule(new EntityModel<>(false));
    initIntervals();
    initTimeZones();
    recurrence.setItems(Arrays.asList(GlusterVolumeSnapshotScheduleRecurrence.values()), GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN);
    endByOptions.setItems(Arrays.asList(EndDateOptions.values()));
    List<String> values = new ArrayList<>();
    for (DayOfWeek day : DayOfWeek.values()) {
        values.add(day.toString().substring(0, 3));
    }
    daysOfWeek = new ListModel<>();
    List<DayOfWeek> daysList = Arrays.asList(DayOfWeek.values());
    List<List<DayOfWeek>> list = new ArrayList<>();
    list.add(daysList);
    daysOfWeek.setItems(list, new ArrayList<DayOfWeek>());
}
#end_block

#method_before
private void initTimeZones() {
    Set<String> timeZoneTypes = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList().keySet();
    getTimeZones().setItems(timeZoneTypes);
}
#method_after
private void initTimeZones() {
    Map<String, String> timeZones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
    getTimeZones().setItems(timeZones.entrySet());
    getTimeZones().setSelectedItem(Linq.firstOrDefault(timeZones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
}
#end_block

#method_before
public ListModel<String> getTimeZones() {
    return timeZones;
}
#method_after
public ListModel<Map.Entry<String, String>> getTimeZones() {
    return timeZones;
}
#end_block

#method_before
public void setTimeZones(ListModel<String> timeZones) {
    this.timeZones = timeZones;
}
#method_after
public void setTimeZones(ListModel<Map.Entry<String, String>> timeZones) {
    this.timeZones = timeZones;
}
#end_block

#method_before
public boolean validate() {
    boolean validWeekDays = true;
    boolean validMonthDays = true;
    boolean validEndDate = true;
    getSnapshotName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(128), new AsciiNameValidation() });
    if (getRecurrence().getSelectedItem() == GlusterVolumeSnapshotScheduleRecurrence.WEEKLY && (getDaysOfTheWeek().getSelectedItem() == null || getDaysOfTheWeek().getSelectedItem().isEmpty())) {
        setMessage(ConstantsManager.getInstance().getConstants().noWeekDaysSelectedMessage());
        validWeekDays = false;
    }
    if (getRecurrence().getSelectedItem() == GlusterVolumeSnapshotScheduleRecurrence.MONTHLY) {
        if (getDaysOfMonth().getSelectedItem() == null || getDaysOfMonth().getSelectedItem().equals("")) {
            // $NON-NLS-1$
            setMessage(ConstantsManager.getInstance().getConstants().noMonthDaysSelectedMessage());
            validMonthDays = false;
        } else if (getDaysOfMonth().getSelectedItem().contains(",L") || getDaysOfMonth().getSelectedItem().contains("L,")) {
            // $NON-NLS-1$//$NON-NLS-2$
            setMessage(ConstantsManager.getInstance().getConstants().lastDayMonthCanBeSelectedAlone());
            validMonthDays = false;
        }
    }
    if (getRecurrence().getSelectedItem() != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN && getEndByOptions().getSelectedItem() == EndDateOptions.HasEndDate && getEndDate().getEntity().compareTo(getStartAt().getEntity()) <= 0) {
        setMessage(ConstantsManager.getInstance().getConstants().endDateBeforeStartDate());
        validEndDate = false;
    }
    return getSnapshotName().getIsValid() && getDaysOfTheWeek().getIsValid() && getDaysOfMonth().getIsValid() && validWeekDays && validMonthDays && validEndDate;
}
#method_after
public boolean validate(boolean inplaceValidate) {
    String propName;
    validateSnapshotName();
    validateDaysOfWeek();
    validateDaysOfMonth();
    validateEndDate();
    if (!listenersRegistered) {
        initValueChangeListeners();
        listenersRegistered = true;
    }
    if (inplaceValidate) {
        // $NON-NLS-1$
        propName = "modelPropertiesChanged";
    } else {
        // $NON-NLS-1$
        propName = "validateAndSwitchAppropriateTab";
    }
    onPropertyChanged(new PropertyChangedEventArgs(propName));
    return getSnapshotName().getIsValid() && getDaysOfTheWeek().getIsValid() && getDaysOfMonth().getIsValid() && getDaysOfTheWeek().getIsValid() && getDaysOfMonth().getIsValid() && getEndDate().getIsValid();
}
#end_block

#method_before
private List<String> getVdsIps(VDS vds) {
    List<String> vdsIps = new ArrayList<String>();
    for (VdsNetworkInterface iface : getInterfaceDao().getAllInterfacesForVds(vds.getId())) {
        if (iface.getAddress() != null) {
            vdsIps.add(iface.getAddress());
        }
    }
    return vdsIps;
}
#method_after
private List<String> getVdsIps(VDS vds) {
    List<String> vdsIps = new ArrayList<>();
    for (VdsNetworkInterface iface : getInterfaceDao().getAllInterfacesForVds(vds.getId())) {
        if (iface.getAddress() != null) {
            vdsIps.add(iface.getAddress());
        }
    }
    return vdsIps;
}
#end_block

#method_before
private List<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    // Create a copy of the existing servers as the fetchServer method can potentially remove elements from it
    List<VDS> tempServers = new ArrayList<VDS>(existingServers);
    List<GlusterServerInfo> fetchedServers = fetchServers(upServer, tempServers);
    if (fetchedServers == null) {
        log.error("gluster peer status command failed on all servers of the cluster '{}'." + "Can't refresh it's data at this point.", cluster.getName());
        return null;
    }
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        log.info("Gluster servers list fetched from server '{}' has only one server", upServer.getName());
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (isSameServer(upServer, server)) {
            // Find a different UP server, and get servers list from it
            tempServers.remove(upServer);
            upServer = getNewUpServer(tempServers, upServer);
            if (upServer == null) {
                log.warn("The only UP server in cluster '{}' seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getName());
                return null;
            }
            fetchedServers = fetchServers(upServer, tempServers);
            if (fetchedServers == null) {
                log.warn("The only UP server in cluster '{}' (or the only one on which gluster peer status " + "command is working) seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getName());
                return null;
            }
        }
    }
    return fetchedServers;
}
#method_after
private List<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    // Create a copy of the existing servers as the fetchServer method can potentially remove elements from it
    List<VDS> tempServers = new ArrayList<>(existingServers);
    List<GlusterServerInfo> fetchedServers = fetchServers(upServer, tempServers);
    if (fetchedServers == null) {
        log.error("gluster peer status command failed on all servers of the cluster '{}'." + "Can't refresh it's data at this point.", cluster.getName());
        return null;
    }
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        log.info("Gluster servers list fetched from server '{}' has only one server", upServer.getName());
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (isSameServer(upServer, server)) {
            // Find a different UP server, and get servers list from it
            tempServers.remove(upServer);
            upServer = getNewUpServer(tempServers, upServer);
            if (upServer == null) {
                log.warn("The only UP server in cluster '{}' seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getName());
                return null;
            }
            fetchedServers = fetchServers(upServer, tempServers);
            if (fetchedServers == null) {
                log.warn("The only UP server in cluster '{}' (or the only one on which gluster peer status " + "command is working) seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getName());
                return null;
            }
        }
    }
    return fetchedServers;
}
#end_block

#method_before
private void refreshVolumeData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    acquireLock(cluster.getId());
    try {
        // Pass a copy of the existing servers as the fetchVolumes method can potentially remove elements from it
        Map<Guid, GlusterVolumeEntity> volumesMap = fetchVolumes(upServer, new ArrayList<VDS>(existingServers));
        if (volumesMap == null) {
            log.error("gluster volume info command failed on all servers of the cluster '{}'." + "Can't refresh it's data at this point.", cluster.getName());
            return;
        }
        // remove deleted volumes must happen before adding new ones,
        // to handle cases where user deleted a volume and created a
        // new one with same name in a very short time
        removeDeletedVolumes(cluster.getId(), volumesMap);
        updateExistingAndNewVolumes(cluster.getId(), volumesMap);
    } finally {
        releaseLock(cluster.getId());
    }
}
#method_after
private void refreshVolumeData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    acquireLock(cluster.getId());
    try {
        // Pass a copy of the existing servers as the fetchVolumes method can potentially remove elements from it
        Map<Guid, GlusterVolumeEntity> volumesMap = fetchVolumes(upServer, new ArrayList<>(existingServers));
        if (volumesMap == null) {
            log.error("gluster volume info command failed on all servers of the cluster '{}'." + "Can't refresh it's data at this point.", cluster.getName());
            return;
        }
        // remove deleted volumes must happen before adding new ones,
        // to handle cases where user deleted a volume and created a
        // new one with same name in a very short time
        removeDeletedVolumes(cluster.getId(), volumesMap);
        updateExistingAndNewVolumes(cluster.getId(), volumesMap);
    } finally {
        releaseLock(cluster.getId());
    }
}
#end_block

#method_before
private void removeDeletedVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(clusterId)) {
        if (!volumesMap.containsKey(volume.getId())) {
            idsToRemove.add(volume.getId());
            log.debug("Volume '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", volume.getName());
            logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI);
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getVolumeDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing volumes from database!", e);
        }
    }
}
#method_after
private void removeDeletedVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(clusterId)) {
        if (!volumesMap.containsKey(volume.getId())) {
            idsToRemove.add(volume.getId());
            log.debug("Volume '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", volume.getName());
            logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI);
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getVolumeDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing volumes from database!", e);
        }
    }
}
#end_block

#method_before
private void updateExistingAndNewVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    VDSGroup cluster = getClusterDao().get(clusterId);
    for (Entry<Guid, GlusterVolumeEntity> entry : volumesMap.entrySet()) {
        GlusterVolumeEntity volume = entry.getValue();
        log.debug("Analyzing volume '{}'", volume.getName());
        GlusterVolumeEntity existingVolume = getVolumeDao().getById(entry.getKey());
        if (existingVolume == null) {
            try {
                createVolume(volume);
            } catch (Exception e) {
                log.error("Could not save volume {} in database: {}", volume.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        } else {
            try {
                log.debug("Volume '{}' exists in engine. Checking if it needs to be updated.", existingVolume.getName());
                updateVolume(existingVolume, volume);
            } catch (Exception e) {
                log.error("Error while updating volume '{}': {}", volume.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
        // If meta volume then set the CLI based snapshot scheduling flag accordingly
        if (cluster.getGlusterCliBasedScheduling() && GlusterConstants.GLUSTER_META_VOLUME_NAME.equalsIgnoreCase(volume.getName())) {
            VDSReturnValue retValue = runVdsCommand(VDSCommandType.EnableGlusterVolumeSnapshotScheduling, new GlusterVolumeSnapshotSchedulingVDSParameters(getClusterUtils().getRandomUpServer(volume.getClusterId()).getId(), true));
            if (!retValue.getSucceeded()) {
                log.warn("Unbale to set volume snapshot scheduling flag to gluster CLI scheduler");
            } else {
                cluster.setGlusterCliBasedScheduling(false);
                getClusterDao().update(cluster);
            }
        }
    }
}
#method_after
private void updateExistingAndNewVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    VDSGroup cluster = getClusterDao().get(clusterId);
    for (Entry<Guid, GlusterVolumeEntity> entry : volumesMap.entrySet()) {
        GlusterVolumeEntity volume = entry.getValue();
        log.debug("Analyzing volume '{}'", volume.getName());
        GlusterVolumeEntity existingVolume = getVolumeDao().getById(entry.getKey());
        if (existingVolume == null) {
            try {
                createVolume(volume);
            } catch (Exception e) {
                log.error("Could not save volume {} in database: {}", volume.getName(), e.getMessage());
                log.debug("Exception", e);
            }
            // If meta volume then set the CLI based snapshot scheduling flag accordingly
            if (getGlusterUtil().isGlusterSnapshotSupported(cluster.getCompatibilityVersion(), clusterId) && cluster.isGlusterCliBasedSchedulingOn() && (Config.<String>getValue(ConfigValues.GlusterMetaVolumeName)).equalsIgnoreCase(volume.getName())) {
                VdcReturnValueBase returnValue = backend.runInternalAction(VdcActionType.DisableGlusterCliSnapshotScheduleInternal, new GlusterVolumeActionParameters(volume.getId(), false), ExecutionHandler.createInternalJobContext());
                if (!returnValue.getSucceeded()) {
                    log.warn("Unbale to set volume snapshot scheduling flag to gluster CLI scheduler on cluster {}", cluster.getName());
                } else {
                    logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_CLI_SNAPSHOT_SCHEDULE_DISABLED);
                }
            }
        } else {
            try {
                log.debug("Volume '{}' exists in engine. Checking if it needs to be updated.", existingVolume.getName());
                updateVolume(existingVolume, volume);
            } catch (Exception e) {
                log.error("Error while updating volume '{}': {}", volume.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#end_block

#method_before
@SuppressWarnings("serial")
private void removeDeletedBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (final GlusterBrickEntity existingBrick : existingVolume.getBricks()) {
        if (!GlusterCoreUtil.containsBrick(fetchedBricks, existingBrick)) {
            idsToRemove.add(existingBrick.getId());
            log.info("Detected brick '{}' removed from volume '{}'. Removing it from engine DB as well.", existingBrick.getQualifiedName(), existingVolume.getName());
            logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, new HashMap<String, String>() {

                {
                    put(GlusterConstants.BRICK, existingBrick.getQualifiedName());
                }
            });
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getBrickDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing bricks from database: {}", e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#method_after
@SuppressWarnings("serial")
private void removeDeletedBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (final GlusterBrickEntity existingBrick : existingVolume.getBricks()) {
        if (!GlusterCoreUtil.containsBrick(fetchedBricks, existingBrick)) {
            idsToRemove.add(existingBrick.getId());
            log.info("Detected brick '{}' removed from volume '{}'. Removing it from engine DB as well.", existingBrick.getQualifiedName(), existingVolume.getName());
            logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, new HashMap<String, String>() {

                {
                    put(GlusterConstants.BRICK, existingBrick.getQualifiedName());
                }
            });
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getBrickDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing bricks from database: {}", e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@SuppressWarnings("serial")
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (final GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            idsToRemove.add(existingOption.getId());
            log.info("Detected option '{}' reset on volume '{}'. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            // Hence it is not required to log it as a removed option, as that would be misleading.
            if (!GlusterConstants.OPTION_GROUP.equals(existingOption.getKey())) {
                logUtil.logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, new HashMap<String, String>() {

                    {
                        put(GlusterConstants.OPTION_KEY, existingOption.getKey());
                        put(GlusterConstants.OPTION_VALUE, existingOption.getValue());
                    }
                });
            }
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getOptionDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing options of volume '{}' from database: {}", fetchedVolume.getName(), e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#method_after
@SuppressWarnings("serial")
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (final GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            idsToRemove.add(existingOption.getId());
            log.info("Detected option '{}' reset on volume '{}'. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            // Hence it is not required to log it as a removed option, as that would be misleading.
            if (!GlusterConstants.OPTION_GROUP.equals(existingOption.getKey())) {
                logUtil.logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, new HashMap<String, String>() {

                    {
                        put(GlusterConstants.OPTION_KEY, existingOption.getKey());
                        put(GlusterConstants.OPTION_VALUE, existingOption.getValue());
                    }
                });
            }
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getOptionDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing options of volume '{}' from database: {}", fetchedVolume.getName(), e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
private void updateExistingAndNewOptions(final GlusterVolumeEntity existingVolume, Collection<GlusterVolumeOptionEntity> fetchedOptions) {
    Map<String, GlusterVolumeOptionEntity> existingOptions = new HashMap<>();
    Map<String, GlusterVolumeOptionEntity> newOptions = new HashMap<>();
    for (final GlusterVolumeOptionEntity fetchedOption : fetchedOptions) {
        final GlusterVolumeOptionEntity existingOption = existingVolume.getOption(fetchedOption.getKey());
        if (existingOption == null) {
            newOptions.put(fetchedOption.getKey(), fetchedOption);
        } else if (!existingOption.getValue().equals(fetchedOption.getValue())) {
            fetchedOption.setId(existingOption.getId());
            existingOptions.put(fetchedOption.getKey(), fetchedOption);
        }
    }
    final List<GlusterVolumeOptionEntity> newOptionsSortedList = new ArrayList<GlusterVolumeOptionEntity>(newOptions.values());
    final List<GlusterVolumeOptionEntity> existingOptionsSortedList = new ArrayList<GlusterVolumeOptionEntity>(existingOptions.values());
    Collections.sort(newOptionsSortedList);
    Collections.sort(existingOptionsSortedList);
    // Insert the new options in a single transaction
    if (!newOptionsSortedList.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveNewOptions(existingVolume, newOptionsSortedList);
                return null;
            }
        });
    }
    // Update the existing options in a single transaction
    if (!existingOptionsSortedList.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                updateExistingOptions(existingVolume, existingOptionsSortedList);
                return null;
            }
        });
    }
}
#method_after
private void updateExistingAndNewOptions(final GlusterVolumeEntity existingVolume, Collection<GlusterVolumeOptionEntity> fetchedOptions) {
    Map<String, GlusterVolumeOptionEntity> existingOptions = new HashMap<>();
    Map<String, GlusterVolumeOptionEntity> newOptions = new HashMap<>();
    for (final GlusterVolumeOptionEntity fetchedOption : fetchedOptions) {
        final GlusterVolumeOptionEntity existingOption = existingVolume.getOption(fetchedOption.getKey());
        if (existingOption == null) {
            newOptions.put(fetchedOption.getKey(), fetchedOption);
        } else if (!existingOption.getValue().equals(fetchedOption.getValue())) {
            fetchedOption.setId(existingOption.getId());
            existingOptions.put(fetchedOption.getKey(), fetchedOption);
        }
    }
    final List<GlusterVolumeOptionEntity> newOptionsSortedList = new ArrayList<>(newOptions.values());
    final List<GlusterVolumeOptionEntity> existingOptionsSortedList = new ArrayList<>(existingOptions.values());
    Collections.sort(newOptionsSortedList);
    Collections.sort(existingOptionsSortedList);
    // Insert the new options in a single transaction
    if (!newOptionsSortedList.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveNewOptions(existingVolume, newOptionsSortedList);
                return null;
            }
        });
    }
    // Update the existing options in a single transaction
    if (!existingOptionsSortedList.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                updateExistingOptions(existingVolume, existingOptionsSortedList);
                return null;
            }
        });
    }
}
#end_block

#method_before
public void refreshVolumeDetails(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<GlusterBrickEntity>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<GlusterBrickEntity>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<GlusterBrickEntity>();
    GlusterVolumeAdvancedDetails volumeAdvancedDetails = getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName());
    if (volumeAdvancedDetails == null) {
        log.error("Error while refreshing brick statuses for volume '{}'. Failed to get volume advanced details ", volume.getName());
        return;
    }
    if (volumeAdvancedDetails.getCapacityInfo() != null) {
        if (volume.getAdvancedDetails().getCapacityInfo() == null) {
            getVolumeDao().addVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        } else {
            getVolumeDao().updateVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        }
    }
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        getBrickDao().addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        getBrickDao().updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        getBrickDao().updateBrickStatuses(bricksToUpdate);
    }
}
#method_after
public void refreshVolumeDetails(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<>();
    GlusterVolumeAdvancedDetails volumeAdvancedDetails = getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName());
    if (volumeAdvancedDetails == null) {
        log.error("Error while refreshing brick statuses for volume '{}'. Failed to get volume advanced details ", volume.getName());
        return;
    }
    if (volumeAdvancedDetails.getCapacityInfo() != null) {
        if (volume.getAdvancedDetails().getCapacityInfo() == null) {
            getVolumeDao().addVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        } else {
            getVolumeDao().updateVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        }
    }
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        getBrickDao().addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        getBrickDao().updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        getBrickDao().updateBrickStatuses(bricksToUpdate);
    }
}
#end_block

#method_before
private void logBrickStatusChange(GlusterVolumeEntity volume, final GlusterBrickEntity brick, final GlusterStatus fetchedStatus) {
    log.debug("Detected that status of brick '{}' in volume '{}' changed from '{}' to '{}'", brick.getQualifiedName(), volume.getName(), brick.getStatus(), fetchedStatus);
    logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, new HashMap<String, String>() {

        {
            put(GlusterConstants.BRICK_PATH, brick.getQualifiedName());
            put(GlusterConstants.OPTION_OLD_VALUE, brick.getStatus().toString());
            put(GlusterConstants.OPTION_NEW_VALUE, fetchedStatus.toString());
        }
    });
}
#method_after
private void logBrickStatusChange(GlusterVolumeEntity volume, final GlusterBrickEntity brick, final GlusterStatus fetchedStatus) {
    log.debug("Detected that status of brick '{}' in volume '{}' changed from '{}' to '{}'", brick.getQualifiedName(), volume.getName(), brick.getStatus(), fetchedStatus);
    logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, new HashMap<String, String>() {

        {
            put(GlusterConstants.BRICK_PATH, brick.getQualifiedName());
            put(GlusterConstants.OPTION_OLD_VALUE, brick.getStatus().toString());
            put(GlusterConstants.OPTION_NEW_VALUE, fetchedStatus.toString());
        }
    });
    if (fetchedStatus == GlusterStatus.DOWN) {
        logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_BRICK_STATUS_DOWN, brick.getId(), brick.getQualifiedName());
    } else if (fetchedStatus == GlusterStatus.UP) {
        AlertDirector.RemoveAlertsByBrickIdLogType(brick.getId(), AuditLogType.GLUSTER_BRICK_STATUS_DOWN);
    }
}
#end_block

#method_before
private Map<Guid, BrickProperties> getBrickPropertiesMap(GlusterVolumeAdvancedDetails volumeDetails) {
    Map<Guid, BrickProperties> brickStatusMap = new HashMap<Guid, BrickProperties>();
    for (BrickDetails brickDetails : volumeDetails.getBrickDetails()) {
        if (brickDetails.getBrickProperties().getBrickId() != null) {
            brickStatusMap.put(brickDetails.getBrickProperties().getBrickId(), brickDetails.getBrickProperties());
        }
    }
    return brickStatusMap;
}
#method_after
private Map<Guid, BrickProperties> getBrickPropertiesMap(GlusterVolumeAdvancedDetails volumeDetails) {
    Map<Guid, BrickProperties> brickStatusMap = new HashMap<>();
    for (BrickDetails brickDetails : volumeDetails.getBrickDetails()) {
        if (brickDetails.getBrickProperties().getBrickId() != null) {
            brickStatusMap.put(brickDetails.getBrickProperties().getBrickId(), brickDetails.getBrickProperties());
        }
    }
    return brickStatusMap;
}
#end_block

#method_before
public static final AbstractTextColumn<Disk> getAllocationColumn(String sortBy) {
    AbstractTextColumn<Disk> column = new AbstractEnumColumn<Disk, VolumeType>() {

        @Override
        protected VolumeType getRawValue(Disk object) {
            return object.getDiskStorageType() == DiskStorageType.IMAGE || object.getDiskStorageType() == DiskStorageType.CINDER ? ((DiskImage) object).getVolumeType() : null;
        }

        @Override
        public SafeHtml getTooltip(Disk object) {
            if (object.getDiskStorageType() != DiskStorageType.IMAGE && object.getDiskStorageType() != DiskStorageType.CINDER) {
                return null;
            }
            DiskImage diskImage = (DiskImage) object;
            if (diskImage.getSnapshots().isEmpty()) {
                return null;
            }
            VolumeType originalVolumeType = diskImage.getSnapshots().get(diskImage.getSnapshots().size() - 1).getVolumeType();
            return SafeHtmlUtils.fromString(// $NON-NLS-1$
            StringFormat.format(// $NON-NLS-1$
            "%s: %s", AssetProvider.getConstants().originalAllocationDisk(), EnumTranslator.getInstance().translate(originalVolumeType)));
        }
    };
    return makeSortable(column, sortBy);
}
#method_after
public static final AbstractTextColumn<Disk> getAllocationColumn(String sortBy) {
    AbstractTextColumn<Disk> column = new AbstractEnumColumn<Disk, VolumeType>() {

        @Override
        protected VolumeType getRawValue(Disk object) {
            return object.getDiskStorageType() == DiskStorageType.IMAGE || object.getDiskStorageType() == DiskStorageType.CINDER ? ((DiskImage) object).getVolumeType() : null;
        }

        @Override
        public SafeHtml getTooltip(Disk object) {
            if (object.getDiskStorageType() != DiskStorageType.IMAGE && object.getDiskStorageType() != DiskStorageType.CINDER) {
                return null;
            }
            VolumeType originalVolumeType = null;
            for (DiskImage snapshot : ((DiskImage) object).getSnapshots()) {
                if (snapshot.getParentId() == null || snapshot.getParentId().equals(Guid.Empty)) {
                    originalVolumeType = snapshot.getVolumeType();
                    break;
                }
            }
            if (originalVolumeType == null) {
                return null;
            }
            return SafeHtmlUtils.fromString(// $NON-NLS-1$
            StringFormat.format(// $NON-NLS-1$
            "%s: %s", AssetProvider.getConstants().originalAllocationDisk(), EnumTranslator.getInstance().translate(originalVolumeType)));
        }
    };
    return makeSortable(column, sortBy);
}
#end_block

#method_before
public static void buildCinderDisk(CinderDisk cinderDisk, Map<String, Object> struct) {
    CinderConnectionInfo connectionInfo = cinderDisk.getCinderConnectionInfo();
    CinderVolumeDriver cinderVolumeDriver = CinderVolumeDriver.forValue(connectionInfo.getDriverVolumeType());
    if (cinderVolumeDriver == null) {
        log.error("Unsupported Cinder volume driver: '{}' (disk: '{}')", connectionInfo.getDriverVolumeType(), cinderDisk.getDiskAlias());
        return;
    }
    switch(cinderVolumeDriver) {
        case RBD:
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            struct.put(VdsProperties.Path, connectionInfoData.get("name"));
            struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
            struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            struct.put(VdsProperties.Protocol, cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            struct.put(VdsProperties.DiskType, VdsProperties.NETWORK);
            List<String> hostAddresses = (ArrayList<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (ArrayList<String>) connectionInfoData.get("ports");
            List<Map<String, Object>> hosts = new ArrayList<>();
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                Map<String, Object> hostMap = new HashMap<>();
                hostMap.put(VdsProperties.NetworkDiskName, hostAddresses.get(i));
                hostMap.put(VdsProperties.NetworkDiskPort, hostPorts.get(i));
                hostMap.put(VdsProperties.NetworkDiskTransport, VdsProperties.Tcp);
                hosts.add(hostMap);
            }
            struct.put(VdsProperties.NetworkDiskHosts, hosts);
            boolean authEnabled = (boolean) cinderDisk.getCinderConnectionInfo().getData().get("auth_enabled");
            String secretType = (String) cinderDisk.getCinderConnectionInfo().getData().get("secret_type");
            String authUsername = (String) cinderDisk.getCinderConnectionInfo().getData().get("auth_username");
            String secretUuid = (String) cinderDisk.getCinderConnectionInfo().getData().get("secret_uuid");
            if (authEnabled) {
                Map<String, Object> authMap = new HashMap<>();
                authMap.put(VdsProperties.NetworkDiskAuthSecretType, secretType);
                authMap.put(VdsProperties.NetworkDiskAuthUsername, authUsername);
                authMap.put(VdsProperties.NetworkDiskAuthSecretUuid, secretUuid);
                struct.put(VdsProperties.NetworkDiskAuth, authMap);
            }
            break;
    }
}
#method_after
public static void buildCinderDisk(CinderDisk cinderDisk, Map<String, Object> struct) {
    CinderConnectionInfo connectionInfo = cinderDisk.getCinderConnectionInfo();
    CinderVolumeDriver cinderVolumeDriver = CinderVolumeDriver.forValue(connectionInfo.getDriverVolumeType());
    if (cinderVolumeDriver == null) {
        log.error("Unsupported Cinder volume driver: '{}' (disk: '{}')", connectionInfo.getDriverVolumeType(), cinderDisk.getDiskAlias());
        return;
    }
    switch(cinderVolumeDriver) {
        case RBD:
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            struct.put(VdsProperties.Path, connectionInfoData.get("name"));
            struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
            struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            struct.put(VdsProperties.Protocol, cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            struct.put(VdsProperties.DiskType, VdsProperties.NETWORK);
            List<String> hostAddresses = (ArrayList<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (ArrayList<String>) connectionInfoData.get("ports");
            List<Map<String, Object>> hosts = new ArrayList<>();
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                Map<String, Object> hostMap = new HashMap<>();
                hostMap.put(VdsProperties.NetworkDiskName, hostAddresses.get(i));
                hostMap.put(VdsProperties.NetworkDiskPort, hostPorts.get(i));
                hostMap.put(VdsProperties.NetworkDiskTransport, VdsProperties.Tcp);
                hosts.add(hostMap);
            }
            struct.put(VdsProperties.NetworkDiskHosts, hosts);
            boolean authEnabled = (boolean) connectionInfoData.get(VdsProperties.CinderAuthEnabled);
            String secretType = (String) connectionInfoData.get(VdsProperties.CinderSecretType);
            String authUsername = (String) connectionInfoData.get(VdsProperties.CinderAuthUsername);
            String secretUuid = (String) connectionInfoData.get(VdsProperties.CinderSecretUuid);
            if (authEnabled) {
                Map<String, Object> authMap = new HashMap<>();
                authMap.put(VdsProperties.NetworkDiskAuthSecretType, secretType);
                authMap.put(VdsProperties.NetworkDiskAuthUsername, authUsername);
                authMap.put(VdsProperties.NetworkDiskAuthSecretUuid, secretUuid);
                struct.put(VdsProperties.NetworkDiskAuth, authMap);
            }
            break;
    }
}
#end_block

#method_before
private void addNumaSetting(final String compatibilityVersion) {
    if (Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinningEnabled, compatibilityVersion))) {
        List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(vm.getId());
        if (vmNumaNodes.isEmpty()) {
            return;
        }
        NumaTuneMode numaTune = vm.getNumaTuneMode();
        List<VdsNumaNode> totalVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vdsId);
        if (numaTune != null) {
            Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes, totalVdsNumaNodes);
            if (!numaTuneSetting.isEmpty()) {
                createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
            }
        }
        List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
        if (!createVmNumaNodes.isEmpty()) {
            createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
        }
        if (StringUtils.isEmpty(vm.getCpuPinning())) {
            Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
            if (!cpuPinDict.isEmpty()) {
                createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
            }
        }
    }
}
#method_after
private void addNumaSetting(final String compatibilityVersion) {
    if (Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinningEnabled, compatibilityVersion))) {
        List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(vm.getId());
        List<VdsNumaNode> totalVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vdsId);
        if (totalVdsNumaNodes.isEmpty()) {
            log.warn("No NUMA nodes found for host {} for vm {} {}", vdsId, vm.getName(), vm.getId());
            return;
        }
        // create a default one with the first numa node of the host
        if (vmNumaNodes.isEmpty()) {
            if (FeatureSupported.hotPlugMemory(vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
                VmNumaNode vmNode = new VmNumaNode();
                vmNode.setIndex(totalVdsNumaNodes.get(0).getIndex());
                vmNode.setMemTotal(vm.getMemSizeMb());
                vmNode.setCpuIds(totalVdsNumaNodes.get(0).getCpuIds());
                vmNumaNodes.add(vmNode);
            } else {
                // no need to send numa if memory hotplug not supported
                return;
            }
        }
        NumaTuneMode numaTune = vm.getNumaTuneMode();
        if (numaTune != null) {
            Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes, totalVdsNumaNodes);
            if (!numaTuneSetting.isEmpty()) {
                createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
            }
        }
        List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
        if (!createVmNumaNodes.isEmpty()) {
            createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
        }
        if (StringUtils.isEmpty(vm.getCpuPinning())) {
            Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
            if (!cpuPinDict.isEmpty()) {
                createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
            }
        }
    }
}
#end_block

#method_before
@Override
protected StorageDomain getEntityObject(StorageDomain object) {
    if (object instanceof StorageDomain) {
        return object;
    } else {
        return null;
    }
}
#method_after
@Override
protected StorageDomain getEntityObject(StorageDomain object) {
    return object;
}
#end_block

#method_before
@Override
@SingleEntityResource
public EventResource getEventSubResource(String id) {
    return inject(new BackendEventResource(id, this));
}
#method_after
@Override
@SingleEntityResource
public EventResource getEventSubResource(String id) {
    return inject(new BackendEventResource(id));
}
#end_block

#method_before
@Override
public Response add(Event event) {
    validateParameters(event, "origin", "severity", "customId", "description");
    validateEnums(Event.class, event);
    AddExternalEventParameters parameters;
    boolean isHostExternalStateDefined = event.isSetHost() && event.getHost().isSetExternalStatus() && event.getHost().getExternalStatus().isSetState();
    boolean isStorageDomainExternalStateDefined = event.isSetStorageDomain() && event.getStorageDomain().isSetExternalStatus() && event.getStorageDomain().getExternalStatus().isSetState();
    if (isHostExternalStateDefined) {
        parameters = new AddExternalEventParameters(map(event), HostMapper.map(EntityExternalStatus.fromValue(event.getHost().getExternalStatus().getState()), null));
    } else if (isStorageDomainExternalStateDefined) {
        parameters = new AddExternalEventParameters(map(event), HostMapper.map(EntityExternalStatus.fromValue(event.getStorageDomain().getExternalStatus().getState()), null));
    } else {
        parameters = new AddExternalEventParameters(map(event), null);
    }
    return performCreate(VdcActionType.AddExternalEvent, parameters, new QueryIdResolver<Long>(VdcQueryType.GetAuditLogById, GetAuditLogByIdParameters.class));
}
#method_after
@Override
public Response add(Event event) {
    validateParameters(event, "origin", "severity", "customId", "description");
    validateEnums(Event.class, event);
    return performCreate(VdcActionType.AddExternalEvent, getParameters(event), new QueryIdResolver<Long>(VdcQueryType.GetAuditLogById, GetAuditLogByIdParameters.class));
}
#end_block

#method_before
@Override
public void validateEnums(StorageDomain storageDomain) {
    if (storageDomain != null) {
        if (storageDomain.isSetType()) {
            validateEnum(StorageDomainType.class, storageDomain.getType(), true);
        }
        if (storageDomain.isSetStorage() && storageDomain.getStorage().isSetType()) {
            validateEnum(StorageType.class, storageDomain.getStorage().getType(), true);
        }
        if (storageDomain.isSetFormat()) {
            validateEnum(StorageFormat.class, storageDomain.getStorageFormat(), true);
        }
        if (storageDomain.isSetStorage() && storageDomain.getStorage().isSetNfsVersion()) {
            validateEnum(NfsVersion.class, storageDomain.getStorage().getNfsVersion(), true);
        }
        if (storageDomain.isSetExternalStatus()) {
            validateEnum(EntityExternalStatus.class, storageDomain.getExternalStatus().getState().toUpperCase());
        }
    }
}
#method_after
@Override
public void validateEnums(StorageDomain storageDomain) {
    if (storageDomain != null) {
        if (storageDomain.isSetType()) {
            validateEnum(StorageDomainType.class, storageDomain.getType(), true);
        }
        if (storageDomain.isSetStorage() && storageDomain.getStorage().isSetType()) {
            validateEnum(StorageType.class, storageDomain.getStorage().getType(), true);
        }
        if (storageDomain.isSetFormat()) {
            validateEnum(StorageFormat.class, storageDomain.getStorageFormat(), true);
        }
        if (storageDomain.isSetStorage() && storageDomain.getStorage().isSetNfsVersion()) {
            validateEnum(NfsVersion.class, storageDomain.getStorage().getNfsVersion(), true);
        }
        if (storageDomain.isSetExternalStatus() && storageDomain.getExternalStatus().getState() != null) {
            validateEnum(EntityExternalStatus.class, storageDomain.getExternalStatus().getState().toUpperCase());
        }
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageDomain.class, to = StorageDomain.class)
public static StorageDomain map(org.ovirt.engine.core.common.businessentities.StorageDomain entity, StorageDomain template) {
    StorageDomain model = template != null ? template : new StorageDomain();
    model.setId(entity.getId().toString());
    model.setName(entity.getStorageName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    model.setType(map(entity.getStorageDomainType(), null));
    model.setWarningLowSpaceIndicator(entity.getWarningLowSpaceIndicator());
    model.setCriticalSpaceActionBlocker(entity.getCriticalSpaceActionBlocker());
    model.setMaster(entity.getStorageDomainType() == org.ovirt.engine.core.common.businessentities.StorageDomainType.Master);
    if (entity.getStatus() != null) {
        StorageDomainStatus status = map(entity.getStatus(), null);
        model.setStatus(status == null ? null : StatusUtils.create(status));
    }
    if (entity.getExternalStatus() != null) {
        // Reuse enum mappings fro HostMapper
        EntityExternalStatus entityExternalStatus = HostMapper.map(entity.getExternalStatus(), null);
        Status hostStatus = new Status();
        hostStatus.setState(entityExternalStatus.value());
        model.setExternalStatus(hostStatus);
    }
    model.setStorage(new Storage());
    model.getStorage().setType(map(entity.getStorageType(), null));
    if (entity.getStorageType() == org.ovirt.engine.core.common.businessentities.storage.StorageType.ISCSI || entity.getStorageType() == org.ovirt.engine.core.common.businessentities.storage.StorageType.FCP) {
        model.getStorage().setVolumeGroup(new VolumeGroup());
        model.getStorage().getVolumeGroup().setId(entity.getStorage());
    }
    if (entity.getAvailableDiskSize() != null) {
        model.setAvailable(SizeConverter.convert(entity.getAvailableDiskSize().longValue(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    }
    if (entity.getUsedDiskSize() != null) {
        model.setUsed(SizeConverter.convert(entity.getUsedDiskSize().longValue(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    }
    model.setCommitted(SizeConverter.convert(entity.getCommittedDiskSize(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    if (entity.getStorageFormat() != null) {
        String storageFormat = StorageFormatMapper.map(entity.getStorageFormat(), null).value();
        if (storageFormat != null) {
            model.setStorageFormat(storageFormat);
        }
    }
    model.setWipeAfterDelete(entity.getWipeAfterDelete());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageDomain.class, to = StorageDomain.class)
public static StorageDomain map(org.ovirt.engine.core.common.businessentities.StorageDomain entity, StorageDomain template) {
    StorageDomain model = template != null ? template : new StorageDomain();
    model.setId(entity.getId().toString());
    model.setName(entity.getStorageName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    model.setType(map(entity.getStorageDomainType(), null));
    model.setWarningLowSpaceIndicator(entity.getWarningLowSpaceIndicator());
    model.setCriticalSpaceActionBlocker(entity.getCriticalSpaceActionBlocker());
    model.setMaster(entity.getStorageDomainType() == org.ovirt.engine.core.common.businessentities.StorageDomainType.Master);
    if (entity.getStatus() != null) {
        StorageDomainStatus status = map(entity.getStatus(), null);
        model.setStatus(status == null ? null : StatusUtils.create(status));
    }
    if (entity.getExternalStatus() != null) {
        EntityExternalStatus entityExternalStatus = ExternalStatusMapper.map(entity.getExternalStatus(), null);
        Status externalStatus = new Status();
        externalStatus.setState(entityExternalStatus.value());
        model.setExternalStatus(externalStatus);
    }
    model.setStorage(new Storage());
    model.getStorage().setType(map(entity.getStorageType(), null));
    if (entity.getStorageType() == org.ovirt.engine.core.common.businessentities.storage.StorageType.ISCSI || entity.getStorageType() == org.ovirt.engine.core.common.businessentities.storage.StorageType.FCP) {
        model.getStorage().setVolumeGroup(new VolumeGroup());
        model.getStorage().getVolumeGroup().setId(entity.getStorage());
    }
    if (entity.getAvailableDiskSize() != null) {
        model.setAvailable(SizeConverter.convert(entity.getAvailableDiskSize().longValue(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    }
    if (entity.getUsedDiskSize() != null) {
        model.setUsed(SizeConverter.convert(entity.getUsedDiskSize().longValue(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    }
    model.setCommitted(SizeConverter.convert(entity.getCommittedDiskSize(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    if (entity.getStorageFormat() != null) {
        String storageFormat = StorageFormatMapper.map(entity.getStorageFormat(), null).value();
        if (storageFormat != null) {
            model.setStorageFormat(storageFormat);
        }
    }
    model.setWipeAfterDelete(entity.getWipeAfterDelete());
    return model;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    AuditLogableBase event = new AuditLogableBase(getParameters().getEvent());
    event.setExternal(true);
    String message = getParameters().getEvent().getMessage();
    switch(getParameters().getEvent().getSeverity()) {
        case NORMAL:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_NORMAL, message);
            break;
        case WARNING:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_WARNING, message);
            break;
        case ERROR:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_ERROR, message);
            break;
        case ALERT:
            AlertDirector.Alert(event, AuditLogType.EXTERNAL_ALERT, auditLogDirector, message);
            break;
    }
    AuditLog auditLog = DbFacade.getInstance().getAuditLogDao().getByOriginAndCustomEventId(getParameters().getEvent().getOrigin(), getParameters().getEvent().getCustomEventId());
    if (auditLog != null) {
        setActionReturnValue(auditLog.getAuditLogId());
        setSucceeded(true);
    }
    // Update host external status if set
    if (hasHostExternalStatus()) {
        hostDao.updateExternalStatus(getParameters().getEvent().getVdsId(), getParameters().getExternalStatus());
    }
    // update storage domain external status if set
    if (hasStorageDomainExternalStatus()) {
        storageDomainDynamicDAO.updateExternalStatus(getParameters().getEvent().getStorageDomainId(), getParameters().getExternalStatus());
    }
}
#method_after
@Override
protected void executeCommand() {
    AuditLogableBase event = new AuditLogableBase(getParameters().getEvent());
    event.setExternal(true);
    String message = getParameters().getEvent().getMessage();
    switch(getParameters().getEvent().getSeverity()) {
        case NORMAL:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_NORMAL, message);
            break;
        case WARNING:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_WARNING, message);
            break;
        case ERROR:
            auditLogDirector.log(event, AuditLogType.EXTERNAL_EVENT_ERROR, message);
            break;
        case ALERT:
            AlertDirector.Alert(event, AuditLogType.EXTERNAL_ALERT, auditLogDirector, message);
            break;
    }
    AuditLog auditLog = DbFacade.getInstance().getAuditLogDao().getByOriginAndCustomEventId(getParameters().getEvent().getOrigin(), getParameters().getEvent().getCustomEventId());
    if (auditLog != null) {
        setActionReturnValue(auditLog.getAuditLogId());
        setSucceeded(true);
    }
    // Update host external status if set
    if (hasHostExternalStatus()) {
        hostDao.updateExternalStatus(getParameters().getEvent().getVdsId(), getParameters().getExternalStatus());
    }
    // update storage domain external status if set
    if (hasStorageDomainExternalStatus()) {
        storageDomainDynamicDao.updateExternalStatus(getParameters().getEvent().getStorageDomainId(), getParameters().getExternalStatus());
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = getPermissionList(getParameters().getEvent());
    // check for external host status modification
    if (hasHostExternalStatus()) {
        permissionList.add(new PermissionSubject(getParameters().getEvent().getVdsId(), VdcObjectType.VDS, ActionGroup.EDIT_HOST_CONFIGURATION));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = getPermissionList(getParameters().getEvent());
    // check for external host status modification
    if (hasHostExternalStatus()) {
        permissionList.add(new PermissionSubject(getParameters().getEvent().getVdsId(), VdcObjectType.VDS, ActionGroup.EDIT_HOST_CONFIGURATION));
    }
    // check for external storage domain status modification
    if (hasStorageDomainExternalStatus()) {
        permissionList.add(new PermissionSubject(getParameters().getEvent().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.EDIT_STORAGE_DOMAIN_CONFIGURATION));
    }
    return permissionList;
}
#end_block

#method_before
public ExternalStatus getExternalStatus() {
    return storagePoolIsoMapData.getExternalStatus();
}
#method_after
public ExternalStatus getExternalStatus() {
    return dynamicData.getExternalStatus();
}
#end_block

#method_before
public void setExternalStatus(ExternalStatus externalStatus) {
    storagePoolIsoMapData.setExternalStatus(externalStatus);
}
#method_after
public void setExternalStatus(ExternalStatus externalStatus) {
    dynamicData.setExternalStatus(externalStatus);
}
#end_block

#method_before
@Mapping(from = DataCenter.class, to = StoragePool.class)
public static StoragePool map(DataCenter model, StoragePool template) {
    StoragePool entity = template != null ? template : new StoragePool();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetStorageType()) {
        StorageType storageType = StorageType.fromValue(model.getStorageType());
        if (storageType != null) {
            entity.setIsLocal(StorageDomainMapper.map(storageType, null) == org.ovirt.engine.core.common.businessentities.storage.StorageType.LOCALFS);
        }
    }
    if (model.isSetLocal()) {
        entity.setIsLocal(model.isLocal());
    }
    if (model.isSetStorageFormat()) {
        StorageFormat storageFormat = StorageFormat.fromValue(model.getStorageFormat());
        if (storageFormat != null) {
            entity.setStoragePoolFormatType(StorageFormatMapper.map(storageFormat, null));
        }
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setCompatibilityVersion(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMacPool() && model.getMacPool().isSetId()) {
        entity.setMacPoolId(GuidUtils.asGuid(model.getMacPool().getId()));
    }
    if (model.isSetQuotaModeType()) {
        entity.setQuotaEnforcementType(map(QuotaModeType.fromValue(model.getQuotaModeType())));
    }
    return entity;
}
#method_after
@Mapping(from = DataCenter.class, to = StoragePool.class)
public static StoragePool map(DataCenter model, StoragePool template) {
    StoragePool entity = template != null ? template : new StoragePool();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetStorageType()) {
        StorageType storageType = StorageType.fromValue(model.getStorageType());
        if (storageType != null) {
            entity.setIsLocal(StorageDomainMapper.map(storageType, null) == org.ovirt.engine.core.common.businessentities.storage.StorageType.LOCALFS);
        }
    }
    if (model.isSetLocal()) {
        entity.setIsLocal(model.isLocal());
    }
    if (model.isSetStorageFormat()) {
        StorageFormat storageFormat = StorageFormat.fromValue(model.getStorageFormat());
        if (storageFormat != null) {
            entity.setStoragePoolFormatType(StorageFormatMapper.map(storageFormat, null));
        }
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setCompatibilityVersion(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMacPool() && model.getMacPool().isSetId()) {
        entity.setMacPoolId(GuidUtils.asGuid(model.getMacPool().getId()));
    }
    if (model.isSetQuotaMode()) {
        entity.setQuotaEnforcementType(map(QuotaModeType.fromValue(model.getQuotaMode())));
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = StoragePool.class, to = DataCenter.class)
public static DataCenter map(StoragePool entity, DataCenter template) {
    DataCenter model = template != null ? template : new DataCenter();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setLocal(entity.isLocal());
    if (!StringUtils.isEmpty(entity.getdescription())) {
        model.setDescription(entity.getdescription());
    }
    if (!StringUtils.isEmpty(entity.getComment())) {
        model.setComment(entity.getComment());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
    }
    if (entity.getCompatibilityVersion() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getCompatibilityVersion().getMajor());
        model.getVersion().setMinor(entity.getCompatibilityVersion().getMinor());
    }
    if (entity.getStoragePoolFormatType() != null) {
        StorageFormat storageFormat = StorageFormatMapper.map(entity.getStoragePoolFormatType(), null);
        if (storageFormat != null) {
            model.setStorageFormat(storageFormat.value());
        }
    }
    if (entity.getMacPoolId() != null) {
        model.setMacPool(new MacPool());
        model.getMacPool().setId(entity.getMacPoolId().toString());
    }
    if (entity.getQuotaEnforcementType() != null) {
        model.setQuotaModeType(map(entity.getQuotaEnforcementType()).value());
    }
    return model;
}
#method_after
@Mapping(from = StoragePool.class, to = DataCenter.class)
public static DataCenter map(StoragePool entity, DataCenter template) {
    DataCenter model = template != null ? template : new DataCenter();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setLocal(entity.isLocal());
    if (!StringUtils.isEmpty(entity.getdescription())) {
        model.setDescription(entity.getdescription());
    }
    if (!StringUtils.isEmpty(entity.getComment())) {
        model.setComment(entity.getComment());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
    }
    if (entity.getCompatibilityVersion() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getCompatibilityVersion().getMajor());
        model.getVersion().setMinor(entity.getCompatibilityVersion().getMinor());
    }
    if (entity.getStoragePoolFormatType() != null) {
        StorageFormat storageFormat = StorageFormatMapper.map(entity.getStoragePoolFormatType(), null);
        if (storageFormat != null) {
            model.setStorageFormat(storageFormat.value());
        }
    }
    if (entity.getMacPoolId() != null) {
        model.setMacPool(new MacPool());
        model.getMacPool().setId(entity.getMacPoolId().toString());
    }
    if (entity.getQuotaEnforcementType() != null) {
        model.setQuotaMode(map(entity.getQuotaEnforcementType()).value());
    }
    return model;
}
#end_block

#method_before
@Mapping(from = QuotaEnforcementTypeEnum.class, to = QuotaModeType.class)
public static QuotaModeType map(QuotaEnforcementTypeEnum type) {
    switch(type) {
        case DISABLED:
            return QuotaModeType.DISABLED;
        case HARD_ENFORCEMENT:
            return QuotaModeType.ENABLED;
        case SOFT_ENFORCEMENT:
            return QuotaModeType.AUDIT;
        default:
            return null;
    }
}
#method_after
@Mapping(from = QuotaEnforcementTypeEnum.class, to = QuotaModeType.class)
public static QuotaModeType map(QuotaEnforcementTypeEnum type) {
    switch(type) {
        case DISABLED:
            return QuotaModeType.DISABLED;
        case HARD_ENFORCEMENT:
            return QuotaModeType.ENABLED;
        case SOFT_ENFORCEMENT:
            return QuotaModeType.AUDIT;
        default:
            throw new IllegalArgumentException("Unknown quota enforcement type \"" + type + "\"");
    }
}
#end_block

#method_before
@Mapping(from = QuotaModeType.class, to = QuotaEnforcementTypeEnum.class)
public static QuotaEnforcementTypeEnum map(QuotaModeType type) {
    switch(type) {
        case DISABLED:
            return QuotaEnforcementTypeEnum.DISABLED;
        case ENABLED:
            return QuotaEnforcementTypeEnum.HARD_ENFORCEMENT;
        case AUDIT:
            return QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT;
        default:
            return null;
    }
}
#method_after
@Mapping(from = QuotaModeType.class, to = QuotaEnforcementTypeEnum.class)
public static QuotaEnforcementTypeEnum map(QuotaModeType type) {
    switch(type) {
        case DISABLED:
            return QuotaEnforcementTypeEnum.DISABLED;
        case ENABLED:
            return QuotaEnforcementTypeEnum.HARD_ENFORCEMENT;
        case AUDIT:
            return QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT;
        default:
            throw new IllegalArgumentException("Unknown quota mode type \"" + type + "\"");
    }
}
#end_block

#method_before
@Override
public void validateEnums(DataCenter dataCenter) {
    if (dataCenter != null) {
        if (dataCenter.isSetStorageType()) {
            validateEnum(StorageType.class, dataCenter.getStorageType(), true);
        }
        if (dataCenter.isSetStorageFormat()) {
            validateEnum(StorageFormat.class, dataCenter.getStorageFormat(), true);
        }
        if (dataCenter.isSetQuotaModeType()) {
            validateEnum(QuotaModeType.class, dataCenter.getQuotaModeType(), true);
        }
    }
}
#method_after
@Override
public void validateEnums(DataCenter dataCenter) {
    if (dataCenter != null) {
        if (dataCenter.isSetStorageType()) {
            validateEnum(StorageType.class, dataCenter.getStorageType(), true);
        }
        if (dataCenter.isSetStorageFormat()) {
            validateEnum(StorageFormat.class, dataCenter.getStorageFormat(), true);
        }
        if (dataCenter.isSetQuotaMode()) {
            validateEnum(QuotaModeType.class, dataCenter.getQuotaMode(), true);
        }
    }
}
#end_block

#method_before
@Override
protected DataCenter postPopulate(DataCenter model) {
    model.setStorageFormat(MappingTestHelper.shuffle(StorageFormat.class).value());
    model.setQuotaModeType(MappingTestHelper.shuffle(QuotaModeType.class).value());
    return model;
}
#method_after
@Override
protected DataCenter postPopulate(DataCenter model) {
    model.setStorageFormat(MappingTestHelper.shuffle(StorageFormat.class).value());
    model.setQuotaMode(MappingTestHelper.shuffle(QuotaModeType.class).value());
    return model;
}
#end_block

#method_before
@Override
protected void verify(DataCenter model, DataCenter transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.isLocal(), transform.isLocal());
    assertEquals(model.getStorageFormat(), transform.getStorageFormat());
    assertEquals(model.getMacPool().getId(), transform.getMacPool().getId());
    assertEquals(model.getQuotaModeType(), transform.getQuotaModeType());
}
#method_after
@Override
protected void verify(DataCenter model, DataCenter transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.isLocal(), transform.isLocal());
    assertEquals(model.getStorageFormat(), transform.getStorageFormat());
    assertEquals(model.getMacPool().getId(), transform.getMacPool().getId());
    assertEquals(model.getQuotaMode(), transform.getQuotaMode());
}
#end_block

#method_before
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskStorageTypes(version, DiskStorageType.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addKdumpStates(version, KdumpStatus.values());
    addSupportedQosTypes(version);
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostProtocols(version, HostProtocol.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    addSELinuxModes(version, SELinuxMode.values());
    addRngSources(version, RngSource.values());
    addPolicyUnitTypes(version, PolicyUnitType.values());
    addSpmStates(version, SpmState.values());
    addNetworkPluginTypes(version, NetworkPluginType.values());
    addMessageBrokerTypes(version, MessageBrokerType.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    addInheritableBooleans(version, InheritableBoolean.values());
    addQuotaModeTypes(version);
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#method_after
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addGraphicsTypes(version, GraphicsType.values());
    addDiskStorageTypes(version, DiskStorageType.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addKdumpStates(version, KdumpStatus.values());
    addSupportedQosTypes(version);
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addExternalStates(version, EntityExternalStatus.values());
    addHostProtocols(version, HostProtocol.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    addSELinuxModes(version, SELinuxMode.values());
    addRngSources(version, RngSource.values());
    addPolicyUnitTypes(version, PolicyUnitType.values());
    addSpmStates(version, SpmState.values());
    addNetworkPluginTypes(version, NetworkPluginType.values());
    addMessageBrokerTypes(version, MessageBrokerType.values());
    addConsoleDisconnectActions(version, ConsoleDisconnectAction.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    addInheritableBooleans(version, InheritableBoolean.values());
    addQuotaModeTypes(version);
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#end_block

#method_before
private void addQuotaModeTypes(VersionCaps version) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_2)) {
        version.setQuotaModeTypes(new QuotaModeTypes());
        for (QuotaModeType mode : QuotaModeType.values()) {
            version.getQuotaModeTypes().getQuotaModeTypes().add(mode.value());
        }
    }
}
#method_after
private void addQuotaModeTypes(VersionCaps version) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_6)) {
        version.setQuotaModeTypes(new QuotaModeTypes());
        for (QuotaModeType mode : QuotaModeType.values()) {
            version.getQuotaModeTypes().getQuotaModeTypes().add(mode.value());
        }
    }
}
#end_block

#method_before
@Override
public Response add(Quota quota) {
    org.ovirt.engine.core.common.businessentities.Quota entity = map(quota);
    entity.setStoragePoolId(dataCenterId);
    return performCreate(VdcActionType.AddQuota, new QuotaCRUDParameters(entity), new QueryIdResolver<Guid>(VdcQueryType.GetQuotaByQuotaId, IdQueryParameters.class));
}
#method_after
@Override
public Response add(Quota quota) {
    validateParameters(quota, "name");
    org.ovirt.engine.core.common.businessentities.Quota entity = map(quota);
    entity.setStoragePoolId(dataCenterId);
    return performCreate(VdcActionType.AddQuota, new QuotaCRUDParameters(entity), new QueryIdResolver<Guid>(VdcQueryType.GetQuotaByQuotaId, IdQueryParameters.class));
}
#end_block

#method_before
private static List<BaseResource> getInlineResources(Object obj) {
    ArrayList<BaseResource> ret = new ArrayList<BaseResource>();
    for (Method method : obj.getClass().getMethods()) {
        if (method.getName().startsWith("get")) {
            // to resources deeply nested:
            if (method.getReturnType().getPackage() == BaseResource.class.getPackage()) {
                Object inline = null;
                try {
                    inline = method.invoke(obj);
                } catch (Exception e) {
                // invocation target exception should not occur on simple getter
                }
                if (inline != null) {
                    if (inline instanceof BaseResource) {
                        ret.add((BaseResource) inline);
                    } else {
                        ret.addAll(getInlineResources(inline));
                    }
                }
            }
        }
    }
    return ret;
}
#method_after
private static List<BaseResource> getInlineResources(Object obj) {
    ArrayList<BaseResource> ret = new ArrayList<BaseResource>();
    for (Method method : getRelevantMethods(obj.getClass())) {
        // We need to recursively scan everything that is in the model package, as there may be references
        // to resources deeply nested:
        Object inline = null;
        try {
            inline = method.invoke(obj);
        } catch (Exception e) {
        // invocation target exception should not occur on simple getter
        }
        if (inline != null) {
            if (inline instanceof BaseResource) {
                ret.add((BaseResource) inline);
            } else {
                ret.addAll(getInlineResources(inline));
            }
        }
    }
    return ret;
}
#end_block

#method_before
@Mapping(from = ClusterQuotaLimit.class, to = org.ovirt.engine.core.common.businessentities.Quota.class)
public static org.ovirt.engine.core.common.businessentities.Quota map(ClusterQuotaLimit model, org.ovirt.engine.core.common.businessentities.Quota template) {
    org.ovirt.engine.core.common.businessentities.Quota entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.Quota();
    QuotaVdsGroup quotaCluster = new QuotaVdsGroup();
    if (model.isSetVcpuLimit()) {
        quotaCluster.setVirtualCpu(model.getVcpuLimit());
    }
    if (model.isSetMemoryLimit() && model.getMemoryLimit() != -1) {
        quotaCluster.setMemSizeMB((long) (model.getMemoryLimit() * 1024));
    }
    // specific cluster
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        quotaCluster.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
        entity.getQuotaVdsGroups().add(quotaCluster);
    } else {
        // global
        entity.setGlobalQuotaVdsGroup(quotaCluster);
    }
    return entity;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.Quota.class, to = QuotaStorageLimit.class)
public static QuotaStorageLimit map(org.ovirt.engine.core.common.businessentities.Quota entity, QuotaStorageLimit template) {
    QuotaStorageLimit model = template != null ? template : new QuotaStorageLimit();
    Guid guid = GuidUtils.asGuid(model.getId());
    // global
    if (guid.equals(entity.getId())) {
        map(model, entity.getGlobalQuotaStorage(), null, entity.getStoragePoolId().toString(), entity.getId().toString());
    } else {
        // specific
        if (entity.getQuotaStorages() != null) {
            for (QuotaStorage quotaStorage : entity.getQuotaStorages()) {
                if (quotaStorage.getStorageId() != null && quotaStorage.getStorageId().equals(guid)) {
                    map(model, quotaStorage, quotaStorage.getStorageId().toString(), entity.getStoragePoolId().toString(), entity.getId().toString());
                }
            }
        }
    }
    return model;
}
#end_block

#method_before
private void localize(CommonApplicationConstants constants, CommonApplicationTemplates templates) {
    isPluggedEditor.setHtmlLabel(templates.textWithTooltip(constants.activateVmDiskPopup(), constants.activateVmDiskPopupToolTip()));
}
#method_after
private void localize() {
    isPluggedEditor.setLabel(constants.activateVmDiskPopup());
    isPluggedEditor.setWidgetTooltip(constants.activateVmDiskPopupToolTip());
    // $NON-NLS-1$
    isPluggedEditor.getContentWidgetContainer().setWidth("90px");
}
#end_block

#method_before
private void initManualWidgets(boolean allowMultipleSelection) {
    isPluggedEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    imageDiskTable = new EntityModelCellTable<>(allowMultipleSelection);
    lunDiskTable = new EntityModelCellTable<>(allowMultipleSelection);
    dynamicWarningLabel = new StringEntityModelTextAreaLabelEditor();
}
#method_after
private void initManualWidgets(boolean allowMultipleSelection) {
    isPluggedEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    imageDiskTable = new EntityModelCellTable<>(allowMultipleSelection);
    lunDiskTable = new EntityModelCellTable<>(allowMultipleSelection);
    cinderDiskTable = new EntityModelCellTable<>(allowMultipleSelection);
    messageLabel = new HTML();
    warningLabel = new HTML();
}
#end_block

#method_before
private void initAttachPanelWidget() {
    // Create tables container
    VerticalPanel verticalPanel = new VerticalPanel();
    verticalPanel.add(imageDiskTable);
    verticalPanel.add(lunDiskTable);
    // Create ValidatedPanelWidget and add tables container
    attachDiskPanel.setWidget(verticalPanel);
}
#method_after
private void initAttachPanelWidget() {
    // Create tables container
    VerticalPanel verticalPanel = new VerticalPanel();
    verticalPanel.add(imageDiskTable);
    verticalPanel.add(lunDiskTable);
    verticalPanel.add(cinderDiskTable);
    // Create ValidatedPanelWidget and add tables container
    attachDiskPanel.setWidget(verticalPanel);
}
#end_block

#method_before
@Override
public void edit(final AttachDiskModel disk) {
    driver.edit(disk);
    if (!isNewLunDiskEnabled) {
        disk.getDiskStorageType().setEntity(DiskStorageType.IMAGE);
    }
    revealDiskPanel(disk);
    diskTypePanel.addRadioButton(constants.internalDisk(), disk.getIsNew() || disk.getDisk().getDiskStorageType() == DiskStorageType.IMAGE, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.IMAGE);
            revealDiskPanel(disk);
        }
    });
    diskTypePanel.addRadioButton(constants.externalDisk(), !disk.getIsNew() && disk.getDisk().getDiskStorageType() == DiskStorageType.LUN, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.LUN);
            revealDiskPanel(disk);
        }
    });
    // Add event handlers
    disk.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if (propName.equals("IsValid")) {
                // $NON-NLS-1$
                if (disk.getIsValid()) {
                    attachDiskPanel.markAsValid();
                } else {
                    attachDiskPanel.markAsInvalid(disk.getInvalidityReasons());
                }
            }
        }
    });
    disk.getDynamicWarning().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            EntityModel ownerModel = (EntityModel) sender;
            String propName = args.propertyName;
            if ("IsAvailable".equals(propName)) {
                // $NON-NLS-1$
                warningPanel.setVisible(ownerModel.getIsAvailable());
            }
        }
    });
    revealDiskPanel(disk);
}
#method_after
@Override
public void edit(final AttachDiskModel disk) {
    driver.edit(disk);
    if (!isNewLunDiskEnabled) {
        disk.getDiskStorageType().setEntity(DiskStorageType.IMAGE);
    }
    revealDiskPanel(disk);
    diskTypePanel.addRadioButton(constants.imageDisk(), disk.getIsNew() || disk.getDisk().getDiskStorageType() == DiskStorageType.IMAGE, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.IMAGE);
            revealDiskPanel(disk);
        }
    });
    diskTypePanel.addRadioButton(constants.directLunDisk(), !disk.getIsNew() && disk.getDisk().getDiskStorageType() == DiskStorageType.LUN, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.LUN);
            revealDiskPanel(disk);
        }
    });
    diskTypePanel.addRadioButton(constants.cinderDisk(), !disk.getIsNew() && disk.getDisk().getDiskStorageType() == DiskStorageType.CINDER, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.CINDER);
            revealDiskPanel(disk);
        }
    });
    // Add event handlers
    disk.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if (propName.equals("IsValid")) {
                // $NON-NLS-1$
                if (disk.getIsValid()) {
                    attachDiskPanel.markAsValid();
                } else {
                    attachDiskPanel.markAsInvalid(disk.getInvalidityReasons());
                }
            } else if ("Message".equals(propName)) {
                // $NON-NLS-1$
                if (StringUtils.isNotEmpty(disk.getMessage())) {
                    messageLabel.setHTML(wrapInUnorderedList(disk.getMessage()));
                } else {
                    // $NON-NLS-1$
                    messageLabel.setHTML("");
                }
            }
        }
    });
    disk.getWarningLabel().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            EntityModel ownerModel = (EntityModel) sender;
            String propName = args.propertyName;
            if ("IsAvailable".equals(propName)) {
                // $NON-NLS-1$
                warningLabel.setVisible(ownerModel.getIsAvailable());
            }
        }
    });
    disk.getWarningLabel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            warningLabel.setHTML(wrapInUnorderedList(disk.getWarningLabel().getEntity()));
        }
    });
    revealDiskPanel(disk);
}
#end_block

#method_before
private void revealDiskPanel(final AttachDiskModel disk) {
    diskTypePanel.setVisible(isNewLunDiskEnabled);
    imageDiskTable.setVisible(false);
    lunDiskTable.setVisible(false);
    EntityModelCellTable<ListModel> diskTable;
    switch(disk.getDiskStorageType().getEntity()) {
        case LUN:
            diskTable = lunDiskTable;
            break;
        default:
            diskTable = imageDiskTable;
            break;
    }
    diskTable.setVisible(true);
    diskTable.asEditor().edit(disk.getAttachableDisksMap().get(disk.getDiskStorageType().getEntity()));
}
#method_after
private void revealDiskPanel(final AttachDiskModel disk) {
    diskTypePanel.setVisible(isNewLunDiskEnabled);
    imageDiskTable.setVisible(false);
    lunDiskTable.setVisible(false);
    cinderDiskTable.setVisible(false);
    EntityModelCellTable<ListModel> diskTable;
    switch(disk.getDiskStorageType().getEntity()) {
        case LUN:
            diskTable = lunDiskTable;
            break;
        case CINDER:
            diskTable = cinderDiskTable;
            break;
        case IMAGE:
        default:
            diskTable = imageDiskTable;
            break;
    }
    diskTable.setVisible(true);
    diskTable.asEditor().edit(disk.getAttachableDisksMap().get(disk.getDiskStorageType().getEntity()));
}
#end_block

#method_before
public void loadAttachableDisks() {
    doLoadAttachableDisks(new GetDisksCallback(DiskStorageType.IMAGE), new GetDisksCallback(DiskStorageType.LUN));
}
#method_after
public void loadAttachableDisks() {
    doLoadAttachableDisks(new GetDisksCallback(DiskStorageType.IMAGE), new GetDisksCallback(DiskStorageType.LUN), new GetDisksCallback(DiskStorageType.CINDER));
}
#end_block

#method_before
protected void doLoadAttachableDisks(GetDisksCallback imageCallback, GetDisksCallback lunCallback) {
    AsyncDataProvider.getInstance().getAllAttachableDisks(new AsyncQuery(this, imageCallback), getVm().getStoragePoolId(), getVm().getId());
    AsyncDataProvider.getInstance().getAllAttachableDisks(new AsyncQuery(this, lunCallback), null, getVm().getId());
}
#method_after
protected void doLoadAttachableDisks(GetDisksCallback imageCallback, GetDisksCallback lunCallback, GetDisksCallback cinderCallback) {
    AsyncDataProvider.getInstance().getAllAttachableDisks(new AsyncQuery(this, imageCallback), getVm().getStoragePoolId(), getVm().getId());
    AsyncDataProvider.getInstance().getAllAttachableDisks(new AsyncQuery(this, lunCallback), null, getVm().getId());
    AsyncDataProvider.getInstance().getAllAttachableDisks(new AsyncQuery(this, cinderCallback), null, getVm().getId());
}
#end_block

#method_before
@Override
public boolean validate() {
    if (isNoSelection()) {
        getInvalidityReasons().add(CONSTANTS.noDisksSelected());
        setIsValid(false);
        return false;
    }
    return true;
}
#method_after
@Override
public boolean validate() {
    if (isNoSelection()) {
        getInvalidityReasons().add(constants.noDisksSelected());
        setIsValid(false);
        return false;
    }
    return true;
}
#end_block

#method_before
private void addListeners() {
    addViewsSelectedItemsChangedListener();
    addIsPluggedEntityChangedListener();
}
#method_after
private void addListeners() {
    addSelectedItemsChangedListener();
    addIsPluggedEntityChangedListener();
}
#end_block

#method_before
private void addIsPluggedEntityChangedListener() {
    IEventListener<EventArgs> entityChangedListener = new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateDynamicWarning();
        }
    };
    getIsPlugged().getEntityChangedEvent().addListener(entityChangedListener);
}
#method_after
private void addIsPluggedEntityChangedListener() {
    IEventListener<EventArgs> entityChangedListener = new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateWarningLabel();
        }
    };
    getIsPlugged().getEntityChangedEvent().addListener(entityChangedListener);
}
#end_block

#method_before
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    if (entity.getCpuName() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getCpuName());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getCompatibilityVersion() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getCompatibilityVersion().getMajor());
        model.getVersion().setMinor(entity.getCompatibilityVersion().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setOptionalReason(entity.isOptionalReasonRequired());
    model.setMaintenanceReasonRequired(entity.isMaintenanceReasonRequired());
    model.setBallooningEnabled(entity.isEnableBallooning());
    model.setKsm(new KSM());
    model.getKsm().setEnabled(entity.isEnableKsm());
    model.getKsm().setMergeAcrossNodes(entity.isKsmMergeAcrossNumaNodes());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    if (entity.getRequiredRngSources() != null) {
        model.setRequiredRngSources(RngDeviceMapper.mapRngSources(entity.getRequiredRngSources(), null));
    }
    model.setMigration(MigrationOptionsMapper.map(entity, null));
    if (entity.getFencingPolicy() != null) {
        model.setFencingPolicy(FencingPolicyMapper.map(entity.getFencingPolicy(), null));
    }
    return model;
}
#method_after
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    if (entity.getCpuName() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getCpuName());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getCompatibilityVersion() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getCompatibilityVersion().getMajor());
        model.getVersion().setMinor(entity.getCompatibilityVersion().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setOptionalReason(entity.isOptionalReasonRequired());
    model.setMaintenanceReasonRequired(entity.isMaintenanceReasonRequired());
    model.setBallooningEnabled(entity.isEnableBallooning());
    KSM ksm = model.getKsm();
    if (ksm == null) {
        ksm = new KSM();
        model.setKsm(ksm);
    }
    ksm.setEnabled(entity.isEnableKsm());
    ksm.setMergeAcrossNodes(entity.isKsmMergeAcrossNumaNodes());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    if (entity.getRequiredRngSources() != null) {
        model.setRequiredRngSources(RngDeviceMapper.mapRngSources(entity.getRequiredRngSources(), null));
    }
    model.setMigration(MigrationOptionsMapper.map(entity, null));
    if (entity.getFencingPolicy() != null) {
        model.setFencingPolicy(FencingPolicyMapper.map(entity.getFencingPolicy(), null));
    }
    return model;
}
#end_block

#method_before
private boolean evaluateReturnValues(AuditLogType auditLogType, List<VdcReturnValueBase> returnValues) {
    boolean succeeded = true;
    List<String> errors = new ArrayList<String>();
    for (VdcReturnValueBase currentReturnValue : returnValues) {
        boolean currentExecutionStatus = currentReturnValue.getSucceeded();
        succeeded &= currentExecutionStatus;
        if (!currentExecutionStatus) {
            errors.addAll(currentReturnValue.getExecuteFailedMessages());
        }
    }
    if (!succeeded) {
        handleVdsErrors(auditLogType, errors);
    }
    return succeeded;
}
#method_after
private boolean evaluateReturnValues(AuditLogType auditLogType, List<VdcReturnValueBase> returnValues) {
    boolean succeeded = true;
    List<String> errors = new ArrayList<>();
    for (VdcReturnValueBase currentReturnValue : returnValues) {
        boolean currentExecutionStatus = currentReturnValue.getSucceeded();
        succeeded = succeeded && currentExecutionStatus;
        if (!currentExecutionStatus) {
            errors.addAll(currentReturnValue.getExecuteFailedMessages());
        }
    }
    if (!succeeded) {
        handleVdsErrors(auditLogType, errors);
    }
    return succeeded;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean isSucceeded = true;
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk disk : getParameters().getCinderDisks()) {
        ImagesContainterParametersBase params = buildChildCommandParameters(disk);
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.TryBackToCinderSnapshot, params, cloneContextAndDetachFromParent());
        try {
            VdcReturnValueBase vdcReturnValueBase = future.get();
            if (!vdcReturnValueBase.getSucceeded()) {
                log.error("Error cloning Cinder disk for preview. '{}': {}", disk.getDiskAlias());
                getReturnValue().setFault(vdcReturnValueBase.getFault());
                isSucceeded = false;
                break;
            }
            CinderDisk cinderDisk = vdcReturnValueBase.getActionReturnValue();
            diskImageMap.put(disk.getId(), cinderDisk.getImageId());
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error cloning Cinder disk for preview. '{}': {}", disk.getDiskAlias(), e.getMessage());
            isSucceeded = false;
        }
    }
    getReturnValue().setActionReturnValue(diskImageMap);
    persistCommand(getParameters().getParentCommand(), true);
    setSucceeded(isSucceeded);
}
#method_after
@Override
protected void executeCommand() {
    boolean isSucceeded = true;
    for (CinderDisk disk : getParameters().getCinderDisks()) {
        ImagesContainterParametersBase params = buildChildCommandParameters(disk);
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.TryBackToCinderSnapshot, params, cloneContextAndDetachFromParent());
        try {
            VdcReturnValueBase vdcReturnValueBase = future.get();
            if (!vdcReturnValueBase.getSucceeded()) {
                log.error("Error cloning Cinder disk '{}': {}", disk.getDiskAlias());
                getReturnValue().setFault(vdcReturnValueBase.getFault());
                isSucceeded = false;
                break;
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error cloning Cinder disk '{}': {}", disk.getDiskAlias(), e.getMessage());
            isSucceeded = false;
        }
    }
    persistCommand(getParameters().getParentCommand(), true);
    setSucceeded(isSucceeded);
}
#end_block

#method_before
private ImagesContainterParametersBase buildChildCommandParameters(CinderDisk cinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(cinderDisk.getImageId());
    createParams.setContainerId(cinderDisk.getId());
    createParams.setStorageDomainId(cinderDisk.getStorageIds().get(0));
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setDestinationImageId(cinderDisk.getImageId());
    createParams.setVmSnapshotId(getParameters().getVmSnapshotId());
    createParams.setParentCommand(getActionType());
    createParams.setParentParameters(getParameters());
    return createParams;
}
#method_after
private ImagesContainterParametersBase buildChildCommandParameters(CinderDisk cinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(cinderDisk.getImageId());
    createParams.setContainerId(cinderDisk.getId());
    cinderDisk.setDiskAlias(cinderDisk.getDiskAlias());
    cinderDisk.setVmSnapshotId(getParameters().getVmSnapshotId());
    createParams.setStorageDomainId(cinderDisk.getStorageIds().get(0));
    createParams.setEntityInfo(getParameters().getEntityInfo());
    return withRootCommandInfo(createParams, getParameters().getParentCommand());
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (!getParameters().isParentHasTasks()) {
        getBackend().endAction(getParameters().getParentCommand(), getParameters().getParentParameters(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    if (!getParameters().isParentHasTasks()) {
        getBackend().endAction(getParameters().getParentCommand(), getParameters().getParentParameters(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void processOldImageFromDb() {
    updateOldImageActive(Snapshot.SnapshotType.PREVIEW, false);
}
#method_after
@Override
protected void processOldImageFromDb() {
    updateOldImageAsActive(Snapshot.SnapshotType.PREVIEW, false);
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    updateOldImageActive(Snapshot.SnapshotType.ACTIVE, true);
    // Remove destination, unlock source:
    undoActionOnSourceAndDestination();
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    updateOldImageAsActive(Snapshot.SnapshotType.ACTIVE, true);
    // Remove destination, unlock source:
    undoActionOnSourceAndDestination();
    setSucceeded(true);
}
#end_block

#method_before
protected void restoreVmConfigFromSnapshot() {
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(getSnapshotDao().getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), getDstSnapshot(), getSnapshotDao().getId(getVm().getId(), SnapshotType.ACTIVE), getImagesToPreview(), getCompensationContext(), getVm().getVdsGroupCompatibilityVersion(), getCurrentUser());
}
#method_after
private void restoreVmConfigFromSnapshot() {
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(getSnapshotDao().getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), getDstSnapshot(), getSnapshotDao().getId(getVm().getId(), SnapshotType.ACTIVE), getImagesToPreview(), getCompensationContext(), getVm().getVdsGroupCompatibilityVersion(), getCurrentUser());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    boolean returnValue = true;
    final boolean restoreMemory = getParameters().isRestoreMemory() && FeatureSupported.memorySnapshot(getVm().getVdsGroupCompatibilityVersion()) && FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getVdsGroupCompatibilityVersion());
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, images, getCompensationContext());
            // being executed in the same transaction so we can restore the vm config and end the command.
            if (!filteredImages.isEmpty()) {
                getCompensationContext().stateChanged();
            } else {
                getVmStaticDAO().incrementDbGeneration(getVm().getId());
                restoreVmConfigFromSnapshot();
            }
            return null;
        }
    });
    if (!filteredImages.isEmpty()) {
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new VdcBLLException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new VdcBLLException(VdcBllErrors.CINDER_ERROR);
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    }
    setSucceeded(returnValue);
}
#method_after
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = getParameters().isRestoreMemory() && FeatureSupported.memorySnapshot(getVm().getVdsGroupCompatibilityVersion()) && FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getVdsGroupCompatibilityVersion());
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, images, getCompensationContext());
            // being executed in the same transaction so we can restore the vm config and end the command.
            if (!filteredImages.isEmpty()) {
                getCompensationContext().stateChanged();
            } else {
                getVmStaticDAO().incrementDbGeneration(getVm().getId());
                restoreVmConfigFromSnapshot();
            }
            return null;
        }
    });
    if (!filteredImages.isEmpty()) {
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new VdcBLLException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new VdcBLLException(VdcBllErrors.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    }
    setSucceeded(true);
}
#end_block

#method_before
private List<DiskImage> getImagesExcludedFromPreview(List<DiskImage> images, Guid previousActiveSnapshotId, Guid newActiveSnapshotId) {
    List<DiskImage> excludedImages = new ArrayList<>();
    for (DiskImage image : images) {
        if (((image.getDiskStorageType() == DiskStorageType.IMAGE) || (image.getDiskStorageType() == DiskStorageType.CINDER)) && image.getVmSnapshotId().equals(previousActiveSnapshotId)) {
            // Image is already active, hence only update snapshot ID.
            getImageDao().updateImageVmSnapshotId(image.getImageId(), newActiveSnapshotId);
            excludedImages.add(image);
        }
    }
    return excludedImages;
}
#method_after
private List<DiskImage> getImagesExcludedFromPreview(List<DiskImage> images, Guid previousActiveSnapshotId, Guid newActiveSnapshotId) {
    List<DiskImage> excludedImages = new ArrayList<>();
    for (DiskImage image : images) {
        if (image.getDiskStorageType().isSupportsSnapshots() && image.getVmSnapshotId().equals(previousActiveSnapshotId)) {
            // Image is already active, hence only update snapshot ID.
            getImageDao().updateImageVmSnapshotId(image.getImageId(), newActiveSnapshotId);
            excludedImages.add(image);
        }
    }
    return excludedImages;
}
#end_block

#method_before
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setIsLocal(StorageType.valueOf(xmlRpcStruct.get("type").toString()).isLocal());
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#method_after
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setIsLocal(StorageType.valueOf(xmlRpcStruct.get("type").toString()).isLocal());
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setMasterDomainVersion(masterVersion);
    }
    return sPool;
}
#end_block

#method_before
public static Map<String, LUNs> buildVmLunDisksData(Map<String, Object> xmlRpcStruct) {
    Map<String, Object> disks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_disks);
    Map<String, LUNs> lunsMap = new HashMap<>();
    if (disks != null) {
        for (Object diskAsObj : disks.values()) {
            Map<String, Object> disk = (Map<String, Object>) diskAsObj;
            String lunGuidString = AssignStringValue(disk, VdsProperties.lun_guid);
            if (!StringUtils.isEmpty(lunGuidString)) {
                LUNs lun = new LUNs();
                lun.setLUN_id(lunGuidString);
                if (disk.containsKey(VdsProperties.disk_true_size)) {
                    long sizeInBytes = AssignLongValue(disk, VdsProperties.disk_true_size);
                    int sizeInGB = SizeConverter.convert(sizeInBytes, SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GB).intValue();
                    lun.setDeviceSize(sizeInGB);
                }
                lunsMap.put(lunGuidString, lun);
            }
        }
    }
    return lunsMap;
}
#method_after
public static Map<String, LUNs> buildVmLunDisksData(Map<String, Object> xmlRpcStruct) {
    Map<String, Object> disks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_disks);
    Map<String, LUNs> lunsMap = new HashMap<>();
    if (disks != null) {
        for (Object diskAsObj : disks.values()) {
            Map<String, Object> disk = (Map<String, Object>) diskAsObj;
            String lunGuidString = AssignStringValue(disk, VdsProperties.lun_guid);
            if (!StringUtils.isEmpty(lunGuidString)) {
                LUNs lun = new LUNs();
                lun.setLUN_id(lunGuidString);
                if (disk.containsKey(VdsProperties.disk_true_size)) {
                    long sizeInBytes = AssignLongValue(disk, VdsProperties.disk_true_size);
                    int sizeInGB = SizeConverter.convert(sizeInBytes, SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GiB).intValue();
                    lun.setDeviceSize(sizeInGB);
                }
                lunsMap.put(lunGuidString, lun);
            }
        }
    }
    return lunsMap;
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.error("Illegal vm display_port '{}'.", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.error("Illegal vm display '{}'.", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.error("Illegal vm display_secure_port '{}'.", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.error("Illegal vm display type '{}'.", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        } else {
            vm.setGuestMemoryBuffered(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        } else {
            vm.setGuestMemoryCached(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        } else {
            vm.setGuestMemoryFree(null);
        }
    } else {
        vm.setGuestMemoryBuffered(null);
        vm.setGuestMemoryCached(null);
        vm.setGuestMemoryFree(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
    // Guest OS Info
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_OS_INFO)) {
        updateGuestOsInfo(vm, xmlRpcStruct);
    }
    // Guest Timezone
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_TIMEZONE)) {
        Map<String, Object> guestTimeZoneStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.GUEST_TIMEZONE);
        vm.setGuestOsTimezoneName(AssignStringValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_ZONE));
        vm.setGuestOsTimezoneOffset(AssignIntValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_OFFSET));
    }
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            Double rx_rate = AssignDoubleValue(nic, VdsProperties.rx_rate);
            Double rx_dropped = AssignDoubleValue(nic, VdsProperties.rx_dropped);
            Double tx_rate = AssignDoubleValue(nic, VdsProperties.tx_rate);
            Double tx_dropped = AssignDoubleValue(nic, VdsProperties.tx_dropped);
            stats.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
            stats.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
            stats.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
            stats.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
            stats.setSpeed(AssignIntValue(nic, VdsProperties.INTERFACE_SPEED));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#method_after
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            extractInterfaceStatistics(nic, stats);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(AssignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(AssignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(AssignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    } else {
        // for backward compatibility's sake
        vds.setLiveSnapshotSupport(true);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(AssignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(AssignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(AssignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    } else {
        // for backward compatibility's sake
        vds.setLiveSnapshotSupport(true);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
    updateAdditionalFeatures(vds, xmlRpcStruct);
}
#end_block

#method_before
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = AssignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                AuditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#method_after
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = AssignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface iface = nicsByName.get(entry.getKey());
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(iface) && !iface.isBondSlave()) {
                    networkUsage = (int) Math.max(networkUsage, computeInterfaceUsage(iface));
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(existingIface) && !existingIface.isBondSlave()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface, statsBuilder.isTotalStatsReported());
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
    updateV2VJobs(vds, xmlRpcStruct);
}
#end_block

#method_before
private static double computeInterfaceUsage(VdsNetworkInterface iface) {
    return Math.max(truncatePercentage(iface.getStatistics().getReceiveRate()), truncatePercentage(iface.getStatistics().getTransmitRate()));
}
#method_after
private static Double computeInterfaceUsage(VdsNetworkInterface iface, boolean totalStatsReported) {
    Double receiveRate = iface.getStatistics().getReceiveRate();
    Double transmitRate = iface.getStatistics().getTransmitRate();
    /**
     * TODO: only needed if rate reported by vdsm (in which case can't be null) - remove in 4.0 and turn
     * NetworkStatisticsBuilder.truncatePercentage() private
     */
    if (!totalStatsReported) {
        receiveRate = NetworkStatisticsBuilder.truncatePercentage(receiveRate);
        transmitRate = NetworkStatisticsBuilder.truncatePercentage(transmitRate);
    }
    if (receiveRate == null) {
        return transmitRate;
    } else if (transmitRate == null) {
        return receiveRate;
    } else {
        return Math.max(receiveRate, transmitRate);
    }
}
#end_block

#method_before
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode node = buildVdsNumaNodeStatistics(percentageFormatter, item);
            vdsNumaNodes.add(node);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.valueOf(item.getKey()));
            if (node != null) {
                node.getNumaNodeStatistics().setMemFree(AssignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#method_after
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vds.getNumaNodeList() != null && !vds.getNumaNodeList().isEmpty()) {
        vdsNumaNodes.addAll(vds.getNumaNodeList());
    }
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode nodeWithStatistics = buildVdsNumaNodeStatistics(percentageFormatter, item);
            if (vdsNumaNodes.isEmpty()) {
                vdsNumaNodes.add(nodeWithStatistics);
            } else {
                boolean foundNumaNode = false;
                // append the statistics to the correct numaNode (search by its Index.)
                for (VdsNumaNode currNumaNode : vdsNumaNodes) {
                    if (currNumaNode.getIndex() == nodeWithStatistics.getIndex()) {
                        currNumaNode.setNumaNodeStatistics(nodeWithStatistics.getNumaNodeStatistics());
                        foundNumaNode = true;
                        break;
                    }
                }
                // append new numaNode (contains only statistics) if not found existing
                if (!foundNumaNode) {
                    vdsNumaNodes.add(nodeWithStatistics);
                }
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.valueOf(item.getKey()));
            if (node != null && node.getNumaNodeStatistics() != null) {
                node.getNumaNodeStatistics().setMemFree(AssignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#end_block

#method_before
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#method_after
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                Boolean actual = Boolean.TRUE;
                if (internalValue.containsKey(VdsProperties.actual)) {
                    actual = (Boolean) internalValue.get(VdsProperties.actual);
                }
                data.setActual(actual);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#end_block

#method_before
private static Double AssignDoubleValue(Map<String, Object> input, String name) {
    Double returnValue = null;
    if (input.containsKey(name)) {
        String stringValue = (String) ((input.get(name) instanceof String) ? input.get(name) : null);
        returnValue = (stringValue == null) ? null : Double.parseDouble(stringValue);
    }
    return returnValue;
}
#method_after
private static Double AssignDoubleValue(Map<String, Object> input, String name) {
    Object value = input.get(name);
    if (value instanceof Double) {
        return (Double) value;
    } else if (value instanceof String) {
        return Double.parseDouble((String) value);
    }
    return null;
}
#end_block

#method_before
private static String AssignStringValueFromArray(Map<String, Object> input, String name) {
    if (input.containsKey(name)) {
        String[] arr = (String[]) ((input.get(name) instanceof String[]) ? input.get(name) : null);
        if (arr == null) {
            Object[] arr2 = (Object[]) ((input.get(name) instanceof Object[]) ? input.get(name) : null);
            if (arr2 != null) {
                arr = new String[arr2.length];
                for (int i = 0; i < arr2.length; i++) arr[i] = arr2[i].toString();
            }
        }
        if (arr != null) {
            return StringUtils.join(arr, ',');
        }
    }
    return null;
}
#method_after
private static String AssignStringValueFromArray(Map<String, Object> input, String name) {
    String[] arr = AssignStringArrayValue(input, name);
    if (arr != null) {
        return StringUtils.join(arr, ',');
    }
    return null;
}
#end_block

#method_before
private static void initAppsList(Map<String, Object> vmStruct, VmDynamic vm) {
    if (vmStruct.containsKey(VdsProperties.app_list)) {
        Object tempAppsList = vmStruct.get(VdsProperties.app_list);
        if (tempAppsList instanceof Object[]) {
            Object[] apps = (Object[]) tempAppsList;
            StringBuilder builder = new StringBuilder();
            boolean firstTime = true;
            for (Object app : apps) {
                String appString = (String) ((app instanceof String) ? app : null);
                if (app == null) {
                    log.warn("Failed to convert app: [null] to string");
                }
                if (!firstTime) {
                    builder.append(",");
                } else {
                    firstTime = false;
                }
                builder.append(appString);
            }
            vm.setAppList(builder.toString());
        } else {
            vm.setAppList("");
        }
    }
}
#method_after
private static void initAppsList(Map<String, Object> vmStruct, VmDynamic vm) {
    if (vmStruct.containsKey(VdsProperties.app_list)) {
        Object tempAppsList = vmStruct.get(VdsProperties.app_list);
        if (tempAppsList instanceof Object[]) {
            Object[] apps = (Object[]) tempAppsList;
            StringBuilder builder = new StringBuilder();
            boolean firstTime = true;
            for (Object app : apps) {
                String appString = (String) ((app instanceof String) ? app : null);
                if (app == null) {
                    log.warn("Failed to convert app: [null] to string");
                    // Don't process this
                    continue;
                }
                if (appString == null) {
                    // Note: app cannot be null here anymore
                    log.warn("Failed to convert app: [" + app.getClass().getName() + "] is not a string");
                    // Don't process this
                    continue;
                }
                if (!firstTime) {
                    builder.append(",");
                } else {
                    firstTime = false;
                }
                builder.append(appString);
            }
            vm.setAppList(builder.toString());
        } else {
            vm.setAppList("");
        }
    }
}
#end_block

#method_before
public static void updateNetworkData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, xmlRpcStruct);
    addHostVlanDevices(vds, xmlRpcStruct);
    addHostBondDevices(vds, xmlRpcStruct);
    // by now, if the host is communicating with engine over a valid interface, the interface will have the host's engine IP
    resolveActiveNic(vds);
    addHostNetworksAndUpdateInterfaces(vds, xmlRpcStruct);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (xmlRpcStruct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    }
}
#method_after
public static void updateNetworkData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, xmlRpcStruct);
    addHostVlanDevices(vds, xmlRpcStruct);
    addHostBondDevices(vds, xmlRpcStruct);
    addHostNetworksAndUpdateInterfaces(vds, xmlRpcStruct);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (xmlRpcStruct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    }
}
#end_block

#method_before
private static void resolveActiveNic(VDS vds) {
    InetAddress mgmt = null;
    try {
        mgmt = InetAddress.getByName(vds.getHostName());
    } catch (SecurityException ex) {
        log.warn("Fail to resolve host ip by name '{}', Details: '{}' ", vds.getHostName(), ex.toString());
        log.debug("Exception", ex);
        return;
    } catch (UnknownHostException ex) {
        log.warn("Fail to resolve host ip by name '{}', Details: '{}' ", vds.getHostName(), ex.toString());
        log.debug("Exception", ex);
        return;
    }
    String mgmtAdd = mgmt.getHostAddress().trim();
    for (VdsNetworkInterface iface : vds.getInterfaces()) {
        if (iface.getAddress().equals(mgmtAdd)) {
            vds.setActiveNic(iface.getName());
        }
    }
}
#method_after
private static VdsNetworkInterface resolveActiveNic(VDS host, String hostIp) {
    if (hostIp == null) {
        return null;
    }
    final String managementAddress = hostIp;
    VdsNetworkInterface activeIface = LinqUtils.firstOrNull(host.getInterfaces(), new InterfaceByAddressPredicate(managementAddress));
    return activeIface;
}
#end_block

#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Object> networks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    if (networks != null) {
        vds.getNetworks().clear();
        for (Entry<String, Object> entry : networks.entrySet()) {
            Map<String, Object> network = (Map<String, Object>) entry.getValue();
            if (network != null) {
                Network net = createNetworkData(entry.getKey(), network);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vds, xmlRpcStruct, network);
                for (VdsNetworkInterface iface : interfaces) {
                    updateNetworkDetailsInInterface(iface, network, vds, net);
                }
                vds.getNetworks().add(net);
                reportInvalidInterfacesForNetwork(interfaces, net, vds);
            }
        }
    }
}
#method_after
private static void addHostNetworksAndUpdateInterfaces(VDS host, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    final String hostActiveNicName = findActiveNicName(host, bridges);
    host.setActiveNic(hostActiveNicName);
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(host.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(host.getVdsGroupCompatibilityVersion());
    if (networks != null) {
        host.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String networkName = entry.getKey();
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgesReported && bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String addr = extractAddress(effectiveProperties);
                String subnet = extractSubnet(effectiveProperties);
                String gateway = (String) effectiveProperties.get(VdsProperties.GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = bridgesReported ? findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties) : findBridgedNetworkInterfaces(networkProperties, vdsInterfaces);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setAddress(addr);
                    iface.setSubnet(subnet);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), host.getVdsGroupId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    setGatewayIfNecessary(iface, host, gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, host, iface);
                    }
                }
                host.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, host);
            }
        }
    }
}
#end_block

#method_before
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, Network network, VDS vds) {
    if (interfaces.isEmpty()) {
        AuditLogDirector.log(createHostNetworkAuditLog(network, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(network, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        AuditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#method_after
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#end_block

#method_before
protected static AuditLogableBase createHostNetworkAuditLog(Network network, VDS vds) {
    AuditLogableBase logable = new AuditLogableBase(vds.getId());
    logable.addCustomValue("NetworkName", network.getName());
    return logable;
}
#method_after
protected static AuditLogableBase createHostNetworkAuditLog(String networkName, VDS vds) {
    AuditLogableBase logable = new AuditLogableBase(vds.getId());
    logable.addCustomValue("NetworkName", networkName);
    return logable;
}
#end_block

#method_before
private static List<VdsNetworkInterface> findNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct, Map<String, Object> network) {
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(vds.getInterfaces());
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    if (FeatureSupported.bridgesReportByVdsm(vds.getVdsGroupCompatibilityVersion())) {
        VdsNetworkInterface iface = null;
        String interfaceName = (String) network.get(VdsProperties.INTERFACE);
        if (interfaceName != null) {
            iface = vdsInterfaces.get(interfaceName);
            if (iface == null) {
                Map<String, Object> bridges = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
                if (bridges != null && bridges.containsKey(interfaceName)) {
                    interfaces.addAll(findBridgedNetworkInterfaces((Map<String, Object>) bridges.get(interfaceName), vdsInterfaces));
                }
            } else {
                interfaces.add(iface);
            }
        }
    } else {
        interfaces.addAll(findBridgedNetworkInterfaces(network, vdsInterfaces));
    }
    return interfaces;
}
#method_after
private static List<VdsNetworkInterface> findNetworkInterfaces(Map<String, VdsNetworkInterface> vdsInterfaces, String interfaceName, Map<String, Object> bridgeProperties) {
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    VdsNetworkInterface iface = vdsInterfaces.get(interfaceName);
    if (iface == null) {
        if (bridgeProperties != null) {
            interfaces.addAll(findBridgedNetworkInterfaces(bridgeProperties, vdsInterfaces));
        }
    } else {
        interfaces.add(iface);
    }
    return interfaces;
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> bonds = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Object> entry : bonds.entrySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.newGuid());
            iStats.setVdsId(vds.getId());
            iface.setId(iStats.getId());
            iface.setName(entry.getKey());
            iface.setVdsId(vds.getId());
            iface.setBonded(true);
            Map<String, Object> bond = (Map<String, Object>) entry.getValue();
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                iface.setAddress((String) bond.get("addr"));
                iface.setSubnet((String) bond.get("netmask"));
                if (bond.get("slaves") != null) {
                    addBondDeviceToHost(vds, iface, (Object[]) bond.get("slaves"));
                }
                if (StringUtils.isNotBlank((String) bond.get(VdsProperties.MTU))) {
                    iface.setMtu(Integer.parseInt((String) bond.get(VdsProperties.MTU)));
                }
                Map<String, Object> config = (Map<String, Object>) bond.get("cfg");
                if (config != null && config.get("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.get("BONDING_OPTS").toString());
                }
                addBootProtocol(config, vds, iface);
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        boolean cfgEntriesDeprecated = FeatureSupported.cfgEntriesDeprecated(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                if (cfgEntriesDeprecated) {
                    bondOptions = bondProperties.get("opts");
                } else {
                    Map<String, Object> config = (Map<String, Object>) bondProperties.get("cfg");
                    bondOptions = (config == null) ? null : config.get("BONDING_OPTS");
                }
                if (bondOptions != null) {
                    bond.setBondOptions(bondOptions.toString());
                }
            }
        }
    }
}
#end_block

#method_before
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Object> vlans = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Object> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.newGuid());
            iface.setId(iStats.getId());
            String vlanDeviceName = entry.getKey();
            iface.setName(vlanDeviceName);
            iface.setVdsId(vds.getId());
            Map<String, Object> vlan = (Map<String, Object>) entry.getValue();
            if (vlan.get(VdsProperties.VLAN_ID) != null && vlan.get(VdsProperties.BASE_INTERFACE) != null) {
                iface.setVlanId((Integer) vlan.get(VdsProperties.VLAN_ID));
                iface.setBaseInterface((String) vlan.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                iface.setVlanId(Integer.parseInt(vlanId));
                iface.setBaseInterface(names[0]);
            }
            iface.setAddress((String) vlan.get("addr"));
            iface.setSubnet((String) vlan.get("netmask"));
            if (StringUtils.isNotBlank((String) vlan.get(VdsProperties.MTU))) {
                iface.setMtu(Integer.parseInt((String) vlan.get(VdsProperties.MTU)));
            }
            iStats.setVdsId(vds.getId());
            addBootProtocol((Map<String, Object>) vlan.get("cfg"), vds, iface);
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Map<String, Object>> vlans = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Map<String, Object>> entry : vlans.entrySet()) {
            VdsNetworkInterface vlan = new Vlan();
            updateCommonInterfaceData(vlan, vds, entry);
            String vlanDeviceName = entry.getKey();
            Map<String, Object> vlanProperties = entry.getValue();
            if (vlanProperties.get(VdsProperties.VLAN_ID) != null && vlanProperties.get(VdsProperties.BASE_INTERFACE) != null) {
                vlan.setVlanId((Integer) vlanProperties.get(VdsProperties.VLAN_ID));
                vlan.setBaseInterface((String) vlanProperties.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                vlan.setVlanId(Integer.parseInt(vlanId));
                vlan.setBaseInterface(names[0]);
            }
            vds.getInterfaces().add(vlan);
        }
    }
}
#end_block

#method_before
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> nics = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Object> entry : nics.entrySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.newGuid());
            iface.setId(iStats.getId());
            iface.setName(entry.getKey());
            iface.setVdsId(vds.getId());
            updateNetworkInterfaceDataFromHost(iface, vds, (Map<String, Object>) entry.getValue());
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> nics = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Map<String, Object>> entry : nics.entrySet()) {
            VdsNetworkInterface nic = new Nic();
            updateCommonInterfaceData(nic, vds, entry);
            Map<String, Object> nicProperties = entry.getValue();
            if (nicProperties != null) {
                if (nicProperties.get("speed") != null) {
                    Object speed = nicProperties.get("speed");
                    nic.setSpeed((Integer) speed);
                }
                nic.setMacAddress((String) nicProperties.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                String mac = (String) nicProperties.get("permhwaddr");
                if (mac != null) {
                    // TODO remove when the minimal supported vdsm version is >=3.6
                    // in older VDSM version, slave's Mac is in upper case
                    nic.setMacAddress(mac.toLowerCase());
                }
            }
            vds.getInterfaces().add(nic);
        }
    }
}
#end_block

#method_before
private static void addBootProtocol(Map<String, Object> cfg, VDS host, VdsNetworkInterface iface) {
    NetworkBootProtocol bootproto = NetworkBootProtocol.NONE;
    if (cfg != null) {
        String bootProtocol = (String) cfg.get("BOOTPROTO");
        if (bootProtocol != null) {
            if (bootProtocol.toLowerCase().equals("dhcp")) {
                bootproto = NetworkBootProtocol.DHCP;
            } else if (bootProtocol.toLowerCase().equals("none") || bootProtocol.toLowerCase().equals("static")) {
                if (StringUtils.isNotEmpty((String) cfg.get("IPADDR"))) {
                    bootproto = NetworkBootProtocol.STATIC_IP;
                }
            }
        } else if (StringUtils.isNotEmpty((String) cfg.get("IPADDR"))) {
            bootproto = NetworkBootProtocol.STATIC_IP;
        }
        if (bootproto == NetworkBootProtocol.STATIC_IP) {
            String gateway = (String) cfg.get(VdsProperties.GATEWAY);
            if (StringUtils.isNotEmpty(gateway)) {
                setGatewayIfNecessary(iface, host, gateway.toString());
            }
        }
    }
    iface.setBootProtocol(bootproto);
}
#method_after
private static void addBootProtocol(Map<String, Object> entry, VDS host, VdsNetworkInterface iface) {
    BootProtocolResolver resolver = FeatureSupported.cfgEntriesDeprecated(host.getVdsGroupCompatibilityVersion()) ? new NoCfgBootProtocolResolver(entry, iface, host) : new CfgBootProtocolResolver(entry, iface, host);
    resolver.resolve();
}
#end_block

#method_before
private static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || NetworkUtils.getEngineNetwork().equals(iface.getNetworkName()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#method_after
public static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    final ManagementNetworkUtil managementNetworkUtil = getManagementNetworkUtil();
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || managementNetworkUtil.isManagementNetwork(iface.getNetworkName(), host.getVdsGroupId()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#end_block

#method_before
public void createManagementNetworkIfRequired() {
    final String managementNetwork = NetworkUtils.getEngineNetwork();
    if (host == null) {
        return;
    }
    Map<String, Network> vdsNetworks = Entities.entitiesByName(host.getNetworks());
    if (vdsNetworks.containsKey(managementNetwork)) {
        log.info("The management network '{}' is already configured on host '{}'", managementNetwork, host.getName());
        return;
    }
    if (!FeatureSupported.setupManagementNetwork(host.getVdsGroupCompatibilityVersion())) {
        log.warn("Cluster of host '{}' does not support normalize management network feature", host.getName());
        return;
    }
    VdsNetworkInterface nic = findNicToSetupManagementNetwork();
    if (nic == null) {
        return;
    }
    List<VdsNetworkInterface> interfaces = filterBondsWithoutSlaves(host.getInterfaces());
    if (interfaces.contains(nic)) {
        nic.setNetworkName(managementNetwork);
        configureManagementNetwork(createSetupNetworkParams(interfaces));
    } else {
        final AuditLogableBase event = createEvent();
        event.addCustomValue("InterfaceName", nic.getName());
        AuditLogDirector.log(event, AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#method_after
public void createManagementNetworkIfRequired() {
    if (host == null) {
        return;
    }
    final String managementNetworkName = resolveManagementNetworkName();
    final String hostManagementNetworkAddress = resolveHostManagementNetworkAddress(managementNetworkName);
    final String hostIp = NetworkUtils.getHostByIp(host);
    if (hostManagementNetworkAddress != null && hostManagementNetworkAddress.equals(hostIp)) {
        log.info("The management network '{}' is already configured on host '{}'", managementNetworkName, host.getName());
        return;
    }
    if (!FeatureSupported.setupManagementNetwork(host.getVdsGroupCompatibilityVersion())) {
        log.warn("Cluster of host '{}' does not support normalize management network feature", host.getName());
        return;
    }
    VdsNetworkInterface nic = findNicToSetupManagementNetwork();
    if (nic == null) {
        return;
    }
    List<VdsNetworkInterface> interfaces = filterBondsWithoutSlaves(host.getInterfaces());
    if (interfaces.contains(nic)) {
        nic.setNetworkName(managementNetworkName);
        configureManagementNetwork(createSetupNetworkParams(interfaces));
    } else {
        final AuditLogableBase event = createEvent();
        event.addCustomValue("InterfaceName", nic.getName());
        auditLogDirector.log(event, AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#end_block

#method_before
private VdsNetworkInterface findNicToSetupManagementNetwork() {
    VdsNetworkInterface nic = Entities.entitiesByName(host.getInterfaces()).get(host.getActiveNic());
    if (nic == null) {
        log.warn("Failed to find a valid interface for the management network." + " If the interface is a bridge, it should be torn-down manually.", host.getActiveNic(), host.getName());
        throw new NetworkConfiguratorException(String.format("Invalid interface for management network"));
    }
    Network managementNetwork = getDbFacade().getNetworkDao().getByNameAndDataCenter(NetworkUtils.getEngineNetwork(), host.getStoragePoolId());
    if (managementNetwork.getName().equals(nic.getNetworkName())) {
        return null;
    }
    if (!nicHasValidVlanId(managementNetwork, nic)) {
        final AuditLogableBase event = createEvent();
        event.addCustomValue("VlanId", resolveVlanId(nic.getVlanId()));
        event.addCustomValue("MgmtVlanId", resolveVlanId(managementNetwork.getVlanId()));
        event.addCustomValue("InterfaceName", nic.getName());
        AuditLogDirector.log(event, AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
    return nic;
}
#method_after
private VdsNetworkInterface findNicToSetupManagementNetwork() {
    VdsNetworkInterface nic = Entities.entitiesByName(host.getInterfaces()).get(host.getActiveNic());
    if (nic == null) {
        log.warn("Failed to find a valid interface for the management network of host {}." + " If the interface {} is a bridge, it should be torn-down manually.", host.getName(), host.getActiveNic());
        throw new NetworkConfiguratorException(String.format("Interface %s is invalid for management network", host.getActiveNic()));
    }
    final Network managementNetwork = getManagementNetworkUtil().getManagementNetwork(host.getVdsGroupId());
    if (managementNetwork.getName().equals(nic.getNetworkName())) {
        return null;
    }
    if (!nicHasValidVlanId(managementNetwork, nic)) {
        final AuditLogableBase event = createEvent();
        event.addCustomValue("VlanId", resolveVlanId(nic.getVlanId()));
        event.addCustomValue("MgmtVlanId", resolveVlanId(managementNetwork.getVlanId()));
        event.addCustomValue("InterfaceName", nic.getName());
        auditLogDirector.log(event, AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
    return nic;
}
#end_block

#method_before
public List<VdsNetworkInterface> filterBondsWithoutSlaves(List<VdsNetworkInterface> interfaces) {
    List<VdsNetworkInterface> filteredList = new ArrayList<VdsNetworkInterface>();
    Map<String, Integer> bonds = new HashMap<String, Integer>();
    for (VdsNetworkInterface iface : interfaces) {
        if (Boolean.TRUE.equals(iface.getBonded())) {
            bonds.put(iface.getName(), 0);
        }
    }
    for (VdsNetworkInterface iface : interfaces) {
        if (bonds.containsKey(iface.getBondName())) {
            bonds.put(iface.getBondName(), bonds.get(iface.getBondName()) + 1);
        }
    }
    for (VdsNetworkInterface iface : interfaces) {
        if (!bonds.containsKey(iface.getName()) || bonds.get(iface.getName()) >= 2) {
            filteredList.add(iface);
        }
    }
    return filteredList;
}
#method_after
public List<VdsNetworkInterface> filterBondsWithoutSlaves(List<VdsNetworkInterface> interfaces) {
    List<VdsNetworkInterface> filteredList = new ArrayList<>();
    Map<String, Integer> bonds = new HashMap<>();
    for (VdsNetworkInterface iface : interfaces) {
        if (Boolean.TRUE.equals(iface.getBonded())) {
            bonds.put(iface.getName(), 0);
        }
    }
    for (VdsNetworkInterface iface : interfaces) {
        if (bonds.containsKey(iface.getBondName())) {
            bonds.put(iface.getBondName(), bonds.get(iface.getBondName()) + 1);
        }
    }
    for (VdsNetworkInterface iface : interfaces) {
        if (!bonds.containsKey(iface.getName()) || bonds.get(iface.getName()) >= 2) {
            filteredList.add(iface);
        }
    }
    return filteredList;
}
#end_block

#method_before
private void configureManagementNetwork(SetupNetworksParameters parameters) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.SetupNetworks, parameters, cloneContextAndDetachFromParent());
    if (retVal.getSucceeded()) {
        retVal = getBackend().runInternalAction(VdcActionType.CommitNetworkChanges, new VdsActionParameters(parameters.getVdsId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            AuditLogDirector.log(createEvent(), AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, NETWORK_CONFIG_LOG_ERR);
            throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
        }
    } else {
        AuditLogDirector.log(createEvent(), AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#method_after
private void configureManagementNetwork(SetupNetworksParameters parameters) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.SetupNetworks, parameters, cloneContextAndDetachFromParent());
    if (retVal.getSucceeded()) {
        retVal = getBackend().runInternalAction(VdcActionType.CommitNetworkChanges, new VdsActionParameters(parameters.getVdsId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            auditLogDirector.log(createEvent(), AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, NETWORK_CONFIG_LOG_ERR);
            throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
        }
    } else {
        auditLogDirector.log(createEvent(), AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Keep a copy of the execution time before conversion to engine time zone during scheduling
    Time originalExecutionTime = getSchedule().getExecutionTime();
    // schedule the snapshot creation task
    try {
        String jobId = scheduleJob();
        if (jobId != null) {
            setSucceeded(true);
            getSchedule().setJobId(jobId);
            // reverting to original execution time in UI populated time zone
            getSchedule().setExecutionTime(originalExecutionTime);
            getGlusterVolumeSnapshotScheduleDao().save(getSchedule());
        } else {
            setSucceeded(false);
        }
    } catch (Exception ex) {
        setSucceeded(false);
        handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SCHEDULE_FAILED, ex.getMessage());
    }
}
#method_after
@Override
protected void executeCommand() {
    // Keep a copy of the execution time before conversion to engine time zone during scheduling
    Time originalExecutionTime = getSchedule().getExecutionTime();
    // schedule the snapshot creation task
    try {
        String jobId = scheduleJob();
        setSucceeded(true);
        getSchedule().setJobId(jobId);
        // reverting to original execution time in UI populated time zone
        getSchedule().setExecutionTime(originalExecutionTime);
        getGlusterVolumeSnapshotScheduleDao().save(getSchedule());
    } catch (Exception ex) {
        setSucceeded(false);
        handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SCHEDULE_FAILED, ex.getMessage());
    }
}
#end_block

#method_before
@Override
public String scheduleACronJob(Object instance, String methodName, Class<?>[] inputTypes, Object[] inputParams, String cronExpression, Date startAt, Date endBy) throws Exception {
    if (!validate(instance, inputTypes)) {
        return null;
    }
    return super.scheduleACronJob(instance, methodName, inputTypes, inputParams, cronExpression, startAt, endBy);
}
#method_after
@Override
public String scheduleACronJob(Object instance, String methodName, Class<?>[] inputTypes, Object[] inputParams, String cronExpression, Date startAt, Date endBy) {
    if (!validate(instance, inputTypes)) {
        throw new RuntimeException("Failed to validate input parameters for scheduling. Only primitives or String values are allowed.");
    }
    return super.scheduleACronJob(instance, methodName, inputTypes, inputParams, cronExpression, startAt, endBy);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CREATE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CREATE);
    super.setActionMessageParameters();
}
#end_block

#method_before
protected String scheduleJob() throws Exception {
    // convert the execution time to engine time zone
    if (schedule.getExecutionTime() != null) {
        Time convertedTime = GlusterUtil.getInstance().convertTime(schedule.getExecutionTime(), schedule.getTimeZone());
        schedule.setExecutionTime(convertedTime);
    }
    // convert the start date and end by date to the given timezone
    Date convertedStartDate = getGlusterUtil().convertDate(schedule.getStartDate(), schedule.getTimeZone());
    Date convertedEndByDate = getGlusterUtil().convertDate(schedule.getEndByDate(), schedule.getTimeZone());
    String cronExpression = GlusterUtil.getInstance().getCronExpression(schedule);
    if (cronExpression == null)
        return null;
    return getDbSchedulUtil().scheduleACronJob(new GlusterSnapshotScheduleJob(), "onTimer", new Class[] { String.class, String.class, String.class, String.class, Boolean.class }, new Object[] { upServer.getId().toString(), getGlusterVolumeId().toString(), schedule.getSnapshotNamePrefix(), schedule.getSnapshotDescription(), force }, cronExpression, convertedStartDate, convertedEndByDate);
}
#method_after
protected String scheduleJob() {
    // convert the execution time to engine time zone
    if (schedule.getExecutionTime() != null) {
        Time convertedTime = GlusterUtil.getInstance().convertTime(schedule.getExecutionTime(), schedule.getTimeZone());
        schedule.setExecutionTime(convertedTime);
    }
    // convert the start date and end by date to the given timezone
    Date convertedStartDate = getGlusterUtil().convertDate(schedule.getStartDate(), schedule.getTimeZone());
    Date convertedEndByDate = getGlusterUtil().convertDate(schedule.getEndByDate(), schedule.getTimeZone());
    String cronExpression = GlusterUtil.getInstance().getCronExpression(schedule);
    if (cronExpression == null)
        throw new RuntimeException("Unable to form cron expression for schedule. Invalid scheduling details.");
    return getDbSchedulUtil().scheduleACronJob(new GlusterSnapshotScheduleJob(), "onTimer", new Class[] { String.class, String.class, String.class, String.class, Boolean.class }, new Object[] { upServer.getId().toString(), getGlusterVolumeId().toString(), schedule.getSnapshotNamePrefix(), schedule.getSnapshotDescription(), force }, cronExpression, convertedStartDate, convertedEndByDate);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid volumeId = getGlusterVolumeId();
    GlusterVolumeSnapshotSchedule fetchedSchedule = getGlusterVolumeSnapshotScheduleDao().getByVolumeId(volumeId);
    String jobId = fetchedSchedule.getJobId();
    // delete the existing job
    getDbSchedulUtil().deleteJob(jobId);
    GlusterVolumeSnapshotSchedule schedule = getSchedule();
    if (schedule.getRecurrence() != null) {
        // Keep a copy of the execution time before conversion to engine time zone
        Time originalExecutionTime = schedule.getExecutionTime();
        try {
            String newJobId = scheduleJob();
            if (newJobId != null) {
                setSucceeded(true);
                schedule.setJobId(newJobId);
                // reverting to original execution time in UI populated time zone
                schedule.setExecutionTime(originalExecutionTime);
                getGlusterVolumeSnapshotScheduleDao().updateScheduleByVolumeId(volumeId, schedule);
            } else {
                setSucceeded(false);
            }
        } catch (Exception ex) {
            setSucceeded(false);
            handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_RESCHEDULE_FAILED, ex.getMessage());
        }
    } else {
        getGlusterVolumeSnapshotScheduleDao().removeByVolumeId(volumeId);
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid volumeId = getGlusterVolumeId();
    GlusterVolumeSnapshotSchedule fetchedSchedule = getGlusterVolumeSnapshotScheduleDao().getByVolumeId(volumeId);
    String jobId = fetchedSchedule.getJobId();
    // delete the existing job
    getDbSchedulUtil().deleteJob(jobId);
    GlusterVolumeSnapshotSchedule schedule = getSchedule();
    if (schedule.getRecurrence() != null) {
        // Keep a copy of the execution time before conversion to engine time zone
        Time originalExecutionTime = schedule.getExecutionTime();
        try {
            String newJobId = scheduleJob();
            setSucceeded(true);
            schedule.setJobId(newJobId);
            // reverting to original execution time in UI populated time zone
            schedule.setExecutionTime(originalExecutionTime);
            getGlusterVolumeSnapshotScheduleDao().updateScheduleByVolumeId(volumeId, schedule);
        } catch (Exception ex) {
            setSucceeded(false);
            handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_RESCHEDULE_FAILED, ex.getMessage());
        }
    } else {
        getGlusterVolumeSnapshotScheduleDao().removeByVolumeId(volumeId);
        setSucceeded(true);
    }
}
#end_block

#method_before
public String scheduleACronJob(Object instance, String methodName, Class<?>[] inputTypes, Object[] inputParams, String cronExpression, Date startAt, Date endBy) throws Exception {
    JobDetail job = createJobWithBasicMapValues(instance, methodName, inputTypes, inputParams);
    try {
        String triggerName = generateUniqueNameForInstance(instance, TRIGGER_PREFIX);
        Trigger trigger = newTrigger().withIdentity(triggerName, Scheduler.DEFAULT_GROUP).withSchedule(cronSchedule(cronExpression)).startAt(startAt).endAt(endBy).build();
        sched.scheduleJob(job, trigger);
    } catch (Exception se) {
        log.error("failed to schedule job: {}", se.getMessage());
        log.debug("Exception", se);
        throw se;
    }
    return job.getKey().getName();
}
#method_after
public String scheduleACronJob(Object instance, String methodName, Class<?>[] inputTypes, Object[] inputParams, String cronExpression, Date startAt, Date endBy) {
    JobDetail job = createJobWithBasicMapValues(instance, methodName, inputTypes, inputParams);
    try {
        String triggerName = generateUniqueNameForInstance(instance, TRIGGER_PREFIX);
        Trigger trigger = newTrigger().withIdentity(triggerName, Scheduler.DEFAULT_GROUP).withSchedule(cronSchedule(cronExpression)).startAt(startAt).endAt(endBy).build();
        sched.scheduleJob(job, trigger);
    } catch (Exception se) {
        log.error("failed to schedule job: {}", se.getMessage());
        log.debug("Exception", se);
        throw new RuntimeException(se);
    }
    return job.getKey().getName();
}
#end_block

#method_before
protected boolean setUpPasswordlessSSH(Guid masterUpServerId, Set<Guid> resmoteServerSet, String userName) {
    List<String> pubKeys = readPubKey(masterUpServerId);
    boolean canProceed = pubKeys != null && pubKeys.size() > 0;
    if (canProceed) {
        canProceed = updatePubKeysToRemoteHosts(pubKeys, resmoteServerSet, userName);
    }
    return canProceed;
}
#method_after
protected boolean setUpPasswordlessSSH(Guid masterUpServerId, Set<Guid> remoteServerSet, String userName) {
    List<String> pubKeys = readPubKey(masterUpServerId);
    boolean canProceed = pubKeys != null && pubKeys.size() > 0;
    if (canProceed) {
        canProceed = updatePubKeysToRemoteHosts(pubKeys, remoteServerSet, userName);
    }
    return canProceed;
}
#end_block

#method_before
private boolean updatePubKeysToRemoteHosts(final List<String> pubKeys, Set<Guid> remoteServersSet, final String userName) {
    List<Callable<Boolean>> slaveWritePubKeyList = new ArrayList<>();
    for (final Guid currentRemoteHost : remoteServersSet) {
        slaveWritePubKeyList.add(new Callable<Boolean>() {

            @Override
            public Boolean call() throws Exception {
                return getBackend().runInternalAction(VdcActionType.UpdateGlusterHostPubKeyToSlaveInternal, new UpdateGlusterHostPubKeyToSlaveParameters(currentRemoteHost, pubKeys, userName)).getSucceeded();
            }
        });
    }
    List<Boolean> returnStatuses = ThreadPoolUtil.invokeAll(slaveWritePubKeyList);
    for (Boolean currentReturnStatus : returnStatuses) {
        if (!currentReturnStatus) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean updatePubKeysToRemoteHosts(final List<String> pubKeys, Set<Guid> remoteServersSet, final String userName) {
    List<Callable<Boolean>> slaveWritePubKeyList = new ArrayList<>();
    for (final Guid currentRemoteHostId : remoteServersSet) {
        slaveWritePubKeyList.add(new Callable<Boolean>() {

            @Override
            public Boolean call() throws Exception {
                return getBackend().runInternalAction(VdcActionType.UpdateGlusterHostPubKeyToSlaveInternal, new UpdateGlusterHostPubKeyToSlaveParameters(currentRemoteHostId, pubKeys, userName)).getSucceeded();
            }
        });
    }
    List<Boolean> returnStatuses = ThreadPoolUtil.invokeAll(slaveWritePubKeyList);
    for (Boolean currentReturnStatus : returnStatuses) {
        if (!currentReturnStatus) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean createGeoRepSession(Guid upServerId, String masterVolumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force, Boolean handleError) {
    GlusterVolumeGeoRepSessionVDSParameters params = new GlusterVolumeGeoRepSessionVDSParameters(upServer.getId(), getGlusterVolumeName(), slaveHost.getHostName(), getParameters().getSlaveVolumeName(), getParameters().getUserName(), getParameters().isForce());
    VDSReturnValue createSessionReturnValue = runVdsCommand(VDSCommandType.CreateGlusterVolumeGeoRepSession, params);
    if (createSessionReturnValue.getSucceeded()) {
        setSucceeded(true);
        return true;
    } else {
        setSucceeded(false);
        if (handleError) {
            handleVdsError(AuditLogType.GLUSTER_GEOREP_SESSION_CREATE_FAILED, createSessionReturnValue.getVdsError().getMessage());
        }
        return false;
    }
}
#method_after
protected boolean createGeoRepSession(Guid upServerId, String masterVolumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force, Boolean handleError) {
    GlusterVolumeGeoRepSessionVDSParameters params = new GlusterVolumeGeoRepSessionVDSParameters(upServerId, masterVolumeName, remoteHost, remoteVolumeName, userName, force);
    VDSReturnValue createSessionReturnValue = runVdsCommand(VDSCommandType.CreateGlusterVolumeGeoRepSession, params);
    if (createSessionReturnValue.getSucceeded()) {
        setSucceeded(true);
        return true;
    } else {
        setSucceeded(false);
        if (handleError) {
            handleVdsError(AuditLogType.GLUSTER_GEOREP_SESSION_CREATE_FAILED, createSessionReturnValue.getVdsError().getMessage());
        }
        return false;
    }
}
#end_block

#method_before
@Override
protected VM postPopulate(VM from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    from.getPayloads().getPayload().get(0).setType(MappingTestHelper.shuffle(VmDeviceType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    CpuTune cpuTune = new CpuTune();
    VCpuPin pin = new VCpuPin();
    pin.setVcpu(33);
    pin.setCpuSet("1-4,6");
    cpuTune.getVCpuPin().add(pin);
    from.getCpu().setCpuTune(cpuTune);
    from.setTimezone("Australia/Darwin");
    from.setPlacementPolicy(new VmPlacementPolicy());
    from.getPlacementPolicy().setHost(new Host());
    from.getPlacementPolicy().getHost().setId(Guid.Empty.toString());
    for (GuestNicConfiguration guestNic : from.getInitialization().getNicConfigurations().getNicConfigurations()) {
        guestNic.setBootProtocol(MappingTestHelper.shuffle(BootProtocol.class).value());
    }
    from.getDisplay().setType("spice");
    from.getSerialNumber().setPolicy(SerialNumberPolicy.CUSTOM.value());
    from.getDisplay().setFileTransferEnabled(true);
    from.getDisplay().setCopyPasteEnabled(true);
    from.getMigration().setAutoConverge(InheritableBoolean.TRUE.value());
    from.getMigration().setCompressed(InheritableBoolean.TRUE.value());
    from.getDisplay().setDisconnectAction(DisplayDisconnectAction.LOCK_SCREEN.toString());
    return from;
}
#method_after
@Override
protected VM postPopulate(VM from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    from.getPayloads().getPayload().get(0).setType(MappingTestHelper.shuffle(VmDeviceType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    CpuTune cpuTune = new CpuTune();
    VCpuPin pin = new VCpuPin();
    pin.setVcpu(33);
    pin.setCpuSet("1-4,6");
    cpuTune.getVCpuPin().add(pin);
    from.getCpu().setCpuTune(cpuTune);
    from.setTimeZone(new TimeZone());
    from.getTimeZone().setName("Australia/Darwin");
    from.setTimezone(from.getTimeZone().getName());
    from.setPlacementPolicy(new VmPlacementPolicy());
    from.getPlacementPolicy().setHost(new Host());
    from.getPlacementPolicy().getHost().setId(Guid.Empty.toString());
    for (GuestNicConfiguration guestNic : from.getInitialization().getNicConfigurations().getNicConfigurations()) {
        guestNic.setBootProtocol(MappingTestHelper.shuffle(BootProtocol.class).value());
    }
    from.getDisplay().setType("spice");
    from.getSerialNumber().setPolicy(SerialNumberPolicy.CUSTOM.value());
    from.getDisplay().setFileTransferEnabled(true);
    from.getDisplay().setCopyPasteEnabled(true);
    from.getMigration().setAutoConverge(InheritableBoolean.TRUE.value());
    from.getMigration().setCompressed(InheritableBoolean.TRUE.value());
    from.getDisplay().setDisconnectAction(DisplayDisconnectAction.LOCK_SCREEN.toString());
    return from;
}
#end_block

#method_before
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertEquals(model.getBios().getBootMenu().isEnabled(), transform.getBios().getBootMenu().isEnabled());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isSingleQxlPci(), transform.getDisplay().isSingleQxlPci());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.getDisplay().getKeyboardLayout(), transform.getDisplay().getKeyboardLayout());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.getMigrationDowntime(), transform.getMigrationDowntime());
    assertEquals(model.getSerialNumber().getPolicy(), transform.getSerialNumber().getPolicy());
    assertEquals(model.getSerialNumber().getValue(), transform.getSerialNumber().getValue());
    assertEquals(model.getDisplay().isFileTransferEnabled(), transform.getDisplay().isFileTransferEnabled());
    assertEquals(model.getDisplay().isCopyPasteEnabled(), transform.getDisplay().isCopyPasteEnabled());
    assertEquals(model.isStartPaused(), transform.isStartPaused());
    assertEquals(model.getMigration().getAutoConverge(), transform.getMigration().getAutoConverge());
    assertEquals(model.getMigration().getCompressed(), transform.getMigration().getCompressed());
    assertEquals(model.getDisplay().getDisconnectAction(), transform.getDisplay().getDisconnectAction());
}
#method_after
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertEquals(model.getBios().getBootMenu().isEnabled(), transform.getBios().getBootMenu().isEnabled());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isSingleQxlPci(), transform.getDisplay().isSingleQxlPci());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertNotNull(model.getTimeZone());
    assertEquals(model.getTimeZone().getName(), transform.getTimezone());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.getDisplay().getKeyboardLayout(), transform.getDisplay().getKeyboardLayout());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.getMigrationDowntime(), transform.getMigrationDowntime());
    assertEquals(model.getSerialNumber().getPolicy(), transform.getSerialNumber().getPolicy());
    assertEquals(model.getSerialNumber().getValue(), transform.getSerialNumber().getValue());
    assertEquals(model.getDisplay().isFileTransferEnabled(), transform.getDisplay().isFileTransferEnabled());
    assertEquals(model.getDisplay().isCopyPasteEnabled(), transform.getDisplay().isCopyPasteEnabled());
    assertEquals(model.isStartPaused(), transform.isStartPaused());
    assertEquals(model.getMigration().getAutoConverge(), transform.getMigration().getAutoConverge());
    assertEquals(model.getMigration().getCompressed(), transform.getMigration().getCompressed());
    assertEquals(model.getDisplay().getDisconnectAction(), transform.getDisplay().getDisconnectAction());
}
#end_block

#method_before
@Test
public void testGuestTimezone() {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    VmDynamic vmDynamic = new VmDynamic();
    vmDynamic.setStatus(VMStatus.Up);
    vmDynamic.setGuestOsTimezoneName("This is not a timezone");
    vmDynamic.setGuestOsTimezoneOffset(-6000);
    vm.setDynamicData(vmDynamic);
    VM map = VmMapper.map(vm, (VM) null);
    assertNotNull(map.getGuestTimeZone());
    assertEquals(map.getGuestTimeZone().getUtcOffset().intValue(), -6000);
    assertEquals(map.getGuestTimeZone().getName(), "This is not a timezone");
}
#method_after
@Test
public void testGuestTimezone() {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    VmDynamic vmDynamic = new VmDynamic();
    vmDynamic.setStatus(VMStatus.Up);
    vmDynamic.setGuestOsTimezoneName("This is not a timezone");
    vmDynamic.setGuestOsTimezoneOffset(-60);
    vm.setDynamicData(vmDynamic);
    VM map = VmMapper.map(vm, (VM) null);
    assertNotNull(map.getGuestTimeZone());
    assertEquals(map.getGuestTimeZone().getUtcOffset(), "-01:00");
    assertEquals(map.getGuestTimeZone().getName(), "This is not a timezone");
}
#end_block

#method_before
@Test
public void testGuestOs() {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    VmDynamic vmDynamic = new VmDynamic();
    vmDynamic.setStatus(VMStatus.Up);
    vmDynamic.setGuestOsType(OsType.Linux);
    vmDynamic.setGuestOsCodename("Santiago");
    vmDynamic.setGuestOsDistribution("Red Hat Enterprise Linux Server");
    vmDynamic.setGuestOsVersion("6.5");
    vmDynamic.setGuestOsArch(ArchitectureType.x86_64);
    vmDynamic.setGuestOsKernelVersion("2.6.32-431.el6.x86_64");
    vm.setDynamicData(vmDynamic);
    VM map = VmMapper.map(vm, (VM) null);
    assertNotNull(map.getGuestOs());
    assertEquals(map.getGuestOs().getType(), "Linux");
    assertEquals(map.getGuestOs().getCodename(), "Santiago");
    assertEquals(map.getGuestOs().getDistribution(), "Red Hat Enterprise Linux Server");
    assertEquals(map.getGuestOs().getVersion(), "6.5");
    assertEquals(map.getGuestOs().getArch(), "x86_64");
    assertEquals(map.getGuestOs().getKernelVersion(), "2.6.32-431.el6.x86_64");
}
#method_after
@Test
public void testGuestOs() {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    VmDynamic vmDynamic = new VmDynamic();
    vmDynamic.setStatus(VMStatus.Up);
    vmDynamic.setGuestOsType(OsType.Linux);
    vmDynamic.setGuestOsCodename("Santiago");
    vmDynamic.setGuestOsDistribution("Red Hat Enterprise Linux Server");
    vmDynamic.setGuestOsVersion("6.5");
    vmDynamic.setGuestOsArch(ArchitectureType.x86_64);
    vmDynamic.setGuestOsKernelVersion("2.6.32-431.el6.x86_64");
    vm.setDynamicData(vmDynamic);
    VM map = VmMapper.map(vm, (VM) null);
    assertNotNull(map.getGuestOperatingSystem());
    assertEquals(map.getGuestOperatingSystem().getFamily(), "Linux");
    assertEquals(map.getGuestOperatingSystem().getCodename(), "Santiago");
    assertEquals(map.getGuestOperatingSystem().getDistribution(), "Red Hat Enterprise Linux Server");
    assertEquals(map.getGuestOperatingSystem().getVersion().getFullVersion(), "6.5");
    assertNotNull(map.getGuestOperatingSystem().getVersion().getMajor());
    assertEquals((long) map.getGuestOperatingSystem().getVersion().getMajor(), 6);
    assertNotNull(map.getGuestOperatingSystem().getVersion().getMinor());
    assertEquals((long) map.getGuestOperatingSystem().getVersion().getMinor(), 5);
    assertNull(map.getGuestOperatingSystem().getVersion().getBuild());
    assertNull(map.getGuestOperatingSystem().getVersion().getRevision());
    assertEquals(map.getGuestOperatingSystem().getArchitecture(), "x86_64");
    assertEquals(map.getGuestOperatingSystem().getKernel().getVersion().getFullVersion(), "2.6.32-431.el6.x86_64");
    assertEquals((long) map.getGuestOperatingSystem().getKernel().getVersion().getMajor(), 2);
    assertEquals((long) map.getGuestOperatingSystem().getKernel().getVersion().getMinor(), 6);
    assertEquals((long) map.getGuestOperatingSystem().getKernel().getVersion().getBuild(), 32);
    assertEquals((long) map.getGuestOperatingSystem().getKernel().getVersion().getRevision(), 431);
}
#end_block

#method_before
@Test
public void testGuestOs2() {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    VmDynamic vmDynamic = new VmDynamic();
    vmDynamic.setStatus(VMStatus.Up);
    vmDynamic.setGuestOsType(OsType.Windows);
    vmDynamic.setGuestOsCodename("");
    vmDynamic.setGuestOsDistribution("");
    vmDynamic.setGuestOsVersion("6.2");
    vmDynamic.setGuestOsArch(ArchitectureType.x86_64);
    vmDynamic.setGuestOsKernelVersion("");
    vm.setDynamicData(vmDynamic);
    VM map = VmMapper.map(vm, (VM) null);
    assertNotNull(map.getGuestOs());
    assertEquals(map.getGuestOs().getType(), "Windows");
    assertEquals(map.getGuestOs().getCodename(), "");
    assertEquals(map.getGuestOs().getDistribution(), "");
    assertEquals(map.getGuestOs().getVersion(), "6.2");
    assertEquals(map.getGuestOs().getArch(), "x86_64");
    assertEquals(map.getGuestOs().getKernelVersion(), "");
}
#method_after
@Test
public void testGuestOs2() {
    org.ovirt.engine.core.common.businessentities.VM vm = new org.ovirt.engine.core.common.businessentities.VM();
    VmDynamic vmDynamic = new VmDynamic();
    vmDynamic.setStatus(VMStatus.Up);
    vmDynamic.setGuestOsType(OsType.Windows);
    vmDynamic.setGuestOsCodename("");
    vmDynamic.setGuestOsDistribution("");
    vmDynamic.setGuestOsVersion("6.2.4800");
    vmDynamic.setGuestOsArch(ArchitectureType.x86_64);
    vmDynamic.setGuestOsKernelVersion("");
    vm.setDynamicData(vmDynamic);
    VM map = VmMapper.map(vm, (VM) null);
    assertNotNull(map.getGuestOperatingSystem());
    assertEquals(map.getGuestOperatingSystem().getFamily(), "Windows");
    assertEquals(map.getGuestOperatingSystem().getCodename(), "");
    assertEquals(map.getGuestOperatingSystem().getDistribution(), "");
    assertEquals(map.getGuestOperatingSystem().getVersion().getFullVersion(), "6.2.4800");
    assertNotNull(map.getGuestOperatingSystem().getVersion().getMajor());
    assertEquals((long) map.getGuestOperatingSystem().getVersion().getMajor(), 6);
    assertNotNull(map.getGuestOperatingSystem().getVersion().getMinor());
    assertEquals((long) map.getGuestOperatingSystem().getVersion().getMinor(), 2);
    assertNotNull(map.getGuestOperatingSystem().getVersion().getBuild());
    assertEquals((long) map.getGuestOperatingSystem().getVersion().getBuild(), 4800);
    assertNull(map.getGuestOperatingSystem().getVersion().getRevision());
    assertEquals(map.getGuestOperatingSystem().getArchitecture(), "x86_64");
    assertNull(map.getGuestOperatingSystem().getKernel());
}
#end_block

#method_before
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template, boolean showDynamicInfo) {
    VM model = template != null ? template : new VM();
    mapVmBaseEntityToModel(model, entity.getStaticData());
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.isUseHostCpuFlags()) {
        model.getCpu().setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    model.getCpu().setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    model.setDisplay(new Display());
    // and dynamic value (current/last run value, that can be different in case of run-once or edit while running)
    if (showDynamicInfo && entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
    }
    // fill dynamic data
    if (entity.getDynamicData() != null && !entity.getStatus().isNotRunning()) {
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        final boolean hasGuestOsVersion = entity.getGuestOsVersion() != null && !entity.getGuestOsVersion().isEmpty();
        final boolean hasTimezoneName = entity.getGuestOsTimezoneName() != null && !entity.getGuestOsTimezoneName().isEmpty();
        if (hasGuestOsVersion) {
            GuestOs os = (new GuestOs());
            os.setArch(entity.getGuestOsArch().name());
            os.setCodename(entity.getGuestOsCodename());
            os.setDistribution(entity.getGuestOsDistribution());
            os.setKernelVersion(entity.getGuestOsKernelVersion());
            os.setVersion(entity.getGuestOsVersion());
            os.setType(entity.getGuestOsType().name());
            model.setGuestOs(os);
        }
        if (hasTimezoneName) {
            model.setGuestTimeZone(new TimeZone());
            model.getGuestTimeZone().setName(entity.getGuestOsTimezoneName());
            model.getGuestTimeZone().setUtcOffset(entity.getGuestOsTimezoneOffset());
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setRunOnce(entity.isRunOnce());
        org.ovirt.engine.core.common.businessentities.GraphicsType graphicsType = deriveGraphicsType(entity.getGraphicsInfos());
        if (graphicsType != null) {
            model.getDisplay().setType(DisplayMapper.map(graphicsType, null).value());
            GraphicsInfo graphicsInfo = entity.getGraphicsInfos().get(graphicsType);
            model.getDisplay().setAddress(graphicsInfo == null ? null : graphicsInfo.getIp());
            Integer displayPort = graphicsInfo == null ? null : graphicsInfo.getPort();
            model.getDisplay().setPort(displayPort == null || displayPort.equals(-1) ? null : displayPort);
            Integer displaySecurePort = graphicsInfo == null ? null : graphicsInfo.getTlsPort();
            model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort.equals(-1) ? null : displaySecurePort);
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    model.getDisplay().setMonitors(entity.getNumOfMonitors());
    model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
    model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    model.getDisplay().setProxy(getEffectiveSpiceProxy(entity));
    model.getDisplay().setDisconnectAction(map(entity.getConsoleDisconnectAction(), null).toString());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    if (entity.getProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getProviderId().toString());
    }
    return model;
}
#method_after
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template, boolean showDynamicInfo) {
    VM model = template != null ? template : new VM();
    mapVmBaseEntityToModel(model, entity.getStaticData());
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.isUseHostCpuFlags()) {
        model.getCpu().setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    model.getCpu().setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    model.setDisplay(new Display());
    // and dynamic value (current/last run value, that can be different in case of run-once or edit while running)
    if (showDynamicInfo && entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
    }
    // fill dynamic data
    if (entity.getDynamicData() != null && !entity.getStatus().isNotRunning()) {
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        final boolean hasGuestOsVersion = entity.getGuestOsVersion() != null && !entity.getGuestOsVersion().isEmpty();
        if (hasGuestOsVersion) {
            GuestOperatingSystem os = model.getGuestOperatingSystem();
            if (os == null) {
                os = new GuestOperatingSystem();
                model.setGuestOperatingSystem(os);
            }
            os.setArchitecture(entity.getGuestOsArch().name());
            os.setCodename(entity.getGuestOsCodename());
            os.setDistribution(entity.getGuestOsDistribution());
            String kernelVersionString = entity.getGuestOsKernelVersion();
            if (StringUtils.isNotEmpty(kernelVersionString)) {
                org.ovirt.engine.api.model.Version kernelVersion = VersionMapper.fromKernelVersionString(kernelVersionString);
                if (kernelVersion != null) {
                    if (os.getKernel() == null) {
                        os.setKernel(new Kernel());
                    }
                    os.getKernel().setVersion(kernelVersion);
                    os.getKernel().getVersion().setFullVersion(entity.getGuestOsKernelVersion());
                }
            }
            String osVersionString = entity.getGuestOsVersion();
            if (StringUtils.isNotEmpty(osVersionString)) {
                os.setVersion(VersionMapper.fromVersionString(osVersionString));
                if (os.getVersion() != null) {
                    os.getVersion().setFullVersion(entity.getGuestOsVersion());
                }
            }
            os.setFamily(entity.getGuestOsType().name());
        }
        final boolean hasTimezoneName = entity.getGuestOsTimezoneName() != null && !entity.getGuestOsTimezoneName().isEmpty();
        if (hasTimezoneName) {
            TimeZone guestTz = model.getGuestTimeZone();
            if (guestTz == null) {
                guestTz = new TimeZone();
                model.setGuestTimeZone(guestTz);
            }
            guestTz.setName(entity.getGuestOsTimezoneName());
            guestTz.setUtcOffset(TimeZoneMapper.mapUtcOffsetToDisplayString(entity.getGuestOsTimezoneOffset()));
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setRunOnce(entity.isRunOnce());
        org.ovirt.engine.core.common.businessentities.GraphicsType graphicsType = deriveGraphicsType(entity.getGraphicsInfos());
        if (graphicsType != null) {
            model.getDisplay().setType(DisplayMapper.map(graphicsType, null).value());
            GraphicsInfo graphicsInfo = entity.getGraphicsInfos().get(graphicsType);
            model.getDisplay().setAddress(graphicsInfo == null ? null : graphicsInfo.getIp());
            Integer displayPort = graphicsInfo == null ? null : graphicsInfo.getPort();
            model.getDisplay().setPort(displayPort == null || displayPort.equals(-1) ? null : displayPort);
            Integer displaySecurePort = graphicsInfo == null ? null : graphicsInfo.getTlsPort();
            model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort.equals(-1) ? null : displaySecurePort);
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    model.getDisplay().setMonitors(entity.getNumOfMonitors());
    model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
    model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    model.getDisplay().setProxy(getEffectiveSpiceProxy(entity));
    model.getDisplay().setDisconnectAction(map(entity.getConsoleDisconnectAction(), null).toString());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    if (entity.getProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getProviderId().toString());
    }
    return model;
}
#end_block

#method_before
protected static void mapVmBaseModelToEntity(org.ovirt.engine.core.common.businessentities.VmBase entity, VmBase model) {
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetIo() && model.getIo().isSetThreads()) {
        entity.setNumOfIoThreads(model.getIo().getThreads());
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetBios()) {
        if (model.getBios().isSetBootMenu()) {
            entity.setBootMenuEnabled(model.getBios().getBootMenu().isEnabled());
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            // let backend decide which video device to use
            entity.setDefaultDisplayType(null);
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
        if (model.getDisplay().isSetFileTransferEnabled()) {
            entity.setSpiceFileTransferEnabled(model.getDisplay().isFileTransferEnabled());
        }
        if (model.getDisplay().isSetCopyPasteEnabled()) {
            entity.setSpiceCopyPasteEnabled(model.getDisplay().isCopyPasteEnabled());
        }
        if (model.getDisplay().isSetDisconnectAction()) {
            DisplayDisconnectAction action = DisplayDisconnectAction.fromValue(model.getDisplay().getDisconnectAction());
            entity.setConsoleDisconnectAction(map(action, null));
        }
    }
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        entity.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetStartPaused()) {
        entity.setRunAndPause(model.isStartPaused());
    }
    if (model.isSetCpuProfile() && model.getCpuProfile().isSetId()) {
        entity.setCpuProfileId(GuidUtils.asGuid(model.getCpuProfile().getId()));
    }
    if (model.isSetMigration()) {
        MigrationOptionsMapper.copyMigrationOptions(model.getMigration(), entity);
    }
    if (model.isSetCustomProperties()) {
        entity.setCustomProperties(CustomPropertiesParser.parse(model.getCustomProperties().getCustomProperty()));
    }
    if (model.isSetCustomEmulatedMachine()) {
        entity.setCustomEmulatedMachine(model.getCustomEmulatedMachine());
    }
    if (model.isSetCustomCpuModel()) {
        entity.setCustomCpuName(model.getCustomCpuModel());
    }
}
#method_after
protected static void mapVmBaseModelToEntity(org.ovirt.engine.core.common.businessentities.VmBase entity, VmBase model) {
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetIo() && model.getIo().isSetThreads()) {
        entity.setNumOfIoThreads(model.getIo().getThreads());
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetBios()) {
        if (model.getBios().isSetBootMenu()) {
            entity.setBootMenuEnabled(model.getBios().getBootMenu().isEnabled());
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            // let backend decide which video device to use
            entity.setDefaultDisplayType(null);
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
        if (model.getDisplay().isSetFileTransferEnabled()) {
            entity.setSpiceFileTransferEnabled(model.getDisplay().isFileTransferEnabled());
        }
        if (model.getDisplay().isSetCopyPasteEnabled()) {
            entity.setSpiceCopyPasteEnabled(model.getDisplay().isCopyPasteEnabled());
        }
        if (model.getDisplay().isSetDisconnectAction()) {
            DisplayDisconnectAction action = DisplayDisconnectAction.fromValue(model.getDisplay().getDisconnectAction());
            entity.setConsoleDisconnectAction(map(action, null));
        }
    }
    if (model.isSetTimeZone()) {
        if (model.getTimeZone().isSetName()) {
            String timezone = model.getTimeZone().getName();
            if (timezone.isEmpty()) {
                // normalize default timezone representation
                timezone = null;
            }
            entity.setTimeZone(timezone);
        }
    } else // now only accepted for backwards compatibility
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        entity.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetStartPaused()) {
        entity.setRunAndPause(model.isStartPaused());
    }
    if (model.isSetCpuProfile() && model.getCpuProfile().isSetId()) {
        entity.setCpuProfileId(GuidUtils.asGuid(model.getCpuProfile().getId()));
    }
    if (model.isSetMigration()) {
        MigrationOptionsMapper.copyMigrationOptions(model.getMigration(), entity);
    }
    if (model.isSetCustomProperties()) {
        entity.setCustomProperties(CustomPropertiesParser.parse(model.getCustomProperties().getCustomProperty()));
    }
    if (model.isSetCustomEmulatedMachine()) {
        entity.setCustomEmulatedMachine(model.getCustomEmulatedMachine());
    }
    if (model.isSetCustomCpuModel()) {
        entity.setCustomCpuName(model.getCustomCpuModel());
    }
}
#end_block

#method_before
protected static void mapVmBaseEntityToModel(VmBase model, org.ovirt.engine.core.common.businessentities.VmBase entity) {
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    IO io = model.getIo();
    if (io == null) {
        io = new IO();
        model.setIo(io);
    }
    io.setThreads(entity.getNumOfIoThreads());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    if (entity.getVmType() != null) {
        model.setType(map(entity.getVmType(), null));
    }
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setBios(new Bios());
    model.getBios().setBootMenu(new BootMenu());
    model.getBios().getBootMenu().setEnabled(entity.isBootMenuEnabled());
    final boolean isWindows = SimpleDependecyInjector.getInstance().get(OsRepository.class).isWindows(entity.getOsId());
    model.setTimeZone(new TimeZone());
    if (isWindows) {
        model.getTimeZone().setUtcOffset(TimeZoneType.WINDOWS_TIMEZONE.getStandardOffset(entity.getTimeZone()));
    } else {
        model.getTimeZone().setUtcOffset(TimeZoneType.GENERAL_TIMEZONE.getStandardOffset(entity.getTimeZone()));
    }
    model.getTimeZone().setName(entity.getTimeZone());
    model.setTimezone(entity.getTimeZone());
    if (entity.getCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getVmInit() != null && entity.getVmInit().getDomain() != null && StringUtils.isNotBlank(entity.getVmInit().getDomain())) {
        Domain domain = new Domain();
        domain.setName(entity.getVmInit().getDomain());
        model.setDomain(domain);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    model.setStartPaused(entity.isRunAndPause());
    if (entity.getCpuProfileId() != null) {
        CpuProfile cpuProfile = new CpuProfile();
        cpuProfile.setId(entity.getCpuProfileId().toString());
        model.setCpuProfile(cpuProfile);
    }
    model.setMigration(MigrationOptionsMapper.map(entity, null));
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getCustomEmulatedMachine() != null) {
        model.setCustomEmulatedMachine(entity.getCustomEmulatedMachine());
    }
    if (entity.getCustomCpuName() != null) {
        model.setCustomCpuModel(entity.getCustomCpuName());
    }
}
#method_after
protected static void mapVmBaseEntityToModel(VmBase model, org.ovirt.engine.core.common.businessentities.VmBase entity) {
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    IO io = model.getIo();
    if (io == null) {
        io = new IO();
        model.setIo(io);
    }
    io.setThreads(entity.getNumOfIoThreads());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    if (entity.getVmType() != null) {
        model.setType(map(entity.getVmType(), null));
    }
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setBios(new Bios());
    model.getBios().setBootMenu(new BootMenu());
    model.getBios().getBootMenu().setEnabled(entity.isBootMenuEnabled());
    if (entity.getTimeZone() != null) {
        model.setTimeZone(new TimeZone());
        model.getTimeZone().setName(entity.getTimeZone());
    }
    // Deprecated: Should be removed in 4.x, use the TimeZone complex type instead
    model.setTimezone(entity.getTimeZone());
    if (entity.getCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getVmInit() != null && entity.getVmInit().getDomain() != null && StringUtils.isNotBlank(entity.getVmInit().getDomain())) {
        Domain domain = new Domain();
        domain.setName(entity.getVmInit().getDomain());
        model.setDomain(domain);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    model.setStartPaused(entity.isRunAndPause());
    if (entity.getCpuProfileId() != null) {
        CpuProfile cpuProfile = new CpuProfile();
        cpuProfile.setId(entity.getCpuProfileId().toString());
        model.setCpuProfile(cpuProfile);
    }
    model.setMigration(MigrationOptionsMapper.map(entity, null));
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getCustomEmulatedMachine() != null) {
        model.setCustomEmulatedMachine(entity.getCustomEmulatedMachine());
    }
    if (entity.getCustomCpuName() != null) {
        model.setCustomCpuModel(entity.getCustomCpuName());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    namesAdded = new ArrayList<>();
    Set<HostDevice> affectedHostDevices = getAffectedHostDevices();
    Map<String, VmHostDevice> existingDevices = getExistingVmHostDevicesByName();
    List<VmDevice> devicesToAdd = new ArrayList<>();
    List<VmDevice> devicesToUpdate = new ArrayList<>();
    for (HostDevice hostDevice : affectedHostDevices) {
        if (!existingDevices.containsKey(hostDevice.getDeviceName())) {
            VmHostDevice device = new VmHostDevice(getVmId(), hostDevice);
            // if the device was not explicitly intended by the user (only added due to the IOMMU group
            // we mark it as as placeholder
            boolean required = getPrimaryDeviceNames().contains(device.getDevice());
            device.setIommuPlaceholder(!required);
            devicesToAdd.add(device);
            namesAdded.add(hostDevice.getDeviceName());
        } else {
            VmHostDevice device = new VmHostDevice(existingDevices.get(hostDevice.getDeviceName()));
            // as it is now explicitly requested by the user
            if (getPrimaryDeviceNames().contains(device.getDevice()) && device.isIommuPlaceholder()) {
                device.setIommuPlaceholder(false);
                devicesToUpdate.add(device);
                namesAdded.add(hostDevice.getDeviceName());
            }
        }
    }
    getVmDeviceDao().saveAllInBatch(devicesToAdd);
    getVmDeviceDao().updateAllInBatch(devicesToUpdate);
    setSucceeded(true);
    setActionReturnValue(namesAdded);
}
#method_after
@Override
protected void executeCommand() {
    Set<HostDevice> affectedHostDevices = getAffectedHostDevices();
    Map<String, VmHostDevice> existingDevices = getExistingVmHostDevicesByName();
    List<VmDevice> devicesToAdd = new ArrayList<>();
    List<VmDevice> devicesToUpdate = new ArrayList<>();
    for (HostDevice hostDevice : affectedHostDevices) {
        if (!existingDevices.containsKey(hostDevice.getDeviceName())) {
            VmHostDevice device = new VmHostDevice(getVmId(), hostDevice);
            // if the device was not explicitly intended by the user (only added due to the IOMMU group
            // we mark it as as placeholder
            boolean required = getPrimaryDeviceNames().contains(device.getDevice());
            device.setIommuPlaceholder(!required);
            devicesToAdd.add(device);
        } else {
            VmHostDevice device = new VmHostDevice(existingDevices.get(hostDevice.getDeviceName()));
            // as it is now explicitly requested by the user
            if (getPrimaryDeviceNames().contains(device.getDevice()) && device.isIommuPlaceholder()) {
                device.setIommuPlaceholder(false);
                devicesToUpdate.add(device);
            }
        }
    }
    getVmDeviceDao().saveAllInBatch(devicesToAdd);
    getVmDeviceDao().updateAllInBatch(devicesToUpdate);
    setSucceeded(true);
}
#end_block

#method_before
public List<String> getNamesAdded() {
    return namesAdded;
}
#method_after
public List<String> getNamesAdded() {
    return new ArrayList<>(getPrimaryDeviceNames());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    namesRemoved = new ArrayList<>();
    Set<HostDevice> affectedHostDevices = getAffectedHostDevices();
    Map<String, VmHostDevice> existingDevices = getExistingVmHostDevicesByName();
    Map<Integer, List<VmHostDevice>> devicesByIommuGroup = new HashMap<>();
    for (HostDevice hostDevice : affectedHostDevices) {
        boolean shouldRemoveDevice = getPrimaryDeviceNames().contains(hostDevice.getDeviceName());
        boolean deviceExists = existingDevices.containsKey(hostDevice.getDeviceName());
        if (shouldRemoveDevice && deviceExists) {
            // first just set the flag that this device is not required
            VmHostDevice device = existingDevices.get(hostDevice.getDeviceName());
            device.setIommuPlaceholder(true);
            addToMap(getIommuGroupKey(hostDevice.getIommuGroup()), device, devicesByIommuGroup);
            namesRemoved.add(hostDevice.getDeviceName());
        }
    }
    List<VmDevice> devicesToRemove = new ArrayList<>();
    List<VmDevice> devicesToUpdate = new ArrayList<>();
    // no longer needed (placeholder) devices
    for (Map.Entry<Integer, List<VmHostDevice>> group : devicesByIommuGroup.entrySet()) {
        List<VmHostDevice> devices = group.getValue();
        // devices without IOMMU group can be safely removed
        boolean noIommuDeviceGroup = group.getKey() == getIommuGroupKey(null);
        if (noIommuDeviceGroup || allPlaceholder(devices)) {
            // all devices in this group became unnecessary, so remove them
            devicesToRemove.addAll(devices);
        } else {
            // some devices in this group are still required so just update the placeholder flag
            devicesToUpdate.addAll(devices);
        }
    }
    getVmDeviceDao().removeAllInBatch(devicesToRemove);
    getVmDeviceDao().updateAllInBatch(devicesToUpdate);
    setSucceeded(true);
    setActionReturnValue(namesRemoved);
}
#method_after
@Override
protected void executeCommand() {
    Set<HostDevice> affectedHostDevices = getAffectedHostDevices();
    Map<String, VmHostDevice> existingDevices = getExistingVmHostDevicesByName();
    Map<Integer, List<VmHostDevice>> existingDevicesByIommuGroup = new HashMap<>();
    for (HostDevice hostDevice : affectedHostDevices) {
        boolean shouldRemoveDevice = getPrimaryDeviceNames().contains(hostDevice.getDeviceName());
        boolean deviceExists = existingDevices.containsKey(hostDevice.getDeviceName());
        if (deviceExists) {
            VmHostDevice device = existingDevices.get(hostDevice.getDeviceName());
            addToMap(getIommuGroupKey(hostDevice.getIommuGroup()), device, existingDevicesByIommuGroup);
            if (shouldRemoveDevice) {
                // first just set the flag that this device is not required
                device.setIommuPlaceholder(true);
            }
        }
    }
    List<VmDevice> devicesToRemove = new ArrayList<>();
    List<VmDevice> devicesToUpdate = new ArrayList<>();
    // no longer needed (placeholder) devices
    for (Map.Entry<Integer, List<VmHostDevice>> group : existingDevicesByIommuGroup.entrySet()) {
        List<VmHostDevice> devices = group.getValue();
        // devices without IOMMU group can be safely removed
        boolean noIommuDeviceGroup = group.getKey() == getIommuGroupKey(null);
        if (noIommuDeviceGroup || allPlaceholder(devices)) {
            // all devices in this group became unnecessary, so remove them
            devicesToRemove.addAll(devices);
        } else {
            // some devices in this group are still required so just update the placeholder flag
            devicesToUpdate.addAll(devices);
        }
    }
    getVmDeviceDao().removeAllInBatch(devicesToRemove);
    getVmDeviceDao().updateAllInBatch(devicesToUpdate);
    setSucceeded(true);
}
#end_block

#method_before
public List<String> getNamesRemoved() {
    return namesRemoved;
}
#method_after
public List<String> getNamesRemoved() {
    return new ArrayList<>(getPrimaryDeviceNames());
}
#end_block

#method_before
protected boolean hasIommu(HostDevice hostDevice) {
    // iommu group restriction only applicable to 'pci' devices
    return CAPABILITY_PCI.equals(hostDevice.getCapability()) || hostDevice.getIommuGroup() == null;
}
#method_after
protected boolean hasIommu(HostDevice hostDevice) {
    // iommu group restriction only applicable to 'pci' devices
    return CAPABILITY_PCI.equals(hostDevice.getCapability()) && hostDevice.getIommuGroup() != null;
}
#end_block

#method_before
private void updatePoolVms() {
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetAllPoolVms, new IdQueryParameters(getVmPool().getVmPoolId()));
    List<VM> vmsInPool = qRetVal.getSucceeded() ? qRetVal.<List<VM>>getReturnValue() : null;
    if (vmsInPool != null) {
        VmTemplateHandler.lockVmTemplateInTransaction(getParameters().getVmStaticData().getVmtGuid(), getCompensationContext());
        for (VM vm : vmsInPool) {
            VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
            boolean isLatest = getParameters().getVmStaticData().isUseLatestVersion();
            updateParams.getVmStaticData().setUseLatestVersion(isLatest);
            if (!isLatest) {
                updateParams.getVmStaticData().setVmtGuid(getParameters().getVmStaticData().getVmtGuid());
            }
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.UpdateVm, updateParams, getLock());
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
            setSucceeded(getSucceeded() && result.getSucceeded());
        }
        VmTemplateHandler.unlockVmTemplate(getParameters().getVmStaticData().getVmtGuid());
    }
}
#method_after
private void updatePoolVms() {
    if (!oldPool.getVmtGuid().equals(getParameters().getVmStaticData().getVmtGuid()) || getParameters().getVmStaticData().isUseLatestVersion() != oldPool.isUseLatestVersion()) {
        VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetAllPoolVms, new IdQueryParameters(getVmPool().getVmPoolId()));
        List<VM> vmsInPool = qRetVal.getSucceeded() ? qRetVal.<List<VM>>getReturnValue() : null;
        if (vmsInPool != null) {
            VmTemplateHandler.lockVmTemplateInTransaction(getParameters().getVmStaticData().getVmtGuid(), getCompensationContext());
            for (VM vm : vmsInPool) {
                VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
                boolean isLatest = getParameters().getVmStaticData().isUseLatestVersion();
                updateParams.getVmStaticData().setUseLatestVersion(isLatest);
                if (!isLatest) {
                    updateParams.getVmStaticData().setVmtGuid(getParameters().getVmStaticData().getVmtGuid());
                }
                VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.UpdateVm, updateParams, getLock());
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                setSucceeded(getSucceeded() && result.getSucceeded());
            }
            VmTemplateHandler.unlockVmTemplate(getParameters().getVmStaticData().getVmtGuid());
        }
    }
}
#end_block

#method_before
private Guid getIdOfDiskOperator() {
    List<Disk> diskIds = getDbFacade().getDiskDao().getAllForVm(getVmId());
    if (diskIds.isEmpty()) {
        return null;
    }
    List<Permission> perms = getPermissionDAO().getAllForRoleAndObject(PredefinedRoles.DISK_OPERATOR.getId(), diskIds.iterator().next().getId());
    if (perms.isEmpty()) {
        return null;
    }
    return perms.iterator().next().getAdElementId();
}
#method_after
private Guid getIdOfDiskOperator() {
    List<Disk> diskIds = getDbFacade().getDiskDao().getAllForVm(getVmId());
    if (diskIds.isEmpty()) {
        return null;
    }
    List<Permissions> perms = getPermissionDAO().getAllForRoleAndObject(PredefinedRoles.DISK_OPERATOR.getId(), diskIds.iterator().next().getId());
    if (perms.isEmpty()) {
        return null;
    }
    return perms.iterator().next().getad_element_id();
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void auditLogHotSetCpusCandos(HotSetNumerOfCpusParameters params) {
    if (!setNumberOfCpusResult.getCanDoAction()) {
        AuditLogableBase logable = new HotSetNumberOfCpusCommand<>(params);
        List<String> canDos = getBackend().getErrorsTranslator().TranslateErrorText(setNumberOfCpusResult.getCanDoActionMessages());
        logable.addCustomValue(HotSetNumberOfCpusCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(canDos, ","));
        auditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#method_after
private void auditLogHotSetCpusCandos(HotSetNumerOfCpusParameters params) {
    if (!setNumberOfCpusResult.getCanDoAction()) {
        AuditLogableBase logable = new HotSetNumberOfCpusCommand<>(params);
        List<String> canDos = getBackend().getErrorsTranslator().TranslateErrorText(setNumberOfCpusResult.getCanDoActionMessages());
        logable.addCustomValue(HotSetNumberOfCpusCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(canDos, ","));
        AuditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#end_block

#method_before
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    if (getParameters().getVm().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getParameters().getVm().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    if (getParameters().getVm().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getParameters().getVm().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
private void addLogMessages(VdcReturnValueBase returnValueBase) {
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_UPDATE_VM_NUMA_NODE_FAILED);
    }
}
#method_after
private void addLogMessages(VdcReturnValueBase returnValueBase) {
    if (!returnValueBase.getSucceeded()) {
        AuditLogDirector.log(this, AuditLogType.NUMA_UPDATE_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDAO().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDAO().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDAO().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        // check if pool vm - if not, the field is not legal and command will fail later on
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        }
    }
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDAO().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // stateless VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDAO().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDAO().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        // check if stateless - if vm is not stateless the field is not legal and command will fail later on
        } else if (vmFromParams.isStateless() || vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        }
    }
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<VM> vmsList = getDbFacade().getVmDao().getAllForVmPool(getParameters().getId());
    for (VM vm : vmsList) {
        VmHandler.updateVmGuestAgentVersion(vm);
    }
    getQueryReturnValue().setReturnValue(vmsList);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<VM> vmsList = getDbFacade().getVmDao().getPoolVms(getParameters().getId());
    for (VM vm : vmsList) {
        VmHandler.updateVmGuestAgentVersion(vm);
    }
    getQueryReturnValue().setReturnValue(vmsList);
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveVm, new RemoveVmParameters(asGuid(id), false));
}
#method_after
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveVm, new RemoveVmParameters(guid, false));
}
#end_block

#method_before
@Override
@Consumes({ "application/xml", "application/json", "application/x-yaml" })
public Response remove(Action action) {
    get();
    boolean forceRemove = action != null && action.isSetForce() ? action.isForce() : false;
    RemoveVmParameters params = new RemoveVmParameters(asGuid(id), forceRemove);
    // If detach only is set we do not remove the VM disks
    if (action != null && action.isSetVm() && action.getVm().isSetDisks() && action.getVm().getDisks().isSetDetachOnly()) {
        params.setRemoveDisks(false);
    }
    return performAction(VdcActionType.RemoveVm, params);
}
#method_after
@Override
public Response remove(Action action) {
    get();
    boolean forceRemove = action != null && action.isSetForce() ? action.isForce() : false;
    RemoveVmParameters params = new RemoveVmParameters(guid, forceRemove);
    // If detach only is set we do not remove the VM disks
    if (action != null && action.isSetVm() && action.getVm().isSetDisks() && action.getVm().getDisks().isSetDetachOnly()) {
        params.setRemoveDisks(false);
    }
    return performAction(VdcActionType.RemoveVm, params);
}
#end_block

#method_before
private VmTemplate lookupInstanceTypeByName(Template template) {
    return getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(template.getName()), "GetVmTemplate");
}
#method_after
private VmTemplate lookupInstanceTypeByName(Template template) {
    return getEntity(VmTemplate.class, VdcQueryType.GetInstanceType, new GetVmTemplateParameters(template.getName()), "GetVmTemplate");
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Guid templateId = getTemplateId(vm.getTemplate());
            VmTemplate templateEntity = lookupTemplate(templateId);
            VDSGroup cluster = getCluster(vm);
            VmStatic builtFromTemplate = VmMapper.map(templateEntity, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !ObjectUtils.equals(templateEntity.getVdsGroupId(), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            org.ovirt.engine.core.common.businessentities.InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                instanceTypeEntity = lookupInstanceType(getTemplateId(vm.getInstanceType()));
                builtFromInstanceType = VmMapper.map(instanceTypeEntity, builtFromTemplate, cluster.getCompatibilityVersion());
                builtFromInstanceType.setInstanceTypeId(getTemplateId(vm.getInstanceType()));
            }
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(cluster.getId());
            }
            if (Guid.Empty.equals(templateId) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster.getCompatibilityVersion()));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && templateId.equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, templateEntity, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(templateId)) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, templateEntity, instanceTypeEntity, cluster);
            }
        }
    }
    VM result = (VM) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
        removeRestrictedInfo(result);
    }
    return response;
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            VDSGroup cluster = getCluster(vm);
            VmTemplate template = lookupTemplate(vm.getTemplate(), cluster.getStoragePoolId());
            VmStatic builtFromTemplate = VmMapper.map(template, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !ObjectUtils.equals(template.getVdsGroupId(), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                instanceTypeEntity = lookupInstance(vm.getInstanceType());
                builtFromInstanceType = VmMapper.map(instanceTypeEntity, builtFromTemplate, cluster.getCompatibilityVersion());
                builtFromInstanceType.setInstanceTypeId(instanceTypeEntity.getId());
            }
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(cluster.getId());
            }
            if (Guid.Empty.equals(template.getId()) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster.getCompatibilityVersion()));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && template.getId().equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, template, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(template.getId())) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, template, instanceTypeEntity, cluster);
            }
        }
    }
    VM result = (VM) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
        removeRestrictedInfo(result);
    }
    return response;
}
#end_block

#method_before
public VmTemplate lookupTemplate(Guid id) {
    return getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(id), "GetVmTemplate");
}
#method_after
protected VmTemplate lookupTemplate(Template template, Guid datacenterId) {
    if (template.isSetId()) {
        return getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(asGuid(template.getId())), "GetVmTemplate");
    } else if (template.isSetName()) {
        GetVmTemplateParameters params = new GetVmTemplateParameters(template.getName());
        params.setDataCenterId(datacenterId);
        return getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, params, "GetVmTemplate");
    }
    // should never happen.
    return null;
}
#end_block

#method_before
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[0]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 1, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(0, 2);
    setUpGetRngDeviceExpectations(0, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(2);
    setUpGetVmOvfExpectations(2);
    setUpGetVirtioScsiExpectations(2);
    setUpGetSoundcardExpectations(1, 2);
    setUpGetRngDeviceExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddStatelessWithLatestTemplateVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 2, 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(2);
    vm.setVmtGuid(GUIDS[1]);
    vm.setStateless(true);
    vm.setUseLatestVersion(true);
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, vm);
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM returnValueVM = (VM) response.getEntity();
    verifyModel(returnValueVM, 2);
    assertTrue(returnValueVM.isStateless());
    assertTrue(returnValueVM.isUseLatestTemplateVersion());
}
#method_after
@Test
public void testAddStatelessWithLatestTemplateVersion() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 2, 1 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(2);
    vm.setVmtGuid(GUIDS[1]);
    vm.setStateless(true);
    vm.setUseLatestVersion(true);
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, vm);
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM returnValueVM = (VM) response.getEntity();
    verifyModel(returnValueVM, 2);
    assertTrue(returnValueVM.isStateless());
    assertTrue(returnValueVM.isUseLatestTemplateVersion());
}
#end_block

#method_before
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAdd() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setupAddExpectations();
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 1, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 1, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 1, 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 1, 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[0]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 0, 2 });
    setUpGetRngDeviceExpectations(new int[] { 0, 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetGraphicsExpectations(1);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetSoundcardExpectations(new int[] { 1, 2 });
    setUpGetRngDeviceExpectations(new int[] { 1, 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpGetSoundcardExpectations(new int[] { 0 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, canDo, success));
    try {
        collection.add(createModel(null));
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#method_after
private void doTestBadAdd(boolean canDo, boolean success, String detail) throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(1));
    setUpGetSoundcardExpectations(new int[] { 1 });
    setUpGetRngDeviceExpectations(new int[] { 1 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUriInfo(setUpActionExpectations(VdcActionType.AddVm, AddVmParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, canDo, success));
    try {
        collection.add(createModel(null));
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VDSGroup getVdsGroupEntity() {
    VDSGroup cluster = new VDSGroup();
    cluster.setArchitecture(ArchitectureType.x86_64);
    cluster.setCompatibilityVersion(Version.getLast());
    return cluster;
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VDSGroup getVdsGroupEntity() {
    VDSGroup cluster = new VDSGroup();
    cluster.setStoragePoolId(GUIDS[3]);
    cluster.setArchitecture(ArchitectureType.x86_64);
    cluster.setCompatibilityVersion(Version.getLast());
    return cluster;
}
#end_block

#method_before
@Override
public void save(VmPool pool) {
    Guid id = pool.getVmPoolId();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.newGuid();
        pool.setVmPoolId(id);
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_description", pool.getVmPoolDescription()).addValue("vm_pool_comment", pool.getComment()).addValue("vm_pool_id", pool.getVmPoolId()).addValue("vm_pool_name", pool.getName()).addValue("vm_pool_type", pool.getVmPoolType()).addValue("parameters", pool.getParameters()).addValue("prestarted_vms", pool.getPrestartedVms()).addValue("vds_group_id", pool.getVdsGroupId()).addValue("max_assigned_vms_per_user", pool.getMaxAssignedVmsPerUser()).addValue("spice_proxy", pool.getSpiceProxy()).addValue("vm_pool_vmt_guid", pool.getVmtGuid()).addValue("vm_pool_is_latest", pool.isUseLatestVersion());
    getCallsHandler().executeModification("InsertVm_pools", parameterSource);
}
#method_after
@Override
public void save(VmPool pool) {
    Guid id = pool.getVmPoolId();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.newGuid();
        pool.setVmPoolId(id);
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_description", pool.getVmPoolDescription()).addValue("vm_pool_comment", pool.getComment()).addValue("vm_pool_id", pool.getVmPoolId()).addValue("vm_pool_name", pool.getName()).addValue("vm_pool_type", pool.getVmPoolType()).addValue("parameters", pool.getParameters()).addValue("prestarted_vms", pool.getPrestartedVms()).addValue("vds_group_id", pool.getVdsGroupId()).addValue("max_assigned_vms_per_user", pool.getMaxAssignedVmsPerUser()).addValue("spice_proxy", pool.getSpiceProxy()).addValue("vm_pool_vmt_guid", pool.getVmtGuid()).addValue("is_vm_pool_latest", pool.isUseLatestVersion());
    getCallsHandler().executeModification("InsertVm_pools", parameterSource);
}
#end_block

#method_before
@Override
public void update(VmPool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_description", pool.getVmPoolDescription()).addValue("vm_pool_comment", pool.getComment()).addValue("vm_pool_id", pool.getVmPoolId()).addValue("vm_pool_name", pool.getName()).addValue("vm_pool_type", pool.getVmPoolType()).addValue("parameters", pool.getParameters()).addValue("prestarted_vms", pool.getPrestartedVms()).addValue("vds_group_id", pool.getVdsGroupId()).addValue("max_assigned_vms_per_user", pool.getMaxAssignedVmsPerUser()).addValue("spice_proxy", pool.getSpiceProxy()).addValue("vm_pool_vmt_guid", pool.getVmtGuid()).addValue("vm_pool_is_latest", pool.isUseLatestVersion());
    getCallsHandler().executeModification("UpdateVm_pools", parameterSource);
}
#method_after
@Override
public void update(VmPool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_description", pool.getVmPoolDescription()).addValue("vm_pool_comment", pool.getComment()).addValue("vm_pool_id", pool.getVmPoolId()).addValue("vm_pool_name", pool.getName()).addValue("vm_pool_type", pool.getVmPoolType()).addValue("parameters", pool.getParameters()).addValue("prestarted_vms", pool.getPrestartedVms()).addValue("vds_group_id", pool.getVdsGroupId()).addValue("max_assigned_vms_per_user", pool.getMaxAssignedVmsPerUser()).addValue("spice_proxy", pool.getSpiceProxy()).addValue("vm_pool_vmt_guid", pool.getVmtGuid()).addValue("is_vm_pool_latest", pool.isUseLatestVersion());
    getCallsHandler().executeModification("UpdateVm_pools", parameterSource);
}
#end_block

#method_before
@Override
public VmPool mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VmPool entity = new VmPool();
    entity.setVmPoolDescription(rs.getString("vm_pool_description"));
    entity.setVmPoolId(getGuidDefaultEmpty(rs, "vm_pool_id"));
    entity.setComment(rs.getString("vm_pool_comment"));
    entity.setName(rs.getString("vm_pool_name"));
    entity.setVmPoolType(VmPoolType.forValue(rs.getInt("vm_pool_type")));
    entity.setParameters(rs.getString("parameters"));
    entity.setPrestartedVms(rs.getInt("prestarted_vms"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setAssignedVmsCount(rs.getInt("assigned_vm_count"));
    entity.setRunningVmsCount(rs.getInt("vm_running_count"));
    entity.setMaxAssignedVmsPerUser(rs.getInt("max_assigned_vms_per_user"));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vm_pool_vmt_guid"));
    entity.setUseLatestVersion(rs.getBoolean("vm_pool_is_latest"));
    return entity;
}
#method_after
@Override
public VmPool mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VmPool entity = new VmPool();
    entity.setVmPoolDescription(rs.getString("vm_pool_description"));
    entity.setVmPoolId(getGuidDefaultEmpty(rs, "vm_pool_id"));
    entity.setComment(rs.getString("vm_pool_comment"));
    entity.setName(rs.getString("vm_pool_name"));
    entity.setVmPoolType(VmPoolType.forValue(rs.getInt("vm_pool_type")));
    entity.setParameters(rs.getString("parameters"));
    entity.setPrestartedVms(rs.getInt("prestarted_vms"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setAssignedVmsCount(rs.getInt("assigned_vm_count"));
    entity.setRunningVmsCount(rs.getInt("vm_running_count"));
    entity.setMaxAssignedVmsPerUser(rs.getInt("max_assigned_vms_per_user"));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vm_pool_vmt_guid"));
    entity.setUseLatestVersion(rs.getBoolean("is_vm_pool_latest"));
    return entity;
}
#end_block

#method_before
@Override
public VmPool mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VmPool entity = new VmPool();
    entity.setVmPoolDescription(rs.getString("vm_pool_description"));
    entity.setVmPoolId(getGuidDefaultEmpty(rs, "vm_pool_id"));
    entity.setComment(rs.getString("vm_pool_comment"));
    entity.setName(rs.getString("vm_pool_name"));
    entity.setVmPoolType(VmPoolType.forValue(rs.getInt("vm_pool_type")));
    entity.setParameters(rs.getString("parameters"));
    entity.setPrestartedVms(rs.getInt("prestarted_vms"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setMaxAssignedVmsPerUser(rs.getInt("max_assigned_vms_per_user"));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vm_pool_vmt_guid"));
    entity.setUseLatestVersion(rs.getBoolean("vm_pool_is_latest"));
    return entity;
}
#method_after
@Override
public VmPool mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VmPool entity = new VmPool();
    entity.setVmPoolDescription(rs.getString("vm_pool_description"));
    entity.setVmPoolId(getGuidDefaultEmpty(rs, "vm_pool_id"));
    entity.setComment(rs.getString("vm_pool_comment"));
    entity.setName(rs.getString("vm_pool_name"));
    entity.setVmPoolType(VmPoolType.forValue(rs.getInt("vm_pool_type")));
    entity.setParameters(rs.getString("parameters"));
    entity.setPrestartedVms(rs.getInt("prestarted_vms"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setMaxAssignedVmsPerUser(rs.getInt("max_assigned_vms_per_user"));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vm_pool_vmt_guid"));
    entity.setUseLatestVersion(rs.getBoolean("is_vm_pool_latest"));
    return entity;
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = VMRowMapper.instance.mapRow(rs, rowNum);
    if (entity != null) {
        entity.setVmtGuid(getGuidDefaultEmpty(rs, "vm_pool_vmt_guid"));
        entity.setUseLatestVersion(rs.getBoolean("vm_pool_is_latest"));
    }
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = VMRowMapper.instance.mapRow(rs, rowNum);
    if (entity != null) {
        entity.setVmtGuid(getGuidDefaultEmpty(rs, "vm_pool_vmt_guid"));
        entity.setUseLatestVersion(rs.getBoolean("is_vm_pool_latest"));
    }
    return entity;
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveVmTemplateFromImportExport, new VmTemplateImportExportParameters(asGuid(id), parent.storageDomainId, getDataCenterId(parent.storageDomainId)));
}
#method_after
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveVmTemplateFromImportExport, new VmTemplateImportExportParameters(guid, parent.storageDomainId, getDataCenterId(parent.storageDomainId)));
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    RemoveVmFromImportExportParameters params = new RemoveVmFromImportExportParameters(asGuid(id), parent.storageDomainId, getDataCenterId(parent.storageDomainId));
    return performAction(VdcActionType.RemoveVmFromImportExport, params);
}
#method_after
@Override
public Response remove() {
    get();
    RemoveVmFromImportExportParameters params = new RemoveVmFromImportExportParameters(guid, parent.storageDomainId, getDataCenterId(parent.storageDomainId));
    return performAction(VdcActionType.RemoveVmFromImportExport, params);
}
#end_block

#method_before
@Override
public void init(final GlusterVolumeGeoRepActionConfirmationModel model) {
    super.init(model);
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName.equalsIgnoreCase("forceLabel")) {
                // $NON-NLS-1$
                if (model.getForceLabel() != null) {
                    getView().setForceLabelMessage(model.getForceLabel());
                }
            } else if (args.propertyName.equalsIgnoreCase("forceHelp")) {
                // $NON-NLS-1$
                getView().setForceHelp(model.getForceHelp());
            } else if (args.propertyName.equalsIgnoreCase("Message")) {
                // $NON-NLS-1$
                getView().setErrorMessage(model.getMessage());
            } else if (args.propertyName.equalsIgnoreCase("messageSet")) {
                // $NON-NLS-1$
                getView().setMessage(model.getMessage());
            }
        }
    });
}
#method_after
@Override
public void init(final GlusterVolumeGeoRepActionConfirmationModel model) {
    super.init(model);
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName.equalsIgnoreCase("forceLabel")) {
                // $NON-NLS-1$
                getView().setForceLabelMessage(model.getForceLabel());
            } else if (args.propertyName.equalsIgnoreCase("forceHelp")) {
                // $NON-NLS-1$
                getView().setForceHelp(model.getForceHelp());
            } else if (args.propertyName.equalsIgnoreCase("Message")) {
                // $NON-NLS-1$
                getView().setErrorMessage(model.getMessage());
            } else if (args.propertyName.equalsIgnoreCase("ActionConfirmationMessage")) {
                // $NON-NLS-1$
                getView().setActionConfirmationMessage(model.getMessage());
            }
        }
    });
}
#end_block

#method_before
public void setForceHelp(String forceHelp) {
    this.forceHelp = forceHelp;
    force.setIsAvailable(true);
    // $NON-NLS-1$
    onPropertyChanged(new PropertyChangedEventArgs("forceHelp"));
}
#method_after
public void setForceHelp(String forceHelp) {
    this.forceHelp = forceHelp;
    // $NON-NLS-1$
    onPropertyChanged(new PropertyChangedEventArgs("forceHelp"));
}
#end_block

#method_before
public void setForceLabel(String forceLabel) {
    this.forceLabel = forceLabel;
    force.setIsAvailable(true);
    // $NON-NLS-1$
    onPropertyChanged(new PropertyChangedEventArgs("forceLabel"));
}
#method_after
public void setForceLabel(String forceLabel) {
    this.forceLabel = forceLabel;
    // $NON-NLS-1$
    onPropertyChanged(new PropertyChangedEventArgs("forceLabel"));
}
#end_block

#method_before
private void updateActionAvailability(GlusterVolumeEntity volumeEntity) {
    boolean allowNewGeoRepSessionCommand = true;
    boolean allowStartSessionCommand = false;
    boolean allowStopSessionCommand = false;
    boolean allowResumeSessionCommand = false;
    boolean allowPauseSessionCommand = false;
    boolean allowSessionOptionsCommand = false;
    boolean allowRemoveSessionCommand = false;
    if (volumeEntity == null) {
        return;
    }
    if (getSelectedItems() != null && getSelectedItems().size() == 1) {
        GlusterGeoRepSession selectedSession = getSelectedItem();
        GeoRepSessionStatus sessionStatus = selectedSession.getStatus();
        allowStartSessionCommand = sessionStatus == GeoRepSessionStatus.CREATED || sessionStatus == GeoRepSessionStatus.STOPPED;
        allowStopSessionCommand = !allowStartSessionCommand;
        allowResumeSessionCommand = sessionStatus == GeoRepSessionStatus.PAUSED;
        allowPauseSessionCommand = sessionStatus == GeoRepSessionStatus.ACTIVE || sessionStatus == GeoRepSessionStatus.INITIALIZING;
        allowSessionOptionsCommand = true;
        allowNewGeoRepSessionCommand = volumeEntity.getStatus() == GlusterStatus.UP;
        allowRemoveSessionCommand = true;
    }
    getNewSessionCommand().setIsExecutionAllowed(allowNewGeoRepSessionCommand);
    getRemoveSessionCommand().setIsExecutionAllowed(allowRemoveSessionCommand);
    getStartSessionCommand().setIsExecutionAllowed(allowStartSessionCommand);
    getStopSessionCommand().setIsExecutionAllowed(allowStopSessionCommand);
    getPauseSessionCommand().setIsExecutionAllowed(allowPauseSessionCommand);
    getResumeSessionCommand().setIsExecutionAllowed(allowResumeSessionCommand);
    getSessionOptionsCommand().setIsExecutionAllowed(allowSessionOptionsCommand);
    getViewSessionDetailsCommand().setIsAvailable(false);
    getRefreshSessionsCommand().setIsAvailable(true);
}
#method_after
private void updateActionAvailability(GlusterVolumeEntity volumeEntity) {
    boolean allowNewGeoRepSessionCommand = true;
    boolean allowStartSessionCommand = false;
    boolean allowStopSessionCommand = false;
    boolean allowResumeSessionCommand = false;
    boolean allowPauseSessionCommand = false;
    boolean allowSessionOptionsCommand = false;
    boolean allowRemoveSessionCommand = false;
    boolean allowSessionDetailsCommand = false;
    if (volumeEntity == null) {
        return;
    }
    if (getSelectedItems() != null && getSelectedItems().size() == 1) {
        GlusterGeoRepSession selectedSession = getSelectedItem();
        GeoRepSessionStatus sessionStatus = selectedSession.getStatus();
        allowStartSessionCommand = sessionStatus == GeoRepSessionStatus.CREATED || sessionStatus == GeoRepSessionStatus.STOPPED;
        allowStopSessionCommand = !allowStartSessionCommand;
        allowResumeSessionCommand = sessionStatus == GeoRepSessionStatus.PAUSED;
        allowPauseSessionCommand = sessionStatus == GeoRepSessionStatus.ACTIVE || sessionStatus == GeoRepSessionStatus.INITIALIZING;
        allowSessionOptionsCommand = true;
        allowNewGeoRepSessionCommand = volumeEntity.getStatus() == GlusterStatus.UP;
        allowRemoveSessionCommand = true;
        allowSessionDetailsCommand = true;
    }
    getNewSessionCommand().setIsExecutionAllowed(allowNewGeoRepSessionCommand);
    getRemoveSessionCommand().setIsExecutionAllowed(allowRemoveSessionCommand);
    getStartSessionCommand().setIsExecutionAllowed(allowStartSessionCommand);
    getStopSessionCommand().setIsExecutionAllowed(allowStopSessionCommand);
    getPauseSessionCommand().setIsExecutionAllowed(allowPauseSessionCommand);
    getResumeSessionCommand().setIsExecutionAllowed(allowResumeSessionCommand);
    getSessionOptionsCommand().setIsExecutionAllowed(allowSessionOptionsCommand);
    getViewSessionDetailsCommand().setIsExecutionAllowed(allowSessionDetailsCommand);
    getRefreshSessionsCommand().setIsAvailable(true);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewSessionCommand())) {
        createGeoRepSession();
    } else if (command.equals(getRemoveSessionCommand())) {
        // $NON-NLS-1$//$NON-NLS-2$
        confirmGeoRepAction(constants.geoReplicationRemoveTitle(), HelpTag.volume_geo_rep_remove_confirmation, "volume_geo_rep_remove_confirmation", "removeGeoRepSession", constants.removeGeoRep());
    } else if (command.equals(getStartSessionCommand())) {
        startGeoRepSession();
    } else if (command.equals(getStopSessionCommand())) {
        // $NON-NLS-1$//$NON-NLS-2$
        confirmGeoRepAction(constants.geoReplicationStopTitle(), HelpTag.volume_geo_rep_stop_confirmation, "volume_geo_rep_stop_confirmation", "stopGeoRepSesssion", constants.stopGeoRep());
    } else if (command.equals(getPauseSessionCommand())) {
        // $NON-NLS-1$//$NON-NLS-2$
        confirmGeoRepAction(constants.geoReplicationPauseTitle(), HelpTag.volume_geo_rep_pause_confirmation, "volume_geo_rep_pause_confirmation", "pauseGeoRepSession", constants.pauseGeoRep());
    } else if (command.equals(getResumeSessionCommand())) {
        resumeGeoRepSession();
    } else if (command.equals(getSessionOptionsCommand())) {
        showSessionOptions();
    } else if (command.equals(getViewSessionDetailsCommand())) {
    } else if (command.equals(getRefreshSessionsCommand())) {
        refreshSessions();
    } else if (command.getName().equalsIgnoreCase("onCreateSession")) {
        // $NON-NLS-1$
        onCreateSession();
    } else if (command.getName().equalsIgnoreCase("onStartGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StartGlusterVolumeGeoRep);
    } else if (command.getName().equalsIgnoreCase("onStopGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StopGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onPauseGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.PauseGlusterVolumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onResumeGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.ResumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onRemoveGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.DeleteGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("ok")) {
        // $NON-NLS-1$
        updateConfig();
    } else if (command.getName().equalsIgnoreCase("closeWindow")) {
        // $NON-NLS-1$
        closeWindow();
    } else if (command.getName().equalsIgnoreCase("stopGeoRepSesssion")) {
        // $NON-NLS-1$
        stopGeoRepSession();
    } else if (command.getName().equalsIgnoreCase("removeGeoRepSession")) {
        // $NON-NLS-1$
        removeGeoRepSession();
    } else if (command.getName().equalsIgnoreCase("pauseGeoRepSession")) {
        // $NON-NLS-1$
        pauseGeoRepSession();
    } else if (command.getName().equalsIgnoreCase("closeConfirmWindow")) {
        // $NON-NLS-1$
        closeConfirmWindow();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewSessionCommand())) {
        createGeoRepSession();
    } else if (command.equals(getRemoveSessionCommand())) {
        // $NON-NLS-1$//$NON-NLS-2$
        confirmGeoRepAction(constants.geoReplicationRemoveTitle(), HelpTag.volume_geo_rep_remove_confirmation, "volume_geo_rep_remove_confirmation", "removeGeoRepSession", constants.removeGeoRep());
    } else if (command.equals(getStartSessionCommand())) {
        startGeoRepSession();
    } else if (command.equals(getStopSessionCommand())) {
        // $NON-NLS-1$//$NON-NLS-2$
        confirmGeoRepAction(constants.geoReplicationStopTitle(), HelpTag.volume_geo_rep_stop_confirmation, "volume_geo_rep_stop_confirmation", "stopGeoRepSesssion", constants.stopGeoRep());
    } else if (command.equals(getPauseSessionCommand())) {
        // $NON-NLS-1$//$NON-NLS-2$
        confirmGeoRepAction(constants.geoReplicationPauseTitle(), HelpTag.volume_geo_rep_pause_confirmation, "volume_geo_rep_pause_confirmation", "pauseGeoRepSession", constants.pauseGeoRep());
    } else if (command.equals(getResumeSessionCommand())) {
        resumeGeoRepSession();
    } else if (command.equals(getSessionOptionsCommand())) {
        showSessionOptions();
    } else if (command.equals(getViewSessionDetailsCommand())) {
        showGeoRepSessionDetails((GlusterGeoRepSession) getSelectedItem());
    } else if (command.equals(getRefreshSessionsCommand())) {
        refreshSessions();
    } else if (command.getName().equalsIgnoreCase("onCreateSession")) {
        // $NON-NLS-1$
        onCreateSession();
    } else if (command.getName().equalsIgnoreCase("onStartGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StartGlusterVolumeGeoRep);
    } else if (command.getName().equalsIgnoreCase("onStopGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StopGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onPauseGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.PauseGlusterVolumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onResumeGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.ResumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onRemoveGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.DeleteGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("ok")) {
        // $NON-NLS-1$
        updateConfig();
    } else if (command.getName().equalsIgnoreCase("closeWindow")) {
        // $NON-NLS-1$
        closeWindow();
    } else if (command.getName().equalsIgnoreCase("stopGeoRepSesssion")) {
        // $NON-NLS-1$
        stopGeoRepSession();
    } else if (command.getName().equalsIgnoreCase("removeGeoRepSession")) {
        // $NON-NLS-1$
        removeGeoRepSession();
    } else if (command.getName().equalsIgnoreCase("pauseGeoRepSession")) {
        // $NON-NLS-1$
        pauseGeoRepSession();
    } else if (command.getName().equalsIgnoreCase("closeConfirmWindow")) {
        // $NON-NLS-1$
        closeConfirmWindow();
    }
}
#end_block

#method_before
private void onCreateSession() {
    final GlusterVolumeGeoRepCreateModel createModel = (GlusterVolumeGeoRepCreateModel) getWindow();
    if (!createModel.validate()) {
        return;
    }
    createModel.startProgress(null);
    final Guid masterVolumeId = getEntity().getId();
    final String remoteVolumeName = createModel.getSlaveVolumes().getSelectedItem().getName();
    final String remoteHostName = createModel.getSlaveHosts().getSelectedItem().getFirst();
    String remoteUserName = createModel.getSlaveUserName().getEntity();
    String remoteUserGroup = createModel.getSlaveUserGroupName().getEntity();
    final Guid remoteHostId = createModel.getSlaveHosts().getSelectedItem().getSecond();
    Frontend.getInstance().runAction(VdcActionType.CreateGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionParameters(masterVolumeId, remoteVolumeName, remoteHostId, remoteUserName, remoteUserGroup, !createModel.getShowEligibleVolumes().getEntity()), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            createModel.stopProgress();
            if (result.getReturnValue().getSucceeded()) {
                closeWindow();
                if (createModel.getStartSession().getEntity()) {
                    // $NON-NLS-1$//$NON-NLS-2$
                    initializeGeoRepActionConfirmation(constants.geoReplicationStartTitle(), HelpTag.volume_geo_rep_start_confirmation, "volume_geo_rep_start_confirmation", constants.geoRepForceHelp(), messages.geoRepForceTitle(constants.startGeoRep()), "onStartGeoRepSession", getEntity().getName(), remoteVolumeName, remoteHostName);
                    final GlusterVolumeGeoRepActionConfirmationModel cModel = (GlusterVolumeGeoRepActionConfirmationModel) getWindow();
                    cModel.startProgress(null);
                    Frontend.getInstance().runAction(VdcActionType.StartGlusterVolumeGeoRep, new GlusterVolumeGeoRepSessionParameters(masterVolumeId, remoteVolumeName, remoteHostId), new IFrontendActionAsyncCallback() {

                        @Override
                        public void executed(FrontendActionAsyncResult result) {
                            cModel.stopProgress();
                            if (!result.getReturnValue().getSucceeded()) {
                                cModel.setMessage(result.getReturnValue().getFault().getMessage());
                            } else {
                                closeWindow();
                            }
                        }
                    }, VolumeGeoRepListModel.this, false);
                }
            } else {
                createModel.setQueryFailureMessage(result.getReturnValue().getFault().getMessage());
            }
        }
    }, this, false);
}
#method_after
private void onCreateSession() {
    final GlusterVolumeGeoRepCreateModel createModel = (GlusterVolumeGeoRepCreateModel) getWindow();
    if (!createModel.validate()) {
        return;
    }
    createModel.startProgress(null);
    final Guid masterVolumeId = getEntity().getId();
    final String remoteVolumeName = createModel.getSlaveVolumes().getSelectedItem().getName();
    final String remoteHostName = createModel.getSlaveHosts().getSelectedItem().getFirst();
    String remoteUserName = createModel.getSlaveUserName().getEntity();
    String remoteUserGroup = createModel.getSlaveUserGroupName().getEntity();
    final Guid remoteHostId = createModel.getSlaveHosts().getSelectedItem().getSecond();
    Frontend.getInstance().runAction(VdcActionType.CreateGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionParameters(masterVolumeId, remoteVolumeName, remoteHostId, remoteUserName, remoteUserGroup, !createModel.getShowEligibleVolumes().getEntity()), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            createModel.stopProgress();
            if (result.getReturnValue().getSucceeded()) {
                closeWindow();
                if (createModel.getStartSession().getEntity()) {
                    // $NON-NLS-1$//$NON-NLS-2$
                    initializeGeoRepActionConfirmation(constants.geoReplicationStartTitle(), HelpTag.volume_geo_rep_start_confirmation, "volume_geo_rep_start_confirmation", constants.geoRepForceHelp(), messages.geoRepForceTitle(constants.startGeoRep()), "onStartGeoRepSession", getEntity().getName(), remoteVolumeName, remoteHostName, null);
                    final GlusterVolumeGeoRepActionConfirmationModel cModel = (GlusterVolumeGeoRepActionConfirmationModel) getWindow();
                    cModel.startProgress(null);
                    Frontend.getInstance().runAction(VdcActionType.StartGlusterVolumeGeoRep, new GlusterVolumeGeoRepSessionParameters(masterVolumeId, remoteVolumeName, remoteHostId), new IFrontendActionAsyncCallback() {

                        @Override
                        public void executed(FrontendActionAsyncResult result) {
                            cModel.stopProgress();
                            if (!result.getReturnValue().getSucceeded()) {
                                cModel.setMessage(result.getReturnValue().getFault().getMessage());
                            } else {
                                closeWindow();
                            }
                        }
                    }, VolumeGeoRepListModel.this, false);
                }
            } else {
                createModel.setQueryFailureMessage(result.getReturnValue().getFault().getMessage());
            }
        }
    }, this, false);
}
#end_block

#method_before
private void confirmGeoRepAction(String title, HelpTag helpTag, String hashName, String commandName, String action) {
    GlusterGeoRepSession selectedSession = getSelectedItem();
    if (selectedSession == null) {
        return;
    }
    GlusterVolumeGeoRepActionConfirmationModel cModel = new GlusterVolumeGeoRepActionConfirmationModel();
    cModel.setTitle(title);
    cModel.setHelpTag(helpTag);
    cModel.setHashName(hashName);
    cModel.setMessage(messages.geoRepActionConfirmationMessage(action));
    setWindow(cModel);
    cModel.initWindow(selectedSession.getMasterVolumeName(), selectedSession.getSlaveVolumeName(), selectedSession.getSlaveHostName());
    cModel.getCommands().add(UICommand.createDefaultOkUiCommand(commandName, this));
    // $NON-NLS-1$
    cModel.getCommands().add(UICommand.createCancelUiCommand("closeWindow", this));
}
#method_after
private void confirmGeoRepAction(String title, HelpTag helpTag, String hashName, String commandName, String action) {
    GlusterGeoRepSession selectedSession = getSelectedItem();
    if (selectedSession == null) {
        return;
    }
    initializeGeoRepActionConfirmation(title, helpTag, hashName, null, null, commandName, selectedSession.getMasterVolumeName(), selectedSession.getSlaveVolumeName(), selectedSession.getSlaveHostName(), messages.geoRepActionConfirmationMessage(action));
}
#end_block

#method_before
private void performGeoRepAction(String commandName, String confirmTitle, HelpTag helpTag, String hashName, String action, VdcActionType actionType, String actionProgressText) {
    GlusterGeoRepSession selectedSession = getSelectedItem();
    if (selectedSession == null) {
        return;
    }
    initializeGeoRepActionConfirmation(confirmTitle, helpTag, hashName, constants.geoRepForceHelp(), messages.geoRepForceTitle(action), commandName, selectedSession.getMasterVolumeName(), selectedSession.getSlaveVolumeName(), selectedSession.getSlaveHostName());
    onGeoRepSessionAction(actionType);
}
#method_after
private void performGeoRepAction(String commandName, String confirmTitle, HelpTag helpTag, String hashName, String action, VdcActionType actionType, String actionProgressText) {
    GlusterGeoRepSession selectedSession = getSelectedItem();
    if (selectedSession == null) {
        return;
    }
    initializeGeoRepActionConfirmation(confirmTitle, helpTag, hashName, constants.geoRepForceHelp(), messages.geoRepForceTitle(action), commandName, selectedSession.getMasterVolumeName(), selectedSession.getSlaveVolumeName(), selectedSession.getSlaveHostName(), null);
    onGeoRepSessionAction(actionType);
}
#end_block

#method_before
private void initializeGeoRepActionConfirmation(String title, HelpTag helpTag, String hashName, String forceHelp, String forceLabelText, String commandName, String masterVolumeName, String slaveVolumeName, String slaveHostName) {
    GlusterVolumeGeoRepActionConfirmationModel cModel;
    if (getWindow() != null) {
        cModel = (GlusterVolumeGeoRepActionConfirmationModel) getWindow();
    } else {
        cModel = new GlusterVolumeGeoRepActionConfirmationModel();
        cModel.setTitle(title);
    }
    cModel.setHelpTag(helpTag);
    cModel.setHashName(hashName);
    setWindow(cModel);
    cModel.initWindow(masterVolumeName, slaveVolumeName, slaveHostName);
    cModel.setForceHelp(forceHelp);
    cModel.setForceLabel(forceLabelText);
    // $NON-NLS-1$
    List<UICommand> geoRepActionCommands = Arrays.asList(UICommand.createDefaultOkUiCommand(commandName, this), UICommand.createCancelUiCommand("closeWindow", this));
    if (cModel.getCommands() != null) {
        cModel.setCommands(geoRepActionCommands);
    }
}
#method_after
private void initializeGeoRepActionConfirmation(String title, HelpTag helpTag, String hashName, String forceHelp, String forceLabelText, String commandName, String masterVolumeName, String slaveVolumeName, String slaveHostName, String message) {
    GlusterVolumeGeoRepActionConfirmationModel cModel;
    if (getWindow() != null) {
        if ((getWindow() instanceof GlusterVolumeGeoRepActionConfirmationModel)) {
            cModel = (GlusterVolumeGeoRepActionConfirmationModel) getWindow();
        } else {
            return;
        }
    } else {
        cModel = new GlusterVolumeGeoRepActionConfirmationModel();
        cModel.setTitle(title);
    }
    cModel.setHelpTag(helpTag);
    cModel.setHashName(hashName);
    setWindow(cModel);
    cModel.initWindow(masterVolumeName, slaveVolumeName, slaveHostName);
    cModel.setActionConfirmationMessage(message);
    cModel.setForceHelp(forceHelp);
    cModel.setForceLabel(forceLabelText);
    // $NON-NLS-1$
    List<UICommand> geoRepActionCommands = Arrays.asList(UICommand.createDefaultOkUiCommand(commandName, this), UICommand.createCancelUiCommand("closeWindow", this));
    if (cModel.getCommands().size() > 0) {
        cModel.setCommands(geoRepActionCommands);
    } else {
        cModel.getCommands().addAll(geoRepActionCommands);
    }
}
#end_block

#method_before
private void onGeoRepSessionAction(VdcActionType actionType) {
    final GlusterVolumeGeoRepActionConfirmationModel cModel = (GlusterVolumeGeoRepActionConfirmationModel) getWindow();
    cModel.startProgress(null);
    boolean force = cModel.getForce().getEntity();
    GlusterGeoRepSession selectedSession = getSelectedItem();
    GlusterVolumeGeoRepSessionParameters sessionParamters = new GlusterVolumeGeoRepSessionParameters(selectedSession.getMasterVolumeId(), selectedSession.getId());
    sessionParamters.setForce(force);
    Frontend.getInstance().runAction(actionType, sessionParamters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            if (cModel == null) {
                return;
            } else {
                cModel.stopProgress();
                if (!result.getReturnValue().getSucceeded()) {
                    cModel.setMessage(result.getReturnValue().getFault().getMessage());
                } else {
                    setWindow(null);
                }
            }
        }
    }, this, false);
}
#method_after
private void onGeoRepSessionAction(VdcActionType actionType) {
    final GlusterVolumeGeoRepActionConfirmationModel cModel = (GlusterVolumeGeoRepActionConfirmationModel) getWindow();
    cModel.startProgress(null);
    boolean force = cModel.getForce().getEntity();
    GlusterGeoRepSession selectedSession = getSelectedItem();
    GlusterVolumeGeoRepSessionParameters sessionParamters = new GlusterVolumeGeoRepSessionParameters(selectedSession.getMasterVolumeId(), selectedSession.getId());
    sessionParamters.setForce(force);
    Frontend.getInstance().runAction(actionType, sessionParamters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            if (cModel == null) {
                return;
            } else {
                cModel.stopProgress();
                if (!result.getReturnValue().getSucceeded()) {
                    cModel.setActionConfirmationMessage(result.getReturnValue().getFault().getMessage());
                } else {
                    setWindow(null);
                }
            }
        }
    }, this, false);
}
#end_block

#method_before
private void initVisibilities() {
    errorMsg.setVisible(false);
    messageLabel.setVisible(false);
    geoRepForceHelpIcon.setVisible(false);
}
#method_after
private void initVisibilities() {
    errorMsg.setVisible(false);
    geoRepForceHelpIcon.setVisible(false);
}
#end_block

#method_before
@Override
public void setForceLabelMessage(String forceLabelMessage) {
    forceEditor.setLabel(forceLabelMessage == null ? constants.notAvailableLabel() : forceLabelMessage);
    forceEditor.setVisible(forceLabelMessage != null);
}
#method_after
@Override
public void setForceLabelMessage(String forceLabelMessage) {
    boolean isNonEmptyForceLabelMessage = forceLabelMessage != null;
    if (isNonEmptyForceLabelMessage) {
        forceEditor.setLabel(forceLabelMessage);
    }
    forceEditor.setVisible(isNonEmptyForceLabelMessage);
}
#end_block

#method_before
@Override
public void setForceHelp(String forceHelpText) {
    geoRepForceHelpIcon.setText(templates.italicText(forceHelpText));
    geoRepForceHelpIcon.setVisible(!forceHelpText.isEmpty());
}
#method_after
@Override
public void setForceHelp(String forceHelpText) {
    boolean isForceHelpNonEmpty = forceHelpText != null;
    if (isForceHelpNonEmpty) {
        geoRepForceHelpIcon.setText(templates.italicText(forceHelpText));
    }
    geoRepForceHelpIcon.setVisible(isForceHelpNonEmpty);
}
#end_block

#method_before
@Override
public void setErrorMessage(String errorMessage) {
    errorMsg.setText(errorMessage);
    errorMsg.setVisible(errorMessage != null);
}
#method_after
@Override
public void setErrorMessage(String errorMessage) {
    boolean isNonEmptyErrorMessage = errorMessage != null;
    if (isNonEmptyErrorMessage) {
        errorMsg.setText(errorMessage);
    }
    errorMsg.setVisible(isNonEmptyErrorMessage);
}
#end_block

#method_before
@Override
public void edit(VmNextRunConfigurationModel object) {
    driver.edit(object);
    cpuPanel.setVisible(object.isCpuPluggable() || object.isMemoryPluggable());
    applyNowCpuMessage.setVisible(object.isCpuPluggable());
    applyNowMemoryMessage.setVisible(object.isMemoryPluggable());
    SafeHtmlBuilder changedFieldsBuilder = new SafeHtmlBuilder();
    for (String field : object.getChangedFields()) {
        String escapedField = SafeHtmlUtils.htmlEscape(field);
        changedFieldsBuilder.append(listItem(escapedField));
    }
    changedFields.setHTML(changedFieldsBuilder.toSafeHtml());
}
#method_after
@Override
public void edit(VmNextRunConfigurationModel object) {
    driver.edit(object);
    hotplugPanel.setVisible(object.isCpuPluggable() || object.isMemoryPluggable());
    applyNowCpuMessage.setVisible(object.isCpuPluggable());
    applyNowMemoryMessage.setVisible(object.isMemoryPluggable());
    SafeHtmlBuilder changedFieldsBuilder = new SafeHtmlBuilder();
    for (String field : object.getChangedFields()) {
        String escapedField = SafeHtmlUtils.htmlEscape(field);
        changedFieldsBuilder.append(listItem(escapedField));
    }
    changedFields.setHTML(changedFieldsBuilder.toSafeHtml());
}
#end_block

#method_before
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    BuilderExecutor.build(model, tempVar.getStaticData(), new CommonUnitToVmBaseBuilder<VmStatic>());
    BuilderExecutor.build(vm.getStaticData(), tempVar.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder());
    return tempVar;
}
#method_after
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    BuilderExecutor.build(model, tempVar.getStaticData(), new CommonUnitToVmBaseBuilder<VmStatic>());
    BuilderExecutor.build(vm.getStaticData(), tempVar.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder(), new CpuSharesVmBaseToVmBaseBuilder());
    return tempVar;
}
#end_block

#method_before
private void importVms() {
    if (getWindow() != null) {
        return;
    }
    final ImportVmsModel model = importVmsModelProvider.get();
    model.init();
    setWindow(model);
    model.getCommands().add(new UICommand(CMD_CONFIGURE_VMS_TO_IMPORT, this).setIsExecutionAllowed(false).setTitle(ConstantsManager.getInstance().getConstants().next()).setIsDefault(true));
    model.getCommands().add(new UICommand(CMD_CANCEL, this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
    model.initImportFromExportDomainModel(new UICommand(CMD_RESTORE_FROM_EXPORT_DOMAIN, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            onRestoreFromExportDomain();
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true), new UICommand(CMD_BACK, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            // remove current window first
            setWindow(null);
            setWindow(model);
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().back()), new UICommand(CMD_CANCEL, this).setIsCancel(true).setTitle(ConstantsManager.getInstance().getConstants().cancel()));
}
#method_after
private void importVms() {
    if (getWindow() != null) {
        return;
    }
    final ImportVmsModel model = importVmsModelProvider.get();
    model.init();
    setWindow(model);
    model.getCommands().add(new UICommand(CMD_CONFIGURE_VMS_TO_IMPORT, this).setIsExecutionAllowed(false).setTitle(ConstantsManager.getInstance().getConstants().next()).setIsDefault(true));
    model.getCommands().add(new UICommand(CMD_CANCEL, this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
    model.initImportModels(new UICommand(CMD_IMPORT, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            model.onRestoreVms(new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    setWindow(null);
                }
            });
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true), new UICommand(CMD_BACK, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            // remove current window first
            setWindow(null);
            setWindow(model);
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().back()), new UICommand(CMD_CANCEL, this).setIsCancel(true).setTitle(ConstantsManager.getInstance().getConstants().cancel()));
}
#end_block

#method_before
private void onConfigureVmsToImport() {
    final ImportVmsModel importVmsModel = (ImportVmsModel) getWindow();
    if (importVmsModel == null) {
        return;
    }
    ImportVmFromExportDomainModel model = importVmsModel.getSpecificImportModel();
    // remove import-vms window first
    setWindow(null);
    setWindow(model);
}
#method_after
private void onConfigureVmsToImport() {
    final ImportVmsModel importVmsModel = (ImportVmsModel) getWindow();
    if (importVmsModel == null) {
        return;
    }
    final ImportVmModel model = importVmsModel.getSpecificImportModel();
    // remove import-vms window first
    setWindow(null);
    setWindow(model);
}
#end_block

#method_before
private ImageResource getImage(T object) {
    VmDevice device = getDeviceFromObject(object);
    if (device != null) {
        switch(device.getType()) {
            case DISK:
                return resources.diskDeviceGeneralTypeIcon();
            case INTERFACE:
                return resources.interfaceDeviceGeneralTypeIcon();
            case VIDEO:
                return resources.videoDeviceGeneralTypeIcon();
            case GRAPHICS:
                return resources.graphicsDeviceGeneralTypeIcon();
            case SOUND:
                return resources.soundDeviceGeneralTypeIcon();
            case CONTROLLER:
                return resources.controllerDeviceGeneralTypeIcon();
            case BALLOON:
                return resources.balloonDeviceGeneralTypeIcon();
            case CHANNEL:
                return resources.channelDeviceGeneralTypeIcon();
            case REDIR:
                return resources.redirDeviceGeneralTypeIcon();
            case CONSOLE:
                return resources.consoleDeviceGeneralTypeIcon();
            case RNG:
                return resources.rngDeviceGeneralTypeIcon();
            case SMARTCARD:
                return resources.smartcardDeviceGeneralTypeIcon();
            case WATCHDOG:
                return resources.watchdogDeviceGeneralTypeIcon();
            case HOSTDEV:
                return resources.hostdevDeviceGeneralTypeIcon();
            case MEMORY:
                return resources.MemoryDeviceGeneralTypeIcon();
            case UNKNOWN:
                return resources.questionMarkImage();
        }
    }
    return null;
}
#method_after
private ImageResource getImage(T object) {
    VmDevice device = getDeviceFromObject(object);
    if (device != null) {
        switch(device.getType()) {
            case DISK:
                return resources.diskDeviceGeneralTypeIcon();
            case INTERFACE:
                return resources.interfaceDeviceGeneralTypeIcon();
            case VIDEO:
                return resources.videoDeviceGeneralTypeIcon();
            case GRAPHICS:
                return resources.graphicsDeviceGeneralTypeIcon();
            case SOUND:
                return resources.soundDeviceGeneralTypeIcon();
            case CONTROLLER:
                return resources.controllerDeviceGeneralTypeIcon();
            case BALLOON:
                return resources.balloonDeviceGeneralTypeIcon();
            case CHANNEL:
                return resources.channelDeviceGeneralTypeIcon();
            case REDIR:
                return resources.redirDeviceGeneralTypeIcon();
            case CONSOLE:
                return resources.consoleDeviceGeneralTypeIcon();
            case RNG:
                return resources.rngDeviceGeneralTypeIcon();
            case SMARTCARD:
                return resources.smartcardDeviceGeneralTypeIcon();
            case WATCHDOG:
                return resources.watchdogDeviceGeneralTypeIcon();
            case HOSTDEV:
                return resources.hostdevDeviceGeneralTypeIcon();
            case MEMORY:
                return resources.memoryDeviceGeneralTypeIcon();
            case UNKNOWN:
                return resources.questionMarkImage();
        }
    }
    return null;
}
#end_block

#method_before
@Test
public void addWithName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Name", "VdsGroupId" }, new Object[] { NAMES[1], GUIDS[2] }, getTemplateEntity());
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVirtioScsiControllers, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpGetEntityExpectations(VdcQueryType.GetSoundDevices, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpCreationExpectations(VdcActionType.AddVmPoolWithVms, VmPoolParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[0], VdcQueryType.GetVmPoolById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VmPool pool = getModel(0);
    pool.setId(null);
    pool.getTemplate().setId(null);
    pool.getTemplate().setName(NAMES[1]);
    Response response = collection.add(pool);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VmPool);
    verifyModelTemplate((VmPool) response.getEntity());
}
#method_after
@Test
public void addWithName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Name", "ClusterId" }, new Object[] { NAMES[1], GUIDS[2] }, getTemplateEntity());
    setUpGetConsoleExpectations(new int[] { 1 });
    setUpGetRngDeviceExpectations(new int[] { 0 });
    setUpGetEntityExpectations(VdcQueryType.GetVirtioScsiControllers, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpGetEntityExpectations(VdcQueryType.GetSoundDevices, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, new ArrayList<>());
    setUpCreationExpectations(VdcActionType.AddVmPoolWithVms, VmPoolParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[0], VdcQueryType.GetVmPoolById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VmPool pool = getModel(0);
    pool.setId(null);
    pool.getTemplate().setId(null);
    pool.getTemplate().setName(NAMES[1]);
    Response response = collection.add(pool);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VmPool);
    verifyModelTemplate((VmPool) response.getEntity());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VmTemplate vmt;
    GetVmTemplateParameters params = getParameters();
    if (params.getName() != null) {
        Guid storagePoolId = getStoragePoolId(params);
        vmt = DbFacade.getInstance().getVmTemplateDao().getByName(params.getName(), storagePoolId, getUserID(), params.isFiltered());
    } else {
        vmt = DbFacade.getInstance().getVmTemplateDao().get(getParameters().getId(), getUserID(), getParameters().isFiltered());
    }
    if (vmt != null) {
        VmTemplateHandler.updateDisksFromDb(vmt);
        VmHandler.updateVmInitFromDB(vmt, true);
    }
    getQueryReturnValue().setReturnValue(vmt);
}
#method_after
@Override
protected void executeQueryCommand() {
    VmTemplate vmt;
    GetVmTemplateParameters params = getParameters();
    if (params.getName() != null) {
        // If no DC info available, the query will return the first
        Guid storagePoolId = getStoragePoolId();
        // Template with the given name found.
        vmt = DbFacade.getInstance().getVmTemplateDao().getByName(params.getName(), storagePoolId, getUserID(), params.isFiltered());
    } else {
        vmt = DbFacade.getInstance().getVmTemplateDao().get(getParameters().getId(), getUserID(), getParameters().isFiltered());
    }
    if (vmt != null) {
        VmTemplateHandler.updateDisksFromDb(vmt);
        VmHandler.updateVmInitFromDB(vmt, true);
    }
    getQueryReturnValue().setReturnValue(vmt);
}
#end_block

#method_before
// Get the DC ID. If no DC info available, the query will return the first VM
private Guid getStoragePoolId(GetVmTemplateParameters params) {
    return params.getStoragePoolId() != null ? params.getStoragePoolId() : params.getVdsGroupId() != null ? DbFacade.getInstance().getVdsGroupDao().get(params.getVdsGroupId()).getStoragePoolId() : null;
}
#method_after
private Guid getStoragePoolId() {
    Guid result = null;
    GetVmTemplateParameters params = getParameters();
    if (params.getDataCenterId() != null) {
        result = params.getDataCenterId();
    } else if (params.getClusterId() != null) {
        VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(params.getClusterId());
        if (vdsGroup != null) {
            result = vdsGroup.getStoragePoolId();
        }
    }
    return result;
}
#end_block

#method_before
public boolean isVmTemlateWithSameNameExist(String name, Guid datacenterId) {
    return DbFacade.getInstance().getVmTemplateDao().getByName(name, datacenterId, null, false) != null;
}
#method_after
public boolean isVmTemlateWithSameNameExist(String name, Guid datacenterId) {
    return vmTemplateDao.getByName(name, datacenterId, null, false) != null;
}
#end_block

#method_before
public boolean isInstanceWithSameNameExists(String name) {
    return DbFacade.getInstance().getVmTemplateDao().getInstanceByName(name, null, false) != null;
}
#method_after
public boolean isInstanceWithSameNameExists(String name) {
    return vmTemplateDao.getInstanceTypeByName(name, null, false) != null;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<>();
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = new HashMap<String, String>();
        jobProperties.put(VdcObjectType.StoragePool.name().toLowerCase(), getStoragePoolName());
        jobProperties.put(VdcObjectType.VmTemplate.name().toLowerCase(), getVmTemplateName());
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = new HashMap<>();
        jobProperties.put(VdcObjectType.StoragePool.name().toLowerCase(), getStoragePoolName());
        jobProperties.put(VdcObjectType.VmTemplate.name().toLowerCase(), getVmTemplateName());
    }
    return jobProperties;
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            VDSGroup cluster = getCluster(vm);
            VmTemplate template = lookupTemplate(vm.getTemplate(), cluster.getStoragePoolId());
            VmStatic builtFromTemplate = VmMapper.map(template, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !ObjectUtils.equals(template.getVdsGroupId(), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                Mapper<InstanceType, VmStatic> instanceTypeMapper = getMapper(InstanceType.class, VmStatic.class);
                instanceTypeEntity = lookupInstance(vm.getInstanceType());
                builtFromInstanceType = instanceTypeMapper.map(instanceTypeEntity, builtFromTemplate);
                builtFromInstanceType.setInstanceTypeId(instanceTypeEntity.getId());
            }
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(cluster.getId());
            }
            if (Guid.Empty.equals(template.getId()) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster.getCompatibilityVersion()));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && template.getId().equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, template, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(template.getId())) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, template, instanceTypeEntity, cluster);
            }
        }
    }
    VM result = (VM) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
        removeRestrictedInfo(result);
    }
    return response;
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            VDSGroup cluster = getCluster(vm);
            VmTemplate template = lookupTemplate(vm.getTemplate(), cluster.getStoragePoolId());
            VmStatic builtFromTemplate = VmMapper.map(template, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !ObjectUtils.equals(template.getVdsGroupId(), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                instanceTypeEntity = lookupInstance(vm.getInstanceType());
                builtFromInstanceType = VmMapper.map(instanceTypeEntity, builtFromTemplate, cluster.getCompatibilityVersion());
                builtFromInstanceType.setInstanceTypeId(instanceTypeEntity.getId());
            }
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(cluster.getId());
            }
            if (Guid.Empty.equals(template.getId()) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster.getCompatibilityVersion()));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && template.getId().equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, template, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(template.getId())) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, template, instanceTypeEntity, cluster);
            }
        }
    }
    VM result = (VM) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
        removeRestrictedInfo(result);
    }
    return response;
}
#end_block

#method_before
protected VmTemplate lookupTemplate(Template template, Guid datacenterId) {
    if (template.isSetId()) {
        return getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(asGuid(template.getId())), "GetVmTemplate");
    } else if (template.isSetName()) {
        GetVmTemplateParameters params = new GetVmTemplateParameters(template.getName());
        params.setStoragePoolId(datacenterId);
        return getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, params, "GetVmTemplate");
    }
    // should never happen.
    return null;
}
#method_after
protected VmTemplate lookupTemplate(Template template, Guid datacenterId) {
    if (template.isSetId()) {
        return getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(asGuid(template.getId())), "GetVmTemplate");
    } else if (template.isSetName()) {
        GetVmTemplateParameters params = new GetVmTemplateParameters(template.getName());
        params.setDataCenterId(datacenterId);
        return getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, params, "GetVmTemplate");
    }
    // should never happen.
    return null;
}
#end_block

#method_before
private void onSave() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate()) {
        return;
    }
    String name = model.getName().getEntity();
    boolean isBaseTemplate = false;
    if (model.getBehavior().isExistingTemplateBehavior()) {
        isBaseTemplate = ((TemplateVmModelBehavior) model.getBehavior()).getVmTemplate().isBaseTemplate();
    } else if (model.getBehavior().isBlankTemplateBehavior()) {
        isBaseTemplate = true;
    }
    if (isBaseTemplate) {
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                TemplateListModel templateListModel = (TemplateListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                templateListModel.postNameUniqueCheck(isNameUnique);
            }
        }), name, model.getDataCenterWithClustersList().getSelectedItem().getDataCenter().getId());
    } else {
        postNameUniqueCheck(true);
    }
}
#method_after
private void onSave() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate()) {
        return;
    }
    String name = model.getName().getEntity();
    boolean isBaseTemplate = false;
    if (model.getBehavior().isExistingTemplateBehavior()) {
        isBaseTemplate = ((TemplateVmModelBehavior) model.getBehavior()).getVmTemplate().isBaseTemplate();
    } else if (model.getBehavior().isBlankTemplateBehavior()) {
        isBaseTemplate = true;
    }
    if (isBaseTemplate) {
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                TemplateListModel templateListModel = (TemplateListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                templateListModel.postNameUniqueCheck(isNameUnique);
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    } else {
        postNameUniqueCheck(true);
    }
}
#end_block

#method_before
public void postNameUniqueCheck(boolean isNameUnique) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VmTemplate selectedItem;
    if (model.getBehavior().isExistingTemplateBehavior()) {
        selectedItem = ((TemplateVmModelBehavior) model.getBehavior()).getVmTemplate();
    } else {
        selectedItem = ((ExistingBlankTemplateModelBehavior) model.getBehavior()).getVmTemplate();
    }
    final VmTemplate template = (VmTemplate) Cloner.clone(selectedItem);
    final String iconForParameters = IconCache.getInstance().getIcon(selectedItem.getLargeIconId()).equals(model.getIcon().getEntity().getIcon()) ? null : IconUtils.filterPredefinedIcons(model.getIcon().getEntity().getIcon());
    String name = model.getName().getEntity();
    // Check name unicitate.
    if (!isNameUnique && name.compareToIgnoreCase(template.getName()) != 0) {
        model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
        model.getName().setIsValid(false);
        model.setValidTab(TabName.GENERAL_TAB, false);
        return;
    }
    // Save changes.
    buildTemplateOnSave(model, template);
    template.setCreatedByUserId(selectedItem.getCreatedByUserId());
    model.startProgress(null);
    template.setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
    parameters.setVmLargeIcon(iconForParameters);
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    BuilderExecutor.build(model, parameters, new UnitToGraphicsDeviceParamsBuilder());
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    setVmRngDeviceToParams(model, parameters);
    Frontend.getInstance().runAction(VdcActionType.UpdateVmTemplate, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            TemplateListModel localModel = (TemplateListModel) result.getState();
            localModel.postUpdateVmTemplate(result.getReturnValue());
        }
    }, this);
}
#method_after
public void postNameUniqueCheck(boolean isNameUnique) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VmTemplate selectedItem;
    if (model.getBehavior().isExistingTemplateBehavior()) {
        selectedItem = ((TemplateVmModelBehavior) model.getBehavior()).getVmTemplate();
    } else {
        selectedItem = ((ExistingBlankTemplateModelBehavior) model.getBehavior()).getVmTemplate();
    }
    final VmTemplate template = (VmTemplate) Cloner.clone(selectedItem);
    final String iconForParameters = IconCache.getInstance().getIcon(selectedItem.getLargeIconId()).equals(model.getIcon().getEntity().getIcon()) ? null : IconUtils.filterPredefinedIcons(model.getIcon().getEntity().getIcon());
    String name = model.getName().getEntity();
    // Check name unicitate.
    if (!isNameUnique && name.compareToIgnoreCase(template.getName()) != 0) {
        model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
        model.getName().setIsValid(false);
        model.setValidTab(TabName.GENERAL_TAB, false);
        return;
    }
    // Save changes.
    buildTemplateOnSave(model, template);
    template.setCreatedByUserId(selectedItem.getCreatedByUserId());
    model.startProgress(null);
    template.setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
    parameters.setVmLargeIcon(iconForParameters);
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    BuilderExecutor.build(model, parameters, new UnitToGraphicsDeviceParamsBuilder());
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    setVmRngDeviceToParams(model, parameters);
    parameters.setBalloonEnabled(balloonEnabled(model));
    parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    Frontend.getInstance().runAction(VdcActionType.UpdateVmTemplate, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            TemplateListModel localModel = (TemplateListModel) result.getState();
            localModel.postUpdateVmTemplate(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        retVal = validateTemplateArchitecture();
    }
    if (retVal) {
        retVal = isVDSGroupCompatible();
    }
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = validate(sourceDomainValidator.isDomainExistAndActive());
    }
    if (retVal && (getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !isImagesAlreadyOnTarget()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal && !isImagesAlreadyOnTarget()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            ArrayList<DiskImage> images = new ArrayList<DiskImage>();
            for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
                if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                    images = new ArrayList<DiskImage>(entry.getValue());
                    getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                    getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                    break;
                }
            }
            getParameters().setImages(images);
            getVmTemplate().setImages(images);
            ensureDomainMap(getImages(), getParameters().getDestDomainId());
            HashMap<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : images) {
                if (Guid.Empty.equals(image.getVmSnapshotId())) {
                    retVal = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
                    break;
                }
                StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
                if (!retVal) {
                    break;
                }
                StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
                retVal = ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setStoragePoolId(getParameters().getStoragePoolId());
                    image.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomain.getId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getName()));
            retVal = false;
        } else if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal) {
        retVal = validateNoDuplicateDiskImages(getImages());
    }
    if (retVal && getImages() != null && !getImages().isEmpty() && !isImagesAlreadyOnTarget()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    if (retVal) {
        retVal = validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVmTemplate().getInterfaces()));
    }
    // if this is a template version, check base template exist
    if (retVal && !getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = getVmTemplateDAO().get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            retVal = false;
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (retVal && !setAndValidateDiskProfiles()) {
        return false;
    }
    if (retVal && !setAndValidateCpuProfile()) {
        return false;
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        retVal = validateTemplateArchitecture();
    }
    if (retVal) {
        retVal = isVDSGroupCompatible();
    }
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = validate(sourceDomainValidator.isDomainExistAndActive());
    }
    if (retVal && (getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !isImagesAlreadyOnTarget()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal && !isImagesAlreadyOnTarget()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            ArrayList<DiskImage> images = new ArrayList<>();
            for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
                if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                    images = new ArrayList<>(entry.getValue());
                    getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                    getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                    break;
                }
            }
            getParameters().setImages(images);
            getVmTemplate().setImages(images);
            ensureDomainMap(getImages(), getParameters().getDestDomainId());
            HashMap<Guid, DiskImage> imageMap = new HashMap<>();
            for (DiskImage image : images) {
                if (Guid.Empty.equals(image.getVmSnapshotId())) {
                    retVal = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
                    break;
                }
                StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
                if (!retVal) {
                    break;
                }
                StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
                retVal = ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setStoragePoolId(getParameters().getStoragePoolId());
                    image.setStorageIds(new ArrayList<>(Arrays.asList(storageDomain.getId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getName()));
            retVal = false;
        } else if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal) {
        retVal = validateNoDuplicateDiskImages(getImages());
    }
    if (retVal && getImages() != null && !getImages().isEmpty() && !isImagesAlreadyOnTarget()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    if (retVal) {
        retVal = validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVmTemplate().getInterfaces()));
    }
    // if this is a template version, check base template exist
    if (retVal && !getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = getVmTemplateDAO().get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            retVal = false;
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (retVal && !setAndValidateDiskProfiles()) {
        return false;
    }
    if (retVal && !setAndValidateCpuProfile()) {
        return false;
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#end_block

#method_before
protected boolean isVmTemplateWithSameNameExist() {
    return DbFacade.getInstance().getVmTemplateDao().getByName(getParameters().getVmTemplate().getName(), getParameters().getStoragePoolId(), null, false) != null;
}
#method_after
protected boolean isVmTemplateWithSameNameExist() {
    return vmTemplateDao.getByName(getParameters().getVmTemplate().getName(), getParameters().getStoragePoolId(), null, false) != null;
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = new HashMap<String, String>();
        jobProperties.put(VdcObjectType.VmTemplate.name().toLowerCase(), (getVmTemplateName() == null) ? "" : getVmTemplateName());
        jobProperties.put(VdcObjectType.StoragePool.name().toLowerCase(), getStoragePoolName());
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = new HashMap<>();
        jobProperties.put(VdcObjectType.VmTemplate.name().toLowerCase(), (getVmTemplateName() == null) ? "" : getVmTemplateName());
        jobProperties.put(VdcObjectType.StoragePool.name().toLowerCase(), getStoragePoolName());
    }
    return jobProperties;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (DiskImage disk : getParameters().getVmTemplate().getDiskList()) {
        // TODO: handle import more than once;
        list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, imageToDestinationDomainMap.get(disk.getId()), (double) disk.getSizeInGigabytes()));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    for (DiskImage disk : getParameters().getVmTemplate().getDiskList()) {
        // TODO: handle import more than once;
        list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, imageToDestinationDomainMap.get(disk.getId()), (double) disk.getSizeInGigabytes()));
    }
    return list;
}
#end_block

#method_before
public boolean isVmTemlateWithSameNameExist(String name, Guid datacenterId) {
    return DbFacade.getInstance().getVmTemplateDao().getByName(name, datacenterId, null, false) != null;
}
#method_after
public boolean isVmTemlateWithSameNameExist(String name, Guid datacenterId) {
    return vmTemplateDao.getByName(name, datacenterId, null, false) != null;
}
#end_block

#method_before
private void setDetailList(final VmGeneralModel vmGeneralModel, final VmInterfaceListModel vmInterfaceListModel, final VmDiskListModel vmDiskListModel, final VmSnapshotListModel vmSnapshotListModel, final VmEventListModel vmEventListModel, final VmAppListModel<VM> vmAppListModel, final PermissionListModel<VM> permissionListModel, final VmAffinityGroupListModel vmAffinityGroupListModel, final VmSessionsModel vmSessionsModel, final VmHostDeviceListModel vmHostDeviceListModel) {
    List<HasEntity<VM>> list = new ArrayList<>();
    list.add(vmGeneralModel);
    list.add(vmInterfaceListModel);
    vmDiskListModel.setSystemTreeContext(this);
    list.add(vmDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(permissionListModel);
    list.add(vmAffinityGroupListModel);
    list.add(vmSessionsModel);
    list.add(vmHostDeviceListModel);
    setDetailModels(list);
}
#method_after
private void setDetailList(final VmGeneralModel vmGeneralModel, final VmInterfaceListModel vmInterfaceListModel, final VmDiskListModel vmDiskListModel, final VmSnapshotListModel vmSnapshotListModel, final VmEventListModel vmEventListModel, final VmAppListModel<VM> vmAppListModel, final PermissionListModel<VM> permissionListModel, final VmAffinityGroupListModel vmAffinityGroupListModel, final VmGuestInfoModel vmGuestInfoModel, final VmHostDeviceListModel vmHostDeviceListModel, final VmDevicesListModel vmDevicesListModel) {
    List<HasEntity<VM>> list = new ArrayList<>();
    list.add(vmGeneralModel);
    list.add(vmInterfaceListModel);
    vmDiskListModel.setSystemTreeContext(this);
    list.add(vmDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(vmDevicesListModel);
    list.add(permissionListModel);
    list.add(vmAffinityGroupListModel);
    list.add(vmGuestInfoModel);
    list.add(vmHostDeviceListModel);
    setDetailModels(list);
}
#end_block

#method_before
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel<Void> vmListModel = (VmListModel<Void>) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name, model.getDataCenterWithClustersList().getSelectedItem().getDataCenter().getId());
    }
}
#method_after
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel<Void> vmListModel = (VmListModel<Void>) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#end_block

#method_before
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setBalloonEnabled(balloonEnabled(model));
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    if (model.getIsSubTemplate().getEntity()) {
        addVmTemplateParameters.setBaseTemplateId(model.getBaseTemplate().getSelectedItem().getId());
        addVmTemplateParameters.setTemplateVersionName(model.getTemplateVersionName().getEntity());
    }
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#method_after
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToAddVmTemplateParametersBuilder());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#end_block

#method_before
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM resultVm = new VM();
    resultVm.setId(vm.getId());
    BuilderExecutor.build(model, resultVm.getStaticData(), new CommonUnitToVmBaseBuilder());
    BuilderExecutor.build(vm.getStaticData(), resultVm.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new DedicatedVmForVdsVmBaseToVmBaseBuilder(), new MigrationOptionsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder());
    return resultVm;
}
#method_after
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM resultVm = new VM();
    resultVm.setId(vm.getId());
    BuilderExecutor.build(model, resultVm.getStaticData(), new CommonUnitToVmBaseBuilder());
    BuilderExecutor.build(vm.getStaticData(), resultVm.getStaticData(), new VmBaseToVmBaseForTemplateCompositeBaseBuilder());
    return resultVm;
}
#end_block

#method_before
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object thisModel, Object returnValue) {
                List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                if (!changedFields.isEmpty()) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#method_after
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object thisModel, Object returnValue) {
                List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                if (!changedFields.isEmpty()) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                    // currentl only hot plug memory is supported here (no hot unplug)
                    confirmModel.setMemoryPluggable(selectedItem.getMemSizeMb() < getcurrentVm().getMemSizeMb());
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#end_block

#method_before
private void importVms() {
    if (getWindow() != null) {
        return;
    }
    final ImportVmsModel model = importVmsModelProvider.get();
    model.init();
    setWindow(model);
    model.getCommands().add(new UICommand(CMD_CONFIGURE_VMS_TO_IMPORT, this).setIsExecutionAllowed(false).setTitle(ConstantsManager.getInstance().getConstants().next()).setIsDefault(true));
    model.getCommands().add(new UICommand(CMD_CANCEL, this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
    model.initImportFromExportDomainModel(new UICommand(CMD_RESTORE_FROM_EXPORT_DOMAIN, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            onRestoreFromExportDomain();
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true), new UICommand(CMD_BACK, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            // remove current window first
            setWindow(null);
            setWindow(model);
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().back()), new UICommand(CMD_CANCEL, this).setIsCancel(true).setTitle(ConstantsManager.getInstance().getConstants().cancel()));
}
#method_after
private void importVms() {
    if (getWindow() != null) {
        return;
    }
    final ImportVmsModel model = importVmsModelProvider.get();
    model.init();
    setWindow(model);
    model.getCommands().add(new UICommand(CMD_CONFIGURE_VMS_TO_IMPORT, this).setIsExecutionAllowed(false).setTitle(ConstantsManager.getInstance().getConstants().next()).setIsDefault(true));
    model.getCommands().add(new UICommand(CMD_CANCEL, this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
    model.initImportModels(new UICommand(CMD_IMPORT, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            model.onRestoreVms(new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    setWindow(null);
                }
            });
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true), new UICommand(CMD_BACK, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            // remove current window first
            setWindow(null);
            setWindow(model);
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().back()), new UICommand(CMD_CANCEL, this).setIsCancel(true).setTitle(ConstantsManager.getInstance().getConstants().cancel()));
}
#end_block

#method_before
private void onConfigureVmsToImport() {
    final ImportVmsModel importVmsModel = (ImportVmsModel) getWindow();
    if (importVmsModel == null) {
        return;
    }
    ImportVmFromExportDomainModel model = importVmsModel.getSpecificImportModel();
    // remove import-vms window first
    setWindow(null);
    setWindow(model);
}
#method_after
private void onConfigureVmsToImport() {
    final ImportVmsModel importVmsModel = (ImportVmsModel) getWindow();
    if (importVmsModel == null) {
        return;
    }
    final ImportVmModel model = importVmsModel.getSpecificImportModel();
    // remove import-vms window first
    setWindow(null);
    setWindow(model);
}
#end_block

#method_before
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    GetImagesListByStoragePoolIdParameters parameters = new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.ISO);
    parameters.setForceRefresh(forceRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, parameters, aQuery);
}
#method_after
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    ImageFileType imageFileType = ImageFileType.ISO;
    getIrsImageList(aQuery, storagePoolId, forceRefresh, imageFileType);
}
#end_block

#method_before
public void getFloppyImageList(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.Floppy), aQuery);
}
#method_after
public void getFloppyImageList(AsyncQuery aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false, ImageFileType.Floppy);
}
#end_block

#method_before
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    GetImagesListByStoragePoolIdParameters parameters = new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.ISO);
    parameters.setForceRefresh(forceRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, parameters, aQuery);
}
#method_after
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh, ImageFileType imageFileType) {
    getIrsImageList(aQuery, storagePoolId, forceRefresh, imageFileType, new RepoImageToImageFileNameAsyncConverter());
}
#end_block

#method_before
public void getHostById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getHostById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id).withoutRefresh(), aQuery);
}
#end_block

#method_before
public void isVmNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#method_after
public void isVmNameUnique(AsyncQuery aQuery, String name, Guid datacenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    NameQueryParameters params = new NameQueryParameters(name);
    params.setDatacenterId(datacenterId);
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, params, aQuery);
}
#end_block

#method_before
public void getVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Disk> list = new ArrayList<Disk>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((Disk) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Disk> list = new ArrayList<Disk>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((Disk) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(id).withoutRefresh(), aQuery);
}
#end_block

#method_before
private void setDetailList() {
    vmGeneralModel.setIsAvailable(false);
    vmSnapshotListModel.setIsAvailable(false);
    vmMonitorModel.setIsAvailable(false);
    vmDiskListModel.setIsAvailable(false);
    vmInterfaceListModel.setIsAvailable(false);
    poolGeneralModel.setIsAvailable(false);
    poolDiskListModel.setIsAvailable(false);
    poolInterfaceListModel.setIsAvailable(false);
    permissionListModel.setIsAvailable(true);
    vmEventListModel.setIsAvailable(true);
    vmAppListModel.setIsAvailable(true);
    vmSessionsModel.setIsAvailable(true);
    List<HasEntity<?>> /* extends VmOrPool */
    list = new ArrayList<>();
    list.add(vmGeneralModel);
    list.add(poolGeneralModel);
    list.add(vmInterfaceListModel);
    list.add(poolInterfaceListModel);
    list.add(vmDiskListModel);
    list.add(poolDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(permissionListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(vmMonitorModel);
    list.add(vmSessionsModel);
    setDetailModels((List) list);
}
#method_after
private void setDetailList() {
    vmGeneralModel.setIsAvailable(false);
    vmSnapshotListModel.setIsAvailable(false);
    vmMonitorModel.setIsAvailable(false);
    vmDiskListModel.setIsAvailable(false);
    vmInterfaceListModel.setIsAvailable(false);
    poolGeneralModel.setIsAvailable(false);
    poolDiskListModel.setIsAvailable(false);
    poolInterfaceListModel.setIsAvailable(false);
    permissionListModel.setIsAvailable(true);
    vmEventListModel.setIsAvailable(true);
    vmAppListModel.setIsAvailable(true);
    vmGuestInfoModel.setIsAvailable(true);
    List<HasEntity<?>> /* extends VmOrPool */
    list = new ArrayList<>();
    list.add(vmGeneralModel);
    list.add(poolGeneralModel);
    list.add(vmInterfaceListModel);
    list.add(poolInterfaceListModel);
    list.add(vmDiskListModel);
    list.add(poolDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(permissionListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(vmMonitorModel);
    list.add(vmGuestInfoModel);
    setDetailModels((List) list);
}
#end_block

#method_before
private void onNewTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress(null);
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name, model.getDataCenterWithClustersList().getSelectedItem().getDataCenter().getId());
    }
}
#method_after
private void onNewTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress(null);
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#end_block

#method_before
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    BuilderExecutor.build(model, tempVar.getStaticData(), new CommonUnitToVmBaseBuilder<VmStatic>());
    BuilderExecutor.build(vm.getStaticData(), tempVar.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder());
    return tempVar;
}
#method_after
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    BuilderExecutor.build(model, tempVar.getStaticData(), new CommonUnitToVmBaseBuilder<VmStatic>());
    BuilderExecutor.build(vm.getStaticData(), tempVar.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder(), new CpuSharesVmBaseToVmBaseBuilder());
    return tempVar;
}
#end_block

#method_before
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress(null);
    // Check name uniqueness.
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setValidTab(TabName.GENERAL_TAB, false);
                stopProgress(target);
            } else {
                userPortalListModel.postVmNameUniqueCheck(userPortalListModel);
            }
        }
    }), model.getName().getEntity());
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress(null);
    // Check name uniqueness.
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setValidTab(TabName.GENERAL_TAB, false);
                stopProgress(target);
            } else {
                userPortalListModel.postVmNameUniqueCheck(userPortalListModel);
            }
        }
    }), model.getName().getEntity(), model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
}
#end_block

#method_before
public void postVmNameUniqueCheck(final UserPortalListModel userPortalListModel) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) ((UserPortalItemModel) userPortalListModel.getSelectedItem()).getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(userPortalListModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(userPortalListModel, false);
        }
    }
}
#method_after
public void postVmNameUniqueCheck(final UserPortalListModel userPortalListModel) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) ((UserPortalItemModel) userPortalListModel.getSelectedItem()).getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        // currentl only hot plug memory is supported here (no hot unplug)
                        confirmModel.setMemoryPluggable(selectedItem.getMemSizeMb() < gettempVm().getMemSizeMb());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(userPortalListModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(userPortalListModel, false);
        }
    }
}
#end_block

#method_before
protected void updateDiskInfoDestinationMap() {
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<Guid, DiskImage>();
    }
    sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getStorageIds().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
}
#method_after
protected void updateDiskInfoDestinationMap() {
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    sourceImageDomainsImageMap = new HashMap<>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getStorageIds().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
}
#end_block

#method_before
private CreateImageTemplateParameters buildChildCommandParameters(DiskImage diskImage, Guid vmSnapshotId) {
    CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getImageId(), getVmTemplateId(), getVmTemplateName(), getVmId());
    createParams.setStorageDomainId(diskImage.getStorageIds().get(0));
    createParams.setVmSnapshotId(vmSnapshotId);
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setDestinationStorageDomainId(diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0));
    createParams.setDiskAlias(diskInfoDestinationMap.get(diskImage.getId()).getDiskAlias());
    createParams.setDescription(diskInfoDestinationMap.get(diskImage.getId()).getDiskDescription());
    createParams.setParentParameters(getParameters());
    createParams.setQuotaId(getQuotaIdForDisk(diskImage));
    createParams.setDiskProfileId(diskInfoDestinationMap.get(diskImage.getId()).getDiskProfileId());
    return createParams;
}
#method_after
private CreateImageTemplateParameters buildChildCommandParameters(DiskImage diskImage, Guid vmSnapshotId) {
    DiskImage imageFromParams = diskInfoDestinationMap.get(diskImage.getId());
    CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getImageId(), getVmTemplateId(), getVmTemplateName(), getVmId());
    createParams.setStorageDomainId(diskImage.getStorageIds().get(0));
    createParams.setVmSnapshotId(vmSnapshotId);
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setDestinationStorageDomainId(imageFromParams.getStorageIds().get(0));
    createParams.setDiskAlias(imageFromParams.getDiskAlias());
    createParams.setDescription(imageFromParams.getDiskDescription());
    createParams.setParentCommand(getActionType());
    createParams.setParentParameters(getParameters());
    createParams.setQuotaId(getQuotaIdForDisk(diskImage));
    createParams.setDiskProfileId(imageFromParams.getDiskProfileId());
    createParams.setVolumeFormat(imageFromParams.getVolumeFormat());
    createParams.setVolumeType(imageFromParams.getVolumeType());
    return createParams;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values());
            if (!cinderDisks.isEmpty() && !addVmTemplateCinderDisks(cinderDisks, srcDeviceIdToTargetDeviceIdMapping)) {
                setSucceeded(false);
                return null;
            }
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), graphicsToSkip, false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), graphicsToSkip, false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            addGraphicsDevice();
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            if (getVm() != null && !addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping)) {
                return null;
            }
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.hasMemoryBalloon(getVmId()), graphicsToSkip, false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), graphicsToSkip, false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            addGraphicsDevice();
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    // be unique also across datacenters.
    if (!isTemplateVersion()) {
        if (isInstanceType) {
            if (isInstanceWithSameNameExists(getVmTemplateName())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        } else {
            if (isVmTemlateWithSameNameExist(getVmTemplateName(), getVdsGroup().getStoragePoolId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        }
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    // be unique also across datacenters.
    if (!isTemplateVersion()) {
        if (isInstanceType) {
            if (isInstanceWithSameNameExists(getVmTemplateName())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        } else {
            if (isVmTemlateWithSameNameExist(getVmTemplateName(), getVdsGroup().getStoragePoolId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        }
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isTemplateVersion() && getBaseTemplate().isBlank()) {
        return failCanDoAction(VdcBllMessages.BLANK_TEMPLATE_CANT_HAVE_SUBTEMPLATES);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#end_block

#method_before
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(mImages);
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
        if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        diskImagesToCheck.addAll(cinderDisks);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#method_after
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(mImages);
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
        if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        diskImagesToCheck.addAll(cinderDisks);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#end_block

#method_before
private Set<Guid> getStorageGuidSet() {
    Set<Guid> destImageDomains = new HashSet<Guid>();
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        destImageDomains.add(diskImage.getStorageIds().get(0));
    }
    return destImageDomains;
}
#method_after
private Set<Guid> getStorageGuidSet() {
    Set<Guid> destImageDomains = new HashSet<>();
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        destImageDomains.add(diskImage.getStorageIds().get(0));
    }
    return destImageDomains;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
protected boolean addVmTemplateCinderDisks(List<CinderDisk> cinderDisks, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    // Create Cinder disk templates
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.CloneCinderDisks, buildCinderChildCommandParameters(cinderDisks, getVmSnapshotId()), cloneContextAndDetachFromParent(), CINDERStorageHelper.getStorageEntities(cinderDisks));
    try {
        VdcReturnValueBase vdcReturnValueBase = future.get();
        if (vdcReturnValueBase.getSucceeded()) {
            Map<Guid, Guid> diskImageMap = vdcReturnValueBase.getActionReturnValue();
            srcDeviceIdToTargetDeviceIdMapping.putAll(diskImageMap);
        } else {
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            log.error("Error cloning Cinder disks for template");
            return false;
        }
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error cloning Cinder disks for template", e);
        return false;
    }
    return true;
}
#method_after
protected boolean addVmTemplateCinderDisks(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values());
    if (cinderDisks.isEmpty()) {
        return true;
    }
    // Create Cinder disk templates
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.CloneCinderDisks, buildCinderChildCommandParameters(cinderDisks, getVmSnapshotId()), cloneContextAndDetachFromParent(), CINDERStorageHelper.getStorageEntities(cinderDisks));
    try {
        VdcReturnValueBase vdcReturnValueBase = future.get();
        if (vdcReturnValueBase.getSucceeded()) {
            Map<Guid, Guid> diskImageMap = vdcReturnValueBase.getActionReturnValue();
            srcDeviceIdToTargetDeviceIdMapping.putAll(diskImageMap);
        } else {
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            log.error("Error cloning Cinder disks for template");
            return false;
        }
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error cloning Cinder disks for template", e);
        return false;
    }
    return true;
}
#end_block

#method_before
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<DiskImage> diskImages = ImagesHandler.filterImageDisks(mImages, true, false, true);
    for (DiskImage diskImage : diskImages) {
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildChildCommandParameters(diskImage, Guid.newGuid()), ExecutionHandler.createDefaultContextForTasks(getContext()));
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
        DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
        srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
    }
}
#method_after
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<DiskImage> diskImages = ImagesHandler.filterImageDisks(mImages, true, false, true);
    for (DiskImage diskImage : diskImages) {
        addVmTemplateImage(srcDeviceIdToTargetDeviceIdMapping, diskImage);
    }
}
#end_block

#method_before
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (isTemplateVersion()) {
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "updateVmVersion", new Class[0], new Object[0], 0, TimeUnit.SECONDS);
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), jobId);
    }
}
#method_after
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (isTemplateVersion()) {
        String jobId = getSchedulUtil().scheduleAOneTimeJob(this, "updateVmVersion", new Class[0], new Object[0], 0, TimeUnit.SECONDS);
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), jobId);
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
            Guid storagePoolId = getVdsGroup() == null ? null : getVdsGroup().getStoragePoolId();
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
            // host-specific parameters can be changed by administration role only
            if (getParameters().getMasterVm().getDedicatedVmForVds() != null || !StringUtils.isEmpty(getParameters().getMasterVm().getCpuPinning())) {
                permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
            }
        } else {
            permissionCheckSubject.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, getActionType().getActionGroup()));
        }
    }
    return permissionCheckSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<>();
        if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
            Guid storagePoolId = getVdsGroup() == null ? null : getVdsGroup().getStoragePoolId();
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
            // host-specific parameters can be changed by administration role only
            if (getParameters().getMasterVm().getDedicatedVmForVds() != null || !StringUtils.isEmpty(getParameters().getMasterVm().getCpuPinning())) {
                permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
            }
        } else {
            permissionCheckSubject.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, getActionType().getActionGroup()));
        }
    }
    return permissionCheckSubject;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (DiskImage disk : getVm().getDiskList()) {
        list.add(new QuotaStorageConsumptionParameter(getQuotaIdForDisk(disk), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes()));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    for (DiskImage disk : getVm().getDiskList()) {
        list.add(new QuotaStorageConsumptionParameter(getQuotaIdForDisk(disk), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes()));
    }
    return list;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    list.add(new QuotaSanityParameter(getQuotaId(), null));
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    list.add(new QuotaSanityParameter(getQuotaId(), null));
    return list;
}
#end_block

#method_before
@Override
public InstanceType getInstanceType(Guid id) {
    VmTemplate result = get(id);
    if (result != null && result.getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        result = null;
    }
    return result;
}
#method_after
@Override
public InstanceType getInstanceType(Guid id, Guid userID, boolean isFiltered) {
    VmTemplate result = get(id, userID, isFiltered);
    if (result != null && result.getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        result = null;
    }
    return result;
}
#end_block

#method_before
@Override
public InstanceType getInstanceType(Guid id) {
    VmTemplate result = get(id);
    if (result != null && result.getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        result = null;
    }
    return result;
}
#method_after
@Override
public InstanceType getInstanceType(Guid id) {
    return getInstanceType(id, null, false);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    InstanceType instance;
    GetVmTemplateParameters params = getParameters();
    if (params.getName() != null) {
        instance = DbFacade.getInstance().getVmTemplateDao().getInstanceByName(params.getName(), getUserID(), getParameters().isFiltered());
    } else {
        instance = DbFacade.getInstance().getVmTemplateDao().get(getParameters().getId(), getUserID(), getParameters().isFiltered());
    }
    getQueryReturnValue().setReturnValue(instance);
}
#method_after
@Override
protected void executeQueryCommand() {
    InstanceType instance;
    GetVmTemplateParameters params = getParameters();
    if (params.getName() != null) {
        instance = vmTemplateDao.getInstanceTypeByName(params.getName(), getUserID(), getParameters().isFiltered());
    } else {
        instance = vmTemplateDao.getInstanceType(getParameters().getId(), getUserID(), getParameters().isFiltered());
    }
    getQueryReturnValue().setReturnValue(instance);
}
#end_block

#method_before
protected VmTemplate getVmTemplate(VmPool pool) {
    if (pool.getTemplate().isSetId()) {
        return getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(asGuid(pool.getTemplate().getId())), pool.getTemplate().getId());
    } else {
        GetVmTemplateParameters params = new GetVmTemplateParameters(pool.getTemplate().getName());
        params.setVdsGroupId(asGuid(pool.getCluster().getId()));
        return getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, params, "Template: name=" + pool.getTemplate().getName());
    }
}
#method_after
protected VmTemplate getVmTemplate(VmPool pool) {
    if (pool.getTemplate().isSetId()) {
        return getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(asGuid(pool.getTemplate().getId())), pool.getTemplate().getId());
    } else {
        GetVmTemplateParameters params = new GetVmTemplateParameters(pool.getTemplate().getName());
        params.setClusterId(asGuid(pool.getCluster().getId()));
        return getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, params, "Template: name=" + pool.getTemplate().getName());
    }
}
#end_block

#method_before
@Test
public void testAddPassTemplateByName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Name", "StoragePoolId" }, new Object[] { NAMES[1], GUIDS[3] }, getTemplateEntity(1));
    setupAddExpectations();
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setName(NAMES[1].toString());
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddPassTemplateByName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Name", "DataCenterId" }, new Object[] { NAMES[1], GUIDS[3] }, getTemplateEntity(1));
    setupAddExpectations();
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setName(NAMES[1].toString());
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getVdsGroup() == null && !(isInstanceType || isBlankTemplate)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType && !isBlankTemplate) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else {
            // be unique also across datacenters.
            if (isInstanceType) {
                if (isInstanceWithSameNameExists(getVmTemplateName())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            } else {
                if (isVmTemlateWithSameNameExist(getVmTemplateName(), getVdsGroup().getStoragePoolId())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            }
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getVdsGroup() == null && !(isInstanceType || isBlankTemplate)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType && !isBlankTemplate) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else {
            // must be unique also across datacenters.
            if (isInstanceType) {
                if (isInstanceWithSameNameExists(getVmTemplateName())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            } else {
                if (isVmTemlateWithSameNameExist(getVmTemplateName(), isBlankTemplate ? null : getVdsGroup().getStoragePoolId())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            }
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    if (mOldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate((new VmWatchdogValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.isVirtioScsiControllerAttached(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.isBalloonEnabled(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVdsGroup().getCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return returnValue;
}
#method_after
private boolean doClusterRelatedChecks() {
    if (mOldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate((new VmWatchdogValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.hasVirtioScsiController(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.hasMemoryBalloon(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVdsGroup().getCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return returnValue;
}
#end_block

#method_before
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : VmDeviceUtils.isSoundDeviceEnabled(getParameters().getVmTemplateData().getId());
}
#method_after
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : VmDeviceUtils.hasSoundDevice(getParameters().getVmTemplateData().getId());
}
#end_block

#method_before
private void updateVmTemplate() {
    VmHandler.updateVmInitToDB(getVmTemplate());
    DbFacade.getInstance().getVmTemplateDao().update(getVmTemplate());
    // also update the smartcard device
    VmDeviceUtils.updateSmartcardDevice(getVmTemplateId(), getParameters().getVmTemplateData().isSmartcardEnabled());
    // update audio device
    VmDeviceUtils.updateAudioDevice(mOldTemplate, getVmTemplate(), getVdsGroup() != null ? getVdsGroup().getCompatibilityVersion() : null, getParameters().isSoundDeviceEnabled());
    VmDeviceUtils.updateConsoleDevice(getVmTemplateId(), getParameters().isConsoleEnabled());
    VmDeviceUtils.updateVirtioScsiController(getVmTemplateId(), getParameters().isVirtioScsiEnabled());
    VmDeviceUtils.updateMemoryBalloon(getVmTemplateId(), getParameters().isBalloonEnabled());
}
#method_after
private void updateVmTemplate() {
    VmHandler.updateVmInitToDB(getVmTemplate());
    DbFacade.getInstance().getVmTemplateDao().update(getVmTemplate());
    // also update the smartcard device
    VmDeviceUtils.updateSmartcardDevice(getVmTemplateId(), getParameters().getVmTemplateData().isSmartcardEnabled());
    // update audio device
    VmDeviceUtils.updateSoundDevice(mOldTemplate, getVmTemplate(), getVdsGroup() != null ? getVdsGroup().getCompatibilityVersion() : null, getParameters().isSoundDeviceEnabled());
    VmDeviceUtils.updateConsoleDevice(getVmTemplateId(), getParameters().isConsoleEnabled());
    VmDeviceUtils.updateVirtioScsiController(getVmTemplateId(), getParameters().isVirtioScsiEnabled());
    VmDeviceUtils.updateMemoryBalloon(getVmTemplateId(), getParameters().isBalloonEnabled());
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    list.add(new QuotaSanityParameter(getParameters().getVmTemplateData().getQuotaId(), null));
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    list.add(new QuotaSanityParameter(getParameters().getVmTemplateData().getQuotaId(), null));
    return list;
}
#end_block

#method_before
@Before
public void setUp() {
    // The VM to use
    Guid vmId = Guid.newGuid();
    Guid vdsGroupId = Guid.newGuid();
    spId = Guid.newGuid();
    vm = new VM();
    vm.setId(vmId);
    vm.setVdsGroupId(vdsGroupId);
    vm.setStoragePoolId(spId);
    vm.setVmOs(14);
    when(vmDao.get(vmId)).thenReturn(vm);
    // The cluster to use
    vdsGroup = new VDSGroup();
    vdsGroup.setCpuName("Intel Conroe Family");
    vdsGroup.setArchitecture(ArchitectureType.x86_64);
    vdsGroup.setId(vdsGroupId);
    vdsGroup.setStoragePoolId(spId);
    vdsGroup.setCompatibilityVersion(Version.v3_2);
    when(vdsGroupDao.get(vdsGroupId)).thenReturn(vdsGroup);
    AddVmTemplateParameters params = new AddVmTemplateParameters(vm, "templateName", "Template for testing");
    mockOsRepository();
    // Using the compensation constructor since the normal one contains DB access
    cmd = spy(new AddVmTemplateCommand<AddVmTemplateParameters>(params) {

        @Override
        protected List<DiskImage> getVmDisksFromDB() {
            return getDisksList(spId);
        }

        @Override
        protected void updateVmDevices() {
        }

        @Override
        public VM getVm() {
            return vm;
        }

        @Override
        public void separateCustomProperties(VmStatic parameterMasterVm) {
        }
    });
    doReturn(vmDao).when(cmd).getVmDAO();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDAO();
    cmd.setVmId(vmId);
    cmd.setVdsGroupId(vdsGroupId);
}
#method_after
@Before
public void setUp() {
    // The VM to use
    Guid vmId = Guid.newGuid();
    Guid vdsGroupId = Guid.newGuid();
    spId = Guid.newGuid();
    vm = new VM();
    vm.setId(vmId);
    vm.setVdsGroupId(vdsGroupId);
    vm.setStoragePoolId(spId);
    vm.setVmOs(14);
    when(vmDao.get(vmId)).thenReturn(vm);
    // The cluster to use
    vdsGroup = new VDSGroup();
    vdsGroup.setCpuName("Intel Conroe Family");
    vdsGroup.setArchitecture(ArchitectureType.x86_64);
    vdsGroup.setId(vdsGroupId);
    vdsGroup.setStoragePoolId(spId);
    vdsGroup.setCompatibilityVersion(Version.v3_2);
    when(vdsGroupDao.get(vdsGroupId)).thenReturn(vdsGroup);
    AddVmTemplateParameters params = new AddVmTemplateParameters(vm, "templateName", "Template for testing");
    mockOsRepository();
    // Using the compensation constructor since the normal one contains DB access
    cmd = spy(new AddVmTemplateCommand<AddVmTemplateParameters>(params) {

        @Override
        protected List<DiskImage> getVmDisksFromDB() {
            return getDisksList(spId);
        }

        @Override
        protected void updateVmDevices() {
        }

        @Override
        public VM getVm() {
            return vm;
        }

        @Override
        public void separateCustomProperties(VmStatic parameterMasterVm) {
        }
    });
    cmd.postConstruct();
    doReturn(vmDao).when(cmd).getVmDAO();
    doReturn(vdsGroupDao).when(cmd).getVdsGroupDAO();
    cmd.setVmId(vmId);
    cmd.setVdsGroupId(vdsGroupId);
}
#end_block

#method_before
@Override
protected void verify(Disk model, Disk transform) {
    assertNotNull(transform);
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getImageId(), transform.getImageId());
    assertEquals(model.getFormat(), transform.getFormat());
    assertEquals(model.getInterface(), transform.getInterface());
    assertEquals(model.isActive(), transform.isActive());
    assertEquals(model.isReadOnly(), transform.isReadOnly());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getLogicalName(), transform.getLogicalName());
    assertEquals(model.getOpenstackVolumeType(), transform.getOpenstackVolumeType());
    assertNotNull(model.getSnapshot());
    assertEquals(model.getSnapshot().getId(), transform.getSnapshot().getId());
    assertEquals("unexpected status", model.getStatus().getState(), transform.getStatus().getState());
    assertEquals("unexpected sparse", model.isSparse(), transform.isSparse());
    assertEquals("unexpected bootable", model.isBootable(), transform.isBootable());
    assertEquals("unexpected propagate errors", model.isPropagateErrors(), transform.isPropagateErrors());
    assertEquals("unexpected wipe after delete", model.isWipeAfterDelete(), transform.isWipeAfterDelete());
    assertEquals("unexpected shareable", model.isShareable(), transform.isShareable());
}
#method_after
@Override
protected void verify(Disk model, Disk transform) {
    assertNotNull(transform);
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getImageId(), transform.getImageId());
    assertEquals(model.getFormat(), transform.getFormat());
    assertEquals(model.getInterface(), transform.getInterface());
    assertEquals(model.isActive(), transform.isActive());
    assertEquals(model.isReadOnly(), transform.isReadOnly());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getLogicalName(), transform.getLogicalName());
    assertEquals(model.getOpenstackVolumeType().getName(), transform.getOpenstackVolumeType().getName());
    assertNotNull(model.getSnapshot());
    assertEquals(model.getSnapshot().getId(), transform.getSnapshot().getId());
    assertEquals("unexpected status", model.getStatus().getState(), transform.getStatus().getState());
    assertEquals("unexpected sparse", model.isSparse(), transform.isSparse());
    assertEquals("unexpected bootable", model.isBootable(), transform.isBootable());
    assertEquals("unexpected propagate errors", model.isPropagateErrors(), transform.isPropagateErrors());
    assertEquals("unexpected wipe after delete", model.isWipeAfterDelete(), transform.isWipeAfterDelete());
    assertEquals("unexpected shareable", model.isShareable(), transform.isShareable());
}
#end_block

#method_before
private static void mapDiskToDiskImageProperties(Disk disk, DiskImage diskImage) {
    if (disk.isSetImageId()) {
        diskImage.setImageId(GuidUtils.asGuid(disk.getImageId()));
    }
    // and overrides the value in <size>
    if (disk.isSetSize()) {
        diskImage.setSize(disk.getSize());
    }
    if (disk.isSetProvisionedSize()) {
        diskImage.setSize(disk.getProvisionedSize());
    }
    if (disk.isSetFormat()) {
        DiskFormat diskFormat = DiskFormat.fromValue(disk.getFormat());
        if (diskFormat != null) {
            diskImage.setvolumeFormat(map(diskFormat, null));
        }
    }
    if (disk.isSetStatus()) {
        diskImage.setImageStatus(map(DiskStatus.fromValue(disk.getStatus().getState())));
    }
    if (disk.isSetSnapshot() && disk.getSnapshot().isSetId()) {
        diskImage.setVmSnapshotId(GuidUtils.asGuid(disk.getSnapshot().getId()));
    }
    if (disk.isSetSparse()) {
        diskImage.setVolumeType(disk.isSparse() ? VolumeType.Sparse : VolumeType.Preallocated);
    }
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        StorageDomain storageDomain = disk.getStorageDomains().getStorageDomains().get(0);
        diskImage.setStorageIds(new ArrayList<Guid>());
        diskImage.getStorageIds().add(Guid.createGuidFromStringDefaultEmpty(storageDomain.getId()));
    }
    if (disk.isSetQuota() && disk.getQuota().isSetId()) {
        diskImage.setQuotaId(GuidUtils.asGuid(disk.getQuota().getId()));
    }
    if (disk.isSetDiskProfile() && disk.getDiskProfile().isSetId()) {
        diskImage.setDiskProfileId(GuidUtils.asGuid(disk.getDiskProfile().getId()));
    }
    if (disk.isSetOpenstackVolumeType()) {
        diskImage.setCinderVolumeType(disk.getOpenstackVolumeType().getName());
    }
}
#method_after
private static void mapDiskToDiskImageProperties(Disk disk, DiskImage diskImage) {
    if (disk.isSetImageId()) {
        diskImage.setImageId(GuidUtils.asGuid(disk.getImageId()));
    }
    // and overrides the value in <size>
    if (disk.isSetSize()) {
        diskImage.setSize(disk.getSize());
    }
    if (disk.isSetProvisionedSize()) {
        diskImage.setSize(disk.getProvisionedSize());
    }
    if (disk.isSetFormat()) {
        DiskFormat diskFormat = DiskFormat.fromValue(disk.getFormat());
        if (diskFormat != null) {
            diskImage.setvolumeFormat(map(diskFormat, null));
        }
    }
    if (disk.isSetStatus()) {
        diskImage.setImageStatus(map(DiskStatus.fromValue(disk.getStatus().getState())));
    }
    if (disk.isSetSnapshot() && disk.getSnapshot().isSetId()) {
        diskImage.setVmSnapshotId(GuidUtils.asGuid(disk.getSnapshot().getId()));
    }
    if (disk.isSetSparse()) {
        diskImage.setVolumeType(disk.isSparse() ? VolumeType.Sparse : VolumeType.Preallocated);
    }
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        StorageDomain storageDomain = disk.getStorageDomains().getStorageDomains().get(0);
        diskImage.setStorageIds(new ArrayList<Guid>());
        diskImage.getStorageIds().add(Guid.createGuidFromStringDefaultEmpty(storageDomain.getId()));
    }
    if (disk.isSetQuota() && disk.getQuota().isSetId()) {
        diskImage.setQuotaId(GuidUtils.asGuid(disk.getQuota().getId()));
    }
    if (disk.isSetDiskProfile() && disk.getDiskProfile().isSetId()) {
        diskImage.setDiskProfileId(GuidUtils.asGuid(disk.getDiskProfile().getId()));
    }
    if (disk.isSetOpenstackVolumeType() && disk.getOpenstackVolumeType().isSetName()) {
        diskImage.setCinderVolumeType(disk.getOpenstackVolumeType().getName());
    }
}
#end_block

#method_before
private static void mapDiskImageToDiskFields(DiskImage entity, Disk model) {
    if (entity.getImageId() != null) {
        model.setImageId(entity.getImageId().toString());
    }
    model.setSize(entity.getSize());
    model.setProvisionedSize(entity.getSize());
    model.setActualSize(entity.getActualSizeInBytes());
    if (entity.getSnapshotId() != null) {
        model.setSnapshot(new Snapshot());
        model.getSnapshot().setId(entity.getSnapshotId().toString());
    }
    if (entity.getVolumeFormat() != null) {
        model.setFormat(map(entity.getVolumeFormat(), null));
    }
    if (entity.getImageStatus() != null) {
        DiskStatus status = map(entity.getImageStatus());
        model.setStatus(StatusUtils.create(status == null ? null : status.value()));
    }
    model.setSparse(VolumeType.Sparse == entity.getVolumeType());
    if (entity.getStorageIds() != null && entity.getStorageIds().size() > 0) {
        if (!model.isSetStorageDomains()) {
            model.setStorageDomains(new StorageDomains());
        }
        for (Guid id : entity.getStorageIds()) {
            StorageDomain storageDomain = new StorageDomain();
            storageDomain.setId(id.toString());
            model.getStorageDomains().getStorageDomains().add(storageDomain);
        }
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getDiskProfileId() != null) {
        DiskProfile diskProfile = new DiskProfile();
        diskProfile.setId(entity.getDiskProfileId().toString());
        model.setDiskProfile(diskProfile);
    }
    if (entity.getCinderVolumeType() != null) {
        OpenStackVolumeType volumeType = new OpenStackVolumeType();
        volumeType.setName(entity.getCinderVolumeType());
        model.setOpenstackVolumeType(volumeType);
    }
}
#method_after
private static void mapDiskImageToDiskFields(DiskImage entity, Disk model) {
    if (entity.getImageId() != null) {
        model.setImageId(entity.getImageId().toString());
    }
    model.setSize(entity.getSize());
    model.setProvisionedSize(entity.getSize());
    model.setActualSize(entity.getActualSizeInBytes());
    if (entity.getSnapshotId() != null) {
        model.setSnapshot(new Snapshot());
        model.getSnapshot().setId(entity.getSnapshotId().toString());
    }
    if (entity.getVolumeFormat() != null) {
        model.setFormat(map(entity.getVolumeFormat(), null));
    }
    if (entity.getImageStatus() != null) {
        DiskStatus status = map(entity.getImageStatus());
        model.setStatus(StatusUtils.create(status == null ? null : status.value()));
    }
    model.setSparse(VolumeType.Sparse == entity.getVolumeType());
    if (entity.getStorageIds() != null && entity.getStorageIds().size() > 0) {
        if (!model.isSetStorageDomains()) {
            model.setStorageDomains(new StorageDomains());
        }
        for (Guid id : entity.getStorageIds()) {
            StorageDomain storageDomain = new StorageDomain();
            storageDomain.setId(id.toString());
            model.getStorageDomains().getStorageDomains().add(storageDomain);
        }
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getDiskProfileId() != null) {
        DiskProfile diskProfile = new DiskProfile();
        diskProfile.setId(entity.getDiskProfileId().toString());
        model.setDiskProfile(diskProfile);
    }
    if (entity.getCinderVolumeType() != null) {
        OpenStackVolumeType volumeType = model.getOpenstackVolumeType();
        if (volumeType == null) {
            volumeType = new OpenStackVolumeType();
            model.setOpenstackVolumeType(volumeType);
        }
        volumeType.setName(entity.getCinderVolumeType());
    }
}
#end_block

#method_before
@Test
public void testSyncSnapshotsList() {
    doReturn(getExistingSnapshots()).when(snapshotDao).getAllByVolumeId(argThat(validVolumeId()));
    doReturn(getSnapshotVDSReturnVal(true)).when(syncJob).runVdsCommand(eq(VDSCommandType.GetGlusterVolumeSnapshotInfo), argThat(snapshotInfoParam()));
    syncJob.refreshSnapshotList();
    Mockito.verify(snapshotDao, times(1)).saveAll(any(List.class));
    Mockito.verify(snapshotDao, times(1)).removeAll(any(List.class));
    Mockito.verify(snapshotDao, times(1)).updateAllInBatch(any(List.class));
}
#method_after
@Test
public void testSyncSnapshotsList() {
    doReturn(getExistingSnapshots()).when(snapshotDao).getAllByVolumeId(argThat(validVolumeId()));
    doReturn(getSnapshotVDSReturnVal(true)).when(syncJob).runVdsCommand(eq(VDSCommandType.GetGlusterVolumeSnapshotInfo), argThat(snapshotInfoParam()));
    when(volumeDao.getById(any(Guid.class))).thenReturn(getVolume(CLUSTER_ID_1, VOLUME_ID_1, VOLUME_NAME_1));
    syncJob.refreshSnapshotList();
    Mockito.verify(snapshotDao, times(1)).saveAll(any(List.class));
    Mockito.verify(snapshotDao, times(1)).removeAll(any(List.class));
    Mockito.verify(snapshotDao, times(1)).updateAllInBatch(any(List.class));
}
#end_block

#method_before
private void addOrUpdateSnapshots(Guid clusterId, List<GlusterVolumeSnapshotEntity> fetchedSnapshots) {
    Map<Guid, GlusterVolumeSnapshotEntity> fetchedSnapshotsMap = new HashMap<>();
    for (GlusterVolumeSnapshotEntity fetchedSnapshot : fetchedSnapshots) {
        fetchedSnapshotsMap.put(fetchedSnapshot.getId(), fetchedSnapshot);
    }
    VDSGroup cluster = getClusterDao().get(clusterId);
    List<GlusterVolumeSnapshotEntity> existingSnapshots = getGlusterVolumeSnapshotDao().getAllByClusterId(clusterId);
    Map<Guid, GlusterVolumeSnapshotEntity> existingSnapshotsMap = new HashMap<>();
    for (GlusterVolumeSnapshotEntity existingSnapshot : existingSnapshots) {
        existingSnapshotsMap.put(existingSnapshot.getId(), existingSnapshot);
    }
    List<GlusterVolumeSnapshotEntity> updatedSnapshots = new ArrayList<>();
    List<GlusterVolumeSnapshotEntity> newlyAddedSnapshots = new ArrayList<>();
    List<GlusterVolumeSnapshotEntity> deletedSnapshots = new ArrayList<>();
    for (GlusterVolumeSnapshotEntity fetchedSnapshot : fetchedSnapshots) {
        GlusterVolumeSnapshotEntity correspondingExistingSnapshot = existingSnapshotsMap.get(fetchedSnapshot.getId());
        if (correspondingExistingSnapshot == null) {
            newlyAddedSnapshots.add(fetchedSnapshot);
            log.debug("Detected new gluster volume snapshot '{}' on cluster: '{}'", fetchedSnapshot.getSnapshotName(), cluster.getName());
            logUtil.logAuditMessage(clusterId, null, null, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_DETECTED_NEW, Collections.singletonMap("snapName", fetchedSnapshot.getSnapshotName()));
        } else if (correspondingExistingSnapshot.getStatus() != fetchedSnapshot.getStatus()) {
            correspondingExistingSnapshot.setStatus(fetchedSnapshot.getStatus());
            updatedSnapshots.add(correspondingExistingSnapshot);
        }
    }
    for (GlusterVolumeSnapshotEntity existingSnapshot : existingSnapshots) {
        GlusterVolumeSnapshotEntity correspondingFetchedSnapshot = fetchedSnapshotsMap.get(existingSnapshot.getId());
        if (correspondingFetchedSnapshot == null) {
            deletedSnapshots.add(existingSnapshot);
            log.debug("Gluster volume snapshot '{}' detected removed on cluster: '{}'", existingSnapshot.getSnapshotName(), cluster.getName());
            logUtil.logAuditMessage(clusterId, null, null, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_DELETED_FROM_CLI, Collections.singletonMap("snapName", existingSnapshot.getSnapshotName()));
        }
    }
    // update snapshot details
    try (EngineLock lock = acquireVolumeSnapshotLock(clusterId)) {
        saveNewSnapshots(newlyAddedSnapshots);
        updateSnapshots(updatedSnapshots);
        deleteSnapshots(deletedSnapshots);
    } catch (Exception e) {
        log.error("Exception ocuured while adding/updating snapshots from CLI - '{}'", e.getMessage());
        log.debug("Exception", e);
        throw new VdcBLLException(VdcBllErrors.GlusterSnapshotInfoFailedException, e.getLocalizedMessage());
    }
}
#method_after
private void addOrUpdateSnapshots(Guid clusterId, List<GlusterVolumeSnapshotEntity> fetchedSnapshots) {
    Map<Guid, GlusterVolumeSnapshotEntity> fetchedSnapshotsMap = new HashMap<>();
    for (GlusterVolumeSnapshotEntity fetchedSnapshot : fetchedSnapshots) {
        fetchedSnapshotsMap.put(fetchedSnapshot.getId(), fetchedSnapshot);
    }
    VDSGroup cluster = getClusterDao().get(clusterId);
    List<GlusterVolumeSnapshotEntity> existingSnapshots = getGlusterVolumeSnapshotDao().getAllByClusterId(clusterId);
    Map<Guid, GlusterVolumeSnapshotEntity> existingSnapshotsMap = new HashMap<>();
    for (GlusterVolumeSnapshotEntity existingSnapshot : existingSnapshots) {
        existingSnapshotsMap.put(existingSnapshot.getId(), existingSnapshot);
    }
    List<GlusterVolumeSnapshotEntity> updatedSnapshots = new ArrayList<>();
    List<GlusterVolumeSnapshotEntity> newlyAddedSnapshots = new ArrayList<>();
    List<GlusterVolumeSnapshotEntity> deletedSnapshots = new ArrayList<>();
    for (final GlusterVolumeSnapshotEntity fetchedSnapshot : fetchedSnapshots) {
        GlusterVolumeSnapshotEntity correspondingExistingSnapshot = existingSnapshotsMap.get(fetchedSnapshot.getId());
        if (correspondingExistingSnapshot == null) {
            final GlusterVolumeEntity volume = getGlusterVolumeDao().getById(fetchedSnapshot.getVolumeId());
            newlyAddedSnapshots.add(fetchedSnapshot);
            log.debug("Detected new gluster volume snapshot '{}' for volume '{}' on cluster: '{}'", fetchedSnapshot.getSnapshotName(), volume.getName(), cluster.getName());
            logUtil.logAuditMessage(clusterId, volume, null, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_DETECTED_NEW, new HashMap<String, String>() {

                {
                    put("snapName", fetchedSnapshot.getSnapshotName());
                    put(GlusterConstants.VOLUME_NAME, volume.getName());
                }
            });
        } else if (correspondingExistingSnapshot.getStatus() != fetchedSnapshot.getStatus()) {
            correspondingExistingSnapshot.setStatus(fetchedSnapshot.getStatus());
            updatedSnapshots.add(correspondingExistingSnapshot);
        }
    }
    for (final GlusterVolumeSnapshotEntity existingSnapshot : existingSnapshots) {
        GlusterVolumeSnapshotEntity correspondingFetchedSnapshot = fetchedSnapshotsMap.get(existingSnapshot.getId());
        if (correspondingFetchedSnapshot == null) {
            final GlusterVolumeEntity volume = getGlusterVolumeDao().getById(existingSnapshot.getVolumeId());
            deletedSnapshots.add(existingSnapshot);
            log.debug("Gluster volume snapshot '{}' detected removed for volume '{}' on cluster: '{}'", existingSnapshot.getSnapshotName(), volume.getName(), cluster.getName());
            logUtil.logAuditMessage(clusterId, volume, null, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_DELETED_FROM_CLI, new HashMap<String, String>() {

                {
                    put("snapName", existingSnapshot.getSnapshotName());
                    put(GlusterConstants.VOLUME_NAME, volume.getName());
                }
            });
        }
    }
    // update snapshot details
    try (EngineLock lock = acquireVolumeSnapshotLock(clusterId)) {
        saveNewSnapshots(newlyAddedSnapshots);
        updateSnapshots(updatedSnapshots);
        deleteSnapshots(deletedSnapshots);
    } catch (Exception e) {
        log.error("Exception ocuured while adding/updating snapshots from CLI - '{}'", e.getMessage());
        log.debug("Exception", e);
        throw new VdcBLLException(VdcBllErrors.GlusterSnapshotInfoFailedException, e.getLocalizedMessage());
    }
}
#end_block

#method_before
private void addOrUpdateVolumeConfig(VDSGroup cluster, final GlusterVolumeEntity volume, final String paramName, final String paramValue) {
    GlusterVolumeSnapshotConfig cfg = new GlusterVolumeSnapshotConfig();
    cfg.setClusterId(cluster.getId());
    cfg.setVolumeId(volume.getId());
    cfg.setParamName(paramName);
    cfg.setParamValue(paramValue);
    GlusterVolumeSnapshotConfig existingParamDetail = getGlusterVolumeSnapshotConfigDao().getConfigByVolumeIdAndName(cluster.getId(), volume.getId(), paramName);
    if (existingParamDetail == null) {
        getGlusterVolumeSnapshotConfigDao().save(cfg);
        log.debug("Detected new gluster volume snapshot configuration '{}' with value '{}' for volume: '{}' on cluster '{}'", paramName, paramValue, cluster.getName(), volume.getName());
        logUtil.logAuditMessage(cluster.getId(), null, null, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_VOLUME_CONFIG_DETECTED_NEW, new HashMap<String, String>() {

            {
                put("snapConfigName", paramName);
                put("snapConfigValue", paramValue);
                put(GlusterConstants.VOLUME_NAME, volume.getName());
            }
        });
    } else if (!(existingParamDetail.getParamValue().equals(paramValue))) {
        getGlusterVolumeSnapshotConfigDao().updateConfigByVolumeIdAndName(cluster.getId(), volume.getId(), paramName, paramValue);
    }
}
#method_after
private void addOrUpdateVolumeConfig(VDSGroup cluster, final GlusterVolumeEntity volume, final String paramName, final String paramValue) {
    GlusterVolumeSnapshotConfig cfg = new GlusterVolumeSnapshotConfig();
    cfg.setClusterId(cluster.getId());
    cfg.setVolumeId(volume.getId());
    cfg.setParamName(paramName);
    cfg.setParamValue(paramValue);
    GlusterVolumeSnapshotConfig existingParamDetail = getGlusterVolumeSnapshotConfigDao().getConfigByVolumeIdAndName(cluster.getId(), volume.getId(), paramName);
    if (existingParamDetail == null) {
        getGlusterVolumeSnapshotConfigDao().save(cfg);
        log.debug("Detected new gluster volume snapshot configuration '{}' with value '{}' for volume: '{}' on cluster '{}'", paramName, paramValue, cluster.getName(), volume.getName());
        logUtil.logAuditMessage(cluster.getId(), volume, null, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_VOLUME_CONFIG_DETECTED_NEW, new HashMap<String, String>() {

            {
                put("snapConfigName", paramName);
                put("snapConfigValue", paramValue);
                put(GlusterConstants.VOLUME_NAME, volume.getName());
            }
        });
    } else if (!(existingParamDetail.getParamValue().equals(paramValue))) {
        getGlusterVolumeSnapshotConfigDao().updateConfigByVolumeIdAndName(cluster.getId(), volume.getId(), paramName, paramValue);
    }
}
#end_block

#method_before
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is different from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, managedDevices, VmDeviceCommonUtils.isOldClusterVersion(vm.getVdsGroupCompatibilityVersion()));
        for (VmDevice vmDevice : managedDevices) {
            for (Map struct : devices) {
                String deviceId = (String) struct.get(VdsProperties.DeviceId);
                if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                    if (vmDevice.getBootOrder() > 0) {
                        struct.put(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                    } else {
                        struct.keySet().remove(VdsProperties.BootOrder);
                    }
                    break;
                }
            }
        }
    }
}
#method_after
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is different from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, vm.isRunOnce() ? vm.getBootSequence() : vm.getDefaultBootSequence(), managedDevices, VmDeviceCommonUtils.isOldClusterVersion(vm.getVdsGroupCompatibilityVersion()));
        for (VmDevice vmDevice : managedDevices) {
            for (Map struct : devices) {
                String deviceId = (String) struct.get(VdsProperties.DeviceId);
                if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                    if (vmDevice.getBootOrder() > 0) {
                        struct.put(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                    } else {
                        struct.keySet().remove(VdsProperties.BootOrder);
                    }
                    break;
                }
            }
        }
    }
}
#end_block

#method_before
private void addNumaSetting(final String compatibilityVersion) {
    if (Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinningEnabled, compatibilityVersion))) {
        List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(vm.getId());
        List<VdsNumaNode> totalVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vdsId);
        if (totalVdsNumaNodes.isEmpty()) {
            log.warn("No NUMA nodes found for host {} for vm {} {}", vdsId, vm.getName(), vm.getId());
            return;
        }
        // create a default one with the first numa node of the host
        if (vmNumaNodes.isEmpty()) {
            VmNumaNode vmNode = new VmNumaNode();
            vmNode.setIndex(totalVdsNumaNodes.get(0).getIndex());
            vmNode.setMemTotal(vm.getMemSizeMb());
            vmNode.setCpuIds(totalVdsNumaNodes.get(0).getCpuIds());
            vmNumaNodes.add(vmNode);
        }
        NumaTuneMode numaTune = vm.getNumaTuneMode();
        if (numaTune != null) {
            Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes, totalVdsNumaNodes);
            if (!numaTuneSetting.isEmpty()) {
                createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
            }
        }
        List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
        if (!createVmNumaNodes.isEmpty()) {
            createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
        }
        if (StringUtils.isEmpty(vm.getCpuPinning())) {
            Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
            if (!cpuPinDict.isEmpty()) {
                createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
            }
        }
    }
}
#method_after
private void addNumaSetting(final String compatibilityVersion) {
    if (Boolean.TRUE.equals(Config.<Boolean>getValue(ConfigValues.CpuPinningEnabled, compatibilityVersion))) {
        List<VmNumaNode> vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(vm.getId());
        List<VdsNumaNode> totalVdsNumaNodes = DbFacade.getInstance().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(vdsId);
        if (totalVdsNumaNodes.isEmpty()) {
            log.warn("No NUMA nodes found for host {} for vm {} {}", vdsId, vm.getName(), vm.getId());
            return;
        }
        // create a default one with the first numa node of the host
        if (vmNumaNodes.isEmpty()) {
            if (FeatureSupported.hotPlugMemory(vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
                VmNumaNode vmNode = new VmNumaNode();
                vmNode.setIndex(totalVdsNumaNodes.get(0).getIndex());
                vmNode.setMemTotal(vm.getMemSizeMb());
                vmNode.setCpuIds(totalVdsNumaNodes.get(0).getCpuIds());
                vmNumaNodes.add(vmNode);
            } else {
                // no need to send numa if memory hotplug not supported
                return;
            }
        }
        NumaTuneMode numaTune = vm.getNumaTuneMode();
        if (numaTune != null) {
            Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes, totalVdsNumaNodes);
            if (!numaTuneSetting.isEmpty()) {
                createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
            }
        }
        List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
        if (!createVmNumaNodes.isEmpty()) {
            createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
        }
        if (StringUtils.isEmpty(vm.getCpuPinning())) {
            Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
            if (!cpuPinDict.isEmpty()) {
                createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
            }
        }
    }
}
#end_block

#method_before
public String getDiskImageAlias() {
    if (diskImageAlias == null) {
        diskImageAlias = getGlanceDiskDefaultAlias();
    }
    return diskImageAlias;
}
#method_after
public String getDiskImageAlias() {
    if (diskImageAlias == null) {
        diskImageAlias = RepoImage.getRepoImageAlias(StorageConstants.GLANCE_DISK_ALIAS_PREFIX, getEntity().getRepoImageId());
    }
    return diskImageAlias;
}
#end_block

#method_before
public String getRepoImageTitle() {
    if (repoImageName != null) {
        // of the id (similarly to what git does with hashes).
        return repoImageName + " (" + getShortHash() + ")";
    } else {
        return repoImageId;
    }
}
#method_after
public String getRepoImageTitle() {
    if (repoImageName != null) {
        // of the id (similarly to what git does with hashes).
        return repoImageName + " (" + getShortHash(repoImageId) + ")";
    } else {
        return repoImageId;
    }
}
#end_block

#method_before
public String getShortHash() {
    return repoImageId.substring(0, SHORT_HASH_END_INDEX);
}
#method_after
private static String getShortHash(String repoId) {
    return repoId.substring(0, SHORT_HASH_END_INDEX);
}
#end_block

#method_before
public DiskImage getImageAsDiskImage(String id, String diskAlias) {
    DiskImage diskImage = new DiskImage();
    Image glanceImage = getClient().images().show(id).execute();
    validateContainerFormat(glanceImage);
    diskImage.setDiskAlias(diskAlias);
    String shortHash = glanceImage.getId().substring(0, 7);
    if (glanceImage.getName() != null) {
        diskImage.setDiskDescription(glanceImage.getName() + " (" + shortHash + ")");
    } else {
        diskImage.setDiskDescription("Glance disk: " + shortHash);
    }
    diskImage.setSize(getImageVirtualSize(glanceImage));
    diskImage.setActualSizeInBytes(glanceImage.getSize());
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue())) {
        diskImage.setvolumeFormat(VolumeFormat.RAW);
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        diskImage.setvolumeFormat(VolumeFormat.COW);
    } else {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_DISK_FORMAT, "Unknown disk format: " + glanceImage.getDiskFormat());
    }
    return diskImage;
}
#method_after
public DiskImage getImageAsDiskImage(String id) {
    DiskImage diskImage = new DiskImage();
    Image glanceImage = getClient().images().show(id).execute();
    validateContainerFormat(glanceImage);
    String shortHash = glanceImage.getId().substring(0, 7);
    if (glanceImage.getName() != null) {
        diskImage.setDiskDescription(glanceImage.getName() + " (" + shortHash + ")");
    } else {
        diskImage.setDiskDescription("Glance disk: " + shortHash);
    }
    diskImage.setSize(getImageVirtualSize(glanceImage));
    diskImage.setActualSizeInBytes(glanceImage.getSize());
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue())) {
        diskImage.setvolumeFormat(VolumeFormat.RAW);
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        diskImage.setvolumeFormat(VolumeFormat.COW);
    } else {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_DISK_FORMAT, "Unknown disk format: " + glanceImage.getDiskFormat());
    }
    return diskImage;
}
#end_block

#method_before
protected DiskImage getDiskImage() {
    if (getParameters().getDiskImage() == null) {
        DiskImage diskImage = getProviderProxy().getImageAsDiskImage(getParameters().getSourceRepoImageId(), getParameters().getDiskAlias());
        if (diskImage != null) {
            if (diskImage.getVolumeFormat() == VolumeFormat.RAW && getStorageDomain().getStorageType().isBlockDomain()) {
                diskImage.setVolumeType(VolumeType.Preallocated);
            } else {
                diskImage.setVolumeType(VolumeType.Sparse);
            }
            if (getParameters().getDiskAlias() != null) {
                diskImage.setDiskAlias(getParameters().getDiskAlias());
            }
        }
        getParameters().setDiskImage(diskImage);
    }
    return getParameters().getDiskImage();
}
#method_after
protected DiskImage getDiskImage() {
    if (getParameters().getDiskImage() == null) {
        DiskImage diskImage = getProviderProxy().getImageAsDiskImage(getParameters().getSourceRepoImageId());
        if (diskImage != null) {
            if (diskImage.getVolumeFormat() == VolumeFormat.RAW && getStorageDomain().getStorageType().isBlockDomain()) {
                diskImage.setVolumeType(VolumeType.Preallocated);
            } else {
                diskImage.setVolumeType(VolumeType.Sparse);
            }
            if (getParameters().getDiskAlias() == null) {
                diskImage.setDiskAlias(RepoImage.getRepoImageAlias(StorageConstants.GLANCE_DISK_ALIAS_PREFIX, getParameters().getSourceRepoImageId()));
            } else {
                diskImage.setDiskAlias(getParameters().getDiskAlias());
            }
        }
        getParameters().setDiskImage(diskImage);
    }
    return getParameters().getDiskImage();
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    RemoveDiskParameters parameters = new RemoveDiskParameters();
    parameters.setDiskId(guid);
    return performAction(VdcActionType.RemoveDisk, parameters);
}
#method_after
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveDisk, new RemoveDiskParameters(guid));
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    RemoveDiskParameters parameters = new RemoveDiskParameters();
    parameters.setDiskId(guid);
    parameters.setStorageDomainId(asGuid(storageDomainId));
    return performAction(VdcActionType.RemoveDisk, parameters);
}
#method_after
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveDisk, new RemoveDiskParameters(guid, asGuid(storageDomainId)));
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(LibvirtSecret entity) {
    return createIdParameterMapper(entity.getId()).addValue("secret_value", DbFacadeUtils.encryptPassword(entity.getValue())).addValue("secret_usage_type", entity.getUsageType()).addValue("secret_description", entity.getDescription()).addValue("provider_id", entity.getProviderId()).addValue("creation_date", entity.getCreationDate());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(LibvirtSecret entity) {
    return createIdParameterMapper(entity.getId()).addValue("secret_value", DbFacadeUtils.encryptPassword(entity.getValue())).addValue("secret_usage_type", entity.getUsageType()).addValue("secret_description", entity.getDescription()).addValue("provider_id", entity.getProviderId()).addValue("_create_date", entity.getCreationDate());
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createIdParameterMapper(Guid uuid) {
    return getCustomMapSqlParameterSource().addValue("secret_uuid", uuid);
}
#method_after
@Override
protected MapSqlParameterSource createIdParameterMapper(Guid uuid) {
    return getCustomMapSqlParameterSource().addValue("secret_id", uuid);
}
#end_block

#method_before
@Override
public LibvirtSecret mapRow(ResultSet rs, int rowNum) throws SQLException {
    LibvirtSecret entity = new LibvirtSecret();
    entity.setId(getGuid(rs, "secret_uuid"));
    entity.setValue(DbFacadeUtils.decryptPassword(rs.getString("secret_value")));
    entity.setUsageType(LibvirtSecretUsageType.forValue(rs.getInt(("secret_usage_type"))));
    entity.setDescription(rs.getString("secret_description"));
    entity.setProviderId(getGuid(rs, "provider_id"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    return entity;
}
#method_after
@Override
public LibvirtSecret mapRow(ResultSet rs, int rowNum) throws SQLException {
    LibvirtSecret entity = new LibvirtSecret();
    entity.setId(getGuid(rs, "secret_id"));
    entity.setValue(DbFacadeUtils.decryptPassword(rs.getString("secret_value")));
    entity.setUsageType(LibvirtSecretUsageType.forValue(rs.getInt(("secret_usage_type"))));
    entity.setDescription(rs.getString("secret_description"));
    entity.setProviderId(getGuid(rs, "provider_id"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("_create_date")));
    return entity;
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.network.VnicProfile getVnicProfile(String id) {
    return getEntity(org.ovirt.engine.core.common.businessentities.network.VnicProfile.class, VdcQueryType.GetVnicProfileById, new IdQueryParameters(asGuidOr404(id)), "VnicProfiles");
}
#method_after
protected org.ovirt.engine.core.common.businessentities.network.VnicProfile getVnicProfile(String id) {
    return getEntity(org.ovirt.engine.core.common.businessentities.network.VnicProfile.class, VdcQueryType.GetVnicProfileById, new IdQueryParameters(guid), "VnicProfiles");
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setVersion(getVersion());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    vds.setVdsGroupCompatibilityVersion(getVdsGroupCompatibilityVersion());
    vds.setUpdateAvailable(isUpdateAvailable());
    vds.setHostDevicePassthroughEnabled(isHostDevicePassthroughEnabled());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setExternalStatus(getExternalStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setVersion(getVersion());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    vds.setVdsGroupCompatibilityVersion(getVdsGroupCompatibilityVersion());
    vds.setUpdateAvailable(isUpdateAvailable());
    vds.setHostDevicePassthroughEnabled(isHostDevicePassthroughEnabled());
    return vds;
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setOnlineCpus(rs.getString("online_cpus"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setIncomingMigrations(rs.getInt("incoming_migrations"));
    entity.setOutgoingMigrations(rs.getInt("outgoing_migrations"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(rs.getString("pm_proxy_preferences")));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeSchedulingMemoryCache();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    entity.setBalloonEnabled(rs.getBoolean("enable_balloon"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    entity.setMaintenanceReason(rs.getString("maintenance_reason"));
    Guid agentGuid = getGuid(rs, "agent_id");
    if (agentGuid != null) {
        FenceAgent agent = new FenceAgent();
        agent.setId(agentGuid);
        agent.setHostId(getGuid(rs, "vds_id"));
        agent.setOrder(rs.getInt("agent_order"));
        agent.setType(rs.getString("agent_type"));
        agent.setUser(rs.getString("agent_user"));
        agent.setPassword(DbFacadeUtils.decryptPassword(rs.getString("agent_password")));
        int port = rs.getInt("agent_port");
        agent.setPort(port == 0 ? null : port);
        agent.setEncryptOptions(rs.getBoolean("agent_encrypt_options"));
        if (agent.getEncryptOptions()) {
            agent.setOptions(DbFacadeUtils.decryptPassword(rs.getString("agent_options")));
        } else {
            agent.setOptions(rs.getString("agent_options"));
        }
        agent.setIp(rs.getString("agent_ip"));
        entity.getFenceAgents().add(agent);
    }
    entity.setUpdateAvailable(rs.getBoolean("is_update_available"));
    entity.setHostDevicePassthroughEnabled(rs.getBoolean("is_hostdev_enabled"));
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setExternalStatus(ExternalStatus.forValue(rs.getInt("external_status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setOnlineCpus(rs.getString("online_cpus"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setIncomingMigrations(rs.getInt("incoming_migrations"));
    entity.setOutgoingMigrations(rs.getInt("outgoing_migrations"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(rs.getString("pm_proxy_preferences")));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeSchedulingMemoryCache();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    entity.setBalloonEnabled(rs.getBoolean("enable_balloon"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    entity.setMaintenanceReason(rs.getString("maintenance_reason"));
    Guid agentGuid = getGuid(rs, "agent_id");
    if (agentGuid != null) {
        FenceAgent agent = new FenceAgent();
        agent.setId(agentGuid);
        agent.setHostId(getGuid(rs, "vds_id"));
        agent.setOrder(rs.getInt("agent_order"));
        agent.setType(rs.getString("agent_type"));
        agent.setUser(rs.getString("agent_user"));
        agent.setPassword(DbFacadeUtils.decryptPassword(rs.getString("agent_password")));
        int port = rs.getInt("agent_port");
        agent.setPort(port == 0 ? null : port);
        agent.setEncryptOptions(rs.getBoolean("agent_encrypt_options"));
        if (agent.getEncryptOptions()) {
            agent.setOptions(DbFacadeUtils.decryptPassword(rs.getString("agent_options")));
        } else {
            agent.setOptions(rs.getString("agent_options"));
        }
        agent.setIp(rs.getString("agent_ip"));
        entity.getFenceAgents().add(agent);
    }
    entity.setUpdateAvailable(rs.getBoolean("is_update_available"));
    entity.setHostDevicePassthroughEnabled(rs.getBoolean("is_hostdev_enabled"));
    return entity;
}
#end_block

#method_before
@Override
public VdsDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsDynamic entity = new VdsDynamic();
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setOnlineCpus(rs.getString("online_cpus"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount(rs.getInt("vm_count"));
    entity.setVmsCoresCount(rs.getInt("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setIncomingMigrations(rs.getInt("incoming_migrations"));
    entity.setOutgoingMigrations(rs.getInt("outgoing_migrations"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead(rs.getInt("guest_overhead"));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setBuildName(rs.getString("build_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.setMaintenanceReason(rs.getString("maintenance_reason"));
    entity.setUpdateAvailable(rs.getBoolean("is_update_available"));
    entity.setHostDevicePassthroughEnabled(rs.getBoolean("is_hostdev_enabled"));
    return entity;
}
#method_after
@Override
public VdsDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsDynamic entity = new VdsDynamic();
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setOnlineCpus(rs.getString("online_cpus"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount(rs.getInt("vm_count"));
    entity.setVmsCoresCount(rs.getInt("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setIncomingMigrations(rs.getInt("incoming_migrations"));
    entity.setOutgoingMigrations(rs.getInt("outgoing_migrations"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead(rs.getInt("guest_overhead"));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setBuildName(rs.getString("build_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.setMaintenanceReason(rs.getString("maintenance_reason"));
    entity.setUpdateAvailable(rs.getBoolean("is_update_available"));
    entity.setExternalStatus(ExternalStatus.forValue(rs.getInt("external_status")));
    entity.setHostDevicePassthroughEnabled(rs.getBoolean("is_hostdev_enabled"));
    return entity;
}
#end_block

#method_before
@Override
public Job getJobWithSteps(final Guid jobId) {
    Job job = jobDao.get(jobId);
    if (job != null) {
        Map<Guid, VdcObjectType> jobSubjectEntity = jobSubjectEntityDao.getJobSubjectEntityByJobId(jobId);
        job.setJobSubjectEntities(jobSubjectEntity);
        loadJobSteps(job);
    }
    return job;
}
#method_after
@Override
public Job getJobWithSteps(final Guid jobId) {
    Job job = jobDao.get(jobId);
    if (job != null) {
        Map<Guid, VdcObjectType> jobSubjectEntity = jobSubjectEntityDao.getJobSubjectEntityByJobId(jobId);
        job.setJobSubjectEntities(jobSubjectEntity);
    }
    return job;
}
#end_block

#method_before
@Test
public void canDoActionVmIsNotDown() throws Exception {
    initializeCommand(ImageOperation.Move);
    initVmDiskImage(false);
    mockGetVmsListForDisk();
    initSrcStorageDomain();
    initDestStorageDomain(StorageType.NFS);
    doReturn(vmDeviceDao).when(command).getVmDeviceDAO();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString()));
}
#method_after
@Test
public void canDoActionVmIsNotDown() throws Exception {
    initializeCommand(ImageOperation.Move);
    initSnapshotValidator();
    initVmDiskImage(false);
    mockGetVmsListForDisk();
    initSrcStorageDomain();
    initDestStorageDomain(StorageType.NFS);
    doReturn(vmDeviceDao).when(command).getVmDeviceDAO();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString()));
}
#end_block

#method_before
@Test
public void canDoActionEnoughSpace() throws Exception {
    initializeCommand(ImageOperation.Move);
    initVmForSpace();
    initVmDiskImage(false);
    initSrcStorageDomain();
    initDestStorageDomain(StorageType.NFS);
    doReturn(mockStorageDomainValidatorWithSpace()).when(command).createStorageDomainValidator();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void canDoActionEnoughSpace() throws Exception {
    initializeCommand(ImageOperation.Move);
    initSnapshotValidator();
    initVmForSpace();
    initVmDiskImage(false);
    initSrcStorageDomain();
    initDestStorageDomain(StorageType.NFS);
    doReturn(mockStorageDomainValidatorWithSpace()).when(command).createStorageDomainValidator();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
protected void initVmForSpace() {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    // Re-mock the vmDao to return this specific VM for it to be correlated with the vm list mocked by getVmsWithPlugInfo(..).
    doReturn(vmDao).when(command).getVmDAO();
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
    VmDevice device = new VmDevice();
    List<Pair<VM, VmDevice>> vmList = Collections.singletonList(new Pair<>(vm, device));
    when(vmDao.getVmsWithPlugInfo(any(Guid.class))).thenReturn(vmList);
}
#method_after
protected void initVmForSpace() {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    // Re-mock the vmDao to return this specific VM for it to be correlated with the vm list mocked by getVmsWithPlugInfo(..).
    doReturn(vmDao).when(command).getVmDAO();
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
    List<Pair<VM, VmDevice>> vmList = Collections.singletonList(new Pair<>(vm, vmDevice));
    when(vmDao.getVmsWithPlugInfo(any(Guid.class))).thenReturn(vmList);
}
#end_block

#method_before
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        protected DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(true).when(command).setAndValidateDiskProfiles();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    StorageDomainValidator sdValidator = new StorageDomainValidator(sd);
    doReturn(sdValidator).when(command).getStorageDomainValidator(any(DiskImage.class));
}
#method_after
protected void initializeCommand(UpdateVmDiskParameters params, List<VM> vms) {
    // Done before creating the spy to have correct values during the ctor run
    mockCtorRelatedDaoCalls(vms);
    command = spy(new UpdateVmDiskCommand<UpdateVmDiskParameters>(params) {

        // Overridden here and not during spying, since it's called in the constructor
        @SuppressWarnings("synthetic-access")
        @Override
        public DiskDao getDiskDao() {
            return diskDao;
        }

        @Override
        public VmDAO getVmDAO() {
            return vmDAO;
        }
    });
    doReturn(true).when(command).acquireLockInternal();
    doReturn(snapshotDao).when(command).getSnapshotDao();
    doReturn(diskImageDao).when(command).getDiskImageDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDAO();
    doReturn(storageDomainDao).when(command).getStorageDomainDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(baseDiskDao).when(command).getBaseDiskDao();
    doReturn(imageDao).when(command).getImageDao();
    doReturn(vmDeviceDAO).when(command).getVmDeviceDao();
    doReturn(vmDAO).when(command).getVmDAO();
    doReturn(diskDao).when(command).getDiskDao();
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doNothing().when(vmStaticDAO).incrementDbGeneration(any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(true).when(command).setAndValidateDiskProfiles();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vms);
    mockToUpdateDiskVm(vms);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    StorageDomainValidator sdValidator = new StorageDomainValidator(sd);
    doReturn(sdValidator).when(command).getStorageDomainValidator(any(DiskImage.class));
}
#end_block

#method_before
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setBootMenuEnabled(getBootMenuEnabled().getEntity());
    params.setRunAndPause(getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless(getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties(getCustomPropertySheet().serialize());
    // kernel params
    String selectedKernelImage = getKernelImage().getSelectedItem();
    if (selectedKernelImage != null) {
        params.setKernelUrl(selectedKernelImage);
    }
    if (getKernelParameters().getEntity() != null) {
        params.setKernelParams(getKernelParameters().getEntity());
    }
    String selectedInitrdImage = getInitrdImage().getSelectedItem();
    if (selectedInitrdImage != null) {
        params.setInitrdUrl(selectedInitrdImage);
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName(getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword(getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && getIsCloudInitEnabled().getEntity() || getIsSysprepEnabled() != null && getIsSysprepEnabled().getEntity()) {
        params.setVmInit(getVmInitModel().buildCloudInitParameters(this));
    }
    params.getRunOnceGraphics().add(Boolean.TRUE.equals(getDisplayConsole_Vnc_IsSelected().getEntity()) ? GraphicsType.VNC : GraphicsType.SPICE);
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    String selectedEmulatedMachine = getEmulatedMachine().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(selectedEmulatedMachine)) {
        params.setCustomEmulatedMachine(selectedEmulatedMachine);
    }
    String selectedCustomCpu = getCustomCpu().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(selectedCustomCpu)) {
        params.setCustomCpuName(selectedCustomCpu);
    }
    params.setSpiceFileTransferEnabled(getSpiceFileTransferEnabled().getEntity());
    params.setSpiceCopyPasteEnabled(getSpiceCopyPasteEnabled().getEntity());
    return params;
}
#method_after
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setBootMenuEnabled(getBootMenuEnabled().getEntity());
    params.setRunAndPause(getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless(getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties(getCustomPropertySheet().serialize());
    // kernel params
    String selectedKernelImage = getKernelImage().getSelectedItem();
    if (!StringUtils.isEmpty(selectedKernelImage)) {
        params.setKernelUrl(selectedKernelImage);
    }
    if (getKernelParameters().getEntity() != null) {
        params.setKernelParams(getKernelParameters().getEntity());
    }
    String selectedInitrdImage = getInitrdImage().getSelectedItem();
    if (!StringUtils.isEmpty(selectedInitrdImage)) {
        params.setInitrdUrl(selectedInitrdImage);
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName(getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword(getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && getIsCloudInitEnabled().getEntity() || getIsSysprepEnabled() != null && getIsSysprepEnabled().getEntity()) {
        params.setVmInit(getVmInitModel().buildCloudInitParameters(this));
    }
    params.getRunOnceGraphics().add(Boolean.TRUE.equals(getDisplayConsole_Vnc_IsSelected().getEntity()) ? GraphicsType.VNC : GraphicsType.SPICE);
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    String selectedEmulatedMachine = getEmulatedMachine().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(selectedEmulatedMachine)) {
        params.setCustomEmulatedMachine(selectedEmulatedMachine);
    }
    String selectedCustomCpu = getCustomCpu().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(selectedCustomCpu)) {
        params.setCustomCpuName(selectedCustomCpu);
    }
    params.setSpiceFileTransferEnabled(getSpiceFileTransferEnabled().getEntity());
    params.setSpiceCopyPasteEnabled(getSpiceCopyPasteEnabled().getEntity());
    return params;
}
#end_block

#method_before
private void updateActionAvailability(GlusterVolumeEntity volumeEntity) {
    boolean allowNewGeoRepSessionCommand = true;
    boolean allowStartSessionCommand = false;
    boolean allowStopSessionCommand = false;
    boolean allowResumeSessionCommand = false;
    boolean allowPauseSessionCommand = false;
    boolean allowSessionOptionsCommand = false;
    boolean allowRemoveSessionCommand = false;
    boolean allowSessionDetailsCommand = false;
    if (volumeEntity == null) {
        return;
    }
    if (getSelectedItems() != null && getSelectedItems().size() == 1) {
        GlusterGeoRepSession selectedSession = getSelectedItem();
        GeoRepSessionStatus sessionStatus = selectedSession.getStatus();
        allowStartSessionCommand = sessionStatus == GeoRepSessionStatus.NOTSTARTED || sessionStatus == GeoRepSessionStatus.STOPPED;
        allowStopSessionCommand = !allowStartSessionCommand;
        allowResumeSessionCommand = sessionStatus == GeoRepSessionStatus.PAUSED;
        allowPauseSessionCommand = sessionStatus == GeoRepSessionStatus.ACTIVE || sessionStatus == GeoRepSessionStatus.INITIALIZING;
        allowSessionOptionsCommand = true;
        allowNewGeoRepSessionCommand = volumeEntity.getStatus() == GlusterStatus.UP;
        allowRemoveSessionCommand = true;
        allowSessionDetailsCommand = true;
    }
    getNewSessionCommand().setIsExecutionAllowed(allowNewGeoRepSessionCommand);
    getRemoveSessionCommand().setIsExecutionAllowed(allowRemoveSessionCommand);
    getStartSessionCommand().setIsExecutionAllowed(allowStartSessionCommand);
    getStopSessionCommand().setIsExecutionAllowed(allowStopSessionCommand);
    getPauseSessionCommand().setIsExecutionAllowed(allowPauseSessionCommand);
    getResumeSessionCommand().setIsExecutionAllowed(allowResumeSessionCommand);
    getSessionOptionsCommand().setIsExecutionAllowed(allowSessionOptionsCommand);
    getViewSessionDetailsCommand().setIsExecutionAllowed(allowSessionDetailsCommand);
    getRefreshSessionsCommand().setIsAvailable(true);
}
#method_after
private void updateActionAvailability(GlusterVolumeEntity volumeEntity) {
    boolean allowNewGeoRepSessionCommand = true;
    boolean allowStartSessionCommand = false;
    boolean allowStopSessionCommand = false;
    boolean allowResumeSessionCommand = false;
    boolean allowPauseSessionCommand = false;
    boolean allowSessionOptionsCommand = false;
    boolean allowRemoveSessionCommand = false;
    boolean allowSessionDetailsCommand = false;
    if (volumeEntity == null) {
        return;
    }
    if (getSelectedItems() != null && getSelectedItems().size() == 1) {
        GlusterGeoRepSession selectedSession = getSelectedItem();
        GeoRepSessionStatus sessionStatus = selectedSession.getStatus();
        allowStartSessionCommand = sessionStatus == GeoRepSessionStatus.CREATED || sessionStatus == GeoRepSessionStatus.STOPPED;
        allowStopSessionCommand = !allowStartSessionCommand;
        allowResumeSessionCommand = sessionStatus == GeoRepSessionStatus.PAUSED;
        allowPauseSessionCommand = sessionStatus == GeoRepSessionStatus.ACTIVE || sessionStatus == GeoRepSessionStatus.INITIALIZING;
        allowSessionOptionsCommand = true;
        allowNewGeoRepSessionCommand = volumeEntity.getStatus() == GlusterStatus.UP;
        allowRemoveSessionCommand = true;
        allowSessionDetailsCommand = true;
    }
    getNewSessionCommand().setIsExecutionAllowed(allowNewGeoRepSessionCommand);
    getRemoveSessionCommand().setIsExecutionAllowed(allowRemoveSessionCommand);
    getStartSessionCommand().setIsExecutionAllowed(allowStartSessionCommand);
    getStopSessionCommand().setIsExecutionAllowed(allowStopSessionCommand);
    getPauseSessionCommand().setIsExecutionAllowed(allowPauseSessionCommand);
    getResumeSessionCommand().setIsExecutionAllowed(allowResumeSessionCommand);
    getSessionOptionsCommand().setIsExecutionAllowed(allowSessionOptionsCommand);
    getViewSessionDetailsCommand().setIsExecutionAllowed(allowSessionDetailsCommand);
    getRefreshSessionsCommand().setIsAvailable(true);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewSessionCommand())) {
        createGeoRepSession();
    } else if (command.equals(getRemoveSessionCommand())) {
        removeGeoRepSession();
    } else if (command.equals(getStartSessionCommand())) {
        startGeoRepSession();
    } else if (command.equals(getStopSessionCommand())) {
        stopGeoRepSession();
    } else if (command.equals(getPauseSessionCommand())) {
        pauseGeoRepSession();
    } else if (command.equals(getResumeSessionCommand())) {
        resumeGeoRepSession();
    } else if (command.equals(getSessionOptionsCommand())) {
        showSessionOptions();
    } else if (command.equals(getViewSessionDetailsCommand())) {
        showGeoRepStatusDetails();
    } else if (command.equals(getRefreshSessionsCommand())) {
        refreshSessions();
    } else if (command.getName().equalsIgnoreCase("onCreateSession")) {
        // $NON-NLS-1$
        onCreateSession();
    } else if (command.getName().equalsIgnoreCase("onStartGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StartGlusterVolumeGeoRep);
    } else if (command.getName().equalsIgnoreCase("onStopGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StopGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onPauseGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.PauseGlusterVolumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onResumeGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.ResumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onRemoveGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.DeleteGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("ok")) {
        // $NON-NLS-1$
        updateConfig();
    } else if (command.getName().equalsIgnoreCase("closeWindow")) {
        // $NON-NLS-1$
        closeWindow();
    } else if (command.getName().equalsIgnoreCase("closeConfirmWindow")) {
        // $NON-NLS-1$
        closeConfirmWindow();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewSessionCommand())) {
        createGeoRepSession();
    } else if (command.equals(getRemoveSessionCommand())) {
        removeGeoRepSession();
    } else if (command.equals(getStartSessionCommand())) {
        startGeoRepSession();
    } else if (command.equals(getStopSessionCommand())) {
        stopGeoRepSession();
    } else if (command.equals(getPauseSessionCommand())) {
        pauseGeoRepSession();
    } else if (command.equals(getResumeSessionCommand())) {
        resumeGeoRepSession();
    } else if (command.equals(getSessionOptionsCommand())) {
        showSessionOptions();
    } else if (command.equals(getViewSessionDetailsCommand())) {
        showGeoRepSessionDetails((GlusterGeoRepSession) getSelectedItem());
    } else if (command.equals(getRefreshSessionsCommand())) {
        refreshSessions();
    } else if (command.getName().equalsIgnoreCase("onCreateSession")) {
        // $NON-NLS-1$
        onCreateSession();
    } else if (command.getName().equalsIgnoreCase("onStartGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StartGlusterVolumeGeoRep);
    } else if (command.getName().equalsIgnoreCase("onStopGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StopGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onPauseGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.PauseGlusterVolumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onResumeGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.ResumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onRemoveGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.DeleteGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("ok")) {
        // $NON-NLS-1$
        updateConfig();
    } else if (command.getName().equalsIgnoreCase("closeWindow")) {
        // $NON-NLS-1$
        closeWindow();
    } else if (command.getName().equalsIgnoreCase("closeConfirmWindow")) {
        // $NON-NLS-1$
        closeConfirmWindow();
    }
}
#end_block

#method_before
private void populateStatus(final List<GlusterGeoRepSessionDetails> details) {
    if (getConfirmWindow() != null) {
        closeConfirmWindow();
    }
    if (getWindow() != null) {
        closeWindow();
    }
    final VolumeGeoRepSessionDetailsModel windowModel = new VolumeGeoRepSessionDetailsModel();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    windowModel.setTitle(constants.geoReplicationSessionDetailsTitle());
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("closeWindow", this);
    okCommand.setIsCancel(true);
    okCommand.setTitle(constants.ok());
    windowModel.getCommands().add(okCommand);
    final List<EntityModel<GeoRepSessionDetailsSummaryTableRow>> detailRows = new ArrayList<>();
    for (final GlusterGeoRepSessionDetails detail : details) {
        AsyncDataProvider.getInstance().getGlusterVolumeBrickById(new AsyncQuery(new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                GlusterBrickEntity brick = (GlusterBrickEntity) returnValue;
                if (brick == null) {
                    brick = new GlusterBrickEntity();
                    brick.setServerName(constants.notAvailableLabel());
                }
                detailRows.add(new EntityModel<VolumeGeoRepSessionDetailsModel.GeoRepSessionDetailsSummaryTableRow>(new GeoRepSessionDetailsSummaryTableRow(brick.getServerName(), detail)));
                if (detailRows.size() == details.size()) {
                    windowModel.getGeoRepSessionSummary().setItems(detailRows, detailRows.get(0));
                    setWindow(windowModel);
                }
            }
        }), detail.getMasterBrickId());
    }
}
#method_after
private void populateStatus(final List<GlusterGeoRepSessionDetails> details) {
    final VolumeGeoRepSessionDetailsModel windowModel = new VolumeGeoRepSessionDetailsModel();
    windowModel.setHelpTag(HelpTag.geo_replication_status_detail);
    // $NON-NLS-1$
    windowModel.setHashName("geo_replication_status_detail");
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    windowModel.setTitle(constants.geoReplicationSessionDetailsTitle());
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("closeWindow", this);
    okCommand.setIsCancel(true);
    okCommand.setTitle(constants.ok());
    windowModel.getCommands().add(okCommand);
    setWindow(windowModel);
    final List<EntityModel<GlusterGeoRepSessionDetails>> detailRows = new ArrayList<>();
    for (GlusterGeoRepSessionDetails detail : details) {
        detailRows.add(new EntityModel<GlusterGeoRepSessionDetails>(detail));
    }
    windowModel.getGeoRepSessionSummary().setItems(detailRows, detailRows.get(0));
}
#end_block

#method_before
public void showGeoRepSessionDetails(Guid sessionId, Guid volumeId, Guid clusterId) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ConfirmationModel cModel = new ConfirmationModel();
    cModel.setTitle(constants.geoReplicationSessionDetailsTitle());
    cModel.startProgress(constants.fetchingDataMessage());
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("closeConfirmWindow", this);
    okCommand.setTitle(constants.ok());
    okCommand.setIsCancel(true);
    cModel.getCommands().add(okCommand);
    setConfirmWindow(cModel);
    AsyncQuery aQuery = new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<GlusterGeoRepSessionDetails> details = (ArrayList<GlusterGeoRepSessionDetails>) returnValue;
            if (details.size() == 0) {
                cModel.setMessage(constants.geoRepSessionStatusDetailFetchFailed());
                return;
            } else {
                closeConfirmWindow();
                populateStatus(details);
            }
        }
    });
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<GlusterGeoRepSessionDetails>();
            }
            ArrayList<GlusterGeoRepSessionDetails> details = ((GlusterGeoRepSession) returnValue).getSessionDetails();
            return details;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeGeoRepSessionById, new IdQueryParameters(sessionId), aQuery);
}
#method_after
public void showGeoRepSessionDetails(GlusterGeoRepSession session) {
    ArrayList<GlusterGeoRepSessionDetails> details = session.getSessionDetails();
    if (getWindow() != null) {
        return;
    }
    if (details == null || details.size() == 0) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        final ConfirmationModel cModel = new ConfirmationModel();
        cModel.setTitle(constants.geoReplicationSessionDetailsTitle());
        // $NON-NLS-1$
        UICommand okCommand = new UICommand("closeConfirmWindow", this);
        okCommand.setTitle(constants.ok());
        okCommand.setIsCancel(true);
        cModel.getCommands().add(okCommand);
        setConfirmWindow(cModel);
        cModel.setMessage(constants.geoRepSessionStatusDetailFetchFailed());
    } else {
        populateStatus(details);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Console Public Key
    bindPresenterWidget(PublicKeyPopupPresenterWidget.class, PublicKeyPopupPresenterWidget.ViewDef.class, PublicKeyPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#end_block

#method_before
private void intiEditors(final ApplicationConstants constants) {
    crawlStatus = new EntityModelLabelEditor<GeoRepCrawlStatus>(new AbstractRenderer<GeoRepCrawlStatus>() {

        @Override
        public String render(GeoRepCrawlStatus object) {
            return object.toString();
        }
    }, new Parser<GeoRepCrawlStatus>() {

        @Override
        public GeoRepCrawlStatus parse(CharSequence text) throws ParseException {
            return null;
        }
    });
    dataOpsPending = getLongEntityModelLabelEditor();
    metaOpsPending = getLongEntityModelLabelEditor();
    entryOpsPending = getLongEntityModelLabelEditor();
    failures = getLongEntityModelLabelEditor();
    checkPointTime = new EntityModelLabelEditor<GlusterGeoRepSessionDetails>(new AbstractRenderer<GlusterGeoRepSessionDetails>() {

        @Override
        public String render(GlusterGeoRepSessionDetails object) {
            return new FullDateTimeRenderer().render(object.getCheckPointTime());
        }
    });
    checkPointCompletedAt = new EntityModelLabelEditor<GlusterGeoRepSessionDetails>(new AbstractRenderer<GlusterGeoRepSessionDetails>() {

        @Override
        public String render(GlusterGeoRepSessionDetails object) {
            return new FullDateTimeRenderer().render(object.getCheckPointCompletedAt());
        }
    });
    geoRepSessionSummaryTable = new EntityModelCellTable<ListModel<EntityModel<GeoRepSessionDetailsSummaryTableRow>>>(false, true);
    geoRepSessionSummaryTable.addColumn(new AbstractEntityModelTextColumn<GeoRepSessionDetailsSummaryTableRow>() {

        @Override
        public String getText(GeoRepSessionDetailsSummaryTableRow object) {
            return object.getMasterHostName() == null ? constants.notAvailableLabel() : object.getMasterHostName();
        }
    }, constants.geoRepSessionHostName());
    geoRepSessionSummaryTable.addColumn(new AbstractEntityModelTextColumn<GeoRepSessionDetailsSummaryTableRow>() {

        @Override
        protected String getText(GeoRepSessionDetailsSummaryTableRow entity) {
            GlusterGeoRepSessionDetails sessionDetail = entity.getSessionDetail();
            return (sessionDetail == null || sessionDetail.getStatus() == null) ? constants.notAvailableLabel() : sessionDetail.getStatus().toString();
        }
    }, constants.geoRepSessionStatus());
    geoRepSessionSummaryTable.addColumn(new AbstractFullDateTimeColumn<EntityModel<GeoRepSessionDetailsSummaryTableRow>>() {

        @Override
        protected Date getRawValue(EntityModel<GeoRepSessionDetailsSummaryTableRow> object) {
            GlusterGeoRepSessionDetails sessionDetail = object.getEntity().getSessionDetail();
            return (sessionDetail == null || sessionDetail.getLastSyncedAt() == null) ? new Date() : sessionDetail.getLastSyncedAt();
        }
    }, constants.geoRepLastSyncedAt());
}
#method_after
private void intiEditors(final ApplicationConstants constants) {
    checkPointStatus = new EntityModelLabelEditor<GlusterGeoRepSessionDetails>(new AbstractRenderer<GlusterGeoRepSessionDetails>() {

        @Override
        public String render(GlusterGeoRepSessionDetails object) {
            return object.getCheckPointStatus();
        }
    });
    crawlStatus = new EntityModelLabelEditor<GlusterGeoRepSessionDetails>(new AbstractRenderer<GlusterGeoRepSessionDetails>() {

        @Override
        public String render(GlusterGeoRepSessionDetails object) {
            return object.getCrawlStatus().toString();
        }
    });
    dataOpsPending = new EntityModelLabelEditor<GlusterGeoRepSessionDetails>(new AbstractRenderer<GlusterGeoRepSessionDetails>() {

        @Override
        public String render(GlusterGeoRepSessionDetails object) {
            return object.getDataOpsPending().toString();
        }
    });
    metaOpsPending = new EntityModelLabelEditor<GlusterGeoRepSessionDetails>(new AbstractRenderer<GlusterGeoRepSessionDetails>() {

        @Override
        public String render(GlusterGeoRepSessionDetails object) {
            return object.getMetaOpsPending().toString();
        }
    });
    entryOpsPending = new EntityModelLabelEditor<GlusterGeoRepSessionDetails>(new AbstractRenderer<GlusterGeoRepSessionDetails>() {

        @Override
        public String render(GlusterGeoRepSessionDetails object) {
            return object.getEntryOpsPending().toString();
        }
    });
    failures = new EntityModelLabelEditor<GlusterGeoRepSessionDetails>(new AbstractRenderer<GlusterGeoRepSessionDetails>() {

        @Override
        public String render(GlusterGeoRepSessionDetails object) {
            return object.getFailures().toString();
        }
    });
    checkPointTime = new EntityModelLabelEditor<GlusterGeoRepSessionDetails>(new AbstractRenderer<GlusterGeoRepSessionDetails>() {

        @Override
        public String render(GlusterGeoRepSessionDetails object) {
            return new FullDateTimeRenderer().render(object.getCheckPointTime());
        }
    });
    checkPointCompletedAt = new EntityModelLabelEditor<GlusterGeoRepSessionDetails>(new AbstractRenderer<GlusterGeoRepSessionDetails>() {

        @Override
        public String render(GlusterGeoRepSessionDetails object) {
            return new FullDateTimeRenderer().render(object.getCheckPointCompletedAt());
        }
    });
    geoRepSessionSummaryTable = new EntityModelCellTable<ListModel<EntityModel<GlusterGeoRepSessionDetails>>>(false, true);
    geoRepSessionSummaryTable.addColumn(new AbstractEntityModelTextColumn<GlusterGeoRepSessionDetails>() {

        @Override
        public String getText(GlusterGeoRepSessionDetails object) {
            return object.getMasterBrickHostName() == null ? constants.notAvailableLabel() : object.getMasterBrickHostName();
        }
    }, constants.geoRepSessionHostName());
    geoRepSessionSummaryTable.addColumn(new AbstractEntityModelTextColumn<GlusterGeoRepSessionDetails>() {

        @Override
        protected String getText(GlusterGeoRepSessionDetails entity) {
            return (entity == null || entity.getStatus() == null) ? constants.notAvailableLabel() : entity.getStatus().toString();
        }
    }, constants.geoRepSessionStatus());
    geoRepSessionSummaryTable.addColumn(new AbstractFullDateTimeColumn<EntityModel<GlusterGeoRepSessionDetails>>() {

        @Override
        protected Date getRawValue(EntityModel<GlusterGeoRepSessionDetails> object) {
            GlusterGeoRepSessionDetails sessionDetail = object.getEntity();
            return (sessionDetail == null || sessionDetail.getLastSyncedAt() == null) ? new Date() : sessionDetail.getLastSyncedAt();
        }
    }, constants.geoRepLastSyncedAt());
}
#end_block

#method_before
@Override
public void edit(final VolumeGeoRepSessionDetailsModel object) {
    driver.edit(object);
    checkPointCompletedAt.setVisible(object.getGeoRepSessionSummary().getSelectedItem().getEntity().getSessionDetail().isCheckpointCompleted());
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName.equalsIgnoreCase("selectedSessionSummaryRow")) {
                // $NON-NLS-1$
                GeoRepSessionDetailsSummaryTableRow selectedRow = object.getGeoRepSessionSummary().getSelectedItem().getEntity();
                entryOpsPending.asValueBox().setValue(selectedRow.getSessionDetail().getEntryOpsPending());
                metaOpsPending.asValueBox().setValue(selectedRow.getSessionDetail().getMetaOpsPending());
                dataOpsPending.asValueBox().setValue(selectedRow.getSessionDetail().getDataOpsPending());
                checkPointStatus.asValueBox().setValue(selectedRow.getSessionDetail().getCheckPointStatus());
                failures.asValueBox().setValue(selectedRow.getSessionDetail().getFailures());
                crawlStatus.asValueBox().setValue(selectedRow.getSessionDetail().getCrawlStatus());
                checkPointTime.asValueBox().setValue(selectedRow.getSessionDetail());
                checkPointCompletedAt.asValueBox().setValue(selectedRow.getSessionDetail());
                checkPointCompletedAt.setVisible(selectedRow.getSessionDetail().isCheckpointCompleted());
            }
        }
    });
    geoRepSessionSummaryTable.asEditor().edit(object.getGeoRepSessionSummary());
}
#method_after
@Override
public void edit(final VolumeGeoRepSessionDetailsModel object) {
    driver.edit(object);
    geoRepSessionSummaryTable.asEditor().edit(object.getGeoRepSessionSummary());
}
#end_block

#method_before
public ListModel<EntityModel<GeoRepSessionDetailsSummaryTableRow>> getGeoRepSessionSummary() {
    return geoRepSessionSummary;
}
#method_after
public ListModel<EntityModel<GlusterGeoRepSessionDetails>> getGeoRepSessionSummary() {
    return geoRepSessionSummary;
}
#end_block

#method_before
public void setGeoRepSessionSummary(ListModel<EntityModel<GeoRepSessionDetailsSummaryTableRow>> geoRepSessionSummary) {
    this.geoRepSessionSummary = geoRepSessionSummary;
}
#method_after
public void setGeoRepSessionSummary(ListModel<EntityModel<GlusterGeoRepSessionDetails>> geoRepSessionSummary) {
    this.geoRepSessionSummary = geoRepSessionSummary;
}
#end_block

#method_before
@Override
public Response add(Event event) {
    validateParameters(event, "origin", "severity", "customId", "description");
    validateEnums(Event.class, event);
    return performCreate(VdcActionType.AddExternalEvent, new AddExternalEventParameters(map(event)), new QueryIdResolver<Long>(VdcQueryType.GetAuditLogById, GetAuditLogByIdParameters.class));
}
#method_after
@Override
public Response add(Event event) {
    validateParameters(event, "origin", "severity", "customId", "description");
    validateEnums(Event.class, event);
    boolean isExternalStateDefined = event.isSetHost() && event.getHost().isSetExternalStatus() && event.getHost().getExternalStatus().isSetState();
    AddExternalEventParameters parameters = isExternalStateDefined ? new AddExternalEventParameters(map(event), HostMapper.map(EntityExternalStatus.fromValue(event.getHost().getExternalStatus().getState()), null)) : new AddExternalEventParameters(map(event), null);
    return performCreate(VdcActionType.AddExternalEvent, parameters, new QueryIdResolver<Long>(VdcQueryType.GetAuditLogById, GetAuditLogByIdParameters.class));
}
#end_block

#method_before
private MapSqlParameterSource getSqlMapper(AuditLog event) {
    return getCustomMapSqlParameterSource().addValue("audit_log_id", event.getAuditLogId()).addValue("log_time", event.getLogTime()).addValue("log_type", event.getLogType()).addValue("log_type_name", event.getLogTypeName()).addValue("severity", event.getSeverity()).addValue("message", event.getMessage()).addValue("user_id", event.getUserId()).addValue("user_name", event.getUserName()).addValue("vds_id", event.getVdsId()).addValue("vds_name", event.getVdsName()).addValue("vm_id", event.getVmId()).addValue("vm_name", event.getVmName()).addValue("vm_template_id", event.getVmTemplateId()).addValue("vm_template_name", event.getVmTemplateName()).addValue("storage_pool_id", event.getStoragePoolId()).addValue("storage_pool_name", event.getStoragePoolName()).addValue("storage_domain_id", event.getStorageDomainId()).addValue("storage_domain_name", event.getStorageDomainName()).addValue("vds_group_id", event.getVdsGroupId()).addValue("vds_group_name", event.getVdsGroupName()).addValue("correlation_id", event.getCorrelationId()).addValue("job_id", event.getJobId()).addValue("quota_id", event.getQuotaId()).addValue("quota_name", event.getQuotaName()).addValue("gluster_volume_id", event.getGlusterVolumeId()).addValue("gluster_volume_name", event.getGlusterVolumeName()).addValue("call_stack", event.getCallStack()).addValue("repeatable", event.isRepeatable()).addValue("brick_path", event.getBrickPath());
}
#method_after
private MapSqlParameterSource getSqlMapper(AuditLog event) {
    return getCustomMapSqlParameterSource().addValue("audit_log_id", event.getAuditLogId()).addValue("log_time", event.getLogTime()).addValue("log_type", event.getLogType()).addValue("log_type_name", event.getLogTypeName()).addValue("severity", event.getSeverity()).addValue("message", event.getMessage()).addValue("user_id", event.getUserId()).addValue("user_name", event.getUserName()).addValue("vds_id", event.getVdsId()).addValue("vds_name", event.getVdsName()).addValue("vm_id", event.getVmId()).addValue("vm_name", event.getVmName()).addValue("vm_template_id", event.getVmTemplateId()).addValue("vm_template_name", event.getVmTemplateName()).addValue("storage_pool_id", event.getStoragePoolId()).addValue("storage_pool_name", event.getStoragePoolName()).addValue("storage_domain_id", event.getStorageDomainId()).addValue("storage_domain_name", event.getStorageDomainName()).addValue("vds_group_id", event.getVdsGroupId()).addValue("vds_group_name", event.getVdsGroupName()).addValue("correlation_id", event.getCorrelationId()).addValue("job_id", event.getJobId()).addValue("quota_id", event.getQuotaId()).addValue("quota_name", event.getQuotaName()).addValue("gluster_volume_id", event.getGlusterVolumeId()).addValue("gluster_volume_name", event.getGlusterVolumeName()).addValue("call_stack", event.getCallStack()).addValue("repeatable", event.isRepeatable()).addValue("brick_id", event.getBrickId()).addValue("brick_path", event.getBrickPath());
}
#end_block

#method_before
@Override
public AuditLog mapRow(ResultSet rs, int rowNum) throws SQLException {
    AuditLog entity = new AuditLog();
    entity.setAuditLogId(rs.getLong("audit_log_id"));
    entity.setLogTime(DbFacadeUtils.fromDate(rs.getTimestamp("log_time")));
    entity.setLogType(AuditLogType.forValue(rs.getInt("log_type")));
    entity.setSeverity(AuditLogSeverity.forValue(rs.getInt("severity")));
    entity.setMessage(rs.getString("message"));
    entity.setUserId(getGuid(rs, "user_id"));
    entity.setUserName(rs.getString("user_name"));
    entity.setVdsId(getGuid(rs, "vds_id"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setVmId(getGuid(rs, "vm_id"));
    entity.setVmName(rs.getString("vm_name"));
    entity.setVmTemplateId(getGuid(rs, "vm_template_id"));
    entity.setVmTemplateName(rs.getString("vm_template_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setStorageDomainId(getGuid(rs, "storage_domain_id"));
    entity.setStorageDomainName(rs.getString("storage_domain_name"));
    entity.setVdsGroupId(getGuid(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setCorrelationId(rs.getString("correlation_id"));
    entity.setJobId(getGuid(rs, "job_id"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setGlusterVolumeId(getGuid(rs, "gluster_volume_id"));
    entity.setGlusterVolumeName(rs.getString("gluster_volume_name"));
    entity.setOrigin(rs.getString("origin"));
    entity.setCustomEventId(rs.getInt("custom_event_id"));
    entity.setEventFloodInSec(rs.getInt("event_flood_in_sec"));
    entity.setCustomData(rs.getString("custom_data"));
    entity.setDeleted(rs.getBoolean("deleted"));
    entity.setCallStack(rs.getString("call_stack"));
    return entity;
}
#method_after
@Override
public AuditLog mapRow(ResultSet rs, int rowNum) throws SQLException {
    AuditLog entity = new AuditLog();
    entity.setAuditLogId(rs.getLong("audit_log_id"));
    entity.setLogTime(DbFacadeUtils.fromDate(rs.getTimestamp("log_time")));
    entity.setLogType(AuditLogType.forValue(rs.getInt("log_type")));
    entity.setSeverity(AuditLogSeverity.forValue(rs.getInt("severity")));
    entity.setMessage(rs.getString("message"));
    entity.setUserId(getGuid(rs, "user_id"));
    entity.setUserName(rs.getString("user_name"));
    entity.setVdsId(getGuid(rs, "vds_id"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setVmId(getGuid(rs, "vm_id"));
    entity.setVmName(rs.getString("vm_name"));
    entity.setVmTemplateId(getGuid(rs, "vm_template_id"));
    entity.setVmTemplateName(rs.getString("vm_template_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setStorageDomainId(getGuid(rs, "storage_domain_id"));
    entity.setStorageDomainName(rs.getString("storage_domain_name"));
    entity.setVdsGroupId(getGuid(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setCorrelationId(rs.getString("correlation_id"));
    entity.setJobId(getGuid(rs, "job_id"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setGlusterVolumeId(getGuid(rs, "gluster_volume_id"));
    entity.setGlusterVolumeName(rs.getString("gluster_volume_name"));
    entity.setOrigin(rs.getString("origin"));
    entity.setCustomEventId(rs.getInt("custom_event_id"));
    entity.setEventFloodInSec(rs.getInt("event_flood_in_sec"));
    entity.setCustomData(rs.getString("custom_data"));
    entity.setDeleted(rs.getBoolean("deleted"));
    entity.setCallStack(rs.getString("call_stack"));
    entity.setBrickId(getGuid(rs, "brick_id"));
    entity.setBrickPath(rs.getString("brick_path"));
    return entity;
}
#end_block

#method_before
private List<String> getVdsIps(VDS vds) {
    List<String> vdsIps = new ArrayList<String>();
    for (VdsNetworkInterface iface : getInterfaceDao().getAllInterfacesForVds(vds.getId())) {
        if (iface.getAddress() != null) {
            vdsIps.add(iface.getAddress());
        }
    }
    return vdsIps;
}
#method_after
private List<String> getVdsIps(VDS vds) {
    List<String> vdsIps = new ArrayList<>();
    for (VdsNetworkInterface iface : getInterfaceDao().getAllInterfacesForVds(vds.getId())) {
        if (iface.getAddress() != null) {
            vdsIps.add(iface.getAddress());
        }
    }
    return vdsIps;
}
#end_block

#method_before
private List<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    // Create a copy of the existing servers as the fetchServer method can potentially remove elements from it
    List<VDS> tempServers = new ArrayList<VDS>(existingServers);
    List<GlusterServerInfo> fetchedServers = fetchServers(upServer, tempServers);
    if (fetchedServers == null) {
        log.error("gluster peer status command failed on all servers of the cluster '{}'." + "Can't refresh it's data at this point.", cluster.getName());
        return null;
    }
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        log.info("Gluster servers list fetched from server '{}' has only one server", upServer.getName());
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (isSameServer(upServer, server)) {
            // Find a different UP server, and get servers list from it
            tempServers.remove(upServer);
            upServer = getNewUpServer(tempServers, upServer);
            if (upServer == null) {
                log.warn("The only UP server in cluster '{}' seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getName());
                return null;
            }
            fetchedServers = fetchServers(upServer, tempServers);
            if (fetchedServers == null) {
                log.warn("The only UP server in cluster '{}' (or the only one on which gluster peer status " + "command is working) seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getName());
                return null;
            }
        }
    }
    return fetchedServers;
}
#method_after
private List<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    // Create a copy of the existing servers as the fetchServer method can potentially remove elements from it
    List<VDS> tempServers = new ArrayList<>(existingServers);
    List<GlusterServerInfo> fetchedServers = fetchServers(upServer, tempServers);
    if (fetchedServers == null) {
        log.error("gluster peer status command failed on all servers of the cluster '{}'." + "Can't refresh it's data at this point.", cluster.getName());
        return null;
    }
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        log.info("Gluster servers list fetched from server '{}' has only one server", upServer.getName());
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (isSameServer(upServer, server)) {
            // Find a different UP server, and get servers list from it
            tempServers.remove(upServer);
            upServer = getNewUpServer(tempServers, upServer);
            if (upServer == null) {
                log.warn("The only UP server in cluster '{}' seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getName());
                return null;
            }
            fetchedServers = fetchServers(upServer, tempServers);
            if (fetchedServers == null) {
                log.warn("The only UP server in cluster '{}' (or the only one on which gluster peer status " + "command is working) seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getName());
                return null;
            }
        }
    }
    return fetchedServers;
}
#end_block

#method_before
private void refreshVolumeData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    acquireLock(cluster.getId());
    try {
        // Pass a copy of the existing servers as the fetchVolumes method can potentially remove elements from it
        Map<Guid, GlusterVolumeEntity> volumesMap = fetchVolumes(upServer, new ArrayList<VDS>(existingServers));
        if (volumesMap == null) {
            log.error("gluster volume info command failed on all servers of the cluster '{}'." + "Can't refresh it's data at this point.", cluster.getName());
            return;
        }
        // remove deleted volumes must happen before adding new ones,
        // to handle cases where user deleted a volume and created a
        // new one with same name in a very short time
        removeDeletedVolumes(cluster.getId(), volumesMap);
        updateExistingAndNewVolumes(cluster.getId(), volumesMap);
    } finally {
        releaseLock(cluster.getId());
    }
}
#method_after
private void refreshVolumeData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    acquireLock(cluster.getId());
    try {
        // Pass a copy of the existing servers as the fetchVolumes method can potentially remove elements from it
        Map<Guid, GlusterVolumeEntity> volumesMap = fetchVolumes(upServer, new ArrayList<>(existingServers));
        if (volumesMap == null) {
            log.error("gluster volume info command failed on all servers of the cluster '{}'." + "Can't refresh it's data at this point.", cluster.getName());
            return;
        }
        // remove deleted volumes must happen before adding new ones,
        // to handle cases where user deleted a volume and created a
        // new one with same name in a very short time
        removeDeletedVolumes(cluster.getId(), volumesMap);
        updateExistingAndNewVolumes(cluster.getId(), volumesMap);
    } finally {
        releaseLock(cluster.getId());
    }
}
#end_block

#method_before
private void removeDeletedVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(clusterId)) {
        if (!volumesMap.containsKey(volume.getId())) {
            idsToRemove.add(volume.getId());
            log.debug("Volume '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", volume.getName());
            logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI);
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getVolumeDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing volumes from database!", e);
        }
    }
}
#method_after
private void removeDeletedVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(clusterId)) {
        if (!volumesMap.containsKey(volume.getId())) {
            idsToRemove.add(volume.getId());
            log.debug("Volume '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", volume.getName());
            logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI);
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getVolumeDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing volumes from database!", e);
        }
    }
}
#end_block

#method_before
@SuppressWarnings("serial")
private void removeDeletedBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (final GlusterBrickEntity existingBrick : existingVolume.getBricks()) {
        if (!GlusterCoreUtil.containsBrick(fetchedBricks, existingBrick)) {
            idsToRemove.add(existingBrick.getId());
            log.info("Detected brick '{}' removed from volume '{}'. Removing it from engine DB as well.", existingBrick.getQualifiedName(), existingVolume.getName());
            logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, new HashMap<String, String>() {

                {
                    put(GlusterConstants.BRICK, existingBrick.getQualifiedName());
                }
            });
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getBrickDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing bricks from database: {}", e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#method_after
@SuppressWarnings("serial")
private void removeDeletedBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (final GlusterBrickEntity existingBrick : existingVolume.getBricks()) {
        if (!GlusterCoreUtil.containsBrick(fetchedBricks, existingBrick)) {
            idsToRemove.add(existingBrick.getId());
            log.info("Detected brick '{}' removed from volume '{}'. Removing it from engine DB as well.", existingBrick.getQualifiedName(), existingVolume.getName());
            logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, new HashMap<String, String>() {

                {
                    put(GlusterConstants.BRICK, existingBrick.getQualifiedName());
                }
            });
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getBrickDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing bricks from database: {}", e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@SuppressWarnings("serial")
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (final GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            idsToRemove.add(existingOption.getId());
            log.info("Detected option '{}' reset on volume '{}'. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            // Hence it is not required to log it as a removed option, as that would be misleading.
            if (!GlusterConstants.OPTION_GROUP.equals(existingOption.getKey())) {
                logUtil.logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, new HashMap<String, String>() {

                    {
                        put(GlusterConstants.OPTION_KEY, existingOption.getKey());
                        put(GlusterConstants.OPTION_VALUE, existingOption.getValue());
                    }
                });
            }
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getOptionDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing options of volume '{}' from database: {}", fetchedVolume.getName(), e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#method_after
@SuppressWarnings("serial")
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (final GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            idsToRemove.add(existingOption.getId());
            log.info("Detected option '{}' reset on volume '{}'. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            // Hence it is not required to log it as a removed option, as that would be misleading.
            if (!GlusterConstants.OPTION_GROUP.equals(existingOption.getKey())) {
                logUtil.logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, new HashMap<String, String>() {

                    {
                        put(GlusterConstants.OPTION_KEY, existingOption.getKey());
                        put(GlusterConstants.OPTION_VALUE, existingOption.getValue());
                    }
                });
            }
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getOptionDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing options of volume '{}' from database: {}", fetchedVolume.getName(), e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
private void updateExistingAndNewOptions(final GlusterVolumeEntity existingVolume, Collection<GlusterVolumeOptionEntity> fetchedOptions) {
    Map<String, GlusterVolumeOptionEntity> existingOptions = new HashMap<>();
    Map<String, GlusterVolumeOptionEntity> newOptions = new HashMap<>();
    for (final GlusterVolumeOptionEntity fetchedOption : fetchedOptions) {
        final GlusterVolumeOptionEntity existingOption = existingVolume.getOption(fetchedOption.getKey());
        if (existingOption == null) {
            newOptions.put(fetchedOption.getKey(), fetchedOption);
        } else if (!existingOption.getValue().equals(fetchedOption.getValue())) {
            fetchedOption.setId(existingOption.getId());
            existingOptions.put(fetchedOption.getKey(), fetchedOption);
        }
    }
    final List<GlusterVolumeOptionEntity> newOptionsSortedList = new ArrayList<GlusterVolumeOptionEntity>(newOptions.values());
    final List<GlusterVolumeOptionEntity> existingOptionsSortedList = new ArrayList<GlusterVolumeOptionEntity>(existingOptions.values());
    Collections.sort(newOptionsSortedList);
    Collections.sort(existingOptionsSortedList);
    // Insert the new options in a single transaction
    if (!newOptionsSortedList.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveNewOptions(existingVolume, newOptionsSortedList);
                return null;
            }
        });
    }
    // Update the existing options in a single transaction
    if (!existingOptionsSortedList.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                updateExistingOptions(existingVolume, existingOptionsSortedList);
                return null;
            }
        });
    }
}
#method_after
private void updateExistingAndNewOptions(final GlusterVolumeEntity existingVolume, Collection<GlusterVolumeOptionEntity> fetchedOptions) {
    Map<String, GlusterVolumeOptionEntity> existingOptions = new HashMap<>();
    Map<String, GlusterVolumeOptionEntity> newOptions = new HashMap<>();
    for (final GlusterVolumeOptionEntity fetchedOption : fetchedOptions) {
        final GlusterVolumeOptionEntity existingOption = existingVolume.getOption(fetchedOption.getKey());
        if (existingOption == null) {
            newOptions.put(fetchedOption.getKey(), fetchedOption);
        } else if (!existingOption.getValue().equals(fetchedOption.getValue())) {
            fetchedOption.setId(existingOption.getId());
            existingOptions.put(fetchedOption.getKey(), fetchedOption);
        }
    }
    final List<GlusterVolumeOptionEntity> newOptionsSortedList = new ArrayList<>(newOptions.values());
    final List<GlusterVolumeOptionEntity> existingOptionsSortedList = new ArrayList<>(existingOptions.values());
    Collections.sort(newOptionsSortedList);
    Collections.sort(existingOptionsSortedList);
    // Insert the new options in a single transaction
    if (!newOptionsSortedList.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveNewOptions(existingVolume, newOptionsSortedList);
                return null;
            }
        });
    }
    // Update the existing options in a single transaction
    if (!existingOptionsSortedList.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                updateExistingOptions(existingVolume, existingOptionsSortedList);
                return null;
            }
        });
    }
}
#end_block

#method_before
public void refreshVolumeDetails(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<GlusterBrickEntity>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<GlusterBrickEntity>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<GlusterBrickEntity>();
    GlusterVolumeAdvancedDetails volumeAdvancedDetails = getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName());
    if (volumeAdvancedDetails == null) {
        log.error("Error while refreshing brick statuses for volume '{}'. Failed to get volume advanced details ", volume.getName());
        return;
    }
    if (volumeAdvancedDetails.getCapacityInfo() != null) {
        if (volume.getAdvancedDetails().getCapacityInfo() == null) {
            getVolumeDao().addVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        } else {
            getVolumeDao().updateVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        }
    }
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        getBrickDao().addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        getBrickDao().updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        getBrickDao().updateBrickStatuses(bricksToUpdate);
    }
}
#method_after
public void refreshVolumeDetails(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<>();
    GlusterVolumeAdvancedDetails volumeAdvancedDetails = getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName());
    if (volumeAdvancedDetails == null) {
        log.error("Error while refreshing brick statuses for volume '{}'. Failed to get volume advanced details ", volume.getName());
        return;
    }
    if (volumeAdvancedDetails.getCapacityInfo() != null) {
        if (volume.getAdvancedDetails().getCapacityInfo() == null) {
            getVolumeDao().addVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        } else {
            getVolumeDao().updateVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        }
    }
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        getBrickDao().addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        getBrickDao().updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        getBrickDao().updateBrickStatuses(bricksToUpdate);
    }
}
#end_block

#method_before
private void logBrickStatusChange(GlusterVolumeEntity volume, final GlusterBrickEntity brick, final GlusterStatus fetchedStatus) {
    log.debug("Detected that status of brick '{}' in volume '{}' changed from '{}' to '{}'", brick.getQualifiedName(), volume.getName(), brick.getStatus(), fetchedStatus);
    logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, new HashMap<String, String>() {

        {
            put(GlusterConstants.BRICK_PATH, brick.getQualifiedName());
            put(GlusterConstants.OPTION_OLD_VALUE, brick.getStatus().toString());
            put(GlusterConstants.OPTION_NEW_VALUE, fetchedStatus.toString());
        }
    });
    if (fetchedStatus.toString().equals("DOWN")) {
        logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_BRICK_STATUS_DOWN, new HashMap<String, String>() {

            {
                put(GlusterConstants.BRICK_PATH, brick.getQualifiedName());
            }
        }, brick.getQualifiedName());
    } else if (fetchedStatus.toString().equals("UP")) {
        AlertDirector.RemoveAlertsByBrickVolumeId(volume.getId(), brick.getQualifiedName(), "GLUSTER_BRICK_STATUS_DOWN");
    }
}
#method_after
private void logBrickStatusChange(GlusterVolumeEntity volume, final GlusterBrickEntity brick, final GlusterStatus fetchedStatus) {
    log.debug("Detected that status of brick '{}' in volume '{}' changed from '{}' to '{}'", brick.getQualifiedName(), volume.getName(), brick.getStatus(), fetchedStatus);
    logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, new HashMap<String, String>() {

        {
            put(GlusterConstants.BRICK_PATH, brick.getQualifiedName());
            put(GlusterConstants.OPTION_OLD_VALUE, brick.getStatus().toString());
            put(GlusterConstants.OPTION_NEW_VALUE, fetchedStatus.toString());
        }
    });
    if (fetchedStatus == GlusterStatus.DOWN) {
        logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_BRICK_STATUS_DOWN, brick.getId(), brick.getQualifiedName());
    } else if (fetchedStatus == GlusterStatus.UP) {
        AlertDirector.RemoveAlertsByBrickIdLogType(brick.getId(), AuditLogType.GLUSTER_BRICK_STATUS_DOWN);
    }
}
#end_block

#method_before
private Map<Guid, BrickProperties> getBrickPropertiesMap(GlusterVolumeAdvancedDetails volumeDetails) {
    Map<Guid, BrickProperties> brickStatusMap = new HashMap<Guid, BrickProperties>();
    for (BrickDetails brickDetails : volumeDetails.getBrickDetails()) {
        if (brickDetails.getBrickProperties().getBrickId() != null) {
            brickStatusMap.put(brickDetails.getBrickProperties().getBrickId(), brickDetails.getBrickProperties());
        }
    }
    return brickStatusMap;
}
#method_after
private Map<Guid, BrickProperties> getBrickPropertiesMap(GlusterVolumeAdvancedDetails volumeDetails) {
    Map<Guid, BrickProperties> brickStatusMap = new HashMap<>();
    for (BrickDetails brickDetails : volumeDetails.getBrickDetails()) {
        if (brickDetails.getBrickProperties().getBrickId() != null) {
            brickStatusMap.put(brickDetails.getBrickProperties().getBrickId(), brickDetails.getBrickProperties());
        }
    }
    return brickStatusMap;
}
#end_block

#method_before
public void logAuditMessage(final Guid clusterId, final GlusterVolumeEntity volume, final VDS server, final AuditLogType logType, final Map<String, String> customValues, final String brickPath) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.setVds(server);
    logable.setGlusterVolume(volume);
    logable.setVdsGroupId(clusterId);
    logable.setBrickPath(brickPath);
    if (customValues != null) {
        for (Entry<String, String> entry : customValues.entrySet()) {
            logable.addCustomValue(entry.getKey(), entry.getValue());
        }
    }
    auditLogDirector.log(logable, logType);
}
#method_after
public void logAuditMessage(final Guid clusterId, final GlusterVolumeEntity volume, final VDS server, final AuditLogType logType, final Guid brickId, final String brickPath) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.setVds(server);
    logable.setGlusterVolume(volume);
    logable.setVdsGroupId(clusterId);
    logable.setBrickId(brickId);
    logable.setBrickPath(brickPath);
    auditLogDirector.log(logable, logType);
}
#end_block

#method_before
private static void setPropertiesFromAuditLogableBase(AuditLogableBase auditLogable, AuditLog auditLog) {
    auditLog.setStorageDomainId(auditLogable.getStorageDomainId());
    auditLog.setStorageDomainName(auditLogable.getStorageDomainName());
    auditLog.setStoragePoolId(auditLogable.getStoragePoolId());
    auditLog.setStoragePoolName(auditLogable.getStoragePoolName());
    auditLog.setVdsGroupId(auditLogable.getVdsGroupId());
    auditLog.setVdsGroupName(auditLogable.getVdsGroupName());
    auditLog.setCorrelationId(auditLogable.getCorrelationId());
    auditLog.setJobId(auditLogable.getJobId());
    auditLog.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
    auditLog.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
    auditLog.setExternal(auditLogable.isExternal());
    auditLog.setQuotaId(auditLogable.getQuotaIdForLog());
    auditLog.setQuotaName(auditLogable.getQuotaNameForLog());
    auditLog.setCallStack(auditLogable.getCallStack());
    auditLog.setBrickPath(auditLogable.getBrickPath());
}
#method_after
private static void setPropertiesFromAuditLogableBase(AuditLogableBase auditLogable, AuditLog auditLog) {
    auditLog.setStorageDomainId(auditLogable.getStorageDomainId());
    auditLog.setStorageDomainName(auditLogable.getStorageDomainName());
    auditLog.setStoragePoolId(auditLogable.getStoragePoolId());
    auditLog.setStoragePoolName(auditLogable.getStoragePoolName());
    auditLog.setVdsGroupId(auditLogable.getVdsGroupId());
    auditLog.setVdsGroupName(auditLogable.getVdsGroupName());
    auditLog.setCorrelationId(auditLogable.getCorrelationId());
    auditLog.setJobId(auditLogable.getJobId());
    auditLog.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
    auditLog.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
    auditLog.setExternal(auditLogable.isExternal());
    auditLog.setQuotaId(auditLogable.getQuotaIdForLog());
    auditLog.setQuotaName(auditLogable.getQuotaNameForLog());
    auditLog.setCallStack(auditLogable.getCallStack());
    auditLog.setBrickId(auditLogable.getBrickId());
    auditLog.setBrickPath(auditLogable.getBrickPath());
}
#end_block

#method_before
private void allocateCustomValues() {
    if (Collections.EMPTY_MAP.equals(customValues)) {
        customValues = new HashMap<String, String>();
    }
}
#method_after
private void allocateCustomValues() {
    if (Collections.emptyMap().equals(customValues)) {
        customValues = new HashMap<>();
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getRestoreSnapshotCommand())) {
        restoreSnapshot();
    } else if (command.equals(getDeleteSnapshotCommand())) {
        deleteSnapshot();
    } else if (command.equals(getDeleteAllSnapshotsCommand())) {
        deleteAllSnapshots();
    } else if (command.equals(getActivateSnapshotCommand())) {
        activateSnapshot();
    } else if (command.equals(getDeactivateSnapshotCommand())) {
        deactivateSnapshot();
    } else if (command.getName().equals("onRestoreSnapshot")) {
        // $NON-NLS-1$
        onRestoreSnapshot();
    } else if (command.getName().equals("onDeleteSnapshot")) {
        // $NON-NLS-1$
        onDeleteSnapshot();
    } else if (command.getName().equals("onDeleteAllSnapshots")) {
        // $NON-NLS-1$
        onDeleteAllSnapshots();
    } else if (command.getName().equals("onActivateSnapshot")) {
        // $NON-NLS-1$
        onActivateSnapshot();
    } else if (command.getName().equals("onDeactivateSnapshot")) {
        // $NON-NLS-1$
        onDeactivateSnapshot();
    } else if (command.getName().equals("cancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.equals(getCreateSnapshotCommand())) {
        createSnapshot();
    } else if (command.getName().equalsIgnoreCase("onCreateSnapshot")) {
        // $NON-NLS-1$
        onCreateSnapshot();
    } else if (command.getName().equalsIgnoreCase("cancel")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.equals(getEditSnapshotScheduleCommand())) {
        editSnapshotSchedule();
    } else if (command.getName().equalsIgnoreCase("onEditSnapshotScheduleWithoutConfirmation")) {
        // $NON-NLS-1$
        onEditSnapshotScheduleWithoutConfirmation();
    } else if (command.getName().equalsIgnoreCase("onEditSnapshotSchedule")) {
        // $NON-NLS-1$
        onEditSnapshotSchedule();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getRestoreSnapshotCommand())) {
        restoreSnapshot();
    } else if (command.equals(getDeleteSnapshotCommand())) {
        deleteSnapshot();
    } else if (command.equals(getDeleteAllSnapshotsCommand())) {
        deleteAllSnapshots();
    } else if (command.equals(getActivateSnapshotCommand())) {
        activateSnapshot();
    } else if (command.equals(getDeactivateSnapshotCommand())) {
        deactivateSnapshot();
    } else if (command.getName().equals("onRestoreSnapshot")) {
        // $NON-NLS-1$
        onRestoreSnapshot();
    } else if (command.getName().equals("onDeleteSnapshot")) {
        // $NON-NLS-1$
        onDeleteSnapshot();
    } else if (command.getName().equals("onDeleteAllSnapshots")) {
        // $NON-NLS-1$
        onDeleteAllSnapshots();
    } else if (command.getName().equals("onActivateSnapshot")) {
        // $NON-NLS-1$
        onActivateSnapshot();
    } else if (command.getName().equals("onDeactivateSnapshot")) {
        // $NON-NLS-1$
        onDeactivateSnapshot();
    } else if (command.getName().equals("cancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.equals(getCreateSnapshotCommand())) {
        createSnapshot();
    } else if (command.getName().equalsIgnoreCase("onCreateSnapshot")) {
        // $NON-NLS-1$
        onCreateSnapshot();
    } else if (command.getName().equalsIgnoreCase("cancel")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.equals(getEditSnapshotScheduleCommand())) {
        editSnapshotSchedule();
    } else if (command.getName().equalsIgnoreCase("onEditSnapshotSchedule")) {
        // $NON-NLS-1$
        onEditSnapshotSchedule();
    } else if (command.getName().equalsIgnoreCase("onEditSnapshotScheduleInternal")) {
        // $NON-NLS-1$
        onEditSnapshotScheduleInternal();
    }
}
#end_block

#method_before
public void editSnapshotSchedule() {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final GlusterVolumeSnapshotModel snapshotModel = new GlusterVolumeSnapshotModel(true, true);
    snapshotModel.setHelpTag(HelpTag.edit_volume_snapshot_schedule);
    // $NON-NLS-1$
    snapshotModel.setHashName("edit_volume_snapshot_schedule");
    snapshotModel.setTitle(constants.editVolumeSnapshotScheduleTitle());
    setWindow(snapshotModel);
    snapshotModel.startProgress(null);
    AsyncDataProvider.getInstance().getVolumeSnapshotSchedule(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue == null) {
                snapshotModel.setMessage(ConstantsManager.getInstance().getConstants().unableToFetchVolumeSnapshotSchedule());
                return;
            }
            final GlusterVolumeSnapshotSchedule schedule = (GlusterVolumeSnapshotSchedule) returnValue;
            snapshotModel.getSnapshotName().setEntity(schedule.getSnapshotNamePrefix());
            snapshotModel.getDescription().setEntity(schedule.getSnapshotDescription());
            snapshotModel.getRecurrence().setSelectedItem(schedule.getRecurrence());
            if (schedule.getEndByDate() == null) {
                snapshotModel.getEndByOptions().setSelectedItem(EndDateOptions.NoEndDate);
            } else {
                snapshotModel.getEndByOptions().setSelectedItem(EndDateOptions.HasEndDate);
                snapshotModel.getEndDate().setEntity(schedule.getEndByDate());
            }
            if (schedule.getRecurrence() != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN) {
                Map<String, String> timeZones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
                snapshotModel.getTimeZones().setSelectedItem(Linq.firstOrDefault(timeZones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

                    @Override
                    public boolean match(Map.Entry<String, String> item) {
                        // $NON-NLS-1$
                        return item.getKey().startsWith(schedule.getTimeZone());
                    }
                }));
            }
            switch(schedule.getRecurrence()) {
                case INTERVAL:
                    snapshotModel.getInterval().setSelectedItem(String.valueOf(schedule.getInterval()));
                    break;
                case HOURLY:
                    break;
                case DAILY:
                    snapshotModel.getExecutionTime().setEntity(getExecutionTimeValue(schedule));
                    break;
                case WEEKLY:
                    List<DayOfWeek> daysList = new ArrayList<>();
                    for (String day : schedule.getDays().split(",")) {
                        // $NON-NLS-1$
                        daysList.add(getDayOfWeek(day));
                    }
                    snapshotModel.getDaysOfTheWeek().setSelectedItem(daysList);
                    snapshotModel.getExecutionTime().setEntity(getExecutionTimeValue(schedule));
                    break;
                case MONTHLY:
                    snapshotModel.getDaysOfMonth().setSelectedItem(schedule.getDays());
                    snapshotModel.getExecutionTime().setEntity(getExecutionTimeValue(schedule));
                    break;
            }
            snapshotModel.getStartAt().setEntity(schedule.getStartDate());
            snapshotModel.stopProgress();
        }

        private DayOfWeek getDayOfWeek(String day) {
            switch(day) {
                case // $NON-NLS-1$
                "Sun":
                    return DayOfWeek.Sunday;
                case // $NON-NLS-1$
                "Mon":
                    return DayOfWeek.Monday;
                case // $NON-NLS-1$
                "Tue":
                    return DayOfWeek.Tuesday;
                case // $NON-NLS-1$
                "Wed":
                    return DayOfWeek.Wednesday;
                case // $NON-NLS-1$
                "Thu":
                    return DayOfWeek.Thursday;
                case // $NON-NLS-1$
                "Fri":
                    return DayOfWeek.Friday;
                case // $NON-NLS-1$
                "Sat":
                    return DayOfWeek.Saturday;
                default:
                    return null;
            }
        }

        private Date getExecutionTimeValue(GlusterVolumeSnapshotSchedule schedule) {
            Date dt = new Date();
            dt.setHours(schedule.getExecutionTime().getHours());
            dt.setMinutes(schedule.getExecutionTime().getMinutes());
            return dt;
        }
    }), getEntity().getId());
    snapshotModel.getClusterName().setEntity(getEntity().getVdsGroupName());
    snapshotModel.getVolumeName().setEntity(getEntity().getName());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onEditSnapshotScheduleWithoutConfirmation", this);
    snapshotModel.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("cancel", this);
    snapshotModel.getCommands().add(cancelCommand);
}
#method_after
public void editSnapshotSchedule() {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final GlusterVolumeSnapshotModel snapshotModel = new GlusterVolumeSnapshotModel(true, true);
    snapshotModel.setHelpTag(HelpTag.edit_volume_snapshot_schedule);
    // $NON-NLS-1$
    snapshotModel.setHashName("edit_volume_snapshot_schedule");
    snapshotModel.setTitle(constants.editVolumeSnapshotScheduleTitle());
    setWindow(snapshotModel);
    snapshotModel.startProgress(null);
    AsyncDataProvider.getInstance().getVolumeSnapshotSchedule(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue == null) {
                snapshotModel.setMessage(ConstantsManager.getInstance().getConstants().unableToFetchVolumeSnapshotSchedule());
                return;
            }
            final GlusterVolumeSnapshotSchedule schedule = (GlusterVolumeSnapshotSchedule) returnValue;
            snapshotModel.getSnapshotName().setEntity(schedule.getSnapshotNamePrefix());
            snapshotModel.getDescription().setEntity(schedule.getSnapshotDescription());
            snapshotModel.getRecurrence().setSelectedItem(schedule.getRecurrence());
            if (schedule.getEndByDate() == null) {
                snapshotModel.getEndByOptions().setSelectedItem(EndDateOptions.NoEndDate);
            } else {
                snapshotModel.getEndByOptions().setSelectedItem(EndDateOptions.HasEndDate);
                snapshotModel.getEndDate().setEntity(schedule.getEndByDate());
            }
            if (schedule.getRecurrence() != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN) {
                Map<String, String> timeZones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
                snapshotModel.getTimeZones().setSelectedItem(Linq.firstOrDefault(timeZones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

                    @Override
                    public boolean match(Map.Entry<String, String> item) {
                        // $NON-NLS-1$
                        return item.getKey().startsWith(schedule.getTimeZone());
                    }
                }));
            }
            switch(schedule.getRecurrence()) {
                case INTERVAL:
                    snapshotModel.getInterval().setSelectedItem(String.valueOf(schedule.getInterval()));
                    break;
                case HOURLY:
                    break;
                case DAILY:
                    snapshotModel.getExecutionTime().setEntity(getExecutionTimeValue(schedule));
                    break;
                case WEEKLY:
                    List<DayOfWeek> daysList = new ArrayList<>();
                    for (String day : schedule.getDays().split(",")) {
                        // $NON-NLS-1$
                        daysList.add(getDayOfWeek(day));
                    }
                    snapshotModel.getDaysOfTheWeek().setSelectedItem(daysList);
                    snapshotModel.getExecutionTime().setEntity(getExecutionTimeValue(schedule));
                    break;
                case MONTHLY:
                    snapshotModel.getDaysOfMonth().setSelectedItem(schedule.getDays());
                    snapshotModel.getExecutionTime().setEntity(getExecutionTimeValue(schedule));
                    break;
            }
            snapshotModel.getStartAt().setEntity(schedule.getStartDate());
            snapshotModel.stopProgress();
        }

        private DayOfWeek getDayOfWeek(String day) {
            switch(day) {
                case // $NON-NLS-1$
                "Sun":
                    return DayOfWeek.Sunday;
                case // $NON-NLS-1$
                "Mon":
                    return DayOfWeek.Monday;
                case // $NON-NLS-1$
                "Tue":
                    return DayOfWeek.Tuesday;
                case // $NON-NLS-1$
                "Wed":
                    return DayOfWeek.Wednesday;
                case // $NON-NLS-1$
                "Thu":
                    return DayOfWeek.Thursday;
                case // $NON-NLS-1$
                "Fri":
                    return DayOfWeek.Friday;
                case // $NON-NLS-1$
                "Sat":
                    return DayOfWeek.Saturday;
                default:
                    return null;
            }
        }

        private Date getExecutionTimeValue(GlusterVolumeSnapshotSchedule schedule) {
            Date dt = new Date();
            dt.setHours(schedule.getExecutionTime().getHours());
            dt.setMinutes(schedule.getExecutionTime().getMinutes());
            return dt;
        }
    }), getEntity().getId());
    snapshotModel.getClusterName().setEntity(getEntity().getVdsGroupName());
    snapshotModel.getVolumeName().setEntity(getEntity().getName());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onEditSnapshotSchedule", this);
    snapshotModel.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("cancel", this);
    snapshotModel.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void confirmDeleteVolumeSnapshotSchedule() {
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeGlusterVolumeSnapshotScheduleConfirmationTitle());
    model.setHelpTag(HelpTag.remove_volume_snapshot_schedule_confirmation);
    // $NON-NLS-1$
    model.setHashName("remove_volume_snapshot_schedule_confirmation");
    model.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutToRemoveSnapshotScheduleMsg());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onEditSnapshotSchedule", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("cancelConfirmation", this);
    model.getCommands().add(cancelCommand);
}
#method_after
private void confirmDeleteVolumeSnapshotSchedule() {
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeGlusterVolumeSnapshotScheduleConfirmationTitle());
    model.setHelpTag(HelpTag.remove_volume_snapshot_schedule_confirmation);
    // $NON-NLS-1$
    model.setHashName("remove_volume_snapshot_schedule_confirmation");
    model.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutToRemoveSnapshotScheduleMsg());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onEditSnapshotScheduleInternal", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("cancelConfirmation", this);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onEditSnapshotSchedule() {
    final GlusterVolumeSnapshotModel snapshotModel = (GlusterVolumeSnapshotModel) getWindow();
    if (!snapshotModel.validate(false)) {
        return;
    }
    setConfirmWindow(null);
    scheduleSnapshot(snapshotModel, true);
}
#method_after
public void onEditSnapshotSchedule() {
    final GlusterVolumeSnapshotModel snapshotModel = (GlusterVolumeSnapshotModel) getWindow();
    if (snapshotModel.getRecurrence().getSelectedItem() == GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN) {
        confirmDeleteVolumeSnapshotSchedule();
    } else {
        onEditSnapshotScheduleInternal();
    }
}
#end_block

#method_before
protected boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        if (!handleDestStorageDomains()) {
            return false;
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    if (!validateGraphicsAndDisplay()) {
        return false;
    }
    if (!validate(getImportValidator().validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces())))) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#method_after
protected boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !validateUniqueVmName()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        if (!handleDestStorageDomains()) {
            return false;
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    if (!validateGraphicsAndDisplay()) {
        return false;
    }
    if (!validate(getImportValidator().validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces())))) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<? extends IVdcQueryable> returnValue = new ArrayList<>();
    switch(getParameters().getSearchTypeValue()) {
        case VM:
            {
                returnValue = searchVmsFromDb();
                break;
            }
        case DirectoryGroup:
            {
                returnValue = searchDirectoryGroups();
                break;
            }
        case DirectoryUser:
            {
                returnValue = searchDirectoryUsers();
                break;
            }
        case AuditLog:
            {
                returnValue = searchAuditLogEvents();
                break;
            }
        case DBUser:
            {
                returnValue = searchDbUsers();
                break;
            }
        case DBGroup:
            {
                returnValue = searchDbGroups();
                break;
            }
        case VDS:
            {
                returnValue = searchVDSsByDb();
                break;
            }
        case VmTemplate:
            {
                returnValue = searchVMTemplates();
                break;
            }
        case VmPools:
            {
                returnValue = searchVmPools();
                break;
            }
        case Cluster:
            {
                returnValue = searchClusters();
                break;
            }
        case StoragePool:
            {
                returnValue = searchStoragePool();
                break;
            }
        case StorageDomain:
            {
                returnValue = searchStorageDomain();
                break;
            }
        case Quota:
            {
                returnValue = searchQuota();
                break;
            }
        case Disk:
            {
                returnValue = searchDisk();
                break;
            }
        case GlusterVolume:
            {
                returnValue = searchGlusterVolumes();
                break;
            }
        case Network:
            {
                returnValue = searchNetworks();
                break;
            }
        case Provider:
            {
                returnValue = searchProviders();
                break;
            }
        case InstanceType:
            {
                returnValue = searchInstanceTypes();
                break;
            }
        case ImageType:
            {
                returnValue = searchVMTemplates();
                break;
            }
        case Session:
            returnValue = searchSessions();
            break;
        default:
            {
                log.error("Search object type not handled: {}", getParameters().getSearchTypeValue());
                break;
            }
    }
    getQueryReturnValue().setReturnValue(returnValue);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<? extends IVdcQueryable> returnValue = new ArrayList<IVdcQueryable>();
    switch(getParameters().getSearchTypeValue()) {
        case VM:
            {
                returnValue = searchVmsFromDb();
                break;
            }
        case DirectoryGroup:
            {
                returnValue = searchDirectoryGroups();
                break;
            }
        case DirectoryUser:
            {
                returnValue = searchDirectoryUsers();
                break;
            }
        case AuditLog:
            {
                returnValue = searchAuditLogEvents();
                break;
            }
        case DBUser:
            {
                returnValue = searchDbUsers();
                break;
            }
        case DBGroup:
            {
                returnValue = searchDbGroups();
                break;
            }
        case VDS:
            {
                returnValue = searchVDSsByDb();
                break;
            }
        case VmTemplate:
            {
                returnValue = searchVMTemplates();
                break;
            }
        case VmPools:
            {
                returnValue = searchVmPools();
                break;
            }
        case Cluster:
            {
                returnValue = searchClusters();
                break;
            }
        case StoragePool:
            {
                returnValue = searchStoragePool();
                break;
            }
        case StorageDomain:
            {
                returnValue = searchStorageDomain();
                break;
            }
        case Quota:
            {
                returnValue = searchQuota();
                break;
            }
        case Disk:
            {
                returnValue = searchDisk();
                break;
            }
        case GlusterVolume:
            {
                returnValue = searchGlusterVolumes();
                break;
            }
        case Network:
            {
                returnValue = searchNetworks();
                break;
            }
        case Provider:
            {
                returnValue = searchProviders();
                break;
            }
        case InstanceType:
            {
                returnValue = searchInstanceTypes();
                break;
            }
        case ImageType:
            {
                returnValue = searchVMTemplates();
                break;
            }
        case Session:
            returnValue = searchSessions();
            break;
        default:
            {
                log.error("Search object type not handled: {}", getParameters().getSearchTypeValue());
                break;
            }
    }
    getQueryReturnValue().setReturnValue(returnValue);
}
#end_block

#method_before
private <T extends IVdcQueryable> List<T> genericSearch(final SearchDAO<T> dao, final boolean useCache, final Filter<T> filter) {
    final QueryData data = initQueryData(useCache);
    if (data == null) {
        return new ArrayList<>();
    }
    log.debug("Executing generic query: {}", data.getQuery());
    return ListUtils.filter(dao.getAllWithQuery(data.getQuery()), filter);
}
#method_after
private <T extends IVdcQueryable> List<T> genericSearch(final SearchDAO<T> dao, final boolean useCache, final Filter<T> filter) {
    final QueryData data = initQueryData(useCache);
    if (data == null) {
        return new ArrayList<T>();
    }
    log.debug("Executing generic query: {}", data.getQuery());
    return ListUtils.filter(dao.getAllWithQuery(data.getQuery()), filter);
}
#end_block

#method_before
private List<Quota> searchQuota() {
    List<Quota> quotaList = genericSearch(getDbFacade().getQuotaDao(), true);
    getQuotaManager().updateUsage(quotaList);
    return quotaList;
}
#method_after
private List<Quota> searchQuota() {
    List<Quota> quotaList = genericSearch(getDbFacade().getQuotaDao(), true);
    QuotaManager.getInstance().updateUsage(quotaList);
    return quotaList;
}
#end_block

#method_before
public static void filterImageDisksForVM(VM vm) {
    List<DiskImage> filteredDisks = ImagesHandler.filterImageDisks(vm.getDiskMap().values(), false, false, true);
    List<CinderDisk> filteredCinderDisks = ImagesHandler.filterDisksBasedOnCinder(vm.getDiskMap().values());
    filteredDisks.addAll(filteredCinderDisks);
    Collection<? extends Disk> vmDisksToRemove = CollectionUtils.subtract(vm.getDiskMap().values(), filteredDisks);
    vm.clearDisks();
    updateDisksForVm(vm, filteredDisks);
    for (Disk diskToRemove : vmDisksToRemove) {
        vm.getManagedVmDeviceMap().remove(diskToRemove.getId());
    }
}
#method_after
public static void filterImageDisksForVM(VM vm) {
    List<DiskImage> filteredDisks = ImagesHandler.filterImageDisks(vm.getDiskMap().values(), false, false, true);
    Collection<? extends Disk> vmDisksToRemove = CollectionUtils.subtract(vm.getDiskMap().values(), filteredDisks);
    vm.clearDisks();
    updateDisksForVm(vm, filteredDisks);
    for (Disk diskToRemove : vmDisksToRemove) {
        vm.getManagedVmDeviceMap().remove(diskToRemove.getId());
    }
}
#end_block

#method_before
public static void updateOperationProgress(final VM vm) {
    vm.setBackgroundOperationDescription(ResourceManager.getInstance().getVmManager(vm.getId()).getBackgroundOperationDescription());
    vm.setBackgroundOperationProgress(ResourceManager.getInstance().getVmManager(vm.getId()).getBackgroundOperationProgress());
}
#method_after
public static void updateOperationProgress(final VM vm) {
    vm.setPhase(ResourceManager.getInstance().getVmManager(vm.getId()).getPhase());
    vm.setProgress(ResourceManager.getInstance().getVmManager(vm.getId()).getProgress());
}
#end_block

#method_before
public static List<VmDeviceUpdate> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<VmDeviceUpdate> fieldList = new ArrayList<>();
    if (objectWithEditableDeviceFields == null) {
        return fieldList;
    }
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        if (VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            // field may be updated on the current run, so not including for the next run
            continue;
        }
        try {
            Object value = field.get(objectWithEditableDeviceFields);
            if (value == null) {
            // preserve current configuration
            } else if (value instanceof Boolean) {
                addDeviceUpdateOnNextRun(vmId, annotation, null, value, fieldList);
            } else if (value instanceof VmManagementParametersBase.Optional) {
                VmManagementParametersBase.Optional<?> optional = (VmManagementParametersBase.Optional<?>) value;
                if (optional.isUpdate()) {
                    addDeviceUpdateOnNextRun(vmId, annotation, null, optional.getValue(), fieldList);
                }
            } else if (value instanceof Map) {
                Map<?, ?> map = (Map<?, ?>) value;
                for (Map.Entry<?, ?> entry : map.entrySet()) {
                    boolean success = addDeviceUpdateOnNextRun(vmId, annotation, entry.getKey(), entry.getValue(), fieldList);
                    if (!success)
                        break;
                }
            } else {
                log.warn("getVmDevicesFieldsToUpdateOnNextRun: Unsupported field type: " + value.getClass().getName());
            }
        } catch (IllegalAccessException | ClassCastException e) {
            log.warn("getVmDevicesFieldsToUpdateOnNextRun: Reflection error");
            log.debug("Original exception was:", e);
        }
    }
    return fieldList;
}
#method_after
public static List<Pair<EditableDeviceOnVmStatusField, Boolean>> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<Pair<EditableDeviceOnVmStatusField, Boolean>> fieldList = new ArrayList<>();
    if (objectWithEditableDeviceFields == null) {
        return fieldList;
    }
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        Boolean isEnabled = null;
        try {
            isEnabled = (Boolean) field.get(objectWithEditableDeviceFields);
        } catch (IllegalAccessException | ClassCastException e) {
            log.warn("VmHandler:: isUpdateValidForVmDevices: Reflection error");
            log.debug("Original exception was:", e);
        }
        // if device type is set to unknown, search by general type only
        // because some devices has more than one type, like sound can be ac97/ich6
        String device = null;
        if (annotation.type() != VmDeviceType.UNKNOWN) {
            device = annotation.type().getName();
        }
        if (isEnabled == null || !VmDeviceUtils.vmDeviceChanged(vmId, annotation.generalType(), device, isEnabled)) {
            continue;
        }
        if (!VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            fieldList.add(new Pair<>(annotation, isEnabled));
        }
    }
    return fieldList;
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
    setGuestCpuCount(vm.getGuestCpuCount());
    getGraphicsInfos().putAll(vm.getGraphicsInfos());
    getDynamicData().setGuestMemoryBuffered(vm.getGuestMemoryBuffered());
    getDynamicData().setGuestMemoryCached(vm.getGuestMemoryCached());
    getDynamicData().setGuestMemoryFree(vm.getGuestMemoryFree());
    setGuestOsArch(vm.getGuestOsArch());
    setGuestOsCodename(vm.getGuestOsCodename());
    setGuestOsDistribution(vm.getGuestOsDistribution());
    setGuestOsKernelVersion(vm.getGuestOsKernelVersion());
    setGuestOsType(vm.getGuestOsType());
    setGuestOsVersion(vm.getGuestOsVersion());
    setGuestOsTimezoneName(vm.getGuestOsTimezoneName());
    setGuestOsTimezoneOffset(vm.getGuestOsTimezoneOffset());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
    setGuestCpuCount(vm.getGuestCpuCount());
    getGraphicsInfos().putAll(vm.getGraphicsInfos());
    getDynamicData().setGuestMemoryBuffered(vm.getGuestMemoryBuffered());
    getDynamicData().setGuestMemoryCached(vm.getGuestMemoryCached());
    getDynamicData().setGuestMemoryFree(vm.getGuestMemoryFree());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    VmStatusColumn<VM> vmStatusColumn = new VmStatusColumn<VM>();
    vmStatusColumn.makeSortable(VmConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(vmStatusColumn, constants.empty(), "35px");
    VmTypeColumn vmTypeColumn = new VmTypeColumn();
    vmTypeColumn.makeSortable(VmConditionFieldAutoCompleter.TYPE);
    // $NON-NLS-1$
    getTable().addColumn(vmTypeColumn, constants.empty(), "30px");
    AbstractTextColumn<VM> nameColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VmConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    CommentColumn<VM> commentColumn = new CommentColumn<VM>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VM> hostColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    hostColumn.makeSortable(VmConditionFieldAutoCompleter.HOST);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    AbstractTextColumn<VM> ipColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    ipColumn.makeSortable(VmConditionFieldAutoCompleter.IP);
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    AbstractTextColumn<VM> fqdnColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmFQDN();
        }
    };
    fqdnColumn.makeSortable(VmConditionFieldAutoCompleter.FQDN);
    // $NON-NLS-1$
    getTable().addColumn(fqdnColumn, constants.fqdn(), "120px");
    AbstractTextColumn<VM> clusterColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    clusterColumn.makeSortable(VmConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    AbstractTextColumn<VM> dcColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    dcColumn.makeSortable(VmConditionFieldAutoCompleter.DATACENTER);
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    ColumnResizeTableLineChartProgressBar memoryColumn = new ColumnResizeTableLineChartProgressBar() {

        @Override
        protected List<Integer> getProgressValues(VM object) {
            return object.getMemoryUsageHistory();
        }
    };
    memoryColumn.makeSortable(VmConditionFieldAutoCompleter.MEM_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    ColumnResizeTableLineChartProgressBar cpuColumn = new ColumnResizeTableLineChartProgressBar() {

        @Override
        protected List<Integer> getProgressValues(VM object) {
            return object.getCpuUsageHistory();
        }
    };
    cpuColumn.makeSortable(VmConditionFieldAutoCompleter.CPU_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "70px");
    ColumnResizeTableLineChartProgressBar networkColumn = new ColumnResizeTableLineChartProgressBar() {

        @Override
        protected List<Integer> getProgressValues(VM object) {
            return object.getNetworkUsageHistory();
        }
    };
    networkColumn.makeSortable(VmConditionFieldAutoCompleter.NETWORK_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "70px");
    AbstractTextColumn<VM> displayColumn = new AbstractEnumColumn<VM, UnitVmModel.GraphicsTypes>() {

        @Override
        protected UnitVmModel.GraphicsTypes getRawValue(VM vm) {
            if ((vm.getStatus() == VMStatus.Down) || (vm.getStatus() == VMStatus.ImageLocked)) {
                return UnitVmModel.GraphicsTypes.NONE;
            }
            Map<GraphicsType, GraphicsInfo> graphicsInfos = vm.getGraphicsInfos();
            return UnitVmModel.GraphicsTypes.fromGraphicsTypes(graphicsInfos.keySet());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "70px");
    AbstractTextColumn<VM> statusColumn = new AbstractEnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            return object.getStatus();
        }

        @Override
        public String getValue(VM vm) {
            if (vm.getStatus() == VMStatus.MigratingFrom) {
                // will be rendered by progress column
                return null;
            }
            if (vm.getBackgroundOperationDescription() != null) {
                // will be rendered by progress column
                return null;
            }
            return super.getValue(vm);
        }
    };
    MigrationProgressColumn migrationProgressColumn = new MigrationProgressColumn();
    ImportProgressColumn importProgressColumn = new ImportProgressColumn();
    ReasonColumn<VM> reasonColumn = new ReasonColumn<VM>() {

        @Override
        protected String getReason(VM value) {
            return value.getStopReason();
        }
    };
    List<HasCell<VM, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    list.add(migrationProgressColumn);
    list.add(importProgressColumn);
    Cell<VM> compositeCell = new StatusCompositeCell<VM>(list);
    AbstractColumn<VM, VM> statusTextColumn = new AbstractColumn<VM, VM>(compositeCell) {

        @Override
        public VM getValue(VM object) {
            return object;
        }
    };
    statusTextColumn.makeSortable(VmConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusVm(), "120px");
    AbstractTextColumn<VM> uptimeColumn = new AbstractUptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    uptimeColumn.makeSortable(VmConditionFieldAutoCompleter.UPTIME);
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "100px");
    AbstractTextColumn<VM> descriptionColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(VmConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.description(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.restoreVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportVmCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cloneVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneVmCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }

        @Override
        public SafeHtml getTooltip() {
            return SafeHtmlUtils.fromSafeConstant(constants.runVm());
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.suspendVmImage(), resources.suspendVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }

        @Override
        public SafeHtml getTooltip() {
            return SafeHtmlUtils.fromSafeConstant(constants.suspendVm());
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }

        @Override
        public SafeHtml getTooltip() {
            return SafeHtmlUtils.fromSafeConstant(constants.shutDownVm());
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }

        @Override
        public SafeHtml getTooltip() {
            return SafeHtmlUtils.fromSafeConstant(constants.powerOffVm());
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.rebootVm(), resources.rebootImage(), resources.rebootDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebootCommand();
        }

        @Override
        public SafeHtml getTooltip() {
            return SafeHtmlUtils.fromSafeConstant(constants.rebootVm());
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConsoleConnectCommand();
        }

        @Override
        public SafeHtml getTooltip() {
            return SafeHtmlUtils.fromSafeConstant(constants.consoleVm());
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.consoleOptions(), // $NON-NLS-1$
    CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.createSnapshotVM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.changeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.enableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnableGlobalHaMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.disableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDisableGlobalHaMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.setConsoleKey()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSetConsoleKeyCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        updateReportsAvailability();
    } else {
        getMainModel().getReportsAvailabilityEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                updateReportsAvailability();
            }
        });
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    VmStatusColumn<VM> vmStatusColumn = new VmStatusColumn<VM>();
    vmStatusColumn.makeSortable(VmConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(vmStatusColumn, constants.empty(), "35px");
    VmTypeColumn vmTypeColumn = new VmTypeColumn();
    vmTypeColumn.makeSortable(VmConditionFieldAutoCompleter.TYPE);
    // $NON-NLS-1$
    getTable().addColumn(vmTypeColumn, constants.empty(), "30px");
    AbstractTextColumn<VM> nameColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VmConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    CommentColumn<VM> commentColumn = new CommentColumn<VM>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VM> hostColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    hostColumn.makeSortable(VmConditionFieldAutoCompleter.HOST);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    AbstractTextColumn<VM> ipColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    ipColumn.makeSortable(VmConditionFieldAutoCompleter.IP);
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    AbstractTextColumn<VM> fqdnColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmFQDN();
        }
    };
    fqdnColumn.makeSortable(VmConditionFieldAutoCompleter.FQDN);
    // $NON-NLS-1$
    getTable().addColumn(fqdnColumn, constants.fqdn(), "120px");
    AbstractTextColumn<VM> clusterColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    clusterColumn.makeSortable(VmConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    AbstractTextColumn<VM> dcColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    dcColumn.makeSortable(VmConditionFieldAutoCompleter.DATACENTER);
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    ColumnResizeTableLineChartProgressBar memoryColumn = new ColumnResizeTableLineChartProgressBar() {

        @Override
        protected List<Integer> getProgressValues(VM object) {
            return object.getMemoryUsageHistory();
        }
    };
    memoryColumn.makeSortable(VmConditionFieldAutoCompleter.MEM_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    ColumnResizeTableLineChartProgressBar cpuColumn = new ColumnResizeTableLineChartProgressBar() {

        @Override
        protected List<Integer> getProgressValues(VM object) {
            return object.getCpuUsageHistory();
        }
    };
    cpuColumn.makeSortable(VmConditionFieldAutoCompleter.CPU_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "70px");
    ColumnResizeTableLineChartProgressBar networkColumn = new ColumnResizeTableLineChartProgressBar() {

        @Override
        protected List<Integer> getProgressValues(VM object) {
            return object.getNetworkUsageHistory();
        }
    };
    networkColumn.makeSortable(VmConditionFieldAutoCompleter.NETWORK_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "70px");
    AbstractTextColumn<VM> displayColumn = new AbstractEnumColumn<VM, UnitVmModel.GraphicsTypes>() {

        @Override
        protected UnitVmModel.GraphicsTypes getRawValue(VM vm) {
            if ((vm.getStatus() == VMStatus.Down) || (vm.getStatus() == VMStatus.ImageLocked)) {
                return UnitVmModel.GraphicsTypes.NONE;
            }
            Map<GraphicsType, GraphicsInfo> graphicsInfos = vm.getGraphicsInfos();
            return UnitVmModel.GraphicsTypes.fromGraphicsTypes(graphicsInfos.keySet());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "70px");
    AbstractTextColumn<VM> statusColumn = new AbstractEnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            return object.getStatus();
        }

        @Override
        public String getValue(VM vm) {
            if (vm.getStatus() == VMStatus.MigratingFrom) {
                // will be rendered by progress column
                return null;
            }
            if (vm.getPhase() != null) {
                // will be rendered by progress column
                return null;
            }
            return super.getValue(vm);
        }
    };
    MigrationProgressColumn migrationProgressColumn = new MigrationProgressColumn();
    ImportProgressColumn importProgressColumn = new ImportProgressColumn();
    ReasonColumn<VM> reasonColumn = new ReasonColumn<VM>() {

        @Override
        protected String getReason(VM value) {
            return value.getStopReason();
        }
    };
    List<HasCell<VM, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    list.add(migrationProgressColumn);
    list.add(importProgressColumn);
    Cell<VM> compositeCell = new StatusCompositeCell<VM>(list);
    AbstractColumn<VM, VM> statusTextColumn = new AbstractColumn<VM, VM>(compositeCell) {

        @Override
        public VM getValue(VM object) {
            return object;
        }
    };
    statusTextColumn.makeSortable(VmConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusVm(), "120px");
    AbstractTextColumn<VM> uptimeColumn = new AbstractUptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    uptimeColumn.makeSortable(VmConditionFieldAutoCompleter.UPTIME);
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "100px");
    AbstractTextColumn<VM> descriptionColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(VmConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.description(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.restoreVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportVmCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cloneVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneVmCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }

        @Override
        public SafeHtml getTooltip() {
            return SafeHtmlUtils.fromSafeConstant(constants.runVm());
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.suspendVmImage(), resources.suspendVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }

        @Override
        public SafeHtml getTooltip() {
            return SafeHtmlUtils.fromSafeConstant(constants.suspendVm());
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }

        @Override
        public SafeHtml getTooltip() {
            return SafeHtmlUtils.fromSafeConstant(constants.shutDownVm());
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }

        @Override
        public SafeHtml getTooltip() {
            return SafeHtmlUtils.fromSafeConstant(constants.powerOffVm());
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.rebootVm(), resources.rebootImage(), resources.rebootDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebootCommand();
        }

        @Override
        public SafeHtml getTooltip() {
            return SafeHtmlUtils.fromSafeConstant(constants.rebootVm());
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConsoleConnectCommand();
        }

        @Override
        public SafeHtml getTooltip() {
            return SafeHtmlUtils.fromSafeConstant(constants.consoleVm());
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.consoleOptions(), // $NON-NLS-1$
    CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.createSnapshotVM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.changeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.enableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnableGlobalHaMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.disableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDisableGlobalHaMaintenanceCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        updateReportsAvailability();
    } else {
        getMainModel().getReportsAvailabilityEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                updateReportsAvailability();
            }
        });
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#end_block

#method_before
@Override
protected Integer getProgressValue(VM vm) {
    return vm.getBackgroundOperationDescription() != null ? vm.getBackgroundOperationProgress() : null;
}
#method_after
@Override
protected Integer getProgressValue(VM object) {
    return object.getPhase() != null ? object.getProgress() : null;
}
#end_block

#method_before
@Override
public SafeHtml getValue(VM object) {
    return object.getBackgroundOperationDescription() != null ? super.getValue(object) : null;
}
#method_after
@Override
public SafeHtml getValue(VM object) {
    if (object.getPhase() == null) {
        return null;
    }
    return super.getValue(object);
}
#end_block

#method_before
@Override
protected String getProgressText(VM vm) {
    String description = vm.getBackgroundOperationDescription();
    return description != null ? description : super.getProgressText(vm);
}
#method_after
@Override
protected String getProgressText(VM object) {
    if (object.getPhase() != null) {
        return object.getProgress() == 0 ? // $NON-NLS-1$
        "Initializing" : object.getPhase();
    }
    return super.getProgressText(object);
}
#end_block

#method_before
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().subtract(new Date(data.getDate()));
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debug("ResourceManager::searchBusinessObjects(''{}'') - entered", searchText);
            final char AT = '@';
            String queryAuthz = getDefaultAuthz();
            String queryNamespace = null;
            ISyntaxChecker curSyntaxChecker;
            if (searchText.startsWith(SearchObjects.AD_USER_OBJ_NAME + AT) || searchText.startsWith(SearchObjects.AD_USER_PLU_OBJ_NAME + AT) || searchText.startsWith(SearchObjects.AD_GROUP_OBJ_NAME + AT) || searchText.startsWith(SearchObjects.AD_GROUP_PLU_OBJ_NAME + AT)) {
                final char COLON = ':';
                String prefix = searchText.substring(0, searchText.indexOf(AT)) + COLON;
                searchText = searchText.replace(SearchObjects.AD_USER_PLU_OBJ_NAME + AT, StringUtils.EMPTY);
                searchText = searchText.replace(SearchObjects.AD_USER_OBJ_NAME + AT, StringUtils.EMPTY);
                searchText = searchText.replace(SearchObjects.AD_GROUP_PLU_OBJ_NAME + AT, StringUtils.EMPTY);
                searchText = searchText.replace(SearchObjects.AD_GROUP_OBJ_NAME + AT, StringUtils.EMPTY);
                // get profile
                List<String> profiles = getBackend().runInternalQuery(VdcQueryType.GetDomainList, new VdcQueryParametersBase()).getReturnValue();
                for (String profile : profiles) {
                    if (searchText.startsWith(profile + COLON)) {
                        queryAuthz = profile;
                        searchText = searchText.replace(profile + COLON, StringUtils.EMPTY);
                        break;
                    }
                }
                // get namespace
                HashMap<String, List<String>> namespacesMap = getBackend().runInternalQuery(VdcQueryType.GetAvailableNamespaces, new VdcQueryParametersBase()).getReturnValue();
                List<String> namespaces = namespacesMap.get(queryAuthz);
                for (String namespace : namespaces) {
                    if (searchText.startsWith(namespace + COLON)) {
                        queryNamespace = namespace;
                        searchText = searchText.replace(namespace + COLON, StringUtils.EMPTY);
                        break;
                    }
                }
                searchText = prefix + searchText;
                curSyntaxChecker = SyntaxCheckerFactory.createADSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            // If a number > maxValue is given then maxValue will be used
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? Integer.MAX_VALUE : Math.min(Integer.MAX_VALUE, getParameters().getMaxCount()));
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.info("ResourceManager::searchBusinessObjects - erroneous search text - ''{}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (!searchObj.getvalid()) {
                log.warn("ResourceManager::searchBusinessObjects - Invalid search text - ''{}''", searchText);
                return null;
            }
            // find if this is a trivial search expression (like 'Vms:' etc).
            isSafe = SearchObjects.isSafeExpression(searchText);
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), DateTime.getNow().getTime(), queryAuthz, queryNamespace);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character: {}", getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: {}", getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: {}: {}", getParameters().getSearchPattern(), ex.getMessage());
        log.debug("Exception", ex);
        data = null;
    }
    return data;
}
#method_after
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().subtract(new Date(data.getDate()));
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debug("ResourceManager::searchBusinessObjects(''{}'') - entered", searchText);
            final char AT = '@';
            String queryAuthz = null;
            String queryNamespace = null;
            ISyntaxChecker curSyntaxChecker;
            Matcher m = adSearchPattern.matcher(searchText);
            // checks if this is a AD query, if it is, verify given profile and namespace and pass the query
            if (m.matches()) {
                final String COLON = ":";
                String prefix = m.group("prefix");
                searchText = m.group("content");
                // get profile
                List<String> profiles = getBackend().runInternalQuery(VdcQueryType.GetDomainList, new VdcQueryParametersBase()).getReturnValue();
                for (String profile : profiles) {
                    if (searchText.startsWith(profile + COLON)) {
                        queryAuthz = profile;
                        searchText = searchText.replace(profile + COLON, StringUtils.EMPTY);
                        break;
                    }
                }
                if (queryAuthz == null) {
                    queryAuthz = getDefaultAuthz();
                }
                // get namespace
                HashMap<String, List<String>> namespacesMap = getBackend().runInternalQuery(VdcQueryType.GetAvailableNamespaces, new VdcQueryParametersBase()).getReturnValue();
                List<String> namespaces = namespacesMap.get(queryAuthz);
                for (String namespace : namespaces) {
                    if (searchText.startsWith(namespace + COLON)) {
                        queryNamespace = namespace;
                        searchText = searchText.replace(namespace + COLON, StringUtils.EMPTY);
                        break;
                    }
                }
                // ADUSER/ADGROUP<profile>::<query>
                if (searchText.startsWith(COLON)) {
                    searchText = prefix + searchText;
                } else {
                    searchText = prefix + COLON + searchText;
                }
                curSyntaxChecker = SyntaxCheckerFactory.createADSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            // If a number > maxValue is given then maxValue will be used
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? Integer.MAX_VALUE : Math.min(Integer.MAX_VALUE, getParameters().getMaxCount()));
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.info("ResourceManager::searchBusinessObjects - erroneous search text - ''{}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (!searchObj.getvalid()) {
                log.warn("ResourceManager::searchBusinessObjects - Invalid search text - ''{}''", searchText);
                return null;
            }
            // find if this is a trivial search expression (like 'Vms:' etc).
            isSafe = SearchObjects.isSafeExpression(searchText);
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), DateTime.getNow().getTime(), queryAuthz, queryNamespace);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character: {}", getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: {}", getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: {}: {}", getParameters().getSearchPattern(), ex.getMessage());
        log.debug("Exception", ex);
        data = null;
    }
    return data;
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn<VDS>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new HostAdditionalStatusColumn<VDS>(), constants.empty(), "60px");
    AbstractTextColumn<VDS> nameColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VdsConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    CommentColumn<VDS> commentColumn = new CommentColumn<VDS>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VDS> hostColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getHostName();
        }
    };
    hostColumn.makeSortable(VdsConditionFieldAutoCompleter.ADDRESS);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    AbstractTextColumn<VDS> clusterColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getVdsGroupName();
        }
    };
    clusterColumn.makeSortable(VdsConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> dcColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getStoragePoolName();
            }
        };
        dcColumn.makeSortable(VdsConditionFieldAutoCompleter.DATACENTER);
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    AbstractTextColumn<VDS> statusColumn = new AbstractEnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getStatus();
        }
    };
    ReasonColumn<VDS> reasonColumn = new ReasonColumn<VDS>() {

        @Override
        protected String getReason(VDS value) {
            return value.getMaintenanceReason();
        }
    };
    List<HasCell<VDS, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    Cell<VDS> compositeCell = new StatusCompositeCell<VDS>(list);
    AbstractColumn<VDS, VDS> statusTextColumn = new AbstractColumn<VDS, VDS>(compositeCell) {

        @Override
        public VDS getValue(VDS object) {
            return object;
        }

        @Override
        public SafeHtml getTooltip(VDS value) {
            String maintenanceReason = value.getMaintenanceReason();
            if (maintenanceReason != null && !maintenanceReason.trim().isEmpty()) {
                return SafeHtmlUtils.fromString(maintenanceReason);
            }
            return null;
        }
    };
    statusTextColumn.makeSortable(VdsConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        VmCountColumn vmCountColumn = new VmCountColumn();
        vmCountColumn.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);
        vmCountColumn.makeSortable(VdsConditionFieldAutoCompleter.ACTIVE_VMS);
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.vmsCount(), "110px");
    }
    AbstractPercentColumn<VDS> memColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageMemPercent();
        }
    };
    memColumn.makeSortable(VdsConditionFieldAutoCompleter.MEM_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    AbstractPercentColumn<VDS> cpuColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageCpuPercent();
        }
    };
    cpuColumn.makeSortable(VdsConditionFieldAutoCompleter.CPU_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    AbstractPercentColumn<VDS> netColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageNetworkPercent();
        }
    };
    netColumn.makeSortable(VdsConditionFieldAutoCompleter.NETWORK_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> spmColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getSpmStatus() != VdsSpmStatus.None) {
                    return object.getSpmStatus().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.selectHostAsSPM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSelectAsSpmCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.numaSupport()) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getNumaSupportCommand();
            }
        });
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromContext) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getManualFenceCommand();
            }
        });
    }
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.reinstallHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getInstallCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.upgradeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getUpgradeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<ActionButtonDefinition<VDS>>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        updateReportsAvailability();
    } else {
        getMainModel().getReportsAvailabilityEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                updateReportsAvailability();
            }
        });
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.refreshHostCapabilities()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRefreshCapabilitiesCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn<VDS>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new HostAdditionalStatusColumn(), constants.empty(), "60px");
    AbstractTextColumn<VDS> nameColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VdsConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    CommentColumn<VDS> commentColumn = new CommentColumn<VDS>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<VDS> hostColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getHostName();
        }
    };
    hostColumn.makeSortable(VdsConditionFieldAutoCompleter.ADDRESS);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    AbstractTextColumn<VDS> clusterColumn = new AbstractTextColumn<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getVdsGroupName();
        }
    };
    clusterColumn.makeSortable(VdsConditionFieldAutoCompleter.CLUSTER);
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> dcColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getStoragePoolName();
            }
        };
        dcColumn.makeSortable(VdsConditionFieldAutoCompleter.DATACENTER);
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    AbstractTextColumn<VDS> statusColumn = new AbstractEnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getStatus();
        }
    };
    ReasonColumn<VDS> reasonColumn = new ReasonColumn<VDS>() {

        @Override
        protected String getReason(VDS value) {
            return value.getMaintenanceReason();
        }
    };
    List<HasCell<VDS, ?>> list = new ArrayList<>();
    list.add(statusColumn);
    list.add(reasonColumn);
    Cell<VDS> compositeCell = new StatusCompositeCell<VDS>(list);
    AbstractColumn<VDS, VDS> statusTextColumn = new AbstractColumn<VDS, VDS>(compositeCell) {

        @Override
        public VDS getValue(VDS object) {
            return object;
        }

        @Override
        public SafeHtml getTooltip(VDS value) {
            String maintenanceReason = value.getMaintenanceReason();
            if (maintenanceReason != null && !maintenanceReason.trim().isEmpty()) {
                return SafeHtmlUtils.fromString(maintenanceReason);
            }
            return null;
        }
    };
    statusTextColumn.makeSortable(VdsConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusTextColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        VmCountColumn vmCountColumn = new VmCountColumn();
        vmCountColumn.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);
        vmCountColumn.makeSortable(VdsConditionFieldAutoCompleter.ACTIVE_VMS);
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.vmsCount(), "110px");
    }
    AbstractPercentColumn<VDS> memColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageMemPercent();
        }
    };
    memColumn.makeSortable(VdsConditionFieldAutoCompleter.MEM_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    AbstractPercentColumn<VDS> cpuColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageCpuPercent();
        }
    };
    cpuColumn.makeSortable(VdsConditionFieldAutoCompleter.CPU_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    AbstractPercentColumn<VDS> netColumn = new AbstractPercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getUsageNetworkPercent();
        }
    };
    netColumn.makeSortable(VdsConditionFieldAutoCompleter.NETWORK_USAGE);
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDS> spmColumn = new AbstractTextColumn<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getSpmStatus() != VdsSpmStatus.None) {
                    return object.getSpmStatus().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.selectHostAsSPM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getSelectAsSpmCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.numaSupport()) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getNumaSupportCommand();
            }
        });
        getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromContext) {

            @Override
            protected UICommand resolveCommand() {
                return getMainModel().getManualFenceCommand();
            }
        });
    }
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.reinstallHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getInstallCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.upgradeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getUpgradeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<ActionButtonDefinition<VDS>>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        updateReportsAvailability();
    } else {
        getMainModel().getReportsAvailabilityEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                updateReportsAvailability();
            }
        });
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.refreshHostCapabilities()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRefreshCapabilitiesCommand();
        }
    });
}
#end_block

#method_before
@Override
public Response add(Event event) {
    validateParameters(event, "origin", "severity", "customId", "description");
    validateEnums(Event.class, event);
    EntityExternalStatus entityExternalStatus = null;
    if (event.isSetHost() && event.getHost().isSetExternalStatus()) {
        entityExternalStatus = EntityExternalStatus.fromValue(event.getHost().getExternalStatus());
        return performCreate(VdcActionType.AddExternalEvent, new AddExternalEventParameters(map(event), HostMapper.map(entityExternalStatus, null)), new QueryIdResolver<Long>(VdcQueryType.GetAuditLogById, GetAuditLogByIdParameters.class));
    }
    return performCreate(VdcActionType.AddExternalEvent, new AddExternalEventParameters(map(event), null), new QueryIdResolver<Long>(VdcQueryType.GetAuditLogById, GetAuditLogByIdParameters.class));
}
#method_after
@Override
public Response add(Event event) {
    validateParameters(event, "origin", "severity", "customId", "description");
    validateEnums(Event.class, event);
    boolean isExternalStateDefined = event.isSetHost() && event.getHost().isSetExternalStatus() && event.getHost().getExternalStatus().isSetState();
    AddExternalEventParameters parameters = isExternalStateDefined ? new AddExternalEventParameters(map(event), HostMapper.map(EntityExternalStatus.fromValue(event.getHost().getExternalStatus().getState()), null)) : new AddExternalEventParameters(map(event), null);
    return performCreate(VdcActionType.AddExternalEvent, parameters, new QueryIdResolver<Long>(VdcQueryType.GetAuditLogById, GetAuditLogByIdParameters.class));
}
#end_block

#method_before
@Override
public void validateEnums(Host host) {
    if (host.isSetPowerManagement()) {
        if (host.getPowerManagement().isSetPmProxies()) {
            for (PmProxy proxy : host.getPowerManagement().getPmProxies().getPmProxy()) {
                validateEnum(PmProxyType.class, proxy.getType(), true);
            }
        }
    }
    if (host.isSetSsh()) {
        sshValidator.validateEnums(host.getSsh());
    }
    if (host.isSetProtocol()) {
        validateEnum(HostProtocol.class, host.getProtocol(), true);
    }
    if (host.isSetExternalStatus()) {
        validateEnum(EntityExternalStatus.class, host.getExternalStatus());
    }
}
#method_after
@Override
public void validateEnums(Host host) {
    if (host.isSetPowerManagement()) {
        if (host.getPowerManagement().isSetPmProxies()) {
            for (PmProxy proxy : host.getPowerManagement().getPmProxies().getPmProxy()) {
                validateEnum(PmProxyType.class, proxy.getType(), true);
            }
        }
    }
    if (host.isSetSsh()) {
        sshValidator.validateEnums(host.getSsh());
    }
    if (host.isSetProtocol()) {
        validateEnum(HostProtocol.class, host.getProtocol(), true);
    }
    if (host.isSetExternalStatus()) {
        validateEnum(EntityExternalStatus.class, host.getExternalStatus().getState().toUpperCase());
    }
}
#end_block

#method_before
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskStorageTypes(version, DiskStorageType.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addKdumpStates(version, KdumpStatus.values());
    addSupportedQosTypes(version);
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostExternalStates(version, EntityExternalStatus.values());
    addHostProtocols(version, HostProtocol.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    addSELinuxModes(version, SELinuxMode.values());
    addRngSources(version, RngSource.values());
    addPolicyUnitTypes(version, PolicyUnitType.values());
    addSpmStates(version, SpmState.values());
    addNetworkPluginTypes(version, NetworkPluginType.values());
    addMessageBrokerTypes(version, MessageBrokerType.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    addInheritableBooleans(version, InheritableBoolean.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#method_after
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addGraphicsTypes(version, GraphicsType.values());
    addDiskStorageTypes(version, DiskStorageType.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addKdumpStates(version, KdumpStatus.values());
    addSupportedQosTypes(version);
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addExternalStates(version, EntityExternalStatus.values());
    addHostProtocols(version, HostProtocol.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    addSELinuxModes(version, SELinuxMode.values());
    addRngSources(version, RngSource.values());
    addPolicyUnitTypes(version, PolicyUnitType.values());
    addSpmStates(version, SpmState.values());
    addNetworkPluginTypes(version, NetworkPluginType.values());
    addMessageBrokerTypes(version, MessageBrokerType.values());
    addConsoleDisconnectActions(version, ConsoleDisconnectAction.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    addInheritableBooleans(version, InheritableBoolean.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    HostProtocol protocol = map(entity.getProtocol(), null);
    model.setProtocol(protocol != null ? protocol.value() : null);
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (entity.getExternalStatus() != null) {
        EntityExternalStatus entityExternalStatus = map(entity.getExternalStatus(), null);
        model.setExternalStatus(entityExternalStatus.name());
    }
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    } else if (status == HostStatus.MAINTENANCE || status == HostStatus.PREPARING_FOR_MAINTENANCE) {
        model.getStatus().setDetail(entity.getMaintenanceReason());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getSpmStatus() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    SPM spm = new SPM();
    spm.setPriority(entity.getVdsSpmPriority());
    if (spm.getStatus() != null) {
        spm.setStatus(StatusUtils.create(map(entity.getSpmStatus(), null)));
    }
    model.setSpm(spm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    PowerManagement pm = map(entity, (PowerManagement) null);
    model.setPowerManagement(DeprecatedPowerManagementMapper.map(entity, pm));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (SSH) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSelinux(map(entity, (SELinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    model.setLiveSnapshotSupport(entity.getLiveSnapshotSupport());
    if (entity.getHostProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getHostProviderId().toString());
    }
    model.setUpdateAvailable(entity.isUpdateAvailable());
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    HostProtocol protocol = map(entity.getProtocol(), null);
    model.setProtocol(protocol != null ? protocol.value() : null);
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (entity.getExternalStatus() != null) {
        EntityExternalStatus entityExternalStatus = map(entity.getExternalStatus(), null);
        Status hostStatus = new Status();
        hostStatus.setState(entityExternalStatus.value());
        model.setExternalStatus(hostStatus);
    }
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    } else if (status == HostStatus.MAINTENANCE || status == HostStatus.PREPARING_FOR_MAINTENANCE) {
        model.getStatus().setDetail(entity.getMaintenanceReason());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getSpmStatus() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    SPM spm = new SPM();
    spm.setPriority(entity.getVdsSpmPriority());
    if (spm.getStatus() != null) {
        spm.setStatus(StatusUtils.create(map(entity.getSpmStatus(), null)));
    }
    model.setSpm(spm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    PowerManagement pm = map(entity, (PowerManagement) null);
    model.setPowerManagement(DeprecatedPowerManagementMapper.map(entity, pm));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (SSH) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSelinux(map(entity, (SELinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    model.setLiveSnapshotSupport(entity.getLiveSnapshotSupport());
    if (entity.getHostProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getHostProviderId().toString());
    }
    model.setUpdateAvailable(entity.isUpdateAvailable());
    return model;
}
#end_block

#method_before
@Mapping(from = ExternalStatus.class, to = EntityExternalStatus.class)
public static ExternalStatus map(EntityExternalStatus entityStatus, ExternalStatus template) {
    switch(entityStatus) {
        case OK:
            return ExternalStatus.Ok;
        case INFO:
            return ExternalStatus.Info;
        case WARNING:
            return ExternalStatus.Warning;
        case ERROR:
            return ExternalStatus.Error;
        case FAILURE:
            return ExternalStatus.Failure;
        default:
            return null;
    }
}
#method_after
@Mapping(from = EntityExternalStatus.class, to = ExternalStatus.class)
public static ExternalStatus map(EntityExternalStatus entityStatus, ExternalStatus template) {
    switch(entityStatus) {
        case OK:
            return ExternalStatus.Ok;
        case INFO:
            return ExternalStatus.Info;
        case WARNING:
            return ExternalStatus.Warning;
        case ERROR:
            return ExternalStatus.Error;
        case FAILURE:
            return ExternalStatus.Failure;
        default:
            return null;
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    // check for external host status modification
    List<PermissionSubject> hostExtStatusUpdatePermissionsList = new ArrayList<>();
    if (hasHostExternalStatus()) {
        hostExtStatusUpdatePermissionsList.add(new PermissionSubject(new Guid(getParameters().getEvent().getVdsId().toString()), VdcObjectType.VDS, ActionGroup.EDIT_HOST_CONFIGURATION));
    }
    List<PermissionSubject> permissionList = getPermissionList(getParameters().getEvent());
    List<PermissionSubject> joinedPermissionList = new ArrayList<>();
    joinedPermissionList.addAll(hostExtStatusUpdatePermissionsList);
    joinedPermissionList.addAll(permissionList);
    return joinedPermissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = getPermissionList(getParameters().getEvent());
    // check for external host status modification
    if (hasHostExternalStatus()) {
        permissionList.add(new PermissionSubject(getParameters().getEvent().getVdsId(), VdcObjectType.VDS, ActionGroup.EDIT_HOST_CONFIGURATION));
    }
    return permissionList;
}
#end_block

#method_before
@Override
public VdsDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsDynamic entity = new VdsDynamic();
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setOnlineCpus(rs.getString("online_cpus"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount(rs.getInt("vm_count"));
    entity.setVmsCoresCount(rs.getInt("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setIncomingMigrations(rs.getInt("incoming_migrations"));
    entity.setOutgoingMigrations(rs.getInt("outgoing_migrations"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead(rs.getInt("guest_overhead"));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setBuildName(rs.getString("build_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.setMaintenanceReason(rs.getString("maintenance_reason"));
    entity.setUpdateAvailable(rs.getBoolean("is_update_available"));
    return entity;
}
#method_after
@Override
public VdsDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsDynamic entity = new VdsDynamic();
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setOnlineCpus(rs.getString("online_cpus"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount(rs.getInt("vm_count"));
    entity.setVmsCoresCount(rs.getInt("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setIncomingMigrations(rs.getInt("incoming_migrations"));
    entity.setOutgoingMigrations(rs.getInt("outgoing_migrations"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead(rs.getInt("guest_overhead"));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setBuildName(rs.getString("build_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.setMaintenanceReason(rs.getString("maintenance_reason"));
    entity.setUpdateAvailable(rs.getBoolean("is_update_available"));
    entity.setExternalStatus(ExternalStatus.forValue(rs.getInt("external_status")));
    return entity;
}
#end_block

#method_before
@Override
public void updateStatus(Guid id, VDSStatus status) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_guid", id).addValue("status", status);
    getCallsHandler().executeModification("UpdateVdsDynamicStatus", parameterSource);
}
#method_after
@Override
public void updateStatus(Guid id, VDSStatus status) {
    MapSqlParameterSource parameterSource = getStatusSqlParameterSource(id, status);
    getCallsHandler().executeModification("UpdateVdsDynamicStatus", parameterSource);
}
#end_block

#method_before
@Override
public void updateExternalStatus(Guid id, ExternalStatus status) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_guid", id).addValue("external_status", status);
    getCallsHandler().executeModification("UpdateVdsDynamiciExternalStatus", parameterSource);
}
#method_after
public void updateExternalStatus(Guid id, ExternalStatus status) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_guid", id).addValue("external_status", status);
    getCallsHandler().executeModification("UpdateHostExternalStatus", parameterSource);
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setExternalStatus(ExternalStatus.forValue(rs.getInt("external_status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setOnlineCpus(rs.getString("online_cpus"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setIncomingMigrations(rs.getInt("incoming_migrations"));
    entity.setOutgoingMigrations(rs.getInt("outgoing_migrations"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(rs.getString("pm_proxy_preferences")));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    entity.setBalloonEnabled(rs.getBoolean("enable_balloon"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    entity.setMaintenanceReason(rs.getString("maintenance_reason"));
    Guid agentGuid = getGuid(rs, "agent_id");
    if (agentGuid != null) {
        FenceAgent agent = new FenceAgent();
        agent.setId(agentGuid);
        agent.setHostId(getGuid(rs, "vds_id"));
        agent.setOrder(rs.getInt("agent_order"));
        agent.setType(rs.getString("agent_type"));
        agent.setUser(rs.getString("agent_user"));
        agent.setPassword(DbFacadeUtils.decryptPassword(rs.getString("agent_password")));
        int port = rs.getInt("agent_port");
        agent.setPort(port == 0 ? null : port);
        agent.setEncryptOptions(rs.getBoolean("agent_encrypt_options"));
        if (agent.getEncryptOptions()) {
            agent.setOptions(DbFacadeUtils.decryptPassword(rs.getString("agent_options")));
        } else {
            agent.setOptions(rs.getString("agent_options"));
        }
        agent.setIp(rs.getString("agent_ip"));
        entity.getFenceAgents().add(agent);
    }
    entity.setUpdateAvailable(rs.getBoolean("is_update_available"));
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setExternalStatus(ExternalStatus.forValue(rs.getInt("external_status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setOnlineCpus(rs.getString("online_cpus"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setIncomingMigrations(rs.getInt("incoming_migrations"));
    entity.setOutgoingMigrations(rs.getInt("outgoing_migrations"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(rs.getString("pm_proxy_preferences")));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeSchedulingMemoryCache();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    entity.setBalloonEnabled(rs.getBoolean("enable_balloon"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    entity.setMaintenanceReason(rs.getString("maintenance_reason"));
    Guid agentGuid = getGuid(rs, "agent_id");
    if (agentGuid != null) {
        FenceAgent agent = new FenceAgent();
        agent.setId(agentGuid);
        agent.setHostId(getGuid(rs, "vds_id"));
        agent.setOrder(rs.getInt("agent_order"));
        agent.setType(rs.getString("agent_type"));
        agent.setUser(rs.getString("agent_user"));
        agent.setPassword(DbFacadeUtils.decryptPassword(rs.getString("agent_password")));
        int port = rs.getInt("agent_port");
        agent.setPort(port == 0 ? null : port);
        agent.setEncryptOptions(rs.getBoolean("agent_encrypt_options"));
        if (agent.getEncryptOptions()) {
            agent.setOptions(DbFacadeUtils.decryptPassword(rs.getString("agent_options")));
        } else {
            agent.setOptions(rs.getString("agent_options"));
        }
        agent.setIp(rs.getString("agent_ip"));
        entity.getFenceAgents().add(agent);
    }
    entity.setUpdateAvailable(rs.getBoolean("is_update_available"));
    return entity;
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setExternalStatus(getExternalStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    vds.setVdsGroupCompatibilityVersion(getVdsGroupCompatibilityVersion());
    vds.setUpdateAvailable(isUpdateAvailable());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setExternalStatus(getExternalStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setVersion(getVersion());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    vds.setVdsGroupCompatibilityVersion(getVdsGroupCompatibilityVersion());
    vds.setUpdateAvailable(isUpdateAvailable());
    return vds;
}
#end_block

#method_before
public void setMemCommited(Integer value) {
    vdsDynamic.setMemCommited(value);
    calculateFreeVirtualMemory();
}
#method_after
public void setMemCommited(Integer value) {
    vdsDynamic.setMemCommited(value);
    calculateFreeSchedulingMemoryCache();
}
#end_block

#method_before
public void setPendingVmemSize(int value) {
    vdsDynamic.setPendingVmemSize(value);
}
#method_after
public void setPendingVmemSize(int value) {
    vdsDynamic.setPendingVmemSize(value);
    calculateFreeSchedulingMemoryCache();
}
#end_block

#method_before
protected void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    repoStorageDom = DbFacade.getInstance().getRepoFileMetaDataDao();
    providerDao = DbFacade.getInstance().getProviderDao();
    isoDomainRefreshRate = Config.<Integer>getValue(ConfigValues.AutoRepoDomainRefreshTime) * MIN_TO_MILLISECONDS;
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "fetchIsoDomains", new Class[] {}, new Object[] {}, 300000, isoDomainRefreshRate, TimeUnit.MILLISECONDS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#method_after
protected void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    repoStorageDom = DbFacade.getInstance().getRepoFileMetaDataDao();
    providerDao = DbFacade.getInstance().getProviderDao();
    isoDomainRefreshRate = Config.<Integer>getValue(ConfigValues.AutoRepoDomainRefreshTime) * MIN_TO_MILLISECONDS;
    Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "fetchIsoDomains", new Class[] {}, new Object[] {}, 300000, isoDomainRefreshRate, TimeUnit.MILLISECONDS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
protected void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    repoStorageDom = DbFacade.getInstance().getRepoFileMetaDataDao();
    providerDao = DbFacade.getInstance().getProviderDao();
    isoDomainRefreshRate = Config.<Integer>getValue(ConfigValues.AutoRepoDomainRefreshTime) * MIN_TO_MILLISECONDS;
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "fetchIsoDomains", new Class[] {}, new Object[] {}, 300000, isoDomainRefreshRate, TimeUnit.MILLISECONDS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#method_after
protected void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    repoStorageDom = DbFacade.getInstance().getRepoFileMetaDataDao();
    providerDao = DbFacade.getInstance().getProviderDao();
    isoDomainRefreshRate = Config.<Integer>getValue(ConfigValues.AutoRepoDomainRefreshTime) * MIN_TO_MILLISECONDS;
    Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "fetchIsoDomains", new Class[] {}, new Object[] {}, 300000, isoDomainRefreshRate, TimeUnit.MILLISECONDS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
@Override
public ClientPolicy clone() throws CloneNotSupportedException {
    return new StompClientPolicy(this.getRetryTimeOut(), this.getRetryNumber(), this.getIncomingHeartbeat(), this.getOutgoingHeartbeat(), this.getExceptions(), this.requestQueue, this.responseQueue);
}
#method_after
@Override
public ClientPolicy clone() throws CloneNotSupportedException {
    StompClientPolicy policy = new StompClientPolicy(this.getRetryTimeOut(), this.getRetryNumber(), this.getIncomingHeartbeat(), this.getOutgoingHeartbeat(), this.getExceptions(), this.requestQueue, this.responseQueue);
    policy.setEventQueue(this.eventQueue);
    return policy;
}
#end_block

#method_before
@Override
public void sendMessage(byte[] message) throws ClientConnectionException {
    waitForConnect();
    send(new Message().send().withHeader(HEADER_DESTINATION, this.getRequestQueue()).withContent(message).build());
}
#method_after
@Override
public void sendMessage(byte[] message) throws ClientConnectionException {
    waitForConnect();
    send(new Message().send().withHeader(HEADER_DESTINATION, this.getRequestQueue()).withHeader(HEADER_REPLY_TO, getResponseQueue()).withContent(message).build());
}
#end_block

#method_before
@Override
public void sendMessage(byte[] message) {
    send(new Message().send().withHeader(HEADER_DESTINATION, this.getRequestQueue()).withContent(message).build());
}
#method_after
@Override
public void sendMessage(byte[] message) {
    send(new Message().send().withHeader(HEADER_DESTINATION, this.getRequestQueue()).withHeader(HEADER_REPLY_TO, getResponseQueue()).withContent(message).build());
}
#end_block

#method_before
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", cachedVds.getName());
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", e.getMessage());
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (getLockObj()) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            dbFacade.getVdsDynamicDao().updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", cachedVds.getName());
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (getLockObj()) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            dbFacade.getVdsDynamicDao().updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
    if (updateAvailable) {
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLogDirector.log(auditLog, AuditLogType.HOST_UPDATES_ARE_AVAILABLE);
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = resourceManager.runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    if (caps.getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                auditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED) || (vds.getVdsGroupSupportsGlusterService() && vds.getSELinuxEnforceMode().equals(SELinuxMode.PERMISSIVE))) {
            auditLogDirector.log(new AuditLogableBase(vds.getId()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warn("Host '{}' is running with SELinux in '{}' mode", vds.getName(), vds.getSELinuxEnforceMode());
            } else {
                log.warn("Host '{}' does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = getHostNetworkTopologyPersister().persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debug("monitoring: vds '{}' networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            dbFacade.getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            processHostFeaturesReported(vds);
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (caps.getExceptionObject() != null) {
        throw caps.getExceptionObject();
    } else {
        log.error("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(caps.getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = resourceManager.runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    if (caps.getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                auditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        // hence warning in case of permissive as well.
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED) || (vds.getVdsGroupSupportsGlusterService() && vds.getSELinuxEnforceMode().equals(SELinuxMode.PERMISSIVE))) {
            auditLogDirector.log(new AuditLogableBase(vds.getId()).addCustomValue("Mode", vds.getSELinuxEnforceMode() == null ? "UNKNOWN" : vds.getSELinuxEnforceMode().name()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warn("Host '{}' is running with SELinux in '{}' mode", vds.getName(), vds.getSELinuxEnforceMode());
            } else {
                log.warn("Host '{}' does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = getHostNetworkTopologyPersister().persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debug("monitoring: vds '{}' networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            dbFacade.getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            processHostFeaturesReported(vds);
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (caps.getExceptionObject() != null) {
        throw caps.getExceptionObject();
    } else {
        log.error("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(caps.getExceptionString());
    }
}
#end_block

#method_before
protected void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    repoStorageDom = DbFacade.getInstance().getRepoFileMetaDataDao();
    providerDao = DbFacade.getInstance().getProviderDao();
    isoDomainRefreshRate = Config.<Integer>getValue(ConfigValues.AutoRepoDomainRefreshTime) * MIN_TO_MILLISECONDS;
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "fetchIsoDomains", new Class[] {}, new Object[] {}, 300000, isoDomainRefreshRate, TimeUnit.MILLISECONDS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#method_after
protected void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    repoStorageDom = DbFacade.getInstance().getRepoFileMetaDataDao();
    providerDao = DbFacade.getInstance().getProviderDao();
    isoDomainRefreshRate = Config.<Integer>getValue(ConfigValues.AutoRepoDomainRefreshTime) * MIN_TO_MILLISECONDS;
    Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "fetchIsoDomains", new Class[] {}, new Object[] {}, 300000, isoDomainRefreshRate, TimeUnit.MILLISECONDS);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
public List<RepoImage> getUserRequestForStorageDomainRepoFileList(Guid storageDomainId, ImageFileType imageType, boolean forceRefresh) {
    // The result list we send back.
    List<RepoImage> repoList;
    if (!isStorageDomainValid(storageDomainId, imageType, forceRefresh)) {
        throw new VdcBLLException(VdcBllErrors.GetIsoListError);
    }
    // At any case, if refreshed or not, get Iso list from the cache.
    repoList = getCachedIsoListByDomainId(storageDomainId, imageType);
    // Return list of repository files.
    return repoList;
}
#method_after
public List<RepoImage> getUserRequestForStorageDomainRepoFileList(Guid storageDomainId, ImageFileType imageType, boolean forceRefresh) {
    if (!isStorageDomainValid(storageDomainId, imageType, forceRefresh)) {
        throw new VdcBLLException(VdcBllErrors.GetIsoListError);
    }
    // At any case, if refreshed or not, get Iso list from the cache.
    return getCachedIsoListByDomainId(storageDomainId, imageType);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDSGroup cluster = getVdsGroup();
    if (!cluster.supportsGlusterService() || !GlusterFeatureSupported.glusterBrickProvisioning(cluster.getCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    VdsValidator validator = new VdsValidator(getVds());
    return validate(validator.isUp());
}
#method_after
@Override
protected boolean canDoAction() {
    VDSGroup cluster = getVdsGroup();
    if (!cluster.supportsGlusterService() || (!getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), getVdsGroup().getId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    VdsValidator validator = new VdsValidator(getVds());
    return validate(validator.isUp());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        getStorageDeviceSyncJobInstance().refreshStorageDevicesFromServer(getVds());
        setSucceeded(true);
    } catch (Exception exp) {
        setSucceeded(false);
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetStorageDeviceList, new VdsIdVDSCommandParametersBase(getVds().getId()));
    if (returnValue.getSucceeded()) {
        List<StorageDevice> storageDevices = (List<StorageDevice>) returnValue.getReturnValue();
        getStorageDeviceSyncJobInstance().updateStorageDevices(getVds(), storageDevices);
        setSucceeded(true);
    } else {
        handleVdsError(returnValue);
        setSucceeded(false);
    }
}
#end_block

#method_before
private void refreshStorageDevicesFromServers(List<VDS> upServers) {
    List<Callable<Pair<VDS, List<StorageDevice>>>> storageDevicesListCalls = new ArrayList<>();
    for (final VDS server : upServers) {
        storageDevicesListCalls.add(new Callable<Pair<VDS, List<StorageDevice>>>() {

            @Override
            public Pair<VDS, List<StorageDevice>> call() throws Exception {
                List<StorageDevice> storageDevices = getStorageDevicesFromServer(server);
                return new Pair<VDS, List<StorageDevice>>(server, storageDevices);
            }
        });
    }
    if (!storageDevicesListCalls.isEmpty()) {
        List<Pair<VDS, List<StorageDevice>>> storageDevices = ThreadPoolUtil.invokeAll(storageDevicesListCalls);
        for (Pair<VDS, List<StorageDevice>> pair : storageDevices) {
            if (pair.getSecond() != null) {
                updateStorageDevices(pair.getFirst(), pair.getSecond());
            }
        }
    }
}
#method_after
private void refreshStorageDevicesFromServers(List<VDS> upServers) {
    List<Callable<Pair<VDS, List<StorageDevice>>>> storageDevicesListCalls = new ArrayList<>();
    for (final VDS server : upServers) {
        storageDevicesListCalls.add(new Callable<Pair<VDS, List<StorageDevice>>>() {

            @Override
            public Pair<VDS, List<StorageDevice>> call() throws Exception {
                List<StorageDevice> storageDevices = getStorageDevicesFromServer(server);
                return new Pair<>(server, storageDevices);
            }
        });
    }
    if (!storageDevicesListCalls.isEmpty()) {
        List<Pair<VDS, List<StorageDevice>>> storageDevices = ThreadPoolUtil.invokeAll(storageDevicesListCalls);
        for (Pair<VDS, List<StorageDevice>> pair : storageDevices) {
            if (pair.getSecond() != null) {
                updateStorageDevices(pair.getFirst(), pair.getSecond());
            }
        }
    }
}
#end_block

#method_before
private List<StorageDevice> getStorageDevicesFromServer(VDS server) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetStorageDeviceList, new VdsIdVDSCommandParametersBase(server.getId()));
        if (returnValue.getSucceeded()) {
            return (List<StorageDevice>) returnValue.getReturnValue();
        } else {
            log.error("VDS error retriving storage device {}", returnValue.getVdsError().getMessage());
            log.debug("VDS Error", returnValue.getVdsError());
            return null;
        }
    } catch (Exception e) {
        log.error("Exception retriving storage device from vds {}", e.getMessage());
        log.debug("Exception", e);
        throw e;
    }
}
#method_after
private List<StorageDevice> getStorageDevicesFromServer(VDS server) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetStorageDeviceList, new VdsIdVDSCommandParametersBase(server.getId()));
        if (returnValue.getSucceeded()) {
            return (List<StorageDevice>) returnValue.getReturnValue();
        } else {
            log.error("VDS error retriving storage device {}", returnValue.getVdsError().getMessage());
            log.debug("VDS Error", returnValue.getVdsError());
            return null;
        }
    } catch (Exception e) {
        log.error("Exception retriving storage device from vds {}", e.getMessage());
        log.debug("Exception", e);
        return null;
    }
}
#end_block

#method_before
private void updateStorageDevices(VDS vds, List<StorageDevice> storageDevicesFromVdsm) {
    Set<String> deviceUuidsFromVdsm = new HashSet<>();
    Set<String> deviceNamesFromVdsm = new HashSet<>();
    List<StorageDevice> storageDevicesInDb = getStorageDeviceDao().getStorageDevicesInHost(vds.getId());
    Map<String, StorageDevice> nameToDeviceMap = new HashMap<>();
    Map<String, StorageDevice> deviceUuidToDeviceMap = new HashMap<>();
    // newly added and updated devices without looping over the same list again and again.
    for (StorageDevice storageDevice : storageDevicesInDb) {
        nameToDeviceMap.put(storageDevice.getName(), storageDevice);
        if (storageDevice.getDevUuid() != null && !storageDevice.getDevUuid().isEmpty()) {
            deviceUuidToDeviceMap.put(storageDevice.getDevUuid(), storageDevice);
        }
    }
    List<StorageDevice> storageDevicesToUpdate = new ArrayList<>();
    List<StorageDevice> storageDevicesToDelete = new ArrayList<>();
    for (StorageDevice storageDevice : storageDevicesFromVdsm) {
        // Create deviceName and deviceUuid set to use it while finding the deleted services.
        deviceNamesFromVdsm.add(storageDevice.getName());
        if (storageDevice.getDevUuid() != null) {
            deviceUuidsFromVdsm.add(storageDevice.getDevUuid());
        }
        // If DevUuid is already exits in the DB then its an existing devices
        // Assume device from vdsm doesn't have devUUID, but device name already exists in the DB
        // Following two cases possible:
        // 1. If device in DB doesn't have a devUUID
        // update the device if there is a change from vdsm.
        // 2. If device in DB has devUUID
        // Though name matches, its two different devices. So treat this device as new one.
        // Device in DB will be updated/removed by some other iteration in the loop
        StorageDevice storageDevByDevUuid = deviceUuidToDeviceMap.get(storageDevice.getDevUuid());
        StorageDevice storageDevByName = nameToDeviceMap.get(storageDevice.getName());
        if (storageDevByDevUuid != null) {
            storageDevice.setId(storageDevByDevUuid.getId());
            if (!Objects.equals(storageDevByDevUuid, storageDevice)) {
                storageDevicesToUpdate.add(storageDevice);
            }
        } else if (storageDevByName != null && StringUtils.isBlank(storageDevByName.getDevUuid())) {
            storageDevice.setId(storageDevByName.getId());
            if (!Objects.equals(storageDevByName, storageDevice)) {
                storageDevicesToUpdate.add(storageDevice);
            }
        } else {
            storageDevice.setId(Guid.newGuid());
            storageDevice.setVdsId(vds.getId());
            log.debug("detected new storage device '{}' for host '{}'", storageDevice.getName(), vds.getName());
            getStorageDeviceDao().save(storageDevice);
            logStorageDeviceMessage(AuditLogType.NEW_STORAGE_DEVICE_DETECTED, vds, storageDevice);
        }
    }
    for (StorageDevice storageDevice : storageDevicesInDb) {
        if ((storageDevice.getDevUuid() != null && !deviceUuidsFromVdsm.contains(storageDevice.getDevUuid())) || (storageDevice.getDevUuid() == null && !deviceNamesFromVdsm.contains(storageDevice.getName()))) {
            log.debug("storage device '{}' detected removed for the host '{}'", storageDevice.getName(), vds.getName());
            logStorageDeviceMessage(AuditLogType.STORAGE_DEVICE_REMOVED_FROM_THE_HOST, vds, storageDevice);
            storageDevicesToDelete.add(storageDevice);
        }
    }
    if (!storageDevicesToUpdate.isEmpty()) {
        getStorageDeviceDao().updateAllInBatch(storageDevicesToUpdate);
    }
    if (!storageDevicesToDelete.isEmpty()) {
        getStorageDeviceDao().removeAllInBatch(storageDevicesToDelete);
    }
}
#method_after
public void updateStorageDevices(VDS vds, List<StorageDevice> storageDevicesFromVdsm) {
    Set<String> deviceUuidsFromVdsm = new HashSet<>();
    Set<String> deviceNamesFromVdsm = new HashSet<>();
    List<StorageDevice> storageDevicesInDb = getStorageDeviceDao().getStorageDevicesInHost(vds.getId());
    Map<String, StorageDevice> nameToDeviceMap = new HashMap<>();
    Map<String, StorageDevice> deviceUuidToDeviceMap = new HashMap<>();
    // newly added and updated devices without looping over the same list again and again.
    for (StorageDevice storageDevice : storageDevicesInDb) {
        nameToDeviceMap.put(storageDevice.getName(), storageDevice);
        if (storageDevice.getDevUuid() != null && !storageDevice.getDevUuid().isEmpty()) {
            deviceUuidToDeviceMap.put(storageDevice.getDevUuid(), storageDevice);
        }
    }
    List<StorageDevice> storageDevicesToUpdate = new ArrayList<>();
    List<StorageDevice> storageDevicesToDelete = new ArrayList<>();
    for (StorageDevice storageDevice : storageDevicesFromVdsm) {
        // Create deviceName and deviceUuid set to use it while finding the deleted services.
        deviceNamesFromVdsm.add(storageDevice.getName());
        if (storageDevice.getDevUuid() != null) {
            deviceUuidsFromVdsm.add(storageDevice.getDevUuid());
        }
        // If DevUuid is already exits in the DB then its an existing devices
        // Assume device from vdsm doesn't have devUUID, but device name already exists in the DB
        // Following two cases possible:
        // 1. If device in DB doesn't have a devUUID
        // update the device if there is a change from vdsm.
        // 2. If device in DB has devUUID
        // Though name matches, its two different devices. So treat this device as new one.
        // Device in DB will be updated/removed by some other iteration in the loop
        StorageDevice storageDevByDevUuid = deviceUuidToDeviceMap.get(storageDevice.getDevUuid());
        StorageDevice storageDevByName = nameToDeviceMap.get(storageDevice.getName());
        if (storageDevByDevUuid != null) {
            storageDevice.setId(storageDevByDevUuid.getId());
            if (!Objects.equals(storageDevByDevUuid, storageDevice)) {
                storageDevicesToUpdate.add(storageDevice);
            }
        } else if (storageDevByName != null && StringUtils.isBlank(storageDevByName.getDevUuid())) {
            storageDevice.setId(storageDevByName.getId());
            if (!Objects.equals(storageDevByName, storageDevice)) {
                storageDevicesToUpdate.add(storageDevice);
            }
        } else {
            storageDevice.setId(Guid.newGuid());
            storageDevice.setVdsId(vds.getId());
            log.debug("detected new storage device '{}' for host '{}'", storageDevice.getName(), vds.getName());
            getStorageDeviceDao().save(storageDevice);
            logStorageDeviceMessage(AuditLogType.NEW_STORAGE_DEVICE_DETECTED, vds, storageDevice);
        }
    }
    for (StorageDevice storageDevice : storageDevicesInDb) {
        if ((storageDevice.getDevUuid() != null && !deviceUuidsFromVdsm.contains(storageDevice.getDevUuid())) || (storageDevice.getDevUuid() == null && !deviceNamesFromVdsm.contains(storageDevice.getName()))) {
            log.debug("storage device '{}' detected removed for the host '{}'", storageDevice.getName(), vds.getName());
            logStorageDeviceMessage(AuditLogType.STORAGE_DEVICE_REMOVED_FROM_THE_HOST, vds, storageDevice);
            storageDevicesToDelete.add(storageDevice);
        }
    }
    if (!storageDevicesToUpdate.isEmpty()) {
        getStorageDeviceDao().updateAllInBatch(storageDevicesToUpdate);
    }
    if (!storageDevicesToDelete.isEmpty()) {
        getStorageDeviceDao().removeAllInBatch(storageDevicesToDelete);
    }
}
#end_block

#method_before
private boolean supportsGlusterDiskProvisioning(VDSGroup cluster) {
    return cluster.supportsGlusterService() && GlusterFeatureSupported.glusterBrickProvisioning(cluster.getCompatibilityVersion());
}
#method_after
private boolean supportsGlusterDiskProvisioning(VDSGroup cluster) {
    return cluster.supportsGlusterService() && getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), cluster.getId());
}
#end_block

#method_before
private void syncDbRecords(boolean removeImages) {
    // If deletion failed after a backwards merge, the snapshots' images need to be swapped
    // as they would upon success.  Instead of removing them, mark them illegal.
    DiskImage baseImage = getDiskImage();
    DiskImage topImage = getDestinationDiskImage();
    // The vdsm merge verb may decide to perform a forward or backward merge.
    if (topImage == null) {
        log.debug("No merge destination image, not updating image/snapshot association");
    } else if (getParameters().getMergeStatusReturnValue().getBlockJobType() == VmBlockJobType.PULL) {
        // For forward merge, the volume format and type may change.
        topImage.setvolumeFormat(baseImage.getVolumeFormat());
        topImage.setVolumeType(baseImage.getVolumeType());
        topImage.setParentId(baseImage.getParentId());
        topImage.setImageStatus(ImageStatus.OK);
        getBaseDiskDao().update(topImage);
        getImageDao().update(topImage.getImage());
        updateDiskImageDynamic(topImage);
        updateVmConfigurationForImageRemoval(baseImage.getImage().getSnapshotId(), baseImage.getImageId());
    } else {
        // For backwards merge, the prior base image now has the data associated with the newer
        // snapshot we want to keep.  Re-associate this older image with the newer snapshot.
        // The base snapshot is deleted if everything went well.  In case it's not deleted, we
        // hijack it to preserve a link to the broken image.  This makes the image discoverable
        // so that we can retry the deletion later, yet doesn't corrupt the VM image chain.
        List<DiskImage> children = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForParent(topImage.getImageId());
        if (!children.isEmpty()) {
            DiskImage childImage = children.get(0);
            childImage.setParentId(baseImage.getImageId());
            getImageDao().update(childImage.getImage());
        }
        Image oldTopImage = topImage.getImage();
        topImage.setImage(baseImage.getImage());
        baseImage.setImage(oldTopImage);
        Guid oldTopSnapshotId = topImage.getImage().getSnapshotId();
        topImage.getImage().setSnapshotId(baseImage.getImage().getSnapshotId());
        baseImage.getImage().setSnapshotId(oldTopSnapshotId);
        boolean oldTopIsActive = topImage.getImage().isActive();
        topImage.getImage().setActive(baseImage.getImage().isActive());
        topImage.getImage().setVolumeClassification(ImagesHandler.getVolumeClassificationForImage(baseImage.getImage().isActive()));
        baseImage.getImage().setActive(oldTopIsActive);
        topImage.getImage().setVolumeClassification(ImagesHandler.getVolumeClassificationForImage(oldTopIsActive));
        topImage.setImageStatus(ImageStatus.OK);
        getBaseDiskDao().update(topImage);
        getImageDao().update(topImage.getImage());
        updateDiskImageDynamic(topImage);
        getBaseDiskDao().update(baseImage);
        getImageDao().update(baseImage.getImage());
        updateVmConfigurationForImageChange(topImage.getImage().getSnapshotId(), baseImage.getImageId(), topImage);
        updateVmConfigurationForImageRemoval(baseImage.getImage().getSnapshotId(), topImage.getImageId());
    }
    Set<Guid> imagesToUpdate = getParameters().getMergeStatusReturnValue().getImagesToRemove();
    if (imagesToUpdate == null) {
        log.error("Failed to update orphaned images in db: image list could not be retrieved");
        return;
    }
    for (Guid imageId : imagesToUpdate) {
        if (removeImages) {
            getImageDao().remove(imageId);
        } else {
            // The (illegal && no-parent && no-children) status indicates an orphaned image.
            Image image = getImageDao().get(imageId);
            image.setStatus(ImageStatus.ILLEGAL);
            image.setParentId(Guid.Empty);
            getImageDao().update(image);
        }
    }
}
#method_after
private void syncDbRecords(boolean removeImages) {
    // If deletion failed after a backwards merge, the snapshots' images need to be swapped
    // as they would upon success.  Instead of removing them, mark them illegal.
    DiskImage baseImage = getDiskImage();
    DiskImage topImage = getDestinationDiskImage();
    // The vdsm merge verb may decide to perform a forward or backward merge.
    if (topImage == null) {
        log.debug("No merge destination image, not updating image/snapshot association");
    } else if (getParameters().getMergeStatusReturnValue().getBlockJobType() == VmBlockJobType.PULL) {
        // For forward merge, the volume format and type may change.
        topImage.setvolumeFormat(baseImage.getVolumeFormat());
        topImage.setVolumeType(baseImage.getVolumeType());
        topImage.setParentId(baseImage.getParentId());
        topImage.setImageStatus(ImageStatus.OK);
        getBaseDiskDao().update(topImage);
        getImageDao().update(topImage.getImage());
        updateDiskImageDynamic(topImage);
        updateVmConfigurationForImageRemoval(baseImage.getImage().getSnapshotId(), baseImage.getImageId());
    } else {
        // For backwards merge, the prior base image now has the data associated with the newer
        // snapshot we want to keep.  Re-associate this older image with the newer snapshot.
        // The base snapshot is deleted if everything went well.  In case it's not deleted, we
        // hijack it to preserve a link to the broken image.  This makes the image discoverable
        // so that we can retry the deletion later, yet doesn't corrupt the VM image chain.
        List<DiskImage> children = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForParent(topImage.getImageId());
        if (!children.isEmpty()) {
            DiskImage childImage = children.get(0);
            childImage.setParentId(baseImage.getImageId());
            getImageDao().update(childImage.getImage());
        }
        Image oldTopImage = topImage.getImage();
        topImage.setImage(baseImage.getImage());
        baseImage.setImage(oldTopImage);
        Guid oldTopSnapshotId = topImage.getImage().getSnapshotId();
        topImage.getImage().setSnapshotId(baseImage.getImage().getSnapshotId());
        baseImage.getImage().setSnapshotId(oldTopSnapshotId);
        boolean oldTopIsActive = topImage.getImage().isActive();
        topImage.getImage().setActive(baseImage.getImage().isActive());
        VolumeClassification baseImageVolumeClassification = VolumeClassification.getVolumeClassificationByActiveFlag(baseImage.getImage().isActive());
        topImage.getImage().setVolumeClassification(baseImageVolumeClassification);
        baseImage.getImage().setActive(oldTopIsActive);
        VolumeClassification oldTopVolumeClassification = VolumeClassification.getVolumeClassificationByActiveFlag(oldTopIsActive);
        topImage.getImage().setVolumeClassification(oldTopVolumeClassification);
        topImage.setImageStatus(ImageStatus.OK);
        getBaseDiskDao().update(topImage);
        getImageDao().update(topImage.getImage());
        updateDiskImageDynamic(topImage);
        getBaseDiskDao().update(baseImage);
        getImageDao().update(baseImage.getImage());
        updateVmConfigurationForImageChange(topImage.getImage().getSnapshotId(), baseImage.getImageId(), topImage);
        updateVmConfigurationForImageRemoval(baseImage.getImage().getSnapshotId(), topImage.getImageId());
    }
    Set<Guid> imagesToUpdate = getParameters().getMergeStatusReturnValue().getImagesToRemove();
    if (imagesToUpdate == null) {
        log.error("Failed to update orphaned images in db: image list could not be retrieved");
        return;
    }
    for (Guid imageId : imagesToUpdate) {
        if (removeImages) {
            getImageDao().remove(imageId);
        } else {
            // The (illegal && no-parent && no-children) status indicates an orphaned image.
            Image image = getImageDao().get(imageId);
            image.setStatus(ImageStatus.ILLEGAL);
            image.setParentId(Guid.Empty);
            getImageDao().update(image);
        }
    }
}
#end_block

#method_before
public VolumeClassification getVolumeClassification() {
    if (volumeClassification == null) {
        if (active) {
            return VolumeClassification.Volume;
        }
        return VolumeClassification.Snapshot;
    }
    return volumeClassification;
}
#method_after
public VolumeClassification getVolumeClassification() {
    if (volumeClassification == null) {
        return (active ? VolumeClassification.Volume : VolumeClassification.Snapshot);
    }
    return volumeClassification;
}
#end_block

#method_before
protected String generateVmConfiguration(VM vm, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices) {
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = getVmTemplateDao().get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    if (vmDevices == null) {
        VmDeviceUtils.setVmDevices(vm.getStaticData());
    } else {
        vm.getStaticData().setManagedDeviceMap(vmDevices);
    }
    if (disks == null) {
        disks = ImagesHandler.filterImageDisks(getDiskDao().getAllForVm(vm.getId()), false, true, true);
        disks.addAll(ImagesHandler.filterDisksBasedOnCinder(getDiskDao().getAllForVm(vm.getId())));
    }
    for (DiskImage image : disks) {
        image.setStorageIds(null);
    }
    return new OvfManager().ExportVm(vm, new ArrayList<>(disks), ClusterUtils.getCompatibilityVersion(vm));
}
#method_after
protected String generateVmConfiguration(VM vm, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices) {
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = getVmTemplateDao().get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    if (vmDevices == null) {
        VmDeviceUtils.setVmDevices(vm.getStaticData());
    } else {
        vm.getStaticData().setManagedDeviceMap(vmDevices);
    }
    if (disks == null) {
        disks = ImagesHandler.filterImageDisks(getDiskDao().getAllForVm(vm.getId()), false, true, true);
        disks.addAll(ImagesHandler.getCinderLeafImages(getDiskDao().getAllForVm(vm.getId()), true));
    }
    for (DiskImage image : disks) {
        image.setStorageIds(null);
    }
    return new OvfManager().ExportVm(vm, new ArrayList<>(disks), ClusterUtils.getCompatibilityVersion(vm));
}
#end_block

#method_before
public ValidationResult validateCinderDiskLimits() {
    return validate(new Callable<ValidationResult>() {

        @Override
        public ValidationResult call() {
            Map<Guid, CinderStorageRelatedDisksAndProxy> relatedCinderDisksByStorageMap = getRelatedCinderDisksToStorageDomainMap();
            Collection<CinderStorageRelatedDisksAndProxy> relatedCinderDisksByStorageCollection = relatedCinderDisksByStorageMap.values();
            for (CinderStorageRelatedDisksAndProxy relatedCinderDisksByStorage : relatedCinderDisksByStorageCollection) {
                Limits limits = relatedCinderDisksByStorage.getProxy().getLimits();
                int numOfDisks = relatedCinderDisksByStorage.getCinderDisks().size();
                if (isLimitExceeded(limits, CinderVolumeType.Volume, numOfDisks)) {
                    String storageName = getStorageDomainDao().get(relatedCinderDisksByStorage.getStorageDomainId()).getStorageName();
                    return new ValidationResult(VdcBllMessages.CANNOT_ADD_CINDER_DISK_VOLUME_LIMIT_EXCEEDED, String.format("$maxTotalVolumes %d", limits.getAbsolute().getMaxTotalVolumes()), String.format("$storageName %s", storageName));
                }
            }
            return ValidationResult.VALID;
        }
    });
}
#method_after
public ValidationResult validateCinderDiskLimits() {
    return validate(new Callable<ValidationResult>() {

        @Override
        public ValidationResult call() {
            Map<Guid, CinderStorageRelatedDisksAndProxy> relatedCinderDisksByStorageMap = getRelatedCinderDisksToStorageDomainMap();
            Collection<CinderStorageRelatedDisksAndProxy> relatedCinderDisksByStorageCollection = relatedCinderDisksByStorageMap.values();
            for (CinderStorageRelatedDisksAndProxy relatedCinderDisksByStorage : relatedCinderDisksByStorageCollection) {
                Limits limits = relatedCinderDisksByStorage.getProxy().getLimits();
                int numOfDisks = relatedCinderDisksByStorage.getCinderDisks().size();
                if (isLimitExceeded(limits, VolumeClassification.Volume, numOfDisks)) {
                    String storageName = getStorageDomainDao().get(relatedCinderDisksByStorage.getStorageDomainId()).getStorageName();
                    return new ValidationResult(VdcBllMessages.CANNOT_ADD_CINDER_DISK_VOLUME_LIMIT_EXCEEDED, String.format("$maxTotalVolumes %d", limits.getAbsolute().getMaxTotalVolumes()), String.format("$storageName %s", storageName));
                }
            }
            return ValidationResult.VALID;
        }
    });
}
#end_block

#method_before
public ValidationResult validateCinderDiskSnapshotsLimits() {
    return validate(new Callable<ValidationResult>() {

        @Override
        public ValidationResult call() {
            Map<Guid, CinderStorageRelatedDisksAndProxy> relatedCinderDisksByStorageMap = getRelatedCinderDisksToStorageDomainMap();
            Collection<CinderStorageRelatedDisksAndProxy> relatedCinderDisksByStorageCollection = relatedCinderDisksByStorageMap.values();
            for (CinderStorageRelatedDisksAndProxy relatedCinderDisksByStorage : relatedCinderDisksByStorageCollection) {
                Limits limits = relatedCinderDisksByStorage.getProxy().getLimits();
                int numOfDisks = relatedCinderDisksByStorage.getCinderDisks().size();
                if (isLimitExceeded(limits, CinderVolumeType.Snapshot, numOfDisks)) {
                    String storageName = getStorageDomainDao().get(relatedCinderDisksByStorage.getStorageDomainId()).getStorageName();
                    return new ValidationResult(VdcBllMessages.CANNOT_ADD_CINDER_DISK_SNAPSHOT_LIMIT_EXCEEDED, String.format("$maxTotalSnapshots %d", limits.getAbsolute().getMaxTotalVolumes()), String.format("$storageName %s", storageName));
                }
            }
            return ValidationResult.VALID;
        }
    });
}
#method_after
public ValidationResult validateCinderDiskSnapshotsLimits() {
    return validate(new Callable<ValidationResult>() {

        @Override
        public ValidationResult call() {
            Map<Guid, CinderStorageRelatedDisksAndProxy> relatedCinderDisksByStorageMap = getRelatedCinderDisksToStorageDomainMap();
            Collection<CinderStorageRelatedDisksAndProxy> relatedCinderDisksByStorageCollection = relatedCinderDisksByStorageMap.values();
            for (CinderStorageRelatedDisksAndProxy relatedCinderDisksByStorage : relatedCinderDisksByStorageCollection) {
                Limits limits = relatedCinderDisksByStorage.getProxy().getLimits();
                int numOfDisks = relatedCinderDisksByStorage.getCinderDisks().size();
                if (isLimitExceeded(limits, VolumeClassification.Snapshot, numOfDisks)) {
                    String storageName = getStorageDomainDao().get(relatedCinderDisksByStorage.getStorageDomainId()).getStorageName();
                    return new ValidationResult(VdcBllMessages.CANNOT_ADD_CINDER_DISK_SNAPSHOT_LIMIT_EXCEEDED, String.format("$maxTotalSnapshots %d", limits.getAbsolute().getMaxTotalVolumes()), String.format("$storageName %s", storageName));
                }
            }
            return ValidationResult.VALID;
        }
    });
}
#end_block

#method_before
private boolean isLimitExceeded(Limits limits, CinderVolumeType cinderType, int diskCount) {
    if (cinderType == CinderVolumeType.Snapshot) {
        return (limits.getAbsolute().getTotalSnapshotsUsed() + diskCount >= limits.getAbsolute().getMaxTotalSnapshots());
    }
    if (cinderType == CinderVolumeType.Volume) {
        return (limits.getAbsolute().getTotalVolumesUsed() + diskCount >= limits.getAbsolute().getMaxTotalVolumes());
    }
    return false;
}
#method_after
private boolean isLimitExceeded(Limits limits, VolumeClassification cinderType, int diskCount) {
    if (cinderType == VolumeClassification.Snapshot) {
        return (limits.getAbsolute().getTotalSnapshotsUsed() + diskCount >= limits.getAbsolute().getMaxTotalSnapshots());
    }
    if (cinderType == VolumeClassification.Volume) {
        return (limits.getAbsolute().getTotalVolumesUsed() + diskCount >= limits.getAbsolute().getMaxTotalVolumes());
    }
    return false;
}
#end_block

#method_before
@Override
public void onFailed(Guid cmdId, List<Guid> childCmdIds) {
    super.onFailed(cmdId, childCmdIds);
    onFinish(cmdId);
}
#method_after
@Override
public void onFailed(Guid cmdId, List<Guid> childCmdIds) {
    log.error("Failed adding a Cinder snapshot. snapshot ID: {}", getDiskId());
    super.onFailed(cmdId, childCmdIds);
    getCommand().getParameters().setTaskGroupSuccess(false);
    onFinish(cmdId);
}
#end_block

#method_before
@Override
protected Guid getDiskId() {
    return getCommand().getParameters().getDestinationImageId();
}
#method_after
@Override
protected Guid getDiskId() {
    // We actually using the destination image id and not the disk id, but the API is strict.
    return getCommand().getParameters().getDestinationImageId();
}
#end_block

#method_before
private ImagesContainterParametersBase buildChildCommandParameters(DiskImage snapshotCinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(snapshotCinderDisk.getImageId());
    createParams.setDestinationImageId(snapshotCinderDisk.getImageId());
    createParams.setStorageDomainId(snapshotCinderDisk.getStorageIds().get(0));
    createParams.setParentHasTasks(isImagesExists());
    return withRootCommandInfo(createParams, getActionType());
}
#method_after
private ImagesContainterParametersBase buildChildCommandParameters(DiskImage snapshotCinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(snapshotCinderDisk.getImageId());
    createParams.setDestinationImageId(snapshotCinderDisk.getImageId());
    createParams.setStorageDomainId(snapshotCinderDisk.getStorageIds().get(0));
    createParams.setParentHasTasks(isContainImages());
    return withRootCommandInfo(createParams, getActionType());
}
#end_block

#method_before
private void removeImages() {
    for (final DiskImage source : getSourceImages()) {
        if (source.getDiskStorageType() == DiskStorageType.CINDER) {
            ImagesContainterParametersBase params = buildChildCommandParameters(source);
            Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveCinderSnapshotDisk, params, cloneContextAndDetachFromParent());
            try {
                VdcReturnValueBase vdcReturnValueBase = future.get();
                if (!vdcReturnValueBase.getSucceeded()) {
                    log.error("Error creating snapshot for Cinder disk '{}'", source.getDiskAlias());
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error creating snapshot for Cinder disk '{}': {}", source.getDiskAlias(), e.getMessage());
            }
            continue;
        }
        // The following is ok because we have tested in the candoaction that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        List<DiskImage> images = getDiskImageDao().getAllSnapshotsForParent(source.getImageId());
        DiskImage dest = null;
        if (!images.isEmpty()) {
            dest = images.get(0);
        }
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDisk) {
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest));
            if (vdcReturnValue != null && vdcReturnValue.getInternalVdsmTaskIdList() != null) {
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            }
        } else {
            CommandCoordinatorUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest), cloneContextAndDetachFromParent());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        if (dest != null) {
            quotasToRemoveFromCache.add(dest.getQuotaId());
        }
        QuotaManager.getInstance().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
}
#method_after
private void removeImages() {
    for (final DiskImage source : getSourceImages()) {
        if (source.getDiskStorageType() == DiskStorageType.CINDER) {
            handleCinderSnapshotDisk(source);
            continue;
        }
        // The following is ok because we have tested in the candoaction that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        List<DiskImage> images = getDiskImageDao().getAllSnapshotsForParent(source.getImageId());
        DiskImage dest = null;
        if (!images.isEmpty()) {
            dest = images.get(0);
        }
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDisk) {
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest));
            if (vdcReturnValue != null && vdcReturnValue.getInternalVdsmTaskIdList() != null) {
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            }
        } else {
            CommandCoordinatorUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest), cloneContextAndDetachFromParent());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        if (dest != null) {
            quotasToRemoveFromCache.add(dest.getQuotaId());
        }
        getQuotaManager().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
}
#end_block

#method_before
private List<DiskImage> getDiskImagesForVm() {
    List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
    List<DiskImage> allDisks = ImagesHandler.filterImageDisks(disks, true, true, true);
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(disks);
    allDisks.addAll(cinderDisks);
    return allDisks;
}
#method_after
private List<DiskImage> getDiskImagesForVm() {
    List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
    List<DiskImage> allDisks = new ArrayList<>(getDiskImages(disks));
    allDisks.addAll(ImagesHandler.getCinderLeafImages(disks, true));
    return allDisks;
}
#end_block

#method_before
protected List<DiskImage> getDisksList() {
    if (cachedSelectedActiveDisks == null) {
        List<DiskImage> imagesAndCinderForVm = getFilteredDisksForSnapshot();
        // Get disks from the specified parameters or according to the VM
        if (getParameters().getDisks() == null) {
            cachedSelectedActiveDisks = imagesAndCinderForVm;
        } else {
            // Get selected images from 'DiskImagesForVm' to ensure disks entities integrity
            // (i.e. only images' IDs and Cinders' IDs are relevant).
            cachedSelectedActiveDisks = ImagesHandler.imagesIntersection(imagesAndCinderForVm, getParameters().getDisks());
        }
    }
    return cachedSelectedActiveDisks;
}
#method_after
protected List<DiskImage> getDisksList() {
    if (cachedSelectedActiveDisks == null) {
        List<DiskImage> imagesAndCinderForVm = getDiskImagesForVm();
        // Get disks from the specified parameters or according to the VM
        if (getParameters().getDisks() == null) {
            cachedSelectedActiveDisks = imagesAndCinderForVm;
        } else {
            // Get selected images from 'DiskImagesForVm' to ensure disks entities integrity
            // (i.e. only images' IDs and Cinders' IDs are relevant).
            cachedSelectedActiveDisks = ImagesHandler.imagesIntersection(imagesAndCinderForVm, getParameters().getDisks());
        }
    }
    return cachedSelectedActiveDisks;
}
#end_block

#method_before
public boolean validateCinder() {
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(DbFacade.getInstance().getDiskDao().getAllForVm(getVmId()));
    if (!cinderDisks.isEmpty()) {
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
        return validate(cinderDisksValidator.validateCinderDiskSnapshotsLimits());
    }
    return true;
}
#method_after
public boolean validateCinder() {
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(DbFacade.getInstance().getDiskDao().getAllForVm(getVmId()));
    if (!cinderDisks.isEmpty()) {
        CinderDisksValidator cinderDisksValidator = getCinderDisksValidator(cinderDisks);
        return validate(cinderDisksValidator.validateCinderDiskSnapshotsLimits());
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    createSnapshotsForDisks();
    fastForwardDisksToActiveSnapshot();
    memoryImageBuilder.build();
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    createSnapshotsForDisks();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    fastForwardDisksToActiveSnapshot();
    memoryImageBuilder.build();
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#end_block

#method_before
public Guid getStorageDomainIdForVmMemory(List<DiskImage> memoryDisksList) {
    if (cachedStorageDomainId.equals(Guid.Empty) && getVm() != null) {
        StorageDomain storageDomain = VmHandler.findStorageDomainForMemory(getVm().getStoragePoolId(), memoryDisksList);
        if (storageDomain != null) {
            cachedStorageDomainId = storageDomain.getId();
        }
    }
    return cachedStorageDomainId;
}
#method_after
public Guid getStorageDomainIdForVmMemory(List<DiskImage> memoryDisksList) {
    if (cachedStorageDomainId.equals(Guid.Empty) && getVm() != null) {
        StorageDomain storageDomain = MemoryStorageHandler.getInstance().findStorageDomainForMemory(getVm().getStoragePoolId(), memoryDisksList, getDisksList());
        if (storageDomain != null) {
            cachedStorageDomainId = storageDomain.getId();
        }
    }
    return cachedStorageDomainId;
}
#end_block

#method_before
private Snapshot addSnapshotToDB(Guid snapshotId, MemoryImageBuilder memoryImageBuilder) {
    boolean taskExists = !getDisksList().isEmpty() || memoryImageBuilder.isCreateTasks();
    return new SnapshotsManager().addSnapshot(snapshotId, getParameters().getDescription(), taskExists ? SnapshotStatus.LOCKED : SnapshotStatus.OK, getParameters().getSnapshotType(), getVm(), true, memoryImageBuilder.getVolumeStringRepresentation(), getDisksList(), getCompensationContext());
}
#method_after
private Snapshot addSnapshotToDB(Guid snapshotId, MemoryImageBuilder memoryImageBuilder) {
    // Reset cachedSelectedActiveDisks so new Cinder volumes can be fetched when calling getDisksList.
    cachedSelectedActiveDisks = null;
    boolean taskExists = !getDisksList().isEmpty() || memoryImageBuilder.isCreateTasks();
    return new SnapshotsManager().addSnapshot(snapshotId, getParameters().getDescription(), taskExists ? SnapshotStatus.LOCKED : SnapshotStatus.OK, getParameters().getSnapshotType(), getVm(), true, memoryImageBuilder.getVolumeStringRepresentation(), getDisksList(), getCompensationContext());
}
#end_block

#method_before
private ImagesContainterParametersBase buildChildCommandParameters(DiskImage cinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(cinderDisk.getId());
    createParams.setVmSnapshotId(newActiveSnapshotId);
    createParams.setParentHasTasks(isImagesExists());
    return withRootCommandInfo(createParams, getActionType());
}
#method_after
private ImagesContainterParametersBase buildChildCommandParameters(DiskImage cinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(cinderDisk.getId());
    createParams.setVmSnapshotId(newActiveSnapshotId);
    createParams.setParentHasTasks(!cachedImagesDisks.isEmpty());
    return withRootCommandInfo(createParams, getActionType());
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    if (CommandCoordinatorUtil.getChildCommandIds(getCommandId()).size() > 1) {
        log.info("There are still running Coco tasks");
        return;
    }
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = isLiveSnapshotApplicable();
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#method_after
@Override
protected void endVmCommand() {
    if (CommandCoordinatorUtil.getChildCommandIds(getCommandId()).size() > 1) {
        log.info("There are still running CoCo tasks");
        return;
    }
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = isLiveSnapshotApplicable();
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    super.endWithFailure();
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    getImageDao().remove(getImageId());
    if (!getParameters().isParentHasTasks()) {
        getBackend().endAction(getParameters().getParentCommand(), getParameters().getParentParameters(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        DiskImage curr = getDestinationDiskImage();
        DiskImage volumeBasedOnsnapshot = getDiskImageDao().getAllSnapshotsForLeaf(curr.getImageId()).get(0);
        getImageDao().remove(curr.getImageId());
        volumeBasedOnsnapshot.setParentId(curr.getParentId());
        getBaseDiskDao().update(volumeBasedOnsnapshot);
        getImageDao().update(volumeBasedOnsnapshot.getImage());
    }
    if (!getParameters().isParentHasTasks()) {
        getBackend().endAction(getParameters().getParentCommand(), getParameters().getParentParameters(), null);
    }
    setSucceeded(true);
}
#end_block

#method_before
private List<DiskImage> getDiskImagesForVm() {
    List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
    List<DiskImage> allDisks = ImagesHandler.filterImageDisks(disks, true, true, true);
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(disks);
    allDisks.addAll(cinderDisks);
    return allDisks;
}
#method_after
private List<DiskImage> getDiskImagesForVm() {
    List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
    List<DiskImage> allDisks = new ArrayList<>(getDiskImages(disks));
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(disks, true);
    for (CinderDisk cinder : cinderDisks) {
        allDisks.add(ImagesHandler.getSnapshotLeaf(cinder.getId()));
    }
    return allDisks;
}
#end_block

#method_before
protected List<DiskImage> getDisksList() {
    if (cachedSelectedActiveDisks == null) {
        List<DiskImage> imagesAndCinderForVm = getFilteredDisksForSnapshot();
        // Get disks from the specified parameters or according to the VM
        if (getParameters().getDisks() == null) {
            cachedSelectedActiveDisks = imagesAndCinderForVm;
        } else {
            // Get selected images from 'DiskImagesForVm' to ensure disks entities integrity
            // (i.e. only images' IDs and Cinders' IDs are relevant).
            cachedSelectedActiveDisks = ImagesHandler.imagesIntersection(imagesAndCinderForVm, getParameters().getDisks());
        }
    }
    return cachedSelectedActiveDisks;
}
#method_after
protected List<DiskImage> getDisksList() {
    if (cachedSelectedActiveDisks == null) {
        List<DiskImage> imagesAndCinderForVm = getDiskImagesForVm();
        // Get disks from the specified parameters or according to the VM
        if (getParameters().getDisks() == null) {
            cachedSelectedActiveDisks = imagesAndCinderForVm;
        } else {
            // Get selected images from 'DiskImagesForVm' to ensure disks entities integrity
            // (i.e. only images' IDs and Cinders' IDs are relevant).
            cachedSelectedActiveDisks = ImagesHandler.imagesIntersection(imagesAndCinderForVm, getParameters().getDisks());
        }
    }
    return cachedSelectedActiveDisks;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    createSnapshotsForDisks();
    fastForwardDisksToActiveSnapshot();
    memoryImageBuilder.build();
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    createSnapshotsForDisks();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    fastForwardDisksToActiveSnapshot();
    memoryImageBuilder.build();
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#end_block

#method_before
public Guid getStorageDomainIdForVmMemory(List<DiskImage> memoryDisksList) {
    if (cachedStorageDomainId.equals(Guid.Empty) && getVm() != null) {
        StorageDomain storageDomain = VmHandler.findStorageDomainForMemory(getVm().getStoragePoolId(), memoryDisksList);
        if (storageDomain != null) {
            cachedStorageDomainId = storageDomain.getId();
        }
    }
    return cachedStorageDomainId;
}
#method_after
public Guid getStorageDomainIdForVmMemory(List<DiskImage> memoryDisksList) {
    if (cachedStorageDomainId.equals(Guid.Empty) && getVm() != null) {
        StorageDomain storageDomain = MemoryStorageHandler.getInstance().findStorageDomainForMemory(getVm().getStoragePoolId(), memoryDisksList, getDisksList());
        if (storageDomain != null) {
            cachedStorageDomainId = storageDomain.getId();
        }
    }
    return cachedStorageDomainId;
}
#end_block

#method_before
private Snapshot addSnapshotToDB(Guid snapshotId, MemoryImageBuilder memoryImageBuilder) {
    boolean taskExists = !getDisksList().isEmpty() || memoryImageBuilder.isCreateTasks();
    return new SnapshotsManager().addSnapshot(snapshotId, getParameters().getDescription(), taskExists ? SnapshotStatus.LOCKED : SnapshotStatus.OK, getParameters().getSnapshotType(), getVm(), true, memoryImageBuilder.getVolumeStringRepresentation(), getDisksList(), getCompensationContext());
}
#method_after
private Snapshot addSnapshotToDB(Guid snapshotId, MemoryImageBuilder memoryImageBuilder) {
    // Reset cachedSelectedActiveDisks so new Cinder volumes can be fetched when calling getDisksList.
    cachedSelectedActiveDisks = null;
    boolean taskExists = !getDisksList().isEmpty() || memoryImageBuilder.isCreateTasks();
    return new SnapshotsManager().addSnapshot(snapshotId, getParameters().getDescription(), taskExists ? SnapshotStatus.LOCKED : SnapshotStatus.OK, getParameters().getSnapshotType(), getVm(), true, memoryImageBuilder.getVolumeStringRepresentation(), getDisksList(), getCompensationContext());
}
#end_block

#method_before
private ImagesContainterParametersBase buildChildCommandParameters(DiskImage cinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(cinderDisk.getId());
    createParams.setVmSnapshotId(newActiveSnapshotId);
    createParams.setParentHasTasks(isImagesExists());
    return withRootCommandInfo(createParams, getActionType());
}
#method_after
private ImagesContainterParametersBase buildChildCommandParameters(DiskImage cinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(cinderDisk.getId());
    createParams.setVmSnapshotId(newActiveSnapshotId);
    createParams.setParentHasTasks(!cachedImagesDisks.isEmpty());
    return withRootCommandInfo(createParams, getActionType());
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    if (CommandCoordinatorUtil.getChildCommandIds(getCommandId()).size() > 1) {
        log.info("There are still running Coco tasks");
        return;
    }
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = isLiveSnapshotApplicable();
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#method_after
@Override
protected void endVmCommand() {
    if (CommandCoordinatorUtil.getChildCommandIds(getCommandId()).size() > 1) {
        log.info("There are still running CoCo tasks");
        return;
    }
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = isLiveSnapshotApplicable();
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#end_block

#method_before
private List<DiskImage> getDiskImagesForVm() {
    List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
    List<DiskImage> allDisks = ImagesHandler.filterImageDisks(disks, true, true, true);
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(disks);
    allDisks.addAll(cinderDisks);
    return allDisks;
}
#method_after
private List<DiskImage> getDiskImagesForVm() {
    List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
    List<DiskImage> allDisks = new ArrayList<>(getDiskImages(disks));
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(disks, true);
    for (CinderDisk cinder : cinderDisks) {
        allDisks.add(ImagesHandler.getSnapshotLeaf(cinder.getId()));
    }
    return allDisks;
}
#end_block

#method_before
protected List<DiskImage> getDisksList() {
    if (cachedSelectedActiveDisks == null) {
        List<DiskImage> imagesAndCinderForVm = getFilteredDisksForSnapshot();
        // Get disks from the specified parameters or according to the VM
        if (getParameters().getDisks() == null) {
            cachedSelectedActiveDisks = imagesAndCinderForVm;
        } else {
            // Get selected images from 'DiskImagesForVm' to ensure disks entities integrity
            // (i.e. only images' IDs and Cinders' IDs are relevant).
            cachedSelectedActiveDisks = ImagesHandler.imagesIntersection(imagesAndCinderForVm, getParameters().getDisks());
        }
    }
    return cachedSelectedActiveDisks;
}
#method_after
protected List<DiskImage> getDisksList() {
    if (cachedSelectedActiveDisks == null) {
        List<DiskImage> imagesAndCinderForVm = getDiskImagesForVm();
        // Get disks from the specified parameters or according to the VM
        if (getParameters().getDisks() == null) {
            cachedSelectedActiveDisks = imagesAndCinderForVm;
        } else {
            // Get selected images from 'DiskImagesForVm' to ensure disks entities integrity
            // (i.e. only images' IDs and Cinders' IDs are relevant).
            cachedSelectedActiveDisks = ImagesHandler.imagesIntersection(imagesAndCinderForVm, getParameters().getDisks());
        }
    }
    return cachedSelectedActiveDisks;
}
#end_block

#method_before
public Guid getStorageDomainIdForVmMemory(List<DiskImage> memoryDisksList) {
    if (cachedStorageDomainId.equals(Guid.Empty) && getVm() != null) {
        StorageDomain storageDomain = VmHandler.findStorageDomainForMemory(getVm().getStoragePoolId(), memoryDisksList);
        if (storageDomain != null) {
            cachedStorageDomainId = storageDomain.getId();
        }
    }
    return cachedStorageDomainId;
}
#method_after
public Guid getStorageDomainIdForVmMemory(List<DiskImage> memoryDisksList) {
    if (cachedStorageDomainId.equals(Guid.Empty) && getVm() != null) {
        StorageDomain storageDomain = MemoryStorageHandler.getInstance().findStorageDomainForMemory(getVm().getStoragePoolId(), memoryDisksList, getDisksList());
        if (storageDomain != null) {
            cachedStorageDomainId = storageDomain.getId();
        }
    }
    return cachedStorageDomainId;
}
#end_block

#method_before
private VolumeClassification removeCinderVolume(CinderDisk volume) {
    VolumeClassification cinderVolumeType = volume.getVolumeClassification();
    if (cinderVolumeType == VolumeClassification.Volume) {
        getCinderBroker().deleteDisk(volume);
    } else if (cinderVolumeType == VolumeClassification.Snapshot) {
        getCinderBroker().deleteSnapshot(volume.getImageId());
    } else {
        log.error("Error, could not determine Cinder entity {} with id {} from Cinder provider.", volume.getDiskAlias(), volume.getImageId());
    }
    return cinderVolumeType;
}
#method_after
private VolumeClassification removeCinderVolume(CinderDisk volume) {
    VolumeClassification cinderVolumeType = volume.getVolumeClassification();
    if (cinderVolumeType == VolumeClassification.Volume) {
        getCinderBroker().deleteVolume(volume);
    } else if (cinderVolumeType == VolumeClassification.Snapshot) {
        getCinderBroker().deleteSnapshot(volume.getImageId());
    } else {
        log.error("Error, could not determine Cinder entity {} with id {} from Cinder provider.", volume.getDiskAlias(), volume.getImageId());
    }
    return cinderVolumeType;
}
#end_block

#method_before
protected void removeDiskFromDb(final CinderDisk lastCinderVolume) {
    final Snapshot updated = getSnapshot(lastCinderVolume);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            // If the image being removed has the same id as the disk id, we should remove the disk.
            if (lastCinderVolume.getImageId().equals(getDisk().getImageId())) {
                getDbFacade().getVmDeviceDao().remove(new VmDeviceId(lastCinderVolume.getId(), null));
                getBaseDiskDao().remove(lastCinderVolume.getId());
            }
            getImageStorageDomainMapDao().remove(lastCinderVolume.getImageId());
            getImageDao().remove(lastCinderVolume.getImageId());
            getDiskImageDynamicDAO().remove(lastCinderVolume.getImageId());
            if (updated != null) {
                getSnapshotDao().update(updated);
            }
            return null;
        }
    });
}
#method_after
protected void removeDiskFromDb(final CinderDisk lastCinderVolume) {
    final Snapshot updated = getSnapshot(lastCinderVolume);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            // If the image being removed has the same id as the disk id, we should remove the disk.
            if (lastCinderVolume.getImageId().equals(getDisk().getImageId())) {
                getDbFacade().getVmDeviceDao().remove(new VmDeviceId(lastCinderVolume.getId(), null));
                getBaseDiskDao().remove(lastCinderVolume.getId());
            }
            getImageStorageDomainMapDao().remove(lastCinderVolume.getImageId());
            getImageDao().remove(lastCinderVolume.getImageId());
            getDiskImageDynamicDAO().remove(lastCinderVolume.getImageId());
            getSnapshotDao().update(updated);
            return null;
        }
    });
}
#end_block

#method_before
protected String getDiskAlias() {
    if (getDisk() != null) {
        return getDisk().getDiskAlias();
    }
    return "";
}
#method_after
protected String getDiskAlias() {
    if (getDisk() != null) {
        return getDisk().getDiskAlias();
    }
    return StringUtils.EMPTY;
}
#end_block

#method_before
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    super.doPolling(cmdId, childCmdIds);
    ImageStatus imageStatus = getCinderBroker().getSnapshotStatus(getDiskId());
    DiskImage disk = getDisk();
    if (imageStatus != null && imageStatus != disk.getImageStatus()) {
        switch(imageStatus) {
            case OK:
                getCommand().setCommandStatus(CommandStatus.SUCCEEDED);
                break;
            case ILLEGAL:
                getCommand().setCommandStatus(CommandStatus.FAILED);
                break;
        }
    }
}
#method_after
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    super.doPolling(cmdId, childCmdIds);
    if (!getCinderBroker().isSnapshotExist(getDiskId())) {
        // Cinder snapshot has been deleted successfully
        getCommand().setCommandStatus(CommandStatus.SUCCEEDED);
        return;
    }
    ImageStatus imageStatus = getCinderBroker().getSnapshotStatus(getDiskId());
    DiskImage disk = getDisk();
    if (imageStatus != null && imageStatus != disk.getImageStatus()) {
        switch(imageStatus) {
            case ILLEGAL:
                getCommand().setCommandStatus(CommandStatus.FAILED);
                break;
        }
    }
}
#end_block

#method_before
@Override
public void onFailed(Guid cmdId, List<Guid> childCmdIds) {
    super.onFailed(cmdId, childCmdIds);
    // If the cinder disk has a snapshot and it is not a part of a template.
    if ((!getDisk().getParentId().equals(Guid.Empty)) && (!getDisk().getParentId().equals(getDisk().getImageTemplateId()))) {
        DiskImage previousSnapshot = getDiskImageDAO().getSnapshotById(getDisk().getParentId());
        previousSnapshot.setActive(true);
        getImageDao().update(previousSnapshot.getImage());
    }
    onFinish(cmdId);
}
#method_after
@Override
public void onFailed(Guid cmdId, List<Guid> childCmdIds) {
    super.onFailed(cmdId, childCmdIds);
    // If the cinder disk has a snapshot and it is not a part of a template.
    if ((!getDisk().getParentId().equals(Guid.Empty)) && (!getDisk().getParentId().equals(getDisk().getImageTemplateId()))) {
        DiskImage previousSnapshot = getDiskImageDAO().getSnapshotById(getDisk().getParentId());
        previousSnapshot.setActive(true);
        getImageDao().update(previousSnapshot.getImage());
    }
    getCommand().getParameters().setTaskGroupSuccess(false);
    onFinish(cmdId);
}
#end_block

#method_before
public Integer getWarningLowSpaceSize() {
    return getWarningLowSpaceIndicator() == null ? 0 : getTotalDiskSize() * getWarningLowSpaceIndicator() / 100;
}
#method_after
public int getWarningLowSpaceSize() {
    return getWarningLowSpaceIndicator() == null ? 0 : getTotalDiskSize() * getWarningLowSpaceIndicator() / 100;
}
#end_block

#method_before
public final boolean IsDynamicVariable(String strMessage) {
    return strMessage.startsWith("$");
}
#method_after
public final boolean IsDynamicVariable(String strMessage) {
    return startsWithVariableDefinitionPattern.matcher(strMessage).matches();
}
#end_block

#method_before
public final List<String> ResolveMessages(List<String> translatedMessages) {
    ArrayList<String> translatedErrors = new ArrayList<String>();
    HashMap<String, String> variables = new HashMap<String, String>();
    for (String currentMessage : translatedMessages) {
        if (startsWithVariableDefinition(currentMessage)) {
            AddVariable(currentMessage, variables);
        } else {
            translatedErrors.add(currentMessage);
        }
    }
    /**
     * Place to global variable adding
     */
    ArrayList<String> returnValue = new ArrayList<String>();
    for (String error : translatedErrors) {
        returnValue.add(resolveMessage(error, variables));
    }
    return returnValue;
}
#method_after
public final List<String> ResolveMessages(List<String> translatedMessages) {
    ArrayList<String> translatedErrors = new ArrayList<String>();
    HashMap<String, String> variables = new HashMap<String, String>();
    for (String currentMessage : translatedMessages) {
        if (IsDynamicVariable(currentMessage)) {
            AddVariable(currentMessage, variables);
        } else {
            translatedErrors.add(currentMessage);
        }
    }
    /**
     * Place to global variable adding
     */
    ArrayList<String> returnValue = new ArrayList<String>();
    for (String error : translatedErrors) {
        returnValue.add(resolveMessage(error, variables));
    }
    return returnValue;
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveVmTemplate, new VmTemplateParametersBase(asGuid(id)));
}
#method_after
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveVmTemplate, new VmTemplateParametersBase(guid));
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("%s, diskId = %s", super.toString(), disk.getId());
}
#method_after
@Override
public String toString() {
    return String.format("%s, diskId = %s, addressMap = %s", super.toString(), disk.getId(), getAddressMap());
}
#end_block

#method_before
@Test
public void testRemoveNonExistant() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetMacPoolById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { NON_EXISTANT_GUID }, null);
    control.replay();
    try {
        resource.guid = NON_EXISTANT_GUID;
        resource.remove();
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        assertNotNull(wae.getResponse());
        assertEquals(404, wae.getResponse().getStatus());
    }
}
#method_after
@Test
public void testRemoveNonExistant() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetMacPoolById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { MAC_POOL_ID }, null);
    control.replay();
    try {
        resource.remove();
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        assertNotNull(wae.getResponse());
        assertEquals(404, wae.getResponse().getStatus());
    }
}
#end_block

#method_before
@Override
@DELETE
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveMacPool, new RemoveMacPoolByIdParameters(asGuid(id)));
}
#method_after
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveMacPool, new RemoveMacPoolByIdParameters(guid));
}
#end_block

#method_before
private Map<String, Object> initDriveData() {
    Map<String, Object> drive = new HashMap<String, Object>();
    Disk disk = getParameters().getDisk();
    VmDevice vmDevice = getParameters().getVmDevice();
    drive.put(VdsProperties.Type, VmDeviceType.DISK.getName());
    addAddress(drive, getParameters().getVmDevice().getAddress());
    drive.put(VdsProperties.INTERFACE, disk.getDiskInterface().getName());
    drive.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(getParameters().getVm().getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
    drive.put(VdsProperties.Optional, Boolean.FALSE.toString());
    drive.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
    drive.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) disk;
        drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
        drive.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
        drive.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
        drive.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
        drive.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
        drive.put(VdsProperties.ImageId, diskImage.getId().toString());
        drive.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
        VmInfoBuilder.handleIoTune(getParameters().getVm(), vmDevice, diskImage, new HashMap<Guid, Guid>(), new HashMap<Guid, Map<String, Long>>());
        if (vmDevice.getSpecParams() != null) {
            drive.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        }
    } else {
        LunDisk lunDisk = (LunDisk) disk;
        // If SCSI pass-through is enabled (VirtIO-SCSI/DirectLUN disk and SGIO is defined),
        // set device type as 'lun' (instead of 'disk') and set the specified SGIO
        boolean isVirtioScsi = getParameters().getDisk().getDiskInterface() == DiskInterface.VirtIO_SCSI;
        boolean isScsiPassthrough = getParameters().getDisk().isScsiPassthrough();
        if (isVirtioScsi) {
            if (isScsiPassthrough) {
                drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                drive.put(VdsProperties.Sgio, getParameters().getDisk().getSgio().toString().toLowerCase());
            } else {
                drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            }
        } else {
            drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
        }
        drive.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
        drive.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
        drive.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
    }
    return drive;
}
#method_after
private Map<String, Object> initDriveData() {
    Map<String, Object> drive = new HashMap<String, Object>();
    Disk disk = getParameters().getDisk();
    VmDevice vmDevice = getParameters().getVmDevice();
    drive.put(VdsProperties.Type, VmDeviceType.DISK.getName());
    drive.put(VdsProperties.Address, getParameters().getAddressMap());
    drive.put(VdsProperties.INTERFACE, disk.getDiskInterface().getName());
    int numOfIoThreads = getParameters().getVm().getNumOfIoThreads();
    if (numOfIoThreads != 0 && disk.getDiskInterface() == DiskInterface.VirtIO) {
        if (vmDevice.getSpecParams() == null) {
            vmDevice.setSpecParams(new HashMap<String, Object>());
        }
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId(), false);
        int numOfAttachedVirtioInterfaces = 0;
        for (Disk oneDisk : allDisks) {
            if (oneDisk.getPlugged() && oneDisk.getDiskInterface() == DiskInterface.VirtIO) {
                numOfAttachedVirtioInterfaces++;
            }
        }
        int pinToIoThread = numOfAttachedVirtioInterfaces % numOfIoThreads + 1;
        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinToIoThread);
    }
    drive.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(getParameters().getVm().getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
    drive.put(VdsProperties.Optional, Boolean.FALSE.toString());
    drive.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
    drive.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            drive.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
            drive.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
            drive.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
            drive.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
            drive.put(VdsProperties.ImageId, diskImage.getId().toString());
            drive.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            VmInfoBuilder.handleIoTune(getParameters().getVm(), vmDevice, diskImage, new HashMap<Guid, Guid>(), new HashMap<Guid, Map<String, Long>>());
            if (vmDevice.getSpecParams() != null) {
                drive.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            }
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            // If SCSI pass-through is enabled (VirtIO-SCSI/DirectLUN disk and SGIO is defined),
            // set device type as 'lun' (instead of 'disk') and set the specified SGIO
            boolean isVirtioScsi = getParameters().getDisk().getDiskInterface() == DiskInterface.VirtIO_SCSI;
            boolean isScsiPassthrough = getParameters().getDisk().isScsiPassthrough();
            if (isVirtioScsi) {
                if (isScsiPassthrough) {
                    drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    drive.put(VdsProperties.Sgio, getParameters().getDisk().getSgio().toString().toLowerCase());
                } else {
                    drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
                }
            } else {
                drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
            }
            drive.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
            drive.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
            drive.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            break;
        case CINDER:
            CinderDisk cinderDisk = (CinderDisk) disk;
            VmInfoBuilder.buildCinderDisk(cinderDisk, drive);
            drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            break;
    }
    return drive;
}
#end_block

#method_before
public Object getQueryableId() {
    return getUserId();
}
#method_after
@Override
public Object getQueryableId() {
    return getUserId();
}
#end_block

#method_before
public Object getQueryableId() {
    return getId();
}
#method_after
@Override
public Object getQueryableId() {
    return getId();
}
#end_block

#method_before
public Object getQueryableId() {
    return getVmId();
}
#method_after
@Override
public Object getQueryableId() {
    return getVmId();
}
#end_block

#method_before
public Object getQueryableId() {
    return getVolumeId();
}
#method_after
@Override
public Object getQueryableId() {
    return getVolumeId();
}
#end_block

#method_before
public Object getQueryableId() {
    return getId();
}
#method_after
@Override
public Object getQueryableId() {
    return getId();
}
#end_block

#method_before
public Object getQueryableId() {
    return getVmId();
}
#method_after
@Override
public Object getQueryableId() {
    return getVmId();
}
#end_block

#method_before
public Object getQueryableId() {
    return getId();
}
#method_after
@Override
public Object getQueryableId() {
    return getId();
}
#end_block

#method_before
public Object getQueryableId() {
    return getJobId();
}
#method_after
@Override
public Object getQueryableId() {
    return getJobId();
}
#end_block

#method_before
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<DiskImage> diskImages = ImagesHandler.filterImageDisks(mImages, true, false, true);
    for (DiskImage diskImage : diskImages) {
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildChildCommandParameters(diskImage, Guid.newGuid()), ExecutionHandler.createDefaultContextForTasks(getContext()));
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
        DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
        srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
    }
}
#method_after
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<DiskImage> diskImages = ImagesHandler.filterImageDisks(mImages, true, false, true);
    for (DiskImage diskImage : diskImages) {
        addVmTemplateImage(srcDeviceIdToTargetDeviceIdMapping, diskImage);
    }
}
#end_block

#method_before
@Override
public void templateWithVersion_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    buildModel(vm.getStaticData(), new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

        @Override
        public void finished(VmBase source, UnitVmModel destination) {
            getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
            updateCpuSharesSelection();
            updateRngDevice(getVm().getId());
            updateTimeZone(vm.getTimeZone());
            updateGraphics();
            getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
            // Storage domain and provisioning are not available for an existing VM.
            getModel().getStorageDomain().setIsChangeable(false);
            getModel().getProvisioning().setIsAvailable(false);
            getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
            getModel().getCpuPinning().setEntity(vm.getCpuPinning());
            getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
            if (isHotSetCpuSupported()) {
                // cancel related events while fetching data
                getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
                getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
                AsyncDataProvider.getInstance().getHostById(new AsyncQuery(getModel().getBehavior(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        ExistingVmModelBehavior existingVmModelBehavior = (ExistingVmModelBehavior) model;
                        runningOnHost = (VDS) returnValue;
                        hostCpu = calculateHostCpus();
                        existingVmModelBehavior.updateNumOfSockets();
                    }
                }), vm.getRunOnVds());
            }
            updateCpuProfile(vm.getVdsGroupId(), vm.getVdsGroupCompatibilityVersion(), vm.getCpuProfileId());
        }
    });
}
#method_after
@Override
public void templateWithVersion_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    buildModel(vm.getStaticData(), new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

        @Override
        public void finished(VmBase source, UnitVmModel destination) {
            getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
            updateCpuSharesSelection();
            updateRngDevice(getVm().getId());
            updateTimeZone(vm.getTimeZone());
            updateGraphics();
            getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
            // Storage domain and provisioning are not available for an existing VM.
            getModel().getStorageDomain().setIsChangeable(false);
            getModel().getProvisioning().setIsAvailable(false);
            getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
            getModel().getCpuPinning().setEntity(vm.getCpuPinning());
            getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
            if (isHotSetCpuSupported()) {
                // cancel related events while fetching data
                getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
                getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
                AsyncDataProvider.getInstance().getHostById(new AsyncQuery(new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        runningOnHost = (VDS) returnValue;
                        hostCpu = calculateHostCpus();
                        updateNumOfSockets();
                    }
                }), vm.getRunOnVds());
            }
            updateCpuProfile(vm.getVdsGroupId(), vm.getVdsGroupCompatibilityVersion(), vm.getCpuProfileId());
        }
    });
}
#end_block

#method_before
private Network createNetwork(String networkName) {
    return new Network("", "", Guid.newGuid(), networkName, "", "", 0, null, false, 0, true);
}
#method_after
private Network createNetwork(String networkName) {
    Network net = new Network("", "", Guid.newGuid(), networkName, "", "", 0, null, false, 0, true);
    net.setCluster(new NetworkCluster());
    return net;
}
#end_block

#method_before
private void validateNotRemovingGlusterBrickNetworks() {
    for (String network : removedNetworks) {
        Network removedNetwork = getExistingClusterNetworks().get(network);
        if (removedNetwork == null || removedNetwork.getCluster() == null || !removedNetwork.getCluster().isGluster()) {
            continue;
        }
        List<GlusterBrickEntity> bricks = getDbFacade().getGlusterBrickDao().getAllByClusterAndNetworkId(vds.getVdsGroupId(), removedNetwork.getId());
        if (!bricks.isEmpty()) {
            addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_NETWORK_FROM_BRICK, network);
        }
    }
}
#method_after
private void validateNotRemovingGlusterBrickNetworks() {
    for (String network : removedNetworks) {
        Network removedNetwork = getExistingClusterNetworks().get(network);
        if (removedNetwork == null || !removedNetwork.getCluster().isGluster()) {
            continue;
        }
        List<GlusterBrickEntity> bricks = getDbFacade().getGlusterBrickDao().getAllByClusterAndNetworkId(vds.getVdsGroupId(), removedNetwork.getId());
        if (!bricks.isEmpty()) {
            addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_NETWORK_FROM_BRICK, network);
        }
    }
}
#end_block

#method_before
/**
 * Checks if a network is configured incorrectly:
 * <ul>
 * <li>If the network is configured to use static IP address and the interface is used by gluster bricks, then it is
 * forbidden to modify the IP address without replacing the bricks.</li>
 * </ul>
 *
 * @param iface
 *            The network interface which carries the network
 * @return <code>true</code> if the network was reconfigured improperly
 */
private boolean networkIpAddressUsedByBrickChanged(VdsNetworkInterface iface, Network network) {
    if (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP) {
        List<GlusterBrickEntity> bricks = getDbFacade().getGlusterBrickDao().getAllByClusterAndNetworkId(vds.getVdsGroupId(), network.getId());
        if (bricks.isEmpty()) {
            return false;
        }
        VdsNetworkInterface existingIface = getExistingIfaceByNetwork(iface.getNetworkName());
        if (existingIface != null) {
            String oldAddress = existingIface.getAddress();
            return !StringUtils.equals(oldAddress, iface.getAddress());
        }
    }
    return false;
}
#method_after
/**
 * Checks if a network is configured incorrectly:
 * <ul>
 * <li>If the network is configured to use static IP address and the interface is used by gluster bricks, then it is
 * forbidden to modify the IP address without replacing the bricks.</li>
 * </ul>
 *
 * @param iface
 *            The network interface which carries the network
 * @return <code>true</code> if the network was reconfigured improperly
 */
private boolean networkIpAddressUsedByBrickChanged(VdsNetworkInterface iface, Network network) {
    if (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP) {
        List<GlusterBrickEntity> bricks = getDbFacade().getGlusterBrickDao().getAllByClusterAndNetworkId(vds.getVdsGroupId(), network.getId());
        if (bricks.isEmpty()) {
            return false;
        }
        VdsNetworkInterface existingIface = getExistingIfaceByNetwork(iface.getNetworkName());
        if (existingIface != null) {
            String oldAddress = existingIface.getAddress();
            return StringUtils.isNotEmpty(oldAddress) && !StringUtils.equals(oldAddress, iface.getAddress());
        }
    }
    return false;
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<NetworkView> nameColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(NetworkConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "200px");
    CommentColumn<NetworkView> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<NetworkView> dcColumn = new AbstractTextColumn<NetworkView>() {

            @Override
            public String getValue(NetworkView object) {
                return object.getDataCenterName();
            }
        };
        dcColumn.makeSortable(NetworkConditionFieldAutoCompleter.DATA_CENTER);
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcNetwork(), "200px");
    }
    AbstractTextColumn<NetworkView> descriptionColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(NetworkConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionNetwork(), "300px");
    AbstractSafeHtmlColumn<NetworkView> roleColumn = new AbstractSafeHtmlColumn<NetworkView>() {

        @Override
        public SafeHtml getValue(NetworkView networkView) {
            List<SafeHtml> images = new LinkedList<>();
            if (networkView.isVmNetwork()) {
                images.add(vmImage);
            } else {
                images.add(emptyImage);
            }
            return NetworkRoleColumnHelper.getValue(images);
        }

        @Override
        public SafeHtml getTooltip(NetworkView networkView) {
            Map<SafeHtml, String> imagesToText = new LinkedHashMap<>();
            if (networkView.isVmNetwork()) {
                imagesToText.put(vmImage, constants.vmItemInfo());
            }
            return NetworkRoleColumnHelper.getTooltip(imagesToText);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(roleColumn, constants.roleNetwork(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<NetworkView> vlanColumn = new AbstractTextColumn<NetworkView>() {

            @Override
            public String getValue(NetworkView object) {
                // $NON-NLS-1$
                return object.getVlanId() == null ? "-" : object.getVlanId().toString();
            }
        };
        vlanColumn.makeSortable(NetworkConditionFieldAutoCompleter.VLAN_ID);
        // $NON-NLS-1$
        getTable().addColumn(vlanColumn, constants.vlanNetwork(), "60px");
    }
    AbstractTextColumn<NetworkView> labelColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getLabel() == null ? "-" : object.getLabel();
        }
    };
    labelColumn.makeSortable(NetworkConditionFieldAutoCompleter.LABEL);
    // $NON-NLS-1$
    getTable().addColumn(labelColumn, constants.networkLabelNetworksTab(), "200px");
    providerColumn = new AbstractLinkColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getProvidedBy() == null ? "" : object.getProviderName();
        }
    };
    providerColumn.makeSortable(NetworkConditionFieldAutoCompleter.PROVIDER_NAME);
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        // $NON-NLS-1$
        getTable().addColumn(providerColumn, constants.providerNetwork(), "200px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.newNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.importNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.editNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.removeNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<NetworkView> nameColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(NetworkConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "200px");
    CommentColumn<NetworkView> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    boolean virtMode = ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly);
    AbstractTextColumn<NetworkView> dcColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDataCenterName();
        }
    };
    dcColumn.makeSortable(NetworkConditionFieldAutoCompleter.DATA_CENTER);
    // $NON-NLS-1$
    getTable().ensureColumnPresent(dcColumn, constants.dcNetwork(), virtMode, "200px");
    AbstractTextColumn<NetworkView> descriptionColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(NetworkConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionNetwork(), "300px");
    AbstractSafeHtmlColumn<NetworkView> roleColumn = new AbstractSafeHtmlColumn<NetworkView>() {

        @Override
        public SafeHtml getValue(NetworkView networkView) {
            List<SafeHtml> images = new LinkedList<>();
            if (networkView.isVmNetwork()) {
                images.add(vmImage);
            } else {
                images.add(emptyImage);
            }
            return NetworkRoleColumnHelper.getValue(images);
        }

        @Override
        public SafeHtml getTooltip(NetworkView networkView) {
            Map<SafeHtml, String> imagesToText = new LinkedHashMap<>();
            if (networkView.isVmNetwork()) {
                imagesToText.put(vmImage, constants.vmItemInfo());
            }
            return NetworkRoleColumnHelper.getTooltip(imagesToText);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(roleColumn, constants.roleNetwork(), "60px");
    AbstractTextColumn<NetworkView> vlanColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getVlanId() == null ? "-" : object.getVlanId().toString();
        }
    };
    vlanColumn.makeSortable(NetworkConditionFieldAutoCompleter.VLAN_ID);
    // $NON-NLS-1$
    getTable().ensureColumnPresent(vlanColumn, constants.vlanNetwork(), virtMode, "60px");
    AbstractTextColumn<NetworkView> labelColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getLabel() == null ? "-" : object.getLabel();
        }
    };
    labelColumn.makeSortable(NetworkConditionFieldAutoCompleter.LABEL);
    // $NON-NLS-1$
    getTable().addColumn(labelColumn, constants.networkLabelNetworksTab(), "200px");
    providerColumn = new AbstractLinkColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getProvidedBy() == null ? "" : object.getProviderName();
        }
    };
    providerColumn.makeSortable(NetworkConditionFieldAutoCompleter.PROVIDER_NAME);
    // $NON-NLS-1$
    getTable().ensureColumnPresent(providerColumn, constants.providerNetwork(), virtMode, "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.newNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.importNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.editNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.removeNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
@Override
public void updateVisibility() {
    messageLabel.setVisible(false);
    if (ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly) {
        externalProviderEditor.setVisible(false);
        neutronPhysicalNetwork.setVisible(false);
        createSubnetEditor.setVisible(false);
        vlanTagging.setVisible(false);
        vlanTag.setVisible(false);
        exportLabel.setVisible(false);
        exportEditor.setVisible(false);
        profilesTab.setVisible(false);
    }
}
#method_after
@Override
public void updateVisibility() {
    messageLabel.setVisible(false);
    exportLabel.setVisible(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getAsyncTask() != null && (volume.getAsyncTask().getType() == GlusterTaskType.REBALANCE || volume.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK)) {
        addCanDoActionMessageVariable("asyncTask", volume.getAsyncTask().getType().name().toLowerCase());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VOLUME_ASYNC_OPERATION_IN_PROGRESS);
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveVolumeId() == null || session.getSlaveNodeUuid() == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getAsyncTask() != null && (volume.getAsyncTask().getType() == GlusterTaskType.REBALANCE || volume.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK) && volume.getAsyncTask().getStatus() == JobExecutionStatus.STARTED) {
        addCanDoActionMessageVariable("asyncTask", volume.getAsyncTask().getType().name().toLowerCase());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VOLUME_ASYNC_OPERATION_IN_PROGRESS);
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveVolumeId() == null || session.getSlaveNodeUuid() == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getStatus() == GlusterStatus.DOWN) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
    }
    if (volume.getAsyncTask() != null && (volume.getAsyncTask().getType() == GlusterTaskType.REBALANCE || volume.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK)) {
        addCanDoActionMessageVariable("asyncTask", volume.getAsyncTask().getType().name().toLowerCase());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VOLUME_ASYNC_OPERATION_IN_PROGRESS);
    }
    if (!GlusterUtil.getInstance().isVolumeThinlyProvisioned(volume)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_NOT_THINLY_PROVISIONED);
    }
    if (getDbFacade().getGlusterVolumeSnapshotDao().getByName(getGlusterVolumeId(), snapshot.getSnapshotName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SNAPSHOT_ALREADY_EXISTS);
    }
    List<GlusterBrickEntity> bricks = volume.getBricks();
    for (GlusterBrickEntity brick : bricks) {
        if (!brick.isOnline()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_BRICKS_ARE_DOWN);
        }
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveNodeUuid() == null || session.getSlaveVolumeId() == null) {
            // the volume
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getStatus() == GlusterStatus.DOWN) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
    }
    if (volume.getAsyncTask() != null && (volume.getAsyncTask().getType() == GlusterTaskType.REBALANCE || volume.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK) && volume.getAsyncTask().getStatus() == JobExecutionStatus.STARTED) {
        addCanDoActionMessageVariable("asyncTask", volume.getAsyncTask().getType().name().toLowerCase());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VOLUME_ASYNC_OPERATION_IN_PROGRESS);
    }
    if (!GlusterUtil.getInstance().isVolumeThinlyProvisioned(volume)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_NOT_THINLY_PROVISIONED);
    }
    if (getDbFacade().getGlusterVolumeSnapshotDao().getByName(getGlusterVolumeId(), snapshot.getSnapshotName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SNAPSHOT_ALREADY_EXISTS);
    }
    List<GlusterBrickEntity> bricks = volume.getBricks();
    for (GlusterBrickEntity brick : bricks) {
        if (!brick.isOnline()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_BRICKS_ARE_DOWN);
        }
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveNodeUuid() == null || session.getSlaveVolumeId() == null) {
            // the volume
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#end_block

#method_before
protected String scheduleJob() {
    // convert the execution time to engine time zone
    if (schedule.getExecutionTime() != null) {
        Time convertedTime = GlusterUtil.getInstance().convertTime(schedule.getExecutionTime(), schedule.getTimeZone());
        schedule.setExecutionTime(convertedTime);
    }
    // convert the start date and end by date to the given timezone
    Date convertedStartDate = getGlusterUtil().convertDate(schedule.getStartDate(), schedule.getTimeZone());
    Date convertedEndByDate = getGlusterUtil().convertDate(schedule.getEndByDate(), schedule.getTimeZone());
    String cronExpression = GlusterUtil.getInstance().getCronExpression(schedule);
    if (cronExpression == null)
        return null;
    return DBSchedulerUtilQuartzImpl.getInstance().scheduleACronJob(new GlusterSnapshotScheduleJob(), "onTimer", new Class[] { String.class, String.class, String.class, String.class, Boolean.class }, new Object[] { upServer.getId().toString(), getGlusterVolumeId().toString(), schedule.getSnapshotNamePrefix(), schedule.getSnapshotDescription(), force }, cronExpression, convertedStartDate, convertedEndByDate);
}
#method_after
protected String scheduleJob() {
    // convert the execution time to engine time zone
    if (schedule.getExecutionTime() != null) {
        Time convertedTime = GlusterUtil.getInstance().convertTime(schedule.getExecutionTime(), schedule.getTimeZone());
        schedule.setExecutionTime(convertedTime);
    }
    // convert the start date and end by date to the given timezone
    Date convertedStartDate = getGlusterUtil().convertDate(schedule.getStartDate(), schedule.getTimeZone());
    Date convertedEndByDate = getGlusterUtil().convertDate(schedule.getEndByDate(), schedule.getTimeZone());
    String cronExpression = GlusterUtil.getInstance().getCronExpression(schedule);
    if (cronExpression == null)
        return null;
    return getDbSchedulUtil().scheduleACronJob(new GlusterSnapshotScheduleJob(), "onTimer", new Class[] { String.class, String.class, String.class, String.class, Boolean.class }, new Object[] { upServer.getId().toString(), getGlusterVolumeId().toString(), schedule.getSnapshotNamePrefix(), schedule.getSnapshotDescription(), force }, cronExpression, convertedStartDate, convertedEndByDate);
}
#end_block

#method_before
@Override
protected void initWidget(Widget widget) {
    container = DataCenterClusterListUiBinder.uiBinder.createAndBindUi(this);
    super.initWidget(container);
    container.insert(widget, 0);
    getListBox().addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            updateGroupLabel();
        }
    });
}
#method_after
@Override
protected void initWidget(Widget widget) {
    container = GroupedListUiBinder.uiBinder.createAndBindUi(this);
    super.initWidget(container);
    container.insert(widget, 0);
    getListBox().addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            updateGroupLabel();
        }
    });
}
#end_block

#method_before
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    clusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<VDSGroup>(new NameRenderer<VDSGroup>()) {

        @Override
        public SortedMap<String, List<VDSGroup>> getGroupedList(List<VDSGroup> acceptableValues) {
            SortedMap<String, List<VDSGroup>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
            Collections.sort(acceptableValues, new DataCenterClusterComparator());
            String currentDataCenter = null;
            List<VDSGroup> currentClusterList = null;
            for (VDSGroup cluster : acceptableValues) {
                if (currentDataCenter == null || !currentDataCenter.equals(cluster.getStoragePoolName())) {
                    if (currentDataCenter != null) {
                        result.put(currentDataCenter, currentClusterList);
                    }
                    currentClusterList = new ArrayList<>();
                    currentDataCenter = cluster.getStoragePoolName();
                }
                if (currentClusterList != null) {
                    currentClusterList.add(cluster);
                }
            }
            return result;
        }

        @Override
        public String getModelLabel(VDSGroup model) {
            return model.getName();
        }

        @Override
        public String getGroupLabel(VDSGroup model) {
            return messages.hostDataCenter(model.getStoragePoolName());
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterClusterComparator implements Comparator<VDSGroup> {

            @Override
            public int compare(VDSGroup cluster1, VDSGroup cluster2) {
                if (cluster1.getStoragePoolName() != null && cluster2.getStoragePoolName() == null) {
                    return -1;
                } else if (cluster2.getStoragePoolName() != null && cluster1.getStoragePoolName() == null) {
                    return 1;
                } else if (cluster1.getStoragePoolName() == null && cluster2.getStoragePoolName() == null) {
                    return 0;
                }
                if (cluster1.getStoragePoolName().equals(cluster2.getStoragePoolName())) {
                    return cluster1.getName().compareToIgnoreCase(cluster2.getName());
                } else {
                    return cluster1.getStoragePoolName().compareToIgnoreCase(cluster2.getStoragePoolName());
                }
            }
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider>());
    pmVariantsEditor = new ListModelListBoxOnlyEditor<>(new StringRenderer<String>());
    pmTypeEditor = new ListModelListBoxEditor<>(new StringRenderer<String>());
    pmSecondaryTypeEditor = new ListModelListBoxEditor<>(new StringRenderer<String>());
    externalDiscoveredHostsEditor = getListModelTypeAheadListBoxEditor();
    externalHostGroupsEditor = getListModelTypeAheadListBoxEditor();
    externalComputeResourceEditor = getListModelTypeAheadListBoxEditor();
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    overrideIpTablesEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    protocolEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new RadioButton("2");
    // $NON-NLS-1$
    rbProvisionedHost = new RadioButton("2");
}
#method_after
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    clusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<VDSGroup>(new NameRenderer<VDSGroup>()) {

        @Override
        public SortedMap<String, List<VDSGroup>> getGroupedList(List<VDSGroup> acceptableValues) {
            SortedMap<String, List<VDSGroup>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
            Collections.sort(acceptableValues, new DataCenterClusterComparator());
            String currentDataCenter = null;
            List<VDSGroup> currentClusterList = null;
            for (VDSGroup cluster : acceptableValues) {
                if (currentDataCenter == null || !currentDataCenter.equals(cluster.getStoragePoolName())) {
                    currentClusterList = new ArrayList<>();
                    currentDataCenter = cluster.getStoragePoolName();
                    result.put(currentDataCenter, currentClusterList);
                }
                if (currentClusterList != null) {
                    currentClusterList.add(cluster);
                }
            }
            return result;
        }

        @Override
        public String getModelLabel(VDSGroup model) {
            return model.getName();
        }

        @Override
        public String getGroupLabel(VDSGroup model) {
            return messages.hostDataCenter(model.getStoragePoolName());
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterClusterComparator implements Comparator<VDSGroup> {

            @Override
            public int compare(VDSGroup cluster1, VDSGroup cluster2) {
                if (cluster1.getStoragePoolName() != null && cluster2.getStoragePoolName() == null) {
                    return -1;
                } else if (cluster2.getStoragePoolName() != null && cluster1.getStoragePoolName() == null) {
                    return 1;
                } else if (cluster1.getStoragePoolName() == null && cluster2.getStoragePoolName() == null) {
                    return 0;
                }
                if (cluster1.getStoragePoolName().equals(cluster2.getStoragePoolName())) {
                    return cluster1.getName().compareToIgnoreCase(cluster2.getName());
                } else {
                    return cluster1.getStoragePoolName().compareToIgnoreCase(cluster2.getStoragePoolName());
                }
            }
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider>());
    pmVariantsEditor = new ListModelListBoxOnlyEditor<>(new StringRenderer<String>());
    pmTypeEditor = new ListModelListBoxEditor<>(new StringRenderer<String>());
    pmSecondaryTypeEditor = new ListModelListBoxEditor<>(new StringRenderer<String>());
    externalDiscoveredHostsEditor = getListModelTypeAheadListBoxEditor();
    externalHostGroupsEditor = getListModelTypeAheadListBoxEditor();
    externalComputeResourceEditor = getListModelTypeAheadListBoxEditor();
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    overrideIpTablesEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    protocolEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new RadioButton("2");
    // $NON-NLS-1$
    rbProvisionedHost = new RadioButton("2");
}
#end_block

#method_before
private void cluster_SelectedItemChanged() {
    VDSGroup cluster = getCluster().getSelectedItem();
    if (cluster != null) {
        AsyncDataProvider.getInstance().getPmTypeList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ArrayList<String> pmTypes = (ArrayList<String>) returnValue;
                updatePmTypeList(pmTypes, getPmType());
                updatePmTypeList(pmTypes, getPmSecondaryType());
            }
        }), cluster.getCompatibilityVersion());
        // Match the appropriate selected data center to the selected cluster, don't fire update events.
        for (StoragePool datacenter : getDataCenter().getItems()) {
            if (datacenter.getId().equals(cluster.getStoragePoolId())) {
                getDataCenter().setSelectedItem(datacenter, false);
                break;
            }
        }
    }
}
#method_after
private void cluster_SelectedItemChanged() {
    VDSGroup cluster = getCluster().getSelectedItem();
    if (cluster != null) {
        AsyncDataProvider.getInstance().getPmTypeList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ArrayList<String> pmTypes = (ArrayList<String>) returnValue;
                updatePmTypeList(pmTypes, getPmType());
                updatePmTypeList(pmTypes, getPmSecondaryType());
            }
        }), cluster.getCompatibilityVersion());
        Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getCompatibilityVersion().toString());
        getProtocol().setEntity(jsonSupported);
        getProtocol().setIsChangeable(jsonSupported);
        // Match the appropriate selected data center to the selected cluster, don't fire update events.
        for (StoragePool datacenter : getDataCenter().getItems()) {
            if (datacenter.getId().equals(cluster.getStoragePoolId())) {
                getDataCenter().setSelectedItem(datacenter, false);
                break;
            }
        }
    }
}
#end_block

#method_before
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void getUserRoles(UserPortalLoginModel loginModel) {
    AsyncDataProvider.getInstance().getPermissionsByAdElementId(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<Permission> permissions = (ArrayList<Permission>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (Permission permission : permissions) {
                // ALL Everyone/DiskProfileUser persmissions
                if (isPermissionOf(everyone, userTemplateBasedVM, permission) || isPermissionOf(everyone, quotaConsumer, permission) || isPermissionOf(everyone, vnicProfileUser, permission) || isPermissionOf(everyone, diskProfileUser, permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getRoleId())) {
                    roleIdList.add(permission.getRoleId());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.updateUserActionGroups(loginModel1, roleIdList);
            } else {
                checkIsENGINEUser(loginModel1);
            }
        }

        private boolean isPermissionOf(ApplicationGuids user, ApplicationGuids role, Permission permission) {
            return permission.getAdElementId().equals(user.asGuid()) && permission.getRoleId().equals(role.asGuid());
        }
    }), loginModel.getLoggedUser().getId());
}
#method_after
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void getUserRoles(UserPortalLoginModel loginModel) {
    AsyncDataProvider.getInstance().getPermissionsByAdElementId(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<Permission> permissions = (ArrayList<Permission>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (Permission permission : permissions) {
                // ALL Everyone/DiskProfileUser permissions
                if (isPermissionOf(everyone, userTemplateBasedVM, permission) || isPermissionOf(everyone, quotaConsumer, permission) || isPermissionOf(everyone, vnicProfileUser, permission) || isPermissionOf(everyone, diskProfileUser, permission) || isPermissionOf(everyone, userProfileEditor, permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getRoleId())) {
                    roleIdList.add(permission.getRoleId());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.updateUserActionGroups(loginModel1, roleIdList);
            } else {
                checkIsENGINEUser(loginModel1);
            }
        }

        private boolean isPermissionOf(ApplicationGuids user, ApplicationGuids role, Permission permission) {
            return permission.getAdElementId().equals(user.asGuid()) && permission.getRoleId().equals(role.asGuid());
        }
    }), loginModel.getLoggedUser().getId());
}
#end_block

#method_before
public String createSnapshot(final CinderDisk cinderDisk, final Boolean force) {
    return execute(new Callable<String>() {

        @Override
        public String call() {
            SnapshotForCreate snapshotForCreate = new SnapshotForCreate();
            snapshotForCreate.setVolumeId(cinderDisk.getId().toString());
            snapshotForCreate.setForce(force);
            return proxy.createSnapshot(snapshotForCreate);
        }
    });
}
#method_after
public String createSnapshot(final CinderDisk cinderDisk) {
    return execute(new Callable<String>() {

        @Override
        public String call() {
            SnapshotForCreate snapshotForCreate = new SnapshotForCreate();
            snapshotForCreate.setVolumeId(cinderDisk.getId().toString());
            return proxy.createSnapshot(snapshotForCreate);
        }
    });
}
#end_block

#method_before
private static boolean isGetter(Method method) {
    String name = method.getName();
    if (// $NON-NLS-1$
    !name.startsWith("get"))
        return false;
    if (name.length() == 3)
        return false;
    if (// $NON-NLS-1$
    name.equals("getClass"))
        return false;
    if (void.class.equals(method.getReturnType()))
        return false;
    if (method.getParameterTypes().length != 0)
        return false;
    return true;
}
#method_after
private static boolean isGetter(Method method) {
    String name = method.getName();
    if (!name.startsWith("get")) {
        // $NON-NLS-1$
        return false;
    }
    if (name.length() == 3) {
        return false;
    }
    if (name.equals("getClass")) {
        // $NON-NLS-1$
        return false;
    }
    if (void.class.equals(method.getReturnType())) {
        return false;
    }
    if (method.getParameterTypes().length != 0) {
        return false;
    }
    return true;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static <T> T get(Object object, String methodName) {
    try {
        Class<? extends Object> xClass = object.getClass();
        Method method = xClass.getMethod(methodName);
        return (T) method.invoke(object);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#method_after
public static Object get(Object object, Method method) {
    try {
        return method.invoke(object);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public static void setIfPossible(Object object, String getterMethodName, Object value) {
    try {
        Class<? extends Object> xClass = object.getClass();
        // $NON-NLS-1$
        String methodName = "s" + getterMethodName.substring(1, getterMethodName.length());
        Method method = getMethod(xClass, methodName);
        if (method == null) {
            return;
        }
        method.invoke(object, value);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#method_after
public static void setIfPossible(Object object, Method getter, Object value) {
    try {
        Class<? extends Object> clazz = object.getClass();
        Method setterMethod = getSetterMethod(clazz, getter, value.getClass());
        if (setterMethod == null) {
            return;
        }
        setterMethod.invoke(object, value);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private static Object doClean(Object dirty, Map<Object, Object> processed) {
    if (dirty == null) {
        return null;
    }
    if (processed == null) {
        processed = new HashMap<>();
    }
    if (processed.get(dirty) != null) {
        return processed.get(dirty);
    }
    if (isPrimitive(dirty)) {
        return dirty;
    }
    if (!processCollections(dirty, processed)) {
        for (String getterName : ReflectionUtils.getGetterNames(dirty)) {
            Object object = ReflectionUtils.get(dirty, getterName);
            if (object instanceof AbstractPersistentCollection) {
                // Hibernate persistent class, replace the implementation.
                ReflectionUtils.setIfPossible(dirty, getterName, doHibernateClean(object, processed));
            } else {
                processed.put(dirty, dirty);
                doClean(object, processed);
            }
        }
    }
    return dirty;
}
#method_after
private static Object doClean(Object dirty, Map<Object, Object> processed) {
    if (dirty == null) {
        return null;
    }
    // Create object tree cache, so we don't process the same object twice.
    if (processed == null) {
        processed = new HashMap<>();
    }
    // Don't process primitive types.
    if (isPrimitive(dirty)) {
        return dirty;
    }
    // We already processed the object, return the result of the previous processing.
    if (processed.get(dirty) != null) {
        return processed.get(dirty);
    }
    if (!processCollections(dirty, processed)) {
        // The object is not a collection, find all the getters and process the objects associated with those.
        for (Method getter : ReflectionUtils.getGetters(dirty.getClass())) {
            Object object = ReflectionUtils.get(dirty, getter);
            if (!dirty.equals(object)) {
                if (object instanceof AbstractPersistentCollection) {
                    // Hibernate persistent class, replace the implementation.
                    ReflectionUtils.setIfPossible(dirty, getter, doHibernateClean(object, processed));
                } else {
                    processed.put(object, doClean(object, processed));
                }
            }
        }
    }
    return dirty;
}
#end_block

#method_before
private static Object doHibernateClean(Object dirty, Map<Object, Object> processed) {
    if (dirty instanceof PersistentList) {
        PersistentList dirtyList = (PersistentList) dirty;
        List<Object> cleanList = new ArrayList<Object>();
        processed.put(dirtyList, cleanList);
        if (dirtyList.wasInitialized()) {
            for (Object value : dirtyList) {
                cleanList.add(doClean(value, processed));
            }
        }
        return cleanList;
    }
    if (dirty instanceof PersistentBag) {
        PersistentBag dirtyList = (PersistentBag) dirty;
        List<Object> cleanList = new ArrayList<Object>();
        processed.put(dirtyList, cleanList);
        if (dirtyList.wasInitialized()) {
            for (Object value : dirtyList) {
                cleanList.add(doClean(value, processed));
            }
        }
        return cleanList;
    }
    if (dirty instanceof PersistentSortedSet) {
        PersistentSortedSet dirtySet = (PersistentSortedSet) dirty;
        Set<Object> cleanSet = new TreeSet<Object>();
        processed.put(dirtySet, cleanSet);
        if (dirtySet.wasInitialized()) {
            for (Object value : dirtySet) {
                cleanSet.add(doClean(value, processed));
            }
        }
        return cleanSet;
    }
    if (dirty instanceof PersistentSet) {
        PersistentSet dirtySet = (PersistentSet) dirty;
        Set<Object> cleanSet = new HashSet<Object>();
        processed.put(dirtySet, cleanSet);
        if (dirtySet.wasInitialized()) {
            for (Object value : dirtySet) {
                cleanSet.add(doClean(value, processed));
            }
        }
        return cleanSet;
    }
    if (dirty instanceof PersistentMap) {
        PersistentMap dirtyMap = (PersistentMap) dirty;
        Map<Object, Object> cleanMap = new LinkedHashMap<Object, Object>();
        processed.put(dirtyMap, cleanMap);
        if (dirtyMap.wasInitialized()) {
            for (Object key : dirtyMap.keySet()) {
                Object value = dirtyMap.get(key);
                cleanMap.put(doClean(key, processed), doClean(value, processed));
            }
        }
        return cleanMap;
    }
    return null;
}
#method_after
private static Object doHibernateClean(Object dirty, Map<Object, Object> processed) {
    if (dirty instanceof PersistentList) {
        PersistentList dirtyList = (PersistentList) dirty;
        List<Object> cleanList = new ArrayList<Object>();
        processed.put(dirtyList, cleanList);
        if (dirtyList.wasInitialized()) {
            for (Object value : dirtyList) {
                cleanList.add(doClean(value, processed));
            }
        }
        return cleanList;
    }
    if (dirty instanceof PersistentBag) {
        PersistentBag dirtyList = (PersistentBag) dirty;
        List<Object> cleanList = new ArrayList<Object>();
        processed.put(dirtyList, cleanList);
        if (dirtyList.wasInitialized()) {
            for (Object value : dirtyList) {
                cleanList.add(doClean(value, processed));
            }
        }
        return cleanList;
    }
    if (dirty instanceof PersistentSortedSet) {
        PersistentSortedSet dirtySet = (PersistentSortedSet) dirty;
        Set<Object> cleanSet = new TreeSet<Object>();
        processed.put(dirtySet, cleanSet);
        if (dirtySet.wasInitialized()) {
            for (Object value : dirtySet) {
                cleanSet.add(doClean(value, processed));
            }
        }
        return cleanSet;
    }
    if (dirty instanceof PersistentSet) {
        PersistentSet dirtySet = (PersistentSet) dirty;
        Set<Object> cleanSet = new HashSet<Object>();
        processed.put(dirtySet, cleanSet);
        if (dirtySet.wasInitialized()) {
            for (Object value : dirtySet) {
                cleanSet.add(doClean(value, processed));
            }
        }
        return cleanSet;
    }
    if (dirty instanceof PersistentMap) {
        PersistentMap dirtyMap = (PersistentMap) dirty;
        Map<Object, Object> cleanMap = new LinkedHashMap<Object, Object>();
        processed.put(dirtyMap, cleanMap);
        if (dirtyMap.wasInitialized()) {
            for (Object entryObject : dirtyMap.entrySet()) {
                // Cast the entry object to the right type since the hibernate library doesn't know how to do
                // generics properly.
                @SuppressWarnings("unchecked")
                Entry<Object, Object> entry = (Entry<Object, Object>) entryObject;
                cleanMap.put(doClean(entry.getKey(), processed), doClean(entry.getValue(), processed));
            }
        }
        return cleanMap;
    }
    return null;
}
#end_block

#method_before
public String createSnapshot(final CinderDisk cinderDisk, final Boolean force) {
    return execute(new Callable<String>() {

        @Override
        public String call() {
            SnapshotForCreate snapshotForCreate = new SnapshotForCreate();
            snapshotForCreate.setVolumeId(cinderDisk.getId().toString());
            snapshotForCreate.setForce(force);
            return proxy.createSnapshot(snapshotForCreate);
        }
    });
}
#method_after
public String createSnapshot(final CinderDisk cinderDisk) {
    return execute(new Callable<String>() {

        @Override
        public String call() {
            SnapshotForCreate snapshotForCreate = new SnapshotForCreate();
            snapshotForCreate.setVolumeId(cinderDisk.getId().toString());
            return proxy.createSnapshot(snapshotForCreate);
        }
    });
}
#end_block

#method_before
public boolean isSnapshotExist(final Guid id) {
    return execute(new Callable<Boolean>() {

        @Override
        public Boolean call() {
            try {
                Snapshot snapshot = proxy.getSnapshotById(id.toString());
                return snapshot != null;
            } catch (OpenStackResponseException ex) {
                if (ex.getStatus() == HttpStatus.SC_NOT_FOUND) {
                    return false;
                }
                throw ex;
            }
        }
    });
}
#method_after
public boolean isSnapshotExist(final Guid id) {
    return execute(new Callable<Boolean>() {

        @Override
        public Boolean call() {
            try {
                Snapshot snapshot = proxy.getSnapshotById(id.toString());
                return snapshot != null;
            } catch (OpenStackResponseException ex) {
                if (ex.getStatus() == HttpStatus.SC_NOT_FOUND) {
                    log.info("Snapshot does not exists");
                    return false;
                } else {
                    log.error("An error has occurred while looking for snapshot.");
                    throw ex;
                }
            }
        }
    });
}
#end_block

#method_before
@TabInfo(container = VirtualMachineSubTabPanelPresenter.class)
static TabData getTabData(ApplicationConstants applicationConstants, DetailModelProvider<VmListModel, VmGuestInfoModel> modelProvider) {
    return new ModelBoundTabData(applicationConstants.virtualMachineGuestInfoSubTabLabel(), 7, modelProvider);
}
#method_after
@TabInfo(container = VirtualMachineSubTabPanelPresenter.class)
static TabData getTabData(DetailModelProvider<VmListModel<Void>, VmGuestInfoModel> modelProvider) {
    return new ModelBoundTabData(constants.virtualMachineGuestInfoSubTabLabel(), 9, modelProvider);
}
#end_block

#method_before
void bindModels() {
    bind(AdElementListModel.class).to(UserPortalAdElementListModel.class);
    // Basic tab
    bind(UserPortalBasicListModel.class).in(Singleton.class);
    bind(VmBasicDiskListModel.class).in(Singleton.class);
    // Extended tab: Virtual Machine
    bind(UserPortalListModel.class).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(PoolGeneralModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(PoolDiskListModel.class).in(Singleton.class);
    bind(UserPortalVmSnapshotListModel.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalPermissionListModel<UserPortalListModel>>() {
    }).in(Singleton.class);
    bind(UserPortalVmEventListModel.class).in(Singleton.class);
    bind(VmAppListModel.class).in(Singleton.class);
    bind(VmMonitorModel.class).in(Singleton.class);
    bind(PoolInterfaceListModel.class).in(Singleton.class);
    bind(VmGuestInfoModel.class).in(Singleton.class);
    // Extended tab: Template
    bind(UserPortalTemplateListModel.class).in(Singleton.class);
    bind(TemplateGeneralModel.class).in(Singleton.class);
    bind(TemplateInterfaceListModel.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalPermissionListModel<VmTemplate>>() {
    }).in(Singleton.class);
    bind(UserPortalTemplateDiskListModel.class).in(Singleton.class);
    bind(UserPortalTemplateEventListModel.class).in(Singleton.class);
    // Extended tab: Resources
    bind(ResourcesModel.class).in(Singleton.class);
}
#method_after
void bindModels() {
    bind(AdElementListModel.class).to(UserPortalAdElementListModel.class);
    // Basic tab
    bind(UserPortalBasicListModel.class).in(Singleton.class);
    bind(VmBasicDiskListModel.class).in(Singleton.class);
    // Extended tab: Virtual Machine
    bind(UserPortalListModel.class).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(PoolGeneralModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(PoolDiskListModel.class).in(Singleton.class);
    bind(UserPortalVmSnapshotListModel.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalPermissionListModel<UserPortalListModel>>() {
    }).in(Singleton.class);
    bind(UserPortalVmEventListModel.class).in(Singleton.class);
    bind(new TypeLiteral<VmAppListModel<VM>>() {
    }).in(Singleton.class);
    bind(VmMonitorModel.class).in(Singleton.class);
    bind(PoolInterfaceListModel.class).in(Singleton.class);
    bind(VmGuestInfoModel.class).in(Singleton.class);
    // Extended tab: Template
    bind(UserPortalTemplateListModel.class).in(Singleton.class);
    bind(TemplateGeneralModel.class).in(Singleton.class);
    bind(TemplateInterfaceListModel.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalPermissionListModel<VmTemplate>>() {
    }).in(Singleton.class);
    bind(UserPortalTemplateDiskListModel.class).in(Singleton.class);
    bind(UserPortalTemplateEventListModel.class).in(Singleton.class);
    // Extended tab: Resources
    bind(ResourcesModel.class).in(Singleton.class);
}
#end_block

#method_before
void bindModelProviders() {
    // Basic tab
    bind(UserPortalBasicListProvider.class).in(Singleton.class);
    // Extended tab: Virtual Machine
    bind(UserPortalListProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, PoolGeneralModel>>() {
    }).in(Singleton.class);
    bind(VmInterfaceListModelProvider.class).in(Singleton.class);
    bind(VmDiskListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<Disk, UserPortalListModel, PoolDiskListModel>>() {
    }).in(Singleton.class);
    bind(VmSnapshotListModelProvider.class).in(Singleton.class);
    bind(VmPermissionListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<AuditLog, UserPortalListModel, UserPortalVmEventListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<String, UserPortalListModel, VmAppListModel>>() {
    }).in(Singleton.class);
    bind(VmMonitorModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<VmNetworkInterface, UserPortalListModel, PoolInterfaceListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, VmGuestInfoModel>>() {
    }).in(Singleton.class);
    // Extended tab: Template
    bind(UserPortalTemplateListProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalTemplateListModel, TemplateGeneralModel>>() {
    }).in(Singleton.class);
    bind(TemplateInterfaceListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<DiskImage, UserPortalTemplateListModel, UserPortalTemplateDiskListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<AuditLog, UserPortalTemplateListModel, UserPortalTemplateEventListModel>>() {
    }).in(Singleton.class);
    bind(TemplatePermissionListModelProvider.class).in(Singleton.class);
    // Extended tab: Resources
    bind(new TypeLiteral<UserPortalDataBoundModelProvider<VM, ResourcesModel>>() {
    }).in(Singleton.class);
}
#method_after
void bindModelProviders() {
    // Basic tab
    bind(UserPortalBasicListProvider.class).in(Singleton.class);
    // Extended tab: Virtual Machine
    bind(UserPortalListProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, PoolGeneralModel>>() {
    }).in(Singleton.class);
    bind(VmInterfaceListModelProvider.class).in(Singleton.class);
    bind(VmDiskListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<Disk, UserPortalListModel, PoolDiskListModel>>() {
    }).in(Singleton.class);
    bind(VmSnapshotListModelProvider.class).in(Singleton.class);
    bind(VmPermissionListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<AuditLog, UserPortalListModel, UserPortalVmEventListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<String, UserPortalListModel, VmAppListModel<VM>>>() {
    }).in(Singleton.class);
    bind(VmMonitorModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<VmNetworkInterface, UserPortalListModel, PoolInterfaceListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalListModel, VmGuestInfoModel>>() {
    }).in(Singleton.class);
    // Extended tab: Template
    bind(UserPortalTemplateListProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalDetailModelProvider<UserPortalTemplateListModel, TemplateGeneralModel>>() {
    }).in(Singleton.class);
    bind(TemplateInterfaceListModelProvider.class).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<DiskImage, UserPortalTemplateListModel, UserPortalTemplateDiskListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<UserPortalSearchableDetailModelProvider<AuditLog, UserPortalTemplateListModel, UserPortalTemplateEventListModel>>() {
    }).in(Singleton.class);
    bind(TemplatePermissionListModelProvider.class).in(Singleton.class);
    // Extended tab: Resources
    bind(new TypeLiteral<UserPortalDataBoundModelProvider<VM, ResourcesModel>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
private void setDetailList(final VmGeneralModel vmGeneralModel, final VmInterfaceListModel vmInterfaceListModel, final VmDiskListModel vmDiskListModel, final VmSnapshotListModel vmSnapshotListModel, final VmEventListModel vmEventListModel, final VmAppListModel vmAppListModel, final PermissionListModel<VmListModel> permissionListModel, final VmAffinityGroupListModel vmAffinityGroupListModel, final VmGuestInfoModel vmGuestInfoModel) {
    List<EntityModel> list = new ArrayList<EntityModel>();
    list.add(vmGeneralModel);
    list.add(vmInterfaceListModel);
    vmDiskListModel.setSystemTreeContext(this);
    list.add(vmDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(permissionListModel);
    list.add(vmAffinityGroupListModel);
    list.add(vmGuestInfoModel);
    setDetailModels(list);
}
#method_after
private void setDetailList(final VmGeneralModel vmGeneralModel, final VmInterfaceListModel vmInterfaceListModel, final VmDiskListModel vmDiskListModel, final VmSnapshotListModel vmSnapshotListModel, final VmEventListModel vmEventListModel, final VmAppListModel<VM> vmAppListModel, final PermissionListModel<VM> permissionListModel, final VmAffinityGroupListModel vmAffinityGroupListModel, final VmGuestInfoModel vmGuestInfoModel, final VmHostDeviceListModel vmHostDeviceListModel, final VmDevicesListModel vmDevicesListModel) {
    List<HasEntity<VM>> list = new ArrayList<>();
    list.add(vmGeneralModel);
    list.add(vmInterfaceListModel);
    vmDiskListModel.setSystemTreeContext(this);
    list.add(vmDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(vmDevicesListModel);
    list.add(permissionListModel);
    list.add(vmAffinityGroupListModel);
    list.add(vmGuestInfoModel);
    list.add(vmHostDeviceListModel);
    setDetailModels(list);
}
#end_block

#method_before
private void getAttachedTagsToSelectedVMs(TagListModel model) {
    ArrayList<Guid> vmIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<Tags>();
    selectedItemsCounter = 0;
    for (Guid id : vmIds) {
        AsyncDataProvider.getInstance().getAttachedTagsToVm(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                VmListModel vmListModel = (VmListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                vmListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                vmListModel.selectedItemsCounter++;
                if (vmListModel.selectedItemsCounter == vmListModel.getSelectedItems().size()) {
                    postGetAttachedTags(vmListModel, tagListModel);
                }
            }
        }), id);
    }
}
#method_after
private void getAttachedTagsToSelectedVMs(TagListModel model) {
    ArrayList<Guid> vmIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    attachedTagsToEntities = new HashMap<>();
    allAttachedTags = new ArrayList<>();
    selectedItemsCounter = 0;
    for (Guid id : vmIds) {
        AsyncDataProvider.getInstance().getAttachedTagsToVm(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                VmListModel<Void> vmListModel = (VmListModel<Void>) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                vmListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                vmListModel.selectedItemsCounter++;
                if (vmListModel.selectedItemsCounter == vmListModel.getSelectedItems().size()) {
                    postGetAttachedTags(vmListModel, tagListModel);
                }
            }
        }), id);
    }
}
#end_block

#method_before
private void postGetAttachedTags(VmListModel vmListModel, TagListModel tagListModel) {
    if (vmListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(vmListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : vmListModel.allAttachedTags) {
                if (tag2.gettag_id().equals(tag.gettag_id())) {
                    count++;
                }
            }
            vmListModel.attachedTagsToEntities.put(tag.gettag_id(), count == vmListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(vmListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(vmListModel.getLastExecutedCommand().getName())) {
        vmListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#method_after
private void postGetAttachedTags(VmListModel<Void> vmListModel, TagListModel tagListModel) {
    if (vmListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(vmListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : vmListModel.allAttachedTags) {
                if (tag2.gettag_id().equals(tag.gettag_id())) {
                    count++;
                }
            }
            vmListModel.attachedTagsToEntities.put(tag.gettag_id(), count == vmListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(vmListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(vmListModel.getLastExecutedCommand().getName())) {
        vmListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#end_block

#method_before
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> vmIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<Guid>();
    ArrayList<Guid> tagsToDetach = new ArrayList<Guid>();
    if (model.getItems() != null && ((ArrayList<TagModel>) model.getItems()).size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    for (Guid a : tagsToAttach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachVmsToTag, parameters);
    parameters = new ArrayList<VdcActionParametersBase>();
    for (Guid a : tagsToDetach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.DetachVmFromTag, parameters);
    cancel();
}
#method_after
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> vmIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<>();
    ArrayList<Guid> tagsToDetach = new ArrayList<>();
    if (model.getItems() != null && model.getItems().size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (Guid a : tagsToAttach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachVmsToTag, parameters);
    parameters = new ArrayList<>();
    for (Guid a : tagsToDetach) {
        parameters.add(new AttachEntityToTagParameters(a, vmIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.DetachVmFromTag, parameters);
    cancel();
}
#end_block

#method_before
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    model.setHelpTag(HelpTag.new_virtual_machine___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = (VM) getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getInstance().getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    model.setHelpTag(HelpTag.new_virtual_machine___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getInstance().getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    List<UICommand> commands = new ArrayList<>();
    // $NON-NLS-1$
    commands.add(UICommand.createDefaultOkUiCommand("OnSave", this));
    // $NON-NLS-1$
    commands.add(UICommand.createCancelUiCommand("Cancel", this));
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior(), this);
    setupNewVmModel(model, VmType.Server, getSystemTreeSelectedItem(), commands);
}
#end_block

#method_before
private void edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getInstance().getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
    }
}
#method_after
private void edit() {
    VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getInstance().getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
    }
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createDefaultOkUiCommand("OnSave", this));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm), this);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createDefaultOkUiCommand("OnSave", this));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<Guid, EntityModel>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    window.getCommands().add(tempVar2);
}
#end_block

#method_before
private void updateRemoveDisksCheckBox(EntityModel model, boolean deleteDisks, boolean isChangable, String changeProhibitionReason) {
    model.setEntity(deleteDisks);
    if (!isChangable && changeProhibitionReason != null) {
        model.setChangeProhibitionReason(changeProhibitionReason);
    }
    model.setIsChangable(isChangable);
}
#method_after
private void updateRemoveDisksCheckBox(EntityModel model, boolean deleteDisks, boolean isChangable, String changeProhibitionReason) {
    model.setEntity(deleteDisks);
    if (!isChangable && changeProhibitionReason != null) {
        model.setChangeProhibitionReason(changeProhibitionReason);
    }
    model.setIsChangeable(isChangable);
}
#end_block

#method_before
private void initRemoveDisksCheckboxes(final Map<Guid, EntityModel> vmsMap) {
    ArrayList<VdcQueryParametersBase> params = new ArrayList<VdcQueryParametersBase>();
    ArrayList<VdcQueryType> queries = new ArrayList<VdcQueryType>();
    for (Entry<Guid, EntityModel> entry : vmsMap.entrySet()) {
        if (entry.getValue().getIsChangable()) {
            // No point in fetching VM disks from ones that already determined
            // is unchangeable since they are already initialized
            params.add(new IdQueryParameters(entry.getKey()));
            queries.add(VdcQueryType.GetAllDisksByVmId);
        }
    }
    // revise when refactoring org.ovirt.engine.ui.Frontend to support runMultipleQuery with a single query
    if (!params.isEmpty()) {
        Frontend.getInstance().runMultipleQueries(queries, params, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                for (int i = 0; i < result.getReturnValues().size(); i++) {
                    if (result.getReturnValues().get(i).getSucceeded()) {
                        Guid vmId = ((IdQueryParameters) result.getParameters().get(i)).getId();
                        initRemoveDisksChecboxesPost(vmId, (List<Disk>) result.getReturnValues().get(i).getReturnValue());
                    }
                }
            }
        });
    }
}
#method_after
private void initRemoveDisksCheckboxes(final Map<Guid, EntityModel> vmsMap) {
    ArrayList<VdcQueryParametersBase> params = new ArrayList<>();
    ArrayList<VdcQueryType> queries = new ArrayList<>();
    for (Entry<Guid, EntityModel> entry : vmsMap.entrySet()) {
        if (entry.getValue().getIsChangable()) {
            // No point in fetching VM disks from ones that already determined
            // is unchangeable since they are already initialized
            params.add(new IdQueryParameters(entry.getKey()));
            queries.add(VdcQueryType.GetAllDisksByVmId);
        }
    }
    // revise when refactoring org.ovirt.engine.ui.Frontend to support runMultipleQuery with a single query
    if (!params.isEmpty()) {
        Frontend.getInstance().runMultipleQueries(queries, params, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                for (int i = 0; i < result.getReturnValues().size(); i++) {
                    if (result.getReturnValues().get(i).getSucceeded()) {
                        Guid vmId = ((IdQueryParameters) result.getParameters().get(i)).getId();
                        initRemoveDisksChecboxesPost(vmId, (List<Disk>) result.getReturnValues().get(i).getReturnValue());
                    }
                }
            }
        });
    }
}
#end_block

#method_before
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = SnapshotModel.createNewSnapshotModel(this);
    model.setValidateByVmSnapshots(true);
    setWindow(model);
    model.setVm(vm);
    model.initialize();
}
#method_after
private void createSnapshot() {
    VM vm = getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = SnapshotModel.createNewSnapshotModel(this);
    model.setValidateByVmSnapshots(true);
    setWindow(model);
    model.setVm(vm);
    model.initialize();
}
#end_block

#method_before
@Override
protected boolean entitiesSelectedOnDifferentDataCenters() {
    ArrayList<VM> vms = new ArrayList<VM>();
    for (Object selectedItem : getSelectedItems()) {
        VM a = (VM) selectedItem;
        vms.add(a);
    }
    Map<Guid, ArrayList<VM>> t = new HashMap<Guid, ArrayList<VM>>();
    for (VM a : vms) {
        if (!t.containsKey(a.getStoragePoolId())) {
            t.put(a.getStoragePoolId(), new ArrayList<VM>());
        }
        ArrayList<VM> list = t.get(a.getStoragePoolId());
        list.add(a);
    }
    return t.size() > 1;
}
#method_after
@Override
protected boolean entitiesSelectedOnDifferentDataCenters() {
    ArrayList<VM> vms = new ArrayList<>();
    for (Object selectedItem : getSelectedItems()) {
        VM a = (VM) selectedItem;
        vms.add(a);
    }
    Map<Guid, ArrayList<VM>> t = new HashMap<>();
    for (VM a : vms) {
        if (!t.containsKey(a.getStoragePoolId())) {
            t.put(a.getStoragePoolId(), new ArrayList<VM>());
        }
        ArrayList<VM> list = t.get(a.getStoragePoolId());
        list.add(a);
    }
    return t.size() > 1;
}
#end_block

#method_before
private void getTemplatesNotPresentOnExportDomain() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            ArrayList<StoragePool> storagePools = (ArrayList<StoragePool>) returnValue;
            StoragePool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
            vmListModel.postGetTemplatesNotPresentOnExportDomain(storagePool);
        }
    }), storageDomainId);
}
#method_after
private void getTemplatesNotPresentOnExportDomain() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) target;
            ArrayList<StoragePool> storagePools = (ArrayList<StoragePool>) returnValue;
            StoragePool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
            vmListModel.postGetTemplatesNotPresentOnExportDomain(storagePool);
        }
    }), storageDomainId);
}
#end_block

#method_before
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (storagePool != null) {
        AsyncDataProvider.getInstance().getAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<String, ArrayList<String>>();
                // check if relevant templates are already there
                for (Object selectedItem : vmListModel.getSelectedItems()) {
                    VM vm = (VM) selectedItem;
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getVmtGuid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getVmtGuid().equals(Guid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getVmtName())) {
                            templateDic.put(vm.getVmtName(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getVmtName()).add(vm.getName());
                    }
                }
                String tempStr;
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<String>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    StringBuilder sb = new StringBuilder("Template " + keyValuePair.getKey() + " (for ");
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        sb.append(tempList.get(i));
                        // $NON-NLS-1$
                        sb.append(", ");
                    }
                    sb.append(tempList.get(i));
                    // $NON-NLS-1$
                    sb.append(")");
                    missingTemplates.add(sb.toString());
                }
                vmListModel.postExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#method_after
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (storagePool != null) {
        AsyncDataProvider.getInstance().getAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel<Void> vmListModel = (VmListModel<Void>) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<>();
                // check if relevant templates are already there
                for (Object selectedItem : vmListModel.getSelectedItems()) {
                    VM vm = (VM) selectedItem;
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getVmtGuid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getVmtGuid().equals(Guid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getVmtName())) {
                            templateDic.put(vm.getVmtName(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getVmtName()).add(vm.getName());
                    }
                }
                String tempStr;
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    StringBuilder sb = new StringBuilder("Template " + keyValuePair.getKey() + " (for ");
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        sb.append(tempList.get(i));
                        // $NON-NLS-1$
                        sb.append(", ");
                    }
                    sb.append(tempList.get(i));
                    // $NON-NLS-1$
                    sb.append(")");
                    missingTemplates.add(sb.toString());
                }
                vmListModel.postExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#end_block

#method_before
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveVmParameters parameter = new MoveVmParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride(model.getForceOverride().getEntity());
        parameter.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!(Boolean) model.getCollapseSnapshots().getEntity()) {
        if ((missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0)) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnExportNoTemplates", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveVmParameters parameter = (MoveVmParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress(null);
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#method_after
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveVmParameters parameter = new MoveVmParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride(model.getForceOverride().getEntity());
        parameter.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!model.getCollapseSnapshots().getEntity()) {
        if ((missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0)) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnExportNoTemplates", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveVmParameters parameter = (MoveVmParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress(null);
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#end_block

#method_before
private void onExportNoTemplates() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        MoveVmParameters parameters = new MoveVmParameters(a.getId(), storageDomainId);
        parameters.setForceOverride(model.getForceOverride().getEntity());
        parameters.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameters.setTemplateMustExists(false);
        list.add(parameters);
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ExportVmModel localModel = (ExportVmModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onExportNoTemplates() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        MoveVmParameters parameters = new MoveVmParameters(a.getId(), storageDomainId);
        parameters.setForceOverride(model.getForceOverride().getEntity());
        parameters.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameters.setTemplateMustExists(false);
        list.add(parameters);
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ExportVmModel localModel = (ExportVmModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void runOnce() {
    VM vm = (VM) getSelectedItem();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel((VM) result, VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
}
#method_after
private void runOnce() {
    VM vm = getSelectedItem();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel((VM) result, VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
}
#end_block

#method_before
private void newTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    model.setHelpTag(HelpTag.new_template);
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(getSystemTreeSelectedItem());
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnNewTemplate", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#method_after
private void newTemplate() {
    VM vm = getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm), this);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    model.setHelpTag(HelpTag.new_template);
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(getSystemTreeSelectedItem());
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnNewTemplate", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#end_block

#method_before
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#method_after
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel<Void> vmListModel = (VmListModel<Void>) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#end_block

#method_before
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setBalloonEnabled(balloonEnabled(model));
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    if (model.getIsSubTemplate().getEntity()) {
        addVmTemplateParameters.setBaseTemplateId(model.getBaseTemplate().getSelectedItem().getId());
        addVmTemplateParameters.setTemplateVersionName(model.getTemplateVersionName().getEntity());
    }
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#method_after
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToAddVmTemplateParametersBuilder());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#end_block

#method_before
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    BuilderExecutor.build(model, tempVar.getStaticData(), new CommonUnitToVmBaseBuilder());
    BuilderExecutor.build(vm.getStaticData(), tempVar.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new DedicatedVmForVdsVmBaseToVmBaseBuilder(), new MigrationOptionsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder());
    return tempVar;
}
#method_after
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM resultVm = new VM();
    resultVm.setId(vm.getId());
    BuilderExecutor.build(model, resultVm.getStaticData(), new CommonUnitToVmBaseBuilder());
    BuilderExecutor.build(vm.getStaticData(), resultVm.getStaticData(), new VmBaseToVmBaseForTemplateCompositeBaseBuilder());
    return resultVm;
}
#end_block

#method_before
private void migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel(this);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    model.setHelpTag(HelpTag.migrate_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>cast(getSelectedItems()));
    model.setVm(vm);
    model.initializeModel();
}
#method_after
private void migrate() {
    VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel(this);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    model.setHelpTag(HelpTag.migrate_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>cast(getSelectedItems()));
    model.setVm(vm);
    model.initializeModel();
}
#end_block

#method_before
private void cancelMigration() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.CancelMigrateVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void cancelMigration() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.CancelMigrateVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
private void onMigrate() {
    MigrateModel model = (MigrateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress(null);
    Guid targetClusterId = model.getClusters().getSelectedItem() != null ? model.getClusters().getSelectedItem().getId() : null;
    if (model.getIsAutoSelect()) {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            list.add(new MigrateVmParameters(true, a.getId(), targetClusterId));
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.MigrateVm, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    } else {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            if (a.getRunOnVds().equals(model.getHosts().getSelectedItem().getId())) {
                continue;
            }
            list.add(new MigrateVmToServerParameters(true, a.getId(), model.getHosts().getSelectedItem().getId(), targetClusterId));
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.MigrateVmToServer, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#method_after
private void onMigrate() {
    MigrateModel model = (MigrateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress(null);
    Guid targetClusterId = model.getClusters().getSelectedItem() != null ? model.getClusters().getSelectedItem().getId() : null;
    if (model.getIsAutoSelect()) {
        ArrayList<VdcActionParametersBase> list = new ArrayList<>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            list.add(new MigrateVmParameters(true, a.getId(), targetClusterId));
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.MigrateVm, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    } else {
        ArrayList<VdcActionParametersBase> list = new ArrayList<>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            if (a.getRunOnVds().equals(model.getHosts().getSelectedItem().getId())) {
                continue;
            }
            list.add(new MigrateVmToServerParameters(true, a.getId(), model.getHosts().getSelectedItem().getId(), targetClusterId));
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.MigrateVmToServer, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#end_block

#method_before
private void powerAction(String actionName, String title, String message, boolean reasonVisible) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    model.setReasonVisible(reasonVisible);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    ArrayList<String> items = new ArrayList<String>();
    boolean stoppingSingleVM = getSelectedItems().size() == 1 && (actionName.equals(SHUTDOWN) || actionName.equals(STOP));
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        items.add(vm.getName());
        // is populated with the current reason so the user can edit it.
        if (stoppingSingleVM && reasonVisible && VMStatus.PoweringDown.equals(vm.getStatus())) {
            model.getReason().setEntity(vm.getStopReason());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void powerAction(String actionName, String title, String message, boolean reasonVisible) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    model.setReasonVisible(reasonVisible);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    ArrayList<String> items = new ArrayList<>();
    boolean stoppingSingleVM = getSelectedItems().size() == 1 && (actionName.equals(SHUTDOWN) || actionName.equals(STOP));
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        items.add(vm.getName());
        // is populated with the current reason so the user can edit it.
        if (stoppingSingleVM && reasonVisible && VMStatus.PoweringDown.equals(vm.getStatus())) {
            model.getReason().setEntity(vm.getStopReason());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onPowerAction(VdcActionType actionType, PowerActionParametersFactory<?> parametersFactory) {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        list.add(parametersFactory.createActionParameters(vm));
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(actionType, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onPowerAction(VdcActionType actionType, PowerActionParametersFactory<?> parametersFactory) {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        list.add(parametersFactory.createActionParameters(vm));
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(actionType, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void pause() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.HibernateVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void pause() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new VmOperationParameterBase(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.HibernateVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
private void run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new RunVmParams(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.RunVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new RunVmParams(a.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.RunVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
private void onRemove() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    final ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Entry<Guid, EntityModel> entry : vmsRemoveMap.entrySet()) {
        list.add(new RemoveVmParameters(entry.getKey(), false, (Boolean) entry.getValue().getEntity()));
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onRemove() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    final ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Entry<Guid, EntityModel> entry : vmsRemoveMap.entrySet()) {
        list.add(new RemoveVmParameters(entry.getKey(), false, (Boolean) entry.getValue().getEntity()));
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void changeCD() {
    final VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getInstance().getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnChangeCD", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    final VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel<Void> vmListModel2 = (VmListModel<Void>) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getInstance().getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnChangeCD", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onChangeCD() {
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem(), vm.getCurrentCd())) {
        cancel();
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void setGlobalHaMaintenance(boolean enabled) {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (!vm.isHostedEngine()) {
        return;
    }
    SetHaMaintenanceParameters params = new SetHaMaintenanceParameters(vm.getRunOnVds(), HaMaintenanceMode.GLOBAL, enabled);
    Frontend.getInstance().runAction(VdcActionType.SetHaMaintenance, params);
}
#method_after
private void setGlobalHaMaintenance(boolean enabled) {
    VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    if (!vm.isHostedEngine()) {
        return;
    }
    SetHaMaintenanceParameters params = new SetHaMaintenanceParameters(vm.getRunOnVds(), HaMaintenanceMode.GLOBAL, enabled);
    Frontend.getInstance().runAction(VdcActionType.SetHaMaintenance, params);
}
#end_block

#method_before
private void preSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    final String name = model.getName().getEntity();
    if (model.getIsNew() == false && selectedItem == null) {
        cancel();
        return;
    }
    setcurrentVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem));
    if (!model.validate()) {
        return;
    }
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (!(Boolean) returnValue && name.compareToIgnoreCase(getcurrentVm().getName()) != 0) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setValidTab(TabName.GENERAL_TAB, false);
            } else {
                model.getName().getInvalidityReasons().clear();
                model.getName().setIsValid(true);
                model.setValidTab(TabName.GENERAL_TAB, true);
                onSave();
            }
        }
    }), name);
}
#method_after
private void preSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    final String name = model.getName().getEntity();
    if (model.getIsNew() == false && selectedItem == null) {
        cancel();
        return;
    }
    setcurrentVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem));
    validateVm(model, name);
}
#end_block

#method_before
private void updateExistingVm(final boolean applyCpuChangesLater) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // runEditVM: should be true if Cluster hasn't changed or if
    // Cluster has changed and Editing it in the Backend has succeeded:
    VM selectedItem = (VM) getSelectedItem();
    Guid oldClusterID = selectedItem.getVdsGroupId();
    Guid newClusterID = model.getSelectedCluster().getId();
    if (oldClusterID.equals(newClusterID) == false) {
        ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
        model.startProgress(null);
        Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                final VmListModel vmListModel = (VmListModel) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    VM vm = vmListModel.getcurrentVm();
                    VmManagementParametersBase updateVmParams = vmListModel.getUpdateVmParameters(applyCpuChangesLater);
                    Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
                } else {
                    vmListModel.getWindow().stopProgress();
                }
            }
        }, this);
    } else {
        model.startProgress(null);
        VmManagementParametersBase updateVmParams = getUpdateVmParameters(applyCpuChangesLater);
        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
    }
}
#method_after
private void updateExistingVm(final boolean applyCpuChangesLater) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // runEditVM: should be true if Cluster hasn't changed or if
    // Cluster has changed and Editing it in the Backend has succeeded:
    VM selectedItem = getSelectedItem();
    Guid oldClusterID = selectedItem.getVdsGroupId();
    Guid newClusterID = model.getSelectedCluster().getId();
    if (oldClusterID.equals(newClusterID) == false) {
        ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
        model.startProgress(null);
        Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                final VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    VM vm = vmListModel.getcurrentVm();
                    VmManagementParametersBase updateVmParams = vmListModel.getUpdateVmParameters(applyCpuChangesLater);
                    Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
                } else {
                    vmListModel.getWindow().stopProgress();
                }
            }
        }, this);
    } else {
        model.startProgress(null);
        VmManagementParametersBase updateVmParams = getUpdateVmParameters(applyCpuChangesLater);
        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
    }
}
#end_block

#method_before
public VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
    setVmWatchdogToParams(model, updateVmParams);
    updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    updateVmParams.setBalloonEnabled(balloonEnabled(model));
    updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    updateVmParams.setApplyChangesLater(applyCpuChangesLater);
    updateVmParams.setUpdateNuma(model.isNumaChanged());
    setRngDeviceToParams(model, updateVmParams);
    BuilderExecutor.build(model, updateVmParams, new UnitToGraphicsDeviceParamsBuilder());
    return updateVmParams;
}
#method_after
public VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
    setVmWatchdogToParams(model, updateVmParams);
    updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    updateVmParams.setBalloonEnabled(balloonEnabled(model));
    updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    updateVmParams.setApplyChangesLater(applyCpuChangesLater);
    updateVmParams.setUpdateNuma(model.isNumaChanged());
    BuilderExecutor.build(new Pair<>((UnitVmModel) getWindow(), getSelectedItem()), updateVmParams, new VmIconUnitAndVmToParameterBuilder());
    setRngDeviceToParams(model, updateVmParams);
    BuilderExecutor.build(model, updateVmParams, new UnitToGraphicsDeviceParamsBuilder());
    return updateVmParams;
}
#end_block

#method_before
private void changeCD(Object sender, EventArgs e) {
    ChangeCDModel model = (ChangeCDModel) sender;
    // TODO: Patch!
    String isoName = model.getTitle();
    if (ObjectUtils.objectsEqual(isoName, ConstantsManager.getInstance().getConstants().noCds())) {
        return;
    }
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeDisk, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(vm.getId(), // $NON-NLS-1$
    ObjectUtils.objectsEqual(isoName, ConsoleModel.getEjectLabel()) ? "" : isoName) })), new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void changeCD(Object sender, EventArgs e) {
    ChangeCDModel model = (ChangeCDModel) sender;
    // TODO: Patch!
    String isoName = model.getTitle();
    if (ObjectUtils.objectsEqual(isoName, ConstantsManager.getInstance().getConstants().noCds())) {
        return;
    }
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeDisk, new ArrayList<>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(vm.getId(), // $NON-NLS-1$
    ObjectUtils.objectsEqual(isoName, ConsoleModel.getEjectLabel()) ? "" : isoName) })), new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
public void cancel() {
    cancelConfirmation();
    setGuideContext(null);
    setWindow(null);
    updateActionAvailability();
}
#method_after
@Override
public void cancel() {
    cancelConfirmation();
    setGuideContext(null);
    setWindow(null);
    updateActionsAvailability();
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionsAvailability();
}
#end_block

#method_before
@Override
protected void selectedItemsChanged() {
    super.selectedItemsChanged();
    updateActionAvailability();
}
#method_after
@Override
protected void selectedItemsChanged() {
    super.selectedItemsChanged();
    updateActionsAvailability();
}
#end_block

#method_before
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.propertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#method_after
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.propertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionsAvailability();
    }
}
#end_block

#method_before
private boolean isConsoleEditEnabled() {
    return getSelectedItem() != null && ((VM) getSelectedItem()).isRunningOrPaused();
}
#method_after
private boolean isConsoleEditEnabled() {
    return getSelectedItem() != null && getSelectedItem().isRunningOrPaused();
}
#end_block

#method_before
private void updateHaMaintenanceAvailability(List items) {
    if (items == null || items.size() != 1) {
        setHaMaintenanceAvailability(false);
        return;
    }
    VM vm = (VM) getSelectedItem();
    if (vm == null || !vm.isHostedEngine() || vm.getVdsGroupCompatibilityVersion().compareTo(Version.v3_4) < 0) {
        setHaMaintenanceAvailability(false);
    } else {
        setHaMaintenanceAvailability(true);
    }
}
#method_after
private void updateHaMaintenanceAvailability(List items) {
    if (items == null || items.size() != 1) {
        setHaMaintenanceAvailability(false);
        return;
    }
    VM vm = getSelectedItem();
    if (vm == null || !vm.isHostedEngine() || vm.getVdsGroupCompatibilityVersion().compareTo(Version.v3_4) < 0) {
        setHaMaintenanceAvailability(false);
    } else {
        setHaMaintenanceAvailability(true);
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnClone".equals(command.getName())) {
        onClone();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getSetConsoleKeyCommand()) {
        editConsoleKey();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnClone".equals(command.getName())) {
        onClone();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if ("OnSetConsoleKey".equals(command.getName())) {
        // $NON-NLS-1$
        onSetConsoleKey();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#end_block

#method_before
private void cloneVm() {
    final VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    CloneVmModel model = new CloneVmModel(vm, constants);
    setWindow(model);
    model.initialize();
    model.setTitle(ConstantsManager.getInstance().getConstants().cloneVmTitle());
    model.setHelpTag(HelpTag.clone_vm);
    // $NON-NLS-1$
    model.setHashName("clone_vm");
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OnClone", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancelCommand);
}
#method_after
private void cloneVm() {
    final VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    CloneVmModel model = new CloneVmModel(vm, constants);
    setWindow(model);
    model.initialize();
    model.setTitle(ConstantsManager.getInstance().getConstants().cloneVmTitle());
    model.setHelpTag(HelpTag.clone_vm);
    // $NON-NLS-1$
    model.setHashName("clone_vm");
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OnClone", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onRestoreFromExportDomain() {
    ImportVmFromExportDomainModel importModel = (ImportVmFromExportDomainModel) getWindow();
    if (importModel.getProgress() != null) {
        return;
    }
    if (!importModel.validate()) {
        return;
    }
    cloneObjectMap = new HashMap<Guid, Object>();
    objectsToClone = new ArrayList<Object>();
    for (Object object : (ArrayList<Object>) importModel.getItems()) {
        ImportEntityData item = (ImportEntityData) object;
        if ((Boolean) item.getClone().getEntity()) {
            objectsToClone.add(object);
        }
    }
    executeImportClone(importModel);
}
#method_after
private void onRestoreFromExportDomain() {
    ImportVmModel importModel = (ImportVmModel) getWindow();
    if (importModel.getProgress() != null) {
        return;
    }
    if (!importModel.validate()) {
        return;
    }
    importModel.importVms(new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            getWindow().stopProgress();
            setWindow(null);
        }
    });
}
#end_block

#method_before
private void setDetailList() {
    vmGeneralModel.setIsAvailable(false);
    vmSnapshotListModel.setIsAvailable(false);
    vmMonitorModel.setIsAvailable(false);
    vmDiskListModel.setIsAvailable(false);
    vmInterfaceListModel.setIsAvailable(false);
    poolGeneralModel.setIsAvailable(false);
    poolDiskListModel.setIsAvailable(false);
    poolInterfaceListModel.setIsAvailable(false);
    permissionListModel.setIsAvailable(true);
    vmEventListModel.setIsAvailable(true);
    vmAppListModel.setIsAvailable(true);
    vmGuestInfoModel.setIsAvailable(true);
    List<EntityModel> list = new ArrayList<EntityModel>();
    list.add(vmGeneralModel);
    list.add(poolGeneralModel);
    list.add(vmInterfaceListModel);
    list.add(poolInterfaceListModel);
    list.add(vmDiskListModel);
    list.add(poolDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(permissionListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(vmMonitorModel);
    list.add(vmGuestInfoModel);
    setDetailModels(list);
}
#method_after
private void setDetailList() {
    vmGeneralModel.setIsAvailable(false);
    vmSnapshotListModel.setIsAvailable(false);
    vmMonitorModel.setIsAvailable(false);
    vmDiskListModel.setIsAvailable(false);
    vmInterfaceListModel.setIsAvailable(false);
    poolGeneralModel.setIsAvailable(false);
    poolDiskListModel.setIsAvailable(false);
    poolInterfaceListModel.setIsAvailable(false);
    permissionListModel.setIsAvailable(true);
    vmEventListModel.setIsAvailable(true);
    vmAppListModel.setIsAvailable(true);
    vmGuestInfoModel.setIsAvailable(true);
    List<HasEntity<?>> /* extends VmOrPool */
    list = new ArrayList<>();
    list.add(vmGeneralModel);
    list.add(poolGeneralModel);
    list.add(vmInterfaceListModel);
    list.add(poolInterfaceListModel);
    list.add(vmDiskListModel);
    list.add(poolDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(permissionListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(vmMonitorModel);
    list.add(vmGuestInfoModel);
    setDetailModels((List) list);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newInternal();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSaveCommand()) {
        onSave();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        stopProgress(UserPortalListModel.this);
        setConfirmWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(UserPortalListModel.this, model.getApplyCpuLater().getEntity());
        setConfirmWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newInternal();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSaveCommand()) {
        onSave();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getSetConsoleKeyCommand()) {
        editConsoleKey();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    "OnSetConsoleKey".equals(command.getName())) {
        onSetConsoleKey();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        stopProgress(UserPortalListModel.this);
        setConfirmWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(UserPortalListModel.this, model.getApplyCpuLater().getEntity());
        setConfirmWindow(null);
    }
}
#end_block

#method_before
private void newTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    UnitVmModel windowModel = new UnitVmModel(new UserPortalNewTemplateVmModelBehavior(vm));
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    windowModel.setHelpTag(HelpTag.new_template);
    // $NON-NLS-1$
    windowModel.setHashName("new_template");
    windowModel.setIsNew(true);
    windowModel.getVmType().setSelectedItem(vm.getVmType());
    windowModel.initialize(null);
    windowModel.getIsTemplatePublic().setEntity(false);
    windowModel.getCommands().add(// $NON-NLS-1$)
    UICommand.createDefaultOkUiCommand("OnNewTemplate", this));
    // $NON-NLS-1$
    windowModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
    windowModel.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
}
#method_after
private void newTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    UnitVmModel windowModel = new UnitVmModel(new UserPortalNewTemplateVmModelBehavior(vm), this);
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    windowModel.setHelpTag(HelpTag.new_template);
    // $NON-NLS-1$
    windowModel.setHashName("new_template");
    windowModel.setIsNew(true);
    windowModel.getVmType().setSelectedItem(vm.getVmType());
    windowModel.initialize(null);
    windowModel.getIsTemplatePublic().setEntity(false);
    windowModel.getCommands().add(// $NON-NLS-1$)
    UICommand.createDefaultOkUiCommand("OnNewTemplate", this));
    // $NON-NLS-1$
    windowModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
    windowModel.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
}
#end_block

#method_before
private void newInternal() {
    UnitVmModel model = new UnitVmModel(new UserPortalNewVmModelBehavior());
    model.getVmType().setSelectedItem(VmType.Server);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void newInternal() {
    UnitVmModel model = new UnitVmModel(new UserPortalNewVmModelBehavior(), this);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new UserPortalExistingVmModelBehavior(vm));
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new UserPortalExistingVmModelBehavior(vm), this);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void saveNewVm(final UnitVmModel model) {
    setstorageDomain(model.getStorageDomain().getSelectedItem());
    VM vm = gettempVm();
    vm.setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    AddVmParameters parameters = new AddVmParameters(vm);
    parameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    parameters.setMakeCreatorExplicitOwner(true);
    parameters.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setRngDeviceToParams(model, parameters);
    BuilderExecutor.build(model, parameters, new UnitToGraphicsDeviceParamsBuilder());
    if (!StringHelper.isNullOrEmpty(model.getVmId().getEntity())) {
        parameters.setVmId(new Guid(model.getVmId().getEntity()));
    }
    Frontend.getInstance().runAction(model.getProvisioning().getEntity() ? VdcActionType.AddVmFromTemplate : VdcActionType.AddVm, parameters, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
}
#method_after
private void saveNewVm(final UnitVmModel model) {
    setstorageDomain(model.getStorageDomain().getSelectedItem());
    VM vm = gettempVm();
    vm.setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    AddVmParameters parameters = new AddVmParameters(vm);
    parameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    parameters.setMakeCreatorExplicitOwner(true);
    parameters.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    parameters.setVmLargeIcon(model.getIcon().getEntity().getIcon());
    setRngDeviceToParams(model, parameters);
    BuilderExecutor.build(model, parameters, new UnitToGraphicsDeviceParamsBuilder());
    if (!StringHelper.isNullOrEmpty(model.getVmId().getEntity())) {
        parameters.setVmId(new Guid(model.getVmId().getEntity()));
    }
    Frontend.getInstance().runAction(model.getProvisioning().getEntity() ? VdcActionType.AddVmFromTemplate : VdcActionType.AddVm, parameters, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
}
#end_block

#method_before
private VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase params = new VmManagementParametersBase(gettempVm());
    params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setRngDeviceToParams(model, params);
    params.setApplyChangesLater(applyCpuChangesLater);
    BuilderExecutor.build(model, params, new UnitToGraphicsDeviceParamsBuilder());
    return params;
}
#method_after
private VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase params = new VmManagementParametersBase(gettempVm());
    BuilderExecutor.build(new Pair<>((UnitVmModel) getWindow(), gettempVm()), params, new VmIconUnitAndVmToParameterBuilder());
    params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setRngDeviceToParams(model, params);
    params.setApplyChangesLater(applyCpuChangesLater);
    BuilderExecutor.build(model, params, new UnitToGraphicsDeviceParamsBuilder());
    return params;
}
#end_block

#method_before
private void updateDataCenterWithCluster() {
    UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    final VM vm = (VM) selectedItem.getEntity();
    DataCenterWithCluster selectedDataCenterWithCluster = null;
    for (DataCenterWithCluster candidate : model.getDataCenterWithClustersList().getItems()) {
        if (model.getIsNew()) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
        if (candidate.getDataCenter().getId().equals(vm.getStoragePoolId()) && candidate.getCluster().getId().equals(vm.getVdsGroupId())) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
    }
    if (!model.getIsNew() && selectedDataCenterWithCluster == null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, final Object loadedDataCenter) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) model;
                final UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object loadedCluster) {
                        DataCenterWithCluster newItem = new DataCenterWithCluster((StoragePool) loadedDataCenter, (VDSGroup) loadedCluster);
                        unitModel.getDataCenterWithClustersList().setItems(Arrays.asList(newItem));
                        unitModel.getDataCenterWithClustersList().setSelectedItem(newItem);
                    }
                }), vm.getVdsGroupId());
            }
        };
        AsyncDataProvider.getInstance().getDataCenterById(_asyncQuery, vm.getStoragePoolId());
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(selectedDataCenterWithCluster);
    }
    model.getDataCenterWithClustersList().setIsChangable(vm.getStatus() == VMStatus.Down);
}
#method_after
private void updateDataCenterWithCluster() {
    UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    final VM vm = (VM) selectedItem.getEntity();
    DataCenterWithCluster selectedDataCenterWithCluster = null;
    for (DataCenterWithCluster candidate : model.getDataCenterWithClustersList().getItems()) {
        if (model.getIsNew()) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
        if (candidate.getDataCenter().getId().equals(vm.getStoragePoolId()) && candidate.getCluster().getId().equals(vm.getVdsGroupId())) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
    }
    if (!model.getIsNew() && selectedDataCenterWithCluster == null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, final Object loadedDataCenter) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) model;
                final UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object loadedCluster) {
                        DataCenterWithCluster newItem = new DataCenterWithCluster((StoragePool) loadedDataCenter, (VDSGroup) loadedCluster);
                        unitModel.getDataCenterWithClustersList().setItems(Arrays.asList(newItem));
                        unitModel.getDataCenterWithClustersList().setSelectedItem(newItem);
                    }
                }), vm.getVdsGroupId());
            }
        };
        AsyncDataProvider.getInstance().getDataCenterById(_asyncQuery, vm.getStoragePoolId());
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(selectedDataCenterWithCluster);
    }
    model.getDataCenterWithClustersList().setIsChangeable(vm.getStatus() == VMStatus.Down);
}
#end_block

#method_before
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concat(getvms(), filteredPools);
        if (filteredPools.isEmpty()) {
            finishSearch(all);
        } else {
            // if we have pools we have to update their console cache and THEN finish search
            List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
            List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
            for (VmPool p : filteredPools) {
                poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
                poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
            }
            Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

                @Override
                public void executed(FrontendMultipleQueryAsyncResult result) {
                    List<VM> poolRepresentants = new LinkedList<VM>();
                    List<VdcQueryReturnValue> poolRepresentantsRetval = result.getReturnValues();
                    for (VdcQueryReturnValue poolRepresentant : poolRepresentantsRetval) {
                        // extract from return value
                        poolRepresentants.add((VM) poolRepresentant.getReturnValue());
                    }
                    consoleModelsCache.updatePoolCache(poolRepresentants);
                    finishSearch(all);
                }
            });
        }
    }
}
#method_after
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        final ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        final List<Object> vms = Collections.<Object>unmodifiableList(getvms());
        final List<Pair<Object, VM>> vmPairs = Linq.wrapAsFirst(vms, VM.class);
        if (filteredPools.isEmpty()) {
            IconUtils.prefetchIcons(getvms(), true, false, new IconCache.IconsCallback() {

                @Override
                public void onSuccess(Map<Guid, String> idToIconMap) {
                    finishSearch(vmPairs);
                }
            });
        } else {
            // if we have pools we have to update their console cache and THEN finish search
            List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
            List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
            for (VmPool p : filteredPools) {
                poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
                poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
            }
            Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

                @Override
                public void executed(FrontendMultipleQueryAsyncResult result) {
                    List<VM> poolRepresentants = new LinkedList<VM>();
                    List<VdcQueryReturnValue> poolRepresentantsRetval = result.getReturnValues();
                    for (VdcQueryReturnValue poolRepresentant : poolRepresentantsRetval) {
                        // extract from return value
                        poolRepresentants.add((VM) poolRepresentant.getReturnValue());
                    }
                    consoleModelsCache.updatePoolCache(poolRepresentants);
                    final List<Pair<Object, VM>> poolsPairs = Linq.zip(Collections.<Object>unmodifiableList(filteredPools), poolRepresentants);
                    final List<Pair<Object, VM>> all = Linq.concat(vmPairs, poolsPairs);
                    final List<VM> vmsAndPoolRepresentants = Linq.concat(getvms(), poolRepresentants);
                    IconUtils.prefetchIcons(vmsAndPoolRepresentants, true, false, new IconCache.IconsCallback() {

                        @Override
                        public void onSuccess(Map<Guid, String> idToIconMap) {
                            finishSearch(all);
                        }
                    });
                }
            });
        }
    }
}
#end_block

#method_before
private void finishSearch(List vmsAndFilteredPools) {
    consoleModelsCache.updateVmCache(getvms());
    Collections.sort(vmsAndFilteredPools, new NameableComparator());
    ArrayList<Model> items = new ArrayList<Model>();
    for (Object item : vmsAndFilteredPools) {
        VmConsoles consoles = consoleModelsCache.getVmConsolesForEntity(item);
        UserPortalItemModel model = new UserPortalItemModel(item, consoles);
        model.setEntity(item);
        items.add(model);
    }
    setItems(items);
    setvms(null);
    setpools(null);
    getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
}
#method_after
private void finishSearch(List<Pair<Object, VM>> vmOrPoolAndPoolRepresentants) {
    consoleModelsCache.updateVmCache(getvms());
    Collections.sort((List) vmOrPoolAndPoolRepresentants, IconUtils.getFirstComponentNameableComparator());
    ArrayList<Model> items = new ArrayList<Model>();
    for (Pair<Object, VM> item : vmOrPoolAndPoolRepresentants) {
        VmConsoles consoles = consoleModelsCache.getVmConsolesForEntity(item.getFirst());
        UserPortalItemModel model = new UserPortalItemModel(item.getFirst(), consoles, item.getSecond());
        model.setEntity(item.getFirst());
        items.add(model);
    }
    setItems(items);
    setvms(null);
    setpools(null);
    getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
}
#end_block

#method_before
public void detach() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachVirtualMachinesTitle());
    model.setHelpTag(HelpTag.detach_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("detach_virtual_machine");
    ArrayList<String> list = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(a.getName());
    }
    Collections.sort(list);
    model.setItems(list);
    if (list.size() == getEntity().getAssignedVmsCount()) {
        model.getLatch().setIsAvailable(true);
        model.getLatch().setIsChangable(true);
        model.setNote(ConstantsManager.getInstance().getConstants().detachAllVmsWarning());
    }
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSurYouWantToDetachSelectedVirtualMachinesMsg());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnDetach", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
public void detach() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachVirtualMachinesTitle());
    model.setHelpTag(HelpTag.detach_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("detach_virtual_machine");
    ArrayList<String> list = new ArrayList<String>();
    for (VM item : getSelectedItems()) {
        list.add(item.getName());
    }
    Collections.sort(list);
    model.setItems(list);
    if (list.size() == getEntity().getAssignedVmsCount()) {
        model.getLatch().setIsAvailable(true);
        model.getLatch().setIsChangeable(true);
        model.setNote(ConstantsManager.getInstance().getConstants().detachAllVmsWarning());
    }
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSurYouWantToDetachSelectedVirtualMachinesMsg());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnDetach", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@TabInfo(container = ExtendedVmSubTabPanelPresenter.class)
static TabData getTabData(ApplicationConstants applicationConstants, UserPortalDetailModelProvider<UserPortalListModel, VmGuestInfoModel> modelProvider) {
    return new ModelBoundTabData(applicationConstants.extendedVirtualMachineGuestInfoSubTabLabel(), 11, modelProvider);
}
#method_after
@TabInfo(container = ExtendedVmSubTabPanelPresenter.class)
static TabData getTabData(UserPortalDetailModelProvider<UserPortalListModel, VmGuestInfoModel> modelProvider) {
    return new ModelBoundTabData(constants.extendedVirtualMachineGuestInfoSubTabLabel(), 11, modelProvider);
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabBasicPresenter.class, MainTabBasicPresenter.ViewDef.class, MainTabBasicView.class, MainTabBasicPresenter.ProxyDef.class);
    bindPresenter(MainTabExtendedPresenter.class, MainTabExtendedPresenter.ViewDef.class, MainTabExtendedView.class, MainTabExtendedPresenter.ProxyDef.class);
    // Main section: side tabs
    bindPresenter(SideTabExtendedVirtualMachinePresenter.class, SideTabExtendedVirtualMachinePresenter.ViewDef.class, SideTabExtendedVirtualMachineView.class, SideTabExtendedVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedTemplatePresenter.class, SideTabExtendedTemplatePresenter.ViewDef.class, SideTabExtendedTemplateView.class, SideTabExtendedTemplatePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedResourcePresenter.class, SideTabExtendedResourcePresenter.ViewDef.class, SideTabExtendedResourceView.class, SideTabExtendedResourcePresenter.ProxyDef.class);
    // Main section: sub tabs
    // Virtual Machine
    bindPresenter(ExtendedVmSubTabPanelPresenter.class, ExtendedVmSubTabPanelPresenter.ViewDef.class, ExtendedVmSubTabPanelView.class, ExtendedVmSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGeneralPresenter.class, SubTabExtendedVmGeneralPresenter.ViewDef.class, SubTabExtendedVmGeneralView.class, SubTabExtendedVmGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolGeneralPresenter.class, SubTabExtendedPoolGeneralPresenter.ViewDef.class, SubTabExtendedPoolGeneralView.class, SubTabExtendedPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmNetworkInterfacePresenter.class, SubTabExtendedVmNetworkInterfacePresenter.ViewDef.class, SubTabExtendedVmNetworkInterfaceView.class, SubTabExtendedVmNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolNetworkInterfacePresenter.class, SubTabExtendedPoolNetworkInterfacePresenter.ViewDef.class, SubTabExtendedPoolNetworkInterfaceView.class, SubTabExtendedPoolNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmVirtualDiskPresenter.class, SubTabExtendedVmVirtualDiskPresenter.ViewDef.class, SubTabExtendedVmVirtualDiskView.class, SubTabExtendedVmVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolVirtualDiskPresenter.class, SubTabExtendedPoolVirtualDiskPresenter.ViewDef.class, SubTabExtendedPoolVirtualDiskView.class, SubTabExtendedPoolVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmSnapshotPresenter.class, SubTabExtendedVmSnapshotPresenter.ViewDef.class, SubTabExtendedVmSnapshotView.class, SubTabExtendedVmSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmPermissionPresenter.class, SubTabExtendedVmPermissionPresenter.ViewDef.class, SubTabExtendedVmPermissionView.class, SubTabExtendedVmPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmEventPresenter.class, SubTabExtendedVmEventPresenter.ViewDef.class, SubTabExtendedVmEventView.class, SubTabExtendedVmEventPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmApplicationPresenter.class, SubTabExtendedVmApplicationPresenter.ViewDef.class, SubTabExtendedVmApplicationView.class, SubTabExtendedVmApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmMonitorPresenter.class, SubTabExtendedVmMonitorPresenter.ViewDef.class, SubTabExtendedVmMonitorView.class, SubTabExtendedVmMonitorPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGuestInfoPresenter.class, SubTabExtendedVmGuestInfoPresenter.ViewDef.class, SubTabExtendedVmGuestInfoView.class, SubTabExtendedVmGuestInfoPresenter.ProxyDef.class);
    // Template
    bindPresenter(ExtendedTemplateSubTabPanelPresenter.class, ExtendedTemplateSubTabPanelPresenter.ViewDef.class, ExtendedTemplateSubTabPanelView.class, ExtendedTemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateGeneralPresenter.class, SubTabExtendedTemplateGeneralPresenter.ViewDef.class, SubTabExtendedTemplateGeneralView.class, SubTabExtendedTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateNetworkInterfacesPresenter.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ViewDef.class, SubTabExtendedTemplateNetworkInterfacesView.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateVirtualDisksPresenter.class, SubTabExtendedTemplateVirtualDisksPresenter.ViewDef.class, SubTabExtendedTemplateVirtualDisksView.class, SubTabExtendedTemplateVirtualDisksPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateEventsPresenter.class, SubTabExtendedTemplateEventsPresenter.ViewDef.class, SubTabExtendedTemplateEventsView.class, SubTabExtendedTemplateEventsPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplatePermissionsPresenter.class, SubTabExtendedTemplatePermissionsPresenter.ViewDef.class, SubTabExtendedTemplatePermissionsView.class, SubTabExtendedTemplatePermissionsPresenter.ProxyDef.class);
    // Main section: basic view
    bindSingletonPresenterWidget(MainTabBasicDetailsPresenterWidget.class, MainTabBasicDetailsPresenterWidget.ViewDef.class, MainTabBasicDetailsView.class);
    bindSingletonPresenterWidget(MainTabBasicListPresenterWidget.class, MainTabBasicListPresenterWidget.ViewDef.class, MainTabBasicListView.class);
    bindPresenterWidget(MainTabBasicListItemPresenterWidget.class, MainTabBasicListItemPresenterWidget.ViewDef.class, MainTabBasicListItemView.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // VM popups
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Template popups
    bindPresenterWidget(TemplateEditPopupPresenterWidget.class, TemplateEditPopupPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabBasicPresenter.class, MainTabBasicPresenter.ViewDef.class, MainTabBasicView.class, MainTabBasicPresenter.ProxyDef.class);
    bindPresenter(MainTabExtendedPresenter.class, MainTabExtendedPresenter.ViewDef.class, MainTabExtendedView.class, MainTabExtendedPresenter.ProxyDef.class);
    // Main section: side tabs
    bindPresenter(SideTabExtendedVirtualMachinePresenter.class, SideTabExtendedVirtualMachinePresenter.ViewDef.class, SideTabExtendedVirtualMachineView.class, SideTabExtendedVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedTemplatePresenter.class, SideTabExtendedTemplatePresenter.ViewDef.class, SideTabExtendedTemplateView.class, SideTabExtendedTemplatePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedResourcePresenter.class, SideTabExtendedResourcePresenter.ViewDef.class, SideTabExtendedResourceView.class, SideTabExtendedResourcePresenter.ProxyDef.class);
    // Main section: sub tabs
    // Virtual Machine
    bindPresenter(ExtendedVmSubTabPanelPresenter.class, ExtendedVmSubTabPanelPresenter.ViewDef.class, ExtendedVmSubTabPanelView.class, ExtendedVmSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGeneralPresenter.class, SubTabExtendedVmGeneralPresenter.ViewDef.class, SubTabExtendedVmGeneralView.class, SubTabExtendedVmGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolGeneralPresenter.class, SubTabExtendedPoolGeneralPresenter.ViewDef.class, SubTabExtendedPoolGeneralView.class, SubTabExtendedPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmNetworkInterfacePresenter.class, SubTabExtendedVmNetworkInterfacePresenter.ViewDef.class, SubTabExtendedVmNetworkInterfaceView.class, SubTabExtendedVmNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolNetworkInterfacePresenter.class, SubTabExtendedPoolNetworkInterfacePresenter.ViewDef.class, SubTabExtendedPoolNetworkInterfaceView.class, SubTabExtendedPoolNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmVirtualDiskPresenter.class, SubTabExtendedVmVirtualDiskPresenter.ViewDef.class, SubTabExtendedVmVirtualDiskView.class, SubTabExtendedVmVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolVirtualDiskPresenter.class, SubTabExtendedPoolVirtualDiskPresenter.ViewDef.class, SubTabExtendedPoolVirtualDiskView.class, SubTabExtendedPoolVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmSnapshotPresenter.class, SubTabExtendedVmSnapshotPresenter.ViewDef.class, SubTabExtendedVmSnapshotView.class, SubTabExtendedVmSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmPermissionPresenter.class, SubTabExtendedVmPermissionPresenter.ViewDef.class, SubTabExtendedVmPermissionView.class, SubTabExtendedVmPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmEventPresenter.class, SubTabExtendedVmEventPresenter.ViewDef.class, SubTabExtendedVmEventView.class, SubTabExtendedVmEventPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmApplicationPresenter.class, SubTabExtendedVmApplicationPresenter.ViewDef.class, SubTabExtendedVmApplicationView.class, SubTabExtendedVmApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmMonitorPresenter.class, SubTabExtendedVmMonitorPresenter.ViewDef.class, SubTabExtendedVmMonitorView.class, SubTabExtendedVmMonitorPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGuestInfoPresenter.class, SubTabExtendedVmGuestInfoPresenter.ViewDef.class, SubTabExtendedVmGuestInfoView.class, SubTabExtendedVmGuestInfoPresenter.ProxyDef.class);
    // Template
    bindPresenter(ExtendedTemplateSubTabPanelPresenter.class, ExtendedTemplateSubTabPanelPresenter.ViewDef.class, ExtendedTemplateSubTabPanelView.class, ExtendedTemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateGeneralPresenter.class, SubTabExtendedTemplateGeneralPresenter.ViewDef.class, SubTabExtendedTemplateGeneralView.class, SubTabExtendedTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateNetworkInterfacesPresenter.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ViewDef.class, SubTabExtendedTemplateNetworkInterfacesView.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateVirtualDisksPresenter.class, SubTabExtendedTemplateVirtualDisksPresenter.ViewDef.class, SubTabExtendedTemplateVirtualDisksView.class, SubTabExtendedTemplateVirtualDisksPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateEventsPresenter.class, SubTabExtendedTemplateEventsPresenter.ViewDef.class, SubTabExtendedTemplateEventsView.class, SubTabExtendedTemplateEventsPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplatePermissionsPresenter.class, SubTabExtendedTemplatePermissionsPresenter.ViewDef.class, SubTabExtendedTemplatePermissionsView.class, SubTabExtendedTemplatePermissionsPresenter.ProxyDef.class);
    // Main section: basic view
    bindSingletonPresenterWidget(MainTabBasicDetailsPresenterWidget.class, MainTabBasicDetailsPresenterWidget.ViewDef.class, MainTabBasicDetailsView.class);
    bindSingletonPresenterWidget(MainTabBasicListPresenterWidget.class, MainTabBasicListPresenterWidget.ViewDef.class, MainTabBasicListView.class);
    bindPresenterWidget(MainTabBasicListItemPresenterWidget.class, MainTabBasicListItemPresenterWidget.ViewDef.class, MainTabBasicListItemView.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // VM popups
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    bindPresenterWidget(PublicKeyPopupPresenterWidget.class, PublicKeyPopupPresenterWidget.ViewDef.class, PublicKeyPopupView.class);
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Template popups
    bindPresenterWidget(TemplateEditPopupPresenterWidget.class, TemplateEditPopupPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Console Public Key
    bindPresenterWidget(PublicKeyPopupPresenterWidget.class, PublicKeyPopupPresenterWidget.ViewDef.class, PublicKeyPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#end_block

#method_before
private void updateProperties() {
    VM vm = (VM) getEntity();
    this.setClientIp(vm.getClientIp());
    this.setConsoleUserName(vm.getConsoleCurentUserName());
    this.setGuestUserName(vm.getGuestCurentUserName());
    this.setGuestOsArch(vm.getGuestOsArch());
    this.setGuestOsCodename(vm.getGuestOsCodename());
    this.setGuestOsDistribution(vm.getGuestOsDistribution());
    this.setGuestOsKernelVersion(vm.getGuestOsKernelVersion());
    this.setGuestOsType(vm.getGuestOsType());
    this.setGuestOsVersion(vm.getGuestOsVersion());
    this.setTimezoneName(vm.getTimezoneName());
    this.setTimezoneOffset(vm.getTimezoneOffset());
    StringBuilder builder = new StringBuilder();
    if (guestOsType == OsType.Linux) {
        // E.g Fedora 20 (Heisenbug)
        builder.append(guestOsDistribution);
        // $NON-NLS-1$
        builder.append(' ');
        builder.append(guestOsVersion);
        if (!StringUtils.isEmpty(guestOsCodename)) {
            // $NON-NLS-1$
            builder.append(" (");
            builder.append(guestOsCodename);
            // $NON-NLS-1$
            builder.append(')');
        }
    } else if (guestOsType == OsType.Windows && guestOs.startsWith("Win ")) {
        // $NON-NLS-1$
        // $NON-NLS-1$
        builder.append("Microsoft Windows ");
        builder.append(guestOs.substring(4));
        if (guestOs.startsWith("Win 20")) {
            // $NON-NLS-1$
            // $NON-NLS-1$
            builder.append(" Server");
        }
        // $NON-NLS-1$
        builder.append(" (");
        builder.append(guestOsVersion);
        // $NON-NLS-1$
        builder.append(')');
    }
    guestOsNamedVersion = builder.toString();
    builder = new StringBuilder();
    builder.append(timezoneName);
    // $NON-NLS-1$
    builder.append(" (UTC");
    if (timezoneOffset >= 0) {
        // $NON-NLS-1$
        builder.append('+');
    } else {
        // $NON-NLS-1$
        builder.append('-');
    }
    // $NON-NLS-1$
    builder.append(NumberFormat.getFormat("00").format(timezoneOffset / 60.));
    // $NON-NLS-1$
    builder.append(':');
    // $NON-NLS-1$
    builder.append(NumberFormat.getFormat("00").format(timezoneOffset % 60));
    // $NON-NLS-1$
    builder.append(')');
    guestOsTimezone = builder.toString();
}
#method_after
private void updateProperties() {
    VM vm = getEntity();
    setClientIp(vm.getClientIp());
    setConsoleUserName(vm.getConsoleCurentUserName());
    setGuestUserName(vm.getGuestCurentUserName());
    setGuestOsArch(vm.getGuestOsArch());
    setGuestOsCodename(vm.getGuestOsCodename());
    setGuestOsDistribution(vm.getGuestOsDistribution());
    setGuestOsKernelVersion(vm.getGuestOsKernelVersion());
    setGuestOsType(vm.getGuestOsType());
    setGuestOsVersion(vm.getGuestOsVersion());
    setGuestOsTimezoneName(vm.getGuestOsTimezoneName());
    setGuestOsTimezoneOffset(vm.getGuestOsTimezoneOffset());
    if (guestOsType == OsType.Linux) {
        // $NON-NLS-1$
        String optional = "";
        if (!StringUtils.isEmpty(guestOsCodename)) {
            optional = messages.guestOSVersionOptional(guestOsCodename);
        }
        guestOsNamedVersion = messages.guestOSVersionLinux(guestOsDistribution, guestOsVersion, optional);
    } else if (guestOsType == OsType.Windows && guestOs.startsWith("Win ")) {
        // $NON-NLS-1$
        if (guestOs.startsWith("Win 20")) {
            // $NON-NLS-1$
            guestOsNamedVersion = messages.guestOSVersionWindowsServer(guestOs.substring(4), guestOsVersion);
        } else {
            guestOsNamedVersion = messages.guestOSVersionWindows(guestOs.substring(4), guestOsVersion);
        }
    }
    // $NON-NLS-1$
    String hours = NumberFormat.getFormat("00").format(guestOsTimezoneOffset / 60.);
    // $NON-NLS-1$
    String minutes = NumberFormat.getFormat("00").format(guestOsTimezoneOffset % 60);
    if (guestOsTimezoneOffset >= 0) {
        guestOsTimezone = messages.positiveTimezoneOffset(guestOsTimezoneName, hours, minutes);
    } else {
        guestOsTimezone = messages.negativeTimezoneOffset(guestOsTimezoneName, hours, minutes);
    }
}
#end_block

#method_before
public void setGuestOsArch(GuestOsArchitectureType guestOsArch) {
    if (!ObjectUtils.objectsEqual(this.guestOsArch, guestOsArch)) {
        this.guestOsArch = guestOsArch;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("GuestOsArch"));
    }
}
#method_after
public void setGuestOsArch(ArchitectureType guestOsArch) {
    if (!ObjectUtils.objectsEqual(this.guestOsArch, guestOsArch)) {
        this.guestOsArch = guestOsArch;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("GuestOsArch"));
    }
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<VM, VmListModel> getVmListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AssignTagsPopupPresenterWidget> assignTagsPopupProvider, final Provider<VmMakeTemplatePopupPresenterWidget> makeTemplatePopupProvider, final Provider<VmRunOncePopupPresenterWidget> runOncePopupProvider, final Provider<VmChangeCDPopupPresenterWidget> changeCDPopupProvider, final Provider<VmExportPopupPresenterWidget> exportPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createSnapshotPopupProvider, final Provider<VmMigratePopupPresenterWidget> migratePopupProvider, final Provider<VmPopupPresenterWidget> newVmPopupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VmRemovePopupPresenterWidget> vmRemoveConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<ConsolePopupPresenterWidget> consolePopupProvider, final Provider<VncInfoPopupPresenterWidget> vncWindoProvider, final Provider<VmNextRunConfigurationPresenterWidget> nextRunProvider, final Provider<ImportVmsPopupPresenterWidget> importVmsProvider, final Provider<ImportCloneDialogPresenterWidget> importClonePopupProvider, final Provider<CloneVmPopupPresenterWidget> cloneVmProvider, final Provider<ImportVmFromExportDomainPopupPresenterWidget> importVmFromExportDomainPopupProvider, final Provider<VmListModel> modelProvider, final Provider<CommonModel> commonModelProvider) {
    MainTabModelProvider<VM, VmListModel> result = new MainTabModelProvider<VM, VmListModel>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAssignTagsCommand()) {
                return assignTagsPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getNewTemplateCommand()) {
                return makeTemplatePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRunOnceCommand()) {
                return runOncePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getChangeCdCommand()) {
                return changeCDPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getExportCommand()) {
                return exportPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCreateSnapshotCommand()) {
                return createSnapshotPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getMigrateCommand()) {
                return migratePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getNewVmCommand()) {
                return newVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return newVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (windowModel instanceof VncInfoModel) {
                return vncWindoProvider.get();
            } else if (lastExecutedCommand == getModel().getEditConsoleCommand()) {
                return consolePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                return cloneVmProvider.get();
            } else if (lastExecutedCommand == getModel().getImportVmCommand() || windowModel instanceof ImportVmsModel) {
                return importVmsProvider.get();
            } else if (windowModel instanceof ImportVmFromExportDomainModel) {
                return importVmFromExportDomainPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return vmRemoveConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getShutdownCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (source.getConfirmWindow() instanceof ImportCloneModel) {
                return importClonePopupProvider.get();
            } else if ("OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                return nextRunProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<VM, VmListModel<Void>> getVmListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AssignTagsPopupPresenterWidget> assignTagsPopupProvider, final Provider<VmMakeTemplatePopupPresenterWidget> makeTemplatePopupProvider, final Provider<VmRunOncePopupPresenterWidget> runOncePopupProvider, final Provider<VmChangeCDPopupPresenterWidget> changeCDPopupProvider, final Provider<PublicKeyPopupPresenterWidget> publicKeyPopupProvider, final Provider<VmExportPopupPresenterWidget> exportPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createSnapshotPopupProvider, final Provider<VmMigratePopupPresenterWidget> migratePopupProvider, final Provider<VmPopupPresenterWidget> newVmPopupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VmRemovePopupPresenterWidget> vmRemoveConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<ConsolePopupPresenterWidget> consolePopupProvider, final Provider<VncInfoPopupPresenterWidget> vncWindoProvider, final Provider<VmNextRunConfigurationPresenterWidget> nextRunProvider, final Provider<ImportVmsPopupPresenterWidget> importVmsProvider, final Provider<CloneVmPopupPresenterWidget> cloneVmProvider, final Provider<ImportVmFromExportDomainPopupPresenterWidget> importVmFromExportDomainPopupProvider, final Provider<VmListModel<Void>> modelProvider, final Provider<CommonModel> commonModelProvider, final Provider<VmDiskPopupPresenterWidget> newDiskPopupProvider, final Provider<SingleSelectionVmDiskAttachPopupPresenterWidget> attachDiskPopupProvider, final Provider<VmDiskRemovePopupPresenterWidget> removeDiskConfirmPopupProvider) {
    MainTabModelProvider<VM, VmListModel<Void>> result = new MainTabModelProvider<VM, VmListModel<Void>>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAssignTagsCommand()) {
                return assignTagsPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getNewTemplateCommand()) {
                return makeTemplatePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRunOnceCommand()) {
                return runOncePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getChangeCdCommand()) {
                return changeCDPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getSetConsoleKeyCommand()) {
                return publicKeyPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getExportCommand()) {
                return exportPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCreateSnapshotCommand()) {
                return createSnapshotPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getMigrateCommand()) {
                return migratePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand() || lastExecutedCommand == getModel().getNewVmCommand() || "OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                if (windowModel instanceof AttachDiskModel) {
                    return attachDiskPopupProvider.get();
                } else if ((windowModel instanceof NewDiskModel) || (windowModel instanceof EditDiskModel)) {
                    return newDiskPopupProvider.get();
                } else {
                    return newVmPopupProvider.get();
                }
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (windowModel instanceof VncInfoModel) {
                return vncWindoProvider.get();
            } else if (lastExecutedCommand == getModel().getEditConsoleCommand()) {
                return consolePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                return cloneVmProvider.get();
            } else if (lastExecutedCommand == getModel().getImportVmCommand() || windowModel instanceof ImportVmsModel) {
                return importVmsProvider.get();
            } else if (windowModel instanceof ImportVmFromExportDomainModel) {
                return importVmFromExportDomainPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return vmRemoveConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getShutdownCommand()) {
                return removeConfirmPopupProvider.get();
            } else if ("OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                return nextRunProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return removeDiskConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<Disk, VmListModel, VmDiskListModel> getVmDiskListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmDiskPopupPresenterWidget> popupProvider, final Provider<VmDiskAttachPopupPresenterWidget> attachPopupProvider, final Provider<VmDiskRemovePopupPresenterWidget> removeConfirmPopupProvider, final Provider<DisksAllocationPopupPresenterWidget> movePopupProvider, final Provider<ChangeQuotaPopupPresenterWidget> changeQutoaPopupProvider, final Provider<VmListModel> mainModelProvider, final Provider<VmDiskListModel> modelProvider) {
    SearchableDetailTabModelProvider<Disk, VmListModel, VmDiskListModel> result = new SearchableDetailTabModelProvider<Disk, VmListModel, VmDiskListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmDiskListModel source, UICommand lastExecutedCommand, Model windowModel) {
            VmDiskListModel model = getModel();
            if (lastExecutedCommand == model.getNewCommand() || lastExecutedCommand == model.getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getAttachCommand()) {
                return attachPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getMoveCommand()) {
                return movePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getChangeQuotaCommand()) {
                return changeQutoaPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmDiskListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<Disk, VmListModel<Void>, VmDiskListModel> getVmDiskListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmDiskPopupPresenterWidget> popupProvider, final Provider<VmDiskAttachPopupPresenterWidget> attachPopupProvider, final Provider<VmDiskRemovePopupPresenterWidget> removeConfirmPopupProvider, final Provider<DisksAllocationPopupPresenterWidget> movePopupProvider, final Provider<ChangeQuotaPopupPresenterWidget> changeQutoaPopupProvider, final Provider<VmListModel<Void>> mainModelProvider, final Provider<VmDiskListModel> modelProvider) {
    SearchableDetailTabModelProvider<Disk, VmListModel<Void>, VmDiskListModel> result = new SearchableDetailTabModelProvider<Disk, VmListModel<Void>, VmDiskListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmDiskListModel source, UICommand lastExecutedCommand, Model windowModel) {
            VmDiskListModel model = getModel();
            if (lastExecutedCommand == model.getNewCommand() || lastExecutedCommand == model.getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getAttachCommand()) {
                return attachPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getMoveCommand()) {
                return movePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getChangeQuotaCommand()) {
                return changeQutoaPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmDiskListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<VmNetworkInterface, VmListModel, VmInterfaceListModel> getVmInterfaceListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmInterfacePopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VmListModel> mainModelProvider, final Provider<VmInterfaceListModel> modelProvider) {
    SearchableDetailTabModelProvider<VmNetworkInterface, VmListModel, VmInterfaceListModel> result = new SearchableDetailTabModelProvider<VmNetworkInterface, VmListModel, VmInterfaceListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmInterfaceListModel source, UICommand lastExecutedCommand, Model windowModel) {
            VmInterfaceListModel model = getModel();
            if (lastExecutedCommand == model.getNewCommand() || lastExecutedCommand == model.getEditCommand()) {
                return popupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmInterfaceListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<VmNetworkInterface, VmListModel<Void>, VmInterfaceListModel> getVmInterfaceListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmInterfacePopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VmListModel<Void>> mainModelProvider, final Provider<VmInterfaceListModel> modelProvider) {
    SearchableDetailTabModelProvider<VmNetworkInterface, VmListModel<Void>, VmInterfaceListModel> result = new SearchableDetailTabModelProvider<VmNetworkInterface, VmListModel<Void>, VmInterfaceListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmInterfaceListModel source, UICommand lastExecutedCommand, Model windowModel) {
            VmInterfaceListModel model = getModel();
            if (lastExecutedCommand == model.getNewCommand() || lastExecutedCommand == model.getEditCommand()) {
                return popupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmInterfaceListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<AuditLog, VmListModel, VmEventListModel> getVmEventListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<EventPopupPresenterWidget> eventPopupProvider, final Provider<VmListModel> mainModelProvider, final Provider<VmEventListModel> modelProvider) {
    SearchableDetailTabModelProvider<AuditLog, VmListModel, VmEventListModel> result = new SearchableDetailTabModelProvider<AuditLog, VmListModel, VmEventListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmEventListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getDetailsCommand())) {
                return eventPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<AuditLog, VmListModel<Void>, VmEventListModel> getVmEventListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<EventPopupPresenterWidget> eventPopupProvider, final Provider<VmListModel<Void>> mainModelProvider, final Provider<VmEventListModel> modelProvider) {
    SearchableDetailTabModelProvider<AuditLog, VmListModel<Void>, VmEventListModel> result = new SearchableDetailTabModelProvider<AuditLog, VmListModel<Void>, VmEventListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmEventListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getDetailsCommand())) {
                return eventPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<Snapshot, VmListModel, VmSnapshotListModel> getVmSnapshotListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createPopupProvider, final Provider<VmClonePopupPresenterWidget> cloneVmPopupProvider, final Provider<VmSnapshotPreviewPopupPresenterWidget> previewPopupProvider, final Provider<VmSnapshotCustomPreviewPopupPresenterWidget> customPreviewPopupProvider, final Provider<VmListModel> mainModelProvider, final Provider<VmSnapshotListModel> modelProvider) {
    SearchableDetailTabModelProvider<Snapshot, VmListModel, VmSnapshotListModel> result = new SearchableDetailTabModelProvider<Snapshot, VmListModel, VmSnapshotListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmSnapshotListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return createPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                getModel().setSystemTreeSelectedItem(this.getMainModel().getSystemTreeSelectedItem());
                return cloneVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getPreviewCommand()) {
                return previewPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCustomPreviewCommand()) {
                return customPreviewPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel> getVmSnapshotListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createPopupProvider, final Provider<VmClonePopupPresenterWidget> cloneVmPopupProvider, final Provider<VmMakeTemplatePopupPresenterWidget> cloneTemplatePopupProvider, final Provider<VmSnapshotPreviewPopupPresenterWidget> previewPopupProvider, final Provider<VmSnapshotCustomPreviewPopupPresenterWidget> customPreviewPopupProvider, final Provider<VmListModel<Void>> mainModelProvider, final Provider<VmSnapshotListModel> modelProvider) {
    SearchableDetailTabModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel> result = new SearchableDetailTabModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmSnapshotListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return createPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                getModel().setSystemTreeSelectedItem(this.getMainModel().getSystemTreeSelectedItem());
                return cloneVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getPreviewCommand()) {
                return previewPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCustomPreviewCommand()) {
                return customPreviewPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneTemplateCommand()) {
                return cloneTemplatePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<AffinityGroup, VmListModel, VmAffinityGroupListModel> getAffinityGroupListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AffinityGroupPopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VmListModel> mainModelProvider, final Provider<VmAffinityGroupListModel> modelProvider) {
    SearchableDetailTabModelProvider<AffinityGroup, VmListModel, VmAffinityGroupListModel> result = new SearchableDetailTabModelProvider<AffinityGroup, VmListModel, VmAffinityGroupListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmAffinityGroupListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmAffinityGroupListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<AffinityGroup, VmListModel<Void>, VmAffinityGroupListModel> getAffinityGroupListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AffinityGroupPopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VmListModel<Void>> mainModelProvider, final Provider<VmAffinityGroupListModel> modelProvider) {
    SearchableDetailTabModelProvider<AffinityGroup, VmListModel<Void>, VmAffinityGroupListModel> result = new SearchableDetailTabModelProvider<AffinityGroup, VmListModel<Void>, VmAffinityGroupListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmAffinityGroupListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmAffinityGroupListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(VmListModel.class).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(VmGuestInfoModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmEventListModel.class).in(Singleton.class);
    bind(VmSnapshotListModel.class).in(Singleton.class);
    bind(VmAffinityGroupListModel.class).in(Singleton.class);
    bind(VmAppListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VmListModel>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<VmListModel, VmGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<DetailModelProvider<VmListModel, VmGuestInfoModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel, VmGuestInfoModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<String, VmListModel, VmAppListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<String, VmListModel, VmAppListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permissions, VmListModel, PermissionListModel<VmListModel>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VmListModel>>() {
    }).in(Singleton.class);
}
#method_after
@Override
protected void configure() {
    bind(new TypeLiteral<VmListModel<Void>>() {
    }).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(VmImportGeneralModel.class).in(Singleton.class);
    bind(VmGuestInfoModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmEventListModel.class).in(Singleton.class);
    bind(VmSnapshotListModel.class).in(Singleton.class);
    bind(VmAffinityGroupListModel.class).in(Singleton.class);
    bind(new TypeLiteral<VmAppListModel<VM>>() {
    }).in(Singleton.class);
    bind(VmHostDeviceListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VM>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<VmDevicesListModel<VM>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<DetailModelProvider<ImportVmsModel, VmImportGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<ImportVmsModel, VmImportGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmGuestInfoModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmGuestInfoModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, VmListModel<Void>, PermissionListModel<VM>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VM, VmListModel<Void>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<VmDevice, VmListModel<Void>, VmDevicesListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VmDevice, VmListModel<Void>, VmDevicesListModel<VM>>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
@Before
public void setUp() {
    disksList = new LinkedList<>();
    initStorageDomains();
    initStorageDomainValidators();
    initMemoryStorageHandler();
}
#method_after
@Before
public void setUp() {
    disksList = new LinkedList<>();
    doNothing().when(memoryStorageHandler).updateDisksStorage(any(StorageDomain.class), anyListOf(DiskImage.class));
    validStorageDomain = initStorageDomain();
    initStorageDomainValidator(validStorageDomainValidator, ValidationResult.VALID);
    doReturn(validStorageDomainValidator).when(memoryStorageHandler).getStorageDomainValidator(validStorageDomain);
    invalidStorageDomain1 = initStorageDomain();
    initInvalidValidator(invalidStorageDomainValidator1);
    doReturn(invalidStorageDomainValidator1).when(memoryStorageHandler).getStorageDomainValidator(invalidStorageDomain1);
    invalidStorageDomain2 = initStorageDomain();
    initInvalidValidator(invalidStorageDomainValidator2);
    doReturn(invalidStorageDomainValidator2).when(memoryStorageHandler).getStorageDomainValidator(invalidStorageDomain2);
}
#end_block

#method_before
@Test
public void verifyNoDomainForMemoryWhenDomainIsNotDataDomain() {
    for (StorageDomainType storageDomainType : StorageDomainType.values()) {
        if (!storageDomainType.isDataDomain()) {
            validStorageDomain.setStorageDomainType(storageDomainType);
            verifyNoDomainForMemory(Arrays.asList(validStorageDomain));
        }
    }
}
#method_after
@Test
public void verifyNoDomainForMemoryWhenDomainIsNotDataDomain() {
    for (StorageDomainType storageDomainType : StorageDomainType.values()) {
        if (!storageDomainType.isDataDomain()) {
            validStorageDomain.setStorageDomainType(storageDomainType);
            verifyNoDomainForMemory(Collections.singletonList(validStorageDomain));
        }
    }
}
#end_block

#method_before
@Test
public void verifyNoDomainForMemoryWhenDomainIsNotActive() {
    for (StorageDomainStatus storageDomainStatus : StorageDomainStatus.values()) {
        if (storageDomainStatus != StorageDomainStatus.Active) {
            validStorageDomain.setStatus(storageDomainStatus);
            verifyNoDomainForMemory(Arrays.asList(validStorageDomain));
        }
    }
}
#method_after
@Test
public void verifyNoDomainForMemoryWhenDomainIsNotActive() {
    for (StorageDomainStatus storageDomainStatus : StorageDomainStatus.values()) {
        if (storageDomainStatus != StorageDomainStatus.Active) {
            validStorageDomain.setStatus(storageDomainStatus);
            verifyNoDomainForMemory(Collections.singletonList(validStorageDomain));
        }
    }
}
#end_block

#method_before
@Test
public void verifyNoDomainForMemoryWhenDomainHasLowSpace() {
    when(validStorageDomainValidator.isDomainWithinThresholds()).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN));
    verifyNoDomainForMemory(Arrays.asList(validStorageDomain));
}
#method_after
@Test
public void verifyNoDomainForMemoryWhenDomainHasLowSpace() {
    when(validStorageDomainValidator.isDomainWithinThresholds()).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN));
    verifyNoDomainForMemory(Collections.singletonList(validStorageDomain));
}
#end_block

#method_before
@Test
public void verifyNoDomainForMemoryWhenDomainHasNoSpaceForClonedDisks() {
    when(validStorageDomainValidator.hasSpaceForClonedDisks(anyCollectionOf(DiskImage.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN));
    verifyNoDomainForMemory(Arrays.asList(validStorageDomain));
}
#method_after
@Test
public void verifyNoDomainForMemoryWhenDomainHasNoSpaceForClonedDisks() {
    when(validStorageDomainValidator.hasSpaceForClonedDisks(anyCollectionOf(DiskImage.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN));
    verifyNoDomainForMemory(Collections.singletonList(validStorageDomain));
}
#end_block

#method_before
private void verifyDomainForMemory(List<StorageDomain> storageDomains) {
    StorageDomain storageDomain = memoryStorageHandler.findStorageDomainForMemory(storageDomains, disksList);
    assertNotNull(storageDomain);
    assertEquals(storageDomain, validStorageDomain);
}
#method_after
private void verifyDomainForMemory(List<StorageDomain> storageDomains) {
    StorageDomain storageDomain = memoryStorageHandler.findStorageDomainForMemory(storageDomains, disksList);
    assertEquals(storageDomain, validStorageDomain);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > getMacPool().getAvailableMacsCount()) {
            return failCanDoAction(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        }
    }
    if (!validateBallonDevice()) {
        return false;
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<>();
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > getMacPool().getAvailableMacsCount()) {
            return failCanDoAction(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        }
    }
    if (!validateBallonDevice()) {
        return false;
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#end_block

#method_before
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVmId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getSourceDomainId(image))));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#method_after
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
        VM vm = getVmFromExportDomain(getParameters().getVmId());
        if (vm == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND_ON_EXPORT_DOMAIN);
        }
        // At this point we should work with the VM that was read from
        // the OVF because the VM from the parameters may lack images
        setVmFromExportDomain(vm);
    }
    if (!validateImages(domainsMap)) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected List<VM> getVmsFromExportDomain() {
    GetAllFromExportDomainQueryParameters p = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetVmsFromExportDomain, p);
    return qRetVal.getSucceeded() ? qRetVal.<List<VM>>getReturnValue() : null;
}
#method_after
@SuppressWarnings("unchecked")
protected List<VM> getVmsFromExportDomain() {
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetVmsFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    return (List<VM>) (qRetVal.getSucceeded() ? qRetVal.getReturnValue() : Collections.emptyList());
}
#end_block

#method_before
private boolean updateDomainsForMemoryImages(List<DiskImage> disksList) {
    Map<String, String> handledMemoryVolumes = new HashMap<String, String>();
    for (Snapshot snapshot : getVm().getSnapshots()) {
        String memoryVolume = snapshot.getMemoryVolume();
        if (memoryVolume.isEmpty()) {
            continue;
        }
        if (handledMemoryVolumes.containsKey(memoryVolume)) {
            // replace the volume representation with the one with the correct domain & pool
            snapshot.setMemoryVolume(handledMemoryVolumes.get(memoryVolume));
            continue;
        }
        StorageDomain storageDomain = updateStorageDomainInMemoryVolumes(disksList);
        if (storageDomain == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        String modifiedMemoryVolume = MemoryUtils.changeStorageDomainAndPoolInMemoryState(memoryVolume, storageDomain.getId(), getParameters().getStoragePoolId());
        // replace the volume representation with the one with the correct domain & pool
        snapshot.setMemoryVolume(modifiedMemoryVolume);
        // save it in case we'll find other snapshots with the same memory volume
        handledMemoryVolumes.put(memoryVolume, modifiedMemoryVolume);
    }
    return true;
}
#method_after
private boolean updateDomainsForMemoryImages(List<DiskImage> disksList) {
    Map<String, String> handledMemoryVolumes = new HashMap<>();
    for (Snapshot snapshot : getVm().getSnapshots()) {
        String memoryVolume = snapshot.getMemoryVolume();
        if (memoryVolume.isEmpty()) {
            continue;
        }
        if (handledMemoryVolumes.containsKey(memoryVolume)) {
            // replace the volume representation with the one with the correct domain & pool
            snapshot.setMemoryVolume(handledMemoryVolumes.get(memoryVolume));
            continue;
        }
        StorageDomain storageDomain = updateStorageDomainInMemoryVolumes(disksList);
        if (storageDomain == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        String modifiedMemoryVolume = MemoryUtils.changeStorageDomainAndPoolInMemoryState(memoryVolume, storageDomain.getId(), getParameters().getStoragePoolId());
        // replace the volume representation with the one with the correct domain & pool
        snapshot.setMemoryVolume(modifiedMemoryVolume);
        // save it in case we'll find other snapshots with the same memory volume
        handledMemoryVolumes.put(memoryVolume, modifiedMemoryVolume);
    }
    return true;
}
#end_block

#method_before
private void setDiskStorageDomainInfo(DiskImage disk) {
    ArrayList<Guid> storageDomain = new ArrayList<Guid>();
    storageDomain.add(imageToDestinationDomainMap.get(disk.getId()));
    disk.setStorageIds(storageDomain);
}
#method_after
private void setDiskStorageDomainInfo(DiskImage disk) {
    ArrayList<Guid> storageDomain = new ArrayList<>();
    storageDomain.add(imageToDestinationDomainMap.get(disk.getId()));
    disk.setStorageIds(storageDomain);
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (Disk disk : getParameters().getVm().getDiskMap().values()) {
        // TODO: handle import more than once;
        if (disk instanceof DiskImage) {
            DiskImage diskImage = (DiskImage) disk;
            list.add(new QuotaStorageConsumptionParameter(diskImage.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, imageToDestinationDomainMap.get(diskImage.getId()), (double) diskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    for (Disk disk : getParameters().getVm().getDiskMap().values()) {
        // TODO: handle import more than once;
        if (disk instanceof DiskImage) {
            DiskImage diskImage = (DiskImage) disk;
            list.add(new QuotaStorageConsumptionParameter(diskImage.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, imageToDestinationDomainMap.get(diskImage.getId()), (double) diskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
public void updateDisksStorage(StorageDomain storageDomain, List<DiskImage> memoryDisks) {
    for (DiskImage disk : memoryDisks) {
        disk.setStorageIds(new ArrayList<Guid>(Collections.singletonList(storageDomain.getId())));
    }
    /*
        There should be two disks in the disksList, first of which is memory disk.
        Only its volume type should be modified.
         */
    updateDiskVolumeType(storageDomain.getStorageType(), memoryDisks.get(0));
}
#method_after
public void updateDisksStorage(StorageDomain storageDomain, List<DiskImage> memoryDisks) {
    for (DiskImage disk : memoryDisks) {
        disk.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
    }
    /*
        There should be two disks in the disksList, first of which is memory disk.
        Only its volume type should be modified.
         */
    updateDiskVolumeType(storageDomain.getStorageType(), memoryDisks.get(0));
}
#end_block

#method_before
protected void sortStorageDomains(List<StorageDomain> domainsInPool, Collection<DiskImage> vmDisks) {
    ComparatorChain comparatorChain = new ComparatorChain();
    // When there is more than one comparator, a nested sort is performed.
    for (Comparator<StorageDomain> comparator : getStorageDomainComparators(domainsInPool, vmDisks)) {
        comparatorChain.addComparator(comparator, true);
    }
    Collections.sort(domainsInPool, comparatorChain);
}
#method_after
protected void sortStorageDomains(List<StorageDomain> domainsInPool, Collection<DiskImage> vmDisks) {
    ComparatorChain comparatorChain = new ComparatorChain();
    // When there is more than one comparator, a nested sort is performed.
    for (Comparator<StorageDomain> comparator : getStorageDomainComparators(domainsInPool, vmDisks)) {
        // A reversed sort will be performed to get the "biggest" storage domain first.
        comparatorChain.addComparator(comparator, true);
    }
    Collections.sort(domainsInPool, comparatorChain);
}
#end_block

#method_before
@Test
public void filterAllDomains() {
    verifyDomainForMemory(Arrays.asList(invalidStorageDomain1, invalidStorageDomain2, invalidStorageDomain3), null);
}
#method_after
@Test
public void filterAllDomains() {
    List<StorageDomain> filteredStorageDomains = memoryStorageHandler.filterStorageDomains(Arrays.asList(invalidStorageDomain1, invalidStorageDomain2, invalidStorageDomain3), memoryDisks);
    assertTrue(filteredStorageDomains.isEmpty());
}
#end_block

#method_before
private void initFilters() {
    filter1 = new StorageDomainRejectingFilter(invalidStorageDomain1);
    filter2 = new StorageDomainRejectingFilter(invalidStorageDomain2);
    filter3 = new StorageDomainRejectingFilter(invalidStorageDomain3);
    List<StorageDomainFilter> storageDomainFilters = Arrays.asList(filter1, filter2, filter3);
    doReturn(storageDomainFilters).when(memoryStorageHandler).getStorageDomainFilters();
}
#method_after
private void initFilters() {
    List<StorageDomainRejectingFilter> storageDomainFilters = Arrays.asList(new StorageDomainRejectingFilter(invalidStorageDomain1), new StorageDomainRejectingFilter(invalidStorageDomain2), new StorageDomainRejectingFilter(invalidStorageDomain3));
    doReturn(storageDomainFilters).when(memoryStorageHandler).getStorageDomainFilters();
}
#end_block

#method_before
private void filterAllStorageDomainsExceptOne(List<StorageDomain> storageDomains, StorageDomain expectedStorageDomain) {
    List<StorageDomain> filteredStorageDomains = memoryStorageHandler.filterStorageDomains(storageDomains, memoryDisks);
    assertEquals(filteredStorageDomains, Arrays.asList(expectedStorageDomain));
}
#method_after
private void filterAllStorageDomainsExceptOne(List<StorageDomain> storageDomains, StorageDomain expectedStorageDomain) {
    List<StorageDomain> filteredStorageDomains = new ArrayList<>(memoryStorageHandler.filterStorageDomains(storageDomains, memoryDisks));
    assertEquals(filteredStorageDomains, Arrays.asList(expectedStorageDomain));
}
#end_block

#method_before
@Override
protected Predicate<StorageDomain> getPredicate(List<DiskImage> disksList) {
    return new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain storageDomain) {
            return !sdToReject.equals(storageDomain);
        }
    };
}
#method_after
@Override
protected Predicate<StorageDomain> getPredicate(List<DiskImage> memoryDisks) {
    return new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain storageDomain) {
            return !sdToReject.equals(storageDomain);
        }
    };
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (DiskImage disk : getDisksList()) {
        list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), disk.getActualSize()));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    for (DiskImage disk : getDisksList()) {
        list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), disk.getActualSize()));
    }
    return list;
}
#end_block

#method_before
@Override
protected void perform() {
    final Guid taskId1 = persistAsyncTaskPlaceHolder(getParameters().getParentCommand(), SAVE_IMAGE_TASK_KEY);
    Guid image1GroupId = Guid.newGuid();
    Guid hiberVol1 = Guid.newGuid();
    final VDSReturnValue ret1 = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getStoragePoolId(), getStorageDomainId(), image1GroupId, getVm().getTotalMemorySizeInBytes(), getMemoryVolumeType(), VolumeFormat.RAW, hiberVol1, ""));
    if (!ret1.getSucceeded()) {
        return;
    }
    Guid guid1 = createTask(taskId1, ret1.getCreationInfo(), VdcActionType.HibernateVm);
    getReturnValue().getVdsmTaskIdList().add(guid1);
    Guid taskId2 = persistAsyncTaskPlaceHolder(getParameters().getParentCommand(), SAVE_RAM_STATE_TASK_KEY);
    // second vol should be 10kb
    Guid image2GroupId = Guid.newGuid();
    Guid hiberVol2 = Guid.newGuid();
    VDSReturnValue ret2 = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getStoragePoolId(), getStorageDomainId(), image2GroupId, MemoryUtils.META_DATA_SIZE_IN_BYTES, VolumeType.Sparse, VolumeFormat.COW, hiberVol2, ""));
    if (!ret2.getSucceeded()) {
        return;
    }
    Guid guid2 = createTask(taskId2, ret2.getCreationInfo(), VdcActionType.HibernateVm);
    getReturnValue().getVdsmTaskIdList().add(guid2);
    getSnapshotDAO().updateHibernationMemory(getVmId(), MemoryUtils.createMemoryStateString(getStorageDomainId(), getStoragePoolId(), image1GroupId, hiberVol1, image2GroupId, hiberVol2));
    getParameters().setVdsmTaskIds(new ArrayList<Guid>(getReturnValue().getVdsmTaskIdList()));
    setSucceeded(true);
}
#method_after
@Override
protected void perform() {
    final Guid taskId1 = persistAsyncTaskPlaceHolder(getParameters().getParentCommand(), SAVE_IMAGE_TASK_KEY);
    Guid image1GroupId = Guid.newGuid();
    Guid hiberVol1 = Guid.newGuid();
    final VDSReturnValue ret1 = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getStoragePoolId(), getStorageDomainId(), image1GroupId, getVm().getTotalMemorySizeInBytes(), getMemoryVolumeType(), VolumeFormat.RAW, hiberVol1, ""));
    if (!ret1.getSucceeded()) {
        return;
    }
    Guid guid1 = createTask(taskId1, ret1.getCreationInfo(), VdcActionType.HibernateVm);
    getReturnValue().getVdsmTaskIdList().add(guid1);
    Guid taskId2 = persistAsyncTaskPlaceHolder(getParameters().getParentCommand(), SAVE_RAM_STATE_TASK_KEY);
    // second vol should be 10kb
    Guid image2GroupId = Guid.newGuid();
    Guid hiberVol2 = Guid.newGuid();
    VDSReturnValue ret2 = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getStoragePoolId(), getStorageDomainId(), image2GroupId, MemoryUtils.META_DATA_SIZE_IN_BYTES, VolumeType.Sparse, VolumeFormat.COW, hiberVol2, ""));
    if (!ret2.getSucceeded()) {
        return;
    }
    Guid guid2 = createTask(taskId2, ret2.getCreationInfo(), VdcActionType.HibernateVm);
    getReturnValue().getVdsmTaskIdList().add(guid2);
    getSnapshotDAO().updateHibernationMemory(getVmId(), MemoryUtils.createMemoryStateString(getStorageDomainId(), getStoragePoolId(), image1GroupId, hiberVol1, image2GroupId, hiberVol2));
    getParameters().setVdsmTaskIds(new ArrayList<>(getReturnValue().getVdsmTaskIdList()));
    setSucceeded(true);
}
#end_block

#method_before
@Test
public void filterAllDomains() {
    verifyDomainForMemory(Arrays.asList(invalidStorageDomain1, invalidStorageDomain2, invalidStorageDomain3), null);
}
#method_after
@Test
public void filterAllDomains() {
    List<StorageDomain> filteredStorageDomains = memoryStorageHandler.filterStorageDomains(Arrays.asList(invalidStorageDomain1, invalidStorageDomain2, invalidStorageDomain3), disksList);
    assertTrue(filteredStorageDomains.isEmpty());
}
#end_block

#method_before
private void initFilters() {
    filter1 = new StorageDomainRejectingFilter(invalidStorageDomain1);
    filter2 = new StorageDomainRejectingFilter(invalidStorageDomain2);
    filter3 = new StorageDomainRejectingFilter(invalidStorageDomain3);
    List<StorageDomainFilter> storageDomainFilters = Arrays.asList(filter1, filter2, filter3);
    doReturn(storageDomainFilters).when(memoryStorageHandler).getStorageDomainFilters();
}
#method_after
private void initFilters() {
    List<StorageDomainRejectingFilter> storageDomainFilters = Arrays.asList(new StorageDomainRejectingFilter(invalidStorageDomain1), new StorageDomainRejectingFilter(invalidStorageDomain2), new StorageDomainRejectingFilter(invalidStorageDomain3));
    doReturn(storageDomainFilters).when(memoryStorageHandler).getStorageDomainFilters();
}
#end_block

#method_before
private void filterAllStorageDomainsExceptOne(List<StorageDomain> storageDomains, StorageDomain expectedStorageDomain) {
    List<StorageDomain> filteredStorageDomains = memoryStorageHandler.filterStorageDomains(storageDomains, disksList);
    assertEquals(filteredStorageDomains, Arrays.asList(expectedStorageDomain));
}
#method_after
private void filterAllStorageDomainsExceptOne(List<StorageDomain> storageDomains, StorageDomain expectedStorageDomain) {
    List<StorageDomain> filteredStorageDomains = new ArrayList<>(memoryStorageHandler.filterStorageDomains(storageDomains, disksList));
    assertEquals(filteredStorageDomains, Arrays.asList(expectedStorageDomain));
}
#end_block

#method_before
private void verifyDomainForMemory(List<StorageDomain> storageDomains, StorageDomain expectedStorageDomain) {
    StorageDomain storageDomain = memoryStorageHandler.findStorageDomainForMemory(storageDomains, disksList);
    assertEquals(expectedStorageDomain, storageDomain);
}
#method_after
private void verifyDomainForMemory(List<StorageDomain> storageDomains) {
    StorageDomain storageDomain = memoryStorageHandler.findStorageDomainForMemory(storageDomains, disksList);
    assertEquals(storageDomain, validStorageDomain);
}
#end_block

#method_before
public void updateDisksStorage(StorageDomain storageDomain, List<DiskImage> disksList) {
    for (DiskImage disk : disksList) {
        disk.setStorageIds(new ArrayList<Guid>(Collections.singletonList(storageDomain.getId())));
    }
    /*
        There should be two disks in the disksList, first of which is memory disk.
        Only its volume type should be modified.
         */
    updateDiskVolumeType(storageDomain.getStorageType(), disksList.get(0));
}
#method_after
public void updateDisksStorage(StorageDomain storageDomain, List<DiskImage> disksList) {
    for (DiskImage disk : disksList) {
        disk.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
    }
    /*
        There should be two disks in the disksList, first of which is memory disk.
        Only its volume type should be modified.
         */
    updateDiskVolumeType(storageDomain.getStorageType(), disksList.get(0));
}
#end_block

#method_before
@Before
public void setUp() {
    disksList = new LinkedList<>();
    initStorageDomains();
    initStorageDomainValidators();
    initMemoryStorageHandler();
}
#method_after
@Before
public void setUp() {
    disksList = new LinkedList<>();
    doNothing().when(memoryStorageHandler).updateDisksStorage(any(StorageDomain.class), anyListOf(DiskImage.class));
    validStorageDomain = initStorageDomain();
    initStorageDomainValidator(validStorageDomainValidator, ValidationResult.VALID);
    doReturn(validStorageDomainValidator).when(memoryStorageHandler).getStorageDomainValidator(validStorageDomain);
    invalidStorageDomain1 = initStorageDomain();
    initInvalidValidator(invalidStorageDomainValidator1);
    doReturn(invalidStorageDomainValidator1).when(memoryStorageHandler).getStorageDomainValidator(invalidStorageDomain1);
    invalidStorageDomain2 = initStorageDomain();
    initInvalidValidator(invalidStorageDomainValidator2);
    doReturn(invalidStorageDomainValidator2).when(memoryStorageHandler).getStorageDomainValidator(invalidStorageDomain2);
}
#end_block

#method_before
@Test
public void verifyNoDomainForMemoryWhenDomainHasLowSpace() {
    when(validStorageDomainValidator.isDomainWithinThresholds()).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN));
    verifyNoDomainForMemory(Arrays.asList(validStorageDomain));
}
#method_after
@Test
public void verifyNoDomainForMemoryWhenDomainHasLowSpace() {
    when(validStorageDomainValidator.isDomainWithinThresholds()).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN));
    verifyNoDomainForMemory(Collections.singletonList(validStorageDomain));
}
#end_block

#method_before
private void verifyDomainForMemory(List<StorageDomain> storageDomains) {
    StorageDomain storageDomain = memoryStorageHandler.findStorageDomainForMemory(storageDomains, disksList);
    assertNotNull(storageDomain);
    assertEquals(storageDomain, validStorageDomain);
}
#method_after
private void verifyDomainForMemory(List<StorageDomain> storageDomains) {
    StorageDomain storageDomain = memoryStorageHandler.findStorageDomainForMemory(storageDomains, disksList);
    assertEquals(storageDomain, validStorageDomain);
}
#end_block

#method_before
protected void updateDisksStorage(StorageDomain storageDomain, List<DiskImage> disksList) {
    for (DiskImage disk : disksList) {
        disk.setStorageIds(new ArrayList<Guid>(Collections.singletonList(storageDomain.getId())));
    }
    /*
        There should be two disks in the disksList, first of which is memory disk.
        Only its volume type should be modified.
         */
    updateDiskVolumeType(storageDomain.getStorageType(), disksList.get(0));
}
#method_after
protected void updateDisksStorage(StorageDomain storageDomain, List<DiskImage> disksList) {
    for (DiskImage disk : disksList) {
        disk.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
    }
    /*
        There should be two disks in the disksList, first of which is memory disk.
        Only its volume type should be modified.
         */
    updateDiskVolumeType(storageDomain.getStorageType(), disksList.get(0));
}
#end_block

#method_before
public static List<Pair<EditableDeviceOnVmStatusField, Boolean>> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<Pair<EditableDeviceOnVmStatusField, Boolean>> fieldList = new ArrayList<>();
    if (objectWithEditableDeviceFields == null) {
        return fieldList;
    }
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        Boolean isEnabled = null;
        try {
            isEnabled = (Boolean) field.get(objectWithEditableDeviceFields);
        } catch (IllegalAccessException | ClassCastException e) {
            log.warn("VmHandler:: isUpdateValidForVmDevices: Reflection error");
            log.debug("Original exception was:", e);
        }
        // if device type is set to unknown, search by general type only
        // because some devices has more than one type, like sound can be ac97/ich6
        String device = null;
        if (annotation.type() != VmDeviceType.UNKNOWN) {
            device = annotation.type().getName();
        }
        if (isEnabled == null || !VmDeviceUtils.vmDeviceChanged(vmId, annotation.generalType(), device, isEnabled)) {
            continue;
        }
        if (!VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            fieldList.add(new Pair<>(annotation, isEnabled));
        }
    }
    return fieldList;
}
#method_after
public static List<VmDeviceUpdate> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<VmDeviceUpdate> fieldList = new ArrayList<>();
    if (objectWithEditableDeviceFields == null) {
        return fieldList;
    }
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        if (VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            // field may be updated on the current run, so not including for the next run
            continue;
        }
        try {
            Object value = field.get(objectWithEditableDeviceFields);
            if (value == null) {
            // preserve current configuration
            } else if (value instanceof Boolean) {
                addDeviceUpdateOnNextRun(vmId, annotation, null, value, fieldList);
            } else if (value instanceof VmManagementParametersBase.Optional) {
                VmManagementParametersBase.Optional<?> optional = (VmManagementParametersBase.Optional<?>) value;
                if (optional.isUpdate()) {
                    addDeviceUpdateOnNextRun(vmId, annotation, null, optional.getValue(), fieldList);
                }
            } else if (value instanceof Map) {
                Map<?, ?> map = (Map<?, ?>) value;
                for (Map.Entry<?, ?> entry : map.entrySet()) {
                    boolean success = addDeviceUpdateOnNextRun(vmId, annotation, entry.getKey(), entry.getValue(), fieldList);
                    if (!success)
                        break;
                }
            } else {
                log.warn("getVmDevicesFieldsToUpdateOnNextRun: Unsupported field type: " + value.getClass().getName());
            }
        } catch (IllegalAccessException | ClassCastException e) {
            log.warn("getVmDevicesFieldsToUpdateOnNextRun: Reflection error");
            log.debug("Original exception was:", e);
        }
    }
    return fieldList;
}
#end_block

#method_before
@Override
protected void perform() {
    final Guid taskId1 = persistAsyncTaskPlaceHolder(getParameters().getParentCommand(), SAVE_IMAGE_TASK_KEY);
    Guid image1GroupId = Guid.newGuid();
    Guid hiberVol1 = Guid.newGuid();
    final VDSReturnValue ret1 = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getStoragePoolId(), getStorageDomainId(), image1GroupId, getVm().getTotalMemorySizeInBytes(), getMemoryVolumeType(), VolumeFormat.RAW, hiberVol1, ""));
    if (!ret1.getSucceeded()) {
        return;
    }
    Guid guid1 = createTask(taskId1, ret1.getCreationInfo(), VdcActionType.HibernateVm);
    getReturnValue().getVdsmTaskIdList().add(guid1);
    Guid taskId2 = persistAsyncTaskPlaceHolder(getParameters().getParentCommand(), SAVE_RAM_STATE_TASK_KEY);
    // second vol should be 10kb
    Guid image2GroupId = Guid.newGuid();
    Guid hiberVol2 = Guid.newGuid();
    VDSReturnValue ret2 = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getStoragePoolId(), getStorageDomainId(), image2GroupId, MemoryUtils.META_DATA_SIZE_IN_BYTES, VolumeType.Sparse, VolumeFormat.COW, hiberVol2, ""));
    if (!ret2.getSucceeded()) {
        return;
    }
    Guid guid2 = createTask(taskId2, ret2.getCreationInfo(), VdcActionType.HibernateVm);
    getReturnValue().getVdsmTaskIdList().add(guid2);
    getSnapshotDAO().updateHibernationMemory(getVmId(), MemoryUtils.createMemoryStateString(getStorageDomainId(), getStoragePoolId(), image1GroupId, hiberVol1, image2GroupId, hiberVol2));
    getParameters().setVdsmTaskIds(new ArrayList<Guid>(getReturnValue().getVdsmTaskIdList()));
    setSucceeded(true);
}
#method_after
@Override
protected void perform() {
    final Guid taskId1 = persistAsyncTaskPlaceHolder(getParameters().getParentCommand(), SAVE_IMAGE_TASK_KEY);
    Guid image1GroupId = Guid.newGuid();
    Guid hiberVol1 = Guid.newGuid();
    final VDSReturnValue ret1 = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getStoragePoolId(), getStorageDomainId(), image1GroupId, getVm().getTotalMemorySizeInBytes(), getMemoryVolumeType(), VolumeFormat.RAW, hiberVol1, ""));
    if (!ret1.getSucceeded()) {
        return;
    }
    Guid guid1 = createTask(taskId1, ret1.getCreationInfo(), VdcActionType.HibernateVm);
    getReturnValue().getVdsmTaskIdList().add(guid1);
    Guid taskId2 = persistAsyncTaskPlaceHolder(getParameters().getParentCommand(), SAVE_RAM_STATE_TASK_KEY);
    // second vol should be 10kb
    Guid image2GroupId = Guid.newGuid();
    Guid hiberVol2 = Guid.newGuid();
    VDSReturnValue ret2 = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getStoragePoolId(), getStorageDomainId(), image2GroupId, MemoryUtils.META_DATA_SIZE_IN_BYTES, VolumeType.Sparse, VolumeFormat.COW, hiberVol2, ""));
    if (!ret2.getSucceeded()) {
        return;
    }
    Guid guid2 = createTask(taskId2, ret2.getCreationInfo(), VdcActionType.HibernateVm);
    getReturnValue().getVdsmTaskIdList().add(guid2);
    getSnapshotDAO().updateHibernationMemory(getVmId(), MemoryUtils.createMemoryStateString(getStorageDomainId(), getStoragePoolId(), image1GroupId, hiberVol1, image2GroupId, hiberVol2));
    getParameters().setVdsmTaskIds(new ArrayList<>(getReturnValue().getVdsmTaskIdList()));
    setSucceeded(true);
}
#end_block

#method_before
private static void updateDisksStorage(StorageDomain storageDomain, List<DiskImage> disksList) {
    for (DiskImage disk : disksList) {
        disk.setStorageIds(new ArrayList<Guid>(Collections.singletonList(storageDomain.getId())));
    }
    /*
        There should be two disks in the disksList, first of which is memory disk.
        Only its volume type should be modified.
         */
    updateDiskVolumeType(storageDomain.getStorageType(), disksList.get(0));
}
#method_after
private static void updateDisksStorage(StorageDomain storageDomain, List<DiskImage> disksList) {
    for (DiskImage disk : disksList) {
        disk.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
    }
    /*
        There should be two disks in the disksList, first of which is memory disk.
        Only its volume type should be modified.
         */
    updateDiskVolumeType(storageDomain.getStorageType(), disksList.get(0));
}
#end_block

#method_before
@Test
public void verifyDomainForMemory() {
    Guid sdId = Guid.newGuid();
    List<StorageDomain> storageDomains = createStorageDomains(sdId);
    long vmSpaceInBytes = SizeConverter.convert(VM_SPACE_IN_MB, SizeConverter.SizeUnit.MB, SizeConverter.SizeUnit.BYTES).intValue();
    List<DiskImage> disksList = MemoryUtils.createDiskDummies(vmSpaceInBytes, META_DATA_SIZE_IN_GB);
    StorageDomain storageDomain = MemoryStorageHandler.findStorageDomainForMemory(storageDomains, disksList);
    assertThat(storageDomain, notNullValue());
    if (storageDomain != null) {
        Guid selectedId = storageDomain.getId();
        assertThat(selectedId.equals(sdId), is(true));
    }
    mcr.mockConfigValue(ConfigValues.FreeSpaceCriticalLowInGB, THRESHOLD_HIGH_GB);
    storageDomain = MemoryStorageHandler.findStorageDomainForMemory(storageDomains, disksList);
    assertThat(storageDomain, nullValue());
}
#method_after
@Test
public void verifyDomainForMemory() {
    Guid sdId = Guid.newGuid();
    List<StorageDomain> storageDomains = createStorageDomains(sdId);
    long vmSpaceInBytes = SizeConverter.convert(VM_SPACE_IN_MB, SizeConverter.SizeUnit.MiB, SizeConverter.SizeUnit.BYTES).intValue();
    List<DiskImage> disksList = MemoryUtils.createDiskDummies(vmSpaceInBytes, META_DATA_SIZE_IN_GB);
    StorageDomain storageDomain = MemoryStorageHandler.findStorageDomainForMemory(storageDomains, disksList);
    assertThat(storageDomain, notNullValue());
    if (storageDomain != null) {
        Guid selectedId = storageDomain.getId();
        assertThat(selectedId.equals(sdId), is(true));
    }
    storageDomain.setCriticalSpaceActionBlocker(THRESHOLD_HIGH_GB);
    storageDomain = MemoryStorageHandler.findStorageDomainForMemory(storageDomains, disksList);
    assertThat(storageDomain, nullValue());
}
#end_block

#method_before
private static StorageDomain createStorageDomain(Guid guid, StorageType storageType, Integer size) {
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setId(guid);
    storageDomain.setStorageDomainType(StorageDomainType.Data);
    storageDomain.setStorageType(storageType);
    storageDomain.setStatus(StorageDomainStatus.Active);
    storageDomain.setAvailableDiskSize(size);
    return storageDomain;
}
#method_after
private static StorageDomain createStorageDomain(Guid guid, StorageType storageType, Integer size) {
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setId(guid);
    storageDomain.setStorageDomainType(StorageDomainType.Data);
    storageDomain.setStorageType(storageType);
    storageDomain.setStatus(StorageDomainStatus.Active);
    storageDomain.setAvailableDiskSize(size);
    storageDomain.setCriticalSpaceActionBlocker(THRESHOLD_IN_GB);
    return storageDomain;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (DiskImage disk : getDisksList()) {
        list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), disk.getActualSize()));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    for (DiskImage disk : getDisksList()) {
        list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), disk.getActualSize()));
    }
    return list;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > getMacPool().getAvailableMacsCount()) {
            return failCanDoAction(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        }
    }
    if (!validateBallonDevice()) {
        return false;
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<>();
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > getMacPool().getAvailableMacsCount()) {
            return failCanDoAction(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        }
    }
    if (!validateBallonDevice()) {
        return false;
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#end_block

#method_before
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVmId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getSourceDomainId(image))));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#method_after
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
        VM vm = getVmFromExportDomain(getParameters().getVmId());
        if (vm == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND_ON_EXPORT_DOMAIN);
        }
        // At this point we should work with the VM that was read from
        // the OVF because the VM from the parameters may lack images
        setVmFromExportDomain(vm);
    }
    if (!validateImages(domainsMap)) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected List<VM> getVmsFromExportDomain() {
    GetAllFromExportDomainQueryParameters p = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetVmsFromExportDomain, p);
    return qRetVal.getSucceeded() ? qRetVal.<List<VM>>getReturnValue() : null;
}
#method_after
@SuppressWarnings("unchecked")
protected List<VM> getVmsFromExportDomain() {
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetVmsFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    return (List<VM>) (qRetVal.getSucceeded() ? qRetVal.getReturnValue() : Collections.emptyList());
}
#end_block

#method_before
private boolean updateDomainsForMemoryImages(List<DiskImage> disksList) {
    Map<String, String> handledMemoryVolumes = new HashMap<String, String>();
    for (Snapshot snapshot : getVm().getSnapshots()) {
        String memoryVolume = snapshot.getMemoryVolume();
        if (memoryVolume.isEmpty()) {
            continue;
        }
        if (handledMemoryVolumes.containsKey(memoryVolume)) {
            // replace the volume representation with the one with the correct domain & pool
            snapshot.setMemoryVolume(handledMemoryVolumes.get(memoryVolume));
            continue;
        }
        StorageDomain storageDomain = updateStorageDomainInMemoryVolumes(disksList);
        if (storageDomain == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        String modifiedMemoryVolume = MemoryUtils.changeStorageDomainAndPoolInMemoryState(memoryVolume, storageDomain.getId(), getParameters().getStoragePoolId());
        // replace the volume representation with the one with the correct domain & pool
        snapshot.setMemoryVolume(modifiedMemoryVolume);
        // save it in case we'll find other snapshots with the same memory volume
        handledMemoryVolumes.put(memoryVolume, modifiedMemoryVolume);
    }
    return true;
}
#method_after
private boolean updateDomainsForMemoryImages(List<DiskImage> disksList) {
    Map<String, String> handledMemoryVolumes = new HashMap<>();
    for (Snapshot snapshot : getVm().getSnapshots()) {
        String memoryVolume = snapshot.getMemoryVolume();
        if (memoryVolume.isEmpty()) {
            continue;
        }
        if (handledMemoryVolumes.containsKey(memoryVolume)) {
            // replace the volume representation with the one with the correct domain & pool
            snapshot.setMemoryVolume(handledMemoryVolumes.get(memoryVolume));
            continue;
        }
        StorageDomain storageDomain = updateStorageDomainInMemoryVolumes(disksList);
        if (storageDomain == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        String modifiedMemoryVolume = MemoryUtils.changeStorageDomainAndPoolInMemoryState(memoryVolume, storageDomain.getId(), getParameters().getStoragePoolId());
        // replace the volume representation with the one with the correct domain & pool
        snapshot.setMemoryVolume(modifiedMemoryVolume);
        // save it in case we'll find other snapshots with the same memory volume
        handledMemoryVolumes.put(memoryVolume, modifiedMemoryVolume);
    }
    return true;
}
#end_block

#method_before
private void setDiskStorageDomainInfo(DiskImage disk) {
    ArrayList<Guid> storageDomain = new ArrayList<Guid>();
    storageDomain.add(imageToDestinationDomainMap.get(disk.getId()));
    disk.setStorageIds(storageDomain);
}
#method_after
private void setDiskStorageDomainInfo(DiskImage disk) {
    ArrayList<Guid> storageDomain = new ArrayList<>();
    storageDomain.add(imageToDestinationDomainMap.get(disk.getId()));
    disk.setStorageIds(storageDomain);
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (Disk disk : getParameters().getVm().getDiskMap().values()) {
        // TODO: handle import more than once;
        if (disk instanceof DiskImage) {
            DiskImage diskImage = (DiskImage) disk;
            list.add(new QuotaStorageConsumptionParameter(diskImage.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, imageToDestinationDomainMap.get(diskImage.getId()), (double) diskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    for (Disk disk : getParameters().getVm().getDiskMap().values()) {
        // TODO: handle import more than once;
        if (disk instanceof DiskImage) {
            DiskImage diskImage = (DiskImage) disk;
            list.add(new QuotaStorageConsumptionParameter(diskImage.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, imageToDestinationDomainMap.get(diskImage.getId()), (double) diskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
protected void performBootstrap() {
    super.performBootstrap();
    Window.setTitle(dynamicMessages.applicationTitle());
    // Check for ApplicationMode configuration
    UiModeData uiModeData = UiModeData.instance();
    if (uiModeData != null) {
        handleUiMode(uiModeData);
    }
    // Check for Engine user session timeout configuration
    EngineSessionTimeoutData engineSessionTimeoutData = EngineSessionTimeoutData.instance();
    if (engineSessionTimeoutData != null) {
        restApiSessionManager.setSessionTimeout(engineSessionTimeoutData.getValue());
    }
    // Initiate transition to requested application place
    placeManager.revealCurrentPlace();
}
#method_after
@Override
protected void performBootstrap() {
    super.performBootstrap();
    Window.setTitle(dynamicMessages.applicationTitle());
    // Check for ApplicationMode configuration
    UiModeData uiModeData = UiModeData.instance();
    if (uiModeData != null) {
        handleUiMode(uiModeData);
    }
    // Initiate transition to requested application place
    placeManager.revealCurrentPlace();
}
#end_block

#method_before
@Override
protected void onLogin(final LoginModel loginModel) {
    // Initialize reports
    ReportInit.getInstance().init();
    // Perform login only after reports have been initialized
    ReportInit.getInstance().getReportsInitEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            performLogin(loginModel);
        }
    });
}
#method_after
@Override
protected void onLogin(final LoginModel loginModel) {
    super.onLogin(loginModel);
    // Initialize reports
    ReportInit.getInstance().init();
    // Update Reports availability after reports xml has been retrieved
    ReportInit.getInstance().getReportsInitEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            commonModelProvider.get().updateReportsAvailability();
        }
    });
    performLogin(loginModel);
}
#end_block

#method_before
@Override
protected void initFrontend() {
    super.initFrontend();
    // Configure REST API integration for UI plugin infrastructure
    frontend.setLoginHandler(new FrontendLoginHandler() {

        @Override
        public void onLoginSuccess(final String userName, final String password, final String domain) {
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    // $NON-NLS-1$
                    final String domainToken = "@";
                    restApiSessionManager.acquireSession(userName.contains(domainToken) ? userName : userName + domainToken + domain, password);
                }
            });
        }

        @Override
        public void onLogout() {
            restApiSessionManager.releaseSession();
        }
    });
}
#method_after
@Override
protected void initFrontend() {
    super.initFrontend();
    ReportInit.getInstance().initHandlers(eventBus);
}
#end_block

#method_before
@Override
public final void onBootstrap() {
    // $NON-NLS-1$
    Logger rootLogger = Logger.getLogger("");
    initLocalStorageLogHandler(rootLogger);
    initUncaughtExceptionHandler(rootLogger);
    // Perform actual bootstrap via deferred command to ensure our
    // UncaughtExceptionHandler is effective during the bootstrap
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            performBootstrap();
        }
    });
}
#method_after
@Override
public final void onBootstrap() {
    // $NON-NLS-1$
    Logger rootLogger = Logger.getLogger("");
    initLocalStorageLogHandler(rootLogger);
    initUncaughtExceptionHandler(rootLogger);
    // Perform actual bootstrap via deferred command to ensure that
    // UncaughtExceptionHandler is effective during the bootstrap
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            performBootstrap();
        }
    });
}
#end_block

#method_before
void initLocalStorageLogHandler(Logger rootLogger) {
    // Configure and attach LocalStorageLogHandler to root logger
    localStorageLogHandler.init(Level.INFO);
    rootLogger.addHandler(localStorageLogHandler);
    // Enable/disable LocalStorageLogHandler when the application window gains/looses its focus
    eventBus.addHandler(ApplicationFocusChangeEvent.getType(), new ApplicationFocusChangeHandler() {

        @Override
        public void onApplicationFocusChange(ApplicationFocusChangeEvent event) {
            localStorageLogHandler.setActive(event.isInFocus());
        }
    });
}
#method_after
void initLocalStorageLogHandler(Logger rootLogger) {
    // Configure and attach LocalStorageLogHandler
    localStorageLogHandler.init();
    rootLogger.addHandler(localStorageLogHandler);
    // Enable/disable LocalStorageLogHandler when the application window gains/looses its focus
    eventBus.addHandler(ApplicationFocusChangeEvent.getType(), new ApplicationFocusChangeHandler() {

        @Override
        public void onApplicationFocusChange(ApplicationFocusChangeEvent event) {
            localStorageLogHandler.setActive(event.isInFocus());
        }
    });
}
#end_block

#method_before
void initUncaughtExceptionHandler(final Logger rootLogger) {
    GWT.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void onUncaughtException(Throwable e) {
            // $NON-NLS-1$
            rootLogger.log(Level.SEVERE, "Uncaught exception occured", e);
        }
    });
}
#method_after
void initUncaughtExceptionHandler(final Logger rootLogger) {
    // Prevent uncaught exceptions from escaping application code
    GWT.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void onUncaughtException(Throwable t) {
            // $NON-NLS-1$
            rootLogger.log(Level.SEVERE, "Uncaught exception: ", t);
        }
    });
}
#end_block

#method_before
protected void performBootstrap() {
    // Handle UI logout requests
    user.setLogoutHandler(this);
    // Initialize UiCommon infrastructure
    initUiCommon();
    initFrontend();
    initLoginModel();
    // Check if the user should be logged in automatically
    AutoLoginData autoLoginData = AutoLoginData.instance();
    if (autoLoginData != null) {
        handleAutoLogin(autoLoginData);
    }
}
#method_after
protected void performBootstrap() {
    // Handle UI logout requests
    user.setLogoutHandler(this);
    // Initialize UiCommon infrastructure
    initUiCommon();
    initFrontend();
    initLoginModel();
    // Check if the user should be logged in automatically
    AutoLoginData autoLoginData = AutoLoginData.instance();
    if (autoLoginData != null) {
        handleAutoLogin(autoLoginData);
    }
    // Check for Engine user session timeout configuration
    EngineSessionTimeoutData engineSessionTimeoutData = EngineSessionTimeoutData.instance();
    if (engineSessionTimeoutData != null) {
        restApiSessionManager.setSessionTimeout(engineSessionTimeoutData.getSessionTimeout());
        restApiSessionManager.setHardLimit(engineSessionTimeoutData.getSessionHardLimit());
    }
}
#end_block

#method_before
protected void initLoginModel() {
    final T loginModel = getLoginModel();
    // Add model login event handler
    loginModel.getLoggedInEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            onLogin(loginModel);
        }
    });
}
#method_after
protected void initLoginModel() {
    final T loginModel = getLoginModel();
    // Add model login event handler
    loginModel.getLoggedInEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            onLogin(loginModel);
        }
    });
    loginModel.getCreateInstanceOnly().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            currentUserRole.setCreateInstanceOnly(loginModel.getCreateInstanceOnly().getEntity());
        }
    });
}
#end_block

#method_before
protected void performLogin(T loginModel) {
    DbUser loggedUser = loginModel.getLoggedUser();
    String loginPassword = (String) loginModel.getPassword().getEntity();
    // UiCommon login preparation
    frontend.initLoggedInUser(loggedUser, loginPassword);
    beforeUiCommonInitEvent(loginModel);
    UiCommonInitEvent.fire(eventBus);
    // UI login actions
    user.onUserLogin(loggedUser);
    // Post-login actions
    loginModel.getPassword().setEntity(null);
}
#method_after
protected void performLogin(T loginModel) {
    DbUser loggedUser = loginModel.getLoggedUser();
    String loginPassword = loginModel.getPassword().getEntity();
    beforeLogin(loginModel);
    // UiCommon login preparation
    frontend.initLoggedInUser(loggedUser, loginPassword);
    // UI login actions
    user.onUserLogin(loggedUser);
    // Post-login actions
    loginModel.getPassword().setEntity(null);
}
#end_block

#method_before
protected void initFrontend() {
    // Set up Frontend event handlers
    frontend.setEventsHandler(frontendEventsHandler);
    frontend.getFrontendFailureEvent().addListener(frontendFailureEventListener);
    frontend.getFrontendNotLoggedInEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            user.logout();
        }
    });
    frontend.setFilterQueries(filterFrontendQueries());
}
#method_after
protected void initFrontend() {
    // Set up Frontend event handlers
    frontend.setEventsHandler(frontendEventsHandler);
    frontend.getFrontendFailureEvent().addListener(frontendFailureEventListener);
    frontend.getFrontendNotLoggedInEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            user.logout();
        }
    });
    frontend.setFilterQueries(filterFrontendQueries());
    // Configure REST API integration for availability of engine session id
    frontend.setLoginHandler(new FrontendLoginHandler() {

        @Override
        public void onLoginSuccess() {
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    frontend.runQuery(VdcQueryType.GetEngineSessionIdToken, new VdcQueryParametersBase(), new AsyncQuery(new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            String engineAuthToken = ((VdcQueryReturnValue) returnValue).getReturnValue();
                            restApiSessionManager.acquireSession(engineAuthToken);
                        }
                    }));
                }
            });
        }

        @Override
        public void onLogout() {
            restApiSessionManager.releaseSession();
        }
    });
}
#end_block

#method_before
protected void handleAutoLogin(AutoLoginData autoLoginData) {
    final DbUser loggedUser = autoLoginData.getDbUser();
    // Use deferred command because CommonModel change needs to happen
    // after all model providers have been properly initialized
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            lockInteractionManager.showLoadingIndicator();
            getLoginModel().autoLogin(loggedUser);
        }
    });
    // Indicate that the user should be logged in automatically
    user.setAutoLogin(true);
}
#method_after
protected void handleAutoLogin(AutoLoginData autoLoginData) {
    final DbUser loggedUser = autoLoginData.getDbUser();
    // Use deferred command because CommonModel change needs to happen
    // after all model providers have been properly initialized
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            lockInteractionManager.showLoadingIndicator();
            getLoginModel().autoLogin(loggedUser);
        }
    });
    SSOTokenChangeEvent.fire(eventBus, SSOTokenData.instance().getToken());
    // Indicate that the user should be logged in automatically
    user.setAutoLogin(true);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            // Assume the REST API session has been acquired and is still active
            restApiSessionManager.reuseSession();
        }
    });
}
#end_block

#method_before
@Override
protected void initLoginModel() {
    super.initLoginModel();
    final UserPortalLoginModel loginModel = getLoginModel();
    // Login model "IsENGINEUser" property determines the availability
    // of the "Extended" main tab and starts the actual login operation
    loginModel.getIsENGINEUser().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean isEngineUser = (Boolean) loginModel.getIsENGINEUser().getEntity();
            if (isEngineUser != null) {
                userRole.setEngineUser(isEngineUser);
                // Proceed with login operation
                performLogin(loginModel);
            }
        }
    });
}
#method_after
@Override
protected void initLoginModel() {
    super.initLoginModel();
    final UserPortalLoginModel loginModel = getLoginModel();
    // Login model "IsENGINEUser" property determines the availability
    // of the "Extended" main tab and starts the actual login operation
    loginModel.getIsENGINEUser().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            Boolean isEngineUser = loginModel.getIsENGINEUser().getEntity();
            if (isEngineUser != null) {
                userRole.setEngineUser(isEngineUser);
                // Proceed with login operation
                performLogin(loginModel);
            }
        }
    });
}
#end_block

#method_before
@Override
protected void onLogin(UserPortalLoginModel loginModel) {
    // Instead of performing login now, request update for "IsENGINEUser" property
    loginModel.updateIsENGINEUser(loginModel.getLoggedUser());
}
#method_after
@Override
protected void onLogin(UserPortalLoginModel loginModel) {
    super.onLogin(loginModel);
    // Instead of performing login now, request update for "IsENGINEUser" property
    loginModel.updateIsENGINEUser(loginModel.getLoggedUser());
}
#end_block

#method_before
protected void bindCommonInfrastructure(Class<? extends PlaceManager> placeManager) {
    bindEventBus();
    bindFrontendInfrastructure();
    bind(TokenFormatter.class).to(ParameterTokenFormatter.class).in(Singleton.class);
    bind(RootPresenter.class).asEagerSingleton();
    bindTypeAndImplAsSingleton(PlaceManager.class, placeManager);
    bind(CurrentUser.class).in(Singleton.class);
    bind(LoggedInGatekeeper.class).in(Singleton.class);
    bind(ErrorPopupManager.class).to(ErrorPopupManagerImpl.class).in(Singleton.class);
    bind(AsyncCallFailureHandler.class).asEagerSingleton();
    bind(ClientAgentType.class).in(Singleton.class);
    bind(ClientStorage.class).in(Singleton.class);
    bind(ApplicationFocusManager.class).asEagerSingleton();
    bind(LockInteractionManager.class).asEagerSingleton();
    bindTypeAndImplAsSingleton(ClientLogProvider.class, LocalStorageLogHandler.class);
}
#method_after
protected void bindCommonInfrastructure(Class<? extends PlaceManager> placeManager) {
    install(new CommonGinModule());
    bindEventBus();
    bindFrontendInfrastructure();
    bind(TokenFormatter.class).to(ParameterTokenFormatter.class).in(Singleton.class);
    bind(RootPresenter.class).asEagerSingleton();
    bindTypeAndImplAsSingleton(PlaceManager.class, placeManager);
    bind(CurrentUser.class).in(Singleton.class);
    bind(LoggedInGatekeeper.class).in(Singleton.class);
    bind(ErrorPopupManager.class).to(ErrorPopupManagerImpl.class).in(Singleton.class);
    bind(AsyncCallFailureHandler.class).asEagerSingleton();
    bind(ClientAgentType.class).in(Singleton.class);
    bind(ClientStorage.class).to(ClientStorageImpl.class).in(Singleton.class);
    bind(ApplicationFocusManager.class).asEagerSingleton();
    bind(LockInteractionManager.class).asEagerSingleton();
    bindTypeAndImplAsSingleton(ClientLogProvider.class, LocalStorageLogHandler.class);
    requestStaticInjection(AssetProvider.class);
}
#end_block

#method_before
private void bindFrontendInfrastructure() {
    bind(Frontend.class).in(Singleton.class);
    requestStaticInjection(Frontend.InstanceHolder.class);
    bind(VdcOperationManager.class).in(Singleton.class);
    bind(OperationProcessor.class).in(Singleton.class);
    bind(CommunicationProvider.class).to(GWTRPCCommunicationProvider.class).in(Singleton.class);
    bind(GenericApiGWTServiceAsync.class).in(Singleton.class);
}
#method_after
private void bindFrontendInfrastructure() {
    bind(Frontend.class).in(Singleton.class);
    requestStaticInjection(Frontend.InstanceHolder.class);
    bind(VdcOperationManager.class).in(Singleton.class);
    bind(OperationProcessor.class).in(Singleton.class);
    bind(CommunicationProvider.class).to(GWTRPCCommunicationProvider.class).in(Singleton.class);
    bind(RestApiSessionManager.class).in(Singleton.class);
}
#end_block

#method_before
private <T> void bindTypeAndImplAsSingleton(Class<T> type, Class<? extends T> impl) {
    bind(type).to(impl);
    bind(impl).in(Singleton.class);
}
#method_after
protected <T> void bindTypeAndImplAsSingleton(Class<T> type, Class<? extends T> impl) {
    bind(type).to(impl);
    bind(impl).in(Singleton.class);
}
#end_block

#method_before
public void init(Level logLevel) {
    setFormatter(new TextLogFormatter(true));
    setLevel(logLevel);
    setActive(true);
}
#method_after
public void init() {
    setFormatter(new TextLogFormatter(true));
    setLevel(Level.ALL);
    setActive(true);
}
#end_block

#method_before
public void setActive(boolean active) {
    this.active = active;
    if (active) {
        // Read logBuffer internal state
        int newHead = readInt(LOG_HEAD_KEY, 0);
        int newSize = readInt(LOG_SIZE_KEY, 0);
        logBuffer.reset(newHead, newSize);
    }
}
#method_after
public void setActive(boolean active) {
    this.active = active;
    if (active) {
        // Read logBuffer state
        int newHead = readInt(KEY_HEAD, 0);
        int newSize = readInt(KEY_SIZE, 0);
        logBuffer.reset(newHead, newSize);
    }
}
#end_block

#method_before
@Override
public void publish(LogRecord record) {
    if (active && isLoggable(record)) {
        // Add message into logBuffer
        String message = getFormatter().format(record);
        logBuffer.add(message);
        // Write logBuffer internal state
        writeInt(LOG_HEAD_KEY, logBuffer.head());
        writeInt(LOG_SIZE_KEY, logBuffer.size());
    }
}
#method_after
@Override
public void publish(LogRecord record) {
    if (active && isLoggable(record)) {
        // Add message to logBuffer
        String message = getFormatter().format(record);
        logBuffer.add(message);
        // Write logBuffer state
        writeInt(KEY_HEAD, logBuffer.head());
        writeInt(KEY_SIZE, logBuffer.size());
    }
}
#end_block

#method_before
@Override
public void write(int index, String element) {
    clientStorage.setLocalItem(LOG_PREFIX_KEY + index, element);
}
#method_after
@Override
public void write(int index, String element) {
    clientStorage.setLocalItem(getLogRecordKey(index), element);
}
#end_block

#method_before
@Override
public String read(int index) {
    return clientStorage.getLocalItem(LOG_PREFIX_KEY + index);
}
#method_after
@Override
public String read(int index) {
    return clientStorage.getLocalItem(getLogRecordKey(index));
}
#end_block

#method_before
@Override
public Serializable disassemble(Object val) throws HibernateException {
    return (RpmVersion) val;
}
#method_after
@Override
public Serializable disassemble(Object val) throws HibernateException {
    return (Serializable) val;
}
#end_block

#method_before
@Override
public boolean equals(Object x, Object y) throws HibernateException {
    if (x == null && y == null) {
        return true;
    }
    if (x == null) {
        return false;
    }
    return x.equals(y);
}
#method_after
@Override
public boolean equals(Object x, Object y) throws HibernateException {
    return Objects.equals(x, y);
}
#end_block

#method_before
@Override
public int hashCode(Object value) throws HibernateException {
    return value.hashCode();
}
#method_after
@Override
public int hashCode(Object value) throws HibernateException {
    return Objects.hashCode(value);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Object deepCopy(Object val) throws HibernateException {
    return (Set<VmRngDevice.Source>) val;
}
#method_after
@Override
public Object deepCopy(Object val) throws HibernateException {
    return val;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Serializable disassemble(Object val) throws HibernateException {
    return (HashSet<VmRngDevice.Source>) val;
}
#method_after
@Override
public Serializable disassemble(Object val) throws HibernateException {
    return (Serializable) val;
}
#end_block

#method_before
@Override
public boolean equals(Object x, Object y) throws HibernateException {
    if (x == null && y == null) {
        return true;
    }
    if (x == null) {
        return false;
    }
    // TODO: Add full compare
    return x.equals(y);
}
#method_after
@Override
public boolean equals(Object x, Object y) throws HibernateException {
    return Objects.equals(x, y);
}
#end_block

#method_before
@Override
public int hashCode(Object value) throws HibernateException {
    return value.hashCode();
}
#method_after
@Override
public int hashCode(Object value) throws HibernateException {
    return Objects.hashCode(value);
}
#end_block

#method_before
protected void logToAudit() {
    AuditLogableBase auditLogableBase = new AuditLogableBase(vds.getId()) {

        public AuditLogType getAuditLogTypeValue() {
            return AuditLogType.VDS_BROKER_COMMAND_FAILURE;
        }
    };
    auditLogableBase.setVds(vds);
    auditLogableBase.addCustomValue("message", getReturnStatus().mMessage);
    AuditLogDirector auditLogDirector = new AuditLogDirector();
    auditLogDirector.log(auditLogableBase);
}
#method_after
@Override
protected void logToAudit() {
    AuditLogableBase auditLogableBase = new AuditLogableBase(vds.getId());
    auditLogableBase.setVds(vds);
    auditLogableBase.addCustomValue("message", getReturnStatus().mMessage);
    auditLogDirector.log(auditLogableBase, AuditLogType.VDS_BROKER_COMMAND_FAILURE);
}
#end_block

#method_before
protected void logToAudit() {
    AuditLogableBase auditLogableBase = new AuditLogableBase() {

        public AuditLogType getAuditLogTypeValue() {
            return AuditLogType.IRS_BROKER_COMMAND_FAILURE;
        }
    };
    auditLogableBase.addCustomValue("message", getReturnStatus().mMessage);
    AuditLogDirector auditLogDirector = new AuditLogDirector();
    auditLogDirector.log(auditLogableBase);
}
#method_after
@Override
protected void logToAudit() {
    AuditLogableBase auditLogableBase = new AuditLogableBase();
    auditLogableBase.addCustomValue("message", getReturnStatus().mMessage);
    auditLogDirector.log(auditLogableBase, AuditLogType.IRS_BROKER_COMMAND_FAILURE);
}
#end_block

#method_before
protected void logToAudit() {
}
#method_after
@Override
protected void logToAudit() {
}
#end_block

#method_before
protected void logToAudit() {
}
#method_after
@Override
protected void logToAudit() {
}
#end_block

#method_before
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    VDSExceptionBase outEx;
    switch(returnStatus) {
        case Done:
            return;
        case recovery:
            outEx = new VDSRecoveringException(returnStatus, getReturnStatus().mMessage);
            break;
        case SpmStatusError:
            outEx = new IRSNonOperationalException(getReturnStatus().mMessage);
            break;
        case StoragePoolMasterNotFound:
        case StoragePoolTooManyMasters:
        case StoragePoolWrongMaster:
        case StoragePoolHasPotentialMaster:
        case StorageDomainMasterError:
            outEx = new IRSNoMasterDomainException(getReturnStatus().mMessage);
            break;
        case UnicodeArgumentException:
            outEx = new IRSUnicodeArgumentException(getReturnStatus().mMessage);
            break;
        case TooManyDomainsInStoragePoolError:
        case StorageDomainAlreadyAttached:
        case StorageDomainDescriptionTooLongError:
        case TooManyPVsInVG:
        case createIllegalVolumeSnapshotError:
        case prepareIllegalVolumeError:
        case createVolumeRollbackError:
        case InvalidParameterException:
        case InvalidDefaultExceptionException:
        case NotImplementedException:
        case OperationInProgress:
        case MiscDirCleanupFailure:
        case createVolumeSizeError:
        case IncorrectFormat:
        case VolumeIsBusy:
        case VolumeImageHasChildren:
        case VolumeUnlinkError:
        case OrphanVolumeError:
        case VolumeAlreadyExists:
        case VolumeNonWritable:
        case VolumeNonShareable:
        case VolumeCannotGetParent:
        case SharedVolumeNonWritable:
        case InternalVolumeNonWritable:
        case CannotDeleteSharedVolume:
        case NonLeafVolumeNotWritable:
        case ImagesActionError:
        case ImageValidationError:
        case ImageDeleteError:
        case ImageIsNotEmpty:
        case ImageIsNotLegalChain:
        case OverwriteImageError:
        case MoveTemplateImageError:
        case StoragePoolDisconnectionError:
        case StoragePoolAlreadyExists:
        case IsoCannotBeMasterDomain:
        case CannotConnectMultiplePools:
        case BackupCannotBeMasterDomain:
        case StoragePoolConnected:
        case StoragePoolDescriptionTooLongError:
        case StorageDomainNotInPool:
        case StorageDomainNotEmpty:
        case StorageDomainMetadataCreationError:
        case StorageDomainMetadataFileMissing:
        case StorageDomainMetadataNotFound:
        case StorageDomainAlreadyExists:
        case StorageDomainMasterUnmountError:
        case BlockStorageDomainMasterFSCKError:
        case StorageDomainLayoutError:
        case StorageDomainTypeError:
        case StorageDomainNotMemberOfPool:
        case StorageDomainStatusError:
        case StorageDomainCheckError:
        case StorageDomainTypeNotBackup:
        case StorageDomainStateTransitionIllegal:
        case StorageDomainActive:
        case CannotDetachMasterStorageDomain:
        case StorageDomainInsufficientPermissions:
        case StorageDomainClassError:
        case StorageDomainIsMadeFromTooManyPVs:
        case InvalidTask:
        case UnknownTask:
        case TaskClearError:
        case TaskNotFinished:
        case InvalidTaskType:
        case AddTaskError:
        case TaskInProgress:
        case TaskStateError:
        case TaskAborted:
        case TaskPersistError:
        case InvalidJob:
        case InvalidRecovery:
        case InvalidTaskMng:
        case TaskStateTransitionError:
        case TaskHasRefs:
        case VolumeGroupSizeError:
        case VolumeGroupAlreadyExistsError:
        case VolumeGroupUninitialized:
        case VolumeGroupHasDomainTag:
        case CannotRemoveLogicalVolume:
        case CannotDeactivateLogicalVolume:
        case CannotActivateLogicalVolume:
        case LogicalVolumePermissionsError:
        case LogicalVolumeAlreadyExists:
        case PartitionedPhysDev:
        case DomainAlreadyLocked:
        case DomainLockDoesNotExist:
        case MetaDataKeyError:
        case MetaDataSealIsBroken:
        case MetaDataValidationError:
        case MetaDataMappingError:
        case MetaDataParamError:
        case MetadataOverflowError:
        case ImportUnknownType:
        case ExportError:
        case MergeVolumeRollbackError:
        case ActionStopped:
        case FAILED_CHANGE_CD_IS_MOUNTED:
        case UnsupportedDomainVersion:
        case CurrentVersionTooAdvancedError:
        case iSCSILogoutError:
        case iSCSIDiscoveryError:
        case ISCSI_LOGIN_AUTH_ERROR:
        case PoolUpgradeInProgress:
        case MixedSDVersionError:
        case NoSpaceLeftOnDomain:
        case ImageDoesNotExistInDomainError:
        case NO_IMPLEMENTATION:
        case VOLUME_WAS_NOT_PREPARED_BEFORE_TEARDOWN:
        case IMAGES_NOT_SUPPORTED_ERROR:
        case GET_FILE_LIST_ERROR:
        case STORAGE_DOMAIN_REFRESH_ERROR:
        case VOLUME_GROUP_BLOCK_SIZE_ERROR:
        case MIGRATION_DEST_INVALID_HOSTNAME:
        case ResourceTimeout:
        case HOT_PLUG_UNPLUG_CPU_ERROR:
        case DEVICE_BLOCK_SIZE_NOT_SUPPORTED:
            if (this instanceof IrsBrokerCommand) {
                outEx = new IrsOperationFailedNoFailoverException(getReturnStatus().mMessage);
            } else {
                outEx = new VDSErrorException(String.format("Failed in vdscommand to %1$s, error = %2$s", getCommandName(), getReturnStatus().mMessage));
            }
            break;
        case VDS_NETWORK_ERROR:
        case ERR_BAD_ADDR:
            outEx = new VDSNetworkException(getReturnStatus().mMessage);
            break;
        default:
            log.error("Failed in '{}' method", getCommandName());
            outEx = createException();
            break;
    }
    VDSError tempVar = new VDSError();
    tempVar.setCode(returnStatus);
    tempVar.setMessage(getReturnStatus().mMessage);
    outEx.setVdsError(tempVar);
    logToAudit();
}
#method_after
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = getReturnValueFromStatus(getReturnStatus());
    VDSExceptionBase outEx;
    switch(returnStatus) {
        case Done:
            return;
        case recovery:
            outEx = new VDSRecoveringException(returnStatus, getReturnStatus().mMessage);
            break;
        case SpmStatusError:
            outEx = new IRSNonOperationalException(getReturnStatus().mMessage);
            break;
        case StoragePoolMasterNotFound:
        case StoragePoolTooManyMasters:
        case StoragePoolWrongMaster:
        case StoragePoolHasPotentialMaster:
        case StorageDomainMasterError:
            outEx = new IRSNoMasterDomainException(getReturnStatus().mMessage);
            break;
        case UnicodeArgumentException:
            outEx = new IRSUnicodeArgumentException(getReturnStatus().mMessage);
            break;
        case TooManyDomainsInStoragePoolError:
        case StorageDomainAlreadyAttached:
        case StorageDomainDescriptionTooLongError:
        case TooManyPVsInVG:
        case createIllegalVolumeSnapshotError:
        case prepareIllegalVolumeError:
        case createVolumeRollbackError:
        case InvalidParameterException:
        case InvalidDefaultExceptionException:
        case NotImplementedException:
        case OperationInProgress:
        case MiscDirCleanupFailure:
        case createVolumeSizeError:
        case IncorrectFormat:
        case VolumeIsBusy:
        case VolumeImageHasChildren:
        case VolumeUnlinkError:
        case OrphanVolumeError:
        case VolumeAlreadyExists:
        case VolumeNonWritable:
        case VolumeNonShareable:
        case VolumeCannotGetParent:
        case SharedVolumeNonWritable:
        case InternalVolumeNonWritable:
        case CannotDeleteSharedVolume:
        case NonLeafVolumeNotWritable:
        case ImagesActionError:
        case ImageValidationError:
        case ImageDeleteError:
        case ImageIsNotEmpty:
        case ImageIsNotLegalChain:
        case OverwriteImageError:
        case MoveTemplateImageError:
        case StoragePoolDisconnectionError:
        case StoragePoolAlreadyExists:
        case IsoCannotBeMasterDomain:
        case CannotConnectMultiplePools:
        case BackupCannotBeMasterDomain:
        case StoragePoolConnected:
        case StoragePoolDescriptionTooLongError:
        case StorageDomainNotInPool:
        case StorageDomainNotEmpty:
        case StorageDomainMetadataCreationError:
        case StorageDomainMetadataFileMissing:
        case StorageDomainMetadataNotFound:
        case StorageDomainAlreadyExists:
        case StorageDomainMasterUnmountError:
        case BlockStorageDomainMasterFSCKError:
        case StorageDomainLayoutError:
        case StorageDomainTypeError:
        case StorageDomainNotMemberOfPool:
        case StorageDomainStatusError:
        case StorageDomainCheckError:
        case StorageDomainTypeNotBackup:
        case StorageDomainStateTransitionIllegal:
        case StorageDomainActive:
        case CannotDetachMasterStorageDomain:
        case StorageDomainInsufficientPermissions:
        case StorageDomainClassError:
        case StorageDomainIsMadeFromTooManyPVs:
        case InvalidTask:
        case UnknownTask:
        case TaskClearError:
        case TaskNotFinished:
        case InvalidTaskType:
        case AddTaskError:
        case TaskInProgress:
        case TaskStateError:
        case TaskAborted:
        case TaskPersistError:
        case InvalidJob:
        case InvalidRecovery:
        case InvalidTaskMng:
        case TaskStateTransitionError:
        case TaskHasRefs:
        case VolumeGroupSizeError:
        case VolumeGroupAlreadyExistsError:
        case VolumeGroupUninitialized:
        case VolumeGroupHasDomainTag:
        case CannotRemoveLogicalVolume:
        case CannotDeactivateLogicalVolume:
        case CannotActivateLogicalVolume:
        case LogicalVolumePermissionsError:
        case LogicalVolumeAlreadyExists:
        case PartitionedPhysDev:
        case DomainAlreadyLocked:
        case DomainLockDoesNotExist:
        case MetaDataKeyError:
        case MetaDataSealIsBroken:
        case MetaDataValidationError:
        case MetaDataMappingError:
        case MetaDataParamError:
        case MetadataOverflowError:
        case ImportUnknownType:
        case ExportError:
        case MergeVolumeRollbackError:
        case ActionStopped:
        case FAILED_CHANGE_CD_IS_MOUNTED:
        case UnsupportedDomainVersion:
        case CurrentVersionTooAdvancedError:
        case iSCSILogoutError:
        case iSCSIDiscoveryError:
        case ISCSI_LOGIN_AUTH_ERROR:
        case PoolUpgradeInProgress:
        case MixedSDVersionError:
        case NoSpaceLeftOnDomain:
        case ImageDoesNotExistInDomainError:
        case NO_IMPLEMENTATION:
        case VOLUME_WAS_NOT_PREPARED_BEFORE_TEARDOWN:
        case IMAGES_NOT_SUPPORTED_ERROR:
        case GET_FILE_LIST_ERROR:
        case STORAGE_DOMAIN_REFRESH_ERROR:
        case VOLUME_GROUP_BLOCK_SIZE_ERROR:
        case MIGRATION_DEST_INVALID_HOSTNAME:
        case ResourceTimeout:
        case HOT_PLUG_UNPLUG_CPU_ERROR:
        case DEVICE_BLOCK_SIZE_NOT_SUPPORTED:
            if (this instanceof IrsBrokerCommand) {
                outEx = new IrsOperationFailedNoFailoverException(getReturnStatus().mMessage);
            } else {
                outEx = new VDSErrorException(String.format("Failed in vdscommand to %1$s, error = %2$s", getCommandName(), getReturnStatus().mMessage));
            }
            break;
        case VDS_NETWORK_ERROR:
        case ERR_BAD_ADDR:
            outEx = new VDSNetworkException(getReturnStatus().mMessage);
            break;
        default:
            log.error("Failed in '{}' method", getCommandName());
            outEx = createException();
            break;
    }
    VDSError tempVar = new VDSError();
    tempVar.setCode(returnStatus);
    tempVar.setMessage(getReturnStatus().mMessage);
    outEx.setVdsError(tempVar);
    logToAudit();
    throw outEx;
}
#end_block

#method_before
protected void logToAudit() {
}
#method_after
@Override
protected void logToAudit() {
}
#end_block

#method_before
protected void logToAudit() {
}
#method_after
@Override
protected void logToAudit() {
}
#end_block

#method_before
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vdsManager::refreshVdsStats entered, vds='{}'({})", vds.getName(), vds.getId());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    VDSReturnValue statsReturnValue = resourceManager.runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
    if (!statsReturnValue.getSucceeded() && statsReturnValue.getExceptionObject() != null) {
        log.error(" Failed getting vds stats,  vds='{}'({}): {}", vds.getName(), vds.getId(), statsReturnValue.getExceptionString());
        throw statsReturnValue.getExceptionObject();
    }
    getVdsEventListener().updateSchedulingStats(vds);
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    saveVdsDynamic = true;
    saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVdsStats\n{}", this);
    }
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vdsManager::refreshVdsStats entered, vds='{}'({})", vds.getName(), vds.getId());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    VDSReturnValue statsReturnValue = resourceManager.runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
    if (!statsReturnValue.getSucceeded() && statsReturnValue.getExceptionObject() != null) {
        log.error(" Failed getting vds stats,  vds='{}'({}): {}", vds.getName(), vds.getId(), statsReturnValue.getExceptionString());
        throw statsReturnValue.getExceptionObject();
    }
    getVdsEventListener().updateSchedulingStats(vds);
    updateV2VJobs();
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    saveVdsDynamic = true;
    saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVdsStats\n{}", this);
    }
}
#end_block

#method_before
public void clearAllDismissedAlerts() {
    ClearDismissedAuditLogsBySeverityParameters params = new ClearDismissedAuditLogsBySeverityParameters(Collections.singletonList(AuditLogSeverity.ALERT));
    Frontend.getInstance().runAction(VdcActionType.ClearDismissedAuditLogsBySeverity, params);
}
#method_after
public void clearAllDismissedAlerts() {
    Frontend.getInstance().runAction(VdcActionType.ClearDismissedAuditLogAlerts, new VdcActionParametersBase());
}
#end_block

#method_before
public void dismissEvent() {
    AuditLog auditLog = getSelectedItem();
    RemoveAuditLogByIdParameters params = new RemoveAuditLogByIdParameters(auditLog.getAuditLogId());
    Frontend.getInstance().runAction(VdcActionType.RemoveAuditLogById, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            EventListModel.this.refresh();
        }
    });
}
#method_after
public void dismissEvent() {
    final AuditLog auditLog = getSelectedItem();
    if (auditLog == null) {
        return;
    }
    RemoveAuditLogByIdParameters params = new RemoveAuditLogByIdParameters(auditLog.getAuditLogId());
    Frontend.getInstance().runAction(VdcActionType.RemoveAuditLogById, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            EventListModel.this.refresh();
        }
    });
}
#end_block

#method_before
public void clearAllDismissedEvents() {
    ClearDismissedAuditLogsBySeverityParameters params = new ClearDismissedAuditLogsBySeverityParameters(Arrays.asList(AuditLogSeverity.ERROR, AuditLogSeverity.WARNING, AuditLogSeverity.NORMAL));
    Frontend.getInstance().runAction(VdcActionType.ClearDismissedAuditLogsBySeverity, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            EventListModel.this.refresh();
        }
    });
}
#method_after
public void clearAllDismissedEvents() {
    Frontend.getInstance().runAction(VdcActionType.ClearDismissedAuditLogEvents, new VdcActionParametersBase(), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            EventListModel.this.refresh();
        }
    });
}
#end_block

#method_before
protected void updateV2VJobs() {
    List<V2VJobInfo> v2vJobInfos = vds.getStatisticsData().getV2VJobs();
    if (v2vJobInfos != null) {
        vdsManager.updateV2VJobInfos(v2vJobInfos);
    }
}
#method_after
protected void updateV2VJobs() {
    List<V2VJobInfo> v2vJobInfos = vds.getV2VJobs();
    if (v2vJobInfos != null) {
        vdsManager.updateV2VJobInfos(v2vJobInfos);
    }
}
#end_block

#method_before
void updateV2VJobInfos(List<V2VJobInfo> v2vJobInfos) {
    for (V2VJobInfo existingJobInfo : vmIdToV2VJob.values()) {
        if (existingJobInfo.monitor() && !v2vJobInfos.contains(existingJobInfo)) {
            existingJobInfo.setStatus(JobStatus.ERROR);
        }
    }
    if (v2vJobInfos.isEmpty()) {
        return;
    }
    synchronized (vmIdToV2VJob) {
        for (V2VJobInfo jobInfo : v2vJobInfos) {
            if (vmIdToV2VJob.containsKey(jobInfo.getId())) {
                vmIdToV2VJob.put(jobInfo.getId(), jobInfo);
            }
        }
    }
}
#method_after
void updateV2VJobInfos(List<V2VJobInfo> v2vJobInfos) {
    // didn't arrive in the latest report to non-exist
    for (V2VJobInfo existingJobInfo : vmIdToV2VJob.values()) {
        if (existingJobInfo.isMonitored() && !v2vJobInfos.contains(existingJobInfo)) {
            existingJobInfo.setStatus(JobStatus.NOT_EXIST);
        }
    }
    if (v2vJobInfos.isEmpty()) {
        return;
    }
    // will be added again in case VDSM reports it at the same time
    synchronized (vmIdToV2VJob) {
        for (V2VJobInfo jobInfo : v2vJobInfos) {
            if (vmIdToV2VJob.containsKey(jobInfo.getId())) {
                vmIdToV2VJob.put(jobInfo.getId(), jobInfo);
            }
        }
    }
}
#end_block

#method_before
private static V2VJobInfo.JobStatus getV2VJobStatusValue(Map<String, Object> input) {
    try {
        String status = (String) input.get(VdsProperties.v2vJobStatus);
        return V2VJobInfo.JobStatus.valueOf(status.toUpperCase());
    } catch (Exception e) {
        return V2VJobInfo.JobStatus.UNKNOWN;
    }
}
#method_after
private static V2VJobInfo.JobStatus getV2VJobStatusValue(Map<String, Object> input) {
    String status = (String) input.get(VdsProperties.v2vJobStatus);
    try {
        return V2VJobInfo.JobStatus.valueOf(status.toUpperCase());
    } catch (Exception e) {
        log.warn("Got invalid status for virt-v2v job: {}", status);
        return V2VJobInfo.JobStatus.UNKNOWN;
    }
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(NetworkAttachment networkAttachment) {
    MapSqlParameterSource mapper = createIdParameterMapper(networkAttachment.getId()).addValue("network_id", networkAttachment.getNetworkId()).addValue("nic_id", networkAttachment.getNicId()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(networkAttachment.getProperties()));
    IpConfiguration ipConfiguration = networkAttachment.getIpConfiguration();
    if (ipConfiguration == null) {
        mapper.addValue("boot_protocol", null).addValue("address", null).addValue("netmask", null).addValue("gateway", null);
    } else {
        mapper.addValue("boot_protocol", EnumUtils.nameOrNull(ipConfiguration.getBootProtocol())).addValue("address", ipConfiguration.getAddress()).addValue("netmask", ipConfiguration.getNetmask()).addValue("gateway", ipConfiguration.getGateway());
    }
    return mapper;
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(NetworkAttachment networkAttachment) {
    MapSqlParameterSource mapper = createIdParameterMapper(networkAttachment.getId()).addValue("network_id", networkAttachment.getNetworkId()).addValue("nic_id", networkAttachment.getNicId()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(networkAttachment.getProperties()));
    IpConfiguration ipConfiguration = networkAttachment.getIpConfiguration();
    if (ipConfiguration != null) {
        mapper.addValue("boot_protocol", EnumUtils.nameOrNull(ipConfiguration.getBootProtocol())).addValue("address", ipConfiguration.getAddress()).addValue("netmask", ipConfiguration.getNetmask()).addValue("gateway", ipConfiguration.getGateway());
    }
    return mapper;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public NetworkAttachment mapRow(ResultSet rs, int rowNum) throws SQLException {
    NetworkAttachment entity = new NetworkAttachment();
    entity.setId(getGuid(rs, "id"));
    entity.setNetworkId(getGuid(rs, "network_id"));
    entity.setNicId(getGuid(rs, "nic_id"));
    entity.setProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    IpConfiguration ipConfiguration = new IpConfiguration();
    String bootProtocol = rs.getString("boot_protocol");
    if (bootProtocol != null) {
        ipConfiguration.setBootProtocol(NetworkBootProtocol.valueOf(bootProtocol));
        ipConfiguration.setAddress(rs.getString("address"));
        ipConfiguration.setNetmask(rs.getString("netmask"));
        ipConfiguration.setGateway(rs.getString("gateway"));
        entity.setIpConfiguration(ipConfiguration);
    }
    return entity;
}
#method_after
@SuppressWarnings("unchecked")
@Override
public NetworkAttachment mapRow(ResultSet rs, int rowNum) throws SQLException {
    NetworkAttachment entity = new NetworkAttachment();
    entity.setId(getGuid(rs, "id"));
    entity.setNetworkId(getGuid(rs, "network_id"));
    entity.setNicId(getGuid(rs, "nic_id"));
    entity.setProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    IpConfiguration ipConfiguration = new IpConfiguration();
    String bootProtocol = rs.getString("boot_protocol");
    ipConfiguration.setBootProtocol(bootProtocol == null ? null : NetworkBootProtocol.valueOf(bootProtocol));
    ipConfiguration.setAddress(rs.getString("address"));
    ipConfiguration.setNetmask(rs.getString("netmask"));
    ipConfiguration.setGateway(rs.getString("gateway"));
    entity.setIpConfiguration(ipConfiguration);
    return entity;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private <T extends DAO> T getDao(Class<T> daoType) {
    for (DAO dao : daos) {
        if (daoType.isAssignableFrom(dao.getClass())) {
            return (T) dao;
        }
    }
    log.error("Can't find dao for " + daoType);
    return null;
}
#method_after
protected <T extends DAO> T getDao(Class<T> daoType) {
    T dao = DaoFactory.get(daoType);
    if (dao instanceof BaseDAODbFacade) {
        BaseDAODbFacade dbFacadeDAO = (BaseDAODbFacade) dao;
        dbFacadeDAO.setTemplate(jdbcTemplate);
        dbFacadeDAO.setDialect(dbEngineDialect);
        dbFacadeDAO.setDbFacade(this);
    }
    return dao;
}
#end_block

#method_before
public static DbFacade getInstance() {
    return instance;
}
#method_after
public static DbFacade getInstance() {
    return DbFacadeLocator.getDbFacade();
}
#end_block

#method_before
public void populateDwhOsInfo(Map<Integer, String> osIdToName) {
    // first clear the table
    new SimpleJdbcCall(jdbcTemplate).withProcedureName("clear_osinfo").execute();
    // batch populate
    List<MapSqlParameterSource> executions = new ArrayList<>();
    for (Map.Entry<Integer, String> e : osIdToName.entrySet()) {
        executions.add(getCustomMapSqlParameterSource().addValue("os_id", e.getKey()).addValue("os_name", e.getValue()));
    }
    getCallsHandler().executeStoredProcAsBatch("insert_osinfo", executions);
}
#method_after
public void populateDwhOsInfo(Map<Integer, String> osIdToName) {
    // first clear the table
    new SimpleJdbcCall(jdbcTemplate).withProcedureName("clear_osinfo").execute();
    // batch populate
    List<MapSqlParameterSource> executions = new ArrayList<MapSqlParameterSource>();
    for (Map.Entry<Integer, String> e : osIdToName.entrySet()) {
        executions.add(getCustomMapSqlParameterSource().addValue("os_id", e.getKey()).addValue("os_name", e.getValue()));
    }
    getCallsHandler().executeStoredProcAsBatch("insert_osinfo", executions);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((ipConfiguration == null) ? 0 : ipConfiguration.hashCode());
    result = prime * result + ((networkId == null) ? 0 : networkId.hashCode());
    result = prime * result + ((nicId == null) ? 0 : nicId.hashCode());
    result = prime * result + ((nicName == null) ? 0 : nicName.hashCode());
    result = prime * result + ((properties == null) ? 0 : properties.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((ipConfiguration == null) ? 0 : ipConfiguration.hashCode());
    result = prime * result + ((networkId == null) ? 0 : networkId.hashCode());
    result = prime * result + ((nicId == null) ? 0 : nicId.hashCode());
    result = prime * result + ((properties == null) ? 0 : properties.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    NetworkAttachment other = (NetworkAttachment) obj;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (ipConfiguration == null) {
        if (other.ipConfiguration != null)
            return false;
    } else if (!ipConfiguration.equals(other.ipConfiguration))
        return false;
    if (networkId == null) {
        if (other.networkId != null)
            return false;
    } else if (!networkId.equals(other.networkId))
        return false;
    if (nicId == null) {
        if (other.nicId != null)
            return false;
    } else if (!nicId.equals(other.nicId))
        return false;
    if (nicName == null) {
        if (other.nicName != null)
            return false;
    } else if (!nicName.equals(other.nicName))
        return false;
    if (properties == null) {
        if (other.properties != null)
            return false;
    } else if (!properties.equals(other.properties))
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    NetworkAttachment other = (NetworkAttachment) obj;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (ipConfiguration == null) {
        if (other.ipConfiguration != null)
            return false;
    } else if (!ipConfiguration.equals(other.ipConfiguration))
        return false;
    if (networkId == null) {
        if (other.networkId != null)
            return false;
    } else if (!networkId.equals(other.networkId))
        return false;
    if (nicId == null) {
        if (other.nicId != null)
            return false;
    } else if (!nicId.equals(other.nicId))
        return false;
    if (properties == null) {
        if (other.properties != null)
            return false;
    } else if (!properties.equals(other.properties))
        return false;
    return true;
}
#end_block

#method_before
@Override
public String toString() {
    return "NetworkAttachment [id=" + id + ", networkId=" + networkId + ", nicId=" + nicId + ", nicName=" + nicName + ", ipConfiguration=" + ipConfiguration + ", properties=" + properties + "]";
}
#method_after
@Override
public String toString() {
    return "NetworkAttachment [id=" + id + ", networkId=" + networkId + ", nicId=" + nicId + ", ipConfiguration=" + ipConfiguration + ", properties=" + properties + "]";
}
#end_block

#method_before
@Override
protected void init() {
    VM vm = getVmFromConfiguration();
    if (vm == null) {
        return;
    }
    setVm(vm);
    if (getParameters().getVm() == null) {
        return;
    }
    vm.setVdsGroupId(getParameters().getVm().getVdsGroupId());
    if (getVdsGroup() == null) {
        return;
    }
    vm.setStoragePoolId(getVdsGroup().getStoragePoolId());
    getParameters().setVm(vm);
    Snapshot snapshot = getSnapshot();
    if (snapshot != null) {
        setSnapshotName(snapshot.getDescription());
    }
    super.init();
}
#method_after
@Override
protected void init() {
    if (getParameters().getVm() == null) {
        return;
    }
    setVdsGroupId(getParameters().getVm().getVdsGroupId());
    if (getVdsGroup() == null) {
        return;
    }
    setStoragePoolId(getVdsGroup().getStoragePoolId());
    VM vm = getVmFromConfiguration();
    if (vm == null) {
        return;
    }
    vm.setVdsGroupId(getVdsGroupId());
    vm.setStoragePoolId(getStoragePoolId());
    setVm(vm);
    getParameters().setVm(vm);
    setSnapshotName(getSnapshot() != null ? getSnapshot().getDescription() : null);
    super.init();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    SnapshotsValidator snapshotsValidator = createSnapshotsValidator();
    if (!validate(snapshotsValidator.snapshotExists(getSnapshot())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getSnapshot().getVmId()))) {
        return false;
    }
    if (getVmFromConfiguration() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION, String.format("$VmName %1$s", getVmName()), String.format("$SnapshotName %1$s", getSnapshotName()));
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    SnapshotsValidator snapshotsValidator = createSnapshotsValidator();
    if (!validate(snapshotsValidator.snapshotExists(getSnapshot())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getSnapshot().getVmId()))) {
        return false;
    }
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION, String.format("$VmName %1$s", getVmName()), String.format("$SnapshotName %1$s", getSnapshotName()));
    }
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.VMT_CLUSTER_IS_NOT_VALID);
    }
    return super.canDoAction();
}
#end_block

#method_before
@Override
protected List<DiskImage> getVmDisksFromDB() {
    if (cachedDisksFromDb == null) {
        cachedDisksFromDb = ImagesHandler.filterImageDisks(getVmFromConfiguration().getDiskMap().values(), false, true, true);
    }
    return cachedDisksFromDb;
}
#method_after
@Override
protected List<DiskImage> getVmDisksFromDB() {
    if (cachedDisksFromDb == null) {
        cachedDisksFromDb = ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, true, true);
    }
    return cachedDisksFromDb;
}
#end_block

#method_before
protected VM getVmFromConfiguration() {
    if (cachedVmFromConfiguration == null) {
        VdcQueryReturnValue queryReturnValue = runInternalQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(getParameters().getSourceSnapshotId()));
        if (queryReturnValue.getSucceeded()) {
            cachedVmFromConfiguration = queryReturnValue.getReturnValue();
        }
    }
    return cachedVmFromConfiguration;
}
#method_after
protected VM getVmFromConfiguration() {
    VdcQueryReturnValue queryReturnValue = runInternalQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(getParameters().getSourceSnapshotId()));
    return queryReturnValue.getSucceeded() ? queryReturnValue.<VM>getReturnValue() : null;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    Map<String, Pair<String, String>> parentLocks = super.getSharedLocks();
    if (parentLocks != null) {
        locks.putAll(parentLocks);
    }
    VM vm = getVmFromConfiguration();
    if (vm != null) {
        locks.put(vm.getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return locks;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    Map<String, Pair<String, String>> parentLocks = super.getSharedLocks();
    if (parentLocks != null) {
        locks.putAll(parentLocks);
    }
    if (getVm() != null) {
        locks.put(getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return locks;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            if (getVm() != null && !addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping)) {
                return null;
            }
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), graphicsToSkip, false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), graphicsToSkip, false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            addGraphicsDevice();
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            if (getVm() != null && !addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping)) {
                return null;
            }
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), graphicsToSkip, false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), graphicsToSkip, false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            addGraphicsDevice();
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (isTemplateVersion()) {
        String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "updateVmVersion", new Class[0], new Object[0], 0, TimeUnit.SECONDS);
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), jobId);
    }
}
#method_after
private void endDefaultOperations() {
    endUnlockOps();
    // in case of new version of a template, update vms marked to use latest
    if (isTemplateVersion()) {
        String jobId = getSchedulUtil().scheduleAOneTimeJob(this, "updateVmVersion", new Class[0], new Object[0], 0, TimeUnit.SECONDS);
        updateVmsJobIdMap.put(getParameters().getBaseTemplateId(), jobId);
    }
}
#end_block

#method_before
private void cloneTemplate() {
    Snapshot snapshot = getSelectedItem();
    if (snapshot == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    VM selectedVm = getEntity();
    final UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(), this);
    setWindow(model);
    model.startProgress(null);
    model.getVmType().setSelectedItem(selectedVm.getVmType());
    model.getIsHighlyAvailable().setEntity(selectedVm.getStaticData().isAutoStartup());
    AsyncDataProvider.getInstance().getVmConfigurationBySnapshot(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            NewTemplateVmModelBehavior behavior = (NewTemplateVmModelBehavior) model.getBehavior();
            VM vm = (VM) returnValue;
            behavior.setVm(vm);
            model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
            model.setHelpTag(HelpTag.new_template);
            // $NON-NLS-1$
            model.setHashName("new_template");
            model.setIsNew(true);
            model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
            model.initialize(VmSnapshotListModel.this.getSystemTreeSelectedItem());
            model.getCommands().add(// $NON-NLS-1$
            new UICommand("OnNewTemplate", VmSnapshotListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
            // $NON-NLS-1$
            model.getCommands().add(UICommand.createCancelUiCommand("Cancel", VmSnapshotListModel.this));
            model.stopProgress();
        }
    }), snapshot.getId());
}
#method_after
private void cloneTemplate() {
    Snapshot snapshot = getSelectedItem();
    if (snapshot == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    VM selectedVm = getEntity();
    final UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(), this);
    setWindow(model);
    model.startProgress(null);
    model.getVmType().setSelectedItem(selectedVm.getVmType());
    model.getIsHighlyAvailable().setEntity(selectedVm.getStaticData().isAutoStartup());
    AsyncDataProvider.getInstance().getVmConfigurationBySnapshot(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            NewTemplateVmModelBehavior behavior = (NewTemplateVmModelBehavior) model.getBehavior();
            VM vm = (VM) returnValue;
            behavior.setVm(vm);
            model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
            model.setHelpTag(HelpTag.clone_template_from_snapshot);
            // $NON-NLS-1$
            model.setHashName("clone_template_from_snapshot");
            model.setIsNew(true);
            model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
            model.initialize(VmSnapshotListModel.this.getSystemTreeSelectedItem());
            model.getCommands().add(// $NON-NLS-1$
            new UICommand("OnNewTemplate", VmSnapshotListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
            // $NON-NLS-1$
            model.getCommands().add(UICommand.createCancelUiCommand("Cancel", VmSnapshotListModel.this));
            model.stopProgress();
        }
    }), snapshot.getId());
}
#end_block

#method_before
@Override
public Set<String> getConsumedEvents() {
    Set<String> set = new HashSet<>(super.getConsumedEvents());
    if (hasCells == null) {
        return set;
    }
    for (HasCell<T, ?> currentHasCell : hasCells) {
        if (currentHasCell instanceof Column) {
            Set<String> consumedEvents = ((Column) (currentHasCell)).getCell().getConsumedEvents();
            if (consumedEvents != null) {
                set.addAll(consumedEvents);
            }
        }
        if (currentHasCell instanceof AbstractCell) {
            set.addAll(((AbstractCell) currentHasCell).getConsumedEvents());
        }
    }
    return set;
}
#method_after
@Override
public Set<String> getConsumedEvents() {
    Set<String> set = new HashSet<>(super.getConsumedEvents());
    if (hasCells == null) {
        return set;
    }
    for (HasCell<T, ?> currentHasCell : hasCells) {
        if (currentHasCell instanceof Column) {
            Set<String> consumedEvents = ((Column) (currentHasCell)).getCell().getConsumedEvents();
            if (consumedEvents != null) {
                set.addAll(consumedEvents);
            }
        }
        if (currentHasCell instanceof Cell) {
            set.addAll(((Cell) currentHasCell).getConsumedEvents());
        }
    }
    return set;
}
#end_block

#method_before
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getVdsGroupCompatibilityVersion(), getMaximumMigrationDowntime(), getAutoConverge(), getMigrateCompressed(), getVds().getConsoleAddress());
}
#method_after
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getVdsGroupCompatibilityVersion(), getMaximumMigrationDowntime(), getAutoConverge(), getMigrateCompressed(), getDestinationVds().getConsoleAddress());
}
#end_block

#method_before
private List<Guid> getVdsBlackList() {
    List<Guid> blackList = new ArrayList<Guid>(getRunVdssList());
    if (getVdsId() != null) {
        blackList.add(getVdsId());
    }
    return blackList;
}
#method_after
private List<Guid> getVdsBlackList() {
    List<Guid> blackList = new ArrayList<>(getRunVdssList());
    if (getVdsId() != null) {
        blackList.add(getVdsId());
    }
    return blackList;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(new TypeLiteral<HostListModel<Void>>() {
    }).in(Singleton.class);
    bind(HostGeneralModel.class).in(Singleton.class);
    bind(HostHardwareGeneralModel.class).in(Singleton.class);
    bind(HostHooksListModel.class).in(Singleton.class);
    bind(HostBricksListModel.class).in(Singleton.class);
    bind(HostGlusterStorageDevicesListModel.class).in(Singleton.class);
    bind(HostInterfaceListModel.class).in(Singleton.class);
    bind(HostVmListModel.class).in(Singleton.class);
    bind(HostGlusterSwiftListModel.class).in(Singleton.class);
    bind(HostEventListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VDS>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<HostListModel<Void>, HostHardwareGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<HostListModel<Void>, HostHardwareGeneralModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<Map<String, String>, HostListModel<Void>, HostHooksListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<Map<String, String>, HostListModel<Void>, HostHooksListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<GlusterBrickEntity, HostListModel<Void>, HostBricksListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<GlusterBrickEntity, HostListModel<Void>, HostBricksListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<GlusterServerService, HostListModel<Void>, HostGlusterSwiftListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<GlusterServerService, HostListModel<Void>, HostGlusterSwiftListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, HostListModel<Void>, PermissionListModel<VDS>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VDS, HostListModel<Void>>>() {
    }).in(Singleton.class);
}
#method_after
@Override
protected void configure() {
    bind(new TypeLiteral<HostListModel<Void>>() {
    }).in(Singleton.class);
    bind(HostGeneralModel.class).in(Singleton.class);
    bind(HostHardwareGeneralModel.class).in(Singleton.class);
    bind(HostHooksListModel.class).in(Singleton.class);
    bind(HostBricksListModel.class).in(Singleton.class);
    bind(HostGlusterStorageDevicesListModel.class).in(Singleton.class);
    bind(HostInterfaceListModel.class).in(Singleton.class);
    bind(HostVmListModel.class).in(Singleton.class);
    bind(HostGlusterSwiftListModel.class).in(Singleton.class);
    bind(HostEventListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VDS>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<HostListModel<Void>, HostHardwareGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<HostListModel<Void>, HostHardwareGeneralModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<Map<String, String>, HostListModel<Void>, HostHooksListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<Map<String, String>, HostListModel<Void>, HostHooksListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<GlusterBrickEntity, HostListModel<Void>, HostBricksListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<GlusterBrickEntity, HostListModel<Void>, HostBricksListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<GlusterServerService, HostListModel<Void>, HostGlusterSwiftListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<GlusterServerService, HostListModel<Void>, HostGlusterSwiftListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<StorageDevice, HostListModel<Void>, HostGlusterStorageDevicesListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<StorageDevice, HostListModel<Void>, HostGlusterStorageDevicesListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permissions, HostListModel<Void>, PermissionListModel<VDS>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VDS, HostListModel<Void>>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
@Override
public void edit(HostSetupNetworksModel uicommonModel) {
    driver.edit(uicommonModel);
    uicommonModel.getNicsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            // this is called after both networks and nics were retrieved
            HostSetupNetworksModel model = (HostSetupNetworksModel) sender;
            if (!keepStatusText) {
                initStatusPanel();
            }
            keepStatusText = false;
            updateNetworks(model.getNetworks());
            updateLabels(model.getNewNetworkLabelModel(), model.getLabels());
            updateNics(model.getNics());
            // mark as rendered
            rendered = true;
        }
    });
    uicommonModel.getOperationCandidateEvent().addListener(new IEventListener<OperationCandidateEventArgs>() {

        @Override
        public void eventRaised(Event<? extends OperationCandidateEventArgs> ev, Object sender, OperationCandidateEventArgs args) {
            NetworkOperation candidate = args.getCandidate();
            NetworkItemModel<?> op1 = args.getOp1();
            NetworkItemModel<?> op2 = args.getOp2();
            if (candidate == null) {
                setErrorStatus(constants.noValidActionSetupNetwork());
            } else {
                if (candidate.isErroneousOperation()) {
                    setErrorStatus(candidate.getMessage(op1, op2));
                } else {
                    if (candidate.isDisplayNetworkAffected(op1, op2)) {
                        setWarningStatus(messages.moveDisplayNetworkWarning(candidate.getMessage(op1, op2)));
                    } else {
                        setValidStatus(candidate.getMessage(op1, op2));
                    }
                }
            }
        }
    });
    internalNetworkList.setSetupModel(uicommonModel);
    externalNetworkList.setSetupModel(uicommonModel);
    labelsList.setSetupModel(uicommonModel);
}
#method_after
@Override
public void edit(HostSetupNetworksModel uicommonModel) {
    driver.edit(uicommonModel);
    uicommonModel.getNicsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            // this is called after both networks and nics were retrieved
            HostSetupNetworksModel model = (HostSetupNetworksModel) sender;
            if (!keepStatusText) {
                initStatusPanel();
            }
            keepStatusText = false;
            updateNetworks(model.getNetworks());
            updateLabels(model.getNewNetworkLabelModel(), model.getLabels());
            updateNics(model.getNics());
            // mark as rendered
            rendered = true;
        }
    });
    uicommonModel.getOperationCandidateEvent().addListener(new IEventListener<OperationCandidateEventArgs>() {

        @Override
        public void eventRaised(Event<? extends OperationCandidateEventArgs> ev, Object sender, OperationCandidateEventArgs args) {
            NetworkOperation candidate = args.getCandidate();
            NetworkItemModel<?> op1 = args.getOp1();
            NetworkItemModel<?> op2 = args.getOp2();
            if (candidate == null) {
                setErrorStatus(constants.noValidActionSetupNetwork());
            } else {
                if (candidate.isErroneousOperation()) {
                    setErrorStatus(candidate.getMessage(op1, op2));
                } else {
                    if (candidate.isDisplayNetworkAffected(op1, op2)) {
                        setWarningStatus(applicationMessages.moveDisplayNetworkWarning(candidate.getMessage(op1, op2)));
                    } else {
                        setValidStatus(candidate.getMessage(op1, op2));
                    }
                }
            }
        }
    });
    internalNetworkList.setSetupModel(uicommonModel);
    externalNetworkList.setSetupModel(uicommonModel);
    labelsList.setSetupModel(uicommonModel);
}
#end_block

#method_before
public Map<NetworkOperation, List<NetworkCommand>> commandsFor(NetworkItemModel<?> item, List<VdsNetworkInterface> allNics) {
    Map<NetworkOperation, List<NetworkCommand>> operations = new HashMap<>();
    // with nics
    for (NetworkInterfaceModel nic : nics) {
        NetworkOperation operation = operationFor(item, nic);
        if (!operation.isNullOperation()) {
            assertBinary(item, nic, operation);
            addToOperationMultiMap(operations, operation, operation.getCommand(item, nic, allNics));
        }
    }
    // with networks
    for (LogicalNetworkModel network : allNetworks) {
        NetworkOperation operation = operationFor(item, network);
        if (!operation.isNullOperation()) {
            assertBinary(item, network, operation);
            addToOperationMultiMap(operations, operation, operation.getCommand(item, network, allNics));
        }
    }
    // with self
    NetworkOperation operation = operationFor(item, null);
    if (!operation.isNullOperation()) {
        assert operation.isUnary() : // $NON-NLS-1$
        "Operation " + operation.name() + " is Binary, while a Uniary Operation is expected for " + // $NON-NLS-1$
        item.getName();
        addToOperationMultiMap(operations, operation, operation.getCommand(item, null, allNics));
    }
    return operations;
}
#method_after
public OperationMap commandsFor(NetworkItemModel<?> item, List<VdsNetworkInterface> allNics) {
    OperationMap operations = new OperationMap();
    // with nics
    for (NetworkInterfaceModel nic : nics) {
        NetworkOperation operation = operationFor(item, nic);
        if (!operation.isNullOperation()) {
            assertBinary(item, nic, operation);
            operations.addCommand(operation, operation.getCommand(item, nic, allNics));
        }
    }
    // with networks
    for (LogicalNetworkModel network : allNetworks) {
        NetworkOperation operation = operationFor(item, network);
        if (!operation.isNullOperation()) {
            assertBinary(item, network, operation);
            operations.addCommand(operation, operation.getCommand(item, network, allNics));
        }
    }
    // with self
    NetworkOperation operation = operationFor(item, null);
    if (!operation.isNullOperation()) {
        assert operation.isUnary() : // $NON-NLS-1$
        "Operation " + operation.name() + " is Binary, while a Uniary Operation is expected for " + // $NON-NLS-1$
        item.getName();
        operations.addCommand(operation, operation.getCommand(item, null, allNics));
    }
    return operations;
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(NetworkListModel.class).in(Singleton.class);
    bind(NetworkGeneralModel.class).in(Singleton.class);
    bind(NetworkProfileListModel.class).in(Singleton.class);
    bind(NetworkExternalSubnetListModel.class).in(Singleton.class);
    bind(NetworkClusterListModel.class).in(Singleton.class);
    bind(NetworkHostListModel.class).in(Singleton.class);
    bind(NetworkVmListModel.class).in(Singleton.class);
    bind(NetworkTemplateListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<NetworkView>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, NetworkListModel, PermissionListModel<NetworkView>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<NetworkView, NetworkListModel>>() {
    }).in(Singleton.class);
}
#method_after
@Override
protected void configure() {
    bind(NetworkListModel.class).in(Singleton.class);
    bind(NetworkGeneralModel.class).in(Singleton.class);
    bind(NetworkProfileListModel.class).in(Singleton.class);
    bind(NetworkExternalSubnetListModel.class).in(Singleton.class);
    bind(NetworkClusterListModel.class).in(Singleton.class);
    bind(NetworkHostListModel.class).in(Singleton.class);
    bind(NetworkVmListModel.class).in(Singleton.class);
    bind(NetworkTemplateListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<NetworkView>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permissions, NetworkListModel, PermissionListModel<NetworkView>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<NetworkView, NetworkListModel>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
public Map<NetworkOperation, List<NetworkCommand>> commandsFor(NetworkItemModel<?> item) {
    return operationFactory.commandsFor(item, allNics);
}
#method_after
public OperationMap commandsFor(NetworkItemModel<?> item) {
    return operationFactory.commandsFor(item, allNics);
}
#end_block

#method_before
@PostConstruct
private void init() {
    int autoStartVmsRunnerIntervalInSeconds = Config.<Integer>getValue(ConfigValues.AutoStartVmsRunnerIntervalInSeconds);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "startFailedAutoStartVms", new Class[] {}, new Object[] {}, autoStartVmsRunnerIntervalInSeconds, autoStartVmsRunnerIntervalInSeconds, TimeUnit.SECONDS);
}
#method_after
@PostConstruct
private void init() {
    int autoStartVmsRunnerIntervalInSeconds = Config.<Integer>getValue(ConfigValues.AutoStartVmsRunnerIntervalInSeconds);
    schedulerUtil.scheduleAFixedDelayJob(this, "startFailedAutoStartVms", new Class[] {}, new Object[] {}, autoStartVmsRunnerIntervalInSeconds, autoStartVmsRunnerIntervalInSeconds, TimeUnit.SECONDS);
}
#end_block

#method_before
@Override
public void updateSlaPolicies(final List<Guid> vmIds, final Guid vdsId) {
    if (vmIds.isEmpty()) {
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            for (Guid vmId : vmIds) {
                CpuQos qos = DbFacade.getInstance().getCpuQosDao().getCpuQosByVmId(vmId);
                if (qos != null && qos.getCpuLimit() != null) {
                    ResourceManager.getInstance().runVdsCommand(VDSCommandType.UpdateVmPolicy, new UpdateVmPolicyVDSParams(vdsId, vmId, qos.getCpuLimit().intValue()));
                }
            }
        }
    });
}
#method_after
@Override
public void updateSlaPolicies(final List<Guid> vmIds, final Guid vdsId) {
    if (vmIds.isEmpty()) {
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            for (Guid vmId : vmIds) {
                CpuQos qos = DbFacade.getInstance().getCpuQosDao().getCpuQosByVmId(vmId);
                if (qos != null && qos.getCpuLimit() != null) {
                    resourceManagerProvider.get().runVdsCommand(VDSCommandType.UpdateVmPolicy, new UpdateVmPolicyVDSParams(vdsId, vmId, qos.getCpuLimit().intValue()));
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.initDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    loadService(VmPoolMonitor.class);
    loadService(AutoStartVmsRunner.class);
    int quotaCacheIntervalInMinutes = Config.<Integer>getValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
@Override
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // TODO temporal solution DbFacade in Utils
    SimpleDependecyInjector.getInstance().bind(dbFacade);
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.initDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    loadService(VmPoolMonitor.class);
    loadService(AutoStartVmsRunner.class);
    int quotaCacheIntervalInMinutes = Config.<Integer>getValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
@Override
public ArrayList<VdcReturnValueBase> runMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isRunOnlyIfAllCanDoPass, boolean waitForResult) {
    VdcReturnValueBase returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        ArrayList<VdcReturnValueBase> list = new ArrayList<VdcReturnValueBase>();
        list.add(returnValue);
        return list;
    } else {
        return runMultipleActionsImpl(actionType, parameters, false, isRunOnlyIfAllCanDoPass, waitForResult, null);
    }
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> runMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isRunOnlyIfAllCanDoPass, boolean waitForResult) {
    VdcReturnValueBase returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        ArrayList<VdcReturnValueBase> list = new ArrayList<>();
        list.add(returnValue);
        return list;
    } else {
        return runMultipleActionsImpl(actionType, parameters, false, isRunOnlyIfAllCanDoPass, waitForResult, null);
    }
}
#end_block

#method_before
@Override
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.initDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    loadService(VmPoolMonitor.class);
    int autoStartVmsRunnerIntervalInSeconds = Config.<Integer>getValue(ConfigValues.AutoStartVmsRunnerIntervalInSeconds);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(AutoStartVmsRunner.getInstance(), "startFailedAutoStartVms", new Class[] {}, new Object[] {}, autoStartVmsRunnerIntervalInSeconds, autoStartVmsRunnerIntervalInSeconds, TimeUnit.SECONDS);
    int quotaCacheIntervalInMinutes = Config.<Integer>getValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
@Override
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // TODO temporal solution DbFacade in Utils
    SimpleDependecyInjector.getInstance().bind(dbFacade);
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.initDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    loadService(VmPoolMonitor.class);
    int autoStartVmsRunnerIntervalInSeconds = Config.<Integer>getValue(ConfigValues.AutoStartVmsRunnerIntervalInSeconds);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(AutoStartVmsRunner.getInstance(), "startFailedAutoStartVms", new Class[] {}, new Object[] {}, autoStartVmsRunnerIntervalInSeconds, autoStartVmsRunnerIntervalInSeconds, TimeUnit.SECONDS);
    int quotaCacheIntervalInMinutes = Config.<Integer>getValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
@Override
public ArrayList<VdcReturnValueBase> runMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isRunOnlyIfAllCanDoPass, boolean waitForResult) {
    VdcReturnValueBase returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        ArrayList<VdcReturnValueBase> list = new ArrayList<VdcReturnValueBase>();
        list.add(returnValue);
        return list;
    } else {
        return runMultipleActionsImpl(actionType, parameters, false, isRunOnlyIfAllCanDoPass, waitForResult, null);
    }
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> runMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isRunOnlyIfAllCanDoPass, boolean waitForResult) {
    VdcReturnValueBase returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        ArrayList<VdcReturnValueBase> list = new ArrayList<>();
        list.add(returnValue);
        return list;
    } else {
        return runMultipleActionsImpl(actionType, parameters, false, isRunOnlyIfAllCanDoPass, waitForResult, null);
    }
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        loadService(PmHealthCheckManager.class);
        loadService(EngineBackupAwarenessManager.class);
        CommandCoordinatorUtil.initAsyncTaskManager();
        loadService(ResourceManager.class);
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDcSingleton.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        SessionDataContainer.getInstance().cleanupEngineSessionsOnStartup();
        loadService(HostDeviceManager.class);
        loadService(DwhHeartBeat.class);
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#method_after
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        loadService(PmHealthCheckManager.class);
        loadService(EngineBackupAwarenessManager.class);
        CommandCoordinatorUtil.initAsyncTaskManager();
        loadService(ResourceManager.class);
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDcSingleton.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        SessionDataContainer.getInstance().cleanupEngineSessionsOnStartup();
        loadService(HostDeviceManager.class);
        loadService(DwhHeartBeat.class);
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation(DWH_HEART_BEAT_METHOD)
public void engineIsRunningNotification() {
    try {
        heartBeatVar.setDateTime(new Date());
        DbFacade.getInstance().getDwhHistoryTimekeepingDao().save(heartBeatVar);
    } catch (Exception ex) {
        log.error("Error updating DWH Heart Beat: {}", ex.getMessage());
        log.debug("Exception", ex);
    }
}
#method_after
@OnTimerMethodAnnotation(DWH_HEART_BEAT_METHOD)
public void engineIsRunningNotification() {
    try {
        heartBeatVar.setDateTime(new Date());
        dwhHistoryTimekeepingDao.save(heartBeatVar);
    } catch (Exception ex) {
        log.error("Error updating DWH Heart Beat: {}", ex.getMessage());
        log.debug("Exception", ex);
    }
}
#end_block

#method_before
@PostConstruct
private void init() {
    log.info("Initializing DWH Heart Beat");
    heartBeatVar = new DwhHistoryTimekeeping();
    heartBeatVar.setVariable(DwhHistoryTimekeepingVariable.HEART_BEAT);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, DWH_HEART_BEAT_METHOD, new Class[] {}, new Object[] {}, 0, Config.<Integer>getValue(ConfigValues.DwhHeartBeatInterval), TimeUnit.SECONDS);
    log.info("DWH Heart Beat initialized");
}
#method_after
@PostConstruct
private void init() {
    log.info("Initializing DWH Heart Beat");
    heartBeatVar = new DwhHistoryTimekeeping();
    heartBeatVar.setVariable(DwhHistoryTimekeepingVariable.HEART_BEAT);
    schedulerUtil.scheduleAFixedDelayJob(this, DWH_HEART_BEAT_METHOD, new Class[] {}, new Object[] {}, 0, Config.<Integer>getValue(ConfigValues.DwhHeartBeatInterval), TimeUnit.SECONDS);
    log.info("DWH Heart Beat initialized");
}
#end_block

#method_before
@Override
public ArrayList<VdcReturnValueBase> runMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isRunOnlyIfAllCanDoPass, boolean waitForResult) {
    VdcReturnValueBase returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        ArrayList<VdcReturnValueBase> list = new ArrayList<VdcReturnValueBase>();
        list.add(returnValue);
        return list;
    } else {
        return runMultipleActionsImpl(actionType, parameters, false, isRunOnlyIfAllCanDoPass, waitForResult, null);
    }
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> runMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isRunOnlyIfAllCanDoPass, boolean waitForResult) {
    VdcReturnValueBase returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        ArrayList<VdcReturnValueBase> list = new ArrayList<>();
        list.add(returnValue);
        return list;
    } else {
        return runMultipleActionsImpl(actionType, parameters, false, isRunOnlyIfAllCanDoPass, waitForResult, null);
    }
}
#end_block

#method_before
public void setup() {
    instance = this;
    final String QUARTZ_DB_PROPERTIES = "ovirt-db-scheduler.properties";
    Properties props = null;
    try {
        props = ResourceUtils.loadProperties(SchedulerUtil.class, QUARTZ_DB_PROPERTIES);
    } catch (IOException exception) {
        throw new IllegalStateException("Can't load properties from resource \"" + QUARTZ_DB_PROPERTIES + "\".", exception);
    }
    setup(props);
}
#method_after
public void setup() {
    final String QUARTZ_DB_PROPERTIES = "ovirt-db-scheduler.properties";
    Properties props = null;
    try {
        props = ResourceUtils.loadProperties(SchedulerUtil.class, QUARTZ_DB_PROPERTIES);
    } catch (IOException exception) {
        throw new IllegalStateException("Can't load properties from resource \"" + QUARTZ_DB_PROPERTIES + "\".", exception);
    }
    setup(props);
}
#end_block

