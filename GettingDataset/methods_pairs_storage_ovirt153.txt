383
#method_before
private boolean removeMemoryVolumes(String memVols) {
    List<Guid> guids = GuidUtils.getGuidListFromString(memVols);
    if (guids.size() != NUM_OF_UUIDS_IN_MEMORT_STATE) {
        log.warnFormat("Cannot remove memory volumes, invalid format: {0}", memVols);
        return true;
    }
    Guid memoryImageRemovalTaskId = removeMemoryImage(guids);
    if (memoryImageRemovalTaskId == null) {
        return false;
    }
    Guid confImageRemovalTaskId = removeConfImage(guids);
    if (startPollingTasks) {
        if (!Guid.Empty.equals(memoryImageRemovalTaskId)) {
            AsyncTaskManager.getInstance().StartPollingTask(memoryImageRemovalTaskId);
        }
        if (confImageRemovalTaskId != null && !Guid.Empty.equals(confImageRemovalTaskId)) {
            AsyncTaskManager.getInstance().StartPollingTask(confImageRemovalTaskId);
        }
    }
    return confImageRemovalTaskId != null;
}
#method_after
private boolean removeMemoryVolumes(String memVols) {
    List<Guid> guids = GuidUtils.getGuidListFromString(memVols);
    if (guids.size() != NUM_OF_UUIDS_IN_MEMORY_STATE) {
        log.warnFormat("Cannot remove memory volumes, invalid format: {0}", memVols);
        return true;
    }
    Guid memoryImageRemovalTaskId = removeMemoryImage(guids);
    if (memoryImageRemovalTaskId == null) {
        return false;
    }
    Guid confImageRemovalTaskId = removeConfImage(guids);
    if (startPollingTasks) {
        if (!Guid.Empty.equals(memoryImageRemovalTaskId)) {
            AsyncTaskManager.getInstance().StartPollingTask(memoryImageRemovalTaskId);
        }
        if (confImageRemovalTaskId != null && !Guid.Empty.equals(confImageRemovalTaskId)) {
            AsyncTaskManager.getInstance().StartPollingTask(confImageRemovalTaskId);
        }
    }
    return confImageRemovalTaskId != null;
}
#end_block

#method_before
protected Guid removeMemoryImage(List<Guid> guids) {
    Guid taskId = enclosingCommand.persistAsyncTaskPlaceHolder(VmCommand.DELETE_PRIMARY_IMAGE_TASK_KEY);
    VDSReturnValue vdsRetValue;
    try {
        vdsRetValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DeleteImageGroup, buildDeleteMemoryImageParams(guids));
        if (!vdsRetValue.getSucceeded()) {
            return null;
        }
    } catch (VdcBLLException e) {
        if (e.getErrorCode() == VdcBllErrors.ImageDoesNotExistInDomainError) {
            return Guid.Empty;
        }
        throw e;
    }
    Guid guid = enclosingCommand.createTask(taskId, vdsRetValue.getCreationInfo(), enclosingCommand.getActionType(), VdcObjectType.Storage, guids.get(0));
    enclosingCommand.getTaskIdList().add(guid);
    return guid;
}
#method_after
protected Guid removeMemoryImage(List<Guid> guids) {
    return removeImage(VmCommand.DELETE_PRIMARY_IMAGE_TASK_KEY, buildDeleteMemoryImageParams(guids));
}
#end_block

#method_before
protected Guid removeConfImage(List<Guid> guids) {
    Guid taskId = enclosingCommand.persistAsyncTaskPlaceHolder(VmCommand.DELETE_SECONDARY_IMAGES_TASK_KEY);
    VDSReturnValue vdsRetValue;
    try {
        vdsRetValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DeleteImageGroup, buildDeleteMemoryConfParams(guids));
        if (!vdsRetValue.getSucceeded()) {
            return null;
        }
    } catch (VdcBLLException e) {
        if (e.getErrorCode() == VdcBllErrors.ImageDoesNotExistInDomainError) {
            return Guid.Empty;
        }
        throw e;
    }
    Guid guid = enclosingCommand.createTask(taskId, vdsRetValue.getCreationInfo(), enclosingCommand.getActionType());
    enclosingCommand.getTaskIdList().add(guid);
    return guid;
}
#method_after
protected Guid removeConfImage(List<Guid> guids) {
    return removeImage(VmCommand.DELETE_SECONDARY_IMAGES_TASK_KEY, buildDeleteMemoryConfParams(guids));
}
#end_block

#method_before
protected boolean removeMemoryVolumes(String memVols, boolean startPollingTasks) {
    List<Guid> guids = GuidUtils.getGuidListFromString(memVols);
    if (guids.size() == 6) {
        Guid guid1 = removeMemoryImage(guids);
        if (guid1 == null) {
            return false;
        }
        Guid guid2 = removeConfImage(guids);
        if (startPollingTasks) {
            if (!Guid.Empty.equals(guid1)) {
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            if (guid2 != null && !Guid.Empty.equals(guid2)) {
                AsyncTaskManager.getInstance().StartPollingTask(guid2);
            }
        }
        return guid2 != null;
    }
    return true;
}
#method_after
protected boolean removeMemoryVolumes(String memVols, boolean startPollingTasks) {
    List<Guid> guids = GuidUtils.getGuidListFromString(memVols);
    if (guids.size() == 6) {
        Guid guid1 = removeMemoryImage(guids);
        if (guid1 == null) {
            return false;
        }
        Guid guid2 = removeConfImage(guids);
        if (startPollingTasks) {
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            if (guid2 != null) {
                AsyncTaskManager.getInstance().StartPollingTask(guid2);
            }
        }
        return guid2 != null;
    }
    return true;
}
#end_block

#method_before
protected Guid removeMemoryImage(List<Guid> guids) {
    Guid taskId1 = enclosingCommand.persistAsyncTaskPlaceHolder(VmCommand.DELETE_PRIMARY_IMAGE_TASK_KEY);
    VDSReturnValue vdsRetValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DeleteImageGroup, buildDeleteMemoryImageParams(guids));
    if (!vdsRetValue.getSucceeded()) {
        return null;
    }
    Guid guid1 = enclosingCommand.createTask(taskId1, vdsRetValue.getCreationInfo(), enclosingCommand.getActionType(), VdcObjectType.Storage, guids.get(0));
    enclosingCommand.getTaskIdList().add(guid1);
    return guid1;
}
#method_after
protected Guid removeMemoryImage(List<Guid> guids) {
    return removeImage(VmCommand.DELETE_PRIMARY_IMAGE_TASK_KEY, buildDeleteMemoryImageParams(guids));
}
#end_block

#method_before
protected Guid removeConfImage(List<Guid> guids) {
    Guid taskId2 = enclosingCommand.persistAsyncTaskPlaceHolder(VmCommand.DELETE_SECONDARY_IMAGES_TASK_KEY);
    VDSReturnValue vdsRetValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DeleteImageGroup, buildDeleteMemoryConfParams(guids));
    if (!vdsRetValue.getSucceeded()) {
        return null;
    }
    Guid guid2 = enclosingCommand.createTask(taskId2, vdsRetValue.getCreationInfo(), enclosingCommand.getActionType());
    enclosingCommand.getTaskIdList().add(guid2);
    return guid2;
}
#method_after
protected Guid removeConfImage(List<Guid> guids) {
    return removeImage(VmCommand.DELETE_SECONDARY_IMAGES_TASK_KEY, buildDeleteMemoryConfParams(guids));
}
#end_block

#method_before
private static void addEmptyDataCenterToList(List<StoragePool> dataCenters) {
    StoragePool tempVar = new StoragePool();
    tempVar.setId(UnassignedDataCenterId);
    // $NON-NLS-1$
    tempVar.setname("(none)");
    dataCenters.add(tempVar);
}
#method_after
private static void addEmptyDataCenterToList(List<StoragePool> dataCenters) {
    StoragePool tempVar = new StoragePool();
    tempVar.setId(UnassignedDataCenterId);
    // $NON-NLS-1$
    tempVar.setName("(none)");
    dataCenters.add(tempVar);
}
#end_block

#method_before
void updateHost() {
    if (getDataCenter().getItems() == null) {
        return;
    }
    if (getSelectedItem() == null) {
        return;
    }
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    if (getSelectedItem() instanceof LocalStorageModel && (dataCenter == null || dataCenter.getId().equals(UnassignedDataCenterId))) {
        ArrayList<StoragePool> dataCenterList = (ArrayList<StoragePool>) getDataCenter().getItems();
        ArrayList<StoragePool> localDCList = new ArrayList<StoragePool>();
        StringBuilder dataCenterQueryLine = new StringBuilder();
        for (StoragePool storagePool : dataCenterList) {
            if (storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
                localDCList.add(storagePool);
            }
        }
        if (localDCList.size() > 0) {
            int i = 0;
            for (; i < localDCList.size() - 1; i++) {
                // $NON-NLS-1$ //$NON-NLS-2$
                dataCenterQueryLine.append("datacenter=").append(localDCList.get(i).getname()).append(" or ");
            }
            // $NON-NLS-1$
            dataCenterQueryLine.append("datacenter=").append(localDCList.get(i).getname());
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.setContext(getHash());
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object ReturnValue) {
                    StorageModel storageModel = (StorageModel) model;
                    Iterable<VDS> hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                    storageModel.postUpdateHost(hosts);
                }
            };
            Frontend.RunQuery(VdcQueryType.Search, new // $NON-NLS-1$
            SearchParameters(// $NON-NLS-1$
            "Hosts: status=Up " + dataCenterQueryLine.toString(), SearchType.VDS), _asyncQuery);
        }
    } else {
        if (dataCenter == null || dataCenter.getId().equals(UnassignedDataCenterId)) {
            AsyncDataProvider.getHostList(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    Iterable<VDS> hosts = (Iterable<VDS>) returnValue;
                    storageModel.postUpdateHost(hosts);
                }
            }, getHash()));
        } else {
            AsyncDataProvider.getHostListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    Iterable<VDS> hosts = (Iterable<VDS>) returnValue;
                    storageModel.postUpdateHost(hosts);
                }
            }, getHash()), dataCenter.getId());
        }
    }
}
#method_after
void updateHost() {
    if (getDataCenter().getItems() == null) {
        return;
    }
    if (getSelectedItem() == null) {
        return;
    }
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    boolean localFsOnly = getSelectedItem() instanceof LocalStorageModel;
    Guid dataCenterId = dataCenter == null ? null : dataCenter.getId();
    AsyncDataProvider.getHostsForStorageOperation(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            StorageModel storageModel = (StorageModel) model;
            Iterable<VDS> hosts = (Iterable<VDS>) returnValue;
            storageModel.postUpdateHost(hosts);
        }
    }, getHash()), dataCenterId, localFsOnly);
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    vmBackupModel = new VmBackupModel();
    vmBackupModel.setIsAvailable(false);
    templateBackupModel = new TemplateBackupModel();
    templateBackupModel.setIsAvailable(false);
    vmListModel = new StorageVmListModel();
    vmListModel.setIsAvailable(false);
    templateListModel = new StorageTemplateListModel();
    templateListModel.setIsAvailable(false);
    isoListModel = new StorageIsoListModel();
    isoListModel.setIsAvailable(false);
    diskListModel = new StorageDiskListModel();
    diskListModel.setIsAvailable(false);
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new StorageGeneralModel());
    list.add(new StorageDataCenterListModel());
    list.add(vmBackupModel);
    list.add(templateBackupModel);
    list.add(vmListModel);
    list.add(templateListModel);
    list.add(isoListModel);
    list.add(diskListModel);
    list.add(new StorageEventListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    generalModel = new StorageGeneralModel();
    generalModel.setIsAvailable(false);
    dcListModel = new StorageDataCenterListModel();
    dcListModel.setIsAvailable(false);
    vmBackupModel = new VmBackupModel();
    vmBackupModel.setIsAvailable(false);
    templateBackupModel = new TemplateBackupModel();
    templateBackupModel.setIsAvailable(false);
    vmListModel = new StorageVmListModel();
    vmListModel.setIsAvailable(false);
    templateListModel = new StorageTemplateListModel();
    templateListModel.setIsAvailable(false);
    isoListModel = new StorageIsoListModel();
    isoListModel.setIsAvailable(false);
    diskListModel = new StorageDiskListModel();
    diskListModel.setIsAvailable(false);
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(dcListModel);
    list.add(vmBackupModel);
    list.add(templateBackupModel);
    list.add(vmListModel);
    list.add(templateListModel);
    list.add(isoListModel);
    list.add(diskListModel);
    list.add(new StorageEventListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
private void newDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDomainTitle());
    // $NON-NLS-1$
    model.setHashName("new_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    ArrayList<IStorageModel> items = new ArrayList<IStorageModel>();
    // putting all Data domains at the beginning on purpose (so when choosing the
    // first selectable storage type/function, it will be a Data one, if relevant).
    NfsStorageModel nfsDataModel = new NfsStorageModel();
    nfsDataModel.setRole(StorageDomainType.Data);
    items.add(nfsDataModel);
    IscsiStorageModel iscsiDataModel = new IscsiStorageModel();
    iscsiDataModel.setRole(StorageDomainType.Data);
    iscsiDataModel.setIsGrouppedByTarget(true);
    items.add(iscsiDataModel);
    FcpStorageModel fcpDataModel = new FcpStorageModel();
    fcpDataModel.setRole(StorageDomainType.Data);
    items.add(fcpDataModel);
    LocalStorageModel localDataModel = new LocalStorageModel();
    localDataModel.setRole(StorageDomainType.Data);
    items.add(localDataModel);
    LocalStorageModel localIsoModel = new LocalStorageModel();
    localIsoModel.setRole(StorageDomainType.ISO);
    items.add(localIsoModel);
    PosixStorageModel posixDataModel = new PosixStorageModel();
    posixDataModel.setRole(StorageDomainType.Data);
    items.add(posixDataModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    posixIsoModel.setRole(StorageDomainType.ISO);
    items.add(posixIsoModel);
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    nfsIsoModel.setRole(StorageDomainType.ISO);
    items.add(nfsIsoModel);
    NfsStorageModel nfsExportModel = new NfsStorageModel();
    nfsExportModel.setRole(StorageDomainType.ImportExport);
    items.add(nfsExportModel);
    GlusterStorageModel GlusterDataModel = new GlusterStorageModel();
    GlusterDataModel.setRole(StorageDomainType.Data);
    items.add(GlusterDataModel);
    model.setItems(items);
    model.initialize();
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand("OnSave", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#method_after
private void newDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDomainTitle());
    // $NON-NLS-1$
    model.setHashName("new_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    ArrayList<IStorageModel> items = new ArrayList<IStorageModel>();
    // putting all Data domains at the beginning on purpose (so when choosing the
    // first selectable storage type/function, it will be a Data one, if relevant).
    NfsStorageModel nfsDataModel = new NfsStorageModel();
    nfsDataModel.setRole(StorageDomainType.Data);
    items.add(nfsDataModel);
    IscsiStorageModel iscsiDataModel = new IscsiStorageModel();
    iscsiDataModel.setRole(StorageDomainType.Data);
    iscsiDataModel.setIsGrouppedByTarget(true);
    items.add(iscsiDataModel);
    FcpStorageModel fcpDataModel = new FcpStorageModel();
    fcpDataModel.setRole(StorageDomainType.Data);
    items.add(fcpDataModel);
    LocalStorageModel localDataModel = new LocalStorageModel();
    localDataModel.setRole(StorageDomainType.Data);
    items.add(localDataModel);
    LocalStorageModel localIsoModel = new LocalStorageModel();
    localIsoModel.setRole(StorageDomainType.ISO);
    items.add(localIsoModel);
    PosixStorageModel posixDataModel = new PosixStorageModel();
    posixDataModel.setRole(StorageDomainType.Data);
    items.add(posixDataModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    posixIsoModel.setRole(StorageDomainType.ISO);
    items.add(posixIsoModel);
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    nfsIsoModel.setRole(StorageDomainType.ISO);
    items.add(nfsIsoModel);
    NfsStorageModel nfsExportModel = new NfsStorageModel();
    nfsExportModel.setRole(StorageDomainType.ImportExport);
    items.add(nfsExportModel);
    GlusterStorageModel GlusterDataModel = new GlusterStorageModel();
    GlusterDataModel.setRole(StorageDomainType.Data);
    items.add(GlusterDataModel);
    model.setItems(items);
    model.initialize();
    // $NON-NLS-1$
    UICommand command = createOKCommand("OnSave");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
private void edit() {
    StorageDomain storage = (StorageDomain) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangable(false);
    model.getFormat().setIsChangable(false);
    boolean isStorageEditable = model.isStorageActive() || model.isNewStorage();
    model.getHost().setIsChangable(false);
    model.getName().setIsChangable(isStorageEditable);
    model.getDescription().setIsChangable(isStorageEditable);
    model.getComment().setIsChangable(isStorageEditable);
    // set the field domain type to non editable
    model.getAvailableStorageItems().setIsChangable(false);
    model.setIsChangable(isStorageEditable);
    IStorageModel item = null;
    switch(storage.getStorageType()) {
        case NFS:
            item = prepareNfsStorageForEdit(storage);
            boolean isNfsPathEditable = isPathEditable(storage);
            isStorageEditable = isStorageEditable || isNfsPathEditable;
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isNfsPathEditable);
            break;
        case FCP:
            item = prepareFcpStorageForEdit(storage);
            break;
        case ISCSI:
            item = prepareIscsiStorageForEdit(storage);
            break;
        case LOCALFS:
            item = prepareLocalStorageForEdit(storage);
            break;
        case POSIXFS:
            item = preparePosixStorageForEdit(storage);
            boolean isPathEditable = isPathEditable(storage);
            isStorageEditable = isStorageEditable || isPathEditable;
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case GLUSTERFS:
            item = prepareGlusterStorageForEdit(storage);
            break;
    }
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case Storage:
                {
                    model.getName().setIsChangable(false);
                    // $NON-NLS-1$
                    model.getName().setInfo("Cannot edit Storage Domains's Name in this tree context");
                }
                break;
        }
    }
    UICommand command;
    if (isStorageEditable) {
        // $NON-NLS-1$
        command = new UICommand("OnSave", this);
        command.setTitle(ConstantsManager.getInstance().getConstants().ok());
        command.setIsDefault(true);
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = new UICommand("Cancel", this);
        command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        command.setIsCancel(true);
        model.getCommands().add(command);
    } else {
        // $NON-NLS-1$
        command = new UICommand("Cancel", this);
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        command.setIsCancel(true);
        model.getCommands().add(command);
    }
}
#method_after
private void edit() {
    StorageDomain storage = (StorageDomain) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangable(false);
    model.getFormat().setIsChangable(false);
    boolean isStorageEditable = model.isStorageActive() || model.isNewStorage();
    model.getHost().setIsChangable(false);
    model.getName().setIsChangable(isStorageEditable);
    model.getDescription().setIsChangable(isStorageEditable);
    model.getComment().setIsChangable(isStorageEditable);
    // set the field domain type to non editable
    model.getAvailableStorageItems().setIsChangable(false);
    model.setIsChangable(isStorageEditable);
    boolean isPathEditable = isPathEditable(storage);
    isStorageEditable = isStorageEditable || isPathEditable;
    IStorageModel item = null;
    switch(storage.getStorageType()) {
        case NFS:
            item = prepareNfsStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case FCP:
            item = prepareFcpStorageForEdit(storage);
            break;
        case ISCSI:
            item = prepareIscsiStorageForEdit(storage);
            break;
        case LOCALFS:
            item = prepareLocalStorageForEdit(storage);
            model.getHost().setIsChangable(isPathEditable);
            break;
        case POSIXFS:
            item = preparePosixStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case GLUSTERFS:
            item = prepareGlusterStorageForEdit(storage);
            break;
    }
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case Storage:
                {
                    model.getName().setIsChangable(false);
                    // $NON-NLS-1$
                    model.getName().setInfo("Cannot edit Storage Domains's Name in this tree context");
                }
                break;
        }
    }
    UICommand command;
    if (isStorageEditable) {
        // $NON-NLS-1$
        command = createOKCommand("OnSave");
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        model.getCommands().add(command);
    } else {
        // close is created the same as cancel, but with a different title
        // thus most of creation code can be reused.
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        model.getCommands().add(command);
    }
}
#end_block

#method_before
private boolean isPathEditable(StorageDomain storage) {
    return (storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master) && storage.getStatus() == StorageDomainStatus.Maintenance;
}
#method_after
private boolean isPathEditable(StorageDomain storage) {
    if (storage.getStorageType().isFileDomain() && !storage.getStorageType().equals(StorageType.GLUSTERFS)) {
        return ((storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master) && storage.getStatus() == StorageDomainStatus.Maintenance);
    }
    return false;
}
#end_block

#method_before
private IStorageModel prepareLocalStorageForEdit(StorageDomain storage) {
    LocalStorageModel model = new LocalStorageModel();
    model.setRole(storage.getStorageDomainType());
    model.getPath().setIsAvailable(false);
    AsyncDataProvider.getStorageConnectionById(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            LocalStorageModel localStorageModel = (LocalStorageModel) target;
            StorageServerConnections connection = (StorageServerConnections) returnValue;
            localStorageModel.getPath().setEntity(connection.getconnection());
        }
    }), storage.getStorage(), true);
    return model;
}
#method_after
private IStorageModel prepareLocalStorageForEdit(StorageDomain storage) {
    LocalStorageModel model = new LocalStorageModel();
    model.setRole(storage.getStorageDomainType());
    boolean isPathEditable = isPathEditable(storage);
    model.getPath().setIsChangable(isPathEditable);
    AsyncDataProvider.getStorageConnectionById(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            LocalStorageModel localStorageModel = (LocalStorageModel) target;
            StorageServerConnections connection = (StorageServerConnections) returnValue;
            localStorageModel.getPath().setEntity(connection.getconnection());
        }
    }), storage.getStorage(), true);
    return model;
}
#end_block

#method_before
private void importDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new ImportStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().importPreConfiguredDomainTitle());
    // $NON-NLS-1$
    model.setHashName("import_pre-configured_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.getName().setIsAvailable(false);
    model.getDescription().setIsAvailable(false);
    model.getComment().setIsAvailable(false);
    model.getFormat().setIsAvailable(false);
    ArrayList<IStorageModel> items = new ArrayList<IStorageModel>();
    NfsStorageModel tempVar = new NfsStorageModel();
    tempVar.setRole(StorageDomainType.ISO);
    items.add(tempVar);
    LocalStorageModel localIsoModel = new LocalStorageModel();
    localIsoModel.setRole(StorageDomainType.ISO);
    items.add(localIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    posixIsoModel.setRole(StorageDomainType.ISO);
    items.add(posixIsoModel);
    NfsStorageModel tempVar2 = new NfsStorageModel();
    tempVar2.setRole(StorageDomainType.ImportExport);
    items.add(tempVar2);
    model.setItems(items);
    model.initialize();
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand("OnImport", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#method_after
private void importDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new ImportStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().importPreConfiguredDomainTitle());
    // $NON-NLS-1$
    model.setHashName("import_pre-configured_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.getName().setIsAvailable(false);
    model.getDescription().setIsAvailable(false);
    model.getComment().setIsAvailable(false);
    model.getFormat().setIsAvailable(false);
    ArrayList<IStorageModel> items = new ArrayList<IStorageModel>();
    NfsStorageModel tempVar = new NfsStorageModel();
    tempVar.setRole(StorageDomainType.ISO);
    items.add(tempVar);
    LocalStorageModel localIsoModel = new LocalStorageModel();
    localIsoModel.setRole(StorageDomainType.ISO);
    items.add(localIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    posixIsoModel.setRole(StorageDomainType.ISO);
    items.add(posixIsoModel);
    NfsStorageModel tempVar2 = new NfsStorageModel();
    tempVar2.setRole(StorageDomainType.ImportExport);
    items.add(tempVar2);
    model.setItems(items);
    model.initialize();
    UICommand command;
    // $NON-NLS-1$
    command = createOKCommand("OnImport");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
private void cleanConnection(StorageServerConnections connection, Guid hostId) {
    Frontend.RunAction(VdcActionType.RemoveStorageServerConnection, new StorageServerConnectionParametersBase(connection, hostId), null, this);
}
#method_after
private void cleanConnection(StorageServerConnections connection, Guid hostId) {
    // then the id of connection will be empty, and there's nothing to delete.
    if (connection.getid() != null && !connection.getid().equals("")) {
        // $NON-NLS-1$
        Frontend.RunAction(VdcActionType.RemoveStorageServerConnection, new StorageServerConnectionParametersBase(connection, hostId), null, this);
    }
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToRemoveTheStorageDomainMsg());
    model.getFormat().setIsAvailable(false);
    AsyncDataProvider.getHostListByStatus(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setIsAvailable(storage.getStorageDomainType() == StorageDomainType.ISO || storage.getStorageDomainType() == StorageDomainType.ImportExport);
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = new UICommand("Cancel", storageListModel);
                tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
                tempVar.setIsDefault(true);
                tempVar.setIsCancel(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = new UICommand("OnRemove", storageListModel);
                command.setTitle(ConstantsManager.getInstance().getConstants().ok());
                command.setIsDefault(true);
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = new UICommand("Cancel", storageListModel);
                command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
                command.setIsCancel(true);
                removeStorageModel.getCommands().add(command);
            }
        }
    }), VDSStatus.Up);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToRemoveTheStorageDomainMsg());
    model.getFormat().setIsAvailable(false);
    AsyncDataProvider.getHostListByStatus(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setIsAvailable(storage.getStorageDomainType() == StorageDomainType.ISO || storage.getStorageDomainType() == StorageDomainType.ImportExport);
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), VDSStatus.Up);
}
#end_block

#method_before
private void destroy() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().destroyStorageDomainTitle());
    // $NON-NLS-1$
    model.setHashName("destroy_storage_domain");
    ArrayList<String> items = new ArrayList<String>();
    items.add(((StorageDomain) getSelectedItem()).getStorageName());
    model.setItems(items);
    model.getLatch().setIsAvailable(true);
    model.getLatch().setIsChangable(true);
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand("OnDestroy", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#method_after
private void destroy() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().destroyStorageDomainTitle());
    // $NON-NLS-1$
    model.setHashName("destroy_storage_domain");
    ArrayList<String> items = new ArrayList<String>();
    items.add(((StorageDomain) getSelectedItem()).getStorageName());
    model.setItems(items);
    model.getLatch().setIsAvailable(true);
    model.getLatch().setIsChangable(true);
    UICommand command;
    // $NON-NLS-1$
    command = createOKCommand("OnDestroy");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
private void forceCreationWarning(ArrayList<String> usedLunsMessages) {
    StorageModel storageModel = (StorageModel) getWindow();
    SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getSelectedItem();
    sanStorageModel.setForce(true);
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().forceStorageDomainCreation());
    model.setMessage(ConstantsManager.getInstance().getConstants().lunsAlreadyInUse());
    // $NON-NLS-1$
    model.setHashName("force_storage_domain_creation");
    model.setItems(usedLunsMessages);
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand("OnSaveSanStorage", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("CancelConfirm", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#method_after
private void forceCreationWarning(ArrayList<String> usedLunsMessages) {
    StorageModel storageModel = (StorageModel) getWindow();
    SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getSelectedItem();
    sanStorageModel.setForce(true);
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().forceStorageDomainCreation());
    model.setMessage(ConstantsManager.getInstance().getConstants().lunsAlreadyInUse());
    // $NON-NLS-1$
    model.setHashName("force_storage_domain_creation");
    model.setItems(usedLunsMessages);
    // $NON-NLS-1$
    UICommand command = createOKCommand("OnSaveSanStorage");
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("CancelConfirm");
    model.getCommands().add(command);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        StorageDomain storage = (StorageDomain) getSelectedItem();
        boolean isBackupStorage = storage.getStorageDomainType() == StorageDomainType.ImportExport;
        boolean isDataStorage = storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master;
        boolean isIsoStorage = storage.getStorageDomainType() == StorageDomainType.ISO;
        vmBackupModel.setIsAvailable(isBackupStorage);
        templateBackupModel.setIsAvailable(isBackupStorage);
        vmListModel.setIsAvailable(isDataStorage);
        templateListModel.setIsAvailable(isDataStorage);
        diskListModel.setIsAvailable(isDataStorage);
        isoListModel.setIsAvailable(isIsoStorage);
    }
}
#method_after
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        StorageDomain storage = (StorageDomain) getSelectedItem();
        boolean isBackupStorage = storage.getStorageDomainType() == StorageDomainType.ImportExport;
        boolean isDataStorage = storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master;
        boolean isImageStorage = storage.getStorageDomainType() == StorageDomainType.Image || storage.getStorageDomainType() == StorageDomainType.ISO;
        boolean isDataCenterAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isGeneralAvailable = storage.getStorageType() != StorageType.GLANCE;
        generalModel.setIsAvailable(isGeneralAvailable);
        dcListModel.setIsAvailable(isDataCenterAvailable);
        vmBackupModel.setIsAvailable(isBackupStorage);
        templateBackupModel.setIsAvailable(isBackupStorage);
        vmListModel.setIsAvailable(isDataStorage);
        templateListModel.setIsAvailable(isDataStorage);
        diskListModel.setIsAvailable(isDataStorage);
        isoListModel.setIsAvailable(isImageStorage);
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<StorageDomain> items = getSelectedItems() != null ? Linq.<StorageDomain>cast(getSelectedItems()) : new ArrayList<StorageDomain>();
    StorageDomain item = (StorageDomain) getSelectedItem();
    getNewDomainCommand().setIsAvailable(true);
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && isEditAvailable(item));
    getRemoveCommand().setIsExecutionAllowed(items.size() == 1 && Linq.findAllStorageDomainsBySharedStatus(items, StorageDomainSharedStatus.Unattached).size() == items.size());
    getDestroyCommand().setIsExecutionAllowed(item != null && items.size() == 1 && item.getStatus() != StorageDomainStatus.Active);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage);
    getNewDomainCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    ArrayList<StorageDomain> items = getSelectedItems() != null ? Linq.<StorageDomain>cast(getSelectedItems()) : new ArrayList<StorageDomain>();
    StorageDomain item = (StorageDomain) getSelectedItem();
    getNewDomainCommand().setIsAvailable(true);
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && isEditAvailable(item));
    getRemoveCommand().setIsExecutionAllowed(items.size() == 1 && items.get(0).getStorageType() != StorageType.GLANCE && Linq.findAllStorageDomainsBySharedStatus(items, StorageDomainSharedStatus.Unattached).size() == items.size());
    getDestroyCommand().setIsExecutionAllowed(item != null && items.size() == 1 && item.getStatus() != StorageDomainStatus.Active);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage);
    getNewDomainCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = (String) posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName((String) model.getName().getEntity());
    storageDomain.setDescription((String) model.getDescription().getEntity());
    storageDomain.setComment((String) model.getComment().getEntity());
    storageDomain.setStorageFormat((StorageFormatType) model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    String storageName = storages.get(0).getStorageName();
                    onFinish(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getMessages().createFailedDomainAlreadyExistStorageMsg(storageName));
                } else {
                    storageListModel.saveNewPosixStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            Frontend.RunAction(VdcActionType.UpdateStorageDomain, new StorageDomainManagementParameter(this.storageDomain), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    StorageListModel storageListModel = (StorageListModel) result.getState();
                    storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
                }
            }, this);
        }
    }
}
#method_after
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = (String) posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName((String) model.getName().getEntity());
    storageDomain.setDescription((String) model.getDescription().getEntity());
    storageDomain.setComment((String) model.getComment().getEntity());
    storageDomain.setStorageFormat((StorageFormatType) model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewPosixStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#end_block

#method_before
public void saveNewPosixStorage() {
    StorageModel model = (StorageModel) getWindow();
    PosixStorageModel posixModel = (PosixStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections connection = new StorageServerConnections();
    connection.setconnection(path);
    connection.setstorage_type(posixModel.getType());
    connection.setVfsType((String) posixModel.getVfsType().getEntity());
    connection.setMountOptions((String) posixModel.getMountOptions().getEntity());
    this.connection = connection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddPosixFsStorageDomain);
    parameters.add(new StorageServerConnectionParametersBase(this.connection, host.getId()));
    StorageDomainManagementParameter parameter = new StorageDomainManagementParameter(storageDomain);
    parameter.setVdsId(host.getId());
    parameters.add(parameter);
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
            storageListModel.connection.setid((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = (NGuid) vdcReturnValueBase.getActionReturnValue();
            // Attach storage to data center as necessary.
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            StoragePool dataCenter = (StoragePool) storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter((Guid) storageListModel.storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.RunMultipleActions(actionTypes, parameters, new ArrayList<IFrontendActionAsyncCallback>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#method_after
public void saveNewPosixStorage() {
    StorageModel model = (StorageModel) getWindow();
    PosixStorageModel posixModel = (PosixStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections connection = new StorageServerConnections();
    connection.setconnection(path);
    connection.setstorage_type(posixModel.getType());
    connection.setVfsType((String) posixModel.getVfsType().getEntity());
    connection.setMountOptions((String) posixModel.getMountOptions().getEntity());
    this.connection = connection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddPosixFsStorageDomain);
    parameters.add(new StorageServerConnectionParametersBase(this.connection, host.getId()));
    StorageDomainManagementParameter parameter = new StorageDomainManagementParameter(storageDomain);
    parameter.setVdsId(host.getId());
    parameters.add(parameter);
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
            storageListModel.connection.setid((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = (Guid) vdcReturnValueBase.getActionReturnValue();
            // Attach storage to data center as necessary.
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            StoragePool dataCenter = (StoragePool) storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.RunMultipleActions(actionTypes, parameters, new ArrayList<IFrontendActionAsyncCallback>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#end_block

#method_before
private void saveGlusterStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    GlusterStorageModel glusterModel = (GlusterStorageModel) storageModel;
    path = (String) glusterModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName((String) model.getName().getEntity());
    storageDomain.setStorageFormat((StorageFormatType) model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    String storageName = storages.get(0).getStorageName();
                    onFinish(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getMessages().createFailedDomainAlreadyExistStorageMsg(storageName));
                } else {
                    storageListModel.saveNewGlusterStorage();
                }
            }
        }), null, path);
    } else {
        Frontend.RunAction(VdcActionType.UpdateStorageDomain, new StorageDomainManagementParameter(storageDomain), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                StorageListModel storageListModel = (StorageListModel) result.getState();
                storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
            }
        }, this);
    }
}
#method_after
private void saveGlusterStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    GlusterStorageModel glusterModel = (GlusterStorageModel) storageModel;
    path = (String) glusterModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName((String) model.getName().getEntity());
    storageDomain.setStorageFormat((StorageFormatType) model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewGlusterStorage();
                }
            }
        }), null, path);
    } else {
        updateStorageDomain();
    }
}
#end_block

#method_before
public void saveNewGlusterStorage() {
    StorageModel model = (StorageModel) getWindow();
    GlusterStorageModel glusterModel = (GlusterStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections connection = new StorageServerConnections();
    connection.setconnection(path);
    connection.setstorage_type(glusterModel.getType());
    connection.setVfsType((String) glusterModel.getVfsType().getEntity());
    connection.setMountOptions((String) glusterModel.getMountOptions().getEntity());
    this.connection = connection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddGlusterFsStorageDomain);
    parameters.add(new StorageServerConnectionParametersBase(this.connection, host.getId()));
    StorageDomainManagementParameter parameter = new StorageDomainManagementParameter(storageDomain);
    parameter.setVdsId(host.getId());
    parameters.add(parameter);
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = (NGuid) vdcReturnValueBase.getActionReturnValue();
            // Attach storage to data center as necessary.
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            StoragePool dataCenter = (StoragePool) storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter((Guid) storageListModel.storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.RunMultipleActions(actionTypes, parameters, new ArrayList<IFrontendActionAsyncCallback>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#method_after
public void saveNewGlusterStorage() {
    StorageModel model = (StorageModel) getWindow();
    GlusterStorageModel glusterModel = (GlusterStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections connection = new StorageServerConnections();
    connection.setconnection(path);
    connection.setstorage_type(glusterModel.getType());
    connection.setVfsType((String) glusterModel.getVfsType().getEntity());
    connection.setMountOptions((String) glusterModel.getMountOptions().getEntity());
    this.connection = connection;
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddGlusterFsStorageDomain);
    parameters.add(new StorageServerConnectionParametersBase(this.connection, host.getId()));
    StorageDomainManagementParameter parameter = new StorageDomainManagementParameter(storageDomain);
    parameter.setVdsId(host.getId());
    parameters.add(parameter);
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = (Guid) vdcReturnValueBase.getActionReturnValue();
            // Attach storage to data center as necessary.
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            StoragePool dataCenter = (StoragePool) storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.RunMultipleActions(actionTypes, parameters, new ArrayList<IFrontendActionAsyncCallback>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2 })), failureCallback, this);
}
#end_block

#method_before
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = (String) nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName((String) model.getName().getEntity());
    storageDomain.setDescription((String) model.getDescription().getEntity());
    storageDomain.setComment((String) model.getComment().getEntity());
    storageDomain.setStorageFormat((StorageFormatType) model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    String storageName = storages.get(0).getStorageName();
                    onFinish(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getMessages().createFailedDomainAlreadyExistStorageMsg(storageName));
                } else {
                    storageListModel.saveNewNfsStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            Frontend.RunAction(VdcActionType.UpdateStorageDomain, new StorageDomainManagementParameter(this.storageDomain), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    StorageListModel storageListModel = (StorageListModel) result.getState();
                    storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
                }
            }, this);
        }
    }
}
#method_after
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = (String) nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName((String) model.getName().getEntity());
    storageDomain.setDescription((String) model.getDescription().getEntity());
    storageDomain.setComment((String) model.getComment().getEntity());
    storageDomain.setStorageFormat((StorageFormatType) model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewNfsStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#end_block

#method_before
public void saveNewNfsStorage() {
    StorageModel model = (StorageModel) getWindow();
    NfsStorageModel nfsModel = (NfsStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections tempVar = new StorageServerConnections();
    tempVar.setconnection(path);
    tempVar.setstorage_type(nfsModel.getType());
    if ((Boolean) nfsModel.getOverride().getEntity()) {
        tempVar.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
        tempVar.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
        tempVar.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
    }
    connection = tempVar;
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddNFSStorageDomain);
    actionTypes.add(VdcActionType.DisconnectStorageServerConnection);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    StorageDomainManagementParameter tempVar2 = new StorageDomainManagementParameter(storageDomain);
    tempVar2.setVdsId(host.getId());
    parameters.add(tempVar2);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
            storageListModel.connection.setid((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = (NGuid) vdcReturnValueBase.getActionReturnValue();
        }
    };
    IFrontendActionAsyncCallback callback3 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            // Attach storage to data center as necessary.
            StoragePool dataCenter = (StoragePool) storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter((Guid) storageListModel.storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.RunMultipleActions(actionTypes, parameters, new ArrayList<IFrontendActionAsyncCallback>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2, callback3 })), failureCallback, this);
}
#method_after
public void saveNewNfsStorage() {
    StorageModel model = (StorageModel) getWindow();
    NfsStorageModel nfsModel = (NfsStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections tempVar = new StorageServerConnections();
    tempVar.setconnection(path);
    tempVar.setstorage_type(nfsModel.getType());
    if ((Boolean) nfsModel.getOverride().getEntity()) {
        tempVar.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
        tempVar.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
        tempVar.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
    }
    connection = tempVar;
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddNFSStorageDomain);
    actionTypes.add(VdcActionType.DisconnectStorageServerConnection);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    StorageDomainManagementParameter tempVar2 = new StorageDomainManagementParameter(storageDomain);
    tempVar2.setVdsId(host.getId());
    parameters.add(tempVar2);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
            storageListModel.connection.setid((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            storageListModel.storageId = (Guid) vdcReturnValueBase.getActionReturnValue();
        }
    };
    IFrontendActionAsyncCallback callback3 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            // Attach storage to data center as necessary.
            StoragePool dataCenter = (StoragePool) storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                storageListModel.attachStorageToDataCenter(storageListModel.storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.cleanConnection(storageListModel.connection, storageListModel.hostId);
            storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
        }
    };
    Frontend.RunMultipleActions(actionTypes, parameters, new ArrayList<IFrontendActionAsyncCallback>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2, callback3 })), failureCallback, this);
}
#end_block

#method_before
public void saveNewSanStorage() {
    StorageModel model = (StorageModel) getWindow();
    SanStorageModel sanModel = (SanStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    boolean force = sanModel.isForce();
    ArrayList<String> lunIds = new ArrayList<String>();
    for (LunModel lun : sanModel.getAddedLuns()) {
        lunIds.add(lun.getLunId());
    }
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(storageDomain);
    params.setVdsId(host.getId());
    params.setLunIds(lunIds);
    params.setForce(force);
    Frontend.RunAction(VdcActionType.AddSANStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            storageListModel.storageModel = storageModel.getSelectedItem();
            if (!result.getReturnValue().getSucceeded()) {
                storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
                return;
            }
            StoragePool dataCenter = (StoragePool) storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                VdcReturnValueBase returnValue = result.getReturnValue();
                NGuid storageId = (NGuid) returnValue.getActionReturnValue();
                storageListModel.attachStorageToDataCenter((Guid) storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    }, this);
}
#method_after
public void saveNewSanStorage() {
    StorageModel model = (StorageModel) getWindow();
    SanStorageModel sanModel = (SanStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    boolean force = sanModel.isForce();
    ArrayList<String> lunIds = new ArrayList<String>();
    for (LunModel lun : sanModel.getAddedLuns()) {
        lunIds.add(lun.getLunId());
    }
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(storageDomain);
    params.setVdsId(host.getId());
    params.setLunIds(lunIds);
    params.setForce(force);
    Frontend.RunAction(VdcActionType.AddSANStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            storageListModel.storageModel = storageModel.getSelectedItem();
            if (!result.getReturnValue().getSucceeded()) {
                storageListModel.onFinish(storageListModel.context, false, storageListModel.storageModel);
                return;
            }
            StoragePool dataCenter = (StoragePool) storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                VdcReturnValueBase returnValue = result.getReturnValue();
                Guid storageId = (Guid) returnValue.getActionReturnValue();
                storageListModel.attachStorageToDataCenter(storageId, dataCenter.getId());
            }
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    }, this);
}
#end_block

#method_before
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = (VDS) model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = (String) localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName((String) model.getName().getEntity());
    storageDomain.setDescription((String) model.getDescription().getEntity());
    storageDomain.setComment((String) model.getComment().getEntity());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    String storageName = storages.get(0).getStorageName();
                    onFinish(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getMessages().createFailedDomainAlreadyExistStorageMsg(storageName));
                } else {
                    storageListModel.saveNewLocalStorage();
                }
            }
        }), host.getStoragePoolId(), path);
    } else {
        Frontend.RunAction(VdcActionType.UpdateStorageDomain, new StorageDomainManagementParameter(storageDomain), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                StorageListModel storageListModel = (StorageListModel) result.getState();
                storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
            }
        }, this);
    }
}
#method_after
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = (StorageDomain) getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = (VDS) model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = (String) localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName((String) model.getName().getEntity());
    storageDomain.setDescription((String) model.getDescription().getEntity());
    storageDomain.setComment((String) model.getComment().getEntity());
    if (isNew) {
        AsyncDataProvider.getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewLocalStorage();
                }
            }
        }), host.getStoragePoolId(), path);
    } else {
        StorageDomain storageDomain = (StorageDomain) getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        } else {
            updateStorageDomain();
        }
    }
}
#end_block

#method_before
public void importFileStorageAddDomain(ArrayList<StorageDomain> domains) {
    StorageDomain sdToAdd = Linq.firstOrDefault(domains);
    StorageDomainStatic sdsToAdd = sdToAdd == null ? null : sdToAdd.getStorageStaticData();
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.RunAction(VdcActionType.AddExistingFileStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            Object[] array = (Object[]) result.getState();
            StorageListModel storageListModel = (StorageListModel) array[0];
            StorageDomain sdToAdd1 = (StorageDomain) array[1];
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) storageListModel.getWindow();
                StoragePool dataCenter = (StoragePool) model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId());
                }
                postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
            } else {
                // $NON-NLS-1$
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
            }
        }
    }, new Object[] { this, sdToAdd });
}
#method_after
public void importFileStorageAddDomain(ArrayList<StorageDomain> domains) {
    StorageDomain sdToAdd = Linq.firstOrDefault(domains);
    StorageDomainStatic sdsToAdd = sdToAdd.getStorageStaticData();
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.RunAction(VdcActionType.AddExistingFileStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            Object[] array = (Object[]) result.getState();
            StorageListModel storageListModel = (StorageListModel) array[0];
            StorageDomain sdToAdd1 = (StorageDomain) array[1];
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) storageListModel.getWindow();
                StoragePool dataCenter = (StoragePool) model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId());
                }
                postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
            } else {
                // $NON-NLS-1$
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
            }
        }
    }, new Object[] { this, sdToAdd });
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "rawtypes" })
void initListBoxEditors() {
    datacenterListEditor = new ListModelListBoxEditor<Object>(new AbstractRenderer<Object>() {

        @Override
        public String render(Object object) {
            // $NON-NLS-1$
            String formattedString = "";
            if (object != null) {
                StoragePool storage = (StoragePool) object;
                // Get formatted storage type and format using Enum renders
                String storageType = // $NON-NLS-1$
                storage.getstorage_pool_type() == StorageType.UNKNOWN ? // $NON-NLS-1$
                "" : (new EnumRenderer<StorageType>()).render(storage.getstorage_pool_type());
                String storageFormatType = // $NON-NLS-1$
                storage.getStoragePoolFormatType() == null ? // $NON-NLS-1$
                "" : (new EnumRenderer<StorageFormatType>()).render(storage.getStoragePoolFormatType());
                // Add storage type and format if available
                if (storageType.length() > 0) {
                    // $NON-NLS-1$
                    formattedString = " (" + storageType;
                    if (storageFormatType.length() > 0) {
                        // $NON-NLS-1$
                        formattedString += ", " + storageFormatType;
                    }
                    // $NON-NLS-1$
                    formattedString += ")";
                }
                formattedString = storage.getname() + formattedString;
            }
            return formattedString;
        }
    });
    formatListEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    hostListEditor = new ListModelListBoxEditor<Object>(new AbstractRenderer<Object>() {

        @Override
        public String render(Object object) {
            // $NON-NLS-1$
            return object == null ? "" : ((VDS) object).getName();
        }
    });
    storageTypeListEditor = new ListModelListBoxEditor<Object>(new AbstractRenderer<Object>() {

        @Override
        public String render(Object object) {
            // $NON-NLS-1$
            String formattedString = "";
            if (object != null) {
                EnumRenderer<StorageType> storageEnumRenderer = new EnumRenderer<StorageType>();
                EnumRenderer<StorageDomainType> storageDomainEnumRenderer = new EnumRenderer<StorageDomainType>();
                String storageDomainType = storageDomainEnumRenderer.render(((IStorageModel) object).getRole());
                String storageType = storageEnumRenderer.render(((IStorageModel) object).getType());
                // $NON-NLS-1$
                formattedString = storageDomainType + " / " + storageType;
            }
            return formattedString;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "rawtypes" })
void initListBoxEditors() {
    datacenterListEditor = new ListModelListBoxEditor<Object>(new AbstractRenderer<Object>() {

        @Override
        public String render(Object object) {
            // $NON-NLS-1$
            String formattedString = "";
            if (object != null) {
                StoragePool storage = (StoragePool) object;
                // Get formatted storage type and format using Enum renders
                String storageType = // $NON-NLS-1$
                storage.getStorageType() == StorageType.UNKNOWN ? // $NON-NLS-1$
                "" : (new EnumRenderer<StorageType>()).render(storage.getStorageType());
                String storageFormatType = // $NON-NLS-1$
                storage.getStoragePoolFormatType() == null ? // $NON-NLS-1$
                "" : (new EnumRenderer<StorageFormatType>()).render(storage.getStoragePoolFormatType());
                // Add storage type and format if available
                if (storageType.length() > 0) {
                    // $NON-NLS-1$
                    formattedString = " (" + storageType;
                    if (storageFormatType.length() > 0) {
                        // $NON-NLS-1$
                        formattedString += ", " + storageFormatType;
                    }
                    // $NON-NLS-1$
                    formattedString += ")";
                }
                formattedString = storage.getName() + formattedString;
            }
            return formattedString;
        }
    });
    formatListEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    hostListEditor = new ListModelListBoxEditor<Object>(new AbstractRenderer<Object>() {

        @Override
        public String render(Object object) {
            // $NON-NLS-1$
            return object == null ? "" : ((VDS) object).getName();
        }
    });
    storageTypeListEditor = new ListModelListBoxEditor<Object>(new AbstractRenderer<Object>() {

        @Override
        public String render(Object object) {
            // $NON-NLS-1$
            String formattedString = "";
            if (object != null) {
                EnumRenderer<StorageType> storageEnumRenderer = new EnumRenderer<StorageType>();
                EnumRenderer<StorageDomainType> storageDomainEnumRenderer = new EnumRenderer<StorageDomainType>();
                String storageDomainType = storageDomainEnumRenderer.render(((IStorageModel) object).getRole());
                String storageType = storageEnumRenderer.render(((IStorageModel) object).getType());
                // $NON-NLS-1$
                formattedString = storageDomainType + " / " + storageType;
            }
            return formattedString;
        }
    });
}
#end_block

#method_before
public NGuid getStoragePoolId() {
    return getStoragePoolIsoMapData().getstorage_pool_id();
}
#method_after
public Guid getStoragePoolId() {
    return getStoragePoolIsoMapData().getstorage_pool_id();
}
#end_block

#method_before
public void setStoragePoolId(NGuid storagePoolId) {
    getStoragePoolIsoMapData().setstorage_pool_id(storagePoolId);
}
#method_after
public void setStoragePoolId(Guid storagePoolId) {
    getStoragePoolIsoMapData().setstorage_pool_id(storagePoolId);
}
#end_block

#method_before
@Mapping(from = StorageDomain.class, to = StorageServerConnections.class)
public static StorageServerConnections map(StorageDomain model, StorageServerConnections template) {
    StorageServerConnections entity = template != null ? template : new StorageServerConnections();
    if (model.isSetStorage() && model.getStorage().isSetType()) {
        Storage storage = model.getStorage();
        StorageType storageType = StorageType.fromValue(storage.getType());
        if (storageType != null) {
            entity.setstorage_type(map(storageType, null));
            switch(storageType) {
                case ISCSI:
                    break;
                case FCP:
                    break;
                case NFS:
                    if (storage.isSetAddress() && storage.isSetPath()) {
                        entity.setconnection(storage.getAddress() + ":" + storage.getPath());
                    }
                    if (storage.getNfsRetrans() != null) {
                        entity.setNfsRetrans(storage.getNfsRetrans().shortValue());
                    }
                    if (storage.getNfsTimeo() != null) {
                        entity.setNfsTimeo(storage.getNfsTimeo().shortValue());
                    }
                    if (storage.getNfsVersion() != null) {
                        NfsVersion nfsVersion = NfsVersion.fromValue(storage.getNfsVersion());
                        if (nfsVersion != null) {
                            entity.setNfsVersion(map(nfsVersion, null));
                        }
                    }
                    break;
                case LOCALFS:
                    if (storage.isSetPath()) {
                        entity.setconnection(storage.getPath());
                    }
                    break;
                case POSIXFS:
                case GLUSTERFS:
                    if (storage.isSetAddress() && storage.isSetPath()) {
                        entity.setconnection(storage.getAddress() + ":" + storage.getPath());
                    } else if (storage.isSetPath()) {
                        entity.setconnection(storage.getPath());
                    }
                    if (storage.isSetMountOptions()) {
                        entity.setMountOptions(storage.getMountOptions());
                    }
                    if (storage.isSetVfsType()) {
                        entity.setVfsType(storage.getVfsType());
                    }
                default:
                    break;
            }
        }
    }
    return entity;
}
#method_after
@Mapping(from = StorageDomain.class, to = StorageServerConnections.class)
public static StorageServerConnections map(StorageDomain model, StorageServerConnections template) {
    StorageServerConnections entity = template != null ? template : new StorageServerConnections();
    if (model.isSetStorage() && model.getStorage().isSetType()) {
        Storage storage = model.getStorage();
        StorageType storageType = StorageType.fromValue(storage.getType());
        if (storageType != null) {
            entity.setstorage_type(map(storageType, null));
            switch(storageType) {
                case ISCSI:
                    break;
                case FCP:
                    break;
                case GLANCE:
                    break;
                case NFS:
                    if (storage.isSetAddress() && storage.isSetPath()) {
                        entity.setconnection(storage.getAddress() + ":" + storage.getPath());
                    }
                    if (storage.getNfsRetrans() != null) {
                        entity.setNfsRetrans(storage.getNfsRetrans().shortValue());
                    }
                    if (storage.getNfsTimeo() != null) {
                        entity.setNfsTimeo(storage.getNfsTimeo().shortValue());
                    }
                    if (storage.getNfsVersion() != null) {
                        NfsVersion nfsVersion = NfsVersion.fromValue(storage.getNfsVersion());
                        if (nfsVersion != null) {
                            entity.setNfsVersion(map(nfsVersion, null));
                        }
                    }
                    break;
                case LOCALFS:
                    if (storage.isSetPath()) {
                        entity.setconnection(storage.getPath());
                    }
                    break;
                case POSIXFS:
                case GLUSTERFS:
                    if (storage.isSetAddress() && storage.isSetPath()) {
                        entity.setconnection(storage.getAddress() + ":" + storage.getPath());
                    } else if (storage.isSetPath()) {
                        entity.setconnection(storage.getPath());
                    }
                    if (storage.isSetMountOptions()) {
                        entity.setMountOptions(storage.getMountOptions());
                    }
                    if (storage.isSetVfsType()) {
                        entity.setVfsType(storage.getVfsType());
                    }
                default:
                    break;
            }
        }
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = StorageType.class, to = org.ovirt.engine.core.common.businessentities.StorageType.class)
public static org.ovirt.engine.core.common.businessentities.StorageType map(StorageType storageType, org.ovirt.engine.core.common.businessentities.StorageType template) {
    switch(storageType) {
        case ISCSI:
            return org.ovirt.engine.core.common.businessentities.StorageType.ISCSI;
        case FCP:
            return org.ovirt.engine.core.common.businessentities.StorageType.FCP;
        case NFS:
            return org.ovirt.engine.core.common.businessentities.StorageType.NFS;
        case LOCALFS:
            return org.ovirt.engine.core.common.businessentities.StorageType.LOCALFS;
        case POSIXFS:
            return org.ovirt.engine.core.common.businessentities.StorageType.POSIXFS;
        case GLUSTERFS:
            return org.ovirt.engine.core.common.businessentities.StorageType.GLUSTERFS;
        default:
            return null;
    }
}
#method_after
@Mapping(from = StorageType.class, to = org.ovirt.engine.core.common.businessentities.StorageType.class)
public static org.ovirt.engine.core.common.businessentities.StorageType map(StorageType storageType, org.ovirt.engine.core.common.businessentities.StorageType template) {
    switch(storageType) {
        case ISCSI:
            return org.ovirt.engine.core.common.businessentities.StorageType.ISCSI;
        case FCP:
            return org.ovirt.engine.core.common.businessentities.StorageType.FCP;
        case NFS:
            return org.ovirt.engine.core.common.businessentities.StorageType.NFS;
        case LOCALFS:
            return org.ovirt.engine.core.common.businessentities.StorageType.LOCALFS;
        case POSIXFS:
            return org.ovirt.engine.core.common.businessentities.StorageType.POSIXFS;
        case GLUSTERFS:
            return org.ovirt.engine.core.common.businessentities.StorageType.GLUSTERFS;
        case GLANCE:
            return org.ovirt.engine.core.common.businessentities.StorageType.GLANCE;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.StorageType storageType, String template) {
    switch(storageType) {
        case ISCSI:
            return StorageType.ISCSI.value();
        case FCP:
            return StorageType.FCP.value();
        case NFS:
            return StorageType.NFS.value();
        case LOCALFS:
            return StorageType.LOCALFS.value();
        case POSIXFS:
            return StorageType.POSIXFS.value();
        case GLUSTERFS:
            return StorageType.GLUSTERFS.value();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.StorageType storageType, String template) {
    switch(storageType) {
        case ISCSI:
            return StorageType.ISCSI.value();
        case FCP:
            return StorageType.FCP.value();
        case NFS:
            return StorageType.NFS.value();
        case LOCALFS:
            return StorageType.LOCALFS.value();
        case POSIXFS:
            return StorageType.POSIXFS.value();
        case GLUSTERFS:
            return StorageType.GLUSTERFS.value();
        case GLANCE:
            return StorageType.GLANCE.value();
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = StorageDomainType.class, to = org.ovirt.engine.core.common.businessentities.StorageDomainType.class)
public static org.ovirt.engine.core.common.businessentities.StorageDomainType map(StorageDomainType storageDomainType, org.ovirt.engine.core.common.businessentities.StorageDomainType template) {
    switch(storageDomainType) {
        case DATA:
            return org.ovirt.engine.core.common.businessentities.StorageDomainType.Data;
        case ISO:
            return org.ovirt.engine.core.common.businessentities.StorageDomainType.ISO;
        case EXPORT:
            return org.ovirt.engine.core.common.businessentities.StorageDomainType.ImportExport;
        default:
            return null;
    }
}
#method_after
@Mapping(from = StorageDomainType.class, to = org.ovirt.engine.core.common.businessentities.StorageDomainType.class)
public static org.ovirt.engine.core.common.businessentities.StorageDomainType map(StorageDomainType storageDomainType, org.ovirt.engine.core.common.businessentities.StorageDomainType template) {
    switch(storageDomainType) {
        case DATA:
            return org.ovirt.engine.core.common.businessentities.StorageDomainType.Data;
        case ISO:
            return org.ovirt.engine.core.common.businessentities.StorageDomainType.ISO;
        case EXPORT:
            return org.ovirt.engine.core.common.businessentities.StorageDomainType.ImportExport;
        case IMAGE:
            return org.ovirt.engine.core.common.businessentities.StorageDomainType.Image;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageDomainType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.StorageDomainType storageDomainType, String template) {
    switch(storageDomainType) {
        case Master:
            return StorageDomainType.DATA.value();
        case Data:
            return StorageDomainType.DATA.value();
        case ISO:
            return StorageDomainType.ISO.value();
        case ImportExport:
            return StorageDomainType.EXPORT.value();
        case Unknown:
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageDomainType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.StorageDomainType storageDomainType, String template) {
    switch(storageDomainType) {
        case Master:
            return StorageDomainType.DATA.value();
        case Data:
            return StorageDomainType.DATA.value();
        case ISO:
            return StorageDomainType.ISO.value();
        case ImportExport:
            return StorageDomainType.EXPORT.value();
        case Image:
            return StorageDomainType.IMAGE.value();
        case Unknown:
        default:
            return null;
    }
}
#end_block

#method_before
@Override
public List<Guid> getAllIds(Guid pool, StorageDomainStatus status) {
    MapSqlParameterSource parameterSource = getStoragePoolIdParameterSource(pool).addValue("status", status.getValue());
    RowMapper<Guid> mapper = new RowMapper<Guid>() {

        @Override
        public Guid mapRow(ResultSet rs, int rowNum) throws SQLException {
            return Guid.createGuidFromString(rs.getString("storage_id"));
        }
    };
    return getCallsHandler().executeReadList("GetStorageDomainIdsByStoragePoolIdAndStatus", mapper, parameterSource);
}
#method_after
@Override
public List<Guid> getAllIds(Guid pool, StorageDomainStatus status) {
    MapSqlParameterSource parameterSource = getStoragePoolIdParameterSource(pool).addValue("status", status.getValue());
    RowMapper<Guid> mapper = new RowMapper<Guid>() {

        @Override
        public Guid mapRow(ResultSet rs, int rowNum) throws SQLException {
            return getGuidDefaultEmpty(rs, "storage_id");
        }
    };
    return getCallsHandler().executeReadList("GetStorageDomainIdsByStoragePoolIdAndStatus", mapper, parameterSource);
}
#end_block

#method_before
@Override
public StorageDomainStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    StorageDomainStatic entity = new StorageDomainStatic();
    entity.setId(Guid.createGuidFromString(rs.getString("id")));
    entity.setStorage(rs.getString("storage"));
    entity.setStorageName(rs.getString("storage_name"));
    entity.setDescription(rs.getString("storage_description"));
    entity.setComment(rs.getString("storage_comment"));
    entity.setStorageType(StorageType.forValue(rs.getInt("storage_type")));
    entity.setStorageDomainType(StorageDomainType.forValue(rs.getInt("storage_domain_type")));
    entity.setStorageFormat(StorageFormatType.forValue(rs.getString("storage_domain_format_type")));
    entity.setLastTimeUsedAsMaster(rs.getLong("last_time_used_as_master"));
    return entity;
}
#method_after
@Override
public StorageDomainStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    StorageDomainStatic entity = new StorageDomainStatic();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setStorage(rs.getString("storage"));
    entity.setStorageName(rs.getString("storage_name"));
    entity.setDescription(rs.getString("storage_description"));
    entity.setComment(rs.getString("storage_comment"));
    entity.setStorageType(StorageType.forValue(rs.getInt("storage_type")));
    entity.setStorageDomainType(StorageDomainType.forValue(rs.getInt("storage_domain_type")));
    entity.setStorageFormat(StorageFormatType.forValue(rs.getString("storage_domain_format_type")));
    entity.setLastTimeUsedAsMaster(rs.getLong("last_time_used_as_master"));
    return entity;
}
#end_block

#method_before
@Override
public StorageDomain getForStoragePool(Guid id, NGuid storagepool) {
    return getCallsHandler().executeRead("Getstorage_domains_By_id_and_by_storage_pool_id", StorageDomainRowMapper.instance, getCustomMapSqlParameterSource().addValue("id", id).addValue("storage_pool_id", storagepool));
}
#method_after
@Override
public StorageDomain getForStoragePool(Guid id, Guid storagepool) {
    return getCallsHandler().executeRead("Getstorage_domains_By_id_and_by_storage_pool_id", StorageDomainRowMapper.instance, getCustomMapSqlParameterSource().addValue("id", id).addValue("storage_pool_id", storagepool));
}
#end_block

#method_before
@Override
public StorageDomain mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final StorageDomain entity = new StorageDomain();
    entity.setId(Guid.createGuidFromString(rs.getString("id")));
    entity.setStorage(rs.getString("storage"));
    entity.setStorageName(rs.getString("storage_name"));
    entity.setDescription(rs.getString("storage_description"));
    entity.setComment(rs.getString("storage_comment"));
    entity.setStoragePoolId(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setStorageType(StorageType.forValue(rs.getInt("storage_type")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setStorageDomainType(StorageDomainType.forValue(rs.getInt("storage_domain_type")));
    entity.setStorageFormat(StorageFormatType.forValue(rs.getString("storage_domain_format_type")));
    entity.setAvailableDiskSize((Integer) rs.getObject("available_disk_size"));
    entity.setUsedDiskSize((Integer) rs.getObject("used_disk_size"));
    entity.setCommittedDiskSize(rs.getInt("commited_disk_size"));
    entity.setStatus(StorageDomainStatus.forValue(rs.getInt("status")));
    entity.setStorageDomainSharedStatus(StorageDomainSharedStatus.forValue(rs.getInt("storage_domain_shared_status")));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setLastTimeUsedAsMaster(rs.getLong("last_time_used_as_master"));
    return entity;
}
#method_after
@Override
public StorageDomain mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final StorageDomain entity = new StorageDomain();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setStorage(rs.getString("storage"));
    entity.setStorageName(rs.getString("storage_name"));
    entity.setDescription(rs.getString("storage_description"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setComment(rs.getString("storage_comment"));
    entity.setStorageType(StorageType.forValue(rs.getInt("storage_type")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setStorageDomainType(StorageDomainType.forValue(rs.getInt("storage_domain_type")));
    entity.setStorageFormat(StorageFormatType.forValue(rs.getString("storage_domain_format_type")));
    entity.setAvailableDiskSize((Integer) rs.getObject("available_disk_size"));
    entity.setUsedDiskSize((Integer) rs.getObject("used_disk_size"));
    entity.setCommittedDiskSize(rs.getInt("commited_disk_size"));
    entity.setStatus(StorageDomainStatus.forValue(rs.getInt("status")));
    entity.setStorageDomainSharedStatus(StorageDomainSharedStatus.forValue(rs.getInt("storage_domain_shared_status")));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setLastTimeUsedAsMaster(rs.getLong("last_time_used_as_master"));
    return entity;
}
#end_block

#method_before
private void initInfoIcon(ApplicationConstants constants) {
    consoleAddressInfoIcon = // $NON-NLS-1$
    new InfoIcon(applicationTemplates.italicText(constants.enableConsoleAddressOverrideHelpMessage()), resources);
    providerSearchInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.providerSearchInfo()), resources);
}
#method_after
private void initInfoIcon(ApplicationConstants constants) {
    consoleAddressInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.enableConsoleAddressOverrideHelpMessage()), // $NON-NLS-1$
    resources);
    providerSearchInfoIcon = new InfoIcon(applicationTemplates.italicText(constants.providerSearchInfo()), resources);
}
#end_block

#method_before
private void initEditors() {
    // List boxes
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((StoragePool) object).getName();
        }
    });
    clusterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDSGroup) object).getName();
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDS) object).getName();
        }
    });
    providersEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Provider) object).getName();
        }
    });
    pmVariantsEditor = new ListModelListBoxOnlyEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    pmTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    pmSecondaryTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    publicKeyEditor = new EntityModelTextAreaLabelEditor(true, true);
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
}
#method_after
private void initEditors() {
    // List boxes
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((StoragePool) object).getName();
        }
    });
    clusterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDSGroup) object).getName();
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDS) object).getName();
        }
    });
    providersEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Provider) object).getName();
        }
    });
    pmVariantsEditor = new ListModelListBoxOnlyEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    pmTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    pmSecondaryTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return (String) object;
        }
    });
    publicKeyEditor = new EntityModelTextAreaLabelEditor(true, true);
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    externalProviderEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Provider) object).getName();
        }
    });
    providerTypeEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    neutronAgentWidget = new NeutronAgentWidget(constants);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
}
#end_block

#method_before
void localize(ApplicationConstants constants) {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.hostPopupDataCenterLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    hostPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    providerSearchFilterLabel.setLabel(constants.hostPopupProviderSearchFilter());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    pmSecondaryConcurrentEditor.setLabel(constants.hostPopupPmConcurrent());
    testButton.setLabel(constants.hostPopupTestButtonLabel());
    upButton.setLabel(constants.hostPopupUpButtonLabel());
    downButton.setLabel(constants.hostPopupDownButtonLabel());
    sourceLabel.setText(constants.hostPopupSourceText());
    // Primary
    pmAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    // Secondary
    pmSecondaryAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmSecondaryUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmSecondaryPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmSecondaryTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmSecondaryPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSecondarySlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmSecondaryOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmSecondaryOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecondarySecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    consoleAddress.setLabel(constants.consoleAddress());
    consoleAddressLabel.setText(constants.enableConsoleAddressOverride());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
}
#method_after
void localize(ApplicationConstants constants) {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.hostPopupDataCenterLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    hostPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    providerSearchFilterLabel.setLabel(constants.hostPopupProviderSearchFilter());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    pmSecondaryConcurrentEditor.setLabel(constants.hostPopupPmConcurrent());
    testButton.setLabel(constants.hostPopupTestButtonLabel());
    upButton.setLabel(constants.hostPopupUpButtonLabel());
    downButton.setLabel(constants.hostPopupDownButtonLabel());
    sourceLabel.setText(constants.hostPopupSourceText());
    // Primary
    pmAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    // Secondary
    pmSecondaryAddressEditor.setLabel(constants.hostPopupPmAddressLabel());
    pmSecondaryUserNameEditor.setLabel(constants.hostPopupPmUserNameLabel());
    pmSecondaryPasswordEditor.setLabel(constants.hostPopupPmPasswordLabel());
    pmSecondaryTypeEditor.setLabel(constants.hostPopupPmTypeLabel());
    pmSecondaryPortEditor.setLabel(constants.hostPopupPmPortLabel());
    pmSecondarySlotEditor.setLabel(constants.hostPopupPmSlotLabel());
    pmSecondaryOptionsEditor.setLabel(constants.hostPopupPmOptionsLabel());
    pmSecondaryOptionsExplanationLabel.setText(constants.hostPopupPmOptionsExplanationLabel());
    pmSecondarySecureEditor.setLabel(constants.hostPopupPmSecureLabel());
    consoleAddress.setLabel(constants.consoleAddress());
    consoleAddressLabel.setText(constants.enableConsoleAddressOverride());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    externalProviderEditor.setLabel(constants.externalProviderLabel());
    providerTypeEditor.setLabel(constants.typeProvider());
    providerPluginTypeEditor.setLabel(constants.pluginType());
}
#end_block

#method_before
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    rbPassword.setValue(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            Object selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    // TODO: until we allow different username for authentication
    userNameEditor.setEnabled(false);
    externalProviderPanel.setVisible(object.showExternalProviderPanel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#method_after
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    rbPassword.setValue(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            Object selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    externalProviderPanel.setVisible(object.showExternalProviderPanel());
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    final NeutronAgentModel model = object.getNeutronAgentModel();
    neutronAgentWidget.edit(model);
    neutronAgentPanel.setVisible(model.getIsAvailable());
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).PropertyName)) {
                // $NON-NLS-1$
                neutronAgentPanel.setVisible(model.getIsAvailable());
            }
        }
    });
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new BaseI18NValidation() {

        @Override
        protected String composeRegex() {
            // $NON-NLS-1$
            return "^[-_\\.0-9a-zA-Z]*$";
        }

        @Override
        protected String composeMessage() {
            return ConstantsManager.getInstance().getConstants().hostNameValidationMsg();
        }
    } });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    getHostPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if ((Boolean) getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if ((Boolean) getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setIsGeneralTabValid(getName().getIsValid() && getHost().getIsValid() && getPort().getIsValid() && getCluster().getIsValid());
    setIsPowerManagementTabValid(getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    return getIsGeneralTabValid() && getIsPowerManagementTabValid() && getConsoleAddress().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new BaseI18NValidation() {

        @Override
        protected String composeRegex() {
            // $NON-NLS-1$
            return "^[-_\\.0-9a-zA-Z]*$";
        }

        @Override
        protected String composeMessage() {
            return ConstantsManager.getInstance().getConstants().hostNameValidationMsg();
        }
    } });
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    getHostPort().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, 65535) });
    if ((Boolean) getConsoleAddressEnabled().getEntity()) {
        getConsoleAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new HostAddressValidation() });
    } else {
        // the console address is ignored so can not be invalid
        getConsoleAddress().setIsValid(true);
    }
    getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if ((Boolean) getIsPm().getEntity()) {
        // If PM enabled primary fencing options must be specified, ensure that.
        validatePmModels(true);
        // if one of the related fields was filled.
        if (!isEntityModelEmpty(getPmSecondaryIp()) || !isEntityModelEmpty(getPmSecondaryUserName()) || !isEntityModelEmpty(getPmSecondaryPassword()) || !isEntityModelEmpty(getPmSecondaryPort()) || !isEntityModelEmpty(getPmSecondarySlot()) || !isEntityModelEmpty(getPmSecondaryOptions())) {
            getPmSecondaryIp().setIsValid(true);
            getPmSecondaryUserName().setIsValid(true);
            getPmSecondaryPassword().setIsValid(true);
            getPmSecondaryPort().setIsValid(true);
            getPmSecondarySlot().setIsValid(true);
            getPmSecondaryOptions().setIsValid(true);
            validatePmModels(false);
        }
    }
    setIsGeneralTabValid(getName().getIsValid() && getHost().getIsValid() && getPort().getIsValid() && getCluster().getIsValid());
    setIsPowerManagementTabValid(getManagementIp().getIsValid() && getPmUserName().getIsValid() && getPmPassword().getIsValid() && getPmType().getIsValid() && getPmPort().getIsValid() && getPmOptions().getIsValid() && getPmSecondaryIp().getIsValid() && getPmSecondaryUserName().getIsValid() && getPmSecondaryPassword().getIsValid() && getPmSecondaryType().getIsValid() && getPmSecondaryPort().getIsValid() && getPmSecondaryOptions().getIsValid());
    neutronAgentModel.validate();
    return getIsGeneralTabValid() && getIsPowerManagementTabValid() && getConsoleAddress().getIsValid() && neutronAgentModel.getIsValid();
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getHostPort().setIsChangable(false);
    getUserName().setEntity(vds.getSshUsername());
    getUserName().setIsChangable(false);
    setHostPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.PmOptionsStringToMap(vds.getPmOptions()).asMap());
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap().asMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                // $NON-NLS-1$
                getName().setInfo("Cannot edit Host's Name in this tree context");
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                // $NON-NLS-1$
                getCluster().setInfo("Cannot change Host's Cluster in tree context");
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    setHostPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    getPkSection().setIsChangable(false);
    getPkSection().setIsAvailable(false);
    // Use public key when edit or approve host
    setAuthenticationMethod(AuthenticationMethod.PublicKey);
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.PmOptionsStringToMap(vds.getPmOptions()).asMap());
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap().asMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                // $NON-NLS-1$
                getName().setInfo("Cannot edit Host's Name in this tree context");
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                // $NON-NLS-1$
                getCluster().setInfo("Cannot change Host's Cluster in tree context");
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
private void updateOptionsNonLocalFS() {
    if (hosts == null || allHosts == null || !isUpHostCheckCompleted()) {
        return;
    }
    if (getEntity() == null) {
        stopProgress();
        setWindow(null);
        return;
    }
    // Add host action.
    // $NON-NLS-1$
    UICommand addHostAction = new UICommand("AddHost", this);
    if (hosts.size() > 1) {
        hosts.remove(0);
    }
    if (hosts.isEmpty()) {
        addHostAction.setTitle(ClusterConfigureHostsAction);
        getCompulsoryActions().add(addHostAction);
    } else if (isAnyUpHostInCluster()) {
        addHostAction.setTitle(ClusterAddAnotherHostAction);
        getOptionalActions().add(addHostAction);
    }
    if (getEntity().getStoragePoolId() == null) {
        addHostAction.getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().theClusterIsntAttachedToADcClusterGuide());
        addHostAction.setIsExecutionAllowed(false);
        return;
    }
    ArrayList<VDS> availableHosts = new ArrayList<VDS>();
    for (VDS vds : allHosts) {
        if (!getEntity().getId().equals(vds.getVdsGroupId()) && (vds.getStatus() == VDSStatus.Maintenance || vds.getStatus() == VDSStatus.PendingApproval) && vds.getSupportedClusterVersionsSet().contains(getEntity().getcompatibility_version())) {
            availableHosts.add(vds);
        }
    }
    // Select host action.
    // $NON-NLS-1$
    UICommand selectHostAction = new UICommand("SelectHost", this);
    if (availableHosts.size() > 0) {
        if (hosts.isEmpty()) {
            selectHostAction.setTitle(SelectHostsAction);
            getCompulsoryActions().add(selectHostAction);
        } else if (isAnyUpHostInCluster()) {
            selectHostAction.setTitle(SelectHostsAction);
            getOptionalActions().add(selectHostAction);
        }
    }
    stopProgress();
}
#method_after
private void updateOptionsNonLocalFS() {
    if (hosts == null || allHosts == null || !isUpHostCheckCompleted()) {
        return;
    }
    if (getEntity() == null) {
        stopProgress();
        setWindow(null);
        return;
    }
    // Add host action.
    // $NON-NLS-1$
    UICommand addHostAction = new UICommand("AddHost", this);
    if (hosts.size() > 1) {
        hosts.remove(0);
    }
    if (hosts.isEmpty()) {
        addHostAction.setTitle(ClusterConfigureHostsAction);
        getCompulsoryActions().add(addHostAction);
    } else if (isAnyUpHostInCluster()) {
        addHostAction.setTitle(ClusterAddAnotherHostAction);
        getOptionalActions().add(addHostAction);
    }
    if (getEntity().getStoragePoolId() == null) {
        addHostAction.getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().theClusterIsntAttachedToADcClusterGuide());
        addHostAction.setIsExecutionAllowed(false);
        return;
    }
    ArrayList<VDS> availableHosts = new ArrayList<VDS>();
    for (VDS vds : allHosts) {
        if (!getEntity().getId().equals(vds.getVdsGroupId()) && (vds.getStatus() == VDSStatus.Maintenance || vds.getStatus() == VDSStatus.PendingApproval) && vds.getSupportedClusterVersionsSet() != null && vds.getSupportedClusterVersionsSet().contains(getEntity().getcompatibility_version())) {
            availableHosts.add(vds);
        }
    }
    // Select host action.
    // $NON-NLS-1$
    UICommand selectHostAction = new UICommand("SelectHost", this);
    if (availableHosts.size() > 0) {
        if (hosts.isEmpty()) {
            selectHostAction.setTitle(SelectHostsAction);
            getCompulsoryActions().add(selectHostAction);
        } else if (isAnyUpHostInCluster()) {
            selectHostAction.setTitle(SelectHostsAction);
            getOptionalActions().add(selectHostAction);
        }
    }
    stopProgress();
}
#end_block

#method_before
public static Object clone(Object instance) {
    if (instance instanceof VM) {
        return cloneVM((VM) instance);
    }
    if (instance instanceof VDS) {
        return cloneVDS((VDS) instance);
    }
    if (instance instanceof VDSGroup) {
        return cloneVDSGroup((VDSGroup) instance);
    }
    if (instance instanceof StoragePool) {
        return cloneStorage_pool((StoragePool) instance);
    }
    if (instance instanceof Network) {
        return cloneNetwork((Network) instance);
    }
    if (instance instanceof NetworkCluster) {
        return cloneNetworkCluster((NetworkCluster) instance);
    }
    if (instance instanceof ProviderNetwork) {
        return cloneProviderNetwork((ProviderNetwork) instance);
    }
    if (instance instanceof VmPool) {
        return cloneVmPool((VmPool) instance);
    }
    if (instance instanceof StorageDomainStatic) {
        return cloneStorageDomainStatic((StorageDomainStatic) instance);
    }
    if (instance instanceof VmTemplate) {
        return cloneVmTemplate((VmTemplate) instance);
    }
    if (instance instanceof VmNetworkInterface) {
        return cloneVmNetworkInterface((VmNetworkInterface) instance);
    }
    if (instance instanceof VdsNetworkInterface) {
        return cloneVdsNetworkInterface((VdsNetworkInterface) instance);
    }
    if (instance instanceof VmStatic) {
        return cloneVmStatic((VmStatic) instance);
    }
    if (instance instanceof Version) {
        return cloneVersion((Version) instance);
    }
    // Throw exception to determine development needs.
    throw new NotImplementedException();
}
#method_after
public static Object clone(Object instance) {
    if (instance instanceof VM) {
        return cloneVM((VM) instance);
    }
    if (instance instanceof VDS) {
        return cloneVDS((VDS) instance);
    }
    if (instance instanceof VDSGroup) {
        return cloneVDSGroup((VDSGroup) instance);
    }
    if (instance instanceof StoragePool) {
        return cloneStorage_pool((StoragePool) instance);
    }
    if (instance instanceof Network) {
        return cloneNetwork((Network) instance);
    }
    if (instance instanceof NetworkCluster) {
        return cloneNetworkCluster((NetworkCluster) instance);
    }
    if (instance instanceof ProviderNetwork) {
        return cloneProviderNetwork((ProviderNetwork) instance);
    }
    if (instance instanceof VmPool) {
        return cloneVmPool((VmPool) instance);
    }
    if (instance instanceof StorageDomainStatic) {
        return cloneStorageDomainStatic((StorageDomainStatic) instance);
    }
    if (instance instanceof VmTemplate) {
        return cloneVmTemplate((VmTemplate) instance);
    }
    if (instance instanceof VmNetworkInterface) {
        return cloneVmNetworkInterface((VmNetworkInterface) instance);
    }
    if (instance instanceof VdsNetworkInterface) {
        return cloneVdsNetworkInterface((VdsNetworkInterface) instance);
    }
    if (instance instanceof VmStatic) {
        return cloneVmStatic((VmStatic) instance);
    }
    if (instance instanceof Version) {
        return cloneVersion((Version) instance);
    }
    if (instance instanceof ClusterPolicy) {
        return cloneClusterPolicy((ClusterPolicy) instance);
    }
    // Throw exception to determine development needs.
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
protected void setAllowChangeHost(VDS vds) {
    if (vds.getStatus() != VDSStatus.InstallFailed) {
        getHost().setIsChangable(false);
        getPort().setIsChangable(false);
        getFetchSshFingerprint().setIsChangable(false);
    } else {
        getHost().setIsChangable(true);
        getPort().setIsChangable(true);
        getFetchSshFingerprint().setIsChangable(true);
    }
}
#method_after
@Override
protected void setAllowChangeHost(VDS vds) {
    if (vds.getStatus() != VDSStatus.InstallFailed) {
        getHost().setIsChangable(false);
        getPort().setIsChangable(false);
    } else {
        getHost().setIsChangable(true);
        getPort().setIsChangable(true);
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).getVdsType() == VDSType.oVirtNode));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    getApproveCommand().setIsAvailable(approveAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
}
#method_after
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).getVdsType() == VDSType.oVirtNode));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    getApproveCommand().setIsAvailable(approveAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit(false);
    } else if (command == getEditWithPMemphasisCommand()) {
        edit(true);
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getActivateCommand()) {
        activate();
    } else if (command == getMaintenanceCommand()) {
        maintenance();
    } else if (command == getApproveCommand()) {
        approve();
    } else if (command == getRestartCommand()) {
        restart();
    } else if (command == getStartCommand()) {
        start();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getManualFenceCommand()) {
        manualFence();
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getConfigureLocalStorageCommand()) {
        configureLocalStorage();
    } else if (command == getRefreshCapabilitiesCommand()) {
        refreshCapabilities();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnManualFence")) {
        onManualFence();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveFalse")) {
        onSaveFalse();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternalFromApprove")) {
        onSaveInternalFromApprove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternalNotFromApprove")) {
        onSaveInternalNotFromApprove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirm")) {
        cancelConfirm();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmFocusPM")) {
        cancelConfirmFocusPM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMaintenance")) {
        onMaintenance();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnApprove")) {
        onApprove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRestart")) {
        onRestart();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        onStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnConfigureLocalStorage")) {
        onConfigureLocalStorage();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit(false);
    } else if (command == getEditWithPMemphasisCommand()) {
        edit(true);
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSelectAsSpmCommand()) {
        selectAsSPM();
    } else if (command == getActivateCommand()) {
        activate();
    } else if (command == getMaintenanceCommand()) {
        maintenance();
    } else if (command == getApproveCommand()) {
        approve();
    } else if (command == getRestartCommand()) {
        restart();
    } else if (command == getStartCommand()) {
        start();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getManualFenceCommand()) {
        manualFence();
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getConfigureLocalStorageCommand()) {
        configureLocalStorage();
    } else if (command == getRefreshCapabilitiesCommand()) {
        refreshCapabilities();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnManualFence")) {
        onManualFence();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveFalse")) {
        onSaveFalse();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternalFromApprove")) {
        onSaveInternalFromApprove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternalNotFromApprove")) {
        onSaveInternalNotFromApprove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirm")) {
        cancelConfirm();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmFocusPM")) {
        cancelConfirmFocusPM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMaintenance")) {
        onMaintenance();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnApprove")) {
        onApprove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRestart")) {
        onRestart();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        onStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnConfigureLocalStorage")) {
        onConfigureLocalStorage();
    }
}
#end_block

#method_before
private void addStyles() {
    importGlusterConfigurationEditor.addContentWidgetStyleName(style.editorContentWidget());
    migrateOnErrorOption_NOEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_YESEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_HA_ONLYEditor.addContentWidgetStyleName(style.label());
    optimizationNoneEditor.setContentWidgetStyleName(style.fullWidth());
    optimizationForServerEditor.setContentWidgetStyleName(style.fullWidth());
    optimizationForDesktopEditor.setContentWidgetStyleName(style.fullWidth());
    optimizationCustomEditor.setContentWidgetStyleName(style.fullWidth());
    countThreadsAsCoresEditor.setContentWidgetStyleName(style.fullWidth());
    enableTrustedServiceEditor.setContentWidgetStyleName(style.fullWidth());
    overCommitTimeEditor.addContentWidgetStyleName(style.timeTextBoxEditorWidget());
}
#method_after
private void addStyles() {
    importGlusterConfigurationEditor.addContentWidgetStyleName(style.editorContentWidget());
    migrateOnErrorOption_NOEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_YESEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_HA_ONLYEditor.addContentWidgetStyleName(style.label());
    optimizationNoneEditor.setContentWidgetStyleName(style.fullWidth());
    optimizationForServerEditor.setContentWidgetStyleName(style.fullWidth());
    optimizationForDesktopEditor.setContentWidgetStyleName(style.fullWidth());
    optimizationCustomEditor.setContentWidgetStyleName(style.fullWidth());
    countThreadsAsCoresEditor.setContentWidgetStyleName(style.fullWidth());
    enableTrustedServiceEditor.setContentWidgetStyleName(style.fullWidth());
}
#end_block

#method_before
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    cPUEditor.setLabel(constants.clusterPopupCPULabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(constants.clusterPopupOptimizationNoneLabel());
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    schedulePolicyPanelTitle.setText(constants.clusterPolicySchedulePolicyPanelTitle());
    policyRadioButton_none.setText(constants.clusterPolicyNoneLabel());
    policyRadioButton_evenDist.setText(constants.clusterPolicyEvenDistLabel());
    policyRadioButton_powerSave.setText(constants.clusterPolicyPowSaveLabel());
    maxServiceLevelLabel.setText(constants.clusterPolicyMaxServiceLevelLabel());
    minServiceLevelLabel.setText(constants.clusterPolicyMinServiceLevelLabel());
    forTimeLabel.setText(constants.clusterPolicyForTimeLabel());
    minTimeLabel.setText(constants.clusterPolicyMinTimeLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
}
#method_after
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    cPUEditor.setLabel(constants.clusterPopupCPULabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(constants.clusterPopupOptimizationNoneLabel());
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
}
#end_block

#method_before
private void initListBoxEditors() {
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((StoragePool) object).getName();
        }
    });
    cPUEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ServerCpu) object).getCpuName();
        }
    });
    versionEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Version) object).toString();
        }
    });
}
#method_after
private void initListBoxEditors() {
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((StoragePool) object).getName();
        }
    });
    cPUEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ServerCpu) object).getCpuName();
        }
    });
    versionEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Version) object).toString();
        }
    });
    clusterPolicyEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ClusterPolicy) object).getName();
        }
    });
}
#end_block

#method_before
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    if (object.getClusterPolicyModel().isEditClusterPolicyFirst()) {
        tabsPanel.switchTab(clusterPolicyTab);
    }
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible((Boolean) object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    setClusterPolicyModel(object.getClusterPolicyModel());
    object.getClusterPolicyModel().getOverCommitTime().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getClusterPolicyModel().getSelectionAlgorithm().equals(VdsSelectionAlgorithm.PowerSave)) {
                policyRadioButton_powerSave.setValue(true);
            } else if (getClusterPolicyModel().getSelectionAlgorithm().equals(VdsSelectionAlgorithm.EvenlyDistribute)) {
                policyRadioButton_evenDist.setValue(true);
            } else {
                policyRadioButton_none.setValue(true);
            }
            setSelectionAlgorithm();
        }
    });
}
#method_after
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    if (object.getClusterPolicyModel().isEditClusterPolicyFirst()) {
        tabsPanel.switchTab(clusterPolicyTab);
    }
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible((Boolean) object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    object.getCustomPropertySheet().getKeyValueLines().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
        }
    });
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDSGroup vdsGroup = (VDSGroup) getSelectedItem();
    getClusterVmListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
    getClusterServiceModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterVolumeServicesSupported(vdsGroup.getcompatibility_version()));
    getClusterGlusterHookListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterHookSupported(vdsGroup.getcompatibility_version()));
    getClusterPolicyModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDSGroup vdsGroup = (VDSGroup) getSelectedItem();
    getClusterVmListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
    getClusterServiceModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterVolumeServicesSupported(vdsGroup.getcompatibility_version()));
    getClusterGlusterHookListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterHookSupported(vdsGroup.getcompatibility_version()));
    getClusterPolicyModel().setIsAvailable(false);
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setName((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setStoragePoolId(((StoragePool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    cluster.setselection_algorithm(model.getClusterPolicyModel().getSelectionAlgorithm());
    cluster.setTrustedService((Boolean) model.getClusterPolicyModel().getEnableTrustedService().getEntity());
    if (model.getClusterPolicyModel().getOverCommitTime().getIsAvailable()) {
        cluster.setcpu_over_commit_duration_minutes(Integer.parseInt(model.getClusterPolicyModel().getOverCommitTime().getEntity().toString()));
    }
    cluster.setlow_utilization(model.getClusterPolicyModel().getOverCommitLowLevel());
    cluster.sethigh_utilization(model.getClusterPolicyModel().getOverCommitHighLevel());
    model.startProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setName((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setStoragePoolId(((StoragePool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    cluster.setselection_algorithm(model.getClusterPolicyModel().getSelectionAlgorithm());
    cluster.setTrustedService((Boolean) model.getClusterPolicyModel().getEnableTrustedService().getEntity());
    if (model.getClusterPolicyModel().getOverCommitTime().getIsAvailable()) {
        cluster.setcpu_over_commit_duration_minutes(Integer.parseInt(model.getClusterPolicyModel().getOverCommitTime().getEntity().toString()));
    }
    cluster.setlow_utilization(model.getClusterPolicyModel().getOverCommitLowLevel());
    cluster.sethigh_utilization(model.getClusterPolicyModel().getOverCommitHighLevel());
    cluster.setClusterPolicyId(((ClusterPolicy) model.getClusterPolicy().getSelectedItem()).getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().getEntity()));
    model.startProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress(null);
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till than using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setVdsGroupId((Guid) hostsModel.getClusterModel().getClusterId());
        host.setpm_enabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(false);
        parameters.setRebootAfterInstallation(hostsModel.getClusterModel().getEnableOvirtService().getIsSelected());
        parametersList.add(parameters);
    }
    Frontend.RunMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllCanDoPassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllCanDoPassed = isAllCanDoPassed && returnValueBase.getCanDoAction();
                if (!isAllCanDoPassed) {
                    break;
                }
            }
            if (isAllCanDoPassed) {
                cancel();
            }
        }
    }, null);
}
#method_after
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress(null);
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till then using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setVdsGroupId((Guid) hostsModel.getClusterModel().getClusterId());
        host.setpm_enabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(false);
        parameters.setRebootAfterInstallation(hostsModel.getClusterModel().getEnableOvirtService().getIsSelected());
        parametersList.add(parameters);
    }
    Frontend.RunMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllCanDoPassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllCanDoPassed = isAllCanDoPassed && returnValueBase.getCanDoAction();
                if (!isAllCanDoPassed) {
                    break;
                }
            }
            if (isAllCanDoPassed) {
                cancel();
            }
        }
    }, null);
}
#end_block

#method_before
public static Object clone(Object instance) {
    if (instance instanceof VM) {
        return cloneVM((VM) instance);
    }
    if (instance instanceof VDS) {
        return cloneVDS((VDS) instance);
    }
    if (instance instanceof VDSGroup) {
        return cloneVDSGroup((VDSGroup) instance);
    }
    if (instance instanceof StoragePool) {
        return cloneStorage_pool((StoragePool) instance);
    }
    if (instance instanceof Network) {
        return cloneNetwork((Network) instance);
    }
    if (instance instanceof NetworkCluster) {
        return cloneNetworkCluster((NetworkCluster) instance);
    }
    if (instance instanceof ProviderNetwork) {
        return cloneProviderNetwork((ProviderNetwork) instance);
    }
    if (instance instanceof VmPool) {
        return cloneVmPool((VmPool) instance);
    }
    if (instance instanceof StorageDomainStatic) {
        return cloneStorageDomainStatic((StorageDomainStatic) instance);
    }
    if (instance instanceof VmTemplate) {
        return cloneVmTemplate((VmTemplate) instance);
    }
    if (instance instanceof VmNetworkInterface) {
        return cloneVmNetworkInterface((VmNetworkInterface) instance);
    }
    if (instance instanceof VdsNetworkInterface) {
        return cloneVdsNetworkInterface((VdsNetworkInterface) instance);
    }
    if (instance instanceof VmStatic) {
        return cloneVmStatic((VmStatic) instance);
    }
    if (instance instanceof Version) {
        return cloneVersion((Version) instance);
    }
    // Throw exception to determine development needs.
    throw new NotImplementedException();
}
#method_after
public static Object clone(Object instance) {
    if (instance instanceof VM) {
        return cloneVM((VM) instance);
    }
    if (instance instanceof VDS) {
        return cloneVDS((VDS) instance);
    }
    if (instance instanceof VDSGroup) {
        return cloneVDSGroup((VDSGroup) instance);
    }
    if (instance instanceof StoragePool) {
        return cloneStorage_pool((StoragePool) instance);
    }
    if (instance instanceof Network) {
        return cloneNetwork((Network) instance);
    }
    if (instance instanceof NetworkCluster) {
        return cloneNetworkCluster((NetworkCluster) instance);
    }
    if (instance instanceof ProviderNetwork) {
        return cloneProviderNetwork((ProviderNetwork) instance);
    }
    if (instance instanceof VmPool) {
        return cloneVmPool((VmPool) instance);
    }
    if (instance instanceof StorageDomainStatic) {
        return cloneStorageDomainStatic((StorageDomainStatic) instance);
    }
    if (instance instanceof VmTemplate) {
        return cloneVmTemplate((VmTemplate) instance);
    }
    if (instance instanceof VmNetworkInterface) {
        return cloneVmNetworkInterface((VmNetworkInterface) instance);
    }
    if (instance instanceof VdsNetworkInterface) {
        return cloneVdsNetworkInterface((VdsNetworkInterface) instance);
    }
    if (instance instanceof VmStatic) {
        return cloneVmStatic((VmStatic) instance);
    }
    if (instance instanceof Version) {
        return cloneVersion((Version) instance);
    }
    if (instance instanceof ClusterPolicy) {
        return cloneClusterPolicy((ClusterPolicy) instance);
    }
    // Throw exception to determine development needs.
    throw new NotImplementedException();
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).getVdsType() == VDSType.oVirtNode));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    getApproveCommand().setIsAvailable(approveAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
}
#method_after
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).getVdsType() == VDSType.oVirtNode));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    getApproveCommand().setIsAvailable(approveAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit(false);
    } else if (command == getEditWithPMemphasisCommand()) {
        edit(true);
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getActivateCommand()) {
        activate();
    } else if (command == getMaintenanceCommand()) {
        maintenance();
    } else if (command == getApproveCommand()) {
        approve();
    } else if (command == getRestartCommand()) {
        restart();
    } else if (command == getStartCommand()) {
        start();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getManualFenceCommand()) {
        manualFence();
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getConfigureLocalStorageCommand()) {
        configureLocalStorage();
    } else if (command == getRefreshCapabilitiesCommand()) {
        refreshCapabilities();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnManualFence")) {
        onManualFence();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveFalse")) {
        onSaveFalse();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternalFromApprove")) {
        onSaveInternalFromApprove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternalNotFromApprove")) {
        onSaveInternalNotFromApprove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirm")) {
        cancelConfirm();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmFocusPM")) {
        cancelConfirmFocusPM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMaintenance")) {
        onMaintenance();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnApprove")) {
        onApprove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRestart")) {
        onRestart();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        onStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnConfigureLocalStorage")) {
        onConfigureLocalStorage();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit(false);
    } else if (command == getEditWithPMemphasisCommand()) {
        edit(true);
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSelectAsSpmCommand()) {
        selectAsSPM();
    } else if (command == getActivateCommand()) {
        activate();
    } else if (command == getMaintenanceCommand()) {
        maintenance();
    } else if (command == getApproveCommand()) {
        approve();
    } else if (command == getRestartCommand()) {
        restart();
    } else if (command == getStartCommand()) {
        start();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getManualFenceCommand()) {
        manualFence();
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getConfigureLocalStorageCommand()) {
        configureLocalStorage();
    } else if (command == getRefreshCapabilitiesCommand()) {
        refreshCapabilities();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnManualFence")) {
        onManualFence();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveFalse")) {
        onSaveFalse();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternalFromApprove")) {
        onSaveInternalFromApprove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternalNotFromApprove")) {
        onSaveInternalNotFromApprove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirm")) {
        cancelConfirm();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmFocusPM")) {
        cancelConfirmFocusPM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMaintenance")) {
        onMaintenance();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnApprove")) {
        onApprove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRestart")) {
        onRestart();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        onStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnConfigureLocalStorage")) {
        onConfigureLocalStorage();
    }
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDSGroup vdsGroup = (VDSGroup) getSelectedItem();
    getClusterVmListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
    getClusterServiceModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterVolumeServicesSupported(vdsGroup.getcompatibility_version()));
    getClusterGlusterHookListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterHookSupported(vdsGroup.getcompatibility_version()));
    getClusterPolicyModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDSGroup vdsGroup = (VDSGroup) getSelectedItem();
    getClusterVmListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
    getClusterServiceModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterVolumeServicesSupported(vdsGroup.getcompatibility_version()));
    getClusterGlusterHookListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterHookSupported(vdsGroup.getcompatibility_version()));
    getClusterPolicyModel().setIsAvailable(false);
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setName((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setStoragePoolId(((StoragePool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    cluster.setselection_algorithm(model.getClusterPolicyModel().getSelectionAlgorithm());
    cluster.setTrustedService((Boolean) model.getClusterPolicyModel().getEnableTrustedService().getEntity());
    if (model.getClusterPolicyModel().getOverCommitTime().getIsAvailable()) {
        cluster.setcpu_over_commit_duration_minutes(Integer.parseInt(model.getClusterPolicyModel().getOverCommitTime().getEntity().toString()));
    }
    cluster.setlow_utilization(model.getClusterPolicyModel().getOverCommitLowLevel());
    cluster.sethigh_utilization(model.getClusterPolicyModel().getOverCommitHighLevel());
    model.startProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setName((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setStoragePoolId(((StoragePool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    cluster.setselection_algorithm(model.getClusterPolicyModel().getSelectionAlgorithm());
    cluster.setTrustedService((Boolean) model.getClusterPolicyModel().getEnableTrustedService().getEntity());
    if (model.getClusterPolicyModel().getOverCommitTime().getIsAvailable()) {
        cluster.setcpu_over_commit_duration_minutes(Integer.parseInt(model.getClusterPolicyModel().getOverCommitTime().getEntity().toString()));
    }
    cluster.setlow_utilization(model.getClusterPolicyModel().getOverCommitLowLevel());
    cluster.sethigh_utilization(model.getClusterPolicyModel().getOverCommitHighLevel());
    cluster.setClusterPolicyId(((ClusterPolicy) model.getClusterPolicy().getSelectedItem()).getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().getEntity()));
    model.startProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
@Parameters
public static Collection<Object[]> data() {
    RandomUtils random = RandomUtils.instance();
    VdsStatic vdsStatic = new VdsStatic(random.nextString(10), random.nextString(10), random.nextString(10), random.nextInt(), random.nextInt(), random.nextString(10), Guid.newGuid(), Guid.newGuid(), random.nextString(10), random.nextBoolean(), random.nextEnum(VDSType.class));
    vdsStatic.setPmOptions("option1=value1,option2=value2");
    Object[][] data = new Object[][] { { vdsStatic }, { new VdsDynamic(random.nextInt(), random.nextInt(), random.nextString(10), random.nextDouble(), random.nextString(10), random.nextBoolean(), random.nextInt(), random.nextInt(), random.nextInt(), Guid.newGuid(), random.nextInt(), random.nextInt(), random.nextInt(), random.nextInt(), random.nextInt(), random.nextEnum(VDSStatus.class), random.nextNumericString(5) + "." + random.nextNumericString(5), random.nextString(10), random.nextString(10), new Date(random.nextLong()), random.nextInt(), random.nextInt(), random.nextBoolean(), random.nextString(10), random.nextString(10), random.nextString(10), random.nextString(10), random.nextString(10), random.nextString(10), new HashMap<String, List<Map<String, String>>>()) }, { new VdsStatistics(random.nextDouble(), random.nextDouble(), random.nextDouble(), random.nextDouble(), random.nextLong(), random.nextLong(), random.nextInt(), random.nextInt(), random.nextInt(), Guid.newGuid()) }, { new vds_spm_id_map(Guid.newGuid(), Guid.newGuid(), random.nextInt()) }, { new StorageDomainStatic(Guid.newGuid(), random.nextString(10), random.nextInt(StorageDomainType.values().length), random.nextString(10), random.nextString(10)) }, { new StorageDomainDynamic(random.nextInt(), Guid.newGuid(), random.nextInt()) }, { new StoragePool(random.nextString(10), "", Guid.newGuid(), random.nextString(10), random.nextEnum(StorageType.class).getValue(), random.nextInt(StoragePoolStatus.values().length)) }, { new StoragePoolIsoMap(Guid.newGuid(), Guid.newGuid(), random.nextEnum(StorageDomainStatus.class)) }, { new Role(random.nextString(10), Guid.newGuid(), random.nextString(10)) }, { new IdContainerClass<vds_spm_id_map>(new vds_spm_id_map(Guid.newGuid(), Guid.newGuid(), random.nextInt())) }, { new IdContainerClass<Guid>(Guid.newGuid()) } };
    return Arrays.asList(data);
}
#method_after
@Parameters
public static Collection<Object[]> data() {
    RandomUtils random = RandomUtils.instance();
    VdsStatic vdsStatic = new VdsStatic(random.nextString(10), random.nextString(10), random.nextString(10), random.nextInt(), random.nextInt(), random.nextString(10), Guid.newGuid(), Guid.newGuid(), random.nextString(10), random.nextBoolean(), random.nextEnum(VDSType.class));
    vdsStatic.setPmOptions("option1=value1,option2=value2");
    Object[][] data = new Object[][] { { vdsStatic }, { new VdsDynamic(random.nextInt(), random.nextInt(), random.nextString(10), random.nextDouble(), random.nextString(10), random.nextBoolean(), random.nextInt(), random.nextInt(), random.nextInt(), Guid.newGuid(), random.nextInt(), random.nextInt(), random.nextInt(), random.nextInt(), random.nextInt(), random.nextEnum(VDSStatus.class), random.nextNumericString(5) + "." + random.nextNumericString(5), random.nextString(10), random.nextString(10), new Date(random.nextLong()), random.nextInt(), random.nextInt(), random.nextBoolean(), random.nextString(10), random.nextString(10), random.nextString(10), random.nextString(10), random.nextString(10), random.nextString(10), new HashMap<String, List<Map<String, String>>>()) }, { new VdsStatistics(random.nextDouble(), random.nextDouble(), random.nextDouble(), random.nextDouble(), random.nextLong(), random.nextLong(), random.nextLong(), random.nextInt(), random.nextInt(), random.nextInt(), Guid.newGuid()) }, { new vds_spm_id_map(Guid.newGuid(), Guid.newGuid(), random.nextInt()) }, { new StorageDomainStatic(Guid.newGuid(), random.nextString(10), random.nextInt(StorageDomainType.values().length), random.nextString(10), random.nextString(10)) }, { new StorageDomainDynamic(random.nextInt(), Guid.newGuid(), random.nextInt()) }, { new StoragePool(random.nextString(10), "", Guid.newGuid(), random.nextString(10), random.nextEnum(StorageType.class).getValue(), random.nextInt(StoragePoolStatus.values().length)) }, { new StoragePoolIsoMap(Guid.newGuid(), Guid.newGuid(), random.nextEnum(StorageDomainStatus.class)) }, { new Role(random.nextString(10), Guid.newGuid(), random.nextString(10)) }, { new IdContainerClass<vds_spm_id_map>(new vds_spm_id_map(Guid.newGuid(), Guid.newGuid(), random.nextInt())) }, { new IdContainerClass<Guid>(Guid.newGuid()) } };
    return Arrays.asList(data);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // to prevent cases where low utilization > high utilization due to specific configuration defaults
    if (getVdsGroup().gethigh_utilization() == GET_CPU_THRESHOLDS_FROM_CONFIGURATION || getVdsGroup().getlow_utilization() == GET_CPU_THRESHOLDS_FROM_CONFIGURATION) {
        VdsSelectionAlgorithm selectionAlgorithm;
        try {
            selectionAlgorithm = VdsSelectionAlgorithm.valueOf(Config.<String>GetValue(ConfigValues.VdsSelectionAlgorithm));
        } catch (java.lang.Exception e) {
            selectionAlgorithm = VdsSelectionAlgorithm.None;
        }
        if (selectionAlgorithm == VdsSelectionAlgorithm.EvenlyDistribute) {
            getVdsGroup().sethigh_utilization(Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute));
            getVdsGroup().setlow_utilization(Config.<Integer>GetValue(ConfigValues.LowUtilizationForEvenlyDistribute));
        } else if (selectionAlgorithm == VdsSelectionAlgorithm.PowerSave) {
            getVdsGroup().sethigh_utilization(Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave));
            getVdsGroup().setlow_utilization(Config.<Integer>GetValue(ConfigValues.LowUtilizationForPowerSave));
        }
    }
    if (getVdsGroup().getcpu_over_commit_duration_minutes() == -1) {
        getVdsGroup().setcpu_over_commit_duration_minutes(Config.<Integer>GetValue(ConfigValues.CpuOverCommitDurationMinutes));
    }
    CheckMaxMemoryOverCommitValue();
    DbFacade.getInstance().getVdsGroupDao().save(getVdsGroup());
    // add default network
    if (getParameters().getVdsGroup().getStoragePoolId() != null) {
        final String networkName = NetworkUtils.getEngineNetwork();
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForDataCenter(getParameters().getVdsGroup().getStoragePoolId());
        Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getName().equals(networkName);
            }
        });
        if (net != null) {
            DbFacade.getInstance().getNetworkClusterDao().save(new NetworkCluster(getParameters().getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, false, true, false));
        }
    }
    setActionReturnValue(getVdsGroup().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    CheckMaxMemoryOverCommitValue();
    DbFacade.getInstance().getVdsGroupDao().save(getVdsGroup());
    // add default network
    if (getParameters().getVdsGroup().getStoragePoolId() != null) {
        final String networkName = NetworkUtils.getEngineNetwork();
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForDataCenter(getParameters().getVdsGroup().getStoragePoolId());
        Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getName().equals(networkName);
            }
        });
        if (net != null) {
            DbFacade.getInstance().getNetworkClusterDao().save(new NetworkCluster(getParameters().getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, false, true, false));
        }
    }
    setActionReturnValue(getVdsGroup().getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = super.canDoAction();
    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VAR__ACTION__CREATE.toString());
    if (DbFacade.getInstance().getVdsGroupDao().getByName(getVdsGroup().getName()) != null) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
        result = false;
    } else if (getVdsGroup().supportsVirtService() && !CpuFlagsManagerHandler.CheckIfCpusExist(getVdsGroup().getcpu_name(), getVdsGroup().getcompatibility_version())) {
        // cpu check required only if the cluster supports Virt service
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
        result = false;
    } else if (!VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    } else if (getVdsGroup().getStoragePoolId() != null) {
        setStoragePoolId(getVdsGroup().getStoragePoolId());
        if (getStoragePool() != null && getStoragePool().getcompatibility_version().compareTo(getVdsGroup().getcompatibility_version()) > 0) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_COMPATIBILITY_VERSION_WITH_LOWER_STORAGE_POOL.toString());
            result = false;
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(getVdsGroup().getStoragePoolId());
        // breaking Fk_vds_groups_storage_pool_id
        if (storagePool == null) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST.toString());
            result = false;
        } else if (storagePool.getStorageType() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!DbFacade.getInstance().getVdsGroupDao().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            }
        }
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessage(String.format("$compatibilityVersion %1$s", getVdsGroup().getcompatibility_version().getValue()));
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result) {
        result = validateClusterPolicy();
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = super.canDoAction();
    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VAR__ACTION__CREATE.toString());
    if (DbFacade.getInstance().getVdsGroupDao().getByName(getVdsGroup().getName()) != null) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
        result = false;
    } else if (getVdsGroup().supportsVirtService() && !CpuFlagsManagerHandler.CheckIfCpusExist(getVdsGroup().getcpu_name(), getVdsGroup().getcompatibility_version())) {
        // cpu check required only if the cluster supports Virt service
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
        result = false;
    } else if (!VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    } else if (getVdsGroup().getStoragePoolId() != null) {
        setStoragePoolId(getVdsGroup().getStoragePoolId());
        if (getStoragePool() != null && getStoragePool().getcompatibility_version().compareTo(getVdsGroup().getcompatibility_version()) > 0) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_COMPATIBILITY_VERSION_WITH_LOWER_STORAGE_POOL.toString());
            result = false;
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(getVdsGroup().getStoragePoolId());
        // breaking Fk_vds_groups_storage_pool_id
        if (storagePool == null) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST.toString());
            result = false;
        } else if (storagePool.getStorageType() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!DbFacade.getInstance().getVdsGroupDao().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            }
        }
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessage(String.format("$compatibilityVersion %1$s", getVdsGroup().getcompatibility_version().getValue()));
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result) {
        result = validateClusterPolicy();
    }
    return result;
}
#end_block

#method_before
protected boolean validateClusterPolicy() {
    ClusterPolicy clusterPolicy = SchedulingManager.getInstance().getClusterPolicy(getVdsGroup().getClusterPolicyId());
    List<ValidationError> validationErrors = SimpleCustomPropertiesUtil.getInstance().validateProperties(SchedulingManager.getInstance().getCustomPropertiesRegexMap(clusterPolicy), getVdsGroup().getClusterPolicyProperties());
    if (!validationErrors.isEmpty()) {
        SimpleCustomPropertiesUtil.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    return true;
}
#method_after
protected boolean validateClusterPolicy() {
    ClusterPolicy clusterPolicy = null;
    if (getVdsGroup().getClusterPolicyId() != null) {
        clusterPolicy = SchedulingManager.getInstance().getClusterPolicy(getVdsGroup().getClusterPolicyId());
    }
    if (clusterPolicy == null) {
        clusterPolicy = SchedulingManager.getInstance().getClusterPolicy(getVdsGroup().getClusterPolicyName());
        if (clusterPolicy == null) {
            return false;
        }
        getVdsGroup().setClusterPolicyId(clusterPolicy.getId());
    }
    updateClusterPolicyProperties(getVdsGroup(), clusterPolicy);
    List<ValidationError> validationErrors = SimpleCustomPropertiesUtil.getInstance().validateProperties(SchedulingManager.getInstance().getCustomPropertiesRegexMap(clusterPolicy), getVdsGroup().getClusterPolicyProperties());
    if (!validationErrors.isEmpty()) {
        SimpleCustomPropertiesUtil.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // check that if name was changed, it was done to the same cluster
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        VDSGroup groupWithName = getVdsGroupDAO().getByName(getVdsGroup().getName());
        if (groupWithName != null && !groupWithName.getId().equals(getVdsGroup().getId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    // decreasing of compatibility version is not allowed
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        result = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION.toString());
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allForVdsGroup.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            List<VM> vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            boolean sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult < 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_LOWER_CPU_LEVEL);
                        result = false;
                    } else if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.getStorageType() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            } else if (VDSGroup.DEFAULT_VDS_GROUP_ID.equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessage(String.format("$compatibilityVersion %1$s", getVdsGroup().getcompatibility_version().getValue()));
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result) {
        result = validateClusterPolicy();
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // check that if name was changed, it was done to the same cluster
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        VDSGroup groupWithName = getVdsGroupDAO().getByName(getVdsGroup().getName());
        if (groupWithName != null && !groupWithName.getId().equals(getVdsGroup().getId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    // decreasing of compatibility version is not allowed
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        result = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION.toString());
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allForVdsGroup.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            List<VM> vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            boolean sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult < 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_LOWER_CPU_LEVEL);
                        result = false;
                    } else if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.getStorageType() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (VDSGroup.DEFAULT_VDS_GROUP_ID.equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessage(String.format("$compatibilityVersion %1$s", getVdsGroup().getcompatibility_version().getValue()));
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result) {
        result = validateClusterPolicy();
    }
    return result;
}
#end_block

#method_before
@Override
protected void postSaveAction(Guid networkGuid, boolean succeeded) {
    super.postSaveAction(networkGuid, succeeded);
    if (!succeeded) {
        return;
    }
    Guid networkId = getNetwork().getId() == null ? networkGuid : getNetwork().getId();
    ArrayList<VdcActionParametersBase> actionParameters1 = new ArrayList<VdcActionParametersBase>();
    for (VDSGroup attachNetworkToCluster : getClustersToAttach()) {
        Network tempVar = new Network();
        tempVar.setId(networkId);
        tempVar.setName(getNetwork().getName());
        // Init default NetworkCluster values (required, display, status)
        NetworkCluster networkCluster = new NetworkCluster();
        networkCluster.setRequired((Boolean) getExport().getEntity());
        tempVar.setCluster(networkCluster);
        actionParameters1.add(new AttachNetworkToVdsGroupParameter(attachNetworkToCluster, tempVar));
    }
    Frontend.RunMultipleAction(VdcActionType.AttachNetworkToVdsGroup, actionParameters1);
}
#method_after
@Override
protected void postSaveAction(Guid networkGuid, boolean succeeded) {
    super.postSaveAction(networkGuid, succeeded);
    if (!succeeded) {
        return;
    }
    Guid networkId = getNetwork().getId() == null ? networkGuid : getNetwork().getId();
    ArrayList<VdcActionParametersBase> actionParameters1 = new ArrayList<VdcActionParametersBase>();
    for (VDSGroup attachNetworkToCluster : getClustersToAttach()) {
        Network tempVar = new Network();
        tempVar.setId(networkId);
        tempVar.setName(getNetwork().getName());
        // Init default NetworkCluster values (required, display, status)
        NetworkCluster networkCluster = new NetworkCluster();
        networkCluster.setRequired(!((Boolean) getExport().getEntity()));
        tempVar.setCluster(networkCluster);
        actionParameters1.add(new AttachNetworkToVdsGroupParameter(attachNetworkToCluster, tempVar));
    }
    Frontend.RunMultipleAction(VdcActionType.AttachNetworkToVdsGroup, actionParameters1);
}
#end_block

#method_before
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName((String) getName().getEntity());
    network.setStp((Boolean) getIsStpEnabled().getEntity());
    network.setDescription((String) getDescription().getEntity());
    network.setLabel((String) getNetworkLabel().getEntity());
    network.setVmNetwork((Boolean) getIsVmNetwork().getEntity());
    network.setMtu(0);
    if (getMtu().getEntity() != null) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setVlanId(null);
    if ((Boolean) getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
}
#method_after
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName((String) getName().getEntity());
    network.setStp((Boolean) getIsStpEnabled().getEntity());
    network.setDescription((String) getDescription().getEntity());
    network.setLabel((String) getNetworkLabel().getEntity());
    network.setVmNetwork((Boolean) getIsVmNetwork().getEntity());
    network.setMtu(0);
    if ((Boolean) getHasMtu().getEntity()) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setVlanId(null);
    if ((Boolean) getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
}
#end_block

#method_before
private void updateVlanTagChangeability() {
    getVLanTag().setIsChangable((Boolean) getHasVLanTag().getEntity());
}
#method_after
private void updateVlanTagChangeability() {
    getVLanTag().setIsChangable((Boolean) getHasVLanTag().getEntity() && !((Boolean) getExport().getEntity()));
}
#end_block

#method_before
private void updateMtuChangeability() {
    getMtu().setIsChangable((Boolean) getHasMtu().getEntity());
}
#method_after
private void updateMtuChangeability() {
    getMtu().setIsChangable((Boolean) getHasMtu().getEntity() && !((Boolean) getExport().getEntity()));
}
#end_block

#method_before
public void newNetwork() {
    if (getWindow() != null) {
        return;
    }
    final NetworkModel networkModel = new NewNetworkModel(this);
    setWindow(networkModel);
    networkModel.startProgress(null);
    initDcList(networkModel);
}
#method_after
public void newNetwork() {
    if (getWindow() != null) {
        return;
    }
    final NetworkModel networkModel = new NewNetworkModel(this);
    setWindow(networkModel);
    initDcList(networkModel);
}
#end_block

#method_before
public void edit() {
    final Network network = (Network) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final NetworkModel networkModel = new EditNetworkModel(network, this);
    setWindow(networkModel);
    networkModel.startProgress(null);
    initDcList(networkModel);
}
#method_after
public void edit() {
    final Network network = (Network) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final NetworkModel networkModel = new EditNetworkModel(network, this);
    setWindow(networkModel);
    initDcList(networkModel);
}
#end_block

#method_before
private void initDcList(final NetworkModel networkModel) {
    SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
    if (treeSelectedDc != null) {
        StoragePool dc = (StoragePool) treeSelectedDc.getEntity();
        networkModel.getDataCenters().setItems(Arrays.asList(dc));
        networkModel.getDataCenters().setSelectedItem(dc);
        networkModel.getDataCenters().setIsChangable(false);
        initExternalNetworksList(networkModel);
        return;
    }
    // Get all data centers
    AsyncDataProvider.getDataCenterList(new AsyncQuery(NetworkListModel.this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
            networkModel.getDataCenters().setItems(dataCenters);
            if (networkModel instanceof EditNetworkModel) {
                StoragePool currentDc = findDc(networkModel.getNetwork().getDataCenterId(), dataCenters);
                networkModel.getDataCenters().setSelectedItem(currentDc);
            } else {
                networkModel.getDataCenters().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            initExternalNetworksList(networkModel);
        }
    }));
}
#method_after
private void initDcList(final NetworkModel networkModel) {
    networkModel.startProgress(null);
    SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
    if (treeSelectedDc != null) {
        StoragePool dc = (StoragePool) treeSelectedDc.getEntity();
        networkModel.getDataCenters().setItems(Arrays.asList(dc));
        networkModel.getDataCenters().setSelectedItem(dc);
        networkModel.getDataCenters().setIsChangable(false);
        initExternalNetworksList(networkModel);
        return;
    }
    // Get all data centers
    AsyncDataProvider.getDataCenterList(new AsyncQuery(NetworkListModel.this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
            networkModel.getDataCenters().setItems(dataCenters);
            if (networkModel instanceof EditNetworkModel) {
                StoragePool currentDc = findDc(networkModel.getNetwork().getDataCenterId(), dataCenters);
                networkModel.getDataCenters().setSelectedItem(currentDc);
            } else {
                networkModel.getDataCenters().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            initExternalNetworksList(networkModel);
        }
    }));
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    List<String> serviceList = getParameters().getServiceList();
    String[] serviceNameList = new String[serviceList.size()];
    serviceList.toArray(serviceNameList);
    returnValue = getBroker().glusterServiceManage(getParameters().getVdsId(), serviceNameList, getParameters().getActionType());
    ProceedProxyReturnValue();
    if (getVDSReturnValue().getSucceeded()) {
        setReturnValue(returnValue.getServices());
    }
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    List<String> serviceList = getParameters().getServiceList();
    String[] serviceNameList = new String[serviceList.size()];
    serviceList.toArray(serviceNameList);
    returnValue = getBroker().glusterServicesAction(getParameters().getVdsId(), serviceNameList, getParameters().getActionType());
    ProceedProxyReturnValue();
    if (getVDSReturnValue().getSucceeded()) {
        setReturnValue(returnValue.getServices());
    }
}
#end_block

#method_before
@Override
protected String composeRegex() {
    return start() + hostnameOrIp() + end();
}
#method_after
@Override
protected String composeRegex() {
    return start() + (acceptEmptyInput ? hostnameOrIpOrEmpty() : hostnameOrIp()) + end();
}
#end_block

#method_before
protected void setComparator(Comparator comparator) {
    this.comparator = comparator;
    Iterable items = getItems();
    if (items == null) {
        return;
    }
    Iterable identicalItems = (comparator == null) ? new ArrayList() : new TreeSet(comparator);
    for (Object item : items) {
        setItems(identicalItems);
    }
}
#method_after
protected void setComparator(Comparator comparator) {
    if (comparator == this.comparator) {
        return;
    }
    this.comparator = comparator;
    Iterable items = getItems();
    if (items == null) {
        return;
    }
    Collection identicalItems = (comparator == null) ? new ArrayList() : new TreeSet(comparator);
    for (Object item : items) {
        identicalItems.add(item);
    }
    setItems(identicalItems);
}
#end_block

#method_before
@Override
public void setItems(Iterable value) {
    if (items != value) {
        IVdcQueryable lastSelectedItem = (IVdcQueryable) getSelectedItem();
        ArrayList<IVdcQueryable> lastSelectedItems = new ArrayList<IVdcQueryable>();
        if (getSelectedItems() != null) {
            for (Object item : getSelectedItems()) {
                lastSelectedItems.add((IVdcQueryable) item);
            }
        }
        if (comparator == null || value instanceof SortedSet) {
            itemsChanging(value, items);
            items = value;
        } else {
            TreeSet sortedValue = null;
            if (value != null) {
                sortedValue = new TreeSet(comparator);
                for (Object item : value) {
                    sortedValue.add(item);
                }
            }
            itemsChanging(sortedValue, items);
            items = sortedValue;
        }
        updatePagingAvailability();
        getItemsChangedEvent().raise(this, EventArgs.Empty);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        selectedItem = null;
        if (getSelectedItems() != null) {
            getSelectedItems().clear();
        }
        if (lastSelectedItem != null && items != null) {
            IVdcQueryable newSelectedItem = null;
            ArrayList<IVdcQueryable> newItems = new ArrayList<IVdcQueryable>();
            for (Object item : items) {
                newItems.add((IVdcQueryable) item);
            }
            if (newItems != null) {
                for (IVdcQueryable newItem : newItems) {
                    // Search for selected item
                    if (newItem.getQueryableId().equals(lastSelectedItem.getQueryableId())) {
                        newSelectedItem = newItem;
                    } else {
                        // Search for selected items
                        for (IVdcQueryable item : lastSelectedItems) {
                            if (newItem.getQueryableId().equals(item.getQueryableId())) {
                                selectedItems.add(newItem);
                            }
                        }
                    }
                }
            }
            if (newSelectedItem != null) {
                selectedItem = newSelectedItem;
                if (selectedItems != null) {
                    selectedItems.add(newSelectedItem);
                }
            }
        }
        onSelectedItemChanged();
    }
}
#method_after
@Override
public void setItems(Iterable value) {
    if (items != value) {
        IVdcQueryable lastSelectedItem = (IVdcQueryable) getSelectedItem();
        ArrayList<IVdcQueryable> lastSelectedItems = new ArrayList<IVdcQueryable>();
        if (getSelectedItems() != null) {
            for (Object item : getSelectedItems()) {
                lastSelectedItems.add((IVdcQueryable) item);
            }
        }
        if (comparator == null || ((value instanceof SortedSet) && (((SortedSet) value).comparator() == comparator))) {
            itemsChanging(value, items);
            items = value;
        } else {
            TreeSet sortedValue = null;
            if (value != null) {
                sortedValue = new TreeSet(comparator);
                for (Object item : value) {
                    sortedValue.add(item);
                }
            }
            itemsChanging(sortedValue, items);
            items = sortedValue;
        }
        updatePagingAvailability();
        getItemsChangedEvent().raise(this, EventArgs.Empty);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        selectedItem = null;
        if (getSelectedItems() != null) {
            getSelectedItems().clear();
        }
        if (lastSelectedItem != null && items != null) {
            IVdcQueryable newSelectedItem = null;
            ArrayList<IVdcQueryable> newItems = new ArrayList<IVdcQueryable>();
            for (Object item : items) {
                newItems.add((IVdcQueryable) item);
            }
            if (newItems != null) {
                for (IVdcQueryable newItem : newItems) {
                    // Search for selected item
                    if (newItem.getQueryableId().equals(lastSelectedItem.getQueryableId())) {
                        newSelectedItem = newItem;
                    } else {
                        // Search for selected items
                        for (IVdcQueryable item : lastSelectedItems) {
                            if (newItem.getQueryableId().equals(item.getQueryableId())) {
                                selectedItems.add(newItem);
                            }
                        }
                    }
                }
            }
            if (newSelectedItem != null) {
                selectedItem = newSelectedItem;
                if (selectedItems != null) {
                    selectedItems.add(newSelectedItem);
                }
            }
        }
        onSelectedItemChanged();
    }
}
#end_block

#method_before
private void flush() {
    provider.setName((String) name.getEntity());
    provider.setType((ProviderType) type.getSelectedItem());
    provider.setDescription((String) description.getEntity());
    provider.setUrl((String) url.getEntity());
    if (isTypeOpenStackNetwork()) {
        OpenstackNetworkProviderProperties properties = new OpenstackNetworkProviderProperties();
        properties.setPluginType((OpenstackNetworkPluginType) getPluginType().getSelectedItem());
        provider.setAdditionalProperties(properties);
    }
    boolean authenticationRequired = (Boolean) requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername((String) username.getEntity());
        provider.setPassword((String) password.getEntity());
        if (isTypeOpenStackNetwork()) {
            ((OpenstackNetworkProviderProperties) provider.getAdditionalProperties()).setTenantName((String) getTenantName().getEntity());
        }
    }
}
#method_after
private void flush() {
    provider.setName((String) name.getEntity());
    provider.setType((ProviderType) type.getSelectedItem());
    provider.setDescription((String) description.getEntity());
    provider.setUrl((String) url.getEntity());
    if (isTypeOpenStackNetwork()) {
        OpenstackNetworkProviderProperties properties = new OpenstackNetworkProviderProperties();
        properties.setPluginType((String) getPluginType().getSelectedItem());
        provider.setAdditionalProperties(properties);
    }
    boolean authenticationRequired = (Boolean) requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername((String) username.getEntity());
        provider.setPassword((String) password.getEntity());
        if (isTypeOpenStackNetwork()) {
            ((OpenstackNetworkProviderProperties) provider.getAdditionalProperties()).setTenantName((String) getTenantName().getEntity());
        }
    }
}
#end_block

#method_before
@Override
protected void preSave() {
    if (StringHelper.stringsEqualIgnoreCase((String) getUrl().getEntity(), oldUrl)) {
        actualSave();
    } else {
        ArrayList<VdcQueryType> queryTypes = new ArrayList<VdcQueryType>();
        ArrayList<VdcQueryParametersBase> queryParams = new ArrayList<VdcQueryParametersBase>();
        final Set<VdcObjectType> providedTypes = provider.getType().getProvidedTypes();
        if (providedTypes.contains(VdcObjectType.Network)) {
            queryTypes.add(VdcQueryType.GetAllNetworksForProvider);
            queryParams.add(new IdQueryParameters(provider.getId()));
        }
        startProgress(null);
        Frontend.RunMultipleQueries(queryTypes, queryParams, new IFrontendMultipleQueryAsyncCallback() {

            @SuppressWarnings("unchecked")
            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                stopProgress();
                Iterator<VdcQueryReturnValue> i = result.getReturnValues().iterator();
                if (providedTypes.contains(VdcObjectType.Network)) {
                    providedNetworks = (Collection<Network>) (i.next()).getReturnValue();
                }
                showConfirmation();
            }
        });
    }
}
#method_after
@Override
protected void preSave() {
    if (!StringHelper.stringsEqualIgnoreCase((String) getUrl().getEntity(), oldUrl)) {
        ArrayList<VdcQueryType> queryTypes = new ArrayList<VdcQueryType>();
        ArrayList<VdcQueryParametersBase> queryParams = new ArrayList<VdcQueryParametersBase>();
        final Set<VdcObjectType> providedTypes = provider.getType().getProvidedTypes();
        if (providedTypes.contains(VdcObjectType.Network)) {
            queryTypes.add(VdcQueryType.GetAllNetworksForProvider);
            queryParams.add(new IdQueryParameters(provider.getId()));
        }
        if (!queryTypes.isEmpty()) {
            startProgress(null);
            Frontend.RunMultipleQueries(queryTypes, queryParams, new IFrontendMultipleQueryAsyncCallback() {

                @SuppressWarnings("unchecked")
                @Override
                public void executed(FrontendMultipleQueryAsyncResult result) {
                    stopProgress();
                    Iterator<VdcQueryReturnValue> i = result.getReturnValues().iterator();
                    if (providedTypes.contains(VdcObjectType.Network)) {
                        providedNetworks = (Collection<Network>) (i.next()).getReturnValue();
                    }
                    showConfirmation();
                }
            });
            return;
        }
    }
    actualSave();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        VM vm = getVm();
        processImages();
        // vm related ops
        if (getReturnValue().getTaskIdList().isEmpty()) {
            endVmRelatedOps();
        }
    } catch (RuntimeException e) {
        MacPoolManager.getInstance().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        processImages();
        // vm related ops
        if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
            endVmRelatedOps();
        }
    } catch (RuntimeException e) {
        MacPoolManager.getInstance().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    int i = 0;
    for (DiskImage disk : disks) {
        Guid destinationDomain = imageToDestinationDomainMap.get(diskGuidList.get(i));
        MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, diskGuidList.get(i), imageGuidList.get(i), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
        p.setParentCommand(getActionType());
        p.setUseCopyCollapse(getParameters().getCopyCollapse());
        p.setCopyVolumeType(CopyVolumeType.LeafVol);
        p.setForceOverride(getParameters().getForceOverride());
        p.setSourceDomainId(getParameters().getSourceDomainId());
        p.setStoragePoolId(getParameters().getStoragePoolId());
        p.setImportEntity(true);
        p.setEntityId(getVm().getId());
        p.setQuotaId(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getQuotaId());
        if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(diskGuidList.get(i))) {
            DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(diskGuidList.get(i));
            p.setVolumeType(diskImageBase.getVolumeType());
            p.setVolumeFormat(diskImageBase.getVolumeFormat());
        }
        p.setParentParameters(getParameters());
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.CopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
        i++;
    }
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    int i = 0;
    for (DiskImage disk : disks) {
        Guid destinationDomain = imageToDestinationDomainMap.get(diskGuidList.get(i));
        MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, diskGuidList.get(i), imageGuidList.get(i), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
        p.setParentCommand(getActionType());
        p.setUseCopyCollapse(getParameters().getCopyCollapse());
        p.setCopyVolumeType(CopyVolumeType.LeafVol);
        p.setForceOverride(getParameters().getForceOverride());
        p.setSourceDomainId(getParameters().getSourceDomainId());
        p.setStoragePoolId(getParameters().getStoragePoolId());
        p.setImportEntity(true);
        p.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
        p.setQuotaId(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getQuotaId());
        if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(diskGuidList.get(i))) {
            DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(diskGuidList.get(i));
            p.setVolumeType(diskImageBase.getVolumeType());
            p.setVolumeFormat(diskImageBase.getVolumeFormat());
        }
        p.setParentParameters(getParameters());
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.CopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        i++;
    }
}
#end_block

#method_before
public void setSelectionAlgorithm(VdsSelectionAlgorithm value) {
    if (selectionAlgorithm != value) {
        selectionAlgorithm = value;
        SelectionAlgorithmChanged();
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("SelectionAlgorithm"));
    }
}
#method_after
public void setSelectionAlgorithm(VdsSelectionAlgorithm value) {
    if (selectionAlgorithm != value) {
        selectionAlgorithm = value;
        selectionAlgorithmChanged();
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("SelectionAlgorithm"));
    }
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDSGroup vdsGroup = (VDSGroup) getSelectedItem();
    getClusterVmListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
    getClusterServiceModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && Version.v3_2.compareTo(vdsGroup.getcompatibility_version()) <= 0);
    getClusterGlusterHookListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService());
    getClusterPolicyModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDSGroup vdsGroup = (VDSGroup) getSelectedItem();
    getClusterVmListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
    getClusterServiceModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterVolumeServicesSupported(vdsGroup.getcompatibility_version()));
    getClusterGlusterHookListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterHookSupported(vdsGroup.getcompatibility_version()));
    getClusterPolicyModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeClusterTitle());
    // $NON-NLS-1$
    model.setHashName("remove_cluster");
    model.setMessage(ConstantsManager.getInstance().getConstants().clustersMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (VDSGroup a : Linq.<VDSGroup>cast(getSelectedItems())) {
        list.add(a.getname());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeClusterTitle());
    // $NON-NLS-1$
    model.setHashName("remove_cluster");
    model.setMessage(ConstantsManager.getInstance().getConstants().clustersMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (VDSGroup a : Linq.<VDSGroup>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().StartProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.setHandleFailure(true);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            getWindow().StopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(Frontend.getAppErrorsTranslator().TranslateErrorTextSingle(returnValue.getExceptionString()));
                return;
            }
            Map<String, String> hostMap = (Map<String, String>) returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel> list = new ArrayList<EntityModel>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel entityModel = new EntityModel(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.GetGlusterHosts(aQuery, (String) clusterModel.getGlusterHostAddress().getEntity(), (String) clusterModel.getGlusterHostPassword().getEntity(), (String) clusterModel.getGlusterHostFingerprint().getEntity());
}
#method_after
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().startProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.setHandleFailure(true);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            getWindow().stopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(Frontend.getAppErrorsTranslator().TranslateErrorTextSingle(returnValue.getExceptionString()));
                return;
            }
            Map<String, String> hostMap = (Map<String, String>) returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel> list = new ArrayList<EntityModel>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel entityModel = new EntityModel(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.getGlusterHosts(aQuery, (String) clusterModel.getGlusterHostAddress().getEntity(), (String) clusterModel.getGlusterHostPassword().getEntity(), (String) clusterModel.getGlusterHostFingerprint().getEntity());
}
#end_block

#method_before
private void importClusterHosts(ClusterModel clusterModel, ArrayList<EntityModel> hostList) {
    setWindow(null);
    getAddMultipleHostsCommand().Execute();
    final MultipleHostsModel hostsModel = new MultipleHostsModel();
    setWindow(hostsModel);
    hostsModel.setTitle(ConstantsManager.getInstance().getConstants().addMultipleHostsTitle());
    // $NON-NLS-1$
    hostsModel.setHashName("add_hosts");
    hostsModel.setClusterModel(clusterModel);
    hostsModel.getHosts().setItems(hostList);
    // $NON-NLS-1$
    UICommand command = new UICommand("OnSaveHosts", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    hostsModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    hostsModel.getCommands().add(command);
}
#method_after
private void importClusterHosts(ClusterModel clusterModel, ArrayList<EntityModel> hostList) {
    setWindow(null);
    getAddMultipleHostsCommand().execute();
    final MultipleHostsModel hostsModel = new MultipleHostsModel();
    setWindow(hostsModel);
    hostsModel.setTitle(ConstantsManager.getInstance().getConstants().addMultipleHostsTitle());
    // $NON-NLS-1$
    hostsModel.setHashName("add_hosts");
    hostsModel.setClusterModel(clusterModel);
    hostsModel.getHosts().setItems(hostList);
    // $NON-NLS-1$
    UICommand command = new UICommand("OnSaveHosts", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    hostsModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    hostsModel.getCommands().add(command);
}
#end_block

#method_before
private void onSaveHosts() {
    MultipleHostsModel hostsModel = (MultipleHostsModel) getWindow();
    if (hostsModel == null) {
        return;
    }
    if (!hostsModel.validate()) {
        return;
    }
    if (hostsModel.getClusterModel().getClusterId() != null) {
        addHosts(hostsModel);
    } else {
        OnSaveInternalWithModel(hostsModel.getClusterModel());
    }
}
#method_after
private void onSaveHosts() {
    MultipleHostsModel hostsModel = (MultipleHostsModel) getWindow();
    if (hostsModel == null) {
        return;
    }
    if (!hostsModel.validate()) {
        return;
    }
    if (hostsModel.getClusterModel().getClusterId() != null) {
        addHosts(hostsModel);
    } else {
        onSaveInternalWithModel(hostsModel.getClusterModel());
    }
}
#end_block

#method_before
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.StartProgress(null);
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSSHKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        host.setVdsGroupId((Guid) hostsModel.getClusterModel().getClusterId());
        host.setpm_enabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setRootPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(false);
        parameters.setRebootAfterInstallation(hostsModel.getClusterModel().getEnableOvirtService().getIsSelected());
        parametersList.add(parameters);
    }
    Frontend.RunMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.StopProgress();
            boolean isAllCanDoPassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllCanDoPassed = isAllCanDoPassed && returnValueBase.getCanDoAction();
                if (!isAllCanDoPassed) {
                    break;
                }
            }
            if (isAllCanDoPassed) {
                Cancel();
            }
        }
    }, null);
}
#method_after
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress(null);
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSSHKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        host.setVdsGroupId((Guid) hostsModel.getClusterModel().getClusterId());
        host.setpm_enabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setRootPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(false);
        parameters.setRebootAfterInstallation(hostsModel.getClusterModel().getEnableOvirtService().getIsSelected());
        parametersList.add(parameters);
    }
    Frontend.RunMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllCanDoPassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllCanDoPassed = isAllCanDoPassed && returnValueBase.getCanDoAction();
                if (!isAllCanDoPassed) {
                    break;
                }
            }
            if (isAllCanDoPassed) {
                cancel();
            }
        }
    }, null);
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    UpdateActionAvailability();
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
}
#end_block

#method_before
@Override
protected void selectedItemsChanged() {
    super.selectedItemsChanged();
    UpdateActionAvailability();
}
#method_after
@Override
protected void selectedItemsChanged() {
    super.selectedItemsChanged();
    updateActionAvailability();
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuThreads")) {
        OnSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        OnSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        onSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuThreads")) {
        onSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#end_block

#method_before
@Override
public void setSystemTreeSelectedItem(SystemTreeItemModel value) {
    if (systemTreeSelectedItem != value) {
        systemTreeSelectedItem = value;
        OnSystemTreeSelectedItemChanged();
    }
}
#method_after
@Override
public void setSystemTreeSelectedItem(SystemTreeItemModel value) {
    if (systemTreeSelectedItem != value) {
        systemTreeSelectedItem = value;
        onSystemTreeSelectedItemChanged();
    }
}
#end_block

#method_before
private void initListBoxEditors() {
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((StoragePool) object).getname();
        }
    });
    cPUEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ServerCpu) object).getCpuName();
        }
    });
    versionEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Version) object).toString();
        }
    });
}
#method_after
private void initListBoxEditors() {
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((StoragePool) object).getName();
        }
    });
    cPUEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ServerCpu) object).getCpuName();
        }
    });
    versionEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Version) object).toString();
        }
    });
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshLightWeightData")
public void refreshLightWeightData() {
    log.debug("Refreshing Gluster Data [lightweight]");
    List<VDSGroup> clusters = getClusterDao().getAll();
    for (VDSGroup cluster : clusters) {
        if (cluster.supportsGlusterService()) {
            try {
                refreshClusterData(cluster);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing Gluster lightweight data of cluster {0}!", cluster.getname(), e);
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("refreshLightWeightData")
public void refreshLightWeightData() {
    log.debug("Refreshing Gluster Data [lightweight]");
    List<VDSGroup> clusters = getClusterDao().getAll();
    for (VDSGroup cluster : clusters) {
        if (cluster.supportsGlusterService()) {
            try {
                refreshClusterData(cluster);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing Gluster lightweight data of cluster {0}!", cluster.getName(), e);
            }
        }
    }
}
#end_block

#method_before
private void refreshClusterData(VDSGroup cluster) {
    log.debugFormat("Refreshing Gluster lightweight Data for cluster {0}", cluster.getname());
    List<VDS> existingServers = getVdsDao().getAllForVdsGroup(cluster.getId());
    VDS upServer = getClusterUtils().getUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getname());
        return;
    }
    refreshServerData(cluster, upServer, existingServers);
    refreshVolumeData(cluster, upServer, existingServers);
}
#method_after
private void refreshClusterData(VDSGroup cluster) {
    log.debugFormat("Refreshing Gluster lightweight Data for cluster {0}", cluster.getName());
    List<VDS> existingServers = getVdsDao().getAllForVdsGroup(cluster.getId());
    VDS upServer = getClusterUtils().getUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    refreshServerData(cluster, upServer, existingServers);
    refreshVolumeData(cluster, upServer, existingServers);
}
#end_block

#method_before
private void refreshServerData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    if (cluster.supportsVirtService()) {
        // If the cluster supports virt service as well, we should not be removing any servers from it, even if they
        // have been removed from the Gluster cluster using the Gluster cli, as they could potentially be used for
        // running VMs
        log.debugFormat("As cluster {0} supports virt service as well, it's servers will not be synced with glusterfs", cluster.getname());
        return;
    }
    acquireLock(cluster.getId());
    try {
        List<GlusterServerInfo> fetchedServers = fetchServers(cluster, upServer, existingServers);
        if (fetchedServers != null) {
            removeDetachedServers(existingServers, fetchedServers);
        }
    } catch (Exception e) {
        log.errorFormat("Error while refreshing server data for cluster {0} from database!", cluster.getname(), e);
    } finally {
        releaseLock(cluster.getId());
    }
}
#method_after
private void refreshServerData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    if (cluster.supportsVirtService()) {
        // If the cluster supports virt service as well, we should not be removing any servers from it, even if they
        // have been removed from the Gluster cluster using the Gluster cli, as they could potentially be used for
        // running VMs
        log.debugFormat("As cluster {0} supports virt service as well, it's servers will not be synced with glusterfs", cluster.getName());
        return;
    }
    acquireLock(cluster.getId());
    try {
        List<GlusterServerInfo> fetchedServers = fetchServers(cluster, upServer, existingServers);
        if (fetchedServers != null) {
            removeDetachedServers(existingServers, fetchedServers);
        }
    } catch (Exception e) {
        log.errorFormat("Error while refreshing server data for cluster {0} from database!", cluster.getName(), e);
    } finally {
        releaseLock(cluster.getId());
    }
}
#end_block

#method_before
private List<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    // Create a copy of the existing servers as the fetchServer method can potentially remove elements from it
    List<VDS> tempServers = new ArrayList<VDS>(existingServers);
    List<GlusterServerInfo> fetchedServers = fetchServers(upServer, tempServers);
    if (fetchedServers == null) {
        log.errorFormat("gluster peer status command failed on all servers of the cluster {0}." + "Can't refresh it's data at this point.", cluster.getname());
        return null;
    }
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (isSameServer(upServer, server)) {
            // Find a different UP server, and get servers list from it
            tempServers.remove(upServer);
            upServer = getNewUpServer(tempServers, upServer);
            if (upServer == null) {
                log.warnFormat("The only UP server in cluster {0} seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getname());
                return null;
            }
            fetchedServers = fetchServers(upServer, tempServers);
            if (fetchedServers == null) {
                log.warnFormat("The only UP server in cluster {0} (or the only one on which gluster peer status " + "command is working) seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getname());
                return null;
            }
        }
    }
    return fetchedServers;
}
#method_after
private List<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    // Create a copy of the existing servers as the fetchServer method can potentially remove elements from it
    List<VDS> tempServers = new ArrayList<VDS>(existingServers);
    List<GlusterServerInfo> fetchedServers = fetchServers(upServer, tempServers);
    if (fetchedServers == null) {
        log.errorFormat("gluster peer status command failed on all servers of the cluster {0}." + "Can't refresh it's data at this point.", cluster.getName());
        return null;
    }
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (isSameServer(upServer, server)) {
            // Find a different UP server, and get servers list from it
            tempServers.remove(upServer);
            upServer = getNewUpServer(tempServers, upServer);
            if (upServer == null) {
                log.warnFormat("The only UP server in cluster {0} seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getName());
                return null;
            }
            fetchedServers = fetchServers(upServer, tempServers);
            if (fetchedServers == null) {
                log.warnFormat("The only UP server in cluster {0} (or the only one on which gluster peer status " + "command is working) seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getName());
                return null;
            }
        }
    }
    return fetchedServers;
}
#end_block

#method_before
private void setNonOperational(VDS server) {
    SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED);
    nonOpParams.setSaveToDb(true);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
}
#method_after
private void setNonOperational(VDS server) {
    SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED, Collections.singletonMap(GlusterConstants.COMMAND, "gluster peer probe"));
    nonOpParams.setSaveToDb(true);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
private void refreshVolumeData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    acquireLock(cluster.getId());
    try {
        // Pass a copy of the existing servers as the fetchVolumes method can potentially remove elements from it
        Map<Guid, GlusterVolumeEntity> volumesMap = fetchVolumes(upServer, new ArrayList<VDS>(existingServers));
        if (volumesMap == null) {
            log.errorFormat("gluster volume info command failed on all servers of the cluster {0}." + "Can't refresh it's data at this point.", cluster.getname());
            return;
        }
        // remove deleted volumes must happen before adding new ones,
        // to handle cases where user deleted a volume and created a
        // new one with same name in a very short time
        removeDeletedVolumes(cluster.getId(), volumesMap);
        updateExistingAndNewVolumes(cluster.getId(), volumesMap);
    } finally {
        releaseLock(cluster.getId());
    }
}
#method_after
private void refreshVolumeData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    acquireLock(cluster.getId());
    try {
        // Pass a copy of the existing servers as the fetchVolumes method can potentially remove elements from it
        Map<Guid, GlusterVolumeEntity> volumesMap = fetchVolumes(upServer, new ArrayList<VDS>(existingServers));
        if (volumesMap == null) {
            log.errorFormat("gluster volume info command failed on all servers of the cluster {0}." + "Can't refresh it's data at this point.", cluster.getName());
            return;
        }
        // remove deleted volumes must happen before adding new ones,
        // to handle cases where user deleted a volume and created a
        // new one with same name in a very short time
        removeDeletedVolumes(cluster.getId(), volumesMap);
        updateExistingAndNewVolumes(cluster.getId(), volumesMap);
    } finally {
        releaseLock(cluster.getId());
    }
}
#end_block

#method_before
@SuppressWarnings("serial")
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (final GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            idsToRemove.add(existingOption.getId());
            log.infoFormat("Detected option {0} reset on volume {1}. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            // Hence it is not required to log it as a removed option, as that would be misleading.
            if (!GlusterConstants.OPTION_GROUP.equals(existingOption.getKey())) {
                logUtil.logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, new HashMap<String, String>() {

                    {
                        put(GlusterConstants.OPTION_KEY, existingOption.getKey());
                    }
                });
            }
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getOptionDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.errorFormat("Error while removing options of volume {0} from database!", fetchedVolume.getName(), e);
        }
    }
}
#method_after
@SuppressWarnings("serial")
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (final GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            idsToRemove.add(existingOption.getId());
            log.infoFormat("Detected option {0} reset on volume {1}. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            // Hence it is not required to log it as a removed option, as that would be misleading.
            if (!GlusterConstants.OPTION_GROUP.equals(existingOption.getKey())) {
                logUtil.logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, new HashMap<String, String>() {

                    {
                        put(GlusterConstants.OPTION_KEY, existingOption.getKey());
                        put(GlusterConstants.OPTION_VALUE, existingOption.getValue());
                    }
                });
            }
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getOptionDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.errorFormat("Error while removing options of volume {0} from database!", fetchedVolume.getName(), e);
        }
    }
}
#end_block

#method_before
@SuppressWarnings("serial")
private void updateExistingAndNewOptions(GlusterVolumeEntity existingVolume, Collection<GlusterVolumeOptionEntity> fetchedOptions) {
    for (final GlusterVolumeOptionEntity fetchedOption : fetchedOptions) {
        final GlusterVolumeOptionEntity existingOption = existingVolume.getOption(fetchedOption.getKey());
        if (existingOption == null) {
            logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, new HashMap<String, String>() {

                {
                    put(GlusterConstants.OPTION_KEY, fetchedOption.getKey());
                    put(GlusterConstants.OPTION_VALUE, fetchedOption.getValue());
                }
            });
            log.infoFormat("New option {0}={1} set on volume {2} from gluster CLI. Updating engine DB accordingly.", fetchedOption.getKey(), fetchedOption.getValue(), existingVolume.getName());
            try {
                getOptionDao().save(fetchedOption);
            } catch (Exception e) {
                log.errorFormat("Could not save option {0} of volume {1) to database!", fetchedOption, existingVolume.getName(), e);
            }
        } else if (!existingOption.getValue().equals(fetchedOption.getValue())) {
            logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_CHANGED_FROM_CLI, new HashMap<String, String>() {

                {
                    put(GlusterConstants.OPTION_KEY, existingOption.getKey());
                    put(GlusterConstants.OPTION_OLD_VALUE, existingOption.getValue());
                    put(GlusterConstants.OPTION_NEW_VALUE, fetchedOption.getValue());
                }
            });
            log.infoFormat("Detected change in value of option {0} of volume {1} from {2} to {3}. Updating engine DB accordingly.", existingOption.getKey(), existingVolume.getName(), existingOption.getValue(), fetchedOption.getValue());
            try {
                getOptionDao().updateVolumeOption(existingOption.getId(), fetchedOption.getValue());
            } catch (Exception e) {
                log.errorFormat("Error while updating option {0} of volume {1} in database!", fetchedOption, existingVolume.getName(), e);
            }
        }
    }
}
#method_after
private void updateExistingAndNewOptions(final GlusterVolumeEntity existingVolume, Collection<GlusterVolumeOptionEntity> fetchedOptions) {
    Map<String, GlusterVolumeOptionEntity> existingOptions = new HashMap<>();
    Map<String, GlusterVolumeOptionEntity> newOptions = new HashMap<>();
    for (final GlusterVolumeOptionEntity fetchedOption : fetchedOptions) {
        final GlusterVolumeOptionEntity existingOption = existingVolume.getOption(fetchedOption.getKey());
        if (existingOption == null) {
            newOptions.put(fetchedOption.getKey(), fetchedOption);
        } else if (!existingOption.getValue().equals(fetchedOption.getValue())) {
            fetchedOption.setId(existingOption.getId());
            existingOptions.put(fetchedOption.getKey(), fetchedOption);
        }
    }
    final List<GlusterVolumeOptionEntity> newOptionsSortedList = new ArrayList<GlusterVolumeOptionEntity>(newOptions.values());
    final List<GlusterVolumeOptionEntity> existingOptionsSortedList = new ArrayList<GlusterVolumeOptionEntity>(existingOptions.values());
    Collections.sort(newOptionsSortedList);
    Collections.sort(existingOptionsSortedList);
    // Insert the new options in a single transaction
    if (!newOptionsSortedList.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveNewOptions(existingVolume, newOptionsSortedList);
                return null;
            }
        });
    }
    // Update the existing options in a single transaction
    if (!existingOptionsSortedList.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                updateExistingOptions(existingVolume, existingOptionsSortedList);
                return null;
            }
        });
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshHeavyWeightData")
public void refreshHeavyWeightData() {
    log.debug("Refreshing Gluster Data [heavyweight]");
    for (VDSGroup cluster : getClusterDao().getAll()) {
        if (GlusterFeatureSupported.refreshHeavyWeight(cluster.getcompatibility_version()) && cluster.supportsGlusterService()) {
            try {
                refreshClusterHeavyWeightData(cluster);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing Gluster heavyweight data of cluster {0}!", cluster.getname(), e);
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("refreshHeavyWeightData")
public void refreshHeavyWeightData() {
    log.debug("Refreshing Gluster Data [heavyweight]");
    for (VDSGroup cluster : getClusterDao().getAll()) {
        if (GlusterFeatureSupported.refreshHeavyWeight(cluster.getcompatibility_version()) && cluster.supportsGlusterService()) {
            try {
                refreshClusterHeavyWeightData(cluster);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing Gluster heavyweight data of cluster {0}!", cluster.getName(), e);
            }
        }
    }
}
#end_block

#method_before
private void refreshClusterHeavyWeightData(VDSGroup cluster) {
    VDS upServer = getClusterUtils().getUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getname());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debugFormat("Refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getname());
        // brick statuses can be fetched only for started volumes
        if (volume.isOnline()) {
            acquireLock(cluster.getId());
            try {
                refreshBrickStatuses(upServer, volume);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getname(), e);
            } finally {
                releaseLock(cluster.getId());
            }
        }
    }
}
#method_after
private void refreshClusterHeavyWeightData(VDSGroup cluster) {
    VDS upServer = getClusterUtils().getUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debugFormat("Refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getName());
        // brick statuses can be fetched only for started volumes
        if (volume.isOnline()) {
            acquireLock(cluster.getId());
            try {
                refreshBrickStatuses(upServer, volume);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getName(), e);
            } finally {
                releaseLock(cluster.getId());
            }
        }
    }
}
#end_block

#method_before
private void createCluster(Version version) {
    existingCluster = new VDSGroup();
    existingCluster.setId(CLUSTER_ID);
    existingCluster.setname("cluster");
    existingCluster.setGlusterService(true);
    existingCluster.setVirtService(false);
    existingCluster.setcompatibility_version(version);
    createObjects(version);
}
#method_after
private void createCluster(Version version) {
    existingCluster = new VDSGroup();
    existingCluster.setId(CLUSTER_ID);
    existingCluster.setName("cluster");
    existingCluster.setGlusterService(true);
    existingCluster.setVirtService(false);
    existingCluster.setcompatibility_version(version);
    createObjects(version);
}
#end_block

#method_before
private void verifyMocksForLightWeight() {
    InOrder inOrder = inOrder(clusterDao, vdsDao, clusterUtils, glusterManager, vdsStatisticsDao, vdsDynamicDao, vdsStaticDao, volumeDao, brickDao, optionDao);
    // all clusters fetched from db
    inOrder.verify(clusterDao, times(1)).getAll();
    // get servers of the cluster from db
    inOrder.verify(vdsDao, times(1)).getAllForVdsGroup(CLUSTER_ID);
    // get the UP server from cluster
    inOrder.verify(clusterUtils, times(1)).getUpServer(CLUSTER_ID);
    // acquire lock on the cluster
    inOrder.verify(glusterManager, times(1)).acquireLock(CLUSTER_ID);
    // servers are fetched from glusterfs
    inOrder.verify(glusterManager, times(1)).fetchServers(existingServer1);
    // detached server SERVER_ID_3 is deleted from DB
    inOrder.verify(vdsStatisticsDao, times(1)).remove(SERVER_ID_3);
    inOrder.verify(vdsDynamicDao, times(1)).remove(SERVER_ID_3);
    inOrder.verify(vdsStaticDao, times(1)).remove(SERVER_ID_3);
    // detached server SERVER_ID_3 is removed from resource manager
    inOrder.verify(glusterManager, times(1)).runVdsCommand(eq(VDSCommandType.RemoveVds), any(RemoveVdsVDSCommandParameters.class));
    // release lock on the cluster
    inOrder.verify(glusterManager, times(1)).releaseLock(CLUSTER_ID);
    // acquire lock on the cluster for next operation (refresh volumes)
    inOrder.verify(glusterManager, times(1)).acquireLock(CLUSTER_ID);
    // volumes are fetched from glusterfs
    inOrder.verify(glusterManager, times(1)).fetchVolumes(any(VDS.class));
    // get volumes by cluster id to identify those that need to be removed
    inOrder.verify(volumeDao, times(1)).getByClusterId(CLUSTER_ID);
    // remove deleted volumes
    inOrder.verify(volumeDao, times(1)).removeAll(argThat(areRemovedVolumes()));
    // create new volume
    inOrder.verify(volumeDao, times(1)).save(newVolume);
    // remove detached bricks
    inOrder.verify(brickDao, times(1)).removeAll(argThat(containsRemovedBricks()));
    // add new bricks
    inOrder.verify(brickDao, times(2)).save(argThat(isAddedBrick()));
    // update modified options
    inOrder.verify(optionDao, times(1)).updateVolumeOption(argThat(isUpdatedOptionId()), eq(OPTION_VALUE_ON));
    // add new options
    inOrder.verify(optionDao, times(1)).save(argThat(isNewOption()));
    // delete removed options
    inOrder.verify(optionDao, times(1)).removeAll(argThat(areRemovedOptions()));
    // release lock on the cluster
    inOrder.verify(glusterManager, times(1)).releaseLock(CLUSTER_ID);
}
#method_after
private void verifyMocksForLightWeight() {
    InOrder inOrder = inOrder(clusterDao, vdsDao, clusterUtils, glusterManager, vdsStatisticsDao, vdsDynamicDao, vdsStaticDao, volumeDao, brickDao, optionDao);
    // all clusters fetched from db
    inOrder.verify(clusterDao, times(1)).getAll();
    // get servers of the cluster from db
    inOrder.verify(vdsDao, times(1)).getAllForVdsGroup(CLUSTER_ID);
    // get the UP server from cluster
    inOrder.verify(clusterUtils, times(1)).getUpServer(CLUSTER_ID);
    // acquire lock on the cluster
    inOrder.verify(glusterManager, times(1)).acquireLock(CLUSTER_ID);
    // servers are fetched from glusterfs
    inOrder.verify(glusterManager, times(1)).fetchServers(existingServer1);
    // detached server SERVER_ID_3 is deleted from DB
    inOrder.verify(vdsStatisticsDao, times(1)).remove(SERVER_ID_3);
    inOrder.verify(vdsDynamicDao, times(1)).remove(SERVER_ID_3);
    inOrder.verify(vdsStaticDao, times(1)).remove(SERVER_ID_3);
    // detached server SERVER_ID_3 is removed from resource manager
    inOrder.verify(glusterManager, times(1)).runVdsCommand(eq(VDSCommandType.RemoveVds), any(RemoveVdsVDSCommandParameters.class));
    // release lock on the cluster
    inOrder.verify(glusterManager, times(1)).releaseLock(CLUSTER_ID);
    // acquire lock on the cluster for next operation (refresh volumes)
    inOrder.verify(glusterManager, times(1)).acquireLock(CLUSTER_ID);
    // volumes are fetched from glusterfs
    inOrder.verify(glusterManager, times(1)).fetchVolumes(any(VDS.class));
    // get volumes by cluster id to identify those that need to be removed
    inOrder.verify(volumeDao, times(1)).getByClusterId(CLUSTER_ID);
    // remove deleted volumes
    inOrder.verify(volumeDao, times(1)).removeAll(argThat(areRemovedVolumes()));
    // create new volume
    inOrder.verify(volumeDao, times(1)).save(newVolume);
    // remove detached bricks
    inOrder.verify(brickDao, times(1)).removeAll(argThat(containsRemovedBricks()));
    // add new bricks
    inOrder.verify(brickDao, times(2)).save(argThat(isAddedBrick()));
    // add new options
    Map<String, GlusterVolumeOptionEntity> newOptions = new HashMap<String, GlusterVolumeOptionEntity>();
    newOptions.put(OPTION_AUTH_REJECT, existingReplVol.getOption(OPTION_AUTH_REJECT));
    List<GlusterVolumeOptionEntity> list1 = new ArrayList<GlusterVolumeOptionEntity>(newOptions.values());
    Collections.sort(list1);
    inOrder.verify(optionDao, times(1)).saveAll(list1);
    // update modified options
    Map<String, GlusterVolumeOptionEntity> existingOptions = new HashMap<String, GlusterVolumeOptionEntity>();
    existingReplVol.getOption(OPTION_NFS_DISABLE).setValue(OPTION_VALUE_ON);
    existingOptions.put(OPTION_NFS_DISABLE, existingReplVol.getOption(OPTION_NFS_DISABLE));
    List<GlusterVolumeOptionEntity> list = new ArrayList<GlusterVolumeOptionEntity>(existingOptions.values());
    Collections.sort(list);
    inOrder.verify(optionDao, times(1)).updateAll("UpdateGlusterVolumeOption", list);
    // delete removed options
    inOrder.verify(optionDao, times(1)).removeAll(argThat(areRemovedOptions()));
    // release lock on the cluster
    inOrder.verify(glusterManager, times(1)).releaseLock(CLUSTER_ID);
}
#end_block

#method_before
private void mockDaos() {
    doReturn(volumeDao).when(glusterManager).getVolumeDao();
    doReturn(brickDao).when(glusterManager).getBrickDao();
    doReturn(optionDao).when(glusterManager).getOptionDao();
    doReturn(vdsDao).when(glusterManager).getVdsDao();
    doReturn(vdsStatisticsDao).when(glusterManager).getVdsStatisticsDao();
    doReturn(vdsStaticDao).when(glusterManager).getVdsStaticDao();
    doReturn(vdsDynamicDao).when(glusterManager).getVdsDynamicDao();
    doReturn(clusterDao).when(glusterManager).getClusterDao();
    doReturn(interfaceDao).when(glusterManager).getInterfaceDao();
    doReturn(glusterServerDao).when(glusterManager).getGlusterServerDao();
    doReturn(Collections.singletonList(existingCluster)).when(clusterDao).getAll();
    doReturn(existingServers).when(vdsDao).getAllForVdsGroup(CLUSTER_ID);
    doReturn(existingDistVol).when(volumeDao).getById(EXISTING_VOL_DIST_ID);
    doReturn(existingReplVol).when(volumeDao).getById(EXISTING_VOL_REPL_ID);
    doReturn(null).when(volumeDao).getById(NEW_VOL_ID);
    doNothing().when(volumeDao).save(newVolume);
    doNothing().when(brickDao).removeAll(argThat(containsRemovedBricks()));
    doNothing().when(brickDao).save(argThat(isAddedBrick()));
    doNothing().when(optionDao).updateVolumeOption(argThat(isUpdatedOptionId()), eq(OPTION_VALUE_ON));
    doNothing().when(optionDao).save(argThat(isNewOption()));
    doNothing().when(optionDao).removeAll(argThat(areRemovedOptions()));
    doReturn(existingVolumes).when(volumeDao).getByClusterId(CLUSTER_ID);
    doNothing().when(volumeDao).removeAll(argThat(areRemovedVolumes()));
    doNothing().when(brickDao).updateBrickStatuses(argThat(hasBricksWithChangedStatus()));
}
#method_after
private void mockDaos() {
    doReturn(volumeDao).when(glusterManager).getVolumeDao();
    doReturn(brickDao).when(glusterManager).getBrickDao();
    doReturn(optionDao).when(glusterManager).getOptionDao();
    doReturn(vdsDao).when(glusterManager).getVdsDao();
    doReturn(vdsStatisticsDao).when(glusterManager).getVdsStatisticsDao();
    doReturn(vdsStaticDao).when(glusterManager).getVdsStaticDao();
    doReturn(vdsDynamicDao).when(glusterManager).getVdsDynamicDao();
    doReturn(clusterDao).when(glusterManager).getClusterDao();
    doReturn(interfaceDao).when(glusterManager).getInterfaceDao();
    doReturn(glusterServerDao).when(glusterManager).getGlusterServerDao();
    doReturn(Collections.singletonList(existingCluster)).when(clusterDao).getAll();
    doReturn(existingServers).when(vdsDao).getAllForVdsGroup(CLUSTER_ID);
    doReturn(existingDistVol).when(volumeDao).getById(EXISTING_VOL_DIST_ID);
    doReturn(existingReplVol).when(volumeDao).getById(EXISTING_VOL_REPL_ID);
    doReturn(null).when(volumeDao).getById(NEW_VOL_ID);
    doNothing().when(volumeDao).save(newVolume);
    doNothing().when(brickDao).removeAll(argThat(containsRemovedBricks()));
    doNothing().when(brickDao).save(argThat(isAddedBrick()));
    doNothing().when(optionDao).updateVolumeOption(argThat(isUpdatedOptionId()), eq(OPTION_VALUE_ON));
    doNothing().when(optionDao).save(argThat(isNewOption()));
    doNothing().when(optionDao).removeAll(argThat(areRemovedOptions()));
    doReturn(existingVolumes).when(volumeDao).getByClusterId(CLUSTER_ID);
    doNothing().when(volumeDao).removeAll(argThat(areRemovedVolumes()));
    doNothing().when(brickDao).updateBrickStatuses(argThat(hasBricksWithChangedStatus()));
    doNothing().when(optionDao).saveAll(argThat(areAddedOptions()));
}
#end_block

#method_before
private void replaceBrick(GlusterBrickEntity brick, Guid newServerId, String newBrickDir) {
    brick.setId(Guid.NewGuid());
    brick.setServerId(newServerId);
    brick.setBrickDirectory(newBrickDir);
    addedBrickIds.add(brick.getId());
}
#method_after
private void replaceBrick(GlusterBrickEntity brick, Guid newServerId, String newBrickDir) {
    brick.setId(Guid.newGuid());
    brick.setServerId(newServerId);
    brick.setBrickDirectory(newBrickDir);
    addedBrickIds.add(brick.getId());
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshGlusterServices")
public void refreshGlusterServices() {
    if (getServiceNameMap().isEmpty()) {
        // Lazy loading. Keeping this out of the constructor/getInstance
        // helps in writing the JUnit test as well.
        populateServiceMap();
    }
    List<VDSGroup> clusters = getClusterDao().getAll();
    for (VDSGroup cluster : clusters) {
        if (supportsGlusterServicesFeature(cluster)) {
            try {
                List<VDS> upServers = getClusterUtils().getAllUpServers(cluster.getId());
                if (upServers == null || upServers.isEmpty()) {
                    log.debugFormat("No UP servers found in cluster {0}, not refreshing status of services.", cluster.getname());
                    continue;
                }
                log.debugFormat("Syncing gluster related services for cluster {0}", cluster.getname());
                refreshClusterServices(cluster, ThreadPoolUtil.invokeAll(createTaskList(upServers)));
            } catch (Exception e) {
                log.errorFormat("Error while refreshing service statuses of cluster {0}!", cluster.getname(), e);
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("refreshGlusterServices")
public void refreshGlusterServices() {
    if (getServiceNameMap().isEmpty()) {
        // Lazy loading. Keeping this out of the constructor/getInstance
        // helps in writing the JUnit test as well.
        populateServiceMap();
    }
    List<VDSGroup> clusters = getClusterDao().getAll();
    for (VDSGroup cluster : clusters) {
        if (supportsGlusterServicesFeature(cluster)) {
            try {
                List<VDS> serversList = getClusterUtils().getAllServers(cluster.getId());
                List<Callable<Map<String, GlusterServiceStatus>>> taskList = createTaskList(serversList);
                if (taskList != null && taskList.size() > 0) {
                    refreshClusterServices(cluster, ThreadPoolUtil.invokeAll(taskList));
                }
            } catch (Exception e) {
                log.errorFormat("Error while refreshing service statuses of cluster {0}!", cluster.getName(), e);
            }
        }
    }
}
#end_block

#method_before
private List<Callable<Map<String, GlusterServiceStatus>>> createTaskList(List<VDS> upServers) {
    List<Callable<Map<String, GlusterServiceStatus>>> taskList = new ArrayList<Callable<Map<String, GlusterServiceStatus>>>();
    for (final VDS upServer : upServers) {
        taskList.add(new Callable<Map<String, GlusterServiceStatus>>() {

            /**
             * Fetches and updates status of all services of the given server, <br>
             * and returns a map having key = service name and value = service status
             */
            @Override
            public Map<String, GlusterServiceStatus> call() throws Exception {
                return refreshServerServices(upServer);
            }
        });
    }
    return taskList;
}
#method_after
private List<Callable<Map<String, GlusterServiceStatus>>> createTaskList(List<VDS> serversList) {
    List<Callable<Map<String, GlusterServiceStatus>>> taskList = new ArrayList<Callable<Map<String, GlusterServiceStatus>>>();
    for (final VDS server : serversList) {
        taskList.add(new Callable<Map<String, GlusterServiceStatus>>() {

            /**
             * Fetches and updates status of all services of the given server, <br>
             * and returns a map having key = service name and value = service status
             */
            @Override
            public Map<String, GlusterServiceStatus> call() throws Exception {
                return refreshServerServices(server);
            }
        });
    }
    return taskList;
}
#end_block

#method_before
private Map<ServiceType, GlusterServiceStatus> createServiceTypeStatusMap(List<Map<String, GlusterServiceStatus>> serviceStatusMaps) {
    Map<ServiceType, GlusterServiceStatus> fetchedServiceTypeStatusMap = new HashMap<ServiceType, GlusterServiceStatus>();
    for (Entry<String, GlusterServiceStatus> entry : mergeServiceStatusMaps(serviceStatusMaps).entrySet()) {
        String serviceName = entry.getKey();
        GlusterServiceStatus status = entry.getValue();
        ServiceType type = getServiceNameMap().get(serviceName).getServiceType();
        GlusterServiceStatus foundStatus = fetchedServiceTypeStatusMap.get(type);
        if (foundStatus == null) {
            fetchedServiceTypeStatusMap.put(type, status);
        } else if (foundStatus != status) {
            fetchedServiceTypeStatusMap.put(type, GlusterServiceStatus.MIXED);
        }
    }
    return fetchedServiceTypeStatusMap;
}
#method_after
private Map<ServiceType, GlusterServiceStatus> createServiceTypeStatusMap(List<Map<String, GlusterServiceStatus>> serviceStatusMaps) {
    Map<ServiceType, GlusterServiceStatus> fetchedServiceTypeStatusMap = new HashMap<ServiceType, GlusterServiceStatus>();
    for (Entry<String, GlusterServiceStatus> entry : mergeServiceStatusMaps(serviceStatusMaps).entrySet()) {
        String serviceName = entry.getKey();
        GlusterServiceStatus status = entry.getValue();
        ServiceType type = getServiceNameMap().get(serviceName).getServiceType();
        GlusterServiceStatus foundStatus = fetchedServiceTypeStatusMap.get(type);
        if (foundStatus == null) {
            fetchedServiceTypeStatusMap.put(type, status);
        } else if (foundStatus != status) {
            GlusterServiceStatus finalStatus = getFinalStatus(status, foundStatus);
            fetchedServiceTypeStatusMap.put(type, finalStatus);
        }
    }
    return fetchedServiceTypeStatusMap;
}
#end_block

#method_before
private Map<String, GlusterServiceStatus> mergeServiceStatusMaps(List<Map<String, GlusterServiceStatus>> serviceStatusMaps) {
    Map<String, GlusterServiceStatus> mergedServiceStatusMap = new HashMap<String, GlusterServiceStatus>();
    for (Map<String, GlusterServiceStatus> serviceStatusMap : serviceStatusMaps) {
        for (Entry<String, GlusterServiceStatus> entry : serviceStatusMap.entrySet()) {
            String serviceName = entry.getKey();
            GlusterServiceStatus status = entry.getValue();
            GlusterServiceStatus alreadyFoundStatus = mergedServiceStatusMap.get(serviceName);
            if (alreadyFoundStatus == null) {
                mergedServiceStatusMap.put(serviceName, status);
            } else if (alreadyFoundStatus != status && alreadyFoundStatus != GlusterServiceStatus.MIXED) {
                mergedServiceStatusMap.put(serviceName, GlusterServiceStatus.MIXED);
            }
        }
    }
    return mergedServiceStatusMap;
}
#method_after
private Map<String, GlusterServiceStatus> mergeServiceStatusMaps(List<Map<String, GlusterServiceStatus>> serviceStatusMaps) {
    Map<String, GlusterServiceStatus> mergedServiceStatusMap = new HashMap<String, GlusterServiceStatus>();
    for (Map<String, GlusterServiceStatus> serviceStatusMap : serviceStatusMaps) {
        for (Entry<String, GlusterServiceStatus> entry : serviceStatusMap.entrySet()) {
            String serviceName = entry.getKey();
            GlusterServiceStatus status = entry.getValue();
            GlusterServiceStatus alreadyFoundStatus = mergedServiceStatusMap.get(serviceName);
            if (alreadyFoundStatus == null) {
                mergedServiceStatusMap.put(serviceName, status);
            } else if (alreadyFoundStatus != status && alreadyFoundStatus != GlusterServiceStatus.MIXED) {
                GlusterServiceStatus finalStatus = getFinalStatus(status, alreadyFoundStatus);
                mergedServiceStatusMap.put(serviceName, finalStatus);
            }
        }
    }
    return mergedServiceStatusMap;
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "serial" })
private Map<String, GlusterServiceStatus> refreshServerServices(VDS server) {
    Map<String, GlusterServiceStatus> serviceStatusMap = new HashMap<String, GlusterServiceStatus>();
    acquireLock(server.getId());
    try {
        Map<Guid, GlusterServerService> existingServicesMap = getExistingServicesMap(server);
        List<GlusterServerService> servicesToUpdate = new ArrayList<GlusterServerService>();
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServicesList, new GlusterServicesListVDSParameters(server.getId(), getServiceNameMap().keySet()));
        if (!returnValue.getSucceeded()) {
            log.errorFormat("Couldn't fetch services statuses from server {0}, error: {1}! " + "Updating statuses of all services on this server to UNKNOWN.", server.getHostName(), returnValue.getVdsError().getMessage());
            logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVICES_LIST_FAILED);
            return updateStatusToUnknown(existingServicesMap.values());
        }
        for (final GlusterServerService fetchedService : (List<GlusterServerService>) returnValue.getReturnValue()) {
            serviceStatusMap.put(fetchedService.getServiceName(), fetchedService.getStatus());
            GlusterServerService existingService = existingServicesMap.get(fetchedService.getServiceId());
            if (existingService == null) {
                insertServerService(server, fetchedService);
            } else {
                final GlusterServiceStatus oldStatus = existingService.getStatus();
                final GlusterServiceStatus newStatus = fetchedService.getStatus();
                if (oldStatus != newStatus) {
                    log.infoFormat("Status of service {0} on server {1} changed from {2} to {3}. Updating in engine now.", fetchedService.getServiceName(), server.getHostName(), oldStatus.name(), newStatus.name());
                    logUtil.logAuditMessage(server.getVdsGroupId(), null, server, AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, new HashMap<String, String>() {

                        {
                            put(GlusterConstants.SERVICE_NAME, fetchedService.getServiceName());
                            put(GlusterConstants.OLD_STATUS, AuditLogDirector.getMessage(AuditLogType.valueOf("GLUSTER_SERVICE_STATUS_" + oldStatus.name())));
                            put(GlusterConstants.NEW_STATUS, AuditLogDirector.getMessage(AuditLogType.valueOf("GLUSTER_SERVICE_STATUS_" + newStatus.name())));
                        }
                    });
                    existingService.setStatus(fetchedService.getStatus());
                    servicesToUpdate.add(existingService);
                }
            }
        }
        if (servicesToUpdate.size() > 0) {
            getGlusterServerServiceDao().updateAll(servicesToUpdate);
        }
        return serviceStatusMap;
    } finally {
        releaseLock(server.getId());
    }
}
#method_after
@SuppressWarnings({ "unchecked", "serial" })
private Map<String, GlusterServiceStatus> refreshServerServices(final VDS server) {
    Map<String, GlusterServiceStatus> serviceStatusMap = new HashMap<String, GlusterServiceStatus>();
    if (server.getStatus() != VDSStatus.Up) {
        // Update the status of all the services of stopped server in single transaction
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Map<String, GlusterServiceStatus>>() {

            @Override
            public Map<String, GlusterServiceStatus> runInTransaction() {
                return updateGlusterServicesStatusForStoppedServer(server);
            }
        });
    } else {
        acquireLock(server.getId());
        try {
            Map<Guid, GlusterServerService> existingServicesMap = getExistingServicesMap(server);
            List<GlusterServerService> servicesToUpdate = new ArrayList<GlusterServerService>();
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServicesList, new GlusterServicesListVDSParameters(server.getId(), getServiceNameMap().keySet()));
            if (!returnValue.getSucceeded()) {
                log.errorFormat("Couldn't fetch services statuses from server {0}, error: {1}! " + "Updating statuses of all services on this server to UNKNOWN.", server.getHostName(), returnValue.getVdsError().getMessage());
                logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVICES_LIST_FAILED);
                return updateStatusToUnknown(existingServicesMap.values());
            }
            for (final GlusterServerService fetchedService : (List<GlusterServerService>) returnValue.getReturnValue()) {
                serviceStatusMap.put(fetchedService.getServiceName(), fetchedService.getStatus());
                GlusterServerService existingService = existingServicesMap.get(fetchedService.getServiceId());
                if (existingService == null) {
                    insertServerService(server, fetchedService);
                } else {
                    final GlusterServiceStatus oldStatus = existingService.getStatus();
                    final GlusterServiceStatus newStatus = fetchedService.getStatus();
                    if (oldStatus != newStatus) {
                        log.infoFormat("Status of service {0} on server {1} changed from {2} to {3}. Updating in engine now.", fetchedService.getServiceName(), server.getHostName(), oldStatus.name(), newStatus.name());
                        logUtil.logAuditMessage(server.getVdsGroupId(), null, server, AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, new HashMap<String, String>() {

                            {
                                put(GlusterConstants.SERVICE_NAME, fetchedService.getServiceName());
                                put(GlusterConstants.OLD_STATUS, oldStatus.getStatusMsg());
                                put(GlusterConstants.NEW_STATUS, newStatus.getStatusMsg());
                            }
                        });
                        existingService.setStatus(fetchedService.getStatus());
                        servicesToUpdate.add(existingService);
                    }
                }
            }
            if (servicesToUpdate.size() > 0) {
                getGlusterServerServiceDao().updateAll(servicesToUpdate);
            }
        } finally {
            releaseLock(server.getId());
        }
    }
    return serviceStatusMap;
}
#end_block

#method_before
@SuppressWarnings("serial")
private void insertServerService(VDS server, final GlusterServerService fetchedService) {
    fetchedService.setId(Guid.NewGuid());
    getGlusterServerServiceDao().save(fetchedService);
    log.infoFormat("Service {0} was not mapped to server {1}. Mapped it now.", fetchedService.getServiceName(), server.getHostName());
    logUtil.logAuditMessage(server.getVdsGroupId(), null, server, AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, new HashMap<String, String>() {

        {
            put(GlusterConstants.SERVICE_NAME, fetchedService.getServiceName());
        }
    });
}
#method_after
@SuppressWarnings("serial")
private void insertServerService(VDS server, final GlusterServerService fetchedService) {
    fetchedService.setId(Guid.newGuid());
    getGlusterServerServiceDao().save(fetchedService);
    log.infoFormat("Service {0} was not mapped to server {1}. Mapped it now.", fetchedService.getServiceName(), server.getHostName());
    logUtil.logAuditMessage(server.getVdsGroupId(), null, server, AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, new HashMap<String, String>() {

        {
            put(GlusterConstants.SERVICE_NAME, fetchedService.getServiceName());
        }
    });
}
#end_block

#method_before
@SuppressWarnings("serial")
private void updateClusterServiceStatus(final GlusterClusterService clusterService, final GlusterServiceStatus newStatus) {
    final GlusterServiceStatus oldStatus = clusterService.getStatus();
    clusterService.setStatus(newStatus);
    getGlusterClusterServiceDao().update(clusterService);
    log.infoFormat("Status of service type {0} changed on cluster {1} from {2} to {3}.", clusterService.getServiceType().name(), clusterService.getClusterId(), oldStatus, newStatus);
    logUtil.logAuditMessage(clusterService.getClusterId(), null, null, AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, new HashMap<String, String>() {

        {
            put(GlusterConstants.SERVICE_TYPE, clusterService.getServiceType().name());
            put(GlusterConstants.OLD_STATUS, AuditLogDirector.getMessage(AuditLogType.valueOf("GLUSTER_SERVICE_STATUS_" + oldStatus.name())));
            put(GlusterConstants.NEW_STATUS, AuditLogDirector.getMessage(AuditLogType.valueOf("GLUSTER_SERVICE_STATUS_" + newStatus.name())));
        }
    });
}
#method_after
@SuppressWarnings("serial")
private void updateClusterServiceStatus(final GlusterClusterService clusterService, final GlusterServiceStatus newStatus) {
    final GlusterServiceStatus oldStatus = clusterService.getStatus();
    clusterService.setStatus(newStatus);
    getGlusterClusterServiceDao().update(clusterService);
    log.infoFormat("Status of service type {0} changed on cluster {1} from {2} to {3}.", clusterService.getServiceType().name(), clusterService.getClusterId(), oldStatus, newStatus);
    logUtil.logAuditMessage(clusterService.getClusterId(), null, null, AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, new HashMap<String, String>() {

        {
            put(GlusterConstants.SERVICE_TYPE, clusterService.getServiceType().name());
            put(GlusterConstants.OLD_STATUS, oldStatus.getStatusMsg());
            put(GlusterConstants.NEW_STATUS, newStatus.getStatusMsg());
        }
    });
}
#end_block

#method_before
@SuppressWarnings("serial")
private GlusterClusterService addClusterServiceToDb(VDSGroup cluster, final ServiceType serviceType, final GlusterServiceStatus status) {
    GlusterClusterService clusterService = new GlusterClusterService();
    clusterService.setClusterId(cluster.getId());
    clusterService.setServiceType(serviceType);
    clusterService.setStatus(status);
    getGlusterClusterServiceDao().save(clusterService);
    log.infoFormat("Service type {0} not mapped to cluster {1}. Mapped it now.", serviceType, cluster.getname());
    logUtil.logAuditMessage(clusterService.getClusterId(), null, null, AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, new HashMap<String, String>() {

        {
            put(GlusterConstants.SERVICE_TYPE, serviceType.name());
            put(GlusterConstants.NEW_STATUS, AuditLogDirector.getMessage(AuditLogType.valueOf("GLUSTER_SERVICE_STATUS_" + status.name())));
        }
    });
    return clusterService;
}
#method_after
@SuppressWarnings("serial")
private GlusterClusterService addClusterServiceToDb(VDSGroup cluster, final ServiceType serviceType, final GlusterServiceStatus status) {
    GlusterClusterService clusterService = new GlusterClusterService();
    clusterService.setClusterId(cluster.getId());
    clusterService.setServiceType(serviceType);
    clusterService.setStatus(status);
    getGlusterClusterServiceDao().save(clusterService);
    log.infoFormat("Service type {0} not mapped to cluster {1}. Mapped it now.", serviceType, cluster.getName());
    logUtil.logAuditMessage(clusterService.getClusterId(), null, null, AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, new HashMap<String, String>() {

        {
            put(GlusterConstants.SERVICE_TYPE, serviceType.name());
            put(GlusterConstants.NEW_STATUS, status.getStatusMsg());
        }
    });
    return clusterService;
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshLightWeightData")
public void refreshLightWeightData() {
    log.debug("Refreshing Gluster Data [lightweight]");
    List<VDSGroup> clusters = getClusterDao().getAll();
    for (VDSGroup cluster : clusters) {
        if (cluster.supportsGlusterService()) {
            try {
                refreshClusterData(cluster);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing Gluster lightweight data of cluster {0}!", cluster.getname(), e);
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("refreshLightWeightData")
public void refreshLightWeightData() {
    log.debug("Refreshing Gluster Data [lightweight]");
    List<VDSGroup> clusters = getClusterDao().getAll();
    for (VDSGroup cluster : clusters) {
        if (cluster.supportsGlusterService()) {
            try {
                refreshClusterData(cluster);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing Gluster lightweight data of cluster {0}!", cluster.getName(), e);
            }
        }
    }
}
#end_block

#method_before
private void refreshClusterData(VDSGroup cluster) {
    log.debugFormat("Refreshing Gluster lightweight Data for cluster {0}", cluster.getname());
    List<VDS> existingServers = getVdsDao().getAllForVdsGroup(cluster.getId());
    VDS upServer = getClusterUtils().getUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getname());
        return;
    }
    refreshServerData(cluster, upServer, existingServers);
    refreshVolumeData(cluster, upServer, existingServers);
}
#method_after
private void refreshClusterData(VDSGroup cluster) {
    log.debugFormat("Refreshing Gluster lightweight Data for cluster {0}", cluster.getName());
    List<VDS> existingServers = getVdsDao().getAllForVdsGroup(cluster.getId());
    VDS upServer = getClusterUtils().getUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    refreshServerData(cluster, upServer, existingServers);
    refreshVolumeData(cluster, upServer, existingServers);
}
#end_block

#method_before
private void refreshServerData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    if (cluster.supportsVirtService()) {
        // If the cluster supports virt service as well, we should not be removing any servers from it, even if they
        // have been removed from the Gluster cluster using the Gluster cli, as they could potentially be used for
        // running VMs
        log.debugFormat("As cluster {0} supports virt service as well, it's servers will not be synced with glusterfs", cluster.getname());
        return;
    }
    acquireLock(cluster.getId());
    try {
        List<GlusterServerInfo> fetchedServers = fetchServers(cluster, upServer, existingServers);
        if (fetchedServers != null) {
            removeDetachedServers(existingServers, fetchedServers);
        }
    } finally {
        releaseLock(cluster.getId());
    }
}
#method_after
private void refreshServerData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    if (cluster.supportsVirtService()) {
        // If the cluster supports virt service as well, we should not be removing any servers from it, even if they
        // have been removed from the Gluster cluster using the Gluster cli, as they could potentially be used for
        // running VMs
        log.debugFormat("As cluster {0} supports virt service as well, it's servers will not be synced with glusterfs", cluster.getName());
        return;
    }
    acquireLock(cluster.getId());
    try {
        List<GlusterServerInfo> fetchedServers = fetchServers(cluster, upServer, existingServers);
        if (fetchedServers != null) {
            removeDetachedServers(existingServers, fetchedServers);
        }
    } finally {
        releaseLock(cluster.getId());
    }
}
#end_block

#method_before
private void removeDetachedServers(List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) {
    for (final VDS server : existingServers) {
        if (isRemovableStatus(server.getStatus()) && serverDetached(server, fetchedServers)) {
            log.debugFormat("Server {0} has been removed directly using the gluster CLI. Removing it from engine as well.", server.getName());
            logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
            logUtil.logAuditMessage(server.getVdsGroupId(), null, server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, new HashMap<String, String>() {

                {
                    put(GlusterConstants.VDS_GROUP_NAME, server.getVdsGroupName());
                }
            });
            try {
                removeServerFromDb(server);
                // remove the server from resource manager
                runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
            } catch (Exception e) {
                log.errorFormat("Error while removing server {0} from database!", server.getName(), e);
            }
        }
    }
}
#method_after
private void removeDetachedServers(List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) {
    for (VDS server : existingServers) {
        if (isRemovableStatus(server.getStatus()) && serverDetached(server, fetchedServers)) {
            log.debugFormat("Server {0} has been removed directly using the gluster CLI. Removing it from engine as well.", server.getName());
            logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
            try {
                removeServerFromDb(server);
                // remove the server from resource manager
                runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
            } catch (Exception e) {
                log.errorFormat("Error while removing server {0} from database!", server.getName(), e);
            }
        }
    }
}
#end_block

#method_before
private List<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    // Create a copy of the existing servers as the fetchServer method can potentially remove elements from it
    List<VDS> tempServers = new ArrayList<VDS>(existingServers);
    List<GlusterServerInfo> fetchedServers = fetchServers(upServer, tempServers);
    if (fetchedServers == null) {
        log.errorFormat("gluster peer status command failed on all servers of the cluster {0}." + "Can't refresh it's data at this point.", cluster.getname());
        return null;
    }
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (server.getHostnameOrIp().equals(upServer.getHostName()) || getVdsIps(upServer).contains(server.getHostnameOrIp())) {
            // Find a different UP server, and get servers list from it
            tempServers.remove(upServer);
            upServer = getNewUpServer(tempServers, upServer);
            if (upServer == null) {
                log.warnFormat("The only UP server in cluster {0} seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getname());
                return null;
            }
            fetchedServers = fetchServers(upServer, tempServers);
            if (fetchedServers == null) {
                log.warnFormat("The only UP server in cluster {0} (or the only one on which gluster peer status " + "command is working) seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getname());
                return null;
            }
        }
    }
    return fetchedServers;
}
#method_after
private List<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    // Create a copy of the existing servers as the fetchServer method can potentially remove elements from it
    List<VDS> tempServers = new ArrayList<VDS>(existingServers);
    List<GlusterServerInfo> fetchedServers = fetchServers(upServer, tempServers);
    if (fetchedServers == null) {
        log.errorFormat("gluster peer status command failed on all servers of the cluster {0}." + "Can't refresh it's data at this point.", cluster.getName());
        return null;
    }
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (server.getHostnameOrIp().equals(upServer.getHostName()) || getVdsIps(upServer).contains(server.getHostnameOrIp())) {
            // Find a different UP server, and get servers list from it
            tempServers.remove(upServer);
            upServer = getNewUpServer(tempServers, upServer);
            if (upServer == null) {
                log.warnFormat("The only UP server in cluster {0} seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getName());
                return null;
            }
            fetchedServers = fetchServers(upServer, tempServers);
            if (fetchedServers == null) {
                log.warnFormat("The only UP server in cluster {0} (or the only one on which gluster peer status " + "command is working) seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getName());
                return null;
            }
        }
    }
    return fetchedServers;
}
#end_block

#method_before
private void setNonOperational(VDS server) {
    SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED);
    nonOpParams.setSaveToDb(true);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
}
#method_after
private void setNonOperational(VDS server) {
    SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED, Collections.singletonMap(GlusterConstants.COMMAND, "gluster peer probe"));
    nonOpParams.setSaveToDb(true);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
private void refreshVolumeData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    acquireLock(cluster.getId());
    try {
        // Pass a copy of the existing servers as the fetchVolumes method can potentially remove elements from it
        Map<Guid, GlusterVolumeEntity> volumesMap = fetchVolumes(upServer, new ArrayList<VDS>(existingServers));
        if (volumesMap == null) {
            log.errorFormat("gluster volume info command failed on all servers of the cluster {0}." + "Can't refresh it's data at this point.", cluster.getname());
            return;
        }
        // remove deleted volumes must happen before adding new ones,
        // to handle cases where user deleted a volume and created a
        // new one with same name in a very short time
        removeDeletedVolumes(cluster.getId(), volumesMap);
        updateExistingAndNewVolumes(cluster.getId(), volumesMap);
    } finally {
        releaseLock(cluster.getId());
    }
}
#method_after
private void refreshVolumeData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    acquireLock(cluster.getId());
    try {
        // Pass a copy of the existing servers as the fetchVolumes method can potentially remove elements from it
        Map<Guid, GlusterVolumeEntity> volumesMap = fetchVolumes(upServer, new ArrayList<VDS>(existingServers));
        if (volumesMap == null) {
            log.errorFormat("gluster volume info command failed on all servers of the cluster {0}." + "Can't refresh it's data at this point.", cluster.getName());
            return;
        }
        // remove deleted volumes must happen before adding new ones,
        // to handle cases where user deleted a volume and created a
        // new one with same name in a very short time
        removeDeletedVolumes(cluster.getId(), volumesMap);
        updateExistingAndNewVolumes(cluster.getId(), volumesMap);
    } finally {
        releaseLock(cluster.getId());
    }
}
#end_block

#method_before
@SuppressWarnings("serial")
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (final GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            idsToRemove.add(existingOption.getId());
            log.infoFormat("Detected option {0} reset on volume {1}. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            // Hence it is not required to log it as a removed option, as that would be misleading.
            if (!GlusterConstants.OPTION_GROUP.equals(existingOption.getKey())) {
                logUtil.logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, new HashMap<String, String>() {

                    {
                        put(GlusterConstants.OPTION_KEY, existingOption.getKey());
                    }
                });
            }
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getOptionDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.errorFormat("Error while removing options of volume {0} from database!", fetchedVolume.getName(), e);
        }
    }
}
#method_after
@SuppressWarnings("serial")
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (final GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            idsToRemove.add(existingOption.getId());
            log.infoFormat("Detected option {0} reset on volume {1}. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            // Hence it is not required to log it as a removed option, as that would be misleading.
            if (!GlusterConstants.OPTION_GROUP.equals(existingOption.getKey())) {
                logUtil.logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, new HashMap<String, String>() {

                    {
                        put(GlusterConstants.OPTION_KEY, existingOption.getKey());
                        put(GlusterConstants.OPTION_VALUE, existingOption.getValue());
                    }
                });
            }
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getOptionDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.errorFormat("Error while removing options of volume {0} from database!", fetchedVolume.getName(), e);
        }
    }
}
#end_block

#method_before
@SuppressWarnings("serial")
private void updateExistingAndNewOptions(GlusterVolumeEntity existingVolume, Collection<GlusterVolumeOptionEntity> fetchedOptions) {
    for (final GlusterVolumeOptionEntity fetchedOption : fetchedOptions) {
        final GlusterVolumeOptionEntity existingOption = existingVolume.getOption(fetchedOption.getKey());
        if (existingOption == null) {
            logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, new HashMap<String, String>() {

                {
                    put(GlusterConstants.OPTION_KEY, fetchedOption.getKey());
                    put(GlusterConstants.OPTION_VALUE, fetchedOption.getValue());
                }
            });
            log.infoFormat("New option {0}={1} set on volume {2} from gluster CLI. Updating engine DB accordingly.", fetchedOption.getKey(), fetchedOption.getValue(), existingVolume.getName());
            try {
                getOptionDao().save(fetchedOption);
            } catch (Exception e) {
                log.errorFormat("Could not save option {0} of volume {1) to database!", fetchedOption, existingVolume.getName(), e);
            }
        } else if (!existingOption.getValue().equals(fetchedOption.getValue())) {
            logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_CHANGED_FROM_CLI, new HashMap<String, String>() {

                {
                    put(GlusterConstants.OPTION_KEY, existingOption.getKey());
                    put(GlusterConstants.OPTION_OLD_VALUE, existingOption.getValue());
                    put(GlusterConstants.OPTION_NEW_VALUE, fetchedOption.getValue());
                }
            });
            log.infoFormat("Detected change in value of option {0} of volume {1} from {2} to {3}. Updating engine DB accordingly.", existingOption.getKey(), existingVolume.getName(), existingOption.getValue(), fetchedOption.getValue());
            try {
                getOptionDao().updateVolumeOption(existingOption.getId(), fetchedOption.getValue());
            } catch (Exception e) {
                log.errorFormat("Error while updating option {0} of volume {1} in database!", fetchedOption, existingVolume.getName(), e);
            }
        }
    }
}
#method_after
private void updateExistingAndNewOptions(final GlusterVolumeEntity existingVolume, Collection<GlusterVolumeOptionEntity> fetchedOptions) {
    Map<String, GlusterVolumeOptionEntity> existingOptions = new HashMap<>();
    Map<String, GlusterVolumeOptionEntity> newOptions = new HashMap<>();
    for (final GlusterVolumeOptionEntity fetchedOption : fetchedOptions) {
        final GlusterVolumeOptionEntity existingOption = existingVolume.getOption(fetchedOption.getKey());
        if (existingOption == null) {
            newOptions.put(fetchedOption.getKey(), fetchedOption);
        } else if (!existingOption.getValue().equals(fetchedOption.getValue())) {
            fetchedOption.setId(existingOption.getId());
            existingOptions.put(fetchedOption.getKey(), fetchedOption);
        }
    }
    final List<GlusterVolumeOptionEntity> newOptionsSortedList = new ArrayList<GlusterVolumeOptionEntity>(newOptions.values());
    final List<GlusterVolumeOptionEntity> existingOptionsSortedList = new ArrayList<GlusterVolumeOptionEntity>(existingOptions.values());
    Collections.sort(newOptionsSortedList);
    Collections.sort(existingOptionsSortedList);
    // Insert the new options in a single transaction
    if (!newOptionsSortedList.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveNewOptions(existingVolume, newOptionsSortedList);
                return null;
            }
        });
    }
    // Update the existing options in a single transaction
    if (!existingOptionsSortedList.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                updateExistingOptions(existingVolume, existingOptionsSortedList);
                return null;
            }
        });
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshHeavyWeightData")
public void refreshHeavyWeightData() {
    log.debug("Refreshing Gluster Data [heavyweight]");
    for (VDSGroup cluster : getClusterDao().getAll()) {
        if (GlusterFeatureSupported.refreshHeavyWeight(cluster.getcompatibility_version()) && cluster.supportsGlusterService()) {
            try {
                refreshClusterHeavyWeightData(cluster);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing Gluster heavyweight data of cluster {0}!", cluster.getname(), e);
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("refreshHeavyWeightData")
public void refreshHeavyWeightData() {
    log.debug("Refreshing Gluster Data [heavyweight]");
    for (VDSGroup cluster : getClusterDao().getAll()) {
        if (GlusterFeatureSupported.refreshHeavyWeight(cluster.getcompatibility_version()) && cluster.supportsGlusterService()) {
            try {
                refreshClusterHeavyWeightData(cluster);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing Gluster heavyweight data of cluster {0}!", cluster.getName(), e);
            }
        }
    }
}
#end_block

#method_before
private void refreshClusterHeavyWeightData(VDSGroup cluster) {
    VDS upServer = getClusterUtils().getUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getname());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debugFormat("Refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getname());
        // brick statuses can be fetched only for started volumes
        if (volume.isOnline()) {
            acquireLock(cluster.getId());
            try {
                refreshBrickStatuses(upServer, volume);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getname(), e);
            } finally {
                releaseLock(cluster.getId());
            }
        }
    }
}
#method_after
private void refreshClusterHeavyWeightData(VDSGroup cluster) {
    VDS upServer = getClusterUtils().getUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debugFormat("Refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getName());
        // brick statuses can be fetched only for started volumes
        if (volume.isOnline()) {
            acquireLock(cluster.getId());
            try {
                refreshBrickStatuses(upServer, volume);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getName(), e);
            } finally {
                releaseLock(cluster.getId());
            }
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshGlusterServices")
public void refreshGlusterServices() {
    if (getServiceNameMap().isEmpty()) {
        // Lazy loading. Keeping this out of the constructor/getInstance
        // helps in writing the JUnit test as well.
        populateServiceMap();
    }
    List<VDSGroup> clusters = getClusterDao().getAll();
    for (VDSGroup cluster : clusters) {
        if (supportsGlusterServicesFeature(cluster)) {
            try {
                List<VDS> upServers = getClusterUtils().getAllUpServers(cluster.getId());
                List<VDS> servers = getClusterUtils().getAllServers(cluster.getId());
                // Update the service status on servers which are not UP
                List<Callable<Map<String, GlusterServiceStatus>>> taskListForNonRunningServers = createTaskListForNonRunningServers(servers);
                if (taskListForNonRunningServers != null && taskListForNonRunningServers.size() > 0) {
                    ThreadPoolUtil.invokeAll(taskListForNonRunningServers);
                }
                // Update the service status on servers which are UP
                log.debugFormat("Syncing gluster related services for cluster {0}", cluster.getname());
                List<Callable<Map<String, GlusterServiceStatus>>> taskList = createTaskList(upServers);
                if (taskList != null && taskList.size() > 0) {
                    refreshClusterServices(cluster, ThreadPoolUtil.invokeAll(createTaskList(upServers)));
                }
            } catch (Exception e) {
                log.errorFormat("Error while refreshing service statuses of cluster {0}!", cluster.getname(), e);
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("refreshGlusterServices")
public void refreshGlusterServices() {
    if (getServiceNameMap().isEmpty()) {
        // Lazy loading. Keeping this out of the constructor/getInstance
        // helps in writing the JUnit test as well.
        populateServiceMap();
    }
    List<VDSGroup> clusters = getClusterDao().getAll();
    for (VDSGroup cluster : clusters) {
        if (supportsGlusterServicesFeature(cluster)) {
            try {
                List<VDS> serversList = getClusterUtils().getAllServers(cluster.getId());
                List<Callable<Map<String, GlusterServiceStatus>>> taskList = createTaskList(serversList);
                if (taskList != null && taskList.size() > 0) {
                    refreshClusterServices(cluster, ThreadPoolUtil.invokeAll(taskList));
                }
            } catch (Exception e) {
                log.errorFormat("Error while refreshing service statuses of cluster {0}!", cluster.getName(), e);
            }
        }
    }
}
#end_block

#method_before
private List<Callable<Map<String, GlusterServiceStatus>>> createTaskList(List<VDS> upServers) {
    List<Callable<Map<String, GlusterServiceStatus>>> taskList = new ArrayList<Callable<Map<String, GlusterServiceStatus>>>();
    for (final VDS upServer : upServers) {
        taskList.add(new Callable<Map<String, GlusterServiceStatus>>() {

            /**
             * Fetches and updates status of all services of the given server, <br>
             * and returns a map having key = service name and value = service status
             */
            @Override
            public Map<String, GlusterServiceStatus> call() throws Exception {
                return refreshServerServices(upServer);
            }
        });
    }
    return taskList;
}
#method_after
private List<Callable<Map<String, GlusterServiceStatus>>> createTaskList(List<VDS> serversList) {
    List<Callable<Map<String, GlusterServiceStatus>>> taskList = new ArrayList<Callable<Map<String, GlusterServiceStatus>>>();
    for (final VDS server : serversList) {
        taskList.add(new Callable<Map<String, GlusterServiceStatus>>() {

            /**
             * Fetches and updates status of all services of the given server, <br>
             * and returns a map having key = service name and value = service status
             */
            @Override
            public Map<String, GlusterServiceStatus> call() throws Exception {
                return refreshServerServices(server);
            }
        });
    }
    return taskList;
}
#end_block

#method_before
private Map<ServiceType, GlusterServiceStatus> createServiceTypeStatusMap(List<Map<String, GlusterServiceStatus>> serviceStatusMaps) {
    Map<ServiceType, GlusterServiceStatus> fetchedServiceTypeStatusMap = new HashMap<ServiceType, GlusterServiceStatus>();
    for (Entry<String, GlusterServiceStatus> entry : mergeServiceStatusMaps(serviceStatusMaps).entrySet()) {
        String serviceName = entry.getKey();
        GlusterServiceStatus status = entry.getValue();
        ServiceType type = getServiceNameMap().get(serviceName).getServiceType();
        GlusterServiceStatus foundStatus = fetchedServiceTypeStatusMap.get(type);
        if (foundStatus == null) {
            fetchedServiceTypeStatusMap.put(type, status);
        } else if (foundStatus != status) {
            fetchedServiceTypeStatusMap.put(type, GlusterServiceStatus.MIXED);
        }
    }
    return fetchedServiceTypeStatusMap;
}
#method_after
private Map<ServiceType, GlusterServiceStatus> createServiceTypeStatusMap(List<Map<String, GlusterServiceStatus>> serviceStatusMaps) {
    Map<ServiceType, GlusterServiceStatus> fetchedServiceTypeStatusMap = new HashMap<ServiceType, GlusterServiceStatus>();
    for (Entry<String, GlusterServiceStatus> entry : mergeServiceStatusMaps(serviceStatusMaps).entrySet()) {
        String serviceName = entry.getKey();
        GlusterServiceStatus status = entry.getValue();
        ServiceType type = getServiceNameMap().get(serviceName).getServiceType();
        GlusterServiceStatus foundStatus = fetchedServiceTypeStatusMap.get(type);
        if (foundStatus == null) {
            fetchedServiceTypeStatusMap.put(type, status);
        } else if (foundStatus != status) {
            GlusterServiceStatus finalStatus = getFinalStatus(status, foundStatus);
            fetchedServiceTypeStatusMap.put(type, finalStatus);
        }
    }
    return fetchedServiceTypeStatusMap;
}
#end_block

#method_before
private Map<String, GlusterServiceStatus> mergeServiceStatusMaps(List<Map<String, GlusterServiceStatus>> serviceStatusMaps) {
    Map<String, GlusterServiceStatus> mergedServiceStatusMap = new HashMap<String, GlusterServiceStatus>();
    for (Map<String, GlusterServiceStatus> serviceStatusMap : serviceStatusMaps) {
        for (Entry<String, GlusterServiceStatus> entry : serviceStatusMap.entrySet()) {
            String serviceName = entry.getKey();
            GlusterServiceStatus status = entry.getValue();
            GlusterServiceStatus alreadyFoundStatus = mergedServiceStatusMap.get(serviceName);
            if (alreadyFoundStatus == null) {
                mergedServiceStatusMap.put(serviceName, status);
            } else if (alreadyFoundStatus != status && alreadyFoundStatus != GlusterServiceStatus.MIXED) {
                mergedServiceStatusMap.put(serviceName, GlusterServiceStatus.MIXED);
            }
        }
    }
    return mergedServiceStatusMap;
}
#method_after
private Map<String, GlusterServiceStatus> mergeServiceStatusMaps(List<Map<String, GlusterServiceStatus>> serviceStatusMaps) {
    Map<String, GlusterServiceStatus> mergedServiceStatusMap = new HashMap<String, GlusterServiceStatus>();
    for (Map<String, GlusterServiceStatus> serviceStatusMap : serviceStatusMaps) {
        for (Entry<String, GlusterServiceStatus> entry : serviceStatusMap.entrySet()) {
            String serviceName = entry.getKey();
            GlusterServiceStatus status = entry.getValue();
            GlusterServiceStatus alreadyFoundStatus = mergedServiceStatusMap.get(serviceName);
            if (alreadyFoundStatus == null) {
                mergedServiceStatusMap.put(serviceName, status);
            } else if (alreadyFoundStatus != status && alreadyFoundStatus != GlusterServiceStatus.MIXED) {
                GlusterServiceStatus finalStatus = getFinalStatus(status, alreadyFoundStatus);
                mergedServiceStatusMap.put(serviceName, finalStatus);
            }
        }
    }
    return mergedServiceStatusMap;
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "serial" })
private Map<String, GlusterServiceStatus> refreshServerServices(VDS server) {
    Map<String, GlusterServiceStatus> serviceStatusMap = new HashMap<String, GlusterServiceStatus>();
    acquireLock(server.getId());
    try {
        Map<Guid, GlusterServerService> existingServicesMap = getExistingServicesMap(server);
        List<GlusterServerService> servicesToUpdate = new ArrayList<GlusterServerService>();
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServicesList, new GlusterServicesListVDSParameters(server.getId(), getServiceNameMap().keySet()));
        if (!returnValue.getSucceeded()) {
            log.errorFormat("Couldn't fetch services statuses from server {0}, error: {1}! " + "Updating statuses of all services on this server to UNKNOWN.", server.getHostName(), returnValue.getVdsError().getMessage());
            logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVICES_LIST_FAILED);
            return updateStatusToUnknown(existingServicesMap.values());
        }
        for (final GlusterServerService fetchedService : (List<GlusterServerService>) returnValue.getReturnValue()) {
            serviceStatusMap.put(fetchedService.getServiceName(), fetchedService.getStatus());
            GlusterServerService existingService = existingServicesMap.get(fetchedService.getServiceId());
            if (existingService == null) {
                insertServerService(server, fetchedService);
            } else {
                final GlusterServiceStatus oldStatus = existingService.getStatus();
                final GlusterServiceStatus newStatus = fetchedService.getStatus();
                if (oldStatus != newStatus) {
                    log.infoFormat("Status of service {0} on server {1} changed from {2} to {3}. Updating in engine now.", fetchedService.getServiceName(), server.getHostName(), oldStatus.name(), newStatus.name());
                    logUtil.logAuditMessage(server.getVdsGroupId(), null, server, AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, new HashMap<String, String>() {

                        {
                            put(GlusterConstants.SERVICE_NAME, fetchedService.getServiceName());
                            put(GlusterConstants.OLD_STATUS, oldStatus.name());
                            put(GlusterConstants.NEW_STATUS, newStatus.name());
                        }
                    });
                    existingService.setStatus(fetchedService.getStatus());
                    servicesToUpdate.add(existingService);
                }
            }
        }
        if (servicesToUpdate.size() > 0) {
            getGlusterServerServiceDao().updateAll(servicesToUpdate);
        }
        return serviceStatusMap;
    } finally {
        releaseLock(server.getId());
    }
}
#method_after
@SuppressWarnings({ "unchecked", "serial" })
private Map<String, GlusterServiceStatus> refreshServerServices(final VDS server) {
    Map<String, GlusterServiceStatus> serviceStatusMap = new HashMap<String, GlusterServiceStatus>();
    if (server.getStatus() != VDSStatus.Up) {
        // Update the status of all the services of stopped server in single transaction
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Map<String, GlusterServiceStatus>>() {

            @Override
            public Map<String, GlusterServiceStatus> runInTransaction() {
                return updateGlusterServicesStatusForStoppedServer(server);
            }
        });
    } else {
        acquireLock(server.getId());
        try {
            Map<Guid, GlusterServerService> existingServicesMap = getExistingServicesMap(server);
            List<GlusterServerService> servicesToUpdate = new ArrayList<GlusterServerService>();
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServicesList, new GlusterServicesListVDSParameters(server.getId(), getServiceNameMap().keySet()));
            if (!returnValue.getSucceeded()) {
                log.errorFormat("Couldn't fetch services statuses from server {0}, error: {1}! " + "Updating statuses of all services on this server to UNKNOWN.", server.getHostName(), returnValue.getVdsError().getMessage());
                logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVICES_LIST_FAILED);
                return updateStatusToUnknown(existingServicesMap.values());
            }
            for (final GlusterServerService fetchedService : (List<GlusterServerService>) returnValue.getReturnValue()) {
                serviceStatusMap.put(fetchedService.getServiceName(), fetchedService.getStatus());
                GlusterServerService existingService = existingServicesMap.get(fetchedService.getServiceId());
                if (existingService == null) {
                    insertServerService(server, fetchedService);
                } else {
                    final GlusterServiceStatus oldStatus = existingService.getStatus();
                    final GlusterServiceStatus newStatus = fetchedService.getStatus();
                    if (oldStatus != newStatus) {
                        log.infoFormat("Status of service {0} on server {1} changed from {2} to {3}. Updating in engine now.", fetchedService.getServiceName(), server.getHostName(), oldStatus.name(), newStatus.name());
                        logUtil.logAuditMessage(server.getVdsGroupId(), null, server, AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, new HashMap<String, String>() {

                            {
                                put(GlusterConstants.SERVICE_NAME, fetchedService.getServiceName());
                                put(GlusterConstants.OLD_STATUS, oldStatus.name());
                                put(GlusterConstants.NEW_STATUS, newStatus.name());
                            }
                        });
                        existingService.setStatus(fetchedService.getStatus());
                        servicesToUpdate.add(existingService);
                    }
                }
            }
            if (servicesToUpdate.size() > 0) {
                getGlusterServerServiceDao().updateAll(servicesToUpdate);
            }
        } finally {
            releaseLock(server.getId());
        }
    }
    return serviceStatusMap;
}
#end_block

#method_before
@SuppressWarnings("serial")
private void insertServerService(VDS server, final GlusterServerService fetchedService) {
    fetchedService.setId(Guid.NewGuid());
    getGlusterServerServiceDao().save(fetchedService);
    log.infoFormat("Service {0} was not mapped to server {1}. Mapped it now.", fetchedService.getServiceName(), server.getHostName());
    logUtil.logAuditMessage(server.getVdsGroupId(), null, server, AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, new HashMap<String, String>() {

        {
            put(GlusterConstants.SERVICE_NAME, fetchedService.getServiceName());
        }
    });
}
#method_after
@SuppressWarnings("serial")
private void insertServerService(VDS server, final GlusterServerService fetchedService) {
    fetchedService.setId(Guid.newGuid());
    getGlusterServerServiceDao().save(fetchedService);
    log.infoFormat("Service {0} was not mapped to server {1}. Mapped it now.", fetchedService.getServiceName(), server.getHostName());
    logUtil.logAuditMessage(server.getVdsGroupId(), null, server, AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, new HashMap<String, String>() {

        {
            put(GlusterConstants.SERVICE_NAME, fetchedService.getServiceName());
        }
    });
}
#end_block

#method_before
@SuppressWarnings("serial")
private GlusterClusterService addClusterServiceToDb(VDSGroup cluster, final ServiceType serviceType, GlusterServiceStatus status) {
    GlusterClusterService clusterService = new GlusterClusterService();
    clusterService.setClusterId(cluster.getId());
    clusterService.setServiceType(serviceType);
    clusterService.setStatus(status);
    getGlusterClusterServiceDao().save(clusterService);
    log.infoFormat("Service type {0} not mapped to cluster {1}. Mapped it now.", serviceType, cluster.getname());
    logUtil.logAuditMessage(clusterService.getClusterId(), null, null, AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, new HashMap<String, String>() {

        {
            put(GlusterConstants.SERVICE_TYPE, serviceType.name());
        }
    });
    return clusterService;
}
#method_after
@SuppressWarnings("serial")
private GlusterClusterService addClusterServiceToDb(VDSGroup cluster, final ServiceType serviceType, GlusterServiceStatus status) {
    GlusterClusterService clusterService = new GlusterClusterService();
    clusterService.setClusterId(cluster.getId());
    clusterService.setServiceType(serviceType);
    clusterService.setStatus(status);
    getGlusterClusterServiceDao().save(clusterService);
    log.infoFormat("Service type {0} not mapped to cluster {1}. Mapped it now.", serviceType, cluster.getName());
    logUtil.logAuditMessage(clusterService.getClusterId(), null, null, AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, new HashMap<String, String>() {

        {
            put(GlusterConstants.SERVICE_TYPE, serviceType.name());
        }
    });
    return clusterService;
}
#end_block

#method_before
@Override
public NGuid getStorageDomainId() {
    NGuid storageDomainId = super.getStorageDomainId();
    if (Guid.Empty.equals(storageDomainId) || storageDomainId == null) {
        List<StorageDomain> storagesInPool = LinqUtils.filter(DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(getStoragePoolId().getValue()), new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain a) {
                return (a.getStorageDomainType() != StorageDomainType.ISO && a.getStorageDomainType() != StorageDomainType.ImportExport) && (a.getStatus() != null) && (a.getStatus() == StorageDomainStatus.Active);
            }
        });
        storageDomainId = (storagesInPool.size() > 0) ? storagesInPool.get(0).getId() : Guid.Empty;
        getParameters().setStorageDomainId(storageDomainId.getValue());
        setStorageDomainId(storageDomainId);
    }
    return storageDomainId;
}
#method_after
@Override
public Guid getStorageDomainId() {
    Guid storageDomainId = super.getStorageDomainId();
    if (Guid.Empty.equals(storageDomainId) || storageDomainId == null) {
        List<StorageDomain> storagesInPool = LinqUtils.filter(DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(getStoragePoolId()), new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain a) {
                return (a.getStorageDomainType() != StorageDomainType.ISO && a.getStorageDomainType() != StorageDomainType.ImportExport) && (a.getStatus() != null) && (a.getStatus() == StorageDomainStatus.Active);
            }
        });
        storageDomainId = (storagesInPool.size() > 0) ? storagesInPool.get(0).getId() : Guid.Empty;
        getParameters().setStorageDomainId(storageDomainId);
        setStorageDomainId(storageDomainId);
    }
    return storageDomainId;
}
#end_block

#method_before
protected boolean ConcreteAddVmImages(Guid itGuid) {
    boolean ret = true;
    if (getVmDisks().size() > 0) {
        for (Disk diskInfo : getVmDisks()) {
            VdcReturnValueBase tmpRetValue = null;
            AddImageFromScratchParameters tempVar = new AddImageFromScratchParameters(itGuid, getParameters().getVmStaticData().getId(), (DiskImage) diskInfo);
            tempVar.setStorageDomainId(this.getStorageDomainId().getValue());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVmFromScratch);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParameters(getParameters());
            tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (!tmpRetValue.getSucceeded()) {
                log.error("AddVmFromScratchCommand::ConcreteAddVmImages: AddImageFromScratch Command failed.");
                ret = false;
            } else // the AddImageFromScratch task created ended successfully:
            {
                getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
            }
        }
        VmHandler.LockVm(getParameters().getVmStaticData().getId());
    } else {
        // if no disks send update vm here
        getVmStaticDao().incrementDbGeneration(getVm().getId());
    }
    return ret;
}
#method_after
protected boolean ConcreteAddVmImages(Guid itGuid) {
    boolean ret = true;
    if (getVmDisks().size() > 0) {
        for (Disk diskInfo : getVmDisks()) {
            VdcReturnValueBase tmpRetValue = null;
            AddImageFromScratchParameters tempVar = new AddImageFromScratchParameters(itGuid, getParameters().getVmStaticData().getId(), (DiskImage) diskInfo);
            tempVar.setStorageDomainId(this.getStorageDomainId());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVmFromScratch);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParameters(getParameters());
            tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (!tmpRetValue.getSucceeded()) {
                log.error("AddVmFromScratchCommand::ConcreteAddVmImages: AddImageFromScratch Command failed.");
                ret = false;
            } else // the AddImageFromScratch task created ended successfully:
            {
                getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
            }
        }
        VmHandler.LockVm(getParameters().getVmStaticData().getId());
    } else {
        // if no disks send update vm here
        getVmStaticDao().incrementDbGeneration(getVm().getId());
    }
    return ret;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null && Guid.Empty.equals(super.getStorageDomainId())) {
        return failCanDoAction(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
    }
    if (!ImagesHandler.CheckImagesConfiguration(getStorageDomainId().getValue(), getParameters().getDiskInfoList(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null && Guid.Empty.equals(super.getStorageDomainId())) {
        return failCanDoAction(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
    }
    if (!ImagesHandler.CheckImagesConfiguration(getStorageDomainId(), getParameters().getDiskInfoList(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return super.canDoAction();
}
#end_block

#method_before
protected void initStoragePoolId() {
    if (getVdsGroup() != null) {
        setStoragePoolId(getVdsGroup().getStoragePoolId() != null ? getVdsGroup().getStoragePoolId().getValue() : Guid.Empty);
    }
}
#method_after
protected void initStoragePoolId() {
    if (getVdsGroup() != null) {
        setStoragePoolId(getVdsGroup().getStoragePoolId() != null ? getVdsGroup().getStoragePoolId() : Guid.Empty);
    }
}
#end_block

#method_before
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId().getValue(), vmStaticFromParams.getPriority());
    if (returnValue) {
        List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    // check that template image and vm are on the same storage pool
    if (returnValue && shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else {
            for (StorageDomain domain : destStorages) {
                StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
                if (!validate(storageDomainValidator.isDomainWithinThresholds()) || !validate(storageDomainValidator.isDomainHasSpaceForRequest(getNeededDiskSize(domain.getId())))) {
                    return false;
                }
            }
        }
    }
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority());
    if (returnValue) {
        List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    // check that template image and vm are on the same storage pool
    if (returnValue && shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else {
            for (StorageDomain domain : destStorages) {
                StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
                if (!validate(storageDomainValidator.isDomainWithinThresholds()) || !validate(storageDomainValidator.isDomainHasSpaceForRequest(getNeededDiskSize(domain.getId())))) {
                    return false;
                }
            }
        }
    }
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#end_block

#method_before
protected Guid getStoragePoolIdFromSourceImageContainer() {
    return getVmTemplate().getStoragePoolId().getValue();
}
#method_after
protected Guid getStoragePoolIdFromSourceImageContainer() {
    return getVmTemplate().getStoragePoolId();
}
#end_block

#method_before
protected void fillImagesMapBasedOnTemplate() {
    ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), getStorageDomainDAO().getAllForStoragePool(getVmTemplate().getStoragePoolId().getValue()), diskInfoDestinationMap, destStorages, false);
}
#method_after
protected void fillImagesMapBasedOnTemplate() {
    ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), getStorageDomainDAO().getAllForStoragePool(getVmTemplate().getStoragePoolId()), diskInfoDestinationMap, destStorages, false);
}
#end_block

#method_before
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    // Checking if a desktop with same name already exists
    if (isVmWithSameNameExists(name)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (!verifyAddVM(reasons, vmPriority)) {
        return false;
    }
    if (!getParameters().getDontCheckTemplateImages()) {
        boolean checkTemplateLock = getParameters().getParentCommand() != VdcActionType.AddVmPoolWithVms;
        for (StorageDomain storage : destStorages.values()) {
            if (!VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), storage.getId(), reasons, false, checkTemplateLock, true, true, storageToDisksMap.get(storage.getId()))) {
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    // Checking if a desktop with same name already exists
    if (isVmWithSameNameExists(name)) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED.name());
        return false;
    }
    if (!verifyAddVM(reasons, vmPriority)) {
        return false;
    }
    if (!getParameters().getDontCheckTemplateImages()) {
        boolean checkTemplateLock = getParameters().getParentCommand() != VdcActionType.AddVmPoolWithVms;
        for (StorageDomain storage : destStorages.values()) {
            if (!VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), storage.getId(), reasons, false, checkTemplateLock, true, true, storageToDisksMap.get(storage.getId()))) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.NewGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getType(), payload.getSpecParams(), true, true, null);
    }
}
#method_after
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getType(), payload.getSpecParams(), true, true, null);
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(getVmTemplateId(), getVmId(), newDiskImages, _vmInterfaces);
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(getVmTemplateId(), getVmId(), newDiskImages, _vmInterfaces, getParameters().isSoundDeviceEnabled());
}
#end_block

#method_before
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNetworkInterface iface : getVmInterfaces()) {
        iface.setId(Guid.NewGuid());
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNetworkInterface iface : getVmInterfaces()) {
        iface.setId(Guid.newGuid());
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    if (getVmTemplate() != null && !getVmTemplate().getDiskList().isEmpty()) {
        for (DiskImage disk : getParameters().getDiskInfoDestinationMap().values()) {
            if (disk.getStorageIds() != null && !disk.getStorageIds().isEmpty()) {
                permissionList.add(new PermissionSubject(GuidUtils.getGuidValue(disk.getStorageIds().get(0)), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
            }
        }
    }
    addPermissionSubjectForAdminLevelProperties(permissionList);
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    if (getVmTemplate() != null && !getVmTemplate().getDiskList().isEmpty()) {
        for (DiskImage disk : getParameters().getDiskInfoDestinationMap().values()) {
            if (disk.getStorageIds() != null && !disk.getStorageIds().isEmpty()) {
                permissionList.add(new PermissionSubject(disk.getStorageIds().get(0), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
            }
        }
    }
    addPermissionSubjectForAdminLevelProperties(permissionList);
    return permissionList;
}
#end_block

#method_before
protected void addActiveSnapshot() {
    _vmSnapshotId = Guid.NewGuid();
    new SnapshotsManager().addActiveSnapshot(_vmSnapshotId, getVm(), getCompensationContext());
}
#method_after
protected void addActiveSnapshot() {
    _vmSnapshotId = Guid.newGuid();
    new SnapshotsManager().addActiveSnapshot(_vmSnapshotId, getVm(), getCompensationContext());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    // check template exists
    if (!validate(templateExists())) {
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BlankVmTemplateId.equals(vmTemplateId)) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
    }
    // check storage pool valid
    if (getStoragePool() == null || getStoragePool().getstatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    // check if delete protected
    if (template.isDeleteProtected()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    fetchImageTemplates();
    List<Guid> storageDomainsList = getParameters().getStorageDomainsList();
    Set<Guid> allDomainsList = getStorageDoaminsByDisks(imageTemplates, true);
    // if null or empty list sent, get all template domains for deletion
    if (storageDomainsList == null || storageDomainsList.isEmpty()) {
        // populate all the domains of the template
        getParameters().setStorageDomainsList(new ArrayList<Guid>(allDomainsList));
        getParameters().setRemoveTemplateFromDb(true);
    } else {
        // if some domains sent, check that the sent domains are part of all domains
        List<String> problematicDomains = new ArrayList<String>();
        for (Guid domainId : storageDomainsList) {
            if (!allDomainsList.contains(domainId)) {
                StorageDomainStatic domain = getDbFacade().getStorageDomainStaticDao().get(domainId);
                problematicDomains.add(domain == null ? domainId.toString() : domain.getStorageName());
            }
        }
        if (!problematicDomains.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DOMAINS_LIST_MISMATCH);
            addCanDoActionMessage(String.format("$domainsList %1$s", StringUtils.join(problematicDomains, ",")));
            return false;
        }
        getParameters().setRemoveTemplateFromDb(allDomainsList.size() == storageDomainsList.size());
    }
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = getDbFacade().getVmDao().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<String>();
    for (VM vm : vms) {
        if (getParameters().isRemoveTemplateFromDb()) {
            problematicVmNames.add(vm.getName());
        } else {
            List<DiskImage> vmDIsks = ImagesHandler.filterImageDisks(getDbFacade().getDiskDao().getAllForVm(vm.getId()), false, false);
            Set<Guid> domainsIds = getStorageDoaminsByDisks(vmDIsks, false);
            for (Guid domainId : domainsIds) {
                if (!getParameters().getStorageDomainsList().contains(domainId)) {
                    problematicVmNames.add(vm.getName());
                }
            }
        }
    }
    if (!problematicVmNames.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
        addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    // check template exists
    if (!validate(templateExists())) {
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BlankVmTemplateId.equals(vmTemplateId)) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
    }
    // check storage pool valid
    if (getStoragePool() == null || getStoragePool().getstatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    // check if delete protected
    if (template.isDeleteProtected()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    fetchImageTemplates();
    List<Guid> storageDomainsList = getParameters().getStorageDomainsList();
    Set<Guid> allDomainsList = getStorageDoaminsByDisks(imageTemplates, true);
    // if null or empty list sent, get all template domains for deletion
    if (storageDomainsList == null || storageDomainsList.isEmpty()) {
        // populate all the domains of the template
        getParameters().setStorageDomainsList(new ArrayList<Guid>(allDomainsList));
        getParameters().setRemoveTemplateFromDb(true);
    } else {
        // if some domains sent, check that the sent domains are part of all domains
        List<String> problematicDomains = new ArrayList<String>();
        for (Guid domainId : storageDomainsList) {
            if (!allDomainsList.contains(domainId)) {
                StorageDomainStatic domain = getDbFacade().getStorageDomainStaticDao().get(domainId);
                problematicDomains.add(domain == null ? domainId.toString() : domain.getStorageName());
            }
        }
        if (!problematicDomains.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DOMAINS_LIST_MISMATCH);
            addCanDoActionMessage(String.format("$domainsList %1$s", StringUtils.join(problematicDomains, ",")));
            return false;
        }
        getParameters().setRemoveTemplateFromDb(allDomainsList.size() == storageDomainsList.size());
    }
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = getVmDAO().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<String>();
    for (VM vm : vms) {
        if (getParameters().isRemoveTemplateFromDb()) {
            problematicVmNames.add(vm.getName());
        } else {
            List<DiskImage> vmDIsks = ImagesHandler.filterImageDisks(getDbFacade().getDiskDao().getAllForVm(vm.getId()), false, false);
            Set<Guid> domainsIds = getStorageDoaminsByDisks(vmDIsks, false);
            for (Guid domainId : domainsIds) {
                if (!getParameters().getStorageDomainsList().contains(domainId)) {
                    problematicVmNames.add(vm.getName());
                }
            }
        }
    }
    if (!problematicVmNames.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
        addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        return false;
    }
    return true;
}
#end_block

#method_before
private void setVmTemplateIdParameter() {
    Map<Boolean, VmTemplate> templateMap = // Disk image is the only disk type that can be part of the template disks.
    getDbFacade().getVmTemplateDao().getAllForImage(getDiskImage().getImageId());
    if (!templateMap.isEmpty()) {
        setVmTemplateId(templateMap.values().iterator().next().getId());
    }
}
#method_after
private void setVmTemplateIdParameter() {
    Map<Boolean, VmTemplate> templateMap = // Disk image is the only disk type that can be part of the template disks.
    getVmTemplateDAO().getAllForImage(getDiskImage().getImageId());
    if (!templateMap.isEmpty()) {
        setVmTemplateId(templateMap.values().iterator().next().getId());
    }
}
#end_block

#method_before
private List<String> getNamesOfDerivedVmsFromTemplate(DiskImage diskImage) {
    List<String> result = new ArrayList<String>();
    for (VM vm : getDbFacade().getVmDao().getAllWithTemplate(getVmTemplateId())) {
        for (Disk vmDisk : getDbFacade().getDiskDao().getAllForVm(vm.getId())) {
            if (vmDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage vmDiskImage = (DiskImage) vmDisk;
                if (vmDiskImage.getImageTemplateId().equals(diskImage.getImageId())) {
                    if (vmDiskImage.getStorageIds().contains(getParameters().getStorageDomainId())) {
                        result.add(vm.getName());
                    }
                    break;
                }
            }
        }
    }
    return result;
}
#method_after
private List<String> getNamesOfDerivedVmsFromTemplate(DiskImage diskImage) {
    List<String> result = new ArrayList<String>();
    for (VM vm : getVmDAO().getAllWithTemplate(getVmTemplateId())) {
        for (Disk vmDisk : getDiskDao().getAllForVm(vm.getId())) {
            if (vmDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage vmDiskImage = (DiskImage) vmDisk;
                if (vmDiskImage.getImageTemplateId().equals(diskImage.getImageId())) {
                    if (vmDiskImage.getStorageIds().contains(getParameters().getStorageDomainId())) {
                        result.add(vm.getName());
                    }
                    break;
                }
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (getDisk() != null && DiskStorageType.IMAGE == getDisk().getDiskStorageType() && getQuotaId() != null && !Guid.Empty.equals(getQuotaId())) {
        list.add(new QuotaStorageConsumptionParameter(getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getStorageDomainId().getValue(), (double) getDiskImage().getSizeInGigabytes()));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (getDisk() != null && DiskStorageType.IMAGE == getDisk().getDiskStorageType() && getQuotaId() != null && !Guid.Empty.equals(getQuotaId())) {
        list.add(new QuotaStorageConsumptionParameter(getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getStorageDomainId(), (double) getDiskImage().getSizeInGigabytes()));
    }
    return list;
}
#end_block

#method_before
private void setNonOperational(VDS server) {
    Map<String, String> customValues = new HashMap<String, String>();
    customValues.put(GlusterConstants.COMMAND, "gluster peer probe");
    customValues.put(GlusterConstants.SERVER, server.getHostName());
    SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED, customValues);
    nonOpParams.setSaveToDb(true);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
}
#method_after
private void setNonOperational(VDS server) {
    SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED, Collections.singletonMap(GlusterConstants.COMMAND, "gluster peer probe"));
    nonOpParams.setSaveToDb(true);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (!(Guid.isNullOrEmpty(serverId))) {
        performActionForServicesOfServer();
    } else if (!(Guid.isNullOrEmpty(clusterId))) {
        performActionForServicesOfCluster();
    }
}
#method_after
@Override
protected void executeCommand() {
    if (!(Guid.isNullOrEmpty(serverId))) {
        performActionForServicesOfServer();
    } else if (!(Guid.isNullOrEmpty(clusterId))) {
        performActionForServicesOfCluster();
    }
    addCustomValue(GlusterConstants.SERVICE_TYPE, getParameters().getServiceType().name());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ResetGlusterVolumeOptions, new ResetGlusterVolumeOptionsVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getVolumeOption(), getParameters().isForceAction()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        if (getParameters().getVolumeOption() != null && !(getParameters().getVolumeOption().getKey().isEmpty())) {
            removeOptionInDb(getGlusterVolume().getOption(getParameters().getVolumeOption().getKey()));
            isResetAllOptions = false;
        } else {
            for (GlusterVolumeOptionEntity option : getGlusterVolume().getOptions()) {
                removeOptionInDb(option);
            }
            isResetAllOptions = true;
        }
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ResetGlusterVolumeOptions, new ResetGlusterVolumeOptionsVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getVolumeOption(), getParameters().isForceAction()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        if (getParameters().getVolumeOption() != null && !(getParameters().getVolumeOption().getKey().isEmpty())) {
            GlusterVolumeOptionEntity entity = getGlusterVolume().getOption(getParameters().getVolumeOption().getKey());
            removeOptionInDb(entity);
            isResetAllOptions = false;
            if (entity != null) {
                String optionValue = entity.getValue();
                getParameters().getVolumeOption().setValue(optionValue != null ? optionValue : "");
                addCustomValue(GlusterConstants.OPTION_KEY, getParameters().getVolumeOption().getKey());
                addCustomValue(GlusterConstants.OPTION_VALUE, getParameters().getVolumeOption().getValue());
            }
        } else {
            for (GlusterVolumeOptionEntity option : getGlusterVolume().getOptions()) {
                removeOptionInDb(option);
            }
            isResetAllOptions = true;
        }
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
private static void initSeverities() {
    initDefaultSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
}
#method_after
private static void initSeverities() {
    initDefaultSeverities();
    initProviderSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
}
#end_block

#method_before
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
}
#method_after
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    String message = null;
    String resolvedMessage = null;
    AuditLogSeverity severity = severities.get(logType);
    if (severity == null) {
        severity = AuditLogSeverity.NORMAL;
        log.infoFormat("No severity for {0} audit log type, assuming Normal severity", logType);
    }
    AuditLog auditLog = null;
    // handle external log messages invoked by plugins via the API
    if (auditLogable.isExternal()) {
        // message is sent as an argument, no need to resolve.
        resolvedMessage = message = loggerString;
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName(), auditLogable.getOrigin(), auditLogable.getCustomEventId(), auditLogable.getEventFloodInSec(), auditLogable.getCustomData());
    } else if ((message = messages.get(logType)) != null) {
        // Application log message from AuditLogMessages
        resolvedMessage = resolveMessage(message, auditLogable);
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
    }
    if (auditLog != null) {
        auditLog.setstorage_domain_id(auditLogable.getStorageDomainId());
        auditLog.setstorage_domain_name(auditLogable.getStorageDomainName());
        auditLog.setstorage_pool_id(auditLogable.getStoragePoolId());
        auditLog.setstorage_pool_name(auditLogable.getStoragePoolName());
        auditLog.setvds_group_id(auditLogable.getVdsGroupId());
        auditLog.setvds_group_name(auditLogable.getVdsGroupName());
        auditLog.setCorrelationId(auditLogable.getCorrelationId());
        auditLog.setJobId(auditLogable.getJobId());
        auditLog.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
        auditLog.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
        auditLog.setExternal(auditLogable.isExternal());
        auditLog.setQuotaId(auditLogable.getQuotaIdForLog());
        auditLog.setQuotaName(auditLogable.getQuotaNameForLog());
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        if (!"".equals(loggerString)) {
            log.infoFormat(loggerString, resolvedMessage);
        }
    }
}
#method_after
private static void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    String message = null;
    String resolvedMessage = null;
    AuditLogSeverity severity = severities.get(logType);
    if (severity == null) {
        severity = AuditLogSeverity.NORMAL;
        log.infoFormat("No severity for {0} audit log type, assuming Normal severity", logType);
    }
    AuditLog auditLog = null;
    // handle external log messages invoked by plugins via the API
    if (auditLogable.isExternal()) {
        // message is sent as an argument, no need to resolve.
        resolvedMessage = message = loggerString;
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName(), auditLogable.getOrigin(), auditLogable.getCustomEventId(), auditLogable.getEventFloodInSec(), auditLogable.getCustomData());
    } else if ((message = messages.get(logType)) != null) {
        // Application log message from AuditLogMessages
        resolvedMessage = resolveMessage(message, auditLogable);
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
    }
    if (auditLog != null) {
        auditLog.setstorage_domain_id(auditLogable.getStorageDomainId());
        auditLog.setstorage_domain_name(auditLogable.getStorageDomainName());
        auditLog.setstorage_pool_id(auditLogable.getStoragePoolId());
        auditLog.setstorage_pool_name(auditLogable.getStoragePoolName());
        auditLog.setvds_group_id(auditLogable.getVdsGroupId());
        auditLog.setvds_group_name(auditLogable.getVdsGroupName());
        auditLog.setCorrelationId(auditLogable.getCorrelationId());
        auditLog.setJobId(auditLogable.getJobId());
        auditLog.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
        auditLog.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
        auditLog.setExternal(auditLogable.isExternal());
        auditLog.setQuotaId(auditLogable.getQuotaIdForLog());
        auditLog.setQuotaName(auditLogable.getQuotaNameForLog());
        auditLog.setCallStack(auditLogable.getCallStack());
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        if (!"".equals(loggerString)) {
            log.infoFormat(loggerString, resolvedMessage);
        }
    }
}
#end_block

#method_before
@Before
public void setUp() {
    mappingLocator = new MappingLocator();
    mappingLocator.populate();
    HashMap<Integer, String> osNames = new HashMap<>(1);
    osNames.put(0, "Unassigned");
}
#method_after
@Before
public void setUp() {
    mappingLocator = new MappingLocator();
    mappingLocator.populate();
}
#end_block

#method_before
public static void mockOsTypes() {
    IMocksControl control = EasyMock.createNiceControl();
    OsRepository osRepositoryMock = control.createMock(OsRepository.class);
    HashMap<Integer, String> osNames = new HashMap<>(1);
    osNames.put(0, "Unassigned");
    expect(osRepositoryMock.getOsNames()).andReturn(osNames).anyTimes();
    expect(osRepositoryMock.osNameUpperCasedAndUnderscored("Unassigned")).andReturn("UNASSIGNED").anyTimes();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepositoryMock);
    control.replay();
}
#method_after
public static void mockOsTypes() {
    IMocksControl control = EasyMock.createNiceControl();
    OsRepository osRepositoryMock = control.createMock(OsRepository.class);
    HashMap<Integer, String> osNames = new HashMap<>(1);
    osNames.put(0, "Unassigned");
    expect(osRepositoryMock.getUniqueOsNames()).andReturn(osNames).anyTimes();
    expect(osRepositoryMock.osNameUpperCasedAndUnderscored("Unassigned")).andReturn("UNASSIGNED").anyTimes();
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepositoryMock);
    control.replay();
}
#end_block

#method_before
@Override
protected Template postPopulate(Template from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    from.setTimezone("Australia/Darwin");
    OsTypeMockUtils.mockOsTypes();
    return from;
}
#method_after
@Override
protected Template postPopulate(Template from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    from.setTimezone("Australia/Darwin");
    return from;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // check source to copy hook from - if engine copy or server copy
    final Boolean copyfromEngine = (getParameters().getSourceServerId() == null);
    entity = getGlusterHook();
    addCustomValue(GlusterConstants.HOOK_NAME, entity.getName());
    final String hookContent;
    final String hookChecksum;
    final GlusterHookContentType hookContentType;
    if (copyfromEngine) {
        hookContent = entity.getContent();
        hookChecksum = entity.getChecksum();
        hookContentType = entity.getContentType();
    } else {
        // use a server's copy
        GlusterServerHook sourceServerHook = getGlusterHooksDao().getGlusterServerHook(entity.getId(), getParameters().getSourceServerId());
        VDSReturnValue retValue = runVdsCommand(VDSCommandType.GetGlusterHookContent, new GlusterHookVDSParameters(getParameters().getSourceServerId(), entity.getGlusterCommand(), entity.getStage(), entity.getName()));
        if (!retValue.getSucceeded()) {
            // throw exception as we cannot continue without content
            log.errorFormat("Failed to get content from server with id {0} with error {1}", getParameters().getSourceServerId(), retValue.getExceptionString());
            throw new VdcBLLException(retValue.getVdsError().getCode(), retValue.getVdsError().getMessage());
        }
        hookContent = (String) retValue.getReturnValue();
        hookChecksum = sourceServerHook.getChecksum();
        hookContentType = sourceServerHook.getContentType();
    }
    List<Callable<Pair<Guid, VDSReturnValue>>> taskList = new ArrayList<Callable<Pair<Guid, VDSReturnValue>>>();
    List<Guid> serverIdsToUpdate = new ArrayList<Guid>();
    if (copyfromEngine) {
        for (final GlusterServerHook serverHook : getContentConflictServerHooks()) {
            serverIdsToUpdate.add(serverHook.getServerId());
        }
    } else {
        // need to be updated with hook content
        for (final VDS server : getClusterUtils().getAllUpServers(entity.getClusterId())) {
            if (!server.getId().equals(getParameters().getSourceServerId())) {
                serverIdsToUpdate.add(server.getId());
            }
        }
    }
    for (final Guid serverId : serverIdsToUpdate) {
        taskList.add(new Callable<Pair<Guid, VDSReturnValue>>() {

            @Override
            public Pair<Guid, VDSReturnValue> call() throws Exception {
                VDSReturnValue returnValue;
                returnValue = runVdsCommand(VDSCommandType.UpdateGlusterHook, new GlusterHookVDSParameters(serverId, entity.getGlusterCommand(), entity.getStage(), entity.getName(), hookContent, hookChecksum));
                return new Pair<Guid, VDSReturnValue>(serverId, returnValue);
            }
        });
    }
    setSucceeded(true);
    if (!taskList.isEmpty()) {
        List<Pair<Guid, VDSReturnValue>> pairResults = ThreadPoolUtil.invokeAll(taskList);
        for (Pair<Guid, VDSReturnValue> pairResult : pairResults) {
            VDSReturnValue retValue = pairResult.getSecond();
            if (!retValue.getSucceeded()) {
                errors.add(retValue.getVdsError().getMessage());
            }
        }
    } else {
        setSucceeded(false);
    }
    if (errors.size() > 0) {
        setSucceeded(false);
        errorType = AuditLogType.GLUSTER_HOOK_UPDATE_FAILED;
        handleVdsErrors(getAuditLogTypeValue(), errors);
        addCustomValue(GlusterConstants.FAILURE_MESSAGE, StringUtils.join(errors, SystemUtils.LINE_SEPARATOR));
    }
    if (getSucceeded() && !copyfromEngine) {
        // update server's content copy
        entity.setChecksum(hookChecksum);
        entity.setContent(hookContent);
        entity.setContentType(hookContentType);
    }
    if (getSucceeded()) {
        entity.removeContentConflict();
        updateGlusterHook(entity);
    }
}
#method_after
@Override
protected void executeCommand() {
    // check source to copy hook from - if engine copy or server copy
    final boolean copyfromEngine = (getParameters().getSourceServerId() == null);
    entity = getGlusterHook();
    addCustomValue(GlusterConstants.HOOK_NAME, entity.getName());
    final String hookContent;
    final String hookChecksum;
    final GlusterHookContentType hookContentType;
    if (copyfromEngine) {
        hookContent = entity.getContent();
        hookChecksum = entity.getChecksum();
        hookContentType = entity.getContentType();
    } else {
        // use a server's copy
        GlusterServerHook sourceServerHook = getGlusterHooksDao().getGlusterServerHook(entity.getId(), getParameters().getSourceServerId());
        VDSReturnValue retValue = runVdsCommand(VDSCommandType.GetGlusterHookContent, new GlusterHookVDSParameters(getParameters().getSourceServerId(), entity.getGlusterCommand(), entity.getStage(), entity.getName()));
        if (!retValue.getSucceeded()) {
            // throw exception as we cannot continue without content
            log.errorFormat("Failed to get content from server with id {0} with error {1}", getParameters().getSourceServerId(), retValue.getExceptionString());
            throw new VdcBLLException(retValue.getVdsError().getCode(), retValue.getVdsError().getMessage());
        }
        hookContent = (String) retValue.getReturnValue();
        hookChecksum = sourceServerHook.getChecksum();
        hookContentType = sourceServerHook.getContentType();
    }
    List<Callable<Pair<Guid, VDSReturnValue>>> taskList = new ArrayList<Callable<Pair<Guid, VDSReturnValue>>>();
    List<Guid> serverIdsToUpdate = new ArrayList<Guid>();
    if (copyfromEngine) {
        for (final GlusterServerHook serverHook : getContentConflictServerHooks()) {
            serverIdsToUpdate.add(serverHook.getServerId());
        }
    } else {
        // need to be updated with hook content
        for (final VDS server : getClusterUtils().getAllUpServers(entity.getClusterId())) {
            if (!server.getId().equals(getParameters().getSourceServerId())) {
                serverIdsToUpdate.add(server.getId());
            }
        }
    }
    for (final Guid serverId : serverIdsToUpdate) {
        taskList.add(new Callable<Pair<Guid, VDSReturnValue>>() {

            @Override
            public Pair<Guid, VDSReturnValue> call() throws Exception {
                VDSReturnValue returnValue;
                returnValue = runVdsCommand(VDSCommandType.UpdateGlusterHook, new GlusterHookVDSParameters(serverId, entity.getGlusterCommand(), entity.getStage(), entity.getName(), hookContent, hookChecksum));
                return new Pair<Guid, VDSReturnValue>(serverId, returnValue);
            }
        });
    }
    setSucceeded(true);
    if (!taskList.isEmpty()) {
        List<Pair<Guid, VDSReturnValue>> pairResults = ThreadPoolUtil.invokeAll(taskList);
        for (Pair<Guid, VDSReturnValue> pairResult : pairResults) {
            VDSReturnValue retValue = pairResult.getSecond();
            if (!retValue.getSucceeded()) {
                errors.add(retValue.getVdsError().getMessage());
            }
        }
    } else {
        setSucceeded(false);
    }
    if (errors.size() > 0) {
        setSucceeded(false);
        errorType = AuditLogType.GLUSTER_HOOK_UPDATE_FAILED;
        handleVdsErrors(getAuditLogTypeValue(), errors);
        addCustomValue(GlusterConstants.FAILURE_MESSAGE, StringUtils.join(errors, SystemUtils.LINE_SEPARATOR));
    }
    if (getSucceeded() && !copyfromEngine) {
        // update server's content copy
        entity.setChecksum(hookChecksum);
        entity.setContent(hookContent);
        entity.setContentType(hookContentType);
    }
    if (getSucceeded()) {
        entity.removeContentConflict();
        updateGlusterHook(entity);
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (String name : interfaces.keySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(name)) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) interfaces.get(name);
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
        if (vds.getUsageCpuPercent() >= vds.getHighUtilization() || vds.getUsageCpuPercent() <= vds.getLowUtilization()) {
            if (vds.getCpuOverCommitTimestamp() == null) {
                vds.setCpuOverCommitTimestamp(new Date());
            }
        } else {
            vds.setCpuOverCommitTimestamp(null);
        }
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
        if (vds.getUsageCpuPercent() >= vds.getHighUtilization() || vds.getUsageCpuPercent() <= vds.getLowUtilization()) {
            if (vds.getCpuOverCommitTimestamp() == null) {
                vds.setCpuOverCommitTimestamp(new Date());
            }
        } else {
            vds.setCpuOverCommitTimestamp(null);
        }
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
}
#end_block

#method_before
protected static void updateLocalDisksUsage(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<String, Long>();
        vds.setLocalDisksUsage(diskStats);
        for (String path : diskStatsStruct.keySet()) {
            Map<String, Object> pathStatsStruct = (Map<String, Object>) diskStatsStruct.get(path);
            diskStats.put(path, AssignLongValue(pathStatsStruct, VdsProperties.DISK_STATS_FREE));
        }
    }
}
#method_after
protected static void updateLocalDisksUsage(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<String, Long>();
        vds.setLocalDisksUsage(diskStats);
        for (Entry<String, Object> entry : diskStatsStruct.entrySet()) {
            Map<String, Object> pathStatsStruct = (Map<String, Object>) entry.getValue();
            diskStats.put(entry.getKey(), AssignLongValue(pathStatsStruct, VdsProperties.DISK_STATS_FREE));
        }
    }
}
#end_block

#method_before
private static void initAppsList(Map<String, Object> vmStruct, VmDynamic vm) {
    if (vmStruct.containsKey(VdsProperties.app_list)) {
        Object tempAppsList = vmStruct.get(VdsProperties.app_list);
        if (tempAppsList instanceof Object[]) {
            Object[] apps = (Object[]) tempAppsList;
            StringBuilder builder = new StringBuilder();
            boolean firstTime = true;
            for (Object app : apps) {
                String appString = (String) ((app instanceof String) ? app : null);
                if (app == null) {
                    log.warnFormat("Failed to convert app: {0} to string", app);
                }
                if (!firstTime) {
                    builder.append(",");
                } else {
                    firstTime = false;
                }
                builder.append(appString);
            }
            vm.setAppList(builder.toString());
        } else {
            vm.setAppList("");
        }
    }
}
#method_after
private static void initAppsList(Map<String, Object> vmStruct, VmDynamic vm) {
    if (vmStruct.containsKey(VdsProperties.app_list)) {
        Object tempAppsList = vmStruct.get(VdsProperties.app_list);
        if (tempAppsList instanceof Object[]) {
            Object[] apps = (Object[]) tempAppsList;
            StringBuilder builder = new StringBuilder();
            boolean firstTime = true;
            for (Object app : apps) {
                String appString = (String) ((app instanceof String) ? app : null);
                if (app == null) {
                    log.warn("Failed to convert app: [null] to string");
                }
                if (!firstTime) {
                    builder.append(",");
                } else {
                    firstTime = false;
                }
                builder.append(appString);
            }
            vm.setAppList(builder.toString());
        } else {
            vm.setAppList("");
        }
    }
}
#end_block

#method_before
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> nics = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (String key : nics.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            updateNetworkInterfaceDataFromHost(iface, (Map<String, Object>) nics.get(key));
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> nics = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Object> entry : nics.entrySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(entry.getKey());
            iface.setVdsId(vds.getId());
            updateNetworkInterfaceDataFromHost(iface, (Map<String, Object>) entry.getValue());
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
}
#end_block

#method_before
@Override
public Disks list() {
    if (QueryHelper.hasMatrixParam(getUriInfo(), UNREGISTERED_CONSTRAINT_PARAMETER)) {
        return mapCollection(getBackendCollection(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(storageDomainId, getStoragePoolIdForDomain(storageDomainId))));
    } else {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllDisksByStorageDomainId, new StorageDomainQueryParametersBase(this.storageDomainId)));
    }
}
#method_after
@Override
public Disks list() {
    if (QueryHelper.hasMatrixParam(getUriInfo(), UNREGISTERED_CONSTRAINT_PARAMETER)) {
        return mapCollection(getBackendCollection(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(storageDomainId, getStoragePoolIdForDomain(storageDomainId))));
    } else {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllDisksByStorageDomainId, new IdQueryParameters(this.storageDomainId)));
    }
}
#end_block

#method_before
protected Guid getStoragePoolIdForDomain(Guid storageDomainId) {
    // Retrieve the storage pools for the storage domain.
    StorageDomainQueryParametersBase params = new StorageDomainQueryParametersBase(storageDomainId);
    List<StoragePool> storagePools = getBackendCollection(StoragePool.class, VdcQueryType.GetStoragePoolsByStorageDomainId, params);
    if (storagePools != null && !storagePools.isEmpty()) {
        // storage pool to deal with.
        return storagePools.get(0).getId();
    } else {
        return Guid.Empty;
    }
}
#method_after
protected Guid getStoragePoolIdForDomain(Guid storageDomainId) {
    // Retrieve the storage pools for the storage domain.
    IdQueryParameters params = new IdQueryParameters(storageDomainId);
    List<StoragePool> storagePools = getBackendCollection(StoragePool.class, VdcQueryType.GetStoragePoolsByStorageDomainId, params);
    if (storagePools != null && !storagePools.isEmpty()) {
        // storage pool to deal with.
        return storagePools.get(0).getId();
    } else {
        return Guid.Empty;
    }
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    returnValue = getBroker().glusterServiceManage(getParameters().getVdsId(), (String[]) getParameters().getServiceList().toArray(), getParameters().getActionType(), true);
    ProceedProxyReturnValue();
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    List<String> serviceList = getParameters().getServiceList();
    String[] serviceNameList = new String[serviceList.size()];
    serviceList.toArray(serviceNameList);
    returnValue = getBroker().glusterServiceManage(getParameters().getVdsId(), serviceNameList, getParameters().getActionType(), true);
    ProceedProxyReturnValue();
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] snapParams) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.snapshot(vmId, snapParams);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.snapshot(vmId, disks);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] snapParams) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.snapshot(vmId, snapParams);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.snapshot(vmId, disks, memory);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
public static void getDefaultTimeZone(AsyncQuery aQuery, TimeZoneType timeZoneType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            // $NON-NLS-1$
            return "";
        }
    };
    TimeZoneQueryParams params = new TimeZoneQueryParams();
    params.setTimeZoneType(timeZoneType);
    Frontend.RunQuery(VdcQueryType.GetDefualtTimeZone, params, aQuery);
}
#method_after
public static void getDefaultTimeZone(AsyncQuery aQuery, TimeZoneType timeZoneType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            // $NON-NLS-1$
            return "";
        }
    };
    TimeZoneQueryParams params = new TimeZoneQueryParams();
    params.setTimeZoneType(timeZoneType);
    Frontend.RunQuery(VdcQueryType.GetDefaultTimeZone, params, aQuery);
}
#end_block

#method_before
void updateHost() {
    if (getDataCenter().getItems() == null) {
        return;
    }
    if (getSelectedItem() == null) {
        return;
    }
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    boolean localFsOnly = getSelectedItem() instanceof LocalStorageModel;
    Guid dataCenterId = dataCenter == null ? null : dataCenter.getId();
    AsyncDataProvider.getSpmCandidates(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            StorageModel storageModel = (StorageModel) model;
            Iterable<VDS> hosts = (Iterable<VDS>) returnValue;
            storageModel.postUpdateHost(hosts);
        }
    }, getHash()), dataCenterId, localFsOnly);
}
#method_after
void updateHost() {
    if (getDataCenter().getItems() == null) {
        return;
    }
    if (getSelectedItem() == null) {
        return;
    }
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    boolean localFsOnly = getSelectedItem() instanceof LocalStorageModel;
    Guid dataCenterId = dataCenter == null ? null : dataCenter.getId();
    AsyncDataProvider.getHostsForStorageOperation(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            StorageModel storageModel = (StorageModel) model;
            Iterable<VDS> hosts = (Iterable<VDS>) returnValue;
            storageModel.postUpdateHost(hosts);
        }
    }, getHash()), dataCenterId, localFsOnly);
}
#end_block

#method_before
@Test
public void executeCommand() {
    cmd = spy(new EnableGlusterHookCommand<GlusterHookParameters>(new GlusterHookParameters(HOOK_ID)));
    setupMocks(cmd);
    mockBackendStatusChange(cmd, true);
    cmd.executeCommand();
    verify(cmd, atLeast(1)).addServerHookInDb(any(GlusterServerHook.class));
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_HOOK_ENABLE);
}
#method_after
@Test
public void executeCommand() {
    cmd = spy(new EnableGlusterHookCommand<GlusterHookParameters>(new GlusterHookParameters(HOOK_ID)));
    setupMocks(cmd);
    mockBackendStatusChange(cmd, true);
    cmd.executeCommand();
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_HOOK_ENABLE);
}
#end_block

#method_before
@Test
public void executeCommandWhenFailed() {
    cmd = spy(new EnableGlusterHookCommand<GlusterHookParameters>(new GlusterHookParameters(HOOK_ID)));
    setupMocks(cmd);
    mockBackendStatusChange(cmd, false);
    cmd.executeCommand();
    verify(cmd, never()).addServerHookInDb(any(GlusterServerHook.class));
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_HOOK_ENABLE_FAILED);
}
#method_after
@Test
public void executeCommandWhenFailed() {
    cmd = spy(new EnableGlusterHookCommand<GlusterHookParameters>(new GlusterHookParameters(HOOK_ID)));
    setupMocks(cmd);
    mockBackendStatusChange(cmd, false);
    cmd.executeCommand();
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_HOOK_ENABLE_FAILED);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    entity = getGlusterHook();
    addCustomValue(GlusterConstants.HOOK_NAME, entity.getName());
    List<GlusterServerHook> serverHooks = entity.getServerHooks();
    if (getAllUpServers().size() < getClusterUtils().getServerCount(getGlusterHook().getClusterId())) {
        errors.add(VdcBllMessages.CLUSTER_ALL_SERVERS_NOT_UP.toString());
    }
    List<Callable<Pair<VDS, VDSReturnValue>>> taskList = new ArrayList<Callable<Pair<VDS, VDSReturnValue>>>();
    for (final VDS upServer : getAllUpServers()) {
        taskList.add(new Callable<Pair<VDS, VDSReturnValue>>() {

            @Override
            public Pair<VDS, VDSReturnValue> call() throws Exception {
                VDSReturnValue returnValue = runVdsCommand(getStatusChangeVDSCommand(), new GlusterHookVDSParameters(upServer.getId(), entity.getGlusterCommand(), entity.getStage(), entity.getName()));
                return new Pair<VDS, VDSReturnValue>(upServer, returnValue);
            }
        });
    }
    boolean atLeastOneSuccess = false;
    List<Pair<VDS, VDSReturnValue>> pairResults = ThreadPoolUtil.invokeAll(taskList);
    for (Pair<VDS, VDSReturnValue> pairResult : pairResults) {
        VDSReturnValue retValue = pairResult.getSecond();
        if (retValue.getSucceeded()) {
            atLeastOneSuccess = true;
            // update status in database
            addOrUpdateServerHook(serverHooks, pairResult);
        } else {
            errors.add(retValue.getVdsError().getMessage());
        }
    }
    setSucceeded(atLeastOneSuccess);
    if (errors.size() > 0) {
        // conflict in status
        entity.addStatusConflict();
        handleVdsErrors(getAuditLogTypeValue(), errors);
        addCustomValue(GlusterConstants.FAILURE_MESSAGE, StringUtils.join(errors, SystemUtils.LINE_SEPARATOR));
    }
    // The intention was to enable/disable hook. So we update the entity with new status if command succeeded
    if (getSucceeded()) {
        entity.setStatus(getNewStatus());
        // no longer conflicts as all hooks have same status
        entity.removeStatusConflict();
        updateHookInDb(entity);
        if (entity.getConflictStatus() == 0) {
            // all conflicts have been resolved, remove server hooks
            getGlusterHooksDao().removeGlusterServerHook(entity.getId());
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    entity = getGlusterHook();
    addCustomValue(GlusterConstants.HOOK_NAME, entity.getName());
    if (getAllUpServers().size() < getClusterUtils().getServerCount(getGlusterHook().getClusterId())) {
        errors.add(VdcBllMessages.CLUSTER_ALL_SERVERS_NOT_UP.toString());
    }
    List<Callable<Pair<VDS, VDSReturnValue>>> taskList = new ArrayList<Callable<Pair<VDS, VDSReturnValue>>>();
    for (final VDS upServer : getAllUpServers()) {
        taskList.add(new Callable<Pair<VDS, VDSReturnValue>>() {

            @Override
            public Pair<VDS, VDSReturnValue> call() throws Exception {
                VDSReturnValue returnValue = runVdsCommand(getStatusChangeVDSCommand(), new GlusterHookVDSParameters(upServer.getId(), entity.getGlusterCommand(), entity.getStage(), entity.getName()));
                return new Pair<VDS, VDSReturnValue>(upServer, returnValue);
            }
        });
    }
    boolean atLeastOneSuccess = false;
    List<Pair<VDS, VDSReturnValue>> pairResults = ThreadPoolUtil.invokeAll(taskList);
    for (Pair<VDS, VDSReturnValue> pairResult : pairResults) {
        VDSReturnValue retValue = pairResult.getSecond();
        if (retValue.getSucceeded()) {
            atLeastOneSuccess = true;
            // update status in database
            updateServerHookStatusInDb(getGlusterHook().getId(), pairResult.getFirst().getId(), getNewStatus());
        } else {
            errors.add(retValue.getVdsError().getMessage());
        }
    }
    setSucceeded(atLeastOneSuccess);
    if (errors.size() > 0) {
        // conflict in status
        entity.addStatusConflict();
        handleVdsErrors(getAuditLogTypeValue(), errors);
        addCustomValue(GlusterConstants.FAILURE_MESSAGE, StringUtils.join(errors, SystemUtils.LINE_SEPARATOR));
    }
    // The intention was to enable/disable hook. So we update the entity with new status if command succeeded
    if (getSucceeded()) {
        entity.setStatus(getNewStatus());
        // no longer conflicts as all hooks have same status
        entity.removeStatusConflict();
        updateHookInDb(entity);
        if (entity.getConflictStatus() == 0) {
            // all conflicts have been resolved, remove server hooks
            getGlusterHooksDao().removeGlusterServerHooks(entity.getId());
        }
    }
}
#end_block

#method_before
@Override
public void render(Context context, SystemTreeItemModel value, SafeHtmlBuilder sb) {
    ImageResource imageResource;
    // get the right image resource
    switch(value.getType()) {
        case Cluster:
            imageResource = applicationResources.clusterImage();
            break;
        case Clusters:
            imageResource = applicationResources.clustersImage();
            break;
        case DataCenter:
            imageResource = applicationResources.dataCenterImage();
            break;
        case DataCenters:
            imageResource = applicationResources.dataCenterImage();
            break;
        case Cluster_Gluster:
            imageResource = applicationResources.glusterClusterImage();
            break;
        case Host:
            imageResource = applicationResources.hostImage();
            break;
        case Hosts:
            imageResource = applicationResources.hostsImage();
            break;
        case Storage:
            imageResource = applicationResources.storageImage();
            break;
        case Storages:
            imageResource = applicationResources.storagesImage();
            break;
        case System:
            imageResource = applicationResources.systemImage();
            break;
        case Templates:
            imageResource = applicationResources.templatesImage();
            break;
        case VMs:
            imageResource = applicationResources.vmsImage();
            break;
        case Volume:
            imageResource = applicationResources.volumeImage();
            break;
        case Volumes:
            imageResource = applicationResources.volumesImage();
            break;
        case Network:
            imageResource = applicationResources.networkTreeImage();
            break;
        case Networks:
            imageResource = applicationResources.networksTreeImage();
            break;
        default:
            imageResource = applicationResources.questionMarkImage();
    }
    // get the image HTML
    SafeHtml imageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(imageResource).getHTML());
    // apply to template
    sb.append(templates.treeItem(imageHtml, value.getTitle(), ElementIdUtils.createTreeCellElementId(elementIdPrefix, value, null)));
}
#method_after
@Override
public void render(Context context, SystemTreeItemModel value, SafeHtmlBuilder sb) {
    ImageResource imageResource;
    // get the right image resource
    switch(value.getType()) {
        case Cluster:
            imageResource = applicationResources.clusterImage();
            break;
        case Clusters:
            imageResource = applicationResources.clustersImage();
            break;
        case DataCenter:
            imageResource = applicationResources.dataCenterImage();
            break;
        case DataCenters:
            imageResource = applicationResources.dataCentersImage();
            break;
        case Cluster_Gluster:
            imageResource = applicationResources.glusterClusterImage();
            break;
        case Host:
            imageResource = applicationResources.hostImage();
            break;
        case Hosts:
            imageResource = applicationResources.hostsImage();
            break;
        case Storage:
            imageResource = applicationResources.storageImage();
            break;
        case Storages:
            imageResource = applicationResources.storagesImage();
            break;
        case System:
            imageResource = applicationResources.systemImage();
            break;
        case Templates:
            imageResource = applicationResources.templatesImage();
            break;
        case VMs:
            imageResource = applicationResources.vmsImage();
            break;
        case Volume:
            imageResource = applicationResources.volumeImage();
            break;
        case Volumes:
            imageResource = applicationResources.volumesImage();
            break;
        case Network:
            imageResource = applicationResources.networkTreeImage();
            break;
        case Networks:
            imageResource = applicationResources.networksTreeImage();
            break;
        default:
            imageResource = applicationResources.questionMarkImage();
    }
    // get the image HTML
    SafeHtml imageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(imageResource).getHTML());
    // apply to template
    sb.append(templates.treeItem(imageHtml, value.getTitle(), ElementIdUtils.createTreeCellElementId(elementIdPrefix, value, null)));
}
#end_block

#method_before
@Override
public void edit(ProviderModel object) {
    Driver.driver.edit(object);
}
#method_after
@Override
public void edit(ProviderModel object) {
    driver.edit(object);
}
#end_block

#method_before
@Override
public ProviderModel flush() {
    return Driver.driver.flush();
}
#method_after
@Override
public ProviderModel flush() {
    return driver.flush();
}
#end_block

#method_before
@Override
public void setTestResultImage(boolean succeeded) {
    testResultImage.setResource(succeeded ? resources.logNormalImage() : resources.logErrorImage());
    testResultImage.setStyleName(style.testResultImageStyle());
}
#method_after
@Override
public void setTestResultImage(boolean succeeded) {
    testResultImage.setResource(succeeded ? resources.logNormalImage() : resources.logErrorImage());
    testResultImage.setStylePrimaryName(style.testResultImageStyle());
}
#end_block

#method_before
private boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getUsername().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    Uri url = new Uri((String) getUrl().getEntity());
    if (url.getScheme().isEmpty()) {
        url.setScheme(Uri.SCHEME_HTTP);
        getUrl().setEntity(url.toString());
    }
    getUrl().validateEntity(new IValidation[] { new NotEmptyValidation(), new UrlValidation() });
    return getName().getIsValid() && getType().getIsValid() && getUrl().getIsValid() && getUsername().getIsValid() && getPassword().getIsValid();
}
#method_after
private boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getUsername().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    Uri url = new Uri((String) getUrl().getEntity());
    if (url.getScheme().isEmpty()) {
        url.setScheme(Uri.SCHEME_HTTP);
        getUrl().setEntity(url.toString());
    }
    getUrl().validateEntity(new IValidation[] { new NotEmptyValidation(), new UrlValidation(new String[] { Uri.SCHEME_HTTP }) });
    return getName().getIsValid() && getType().getIsValid() && getUrl().getIsValid() && getUsername().getIsValid() && getPassword().getIsValid();
}
#end_block

#method_before
private void flush() {
    provider.setName((String) privateName.getEntity());
    provider.setType((ProviderType) privateType.getSelectedItem());
    provider.setDescription((String) privateDescription.getEntity());
    provider.setUrl((String) privateUrl.getEntity());
    provider.setRequiringAuthentication((Boolean) privateRequiresAuthentication.getEntity());
    provider.setUsername((String) privateUsername.getEntity());
    provider.setPassword((String) privatePassword.getEntity());
}
#method_after
private void flush() {
    provider.setName((String) privateName.getEntity());
    provider.setType((ProviderType) privateType.getSelectedItem());
    provider.setDescription((String) privateDescription.getEntity());
    provider.setUrl((String) privateUrl.getEntity());
    boolean requiresAuthentication = (Boolean) privateRequiresAuthentication.getEntity();
    provider.setRequiringAuthentication(requiresAuthentication);
    if (requiresAuthentication) {
        provider.setUsername((String) privateUsername.getEntity());
        provider.setPassword((String) privatePassword.getEntity());
    }
}
#end_block

#method_before
private void onSave() {
    if (!validate()) {
        return;
    }
    flush();
    startProgress(null);
    Frontend.RunAction(action, new ProviderParameters(provider), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress();
            VdcReturnValueBase res = result.getReturnValue();
            if (res == null || !res.getSucceeded()) {
                return;
            }
            cancel();
            sourceListModel.getSearchCommand().execute();
        }
    });
}
#method_after
private void onSave() {
    if (!validate()) {
        return;
    }
    flush();
    Frontend.RunAction(action, new ProviderParameters(provider));
    cancel();
}
#end_block

#method_before
void initTable() {
    TextColumnWithTooltip<Provider> nameColumn = new TextColumnWithTooltip<Provider>() {

        @Override
        public String getValue(Provider object) {
            return object.getName();
        }
    };
    getTable().addColumn(nameColumn, constants.nameProvider());
    TextColumnWithTooltip<Provider> descriptionColumn = new TextColumnWithTooltip<Provider>() {

        @Override
        public String getValue(Provider object) {
            return object.getDescription();
        }
    };
    getTable().addColumn(descriptionColumn, constants.descriptionProvider());
    TextColumnWithTooltip<Provider> urlColumn = new TextColumnWithTooltip<Provider>() {

        @Override
        public String getValue(Provider object) {
            return object.getUrl();
        }
    };
    getTable().addColumn(urlColumn, constants.urlProvider());
    getTable().addActionButton(new WebAdminButtonDefinition<Provider>(constants.addProvider()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAddCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Provider>(constants.editProvider()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Provider>(constants.removeProvider()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<Provider> nameColumn = new TextColumnWithTooltip<Provider>() {

        @Override
        public String getValue(Provider object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameProvider(), "200px");
    TextColumnWithTooltip<Provider> descriptionColumn = new TextColumnWithTooltip<Provider>() {

        @Override
        public String getValue(Provider object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionProvider(), "300px");
    TextColumnWithTooltip<Provider> urlColumn = new TextColumnWithTooltip<Provider>() {

        @Override
        public String getValue(Provider object) {
            return object.getUrl();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(urlColumn, constants.urlProvider(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<Provider>(constants.addProvider()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAddCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Provider>(constants.editProvider()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Provider>(constants.removeProvider()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
private void onSave() {
    if (!validate()) {
        return;
    }
    provider.setName((String) privateName.getEntity());
    provider.setDescription((String) privateDescription.getEntity());
    provider.setUrl((String) privateUrl.getEntity());
    startProgress(null);
    Frontend.RunAction(action, new ProviderParameters(provider), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress();
            VdcReturnValueBase res = result.getReturnValue();
            if (res == null || !res.getSucceeded()) {
                return;
            }
            cancel();
            sourceListModel.getSearchCommand().execute();
        }
    });
}
#method_after
private void onSave() {
    if (!validate()) {
        return;
    }
    provider.setName((String) privateName.getEntity());
    provider.setDescription((String) privateDescription.getEntity());
    provider.setUrl((String) privateUrl.getEntity());
    Frontend.RunAction(action, new ProviderParameters(provider));
    cancel();
}
#end_block

#method_before
private void onSave() {
    if (!validate()) {
        return;
    }
    Provider provider = new Provider();
    provider.setName((String) privateName.getEntity());
    provider.setDescription((String) privateDescription.getEntity());
    provider.setUrl((String) privateUrl.getEntity());
    startProgress(null);
    Frontend.RunAction(VdcActionType.AddProvider, new ProviderParameters(provider), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress();
            VdcReturnValueBase res = result.getReturnValue();
            if (res == null || !res.getSucceeded()) {
                return;
            }
            cancel();
            sourceListModel.getSearchCommand().execute();
        }
    });
}
#method_after
private void onSave() {
    if (!validate()) {
        return;
    }
    Provider provider = new Provider();
    provider.setName((String) privateName.getEntity());
    provider.setDescription((String) privateDescription.getEntity());
    provider.setUrl((String) privateUrl.getEntity());
    Frontend.RunAction(VdcActionType.AddProvider, new ProviderParameters(provider));
    cancel();
}
#end_block

#method_before
@Override
protected void ExecuteIrsBrokerCommand() {
    /**
     * TODO: EINAV: - Consider 'RunAsync' parameter (pass it to IRS too). - Add 'description' parameter. - we should
     * provide 'volumeUUID'. - TaskID should be provided by IRS.
     */
    setReturnValue(Guid.Empty);
    log.info("-- CopyImageVDSCommand::ExecuteIrsBrokerCommand: calling 'copyImage' with two new parameters: description and UUID");
    log.infoFormat("-- copyImage parameters:" + "\r\n" + "                sdUUID={0}" + "\r\n" + "                spUUID={1}" + "\r\n" + "                vmGUID={2}" + "\r\n" + "                srcImageGUID={3}" + "\r\n" + "                srcVolUUID={4}" + "\r\n" + "                dstImageGUID={5}" + "\r\n" + "                dstVolUUID={6}" + "\r\n" + "                descr={7}" + "                dstSdUUID={8}" + "\r\n" + "                ", getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getVmId().toString(), getParameters().getImageGroupId().toString(), getParameters().getImageId().toString(), getParameters().getdstImageGroupId().toString(), getParameters().getDstImageId().toString(), getParameters().getImageDescription(), getParameters().getDstStorageDomainId());
    // NOTE: The 'uuidReturn' variable will contain the taskID and not the
    // created image id!
    uuidReturn = getIrsProxy().copyImage(getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getVmId().toString(), getParameters().getImageGroupId().toString(), getParameters().getImageId().toString(), getParameters().getdstImageGroupId().toString(), getParameters().getDstImageId().toString(), getParameters().getImageDescription(), getParameters().getDstStorageDomainId().toString(), getParameters().getCopyVolumeType().getValue(), getParameters().getVolumeFormat().getValue(), getParameters().getPreallocate().getValue(), String.valueOf(getParameters().getPostZero()).toLowerCase(), String.valueOf(getParameters().getForce()).toLowerCase());
    ProceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.mUuid);
    mCreatedImageId = getParameters().getDstImageId().toString();
    // ReturnValue = new Guid(mCreatedImageId);
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.copyImage, getParameters().getStoragePoolId()));
}
#method_after
@Override
protected void ExecuteIrsBrokerCommand() {
    /**
     * TODO: EINAV: - Consider 'RunAsync' parameter (pass it to IRS too). - Add 'description' parameter. - we should
     * provide 'volumeUUID'. - TaskID should be provided by IRS.
     */
    setReturnValue(Guid.Empty);
    log.info("-- CopyImageVDSCommand::ExecuteIrsBrokerCommand: calling 'copyImage' with two new parameters: description and UUID");
    log.infoFormat("-- copyImage parameters:" + "\r\n" + "                sdUUID={0}" + "\r\n" + "                spUUID={1}" + "\r\n" + "                vmGUID={2}" + "\r\n" + "                srcImageGUID={3}" + "\r\n" + "                srcVolUUID={4}" + "\r\n" + "                dstImageGUID={5}" + "\r\n" + "                dstVolUUID={6}" + "\r\n" + "                descr={7}" + "\r\n" + "                dstSdUUID={8}", getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getVmId().toString(), getParameters().getImageGroupId().toString(), getParameters().getImageId().toString(), getParameters().getdstImageGroupId().toString(), getParameters().getDstImageId().toString(), getParameters().getImageDescription(), getParameters().getDstStorageDomainId());
    // NOTE: The 'uuidReturn' variable will contain the taskID and not the
    // created image id!
    uuidReturn = getIrsProxy().copyImage(getParameters().getStorageDomainId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getVmId().toString(), getParameters().getImageGroupId().toString(), getParameters().getImageId().toString(), getParameters().getdstImageGroupId().toString(), getParameters().getDstImageId().toString(), getParameters().getImageDescription(), getParameters().getDstStorageDomainId().toString(), getParameters().getCopyVolumeType().getValue(), getParameters().getVolumeFormat().getValue(), getParameters().getPreallocate().getValue(), String.valueOf(getParameters().getPostZero()).toLowerCase(), String.valueOf(getParameters().getForce()).toLowerCase());
    ProceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.mUuid);
    mCreatedImageId = getParameters().getDstImageId().toString();
    // ReturnValue = new Guid(mCreatedImageId);
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.copyImage, getParameters().getStoragePoolId()));
}
#end_block

#method_before
private void saveHookContent(List<Callable<Pair<GlusterHookEntity, VDSReturnValue>>> contentTasksList) {
    if (contentTasksList.isEmpty()) {
        return;
    }
    List<Pair<GlusterHookEntity, VDSReturnValue>> pairResults = ThreadPoolUtil.invokeAll(contentTasksList);
    for (Pair<GlusterHookEntity, VDSReturnValue> pairResult : pairResults) {
        final GlusterHookEntity hook = pairResult.getFirst();
        final String content = (String) pairResult.getSecond().getReturnValue();
        getHooksDao().updateGlusterHookContent(hook.getId(), hook.getChecksum(), content);
    }
}
#method_after
private void saveHookContent(List<Callable<Pair<GlusterHookEntity, VDSReturnValue>>> contentTasksList) {
    if (contentTasksList.isEmpty()) {
        return;
    }
    List<Pair<GlusterHookEntity, VDSReturnValue>> pairResults = ThreadPoolUtil.invokeAll(contentTasksList);
    for (Pair<GlusterHookEntity, VDSReturnValue> pairResult : pairResults) {
        final GlusterHookEntity hook = pairResult.getFirst();
        if (!pairResult.getSecond().getSucceeded()) {
            log.infoFormat("Failed to get content of hook {0} with error {1} ", hook.getHookKey(), pairResult.getSecond().getVdsError().getMessage());
            logMessage(hook.getClusterId(), hook.getHookKey(), AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED);
            continue;
        }
        final String content = (String) pairResult.getSecond().getReturnValue();
        getHooksDao().updateGlusterHookContent(hook.getId(), hook.getChecksum(), content);
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    if (getVmTemplate() != null && !getVmTemplate().getDiskList().isEmpty()) {
        for (DiskImage disk : getParameters().getDiskInfoDestinationMap().values()) {
            if (disk.getStorageIds() != null && !disk.getStorageIds().isEmpty()) {
                permissionList.add(new PermissionSubject(GuidUtils.getGuidValue(getStoragePoolId()), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
            }
        }
    }
    addPermissionSubjectForAdminLevelProperties(permissionList);
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    if (getVmTemplate() != null && !getVmTemplate().getDiskList().isEmpty()) {
        for (DiskImage disk : getParameters().getDiskInfoDestinationMap().values()) {
            if (disk.getStorageIds() != null && !disk.getStorageIds().isEmpty()) {
                permissionList.add(new PermissionSubject(GuidUtils.getGuidValue(disk.getStorageIds().get(0)), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
            }
        }
    }
    addPermissionSubjectForAdminLevelProperties(permissionList);
    return permissionList;
}
#end_block

#method_before
protected Guid createTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, VdcObjectType entityType, Guid... entityIds) {
    Guid retValue = Guid.Empty;
    Transaction transaction = TransactionSupport.suspend();
    try {
        Step taskStep = ExecutionHandler.addTaskStep(getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
        if (taskStep != null) {
            asyncTaskCreationInfo.setStepId(taskStep.getId());
        }
        SPMAsyncTask task = concreteCreateTask(asyncTaskCreationInfo, parentCommand);
        retValue = task.getTaskID();
        task.setEntityType(entityType);
        task.setAssociatedEntities(entityIds);
        AsyncTaskUtils.addOrUpdateTaskInDB(task);
        getAsyncTaskManager().lockAndAddTaskToManager(task);
        retValue = task.getTaskID();
        ExecutionHandler.updateStepExternalId(taskStep, retValue, ExternalSystemType.VDSM);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return retValue;
}
#method_after
protected Guid createTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, VdcObjectType entityType, Guid... entityIds) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        return createTaskImpl(asyncTaskCreationInfo, parentCommand, description, entityType, entityIds);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return Guid.Empty;
}
#end_block

#method_before
@Override
protected void ExecuteVdsIdCommand() {
    if (_vdsManager == null) {
        getVDSReturnValue().setSucceeded(false);
        return;
    }
    VDSReturnValue retVal = runHibernateBrokerVDSCommand();
    if (retVal.getSucceeded()) {
        changeVmStatusToSavingState();
        getVDSReturnValue().setSucceeded(true);
    } else {
        log.errorFormat("VDS::hibernate Failed hibernate vm '{0}' in vds = {1} : {2}, error = {3}", getParameters().getVmId(), getVds().getId(), getVds().getName(), retVal.getExceptionString());
        getVDSReturnValue().setSucceeded(false);
        getVDSReturnValue().setExceptionString(retVal.getExceptionString());
        getVDSReturnValue().setExceptionObject(retVal.getExceptionObject());
        getVDSReturnValue().setVdsError(retVal.getVdsError());
    }
}
#method_after
@Override
protected void ExecuteVdsIdCommand() {
    if (_vdsManager == null) {
        getVDSReturnValue().setSucceeded(false);
        return;
    }
    VDSReturnValue retVal = runHibernateBrokerVDSCommand();
    if (retVal.getSucceeded()) {
        changeVmStatusToSavingState();
        getVDSReturnValue().setSucceeded(true);
    } else {
        log.errorFormat("Failed to hibernate vm '{0}' in vds = {1} : {2}, error = {3}", getParameters().getVmId(), getVds().getId(), getVds().getName(), retVal.getExceptionString());
        getVDSReturnValue().setSucceeded(false);
        getVDSReturnValue().setExceptionString(retVal.getExceptionString());
        getVDSReturnValue().setExceptionObject(retVal.getExceptionObject());
        getVDSReturnValue().setVdsError(retVal.getVdsError());
    }
}
#end_block

#method_before
private List<storage_pool> asList(Object returnValue) {
    if (returnValue instanceof ArrayList) {
        return (ArrayList<storage_pool>) returnValue;
    }
    if (returnValue instanceof storage_pool) {
        List<storage_pool> res = new ArrayList<storage_pool>();
        res.add((storage_pool) returnValue);
        return res;
    }
    // $NON-NLS-1$
    throw new IllegalArgumentException("Expected ArrayList of storage_pools or a storage_pool. Given " + returnValue.getClass().getName());
}
#method_after
private List<StoragePool> asList(Object returnValue) {
    if (returnValue instanceof ArrayList) {
        return (ArrayList<StoragePool>) returnValue;
    }
    if (returnValue instanceof StoragePool) {
        List<StoragePool> res = new ArrayList<StoragePool>();
        res.add((StoragePool) returnValue);
        return res;
    }
    // $NON-NLS-1$
    throw new IllegalArgumentException("Expected ArrayList of storage_pools or a storage_pool. Given " + returnValue.getClass().getName());
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removePoolsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_pool");
    model.setMessage(ConstantsManager.getInstance().getConstants().poolsMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (VmPool item : Linq.<VmPool>Cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removePoolsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_pool");
    model.setMessage(ConstantsManager.getInstance().getConstants().poolsMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (VmPool item : Linq.<VmPool>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
public void edit(final UnitVmModel object) {
    super.edit(object);
    initTabAvailabilityListeners(object);
    isStatelessEditor.setVisible(false);
    poolNameIcon.setVisible(true);
    if (object.getIsNew()) {
        prestartedVmsEditor.setEnabled(false);
        maxAssignedVmsPerUserEditor.setEnabled(false);
        // $NON-NLS-1$
        object.getNumOfDesktops().setEntity("1");
        numOfVmsEditor.setVisible(true);
        newPoolEditVmsPanel.setVisible(true);
        newPoolEditMaxAssignedVmsPerUserPanel.setVisible(true);
        editPoolEditVmsPanel.setVisible(false);
        editPoolIncraseNumOfVmsPanel.setVisible(false);
        editPoolEditMaxAssignedVmsPerUserPanel.setVisible(false);
    } else {
        numOfVmsEditor.setVisible(false);
        newPoolEditVmsPanel.setVisible(false);
        newPoolEditMaxAssignedVmsPerUserPanel.setVisible(false);
        editPoolEditVmsPanel.setVisible(true);
        prestartedVmsEditor.setEnabled(true);
        editPoolIncraseNumOfVmsPanel.setVisible(true);
        editPoolEditMaxAssignedVmsPerUserPanel.setVisible(true);
    }
}
#method_after
@Override
public void edit(final UnitVmModel object) {
    super.edit(object);
    initTabAvailabilityListeners(object);
    isStatelessEditor.setVisible(false);
    poolNameIcon.setVisible(true);
    isRunAndPauseEditor.setVisible(false);
    if (object.getIsNew()) {
        prestartedVmsEditor.setEnabled(false);
        maxAssignedVmsPerUserEditor.setEnabled(false);
        // $NON-NLS-1$
        object.getNumOfDesktops().setEntity("1");
        numOfVmsEditor.setVisible(true);
        newPoolEditVmsPanel.setVisible(true);
        newPoolEditMaxAssignedVmsPerUserPanel.setVisible(true);
        editPoolEditVmsPanel.setVisible(false);
        editPoolIncraseNumOfVmsPanel.setVisible(false);
        editPoolEditMaxAssignedVmsPerUserPanel.setVisible(false);
    } else {
        numOfVmsEditor.setVisible(false);
        newPoolEditVmsPanel.setVisible(false);
        newPoolEditMaxAssignedVmsPerUserPanel.setVisible(false);
        editPoolEditVmsPanel.setVisible(true);
        prestartedVmsEditor.setEnabled(true);
        editPoolIncraseNumOfVmsPanel.setVisible(true);
        editPoolEditMaxAssignedVmsPerUserPanel.setVisible(true);
    }
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenter().setIsChangable(false);
        getCluster().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenter().setIsChangable(false);
        getCluster().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public void setIsBlankTemplate(boolean value) {
    if (isBlankTemplate != value) {
        isBlankTemplate = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsBlankTemplate"));
    }
}
#method_after
public void setIsBlankTemplate(boolean value) {
    if (isBlankTemplate != value) {
        isBlankTemplate = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsBlankTemplate"));
    }
}
#end_block

#method_before
public void setIsWindowsOS(boolean value) {
    if (isWindowsOS != value) {
        isWindowsOS = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsWindowsOS"));
    }
}
#method_after
public void setIsWindowsOS(boolean value) {
    if (isWindowsOS != value) {
        isWindowsOS = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsWindowsOS"));
    }
}
#end_block

#method_before
public void setIsLinuxOS(boolean value) {
    if (isLinuxOS != value) {
        isLinuxOS = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsLinuxOS"));
    }
}
#method_after
public void setIsLinuxOS(boolean value) {
    if (isLinuxOS != value) {
        isLinuxOS = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsLinuxOS"));
    }
}
#end_block

#method_before
public void setCPUNotification(String value) {
    if (!StringHelper.stringsEqual(cpuNotification, value)) {
        cpuNotification = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("CPUNotification"));
    }
}
#method_after
public void setCPUNotification(String value) {
    if (!StringHelper.stringsEqual(cpuNotification, value)) {
        cpuNotification = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("CPUNotification"));
    }
}
#end_block

#method_before
public void setIsCPUsAmountValid(boolean value) {
    if (isCPUsAmountValid != value) {
        isCPUsAmountValid = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsCPUsAmountValid"));
    }
}
#method_after
public void setIsCPUsAmountValid(boolean value) {
    if (isCPUsAmountValid != value) {
        isCPUsAmountValid = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsCPUsAmountValid"));
    }
}
#end_block

#method_before
public void setIsGeneralTabValid(boolean value) {
    if (isGeneralTabValid != value) {
        isGeneralTabValid = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsGeneralTabValid"));
    }
}
#method_after
public void setIsGeneralTabValid(boolean value) {
    if (isGeneralTabValid != value) {
        isGeneralTabValid = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsGeneralTabValid"));
    }
}
#end_block

#method_before
public void setIsFirstRunTabValid(boolean value) {
    if (isFirstRunTabValid != value) {
        isFirstRunTabValid = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsFirstRunTabValid"));
    }
}
#method_after
public void setIsFirstRunTabValid(boolean value) {
    if (isFirstRunTabValid != value) {
        isFirstRunTabValid = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsFirstRunTabValid"));
    }
}
#end_block

#method_before
public void setIsDisplayTabValid(boolean value) {
    if (isDisplayTabValid != value) {
        isDisplayTabValid = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsDisplayTabValid"));
    }
}
#method_after
public void setIsDisplayTabValid(boolean value) {
    if (isDisplayTabValid != value) {
        isDisplayTabValid = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsDisplayTabValid"));
    }
}
#end_block

#method_before
public void setIsAllocationTabValid(boolean value) {
    if (isAllocationTabValid != value) {
        isAllocationTabValid = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsAllocationTabValid"));
    }
}
#method_after
public void setIsAllocationTabValid(boolean value) {
    if (isAllocationTabValid != value) {
        isAllocationTabValid = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsAllocationTabValid"));
    }
}
#end_block

#method_before
public void setIsHostTabValid(boolean value) {
    if (isHostTabValid != value) {
        isHostTabValid = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsHostTabValid"));
    }
}
#method_after
public void setIsHostTabValid(boolean value) {
    if (isHostTabValid != value) {
        isHostTabValid = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsHostTabValid"));
    }
}
#end_block

#method_before
public void setIsBootSequenceTabValid(boolean value) {
    if (isBootSequenceTabValid != value) {
        isBootSequenceTabValid = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsBootSequenceTabValid"));
    }
}
#method_after
public void setIsBootSequenceTabValid(boolean value) {
    if (isBootSequenceTabValid != value) {
        isBootSequenceTabValid = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsBootSequenceTabValid"));
    }
}
#end_block

#method_before
public void setIsCustomPropertiesTabValid(boolean value) {
    if (isCustomPropertiesTabValid != value) {
        isCustomPropertiesTabValid = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsCustomPropertiesTabValid"));
    }
}
#method_after
public void setIsCustomPropertiesTabValid(boolean value) {
    if (isCustomPropertiesTabValid != value) {
        isCustomPropertiesTabValid = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsCustomPropertiesTabValid"));
    }
}
#end_block

#method_before
public void setDisks(List<DiskModel> value) {
    if (disks != value) {
        disks = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("Disks"));
    }
}
#method_after
public void setDisks(List<DiskModel> value) {
    if (disks != value) {
        disks = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Disks"));
    }
}
#end_block

#method_before
public void setIsDisksAvailable(boolean value) {
    if (isDisksAvailable != value) {
        isDisksAvailable = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsDisksAvailable"));
    }
}
#method_after
public void setIsDisksAvailable(boolean value) {
    isDisksAvailable = value;
    // $NON-NLS-1$
    onPropertyChanged(new PropertyChangedEventArgs("IsDisksAvailable"));
}
#end_block

#method_before
public void setIsHostAvailable(boolean value) {
    if (isHostAvailable != value) {
        isHostAvailable = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsHostAvailable"));
    }
}
#method_after
public void setIsHostAvailable(boolean value) {
    if (isHostAvailable != value) {
        isHostAvailable = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsHostAvailable"));
    }
}
#end_block

#method_before
public void setIsCustomPropertiesTabAvailable(boolean value) {
    if (isCustomPropertiesTabAvailable != value) {
        isCustomPropertiesTabAvailable = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsCustomPropertiesTabAvailable"));
    }
}
#method_after
public void setIsCustomPropertiesTabAvailable(boolean value) {
    if (isCustomPropertiesTabAvailable != value) {
        isCustomPropertiesTabAvailable = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsCustomPropertiesTabAvailable"));
    }
}
#end_block

#method_before
public void setIsDatacenterAvailable(Boolean value) {
    if (isDatacenterAvailable == null && value == null) {
        return;
    }
    if (isDatacenterAvailable == null || !isDatacenterAvailable.equals(value)) {
        isDatacenterAvailable = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsDatacenterAvailable"));
    }
}
#method_after
public void setIsDatacenterAvailable(Boolean value) {
    if (isDatacenterAvailable == null && value == null) {
        return;
    }
    if (isDatacenterAvailable == null || !isDatacenterAvailable.equals(value)) {
        isDatacenterAvailable = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsDatacenterAvailable"));
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.SelectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            DataCenter_SelectedItemChanged(sender, args);
        } else if (sender == getTemplate()) {
            Template_SelectedItemChanged(sender, args);
        } else if (sender == getCluster()) {
            Cluster_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getTimeZone()) {
            TimeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            DefaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            OSType_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            FirstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            DisplayProtocol_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            NumOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            CoresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
        }
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            MemSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            TotalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
        } else if (sender == getProvisioning()) {
            Provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            dataCenter_SelectedItemChanged(sender, args);
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getCluster()) {
            cluster_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            oSType_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
        }
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        }
    }
}
#end_block

#method_before
private void initVncKeyboardLayout() {
    final List<String> layouts = (List<String>) AsyncDataProvider.GetConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    final ArrayList<String> vncKeyboardLayoutItems = new ArrayList<String>();
    // null value means the global VncKeyboardLayout from vdc_options will be used
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsAvailable(isVncSelected());
}
#method_after
private void initVncKeyboardLayout() {
    final List<String> layouts = (List<String>) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    final ArrayList<String> vncKeyboardLayoutItems = new ArrayList<String>();
    // null value means the global VncKeyboardLayout from vdc_options will be used
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsAvailable(isVncSelected());
}
#end_block

#method_before
public void setBootSequence(BootSequence value) {
    ArrayList<BootSequence> items = new ArrayList<BootSequence>();
    for (char a : value.toString().toCharArray()) {
        items.add(BootSequence.valueOf((new Character(a)).toString()));
    }
    Object firstBootDevice = null;
    for (Object item : getFirstBootDevice().getItems()) {
        EntityModel a = (EntityModel) item;
        if ((BootSequence) a.getEntity() == Linq.FirstOrDefault(items)) {
            firstBootDevice = a;
        }
    }
    getFirstBootDevice().setSelectedItem(firstBootDevice);
    ArrayList<EntityModel> secondDeviceOptions = Linq.<EntityModel>Cast(getSecondBootDevice().getItems());
    if (items.size() > 1) {
        BootSequence last = items.get(items.size() - 1);
        for (EntityModel a : secondDeviceOptions) {
            if (a.getEntity() != null && (BootSequence) a.getEntity() == last) {
                getSecondBootDevice().setSelectedItem(a);
                break;
            }
        }
    } else {
        for (EntityModel a : secondDeviceOptions) {
            if (a.getEntity() == null) {
                getSecondBootDevice().setSelectedItem(a);
                break;
            }
        }
    }
}
#method_after
public void setBootSequence(BootSequence value) {
    ArrayList<BootSequence> items = new ArrayList<BootSequence>();
    for (char a : value.toString().toCharArray()) {
        items.add(BootSequence.valueOf(String.valueOf(a)));
    }
    Object firstBootDevice = null;
    for (Object item : getFirstBootDevice().getItems()) {
        EntityModel a = (EntityModel) item;
        if ((BootSequence) a.getEntity() == Linq.firstOrDefault(items)) {
            firstBootDevice = a;
        }
    }
    getFirstBootDevice().setSelectedItem(firstBootDevice);
    ArrayList<EntityModel> secondDeviceOptions = Linq.<EntityModel>cast(getSecondBootDevice().getItems());
    if (items.size() > 1) {
        BootSequence last = items.get(items.size() - 1);
        for (EntityModel a : secondDeviceOptions) {
            if (a.getEntity() != null && (BootSequence) a.getEntity() == last) {
                getSecondBootDevice().setSelectedItem(a);
                break;
            }
        }
    } else {
        for (EntityModel a : secondDeviceOptions) {
            if (a.getEntity() == null) {
                getSecondBootDevice().setSelectedItem(a);
                break;
            }
        }
    }
}
#end_block

#method_before
private void setDataCenter(NotChangableForVmInPoolListModel value) {
    privateDataCenter = value;
}
#method_after
public void setDataCenter(UnitVmModel model, ArrayList<StoragePool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (StoragePool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case Cluster_Gluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                if (cluster.supportsVirtService()) {
                    for (StoragePool dc : list) {
                        if (dc.getId().equals(cluster.getStoragePoolId())) {
                            model.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                            model.getDataCenter().setSelectedItem(dc);
                            break;
                        }
                    }
                    model.getDataCenter().setIsChangable(false);
                    // $NON-NLS-1$
                    model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                }
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (StoragePool dc : list) {
                    if (dc.getId().equals(host.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                StorageDomain storage = (StorageDomain) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (StoragePool dc : list) {
                    if (dc.getId().equals(storage.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.firstOrDefault(list));
    }
}
#end_block

#method_before
public void setIsPoolTabValid(boolean value) {
    if (isPoolTabValid != value) {
        isPoolTabValid = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("IsPoolTabValid"));
    }
}
#method_after
public void setIsPoolTabValid(boolean value) {
    if (isPoolTabValid != value) {
        isPoolTabValid = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("IsPoolTabValid"));
    }
}
#end_block

#method_before
public void setPrestartedVmsHint(String value) {
    if (prestartedVmsHint != value) {
        prestartedVmsHint = value;
        // $NON-NLS-1$
        OnPropertyChanged(new PropertyChangedEventArgs("PrestartedVmsHint"));
    }
}
#method_after
public void setPrestartedVmsHint(String value) {
    if (!StringHelper.stringsEqual(prestartedVmsHint, value)) {
        prestartedVmsHint = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("PrestartedVmsHint"));
    }
}
#end_block

#method_before
@Override
public void setIsChangable(boolean value) {
    if (!isVmAttachedToPool())
        super.setIsChangable(value);
}
#method_after
@Override
public ListModel setIsChangable(boolean value) {
    if (!isVmAttachedToPool())
        super.setIsChangable(value);
    return this;
}
#end_block

#method_before
@Override
public void setIsChangable(boolean value) {
    if (!isVmAttachedToPool())
        super.setIsChangable(value);
}
#method_after
@Override
public EntityModel setIsChangable(boolean value) {
    if (!isVmAttachedToPool())
        super.setIsChangable(value);
    return this;
}
#end_block

#method_before
@Override
public void setIsChangable(boolean value) {
    if (!isVmAttachedToPool())
        super.setIsChangable(value);
}
#method_after
@Override
public KeyValueModel setIsChangable(boolean value) {
    if (!isVmAttachedToPool())
        super.setIsChangable(value);
    return this;
}
#end_block

#method_before
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(vmBase.getOs());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getNumOfMonitors());
        getModel().getDomain().setSelectedItem(vmBase.getDomain());
        getModel().getMemSize().setEntity(vmBase.getMemSizeMb());
        getModel().getUsbPolicy().setSelectedItem(vmBase.getUsbPolicy());
        getModel().setBootSequence(vmBase.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.isAutoStartup());
        getModel().getIsDeleteProtected().setEntity(vmBase.isDeleteProtected());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        getModel().getVncKeyboardLayout().setSelectedItem(vmBase.getVncKeyboardLayout());
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
        }
        if (!StringHelper.isNullOrEmpty(vmBase.getTimeZone())) {
            updateTimeZone(vmBase.getTimeZone());
        } else {
            UpdateDefaultTimeZone();
        }
        // Update domain list
        UpdateDomain();
        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) getModel().getCluster().getItems();
        VDSGroup selectCluster = Linq.FirstOrDefault(clusters, new Linq.ClusterPredicate(vmBase.getVdsGroupId()));
        getModel().getCluster().setSelectedItem((selectCluster != null) ? selectCluster : Linq.FirstOrDefault(clusters));
        // Update display protocol selected item
        EntityModel displayProtocol = null;
        boolean isFirst = true;
        for (Object item : getModel().getDisplayProtocol().getItems()) {
            EntityModel a = (EntityModel) item;
            if (isFirst) {
                displayProtocol = a;
                isFirst = false;
            }
            DisplayType dt = (DisplayType) a.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = a;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getKernelUrl());
        getModel().getKernel_parameters().setEntity(vmBase.getKernelParams());
        getModel().getInitrd_path().setEntity(vmBase.getInitrdUrl());
        getModel().setIsDisksAvailable(true);
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            InitDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        InitPriority(vmBase.getPriority());
        InitStorageDomains();
        // use min. allocated memory from the template, if specified
        if (vmBase.getMinAllocatedMem() == 0) {
            UpdateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
        }
    }
}
#method_after
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(vmBase.getOs());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getNumOfMonitors());
        getModel().getDomain().setSelectedItem(vmBase.getDomain());
        getModel().getMemSize().setEntity(vmBase.getMemSizeMb());
        getModel().getUsbPolicy().setSelectedItem(vmBase.getUsbPolicy());
        getModel().setBootSequence(vmBase.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.isAutoStartup());
        getModel().getIsDeleteProtected().setEntity(vmBase.isDeleteProtected());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        getModel().getVncKeyboardLayout().setSelectedItem(vmBase.getVncKeyboardLayout());
        getModel().getIsRunAndPause().setEntity(false);
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
        }
        if (!StringHelper.isNullOrEmpty(vmBase.getTimeZone())) {
            updateTimeZone(vmBase.getTimeZone());
        } else {
            updateDefaultTimeZone();
        }
        // Update domain list
        updateDomain();
        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) getModel().getCluster().getItems();
        VDSGroup selectCluster = Linq.firstOrDefault(clusters, new Linq.ClusterPredicate(vmBase.getVdsGroupId()));
        getModel().getCluster().setSelectedItem((selectCluster != null) ? selectCluster : Linq.firstOrDefault(clusters));
        // Update display protocol selected item
        EntityModel displayProtocol = null;
        boolean isFirst = true;
        for (Object item : getModel().getDisplayProtocol().getItems()) {
            EntityModel a = (EntityModel) item;
            if (isFirst) {
                displayProtocol = a;
                isFirst = false;
            }
            DisplayType dt = (DisplayType) a.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = a;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getKernelUrl());
        getModel().getKernel_parameters().setEntity(vmBase.getKernelParams());
        getModel().getInitrd_path().setEntity(vmBase.getInitrdUrl());
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            initDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        initPriority(vmBase.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (vmBase.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
        }
    }
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((storage_pool) object).getname();
        }
    });
    clusterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDSGroup) object).getname();
        }
    });
    quotaEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Quota) object).getQuotaName();
        }
    });
    templateEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VmTemplate) object).getName();
        }
    });
    oSTypeEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return object.toString();
        }
    });
    timeZoneEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Entry<String, String>) object).getValue();
        }
    });
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    usbSupportEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return object.toString();
        }
    });
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<Object>(new AbstractRenderer<Object>() {

        final String globalLayout = (String) AsyncDataProvider.GetConfigValuePreConverted(ConfigurationValues.VncKeyboardLayout);

        @Override
        public String render(Object object) {
            if (object == null) {
                return messages.globalVncKeyboardLayoutCaption(globalLayout);
            } else {
                return object.toString();
            }
        }
    });
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    // $NON-NLS-1$
    isAutoAssignEditor = new EntityModelRadioButtonEditor("runVmOnHostGroup");
    defaultHostEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDS) object).getName();
        }
    });
    migrationModeEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    // Resource Allocation
    // $NON-NLS-1$
    provisioningThinEditor = new EntityModelRadioButtonEditor("provisioningGroup");
    // $NON-NLS-1$
    provisioningCloneEditor = new EntityModelRadioButtonEditor("provisioningGroup");
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    secondBootDeviceEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    cdImageEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return (String) object;
        }
    });
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((StoragePool) object).getname();
        }
    });
    clusterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDSGroup) object).getname();
        }
    });
    quotaEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Quota) object).getQuotaName();
        }
    });
    templateEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VmTemplate) object).getName();
        }
    });
    oSTypeEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return object.toString();
        }
    });
    timeZoneEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Entry<String, String>) object).getValue();
        }
    });
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    usbSupportEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return object.toString();
        }
    });
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<Object>(new AbstractRenderer<Object>() {

        final String globalLayout = (String) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayout);

        @Override
        public String render(Object object) {
            if (object == null) {
                return messages.globalVncKeyboardLayoutCaption(globalLayout);
            } else {
                return object.toString();
            }
        }
    });
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    // $NON-NLS-1$
    isAutoAssignEditor = new EntityModelRadioButtonEditor("runVmOnHostGroup");
    defaultHostEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDS) object).getName();
        }
    });
    migrationModeEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    // Resource Allocation
    // $NON-NLS-1$
    provisioningThinEditor = new EntityModelRadioButtonEditor("provisioningGroup");
    // $NON-NLS-1$
    provisioningCloneEditor = new EntityModelRadioButtonEditor("provisioningGroup");
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    secondBootDeviceEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    cdImageEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return (String) object;
        }
    });
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterEditor.setLabel(constants.dcVmPopup());
    clusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    templateEditor.setLabel(constants.basedOnTemplateVmPopup());
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
    oSTypeEditor.setLabel(constants.osVmPopup());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    cpuPinningLabel.setHTML(constants.cpuPinningLabelExplanation());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
}
#method_after
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterEditor.setLabel(constants.dcVmPopup());
    clusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    templateEditor.setLabel(constants.basedOnTemplateVmPopup());
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
    oSTypeEditor.setLabel(constants.osVmPopup());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    cpuPinningLabel.setHTML(constants.cpuPinningLabelExplanation());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
}
#end_block

#method_before
private void applyStyles() {
    hostCpuEditor.addContentWidgetStyleName(style.longCheckboxContent());
    allowConsoleReconnectEditor.addContentWidgetStyleName(style.longCheckboxContent());
    provisioningEditor.addContentWidgetStyleName(style.provisioningEditorContent());
    provisioningThinEditor.addContentWidgetStyleName(style.provisioningRadioContent());
    provisioningCloneEditor.addContentWidgetStyleName(style.provisioningRadioContent());
    cdAttachedEditor.addContentWidgetStyleName(style.cdAttachedLabelWidth());
}
#method_after
protected void applyStyles() {
    hostCpuEditor.addContentWidgetStyleName(style.longCheckboxContent());
    allowConsoleReconnectEditor.addContentWidgetStyleName(style.longCheckboxContent());
    provisioningEditor.addContentWidgetStyleName(style.provisioningEditorContent());
    provisioningThinEditor.addContentWidgetStyleName(style.provisioningRadioContent());
    provisioningCloneEditor.addContentWidgetStyleName(style.provisioningRadioContent());
    cdAttachedEditor.addContentWidgetStyleName(style.cdAttachedLabelWidth());
}
#end_block

#method_before
protected void updateUsbNativeMessageVisibility(final UnitVmModel object) {
    VDSGroup vdsGroup = (VDSGroup) object.getCluster().getSelectedItem();
    nativeUsbWarningMessage.setVisible(object.getUsbPolicy().getSelectedItem() == UsbPolicy.ENABLED_NATIVE && vdsGroup != null && vdsGroup.getcompatibility_version() != null && !(Boolean) AsyncDataProvider.GetConfigValuePreConverted(ConfigurationValues.MigrationSupportForNativeUsb, vdsGroup.getcompatibility_version().getValue()));
}
#method_after
protected void updateUsbNativeMessageVisibility(final UnitVmModel object) {
    VDSGroup vdsGroup = (VDSGroup) object.getCluster().getSelectedItem();
    nativeUsbWarningMessage.setVisible(object.getUsbPolicy().getSelectedItem() == UsbPolicy.ENABLED_NATIVE && vdsGroup != null && vdsGroup.getcompatibility_version() != null && !(Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MigrationSupportForNativeUsb, vdsGroup.getcompatibility_version().getValue()));
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    quotaEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = generalAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    quotaEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = generalAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public void edit(final UnitVmModel object) {
    super.edit(object);
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getProgress() == null) {
                // $NON-NLS-1$
                disableAllTabs();
                enableEditPoolFields();
            }
        }
    });
}
#method_after
@Override
public void edit(final UnitVmModel object) {
    super.edit(object);
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getProgress() == null) {
                disableAllTabs();
                enableEditPoolFields();
            }
        }
    });
}
#end_block

#method_before
@Override
public void Initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.Initialize(systemTreeSelectedItem);
    AsyncDataProvider.GetDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<storage_pool> list = new ArrayList<storage_pool>();
            for (storage_pool a : (ArrayList<storage_pool>) returnValue) {
                if (a.getstatus() == StoragePoolStatus.Up) {
                    list.add(a);
                }
            }
            model.SetDataCenter(model, list);
        }
    }, getModel().getHash()), true, false);
    InitPriority(0);
}
#method_after
@Override
public void Initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.Initialize(systemTreeSelectedItem);
    AsyncDataProvider.GetDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<StoragePool> list = new ArrayList<StoragePool>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getstatus() == StoragePoolStatus.Up) {
                    list.add(a);
                }
            }
            model.SetDataCenter(model, list);
        }
    }, getModel().getHash()), true, false);
    InitPriority(0);
}
#end_block

#method_before
@Override
public void DataCenter_SelectedItemChanged() {
    storage_pool dataCenter = (storage_pool) getModel().getDataCenter().getSelectedItem();
    getModel().setIsHostAvailable(dataCenter.getstorage_pool_type() != StorageType.LOCALFS);
    AsyncDataProvider.GetClusterByServiceList(new AsyncQuery(new Object[] { this, getModel() }, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            NewVmModelBehavior behavior = (NewVmModelBehavior) array[0];
            UnitVmModel model = (UnitVmModel) array[1];
            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
            model.SetClusters(model, clusters, null);
            behavior.InitTemplate();
            behavior.InitCdImage();
        }
    }, getModel().getHash()), dataCenter.getId(), true, false);
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
}
#method_after
@Override
public void DataCenter_SelectedItemChanged() {
    StoragePool dataCenter = (StoragePool) getModel().getDataCenter().getSelectedItem();
    getModel().setIsHostAvailable(dataCenter.getstorage_pool_type() != StorageType.LOCALFS);
    AsyncDataProvider.GetClusterByServiceList(new AsyncQuery(new Object[] { this, getModel() }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            NewVmModelBehavior behavior = (NewVmModelBehavior) array[0];
            UnitVmModel model = (UnitVmModel) array[1];
            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
            model.SetClusters(model, clusters, null);
            behavior.InitTemplate();
            behavior.InitCdImage();
        }
    }, getModel().getHash()), dataCenter.getId(), true, false);
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
}
#end_block

#method_before
@Override
public void Cluster_SelectedItemChanged() {
    UpdateDefaultHost();
    updateCustomPropertySheet();
    UpdateMinAllocatedMemory();
    UpdateNumOfSockets();
    if ((VmTemplate) getModel().getTemplate().getSelectedItem() != null) {
        VmTemplate template = (VmTemplate) getModel().getTemplate().getSelectedItem();
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    }
    updateCpuPinningVisibility();
}
#method_after
@Override
public void Cluster_SelectedItemChanged() {
    UpdateDefaultHost();
    updateCustomPropertySheet();
    UpdateMinAllocatedMemory();
    UpdateNumOfSockets();
    if (getModel().getTemplate().getSelectedItem() != null) {
        VmTemplate template = (VmTemplate) getModel().getTemplate().getSelectedItem();
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    }
    updateCpuPinningVisibility();
}
#end_block

#method_before
private void InitTemplate() {
    storage_pool dataCenter = (storage_pool) getModel().getDataCenter().getSelectedItem();
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain storage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        AsyncDataProvider.GetTemplateListByDataCenter(new AsyncQuery(new Object[] { this, storage }, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target1, Object returnValue1) {
                Object[] array1 = (Object[]) target1;
                NewVmModelBehavior behavior1 = (NewVmModelBehavior) array1[0];
                StorageDomain storage1 = (StorageDomain) array1[1];
                AsyncDataProvider.GetTemplateListByStorage(new AsyncQuery(new Object[] { behavior1, returnValue1 }, new INewAsyncCallback() {

                    @Override
                    public void OnSuccess(Object target2, Object returnValue2) {
                        Object[] array2 = (Object[]) target2;
                        NewVmModelBehavior behavior2 = (NewVmModelBehavior) array2[0];
                        ArrayList<VmTemplate> templatesByDataCenter = (ArrayList<VmTemplate>) array2[1];
                        ArrayList<VmTemplate> templatesByStorage = (ArrayList<VmTemplate>) returnValue2;
                        VmTemplate blankTemplate = Linq.FirstOrDefault(templatesByDataCenter, new Linq.TemplatePredicate(NGuid.Empty));
                        if (blankTemplate != null) {
                            templatesByStorage.add(0, blankTemplate);
                        }
                        behavior2.PostInitTemplate((ArrayList<VmTemplate>) returnValue2);
                    }
                }), storage1.getId());
            }
        }, getModel().getHash()), dataCenter.getId());
    } else {
        AsyncDataProvider.GetTemplateListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target, Object returnValue) {
                NewVmModelBehavior behavior = (NewVmModelBehavior) target;
                behavior.PostInitTemplate((ArrayList<VmTemplate>) returnValue);
            }
        }, getModel().getHash()), dataCenter.getId());
    }
}
#method_after
private void InitTemplate() {
    StoragePool dataCenter = (StoragePool) getModel().getDataCenter().getSelectedItem();
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain storage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        AsyncDataProvider.GetTemplateListByDataCenter(new AsyncQuery(new Object[] { this, storage }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target1, Object returnValue1) {
                Object[] array1 = (Object[]) target1;
                NewVmModelBehavior behavior1 = (NewVmModelBehavior) array1[0];
                StorageDomain storage1 = (StorageDomain) array1[1];
                AsyncDataProvider.GetTemplateListByStorage(new AsyncQuery(new Object[] { behavior1, returnValue1 }, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target2, Object returnValue2) {
                        Object[] array2 = (Object[]) target2;
                        NewVmModelBehavior behavior2 = (NewVmModelBehavior) array2[0];
                        ArrayList<VmTemplate> templatesByDataCenter = (ArrayList<VmTemplate>) array2[1];
                        ArrayList<VmTemplate> templatesByStorage = (ArrayList<VmTemplate>) returnValue2;
                        VmTemplate blankTemplate = Linq.firstOrDefault(templatesByDataCenter, new Linq.TemplatePredicate(NGuid.Empty));
                        if (blankTemplate != null) {
                            templatesByStorage.add(0, blankTemplate);
                        }
                        behavior2.PostInitTemplate((ArrayList<VmTemplate>) returnValue2);
                    }
                }), storage1.getId());
            }
        }, getModel().getHash()), dataCenter.getId());
    } else {
        AsyncDataProvider.GetTemplateListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                NewVmModelBehavior behavior = (NewVmModelBehavior) target;
                behavior.PostInitTemplate((ArrayList<VmTemplate>) returnValue);
            }
        }, getModel().getHash()), dataCenter.getId());
    }
}
#end_block

#method_before
private void PostInitTemplate(ArrayList<VmTemplate> templates) {
    // If there was some template selected before, try select it again.
    VmTemplate oldTemplate = (VmTemplate) getModel().getTemplate().getSelectedItem();
    getModel().getTemplate().setItems(templates);
    getModel().getTemplate().setSelectedItem(Linq.FirstOrDefault(templates, oldTemplate != null ? new Linq.TemplatePredicate(oldTemplate.getId()) : new Linq.TemplatePredicate(NGuid.Empty)));
    UpdateIsDisksAvailable();
}
#method_after
private void PostInitTemplate(ArrayList<VmTemplate> templates) {
    // If there was some template selected before, try select it again.
    VmTemplate oldTemplate = (VmTemplate) getModel().getTemplate().getSelectedItem();
    getModel().getTemplate().setItems(templates);
    getModel().getTemplate().setSelectedItem(Linq.firstOrDefault(templates, oldTemplate != null ? new Linq.TemplatePredicate(oldTemplate.getId()) : new Linq.TemplatePredicate(NGuid.Empty)));
    UpdateIsDisksAvailable();
}
#end_block

#method_before
public void InitCdImage() {
    updateUserCdImage(((storage_pool) getModel().getDataCenter().getSelectedItem()).getId());
}
#method_after
public void InitCdImage() {
    updateUserCdImage(((StoragePool) getModel().getDataCenter().getSelectedItem()).getId());
}
#end_block

#method_before
protected void updateUserCdImage(Guid storagePoolId) {
    AsyncDataProvider.GetIrsImageList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            List<String> images = (List<String>) returnValue;
            setImagesToModel(model, images);
        }
    }), storagePoolId);
}
#method_after
protected void updateUserCdImage(Guid storagePoolId) {
    AsyncDataProvider.GetIrsImageList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            List<String> images = (List<String>) returnValue;
            setImagesToModel(model, images);
        }
    }), storagePoolId);
}
#end_block

#method_before
protected void setImagesToModel(UnitVmModel model, List<String> images) {
    String oldCdImage = (String) model.getCdImage().getSelectedItem();
    model.getCdImage().setItems(images);
    model.getCdImage().setSelectedItem((oldCdImage != null) ? oldCdImage : Linq.FirstOrDefault(images));
}
#method_after
protected void setImagesToModel(UnitVmModel model, List<String> images) {
    String oldCdImage = (String) model.getCdImage().getSelectedItem();
    model.getCdImage().setItems(images);
    model.getCdImage().setSelectedItem((oldCdImage != null) ? oldCdImage : Linq.firstOrDefault(images));
}
#end_block

#method_before
protected void UpdateCdImage() {
    storage_pool dataCenter = (storage_pool) getModel().getDataCenter().getSelectedItem();
    if (dataCenter == null) {
        return;
    }
    AsyncDataProvider.GetIrsImageList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<String> images = (ArrayList<String>) returnValue;
            setImagesToModel(model, images);
        }
    }, getModel().getHash()), dataCenter.getId());
}
#method_after
protected void UpdateCdImage() {
    StoragePool dataCenter = (StoragePool) getModel().getDataCenter().getSelectedItem();
    if (dataCenter == null) {
        return;
    }
    AsyncDataProvider.GetIrsImageList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<String> images = (ArrayList<String>) returnValue;
            setImagesToModel(model, images);
        }
    }, getModel().getHash()), dataCenter.getId());
}
#end_block

#method_before
protected void updateTimeZone(final String selectedTimeZone) {
    final TimezoneType timezoneType = TimezoneType.getTimezoneByOs(getModel().getIsWindowsOS());
    if (cachedTimeZones.get(timezoneType) == null) {
        AsyncDataProvider.GetTimeZoneList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target, Object returnValue) {
                VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
                Map<String, String> timezones = (Map<String, String>) returnValue;
                // empty entry for default timezone
                // $NON-NLS-1$
                timezones.put(null, "");
                cachedTimeZones.put(timezoneType, timezones.entrySet());
                behavior.PostUpdateTimeZone(selectedTimeZone);
            }
        }, getModel().getHash()));
    } else {
        PostUpdateTimeZone(selectedTimeZone);
    }
}
#method_after
protected void updateTimeZone(final String selectedTimeZone) {
    final TimezoneType timezoneType = TimezoneType.getTimezoneByOs(getModel().getIsWindowsOS());
    if (cachedTimeZones.get(timezoneType) == null) {
        AsyncDataProvider.GetTimeZoneList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
                Map<String, String> timezones = (Map<String, String>) returnValue;
                // empty entry for default timezone
                // $NON-NLS-1$
                timezones.put(null, "");
                cachedTimeZones.put(timezoneType, timezones.entrySet());
                behavior.PostUpdateTimeZone(selectedTimeZone);
            }
        }, getModel().getHash()));
    } else {
        PostUpdateTimeZone(selectedTimeZone);
    }
}
#end_block

#method_before
private void PostUpdateTimeZone(String selectedTimeZone) {
    if (getModel().getIsWindowsOS() != lastIsWinOS) {
        lastIsWinOS = getModel().getIsWindowsOS();
        if (selectedTimeZone != null) {
            if (getModel().getIsWindowsOS()) {
                generalTimezonesString = selectedTimeZone;
            } else {
                winTimezoneString = selectedTimeZone;
            }
        }
        selectedTimeZone = getModel().getIsWindowsOS() ? winTimezoneString : generalTimezonesString;
    } else {
        if (selectedTimeZone != null) {
            if (getModel().getIsWindowsOS()) {
                winTimezoneString = selectedTimeZone;
            } else {
                generalTimezonesString = selectedTimeZone;
            }
        }
    }
    final TimezoneType timezoneType = TimezoneType.getTimezoneByOs(getModel().getIsWindowsOS());
    getModel().getTimeZone().setItems(cachedTimeZones.get(timezoneType));
    // If there was some time zone selected before, try select it again.
    Entry<String, String> selectedTimeZoneEntry = getTimezoneEntryByKey(selectedTimeZone, cachedTimeZones.get(timezoneType));
    Map.Entry<String, String> selectedItem = selectedTimeZoneEntry != null ? selectedTimeZoneEntry : (Map.Entry<String, String>) getModel().getTimeZone().getSelectedItem();
    getModel().getTimeZone().setSelectedItem(selectedItem == null ? null : Linq.FirstOrDefault(cachedTimeZones.get(timezoneType), new Linq.TimeZonePredicate(selectedItem.getKey())));
}
#method_after
private void PostUpdateTimeZone(String selectedTimeZone) {
    if (getModel().getIsWindowsOS() != lastIsWinOS) {
        lastIsWinOS = getModel().getIsWindowsOS();
        if (selectedTimeZone != null) {
            if (getModel().getIsWindowsOS()) {
                generalTimezonesString = selectedTimeZone;
            } else {
                winTimezoneString = selectedTimeZone;
            }
        }
        selectedTimeZone = getModel().getIsWindowsOS() ? winTimezoneString : generalTimezonesString;
    } else {
        if (selectedTimeZone != null) {
            if (getModel().getIsWindowsOS()) {
                winTimezoneString = selectedTimeZone;
            } else {
                generalTimezonesString = selectedTimeZone;
            }
        }
    }
    final TimezoneType timezoneType = TimezoneType.getTimezoneByOs(getModel().getIsWindowsOS());
    getModel().getTimeZone().setItems(cachedTimeZones.get(timezoneType));
    // If there was some time zone selected before, try select it again.
    Entry<String, String> selectedTimeZoneEntry = getTimezoneEntryByKey(selectedTimeZone, cachedTimeZones.get(timezoneType));
    Map.Entry<String, String> selectedItem = selectedTimeZoneEntry != null ? selectedTimeZoneEntry : (Map.Entry<String, String>) getModel().getTimeZone().getSelectedItem();
    getModel().getTimeZone().setSelectedItem(selectedItem == null ? null : Linq.firstOrDefault(cachedTimeZones.get(timezoneType), new Linq.TimeZonePredicate(selectedItem.getKey())));
}
#end_block

#method_before
protected void UpdateDefaultTimeZone() {
    if (cachedDefaultTimeZoneKey == null) {
        AsyncDataProvider.GetDefaultTimeZone(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target, Object returnValue) {
                VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
                cachedDefaultTimeZoneKey = (String) returnValue;
                behavior.PostUpdateDefaultTimeZone();
            }
        }, getModel().getHash()));
    } else {
        PostUpdateDefaultTimeZone();
    }
}
#method_after
protected void UpdateDefaultTimeZone() {
    if (cachedDefaultTimeZoneKey == null) {
        AsyncDataProvider.GetDefaultTimeZone(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
                cachedDefaultTimeZoneKey = (String) returnValue;
                behavior.PostUpdateDefaultTimeZone();
            }
        }, getModel().getHash()));
    } else {
        PostUpdateDefaultTimeZone();
    }
}
#end_block

#method_before
protected void UpdateDomain() {
    AsyncDataProvider.GetDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            List<String> domains = (List<String>) returnValue;
            String oldDomain = (String) behavior.getModel().getDomain().getSelectedItem();
            if (// $NON-NLS-1$
            oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                domains.add(0, oldDomain);
            }
            behavior.getModel().getDomain().setItems(domains);
            behavior.getModel().getDomain().setSelectedItem((oldDomain != null) ? oldDomain : Linq.FirstOrDefault(domains));
        }
    }, getModel().getHash()), true);
}
#method_after
protected void UpdateDomain() {
    AsyncDataProvider.GetDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            List<String> domains = (List<String>) returnValue;
            String oldDomain = (String) behavior.getModel().getDomain().getSelectedItem();
            if (// $NON-NLS-1$
            oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                domains.add(0, oldDomain);
            }
            behavior.getModel().getDomain().setItems(domains);
            behavior.getModel().getDomain().setSelectedItem((oldDomain != null) ? oldDomain : Linq.firstOrDefault(domains));
        }
    }, getModel().getHash()), true);
}
#end_block

#method_before
protected void InitPriority(int priority) {
    AsyncDataProvider.GetMaxVmPriority(new AsyncQuery(new Object[] { getModel(), priority }, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            UnitVmModel model = (UnitVmModel) array[0];
            int vmPriority = (Integer) array[1];
            cachedMaxPriority = (Integer) returnValue;
            int value = AsyncDataProvider.GetRoundedPriority(vmPriority, cachedMaxPriority);
            EntityModel tempVar = new EntityModel();
            tempVar.setEntity(value);
            model.getPriority().setSelectedItem(tempVar);
            UpdatePriority();
        }
    }, getModel().getHash()));
}
#method_after
protected void InitPriority(int priority) {
    AsyncDataProvider.GetMaxVmPriority(new AsyncQuery(new Object[] { getModel(), priority }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            UnitVmModel model = (UnitVmModel) array[0];
            int vmPriority = (Integer) array[1];
            cachedMaxPriority = (Integer) returnValue;
            int value = AsyncDataProvider.GetRoundedPriority(vmPriority, cachedMaxPriority);
            EntityModel tempVar = new EntityModel();
            tempVar.setEntity(value);
            model.getPriority().setSelectedItem(tempVar);
            UpdatePriority();
        }
    }, getModel().getHash()));
}
#end_block

#method_before
protected void UpdatePriority() {
    if (cachedMaxPriority == null) {
        AsyncDataProvider.GetMaxVmPriority(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target, Object returnValue) {
                VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
                cachedMaxPriority = (Integer) returnValue;
                behavior.PostUpdatePriority();
            }
        }, getModel().getHash()));
    } else {
        PostUpdatePriority();
    }
}
#method_after
protected void UpdatePriority() {
    if (cachedMaxPriority == null) {
        AsyncDataProvider.GetMaxVmPriority(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
                cachedMaxPriority = (Integer) returnValue;
                behavior.PostUpdatePriority();
            }
        }, getModel().getHash()));
    } else {
        PostUpdatePriority();
    }
}
#end_block

#method_before
private void PostUpdatePriority() {
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().lowTitle());
    tempVar.setEntity(1);
    items.add(tempVar);
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().mediumTitle());
    tempVar2.setEntity(cachedMaxPriority / 2);
    items.add(tempVar2);
    EntityModel tempVar3 = new EntityModel();
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().highTitle());
    tempVar3.setEntity(cachedMaxPriority);
    items.add(tempVar3);
    // If there was some priority selected before, try select it again.
    EntityModel oldPriority = (EntityModel) getModel().getPriority().getSelectedItem();
    getModel().getPriority().setItems(items);
    if (oldPriority != null) {
        for (EntityModel item : items) {
            int val1 = (Integer) item.getEntity();
            int val2 = (Integer) oldPriority.getEntity();
            if ((new Integer(val1)).equals(val2)) {
                getModel().getPriority().setSelectedItem(item);
                break;
            }
        }
    } else {
        getModel().getPriority().setSelectedItem(Linq.FirstOrDefault(items));
    }
}
#method_after
private void PostUpdatePriority() {
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().lowTitle());
    tempVar.setEntity(1);
    items.add(tempVar);
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().mediumTitle());
    tempVar2.setEntity(cachedMaxPriority / 2);
    items.add(tempVar2);
    EntityModel tempVar3 = new EntityModel();
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().highTitle());
    tempVar3.setEntity(cachedMaxPriority);
    items.add(tempVar3);
    // If there was some priority selected before, try select it again.
    EntityModel oldPriority = (EntityModel) getModel().getPriority().getSelectedItem();
    getModel().getPriority().setItems(items);
    if (oldPriority != null) {
        for (EntityModel item : items) {
            Integer val1 = (Integer) item.getEntity();
            Integer val2 = (Integer) oldPriority.getEntity();
            if (val1 != null && val1.equals(val2)) {
                getModel().getPriority().setSelectedItem(item);
                break;
            }
        }
    } else {
        getModel().getPriority().setSelectedItem(Linq.firstOrDefault(items));
    }
}
#end_block

#method_before
protected void doChangeDefautlHost(NGuid hostGuid) {
    if (hostGuid != null) {
        Guid vdsId = hostGuid.getValue();
        if (getModel().getDefaultHost().getItems() != null) {
            getModel().getDefaultHost().setSelectedItem(Linq.FirstOrDefault(getModel().getDefaultHost().getItems(), new Linq.HostPredicate(vdsId)));
        }
        getModel().getIsAutoAssign().setEntity(false);
    } else {
        getModel().getIsAutoAssign().setEntity(true);
    }
}
#method_after
protected void doChangeDefautlHost(NGuid hostGuid) {
    if (hostGuid != null) {
        Guid vdsId = hostGuid.getValue();
        if (getModel().getDefaultHost().getItems() != null) {
            getModel().getDefaultHost().setSelectedItem(Linq.firstOrDefault(getModel().getDefaultHost().getItems(), new Linq.HostPredicate(vdsId)));
        }
        getModel().getIsAutoAssign().setEntity(false);
    } else {
        getModel().getIsAutoAssign().setEntity(true);
    }
}
#end_block

#method_before
protected void UpdateDefaultHost() {
    VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
    if (cluster == null) {
        getModel().getDefaultHost().setItems(new ArrayList<VDS>());
        getModel().getDefaultHost().setSelectedItem(null);
        return;
    }
    AsyncQuery query = new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<VDS> hosts = null;
            if (returnValue instanceof ArrayList) {
                hosts = (ArrayList<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof ArrayList) {
                hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                // $NON-NLS-1$
                throw new IllegalArgumentException("The return value should be ArrayList<VDS> or VdcQueryReturnValue with return value ArrayList<VDS>");
            }
            VDS oldDefaultHost = (VDS) model.getDefaultHost().getSelectedItem();
            if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (VDS vds : hosts) {
                    if (host.getId().equals(vds.getId())) {
                        model.getDefaultHost().setItems(new ArrayList<VDS>(Arrays.asList(new VDS[] { vds })));
                        model.getDefaultHost().setSelectedItem(vds);
                        model.getDefaultHost().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDefaultHost().setInfo("Cannot choose other Host in tree context");
                        break;
                    }
                }
            } else {
                model.getDefaultHost().setItems(hosts);
                model.getDefaultHost().setSelectedItem(oldDefaultHost != null ? Linq.FirstOrDefault(hosts, new Linq.HostPredicate(oldDefaultHost.getId())) : Linq.FirstOrDefault(hosts));
            }
            ChangeDefualtHost();
        }
    }, getModel().getHash());
    getHostListByCluster(cluster, query);
}
#method_after
protected void UpdateDefaultHost() {
    VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
    if (cluster == null) {
        getModel().getDefaultHost().setItems(new ArrayList<VDS>());
        getModel().getDefaultHost().setSelectedItem(null);
        return;
    }
    AsyncQuery query = new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<VDS> hosts = null;
            if (returnValue instanceof ArrayList) {
                hosts = (ArrayList<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof ArrayList) {
                hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                // $NON-NLS-1$
                throw new IllegalArgumentException("The return value should be ArrayList<VDS> or VdcQueryReturnValue with return value ArrayList<VDS>");
            }
            VDS oldDefaultHost = (VDS) model.getDefaultHost().getSelectedItem();
            if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (VDS vds : hosts) {
                    if (host.getId().equals(vds.getId())) {
                        model.getDefaultHost().setItems(new ArrayList<VDS>(Arrays.asList(new VDS[] { vds })));
                        model.getDefaultHost().setSelectedItem(vds);
                        model.getDefaultHost().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDefaultHost().setInfo("Cannot choose other Host in tree context");
                        break;
                    }
                }
            } else {
                model.getDefaultHost().setItems(hosts);
                model.getDefaultHost().setSelectedItem(oldDefaultHost != null ? Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldDefaultHost.getId())) : Linq.firstOrDefault(hosts));
            }
            ChangeDefualtHost();
        }
    }, getModel().getHash());
    getHostListByCluster(cluster, query);
}
#end_block

#method_before
public void UpdataMaxVmsInPool() {
    AsyncDataProvider.GetMaxVmsInPool(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            behavior.setMaxVmsInPool((Integer) returnValue);
            behavior.UpdateMaxNumOfVmCpus();
        }
    }));
}
#method_after
public void UpdataMaxVmsInPool() {
    AsyncDataProvider.GetMaxVmsInPool(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            behavior.setMaxVmsInPool((Integer) returnValue);
            behavior.UpdateMaxNumOfVmCpus();
        }
    }));
}
#end_block

#method_before
public void UpdateMaxNumOfVmCpus() {
    VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
    String version = cluster.getcompatibility_version().toString();
    AsyncDataProvider.GetMaxNumOfVmCpus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            behavior.maxCpus = (Integer) returnValue;
            behavior.PostUpdateNumOfSockets2();
        }
    }, getModel().getHash()), version);
}
#method_after
public void UpdateMaxNumOfVmCpus() {
    VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
    String version = cluster.getcompatibility_version().toString();
    AsyncDataProvider.GetMaxNumOfVmCpus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            behavior.maxCpus = (Integer) returnValue;
            behavior.PostUpdateNumOfSockets2();
        }
    }, getModel().getHash()), version);
}
#end_block

#method_before
public void PostUpdateNumOfSockets2() {
    VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
    String version = cluster.getcompatibility_version().toString();
    AsyncDataProvider.GetMaxNumOfCPUsPerSocket(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            behavior.maxCpusPerSocket = (Integer) returnValue;
            behavior.totalCpuCoresChanged();
        }
    }, getModel().getHash()), version);
}
#method_after
public void PostUpdateNumOfSockets2() {
    VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
    String version = cluster.getcompatibility_version().toString();
    AsyncDataProvider.GetMaxNumOfCPUsPerSocket(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            behavior.maxCpusPerSocket = (Integer) returnValue;
            behavior.totalCpuCoresChanged();
        }
    }, getModel().getHash()), version);
}
#end_block

#method_before
public void InitDisks() {
    VmTemplate template = (VmTemplate) getModel().getTemplate().getSelectedItem();
    AsyncDataProvider.GetTemplateDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<DiskImage> disks = (ArrayList<DiskImage>) returnValue;
            Collections.sort(disks, new Linq.DiskByAliasComparer());
            ArrayList<DiskModel> list = new ArrayList<DiskModel>();
            for (Disk disk : disks) {
                DiskModel diskModel = new DiskModel();
                diskModel.getAlias().setEntity(disk.getDiskAlias());
                if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage diskImage = (DiskImage) disk;
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(diskImage.getSizeInGigabytes());
                    diskModel.setSize(tempVar);
                    ListModel tempVar2 = new ListModel();
                    tempVar2.setItems((diskImage.getVolumeType() == VolumeType.Preallocated ? new ArrayList<VolumeType>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated })) : AsyncDataProvider.GetVolumeTypeList()));
                    tempVar2.setSelectedItem(diskImage.getVolumeType());
                    diskModel.setVolumeType(tempVar2);
                    diskModel.getVolumeType().setIsAvailable(false);
                }
                diskModel.setDisk(disk);
                list.add(diskModel);
            }
            model.setDisks(list);
            UpdateIsDisksAvailable();
            InitStorageDomains();
        }
    }, getModel().getHash()), template.getId());
}
#method_after
public void InitDisks() {
    VmTemplate template = (VmTemplate) getModel().getTemplate().getSelectedItem();
    AsyncDataProvider.GetTemplateDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<DiskImage> disks = (ArrayList<DiskImage>) returnValue;
            Collections.sort(disks, new Linq.DiskByAliasComparer());
            ArrayList<DiskModel> list = new ArrayList<DiskModel>();
            for (Disk disk : disks) {
                DiskModel diskModel = new DiskModel();
                diskModel.getAlias().setEntity(disk.getDiskAlias());
                if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage diskImage = (DiskImage) disk;
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(diskImage.getSizeInGigabytes());
                    diskModel.setSize(tempVar);
                    ListModel tempVar2 = new ListModel();
                    tempVar2.setItems((diskImage.getVolumeType() == VolumeType.Preallocated ? new ArrayList<VolumeType>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated })) : AsyncDataProvider.GetVolumeTypeList()));
                    tempVar2.setSelectedItem(diskImage.getVolumeType());
                    diskModel.setVolumeType(tempVar2);
                    diskModel.getVolumeType().setIsAvailable(false);
                }
                diskModel.setDisk(disk);
                list.add(diskModel);
            }
            model.setDisks(list);
            UpdateIsDisksAvailable();
            InitStorageDomains();
        }
    }, getModel().getHash()), template.getId());
}
#end_block

#method_before
protected void PostInitStorageDomains() {
    if (getModel().getDisks() == null) {
        return;
    }
    storage_pool dataCenter = (storage_pool) getModel().getDataCenter().getSelectedItem();
    AsyncDataProvider.GetPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> activeStorageDomains = FilterStorageDomains(storageDomains);
            boolean provisioning = (Boolean) behavior.getModel().getProvisioning().getEntity();
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) behavior.getModel().getDisks();
            Linq.Sort(activeStorageDomains, new Linq.StorageDomainByNameComparer());
            for (DiskModel diskModel : disks) {
                ArrayList<StorageDomain> availableDiskStorageDomains = new ArrayList<StorageDomain>();
                diskModel.getQuota().setItems(behavior.getModel().getQuota().getItems());
                ArrayList<Guid> storageIds = ((DiskImage) diskModel.getDisk()).getStorageIds();
                // Active storage domains that the disk resides on
                ArrayList<StorageDomain> activeDiskStorageDomains = Linq.getStorageDomainsByIds(storageIds, activeStorageDomains);
                // Set target storage domains
                availableDiskStorageDomains = provisioning ? activeStorageDomains : activeDiskStorageDomains;
                Linq.Sort(availableDiskStorageDomains, new Linq.StorageDomainByNameComparer());
                diskModel.getStorageDomain().setItems(availableDiskStorageDomains);
                diskModel.getStorageDomain().setChangeProhibitionReason(constants.noActiveTargetStorageDomainAvailableMsg());
                diskModel.getStorageDomain().setIsChangable(!availableDiskStorageDomains.isEmpty());
            }
        }
    }, getModel().getHash()), dataCenter.getId(), ActionGroup.CREATE_VM);
}
#method_after
protected void PostInitStorageDomains() {
    if (getModel().getDisks() == null) {
        return;
    }
    StoragePool dataCenter = (StoragePool) getModel().getDataCenter().getSelectedItem();
    AsyncDataProvider.GetPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> activeStorageDomains = FilterStorageDomains(storageDomains);
            boolean provisioning = (Boolean) behavior.getModel().getProvisioning().getEntity();
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) behavior.getModel().getDisks();
            Linq.sort(activeStorageDomains, new Linq.StorageDomainByNameComparer());
            for (DiskModel diskModel : disks) {
                ArrayList<StorageDomain> availableDiskStorageDomains = new ArrayList<StorageDomain>();
                diskModel.getQuota().setItems(behavior.getModel().getQuota().getItems());
                ArrayList<Guid> storageIds = ((DiskImage) diskModel.getDisk()).getStorageIds();
                // Active storage domains that the disk resides on
                ArrayList<StorageDomain> activeDiskStorageDomains = Linq.getStorageDomainsByIds(storageIds, activeStorageDomains);
                // Set target storage domains
                availableDiskStorageDomains = provisioning ? activeStorageDomains : activeDiskStorageDomains;
                Linq.sort(availableDiskStorageDomains, new Linq.StorageDomainByNameComparer());
                diskModel.getStorageDomain().setItems(availableDiskStorageDomains);
                diskModel.getStorageDomain().setChangeProhibitionReason(constants.noActiveTargetStorageDomainAvailableMsg());
                diskModel.getStorageDomain().setIsChangable(!availableDiskStorageDomains.isEmpty());
            }
        }
    }, getModel().getHash()), dataCenter.getId(), ActionGroup.CREATE_VM);
}
#end_block

#method_before
public ArrayList<StorageDomain> FilterStorageDomains(ArrayList<StorageDomain> storageDomains) {
    // filter only the Active storage domains (Active regarding the relevant storage pool).
    ArrayList<StorageDomain> list = new ArrayList<StorageDomain>();
    for (StorageDomain a : storageDomains) {
        if (Linq.IsDataActiveStorageDomain(a)) {
            list.add(a);
        }
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain selectStorage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        StorageDomain sd = Linq.FirstOrDefault(list, new Linq.StoragePredicate(selectStorage.getId()));
        list = new ArrayList<StorageDomain>(Arrays.asList(new StorageDomain[] { sd }));
    }
    return list;
}
#method_after
public ArrayList<StorageDomain> FilterStorageDomains(ArrayList<StorageDomain> storageDomains) {
    // filter only the Active storage domains (Active regarding the relevant storage pool).
    ArrayList<StorageDomain> list = new ArrayList<StorageDomain>();
    for (StorageDomain a : storageDomains) {
        if (Linq.isDataActiveStorageDomain(a)) {
            list.add(a);
        }
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain selectStorage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        StorageDomain sd = Linq.firstOrDefault(list, new Linq.StoragePredicate(selectStorage.getId()));
        list = new ArrayList<StorageDomain>(Arrays.asList(new StorageDomain[] { sd }));
    }
    return list;
}
#end_block

#method_before
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
        if (cluster == null) {
            return;
        }
        Frontend.RunQuery(VdcQueryType.GetAllRelevantQuotasForVdsGroup, new GetAllRelevantQuotasForVdsGroupParameters(cluster.getId()), new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object model, Object returnValue) {
                UnitVmModel vmModel = (UnitVmModel) model;
                ArrayList<Quota> quotaList = (ArrayList<Quota>) ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (quotaList != null && !quotaList.isEmpty()) {
                    vmModel.getQuota().setItems(quotaList);
                }
                if (defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                    boolean hasQuotaInList = false;
                    for (Quota quota : quotaList) {
                        if (quota.getId().equals(defaultQuota)) {
                            vmModel.getQuota().setSelectedItem(quota);
                            hasQuotaInList = true;
                            break;
                        }
                    }
                    if (!hasQuotaInList) {
                        Quota quota = new Quota();
                        quota.setId(defaultQuota);
                        quota.setQuotaName(quotaName);
                        quotaList.add(quota);
                        vmModel.getQuota().setItems(quotaList);
                        vmModel.getQuota().setSelectedItem(quota);
                    }
                }
            }
        }));
    }
}
#method_after
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
        if (cluster == null) {
            return;
        }
        Frontend.RunQuery(VdcQueryType.GetAllRelevantQuotasForVdsGroup, new GetAllRelevantQuotasForVdsGroupParameters(cluster.getId()), new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                UnitVmModel vmModel = (UnitVmModel) model;
                ArrayList<Quota> quotaList = (ArrayList<Quota>) ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (quotaList != null && !quotaList.isEmpty()) {
                    vmModel.getQuota().setItems(quotaList);
                }
                if (defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                    boolean hasQuotaInList = false;
                    for (Quota quota : quotaList) {
                        if (quota.getId().equals(defaultQuota)) {
                            vmModel.getQuota().setSelectedItem(quota);
                            hasQuotaInList = true;
                            break;
                        }
                    }
                    if (!hasQuotaInList) {
                        Quota quota = new Quota();
                        quota.setId(defaultQuota);
                        quota.setQuotaName(quotaName);
                        quotaList.add(quota);
                        vmModel.getQuota().setItems(quotaList);
                        vmModel.getQuota().setSelectedItem(quota);
                    }
                }
            }
        }));
    }
}
#end_block

#method_before
protected void setupTemplate(VM vm, ListModel model) {
    AsyncDataProvider.GetTemplateById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            VmTemplate template = (VmTemplate) returnValue;
            model.getTemplate().setItems(new ArrayList<VmTemplate>(Arrays.asList(new VmTemplate[] { template })));
            model.getTemplate().setSelectedItem(template);
            model.getTemplate().setIsChangable(false);
            PostInitTemplate();
        }
    }, getModel().getHash()), vm.getVmtGuid());
}
#method_after
protected void setupTemplate(VM vm, ListModel model) {
    AsyncDataProvider.GetTemplateById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            VmTemplate template = (VmTemplate) returnValue;
            model.getTemplate().setItems(new ArrayList<VmTemplate>(Arrays.asList(new VmTemplate[] { template })));
            model.getTemplate().setSelectedItem(template);
            model.getTemplate().setIsChangable(false);
            PostInitTemplate();
        }
    }, getModel().getHash()), vm.getVmtGuid());
}
#end_block

#method_before
protected void UpdateNumOfSockets() {
    VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
    if (cluster == null) {
        return;
    }
    String version = cluster.getcompatibility_version().toString();
    AsyncDataProvider.GetMaxNumOfVmSockets(new AsyncQuery(new Object[] { this, getModel() }, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) array[0];
            behavior.maxNumOfSockets = ((Integer) returnValue);
            behavior.UpdataMaxVmsInPool();
        }
    }, getModel().getHash()), version);
}
#method_after
protected void UpdateNumOfSockets() {
    VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
    if (cluster == null) {
        return;
    }
    String version = cluster.getcompatibility_version().toString();
    AsyncDataProvider.GetMaxNumOfVmSockets(new AsyncQuery(new Object[] { this, getModel() }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) array[0];
            behavior.maxNumOfSockets = ((Integer) returnValue);
            behavior.UpdataMaxVmsInPool();
        }
    }, getModel().getHash()), version);
}
#end_block

#method_before
@Override
public void init(ServletConfig config) throws ServletException {
    // Let the parent do its work:
    super.init(config);
    // Get the content type of the file (it can be null, in which case the
    // global system MIME types map will be used to figure it out):
    type = config.getInitParameter(TYPE);
    // Get the name of the file or base directory:
    final String name = config.getInitParameter(FILE);
    if (name == null) {
        final String message = "Can't get base name from parameter \"" + FILE + "\".";
        log.error(message);
        throw new ServletException(message);
    }
    // Create the base file object:
    base = new File(LocalConfig.getInstance().expandString(name));
}
#method_after
@Override
public void init(ServletConfig config) throws ServletException {
    // Let the parent do its work:
    super.init(config);
    // Get the content type of the file (it can be null, in which case the
    // global system MIME types map will be used to figure it out):
    type = config.getInitParameter(TYPE);
    // Get the name of the file or base directory:
    final String name = config.getInitParameter(FILE);
    if (name == null) {
        final String message = "Can't get base name from parameter \"" + FILE + "\".";
        log.error(message);
        throw new ServletException(message);
    }
    // Create the base file object:
    base = new File(EngineLocalConfig.getInstance().expandString(name));
}
#end_block

#method_before
@Override
public void init() throws ServletException {
    try {
        this.resourceLocation = getInitParameter(PARAMETER_RESOURCE_LOCATION);
        this.outputFormat = getInitParameter(PARAMETER_OUTPUT_FORMAT);
        this.outputAlias = getInitParameter(PARAMETER_OUTPUT_ALIAS);
        if (this.resourceLocation == null) {
            throw new ServletException(String.format("The parameter '%s' must be specified.", PARAMETER_RESOURCE_LOCATION));
        }
        if (this.outputFormat == null) {
            throw new ServletException(String.format("The parameter '%s' must be specified.", PARAMETER_OUTPUT_FORMAT));
        }
        this.resourceLocation = LocalConfig.getInstance().expandString(this.resourceLocation);
    } catch (Exception e) {
        log.error("Cannot initialize", e);
    }
}
#method_after
@Override
public void init() throws ServletException {
    try {
        this.resourceLocation = getInitParameter(PARAMETER_RESOURCE_LOCATION);
        this.outputFormat = getInitParameter(PARAMETER_OUTPUT_FORMAT);
        this.outputAlias = getInitParameter(PARAMETER_OUTPUT_ALIAS);
        if (this.resourceLocation == null) {
            throw new ServletException(String.format("The parameter '%s' must be specified.", PARAMETER_RESOURCE_LOCATION));
        }
        if (this.outputFormat == null) {
            throw new ServletException(String.format("The parameter '%s' must be specified.", PARAMETER_OUTPUT_FORMAT));
        }
        this.resourceLocation = EngineLocalConfig.getInstance().expandString(this.resourceLocation);
    } catch (Exception e) {
        log.error("Cannot initialize", e);
    }
}
#end_block

#method_before
@Override
protected boolean canMigrateVm(VM vm) {
    if (vm.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return super.canMigrateVm(vm);
    } else {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE);
    }
}
#method_after
@Override
protected boolean canMigrateVm(VM vm) {
    if (vm.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return super.canMigrateVm(vm);
    }
    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE);
}
#end_block

#method_before
protected boolean canMigrateVm(VM vm) {
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        // If VM is pinned to host, no migration can occur
        if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
        }
        if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !forcedMigrationForNonMigratableVM) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
        }
        if (vm.getStatus() == VMStatus.MigratingFrom) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        }
        if (vm.getStatus() == VMStatus.NotResponding) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
        }
        if (vm.getStatus() == VMStatus.Paused) {
            return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_VM_IS_UNSUPPORTED);
        }
        if (!vm.isQualifyToMigrate()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
        }
        if (getDestinationVds() != null && getDestinationVds().getStatus() != VDSStatus.Up) {
            addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP);
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
        }
        return // migrated or snapshot is taken for them. TODO: replace it with a better solution
        validate(new DiskImagesValidator(ImagesHandler.getPluggedImagesForVm(vm.getId())).diskImagesNotLocked()) && validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && getVdsSelector().canFindVdsToRunOn(getReturnValue().getCanDoActionMessages(), true);
    }
}
#method_after
protected boolean canMigrateVm(VM vm) {
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !forcedMigrationForNonMigratableVM) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    if (vm.getStatus() == VMStatus.MigratingFrom) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
    }
    if (vm.getStatus() == VMStatus.NotResponding) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
    }
    if (vm.getStatus() == VMStatus.Paused) {
        return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_VM_IS_UNSUPPORTED);
    }
    if (!vm.isQualifyToMigrate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (getDestinationVds() != null && getDestinationVds().getStatus() != VDSStatus.Up) {
        addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP);
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
    }
    return // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedImagesForVm(vm.getId())).diskImagesNotLocked()) && validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && getVdsSelector().canFindVdsToRunOn(getReturnValue().getCanDoActionMessages(), true);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc create(XmlRpcStruct createInfo) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.create(createInfo.getInnerMap());
        OneVmReturnForXmlRpc wrapper = new OneVmReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public OneVmReturnForXmlRpc create(Map createInfo) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.create(createInfo);
        OneVmReturnForXmlRpc wrapper = new OneVmReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hotplugDisk(XmlRpcStruct info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotplugDisk(info.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc hotplugDisk(Map info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotplugDisk(info);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hotunplugDisk(XmlRpcStruct info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotunplugDisk(info.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc hotunplugDisk(Map info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotunplugDisk(info);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hotPlugNic(XmlRpcStruct info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotplugNic(info.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc hotPlugNic(Map info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotplugNic(info);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hotUnplugNic(XmlRpcStruct info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotunplugNic(info.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc hotUnplugNic(Map info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotunplugNic(info);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public Future<Map<String, Object>> setupNetworks(XmlRpcStruct networks, XmlRpcStruct bonds, XmlRpcStruct options) {
    return vdsServer.futureSetupNetworks(networks.getInnerMap(), bonds.getInnerMap(), options.getInnerMap());
}
#method_after
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonds, Map options) {
    return vdsServer.futureSetupNetworks(networks, bonds, options);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc diskReplicateStart(String vmUUID, XmlRpcStruct srcDisk, XmlRpcStruct dstDisk) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.diskReplicateStart(vmUUID, srcDisk.getInnerMap(), dstDisk.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc diskReplicateStart(String vmUUID, Map srcDisk, Map dstDisk) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.diskReplicateStart(vmUUID, srcDisk, dstDisk);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc diskReplicateFinish(String vmUUID, XmlRpcStruct srcDisk, XmlRpcStruct dstDisk) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.diskReplicateFinish(vmUUID, srcDisk.getInnerMap(), dstDisk.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc diskReplicateFinish(String vmUUID, Map srcDisk, Map dstDisk) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.diskReplicateFinish(vmUUID, srcDisk, dstDisk);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc vmUpdateDevice(String vmId, XmlRpcStruct device) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.vmUpdateDevice(vmId, device.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc vmUpdateDevice(String vmId, Map device) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.vmUpdateDevice(vmId, device);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected void ProceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case RemoveGlusterServerFailed:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookAlreadyEnabled:
        case GlusterHookAlreadyDisabled:
        case GlusterHookNotFound:
        case GlusterHostUUIDNotFound:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.ProceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void ProceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case RemoveGlusterServerFailed:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookAlreadyEnabled:
        case GlusterHookAlreadyDisabled:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.ProceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc create(XmlRpcStruct createInfo) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.create(createInfo.getInnerMap());
        OneVmReturnForXmlRpc wrapper = new OneVmReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public OneVmReturnForXmlRpc create(Map createInfo) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.create(createInfo);
        OneVmReturnForXmlRpc wrapper = new OneVmReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hotplugDisk(XmlRpcStruct info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotplugDisk(info.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc hotplugDisk(Map info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotplugDisk(info);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hotunplugDisk(XmlRpcStruct info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotunplugDisk(info.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc hotunplugDisk(Map info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotunplugDisk(info);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hotPlugNic(XmlRpcStruct info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotplugNic(info.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc hotPlugNic(Map info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotplugNic(info);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hotUnplugNic(XmlRpcStruct info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotunplugNic(info.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc hotUnplugNic(Map info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotunplugNic(info);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public Future<Map<String, Object>> setupNetworks(XmlRpcStruct networks, XmlRpcStruct bonds, XmlRpcStruct options) {
    return vdsServer.futureSetupNetworks(networks.getInnerMap(), bonds.getInnerMap(), options.getInnerMap());
}
#method_after
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonds, Map options) {
    return vdsServer.futureSetupNetworks(networks, bonds, options);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc diskReplicateStart(String vmUUID, XmlRpcStruct srcDisk, XmlRpcStruct dstDisk) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.diskReplicateStart(vmUUID, srcDisk.getInnerMap(), dstDisk.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc diskReplicateStart(String vmUUID, Map srcDisk, Map dstDisk) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.diskReplicateStart(vmUUID, srcDisk, dstDisk);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc diskReplicateFinish(String vmUUID, XmlRpcStruct srcDisk, XmlRpcStruct dstDisk) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.diskReplicateFinish(vmUUID, srcDisk.getInnerMap(), dstDisk.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc diskReplicateFinish(String vmUUID, Map srcDisk, Map dstDisk) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.diskReplicateFinish(vmUUID, srcDisk, dstDisk);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc vmUpdateDevice(String vmId, XmlRpcStruct device) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.vmUpdateDevice(vmId, device.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc vmUpdateDevice(String vmId, Map device) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.vmUpdateDevice(vmId, device);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
public boolean candidateOperation(String op1Key, String op1Type, String op2Key, String op2Type, boolean drop) {
    NetworkInterfaceModel nic1 = null;
    LogicalNetworkModel network1 = null;
    NetworkInterfaceModel nic2 = null;
    LogicalNetworkModel network2 = null;
    if (op1Type != null && op1Type.equals(NIC)) {
        nic1 = nicMap.get(op1Key);
    } else if (op1Type != null && op1Type.equals(NETWORK)) {
        network1 = networkMap.get(op1Key);
    }
    if (op2Type != null && op2Type.equals(NIC)) {
        nic2 = nicMap.get(op2Key);
    } else if (op2Type != null && op2Type.equals(NETWORK)) {
        network2 = networkMap.get(op2Key);
    }
    NetworkItemModel<?> op1 = nic1 == null ? network1 : nic1;
    NetworkItemModel<?> op2 = nic2 == null ? network2 : nic2;
    if (op1 == null || (op1 == null && op2 == null)) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("null Operands");
    }
    NetworkOperation candidate = NetworkOperationFactory.operationFor(op1, op2, true);
    if (drop) {
        if (candidate.isNullOperation()) {
            getNullOperationEvent().raise(this, null);
        }
        onOperation(candidate, candidate.getCommand(op1, op2, allNics));
    } else {
        // raise the candidate event only if it was changed
        if (!candidate.equals(currentCandidate) || !equals(op1, currentOp1) || !equals(op2, currentOp2)) {
            currentCandidate = candidate;
            currentOp1 = op1;
            currentOp2 = op2;
            getOperationCandidateEvent().raise(this, new OperationCadidateEventArgs(candidate, op1, op2));
        }
    }
    return !candidate.isNullOperation();
}
#method_after
public boolean candidateOperation(String op1Key, String op1Type, String op2Key, String op2Type, boolean drop) {
    NetworkInterfaceModel nic1 = null;
    LogicalNetworkModel network1 = null;
    NetworkInterfaceModel nic2 = null;
    LogicalNetworkModel network2 = null;
    if (op1Type != null && op1Type.equals(NIC)) {
        nic1 = nicMap.get(op1Key);
    } else if (op1Type != null && op1Type.equals(NETWORK)) {
        network1 = networkMap.get(op1Key);
    }
    if (op2Type != null && op2Type.equals(NIC)) {
        nic2 = nicMap.get(op2Key);
    } else if (op2Type != null && op2Type.equals(NETWORK)) {
        network2 = networkMap.get(op2Key);
    }
    NetworkItemModel<?> op1 = nic1 == null ? network1 : nic1;
    NetworkItemModel<?> op2 = nic2 == null ? network2 : nic2;
    if (op1 == null || (op1 == null && op2 == null)) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("null Operands");
    }
    NetworkOperation candidate = NetworkOperationFactory.operationFor(op1, op2, true);
    if (drop) {
        onOperation(candidate, candidate.getCommand(op1, op2, allNics));
    }
    // raise the candidate event only if it was changed or if a drop occured
    if (drop || !candidate.equals(currentCandidate) || !equals(op1, currentOp1) || !equals(op2, currentOp2)) {
        currentCandidate = candidate;
        currentOp1 = op1;
        currentOp2 = op2;
        getOperationCandidateEvent().raise(this, new OperationCadidateEventArgs(candidate, op1, op2, drop));
    }
    return !candidate.isNullOperation();
}
#end_block

#method_before
@Override
public void edit(HostSetupNetworksModel uicommonModel) {
    driver.edit(uicommonModel);
    uicommonModel.getNicsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // this is called after both networks and nics were retrieved
            HostSetupNetworksModel model = (HostSetupNetworksModel) sender;
            List<LogicalNetworkModel> networks = model.getNetworks();
            List<NetworkInterfaceModel> nics = model.getNics();
            status.setText(EMPTY_STATUS);
            updateNetworks(networks);
            updateNics(nics);
            // mark as rendered
            rendered = true;
        }
    });
    uicommonModel.getOperationCandidateEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            OperationCadidateEventArgs evtArgs = (OperationCadidateEventArgs) args;
            NetworkOperation candidate = evtArgs.getCandidate();
            NetworkItemModel<?> op1 = evtArgs.getOp1();
            NetworkItemModel<?> op2 = evtArgs.getOp2();
            status.setFadeText(candidate != null ? candidate.getMessage(op1, op2) : constants.noValidActionSetupNetwork());
            setStatusStyle(true);
        }
    });
    uicommonModel.getNullOperationEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setStatusStyle(false);
        }
    });
    networkList.setSetupModel(uicommonModel);
}
#method_after
@Override
public void edit(HostSetupNetworksModel uicommonModel) {
    driver.edit(uicommonModel);
    uicommonModel.getNicsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // this is called after both networks and nics were retrieved
            HostSetupNetworksModel model = (HostSetupNetworksModel) sender;
            List<LogicalNetworkModel> networks = model.getNetworks();
            List<NetworkInterfaceModel> nics = model.getNics();
            status.setText(EMPTY_STATUS);
            updateNetworks(networks);
            updateNics(nics);
            // mark as rendered
            rendered = true;
        }
    });
    uicommonModel.getOperationCandidateEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            OperationCadidateEventArgs evtArgs = (OperationCadidateEventArgs) args;
            NetworkOperation candidate = evtArgs.getCandidate();
            NetworkItemModel<?> op1 = evtArgs.getOp1();
            NetworkItemModel<?> op2 = evtArgs.getOp2();
            boolean drop = evtArgs.isDrop();
            if (!drop) {
                status.setFadeText(candidate != null ? candidate.getMessage(op1, op2) : constants.noValidActionSetupNetwork());
            }
            setStatusStyle(!drop || !candidate.isNullOperation());
        }
    });
    networkList.setSetupModel(uicommonModel);
}
#end_block

#method_before
public void OnInstall() {
    InstallModel model = (InstallModel) getWindow();
    boolean isOVirt = getEntity().getVdsType() == VDSType.oVirtNode;
    if (!model.Validate(isOVirt)) {
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(getEntity());
    param.setVdsId(getEntity().getId());
    param.setRootPassword((String) model.getRootPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(isOVirt ? ((RpmVersion) model.getOVirtISO().getSelectedItem()).getRpmName() : null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    param.setRebootAfterInstallation(isOVirt);
    Frontend.RunAction(VdcActionType.UpdateVds, param, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            if (returnValue != null && returnValue.getSucceeded()) {
                Cancel();
            }
        }
    });
}
#method_after
public void OnInstall() {
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = getEntity().getVdsType() == VDSType.oVirtNode;
    if (!model.Validate(isOVirt)) {
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(getEntity());
    param.setVdsId(getEntity().getId());
    param.setRootPassword((String) model.getRootPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(isOVirt ? ((RpmVersion) model.getOVirtISO().getSelectedItem()).getRpmName() : null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    AsyncDataProvider.GetClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.RunAction(VdcActionType.UpdateVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        Cancel();
                    }
                }
            });
        }
    }), getEntity().getVdsGroupId());
}
#end_block

#method_before
public void OnSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSSHKeyFingerprint(host.getSSHKeyFingerprint());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(new ValueObjectMap(model.getPmOptionsMap(), false));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(new ValueObjectMap(model.getPmSecondaryOptionsMap(), false));
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    CancelConfirm();
    model.StartProgress(null);
    boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setRootPassword((String) model.getRootPassword().getEntity());
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.PostOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setRootPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.PostOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().StopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            PostOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void OnSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSSHKeyFingerprint(host.getSSHKeyFingerprint());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(new ValueObjectMap(model.getPmOptionsMap(), false));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(new ValueObjectMap(model.getPmSecondaryOptionsMap(), false));
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    CancelConfirm();
    model.StartProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setRootPassword((String) model.getRootPassword().getEntity());
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.PostOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setRootPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.PostOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().StopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            PostOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void Restart() {
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().restartHostsTitle());
    // $NON-NLS-1$
    model.setHashName("restart_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToRestartTheFollowingHostsMsg());
    // model.Items = SelectedItems.Cast<VDS>().Select(a => a.vds_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        items.add(vds.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRestart", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void Restart() {
    final Constants constants = ConstantsManager.getInstance().getConstants();
    final Messages messages = ConstantsManager.getInstance().getMessages();
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(constants.restartHostsTitle());
    // $NON-NLS-1$
    model.setHashName("restart_host");
    model.setMessage(constants.areYouSureYouWantToRestartTheFollowingHostsMsg());
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        int runningVms = vds.getVmCount();
        if (runningVms > 0) {
            items.add(messages.hostNumberOfRunningVms(vds.getName(), runningVms));
        } else {
            items.add(vds.getName());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRestart", this);
    tempVar.setTitle(constants.ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(constants.cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private static void initGlusterVolumeSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initGlusterVolumeSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    // External Events/Alerts
    severities.put(AuditLogType.EXTERNAL_EVENT_NORMAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.EXTERNAL_EVENT_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EXTERNAL_EVENT_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXTERNAL_ALERT, AuditLogSeverity.ALERT);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    // External Events/Alerts
    severities.put(AuditLogType.EXTERNAL_EVENT_NORMAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.EXTERNAL_EVENT_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EXTERNAL_EVENT_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXTERNAL_ALERT, AuditLogSeverity.ALERT);
}
#end_block

#method_before
private static Map<String, String> getAvailableValues(String message, AuditLogableBase logable) {
    Map<String, String> returnValue = new HashMap<String, String>(logable.getCustomValues());
    Set<String> attributes = resolvePlaceHolders(message);
    attributes = AuditLogHelper.merge(attributes, AuditLogHelper.getCustomLogFields(logable.getClass(), true));
    if (attributes != null && attributes.size() > 0) {
        TypeCompat.getPropertyValues(logable, attributes, returnValue);
    }
    return returnValue;
}
#method_after
private static Map<String, String> getAvailableValues(String message, AuditLogableBase logable) {
    Map<String, String> returnValue = new HashMap<String, String>(logable.getCustomValues());
    Set<String> attributes = resolvePlaceHolders(message);
    if (attributes != null && attributes.size() > 0) {
        TypeCompat.getPropertyValues(logable, attributes, returnValue);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VDS vds = getDbFacade().getVdsDao().get(getParameters().getName());
    getQueryReturnValue().setReturnValue(vds);
}
#method_after
@Override
protected void executeQueryCommand() {
    VDS vds = getDbFacade().getVdsDao().getByName(getParameters().getName());
    getQueryReturnValue().setReturnValue(vds);
}
#end_block

#method_before
private boolean HandleOldVdssWithSameName(VDS hostToRegister) {
    log.debugFormat("Entering");
    boolean returnValue = true;
    VdsDAO vdsDAO = DbFacade.getInstance().getVdsDao();
    VDS storedHost = vdsDAO.get(getParameters().getVdsName());
    List<String> allHostNames = getAllHostNames(vdsDAO.getAll());
    boolean hostExistInDB = hostToRegister != null;
    if (storedHost != null) {
        log.debugFormat("found VDS with the same name {0}.  Will try to register with a new name", getParameters().getVdsName());
        String nameToRegister = getParameters().getVdsName();
        String uniqueIdToRegister = getParameters().getVdsUniqueId();
        String newName;
        // check different uniqueIds but same name
        if (!uniqueIdToRegister.equals(storedHost.getUniqueId()) && nameToRegister.equals(storedHost.getName())) {
            if (hostExistInDB) {
                // update the registered host if exist in db
                allHostNames.remove(hostToRegister.getName());
                newName = generateUniqueName(nameToRegister, allHostNames);
                hostToRegister.setVdsName(newName);
                UpdateVdsActionParameters parameters = new UpdateVdsActionParameters(hostToRegister.getStaticData(), "", false);
                VdcReturnValueBase ret = Backend.getInstance().runInternalAction(VdcActionType.UpdateVds, parameters);
                if (ret == null || !ret.getSucceeded()) {
                    error = AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME;
                    logable.addCustomValue("VdsName2", newName);
                    log.errorFormat("could not update VDS {0}", nameToRegister);
                    CaptureCommandErrorsToLogger(ret, "RegisterVdsQuery::HandleOldVdssWithSameName");
                    return false;
                } else {
                    log.infoFormat("Another VDS was using this name with IP {0}. Changed to {1}", nameToRegister, newName);
                }
            } else {
                // host doesn't exist in db yet. not persisting changes just object values.
                newName = generateUniqueName(nameToRegister, allHostNames);
                getParameters().setVdsName(newName);
            }
        }
    }
    log.debugFormat("Leaving with value {0}", returnValue);
    return returnValue;
}
#method_after
private boolean HandleOldVdssWithSameName(VDS hostToRegister) {
    log.debugFormat("Entering");
    boolean returnValue = true;
    VdsDAO vdsDAO = DbFacade.getInstance().getVdsDao();
    VDS storedHost = vdsDAO.getByName(getParameters().getVdsName());
    List<String> allHostNames = getAllHostNames(vdsDAO.getAll());
    boolean hostExistInDB = hostToRegister != null;
    if (storedHost != null) {
        log.debugFormat("found VDS with the same name {0}.  Will try to register with a new name", getParameters().getVdsName());
        String nameToRegister = getParameters().getVdsName();
        String uniqueIdToRegister = getParameters().getVdsUniqueId();
        String newName;
        // check different uniqueIds but same name
        if (!uniqueIdToRegister.equals(storedHost.getUniqueId()) && nameToRegister.equals(storedHost.getName())) {
            if (hostExistInDB) {
                // update the registered host if exist in db
                allHostNames.remove(hostToRegister.getName());
                newName = generateUniqueName(nameToRegister, allHostNames);
                hostToRegister.setVdsName(newName);
                UpdateVdsActionParameters parameters = new UpdateVdsActionParameters(hostToRegister.getStaticData(), "", false);
                VdcReturnValueBase ret = Backend.getInstance().runInternalAction(VdcActionType.UpdateVds, parameters);
                if (ret == null || !ret.getSucceeded()) {
                    error = AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME;
                    logable.addCustomValue("VdsName2", newName);
                    log.errorFormat("could not update VDS {0}", nameToRegister);
                    CaptureCommandErrorsToLogger(ret, "RegisterVdsQuery::HandleOldVdssWithSameName");
                    return false;
                } else {
                    log.infoFormat("Another VDS was using this name with IP {0}. Changed to {1}", nameToRegister, newName);
                }
            } else {
                // host doesn't exist in db yet. not persisting changes just object values.
                newName = generateUniqueName(nameToRegister, allHostNames);
                getParameters().setVdsName(newName);
            }
        }
    }
    log.debugFormat("Leaving with value {0}", returnValue);
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getVdsGroupId());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getName();
        String hostName = vds.getHostName();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else if (getVdsDAO().get(vdsName) != null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            returnValue = false;
        } else if (getVdsDAO().getAllForHostname(hostName).size() != 0) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !new File(Config.resolveCertificatePath()).exists()) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getVdsGroupId());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getName();
        String hostName = vds.getHostName();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else if (getVdsDAO().getByName(vdsName) != null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            returnValue = false;
        } else if (getVdsDAO().getAllForHostname(hostName).size() != 0) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !new File(Config.resolveCertificatePath()).exists()) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
@Test
public void testGetUsingInvalidName() {
    VDS result = dao.get("farkle");
    assertNull(result);
}
#method_after
@Test
public void testGetUsingInvalidName() {
    VDS result = dao.getByName("farkle");
    assertNull(result);
}
#end_block

#method_before
@Test
public void testGetWithName() {
    VDS result = dao.get(existingVds.getName());
    assertNotNull(result);
    assertEquals(existingVds.getName(), result.getName());
}
#method_after
@Test
public void testGetWithName() {
    VDS result = dao.getByName(existingVds.getName());
    assertNotNull(result);
    assertEquals(existingVds.getName(), result.getName());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = false;
    _oldVds = getVdsDAO().get(getVdsId());
    if (_oldVds != null && getParameters().getVdsStaticData() != null) {
        String compatibilityVersion = _oldVds.getVdsGroupCompatibilityVersion().toString();
        if (VdsHandler.IsUpdateValid(getParameters().getVdsStaticData(), _oldVds.getStaticData(), _oldVds.getStatus())) {
            if ("".equals(getParameters().getVdsStaticData().getName())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
            String vdsName = getParameters().getvds().getName();
            String hostName = getParameters().getvds().getHostName();
            int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
            // check that VDS name is not null or empty
            if (vdsName == null || vdsName.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
                returnValue = false;
            // check that VDS name is not too long
            } else if (vdsName.length() > maxVdsNameLength) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
                returnValue = false;
            } else if (_oldVds.getStatus() != VDSStatus.InstallFailed && !_oldVds.getHostName().equals(hostName)) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOSNAME_CANNOT_CHANGE);
                returnValue = false;
            } else // check if a name is updated to an existing vds name
            if (!StringUtils.equalsIgnoreCase(_oldVds.getName(), getParameters().getVdsStaticData().getName()) && getVdsDAO().get(vdsName) != null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            } else if (!StringUtils.equalsIgnoreCase(_oldVds.getHostName(), getParameters().getVdsStaticData().getHostName()) && getVdsDAO().getAllForHostname(hostName).size() != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
            } else if (getParameters().getInstallVds() && _oldVds.getStatus() != VDSStatus.Maintenance && _oldVds.getStatus() != VDSStatus.NonOperational && _oldVds.getStatus() != VDSStatus.InstallFailed) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_STATUS_ILLEGAL);
            } else if (getParameters().getInstallVds() && StringUtils.isEmpty(getParameters().getRootPassword()) && getParameters().getVdsStaticData().getVdsType() == VDSType.VDS) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!getParameters().getInstallVds() && _oldVds.getPort() != getParameters().getVdsStaticData().getPort()) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_CHANGE_REQUIRE_INSTALL);
            } else if (!_oldVds.getVdsGroupId().equals(getParameters().getVdsStaticData().getVdsGroupId())) {
                // Forbid updating group id - this must be done through
                // ChangeVDSClusterCommand
                // This is due to permission check that must be done both on
                // the VDS and on the VDSGroup
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPDATE_CLUSTER);
            } else {
                returnValue = true;
            }
            // if all ok check PM is legal
            returnValue = returnValue && IsPowerManagementLegal(getParameters().getVdsStaticData(), compatibilityVersion);
        } else {
            addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE.toString());
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = false;
    _oldVds = getVdsDAO().get(getVdsId());
    if (_oldVds != null && getParameters().getVdsStaticData() != null) {
        String compatibilityVersion = _oldVds.getVdsGroupCompatibilityVersion().toString();
        if (VdsHandler.IsUpdateValid(getParameters().getVdsStaticData(), _oldVds.getStaticData(), _oldVds.getStatus())) {
            if ("".equals(getParameters().getVdsStaticData().getName())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
            String vdsName = getParameters().getvds().getName();
            String hostName = getParameters().getvds().getHostName();
            int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
            // check that VDS name is not null or empty
            if (vdsName == null || vdsName.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
                returnValue = false;
            // check that VDS name is not too long
            } else if (vdsName.length() > maxVdsNameLength) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
                returnValue = false;
            } else if (_oldVds.getStatus() != VDSStatus.InstallFailed && !_oldVds.getHostName().equals(hostName)) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOSNAME_CANNOT_CHANGE);
                returnValue = false;
            } else // check if a name is updated to an existing vds name
            if (!StringUtils.equalsIgnoreCase(_oldVds.getName(), getParameters().getVdsStaticData().getName()) && getVdsDAO().getByName(vdsName) != null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            } else if (!StringUtils.equalsIgnoreCase(_oldVds.getHostName(), getParameters().getVdsStaticData().getHostName()) && getVdsDAO().getAllForHostname(hostName).size() != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST);
            } else if (getParameters().getInstallVds() && _oldVds.getStatus() != VDSStatus.Maintenance && _oldVds.getStatus() != VDSStatus.NonOperational && _oldVds.getStatus() != VDSStatus.InstallFailed) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_STATUS_ILLEGAL);
            } else if (getParameters().getInstallVds() && StringUtils.isEmpty(getParameters().getRootPassword()) && getParameters().getVdsStaticData().getVdsType() == VDSType.VDS) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
            } else if (!getParameters().getInstallVds() && _oldVds.getPort() != getParameters().getVdsStaticData().getPort()) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_CHANGE_REQUIRE_INSTALL);
            } else if (!_oldVds.getVdsGroupId().equals(getParameters().getVdsStaticData().getVdsGroupId())) {
                // Forbid updating group id - this must be done through
                // ChangeVDSClusterCommand
                // This is due to permission check that must be done both on
                // the VDS and on the VDSGroup
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPDATE_CLUSTER);
            } else {
                returnValue = true;
            }
            // if all ok check PM is legal
            returnValue = returnValue && IsPowerManagementLegal(getParameters().getVdsStaticData(), compatibilityVersion);
        } else {
            addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE.toString());
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
    }
    return returnValue;
}
#end_block

#method_before
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getEntity();
        editPopup = new HostBondInterfaceModel(true);
        final HostBondInterfaceModel bondDialogModel = (HostBondInterfaceModel) editPopup;
        bondDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editBondInterfaceTitle(entity.getName()));
        bondDialogModel.getNetwork().setIsAvailable(false);
        bondDialogModel.getCheckConnectivity().setIsAvailable(false);
        bondDialogModel.getAddress().setIsAvailable(false);
        bondDialogModel.getSubnet().setIsAvailable(false);
        bondDialogModel.getGateway().setIsAvailable(false);
        bondDialogModel.setBootProtocolAvailable(false);
        // bond name
        bondDialogModel.getBond().setIsChangable(false);
        List<String> bondName = Arrays.asList(entity.getName());
        bondDialogModel.getBond().setItems(bondName);
        bondDialogModel.getBond().setSelectedItem(entity.getName());
        // bond options
        String bondOptions = entity.getBondOptions();
        List<KeyValuePairCompat<String, EntityModel>> items = (List<KeyValuePairCompat<String, EntityModel>>) bondDialogModel.getBondingOptions().getItems();
        boolean found = false;
        KeyValuePairCompat<String, EntityModel> customKey = null;
        for (KeyValuePairCompat<String, EntityModel> pair : items) {
            String key = pair.getKey();
            if (key.equals(bondOptions)) {
                bondDialogModel.getBondingOptions().setSelectedItem(pair);
                found = true;
                break;
            } else {
                if ("custom".equals(key)) {
                    // $NON-NLS-1$
                    customKey = pair;
                }
            }
        }
        if (!found) {
            EntityModel value = new EntityModel();
            value.setEntity(bondOptions);
            customKey.setValue(value);
            bondDialogModel.getBondingOptions().setSelectedItem(customKey);
        }
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand command) {
                setBondOptions(entity, bondDialogModel);
                sourceListModel.setConfirmWindow(null);
            }
        };
    } else if (item instanceof LogicalNetworkModel) {
        final LogicalNetworkModel logicalNetwork = (LogicalNetworkModel) item;
        final VdsNetworkInterface entity = logicalNetwork.hasVlan() ? logicalNetwork.getVlanNic().getEntity() : logicalNetwork.getAttachedToNic().getEntity();
        if (logicalNetwork.isManagement()) {
            /**
             * **************
             *  Management Network Dialog
             * ***************
             */
            editPopup = new HostManagementNetworkModel(true);
            final HostManagementNetworkModel mgmntDialogModel = (HostManagementNetworkModel) editPopup;
            mgmntDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            mgmntDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
            mgmntDialogModel.setEntity(logicalNetwork.getEntity());
            mgmntDialogModel.getAddress().setEntity(entity.getAddress());
            mgmntDialogModel.getSubnet().setEntity(entity.getSubnet());
            mgmntDialogModel.getGateway().setEntity(entity.getGateway());
            mgmntDialogModel.setNoneBootProtocolAvailable(false);
            mgmntDialogModel.getBondingOptions().setIsAvailable(false);
            mgmntDialogModel.getInterface().setIsAvailable(false);
            mgmntDialogModel.setBootProtocol(entity.getBootProtocol());
            mgmntDialogModel.getIsToSync().setIsChangable(!logicalNetwork.isInSync());
            mgmntDialogModel.getIsToSync().setEntity(HostSetupNetworksModel.this.networksToSync.contains(logicalNetwork.getName()));
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void ExecuteCommand(UICommand command) {
                    if (!mgmntDialogModel.Validate()) {
                        return;
                    }
                    entity.setBootProtocol(mgmntDialogModel.getBootProtocol());
                    entity.setAddress((String) mgmntDialogModel.getAddress().getEntity());
                    entity.setSubnet((String) mgmntDialogModel.getSubnet().getEntity());
                    entity.setGateway((String) mgmntDialogModel.getGateway().getEntity());
                    if ((Boolean) mgmntDialogModel.getIsToSync().getEntity()) {
                        HostSetupNetworksModel.this.networksToSync.add(logicalNetwork.getName());
                    } else {
                        HostSetupNetworksModel.this.networksToSync.remove(logicalNetwork.getName());
                    }
                    sourceListModel.setConfirmWindow(null);
                }
            };
        } else {
            /**
             * **************
             *  Network Dialog
             * ***************
             */
            editPopup = new HostInterfaceModel(true);
            final HostInterfaceModel networkDialogModel = (HostInterfaceModel) editPopup;
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetwork.getName()));
            networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
            networkDialogModel.getAddress().setEntity(entity.getAddress());
            networkDialogModel.getSubnet().setEntity(entity.getSubnet());
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getBondingOptions().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangable(false);
            networkDialogModel.getNetwork().setSelectedItem(logicalNetwork.getEntity());
            networkDialogModel.setBootProtocol(entity.getBootProtocol());
            networkDialogModel.getIsToSync().setIsChangable(!logicalNetwork.isInSync());
            networkDialogModel.getIsToSync().setEntity(HostSetupNetworksModel.this.networksToSync.contains(logicalNetwork.getName()));
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void ExecuteCommand(UICommand command) {
                    if (!networkDialogModel.Validate()) {
                        return;
                    }
                    entity.setBootProtocol(networkDialogModel.getBootProtocol());
                    entity.setAddress((String) networkDialogModel.getAddress().getEntity());
                    entity.setSubnet((String) networkDialogModel.getSubnet().getEntity());
                    if ((Boolean) networkDialogModel.getIsToSync().getEntity()) {
                        HostSetupNetworksModel.this.networksToSync.add(logicalNetwork.getName());
                    } else {
                        HostSetupNetworksModel.this.networksToSync.remove(logicalNetwork.getName());
                    }
                    sourceListModel.setConfirmWindow(null);
                }
            };
        }
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OK", okTarget);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void ExecuteCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#method_after
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getEntity();
        editPopup = new SetupNetworksEditBondModel(entity);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand command) {
                setBondOptions(entity, bondDialogModel);
                sourceListModel.setConfirmWindow(null);
            }
        };
    } else if (item instanceof LogicalNetworkModel) {
        final LogicalNetworkModel logicalNetwork = (LogicalNetworkModel) item;
        final VdsNetworkInterface entity = logicalNetwork.hasVlan() ? logicalNetwork.getVlanNic().getEntity() : logicalNetwork.getAttachedToNic().getEntity();
        if (logicalNetwork.isManagement()) {
            /**
             * **************
             *  Management Network Dialog
             * ***************
             */
            editPopup = new HostManagementNetworkModel(true);
            final HostManagementNetworkModel mgmntDialogModel = (HostManagementNetworkModel) editPopup;
            mgmntDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            mgmntDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
            mgmntDialogModel.setEntity(logicalNetwork.getEntity());
            mgmntDialogModel.getAddress().setEntity(entity.getAddress());
            mgmntDialogModel.getSubnet().setEntity(entity.getSubnet());
            mgmntDialogModel.getGateway().setEntity(entity.getGateway());
            mgmntDialogModel.setNoneBootProtocolAvailable(false);
            mgmntDialogModel.getBondingOptions().setIsAvailable(false);
            mgmntDialogModel.getInterface().setIsAvailable(false);
            mgmntDialogModel.setBootProtocol(entity.getBootProtocol());
            mgmntDialogModel.getIsToSync().setIsChangable(!logicalNetwork.isInSync());
            mgmntDialogModel.getIsToSync().setEntity(HostSetupNetworksModel.this.networksToSync.contains(logicalNetwork.getName()));
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void ExecuteCommand(UICommand command) {
                    if (!mgmntDialogModel.Validate()) {
                        return;
                    }
                    entity.setBootProtocol(mgmntDialogModel.getBootProtocol());
                    entity.setAddress((String) mgmntDialogModel.getAddress().getEntity());
                    entity.setSubnet((String) mgmntDialogModel.getSubnet().getEntity());
                    entity.setGateway((String) mgmntDialogModel.getGateway().getEntity());
                    if ((Boolean) mgmntDialogModel.getIsToSync().getEntity()) {
                        HostSetupNetworksModel.this.networksToSync.add(logicalNetwork.getName());
                    } else {
                        HostSetupNetworksModel.this.networksToSync.remove(logicalNetwork.getName());
                    }
                    sourceListModel.setConfirmWindow(null);
                }
            };
        } else {
            /**
             * **************
             *  Network Dialog
             * ***************
             */
            editPopup = new HostInterfaceModel(true);
            final HostInterfaceModel networkDialogModel = (HostInterfaceModel) editPopup;
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetwork.getName()));
            networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
            networkDialogModel.getAddress().setEntity(entity.getAddress());
            networkDialogModel.getSubnet().setEntity(entity.getSubnet());
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getBondingOptions().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangable(false);
            networkDialogModel.getNetwork().setSelectedItem(logicalNetwork.getEntity());
            networkDialogModel.setBootProtocol(entity.getBootProtocol());
            networkDialogModel.getIsToSync().setIsChangable(!logicalNetwork.isInSync());
            networkDialogModel.getIsToSync().setEntity(HostSetupNetworksModel.this.networksToSync.contains(logicalNetwork.getName()));
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void ExecuteCommand(UICommand command) {
                    if (!networkDialogModel.Validate()) {
                        return;
                    }
                    entity.setBootProtocol(networkDialogModel.getBootProtocol());
                    entity.setAddress((String) networkDialogModel.getAddress().getEntity());
                    entity.setSubnet((String) networkDialogModel.getSubnet().getEntity());
                    if ((Boolean) networkDialogModel.getIsToSync().getEntity()) {
                        HostSetupNetworksModel.this.networksToSync.add(logicalNetwork.getName());
                    } else {
                        HostSetupNetworksModel.this.networksToSync.remove(logicalNetwork.getName());
                    }
                    sourceListModel.setConfirmWindow(null);
                }
            };
        }
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OK", okTarget);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void ExecuteCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#end_block

#method_before
public void onOperation(NetworkOperation operation, final NetworkCommand networkCommand) {
    Model popupWindow;
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void ExecuteCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (operation.isNullOperation()) {
        return;
    } else if (operation == NetworkOperation.BOND_WITH) {
        final HostBondInterfaceModel bondPopup = new HostBondInterfaceModel(true);
        bondPopup.setTitle(ConstantsManager.getInstance().getConstants().createNewBondTitle());
        bondPopup.getNetwork().setIsAvailable(false);
        bondPopup.getCheckConnectivity().setIsAvailable(false);
        bondPopup.setBootProtocol(NetworkBootProtocol.NONE);
        bondPopup.getAddress().setIsAvailable(false);
        bondPopup.getSubnet().setIsAvailable(false);
        bondPopup.getGateway().setIsAvailable(false);
        bondPopup.setBootProtocolAvailable(false);
        bondPopup.getBond().setItems(getFreeBonds());
        bondPopup.getBond().setSelectedItem(BondNameValidation.BOND_PREFIX);
        bondPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand command) {
                if (!bondPopup.Validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                VdsNetworkInterface bond = new Bond((String) bondPopup.getBond().getSelectedItem());
                setBondOptions(bond, bondPopup);
                NetworkInterfaceModel nic1 = (NetworkInterfaceModel) networkCommand.getOp1();
                NetworkInterfaceModel nic2 = (NetworkInterfaceModel) networkCommand.getOp2();
                List<LogicalNetworkModel> networks = nic1.getItems().size() != 0 ? new ArrayList<LogicalNetworkModel>(nic1.getItems()) : new ArrayList<LogicalNetworkModel>(nic2.getItems());
                networkCommand.Execute(bond);
                redraw();
                // Attach the previous networks
                for (NetworkInterfaceModel nic : getNics()) {
                    if (nic.getName().equals(bond.getName())) {
                        NetworkOperation.attachNetworks(nic, networks, allNics);
                        redraw();
                        return;
                    }
                }
            }
        }));
        popupWindow = bondPopup;
    } else {
        // just execute the command
        networkCommand.Execute();
        redraw();
        return;
    }
    // add cancel
    popupWindow.getCommands().add(cancelCommand);
    // set window
    sourceListModel.setConfirmWindow(popupWindow);
}
#method_after
public void onOperation(NetworkOperation operation, final NetworkCommand networkCommand) {
    Model popupWindow;
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void ExecuteCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (operation.isNullOperation()) {
        return;
    } else if (operation == NetworkOperation.BOND_WITH) {
        final SetupNetworksBondModel bondPopup = new SetupNetworksAddBondModel(getFreeBonds());
        bondPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand command) {
                if (!bondPopup.Validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                VdsNetworkInterface bond = new Bond((String) bondPopup.getBond().getSelectedItem());
                setBondOptions(bond, bondPopup);
                NetworkInterfaceModel nic1 = (NetworkInterfaceModel) networkCommand.getOp1();
                NetworkInterfaceModel nic2 = (NetworkInterfaceModel) networkCommand.getOp2();
                List<LogicalNetworkModel> networks = nic1.getItems().size() != 0 ? new ArrayList<LogicalNetworkModel>(nic1.getItems()) : new ArrayList<LogicalNetworkModel>(nic2.getItems());
                networkCommand.Execute(bond);
                redraw();
                // Attach the previous networks
                for (NetworkInterfaceModel nic : getNics()) {
                    if (nic.getName().equals(bond.getName())) {
                        NetworkOperation.attachNetworks(nic, networks, allNics);
                        redraw();
                        return;
                    }
                }
            }
        }));
        popupWindow = bondPopup;
    } else {
        // just execute the command
        networkCommand.Execute();
        redraw();
        return;
    }
    // add cancel
    popupWindow.getCommands().add(cancelCommand);
    // set window
    sourceListModel.setConfirmWindow(popupWindow);
}
#end_block

#method_before
private void setBondOptions(VdsNetworkInterface entity, HostBondInterfaceModel bondDialogModel) {
    KeyValuePairCompat<String, EntityModel> BondPair = (KeyValuePairCompat<String, EntityModel>) bondDialogModel.getBondingOptions().getSelectedItem();
    String key = BondPair.getKey();
    // $NON-NLS-1$
    entity.setBondOptions((String) ("custom".equals(key) ? BondPair.getValue().getEntity() : key));
}
#method_after
private void setBondOptions(VdsNetworkInterface entity, SetupNetworksBondModel bondDialogModel) {
    KeyValuePairCompat<String, EntityModel> BondPair = (KeyValuePairCompat<String, EntityModel>) bondDialogModel.getBondingOptions().getSelectedItem();
    String key = BondPair.getKey();
    // $NON-NLS-1$
    entity.setBondOptions((String) ("custom".equals(key) ? BondPair.getValue().getEntity() : key));
}
#end_block

#method_before
@Override
public void edit(final HostBondInterfaceModel object) {
    super.edit(object);
    // hide widgets
    info.setVisible(false);
    message.setVisible(false);
    checkConnectivity.setVisible(false);
    commitChanges.setVisible(false);
    // resize
    layoutPanel.remove(infoPanel);
    layoutPanel.setWidgetSize(mainPanel, 300);
    asPopupPanel().setPixelSize(400, 400);
}
#method_after
@Override
public void edit(final HostBondInterfaceModel object) {
    super.edit(object);
    // hide widgets
    info.setVisible(false);
    message.setVisible(false);
    // resize
    layoutPanel.remove(infoPanel);
    layoutPanel.setWidgetSize(mainPanel, 300);
    asPopupPanel().setPixelSize(400, 400);
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
}
#end_block

#method_before
static void checkMessages() {
    AuditLogType[] values = AuditLogType.values();
    if (values.length != messages.size()) {
        for (AuditLogType value : values) {
            if (!messages.containsKey(value)) {
                log.infoFormat("AuditLogType: {0} not exist in string table", value.toString());
            }
        }
    }
}
#method_after
private static void checkMessages() {
    AuditLogType[] values = AuditLogType.values();
    if (values.length != messages.size()) {
        for (AuditLogType value : values) {
            if (!messages.containsKey(value)) {
                log.infoFormat("AuditLogType: {0} not exist in string table", value.toString());
            }
        }
    }
}
#end_block

#method_before
static void checkSeverities() {
    AuditLogType[] values = AuditLogType.values();
    if (values.length != severities.size()) {
        for (AuditLogType value : values) {
            if (!severities.containsKey(value)) {
                log.warnFormat("AuditLogType: {0} not have severity. Assumed Normal", value.toString());
            }
        }
    }
}
#method_after
private static void checkSeverities() {
    AuditLogType[] values = AuditLogType.values();
    if (values.length != severities.size()) {
        for (AuditLogType value : values) {
            if (!severities.containsKey(value)) {
                log.warnFormat("AuditLogType: {0} not have severity. Assumed Normal", value.toString());
            }
        }
    }
}
#end_block

#method_before
public static void log(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    updateTimeoutLogableObject(auditLogable, logType);
    if (auditLogable == null || auditLogable.getLegal()) {
        String message = null;
        String resolvedMessage = null;
        AuditLogSeverity severity = severities.get(logType);
        if (severity == null) {
            severity = AuditLogSeverity.NORMAL;
            log.infoFormat("No severity for {0} audit log type, assuming Normal severity", logType);
        }
        AuditLog auditLog = null;
        if (auditLogable != null) {
            AuditLog tempVar = null;
            // handle external log messages invoked by plugins via the API
            if (auditLogable.isExternal()) {
                // message is sent as an argument, no need to resolve.
                resolvedMessage = message = loggerString;
                tempVar = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName(), auditLogable.getOrigin(), auditLogable.getCustomEventId(), auditLogable.getEventFloodInSec(), auditLogable.getCustomData());
            } else if ((message = messages.get(logType)) != null) {
                // Application log message from AuditLogMessages
                resolvedMessage = resolveMessage(message, auditLogable);
                tempVar = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
            }
            if (tempVar != null) {
                tempVar.setstorage_domain_id(auditLogable.getStorageDomainId());
                tempVar.setstorage_domain_name(auditLogable.getStorageDomainName());
                tempVar.setstorage_pool_id(auditLogable.getStoragePoolId());
                tempVar.setstorage_pool_name(auditLogable.getStoragePoolName());
                tempVar.setvds_group_id(auditLogable.getVdsGroupId());
                tempVar.setvds_group_name(auditLogable.getVdsGroupName());
                tempVar.setCorrelationId(auditLogable.getCorrelationId());
                tempVar.setJobId(auditLogable.getJobId());
                tempVar.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
                tempVar.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
                tempVar.setExternal(auditLogable.isExternal());
                auditLog = tempVar;
            }
        } else {
            auditLog = new AuditLog(logType, severity, resolvedMessage, null, null, null, null, null, null, null, null);
        }
        if (auditLog != null) {
            getDbFacadeInstance().getAuditLogDao().save(auditLog);
            if (!"".equals(loggerString)) {
                log.infoFormat(loggerString, resolvedMessage);
            }
        }
    }
}
#method_after
public static void log(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    updateTimeoutLogableObject(auditLogable, logType);
    if (auditLogable.getLegal()) {
        String message = null;
        String resolvedMessage = null;
        AuditLogSeverity severity = severities.get(logType);
        if (severity == null) {
            severity = AuditLogSeverity.NORMAL;
            log.infoFormat("No severity for {0} audit log type, assuming Normal severity", logType);
        }
        AuditLog auditLog = null;
        // handle external log messages invoked by plugins via the API
        if (auditLogable.isExternal()) {
            // message is sent as an argument, no need to resolve.
            resolvedMessage = message = loggerString;
            auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName(), auditLogable.getOrigin(), auditLogable.getCustomEventId(), auditLogable.getEventFloodInSec(), auditLogable.getCustomData());
        } else if ((message = messages.get(logType)) != null) {
            // Application log message from AuditLogMessages
            resolvedMessage = resolveMessage(message, auditLogable);
            auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
        }
        if (auditLog != null) {
            auditLog.setstorage_domain_id(auditLogable.getStorageDomainId());
            auditLog.setstorage_domain_name(auditLogable.getStorageDomainName());
            auditLog.setstorage_pool_id(auditLogable.getStoragePoolId());
            auditLog.setstorage_pool_name(auditLogable.getStoragePoolName());
            auditLog.setvds_group_id(auditLogable.getVdsGroupId());
            auditLog.setvds_group_name(auditLogable.getVdsGroupName());
            auditLog.setCorrelationId(auditLogable.getCorrelationId());
            auditLog.setJobId(auditLogable.getJobId());
            auditLog.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
            auditLog.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
            auditLog.setExternal(auditLogable.isExternal());
            auditLog.setQuotaId(auditLogable.getQuotaIdForLog());
            auditLog.setQuotaName(auditLogable.getQuotaNameForLog());
            getDbFacadeInstance().getAuditLogDao().save(auditLog);
            if (!"".equals(loggerString)) {
                log.infoFormat(loggerString, resolvedMessage);
            }
        }
    }
}
#end_block

#method_before
static String resolveMessage(String message, AuditLogableBase logable) {
    String returnValue = message;
    if (logable != null) {
        Map<String, String> map = getAvailableValues(logable);
        returnValue = resolveMessage(message, map);
    }
    return returnValue;
}
#method_after
static String resolveMessage(String message, AuditLogableBase logable) {
    String returnValue = message;
    if (logable != null) {
        Map<String, String> map = getAvailableValues(message, logable);
        returnValue = resolveMessage(message, map);
    }
    return returnValue;
}
#end_block

#method_before
static Map<String, String> getAvailableValues(AuditLogableBase logable) {
    Map<String, String> returnValue = new HashMap<String, String>(logable.getCustomValues());
    Class<?> type = AuditLogableBase.class;
    for (PropertyInfo propertyInfo : TypeCompat.GetProperties(type)) {
        Object value = propertyInfo.getValue(logable, null);
        String stringValue = value != null ? value.toString() : null;
        if (!returnValue.containsKey(propertyInfo.getName().toLowerCase())) {
            returnValue.put(propertyInfo.getName().toLowerCase(), stringValue);
        } else {
            log.errorFormat("Try to add duplicate audit log values with the same name. Type: {0}. Value: {1}", logable.getAuditLogTypeValue(), propertyInfo.getName().toLowerCase());
        }
    }
    List<String> attributes = AuditLogHelper.getCustomLogFields(logable.getClass(), true);
    if (attributes != null && attributes.size() > 0) {
        TypeCompat.getPropertyValues(logable, new HashSet<String>(attributes), returnValue);
    }
    return returnValue;
}
#method_after
private static Map<String, String> getAvailableValues(String message, AuditLogableBase logable) {
    Map<String, String> returnValue = new HashMap<String, String>(logable.getCustomValues());
    Set<String> attributes = resolvePlaceHolders(message);
    if (attributes != null && attributes.size() > 0) {
        TypeCompat.getPropertyValues(logable, attributes, returnValue);
    }
    return returnValue;
}
#end_block

#method_before
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getEditQuotaCommand().setIsExecutionAllowed(items.size() == 1);
    getRemoveQuotaCommand().setIsExecutionAllowed(items.size() > 0);
    getCloneQuotaCommand().setIsExecutionAllowed(items.size() == 1);
}
#method_after
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getEditCommand().setIsExecutionAllowed(items.size() == 1);
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0);
    getCloneCommand().setIsExecutionAllowed(items.size() == 1);
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command.equals(getCreateQuotaCommand())) {
        createQuota();
    } else if (command.equals(getEditQuotaCommand())) {
        editQuota(false);
    } else if (command.getName().equals("OnCreateQuota")) {
        // $NON-NLS-1$
        onCreateQuota();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.equals(getRemoveQuotaCommand())) {
        remove();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemove();
    } else if (command.equals(getCloneQuotaCommand())) {
        editQuota(true);
    } else if (command.getName().equals("onCloneQuota")) {
        // $NON-NLS-1$
        onCreateQuotaInternal(true);
    } else if (command.getName().equals("OnCreateQuotaInternal")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
        onCreateQuotaInternal(false);
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        cancelConfirmation();
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command.equals(getCreateCommand())) {
        createQuota();
    } else if (command.equals(getEditCommand())) {
        editQuota(false);
    } else if (command.getName().equals("OnCreateQuota")) {
        // $NON-NLS-1$
        onCreateQuota();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.equals(getRemoveCommand())) {
        remove();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemove();
    } else if (command.equals(getCloneCommand())) {
        editQuota(true);
    } else if (command.getName().equals("onCloneQuota")) {
        // $NON-NLS-1$
        onCreateQuotaInternal(true);
    } else if (command.getName().equals("OnCreateQuotaInternal")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
        onCreateQuotaInternal(false);
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        cancelConfirmation();
    }
}
#end_block

#method_before
private boolean checkQuotaStorageLimits(QuotaEnforcementTypeEnum quotaEnforcementTypeEnum, Quota quota, double limit, double storageUsagePercentage, double storageRequestPercentage, List<String> canDoActionMessages, Pair<AuditLogType, AuditLogableBase> log) {
    double storageTotalPercentage = storageUsagePercentage + storageRequestPercentage;
    boolean requestIsApproved;
    if (limit == QuotaStorage.UNLIMITED || storageTotalPercentage <= quota.getThresholdStoragePercentage() || storageRequestPercentage <= 0) {
        requestIsApproved = true;
    } else if (storageTotalPercentage <= 100) {
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_THRESHOLD);
        quotaManagerAuditLogger.addCustomValuesStorage(log.getSecond(), quota.getQuotaName(), storageUsagePercentage + storageRequestPercentage, storageRequestPercentage);
        requestIsApproved = true;
    } else if (storageTotalPercentage <= quota.getGraceStoragePercentage() + 100) {
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_LIMIT);
        quotaManagerAuditLogger.addCustomValuesStorage(log.getSecond(), quota.getQuotaName(), storageUsagePercentage + storageRequestPercentage, storageRequestPercentage);
        requestIsApproved = true;
    } else {
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT);
        quotaManagerAuditLogger.addCustomValuesStorage(log.getSecond(), quota.getQuotaName(), storageUsagePercentage, storageRequestPercentage);
        if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == quotaEnforcementTypeEnum) {
            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_STORAGE_LIMIT_EXCEEDED.toString());
            requestIsApproved = false;
        } else {
            requestIsApproved = true;
        }
    }
    return requestIsApproved;
}
#method_after
private boolean checkQuotaStorageLimits(QuotaEnforcementTypeEnum quotaEnforcementTypeEnum, Quota quota, double limit, double storageUsagePercentage, double storageRequestPercentage, List<String> canDoActionMessages, Pair<AuditLogType, AuditLogableBase> log) {
    double storageTotalPercentage = storageUsagePercentage + storageRequestPercentage;
    boolean requestIsApproved;
    if (limit == QuotaStorage.UNLIMITED || storageTotalPercentage <= quota.getThresholdStoragePercentage() || storageRequestPercentage <= 0) {
        requestIsApproved = true;
    } else if (storageTotalPercentage <= 100) {
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_THRESHOLD);
        quotaManagerAuditLogger.addCustomValuesStorage(log.getSecond(), quota.getQuotaName(), quota.getId(), storageUsagePercentage + storageRequestPercentage, storageRequestPercentage);
        requestIsApproved = true;
    } else if (storageTotalPercentage <= quota.getGraceStoragePercentage() + 100) {
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_LIMIT);
        quotaManagerAuditLogger.addCustomValuesStorage(log.getSecond(), quota.getQuotaName(), quota.getId(), storageUsagePercentage + storageRequestPercentage, storageRequestPercentage);
        requestIsApproved = true;
    } else {
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT);
        quotaManagerAuditLogger.addCustomValuesStorage(log.getSecond(), quota.getQuotaName(), quota.getId(), storageUsagePercentage, storageRequestPercentage);
        if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == quotaEnforcementTypeEnum) {
            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_STORAGE_LIMIT_EXCEEDED.toString());
            requestIsApproved = false;
        } else {
            requestIsApproved = true;
        }
    }
    if (!requestIsApproved) {
        log.getSecond().setQuotaIdForLog(quota.getId());
    }
    return requestIsApproved;
}
#end_block

#method_before
private boolean checkQuotaClusterLimits(QuotaEnforcementTypeEnum quotaEnforcementTypeEnum, Quota quota, QuotaVdsGroup quotaVdsGroup, long memToAdd, int vcpuToAdd, List<String> canDoActionMessages, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    if (quotaVdsGroup.getVirtualCpu() == 0 || quotaVdsGroup.getMemSizeMB() == 0) {
        return false;
    }
    double vcpuToAddPercentage = (double) vcpuToAdd / (double) quotaVdsGroup.getVirtualCpu() * 100;
    double vcpuCurrentPercentage = (double) quotaVdsGroup.getVirtualCpuUsage() / (double) quotaVdsGroup.getVirtualCpu() * 100;
    double newVcpuPercent = vcpuToAddPercentage + vcpuCurrentPercentage;
    double memToAddPercentage = (double) memToAdd / (double) quotaVdsGroup.getMemSizeMB() * 100;
    double memCurrentPercentage = (double) quotaVdsGroup.getMemSizeMBUsage() / (double) quotaVdsGroup.getMemSizeMB() * 100;
    double newMemoryPercent = memToAddPercentage + memCurrentPercentage;
    long newMemory = memToAdd + quotaVdsGroup.getMemSizeMBUsage();
    int newVcpu = vcpuToAdd + quotaVdsGroup.getVirtualCpuUsage();
    long memLimit = quotaVdsGroup.getMemSizeMB();
    int cpuLimit = quotaVdsGroup.getVirtualCpu();
    boolean requestIsApproved;
    if (memLimit == QuotaVdsGroup.UNLIMITED_MEM && cpuLimit == QuotaVdsGroup.UNLIMITED_VCPU) {
        // if both cpu and
        // mem are unlimited
        requestIsApproved = true;
    } else if ((// if cpu and mem usages are under the limit
    newVcpuPercent <= quota.getThresholdVdsGroupPercentage() && newMemoryPercent <= quota.getThresholdVdsGroupPercentage()) || (vcpuToAdd <= 0 && memToAdd <= 0)) {
        requestIsApproved = true;
    } else if (newVcpuPercent <= 100 && newMemoryPercent <= 100) {
        // passed the threshold (not the quota limit)
        auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_THRESHOLD);
        quotaManagerAuditLogger.addCustomValuesVdsGroup(auditLogPair.getSecond(), quota.getQuotaName(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > quota.getThresholdVdsGroupPercentage(), newMemoryPercent > quota.getThresholdVdsGroupPercentage());
        requestIsApproved = true;
    } else if (newVcpuPercent <= quota.getGraceVdsGroupPercentage() + 100 && newMemoryPercent <= quota.getGraceVdsGroupPercentage() + 100) {
        // passed the quota limit (not the
        // grace)
        auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_LIMIT);
        quotaManagerAuditLogger.addCustomValuesVdsGroup(auditLogPair.getSecond(), quota.getQuotaName(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > 100, newMemoryPercent > 100);
        requestIsApproved = true;
    } else {
        // passed the grace
        auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_GRACE_LIMIT);
        quotaManagerAuditLogger.addCustomValuesVdsGroup(auditLogPair.getSecond(), quota.getQuotaName(), vcpuCurrentPercentage, vcpuToAddPercentage, memCurrentPercentage, memToAddPercentage, newVcpuPercent > quota.getGraceVdsGroupPercentage() + 100, newMemoryPercent > quota.getGraceVdsGroupPercentage() + 100);
        if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == quotaEnforcementTypeEnum) {
            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_VDS_GROUP_LIMIT_EXCEEDED.toString());
            requestIsApproved = false;
        } else {
            requestIsApproved = true;
        }
    }
    // cache
    if (requestIsApproved) {
        cacheNewValues(quotaVdsGroup, newMemory, newVcpu);
    }
    return requestIsApproved;
}
#method_after
private boolean checkQuotaClusterLimits(QuotaEnforcementTypeEnum quotaEnforcementTypeEnum, Quota quota, QuotaVdsGroup quotaVdsGroup, long memToAdd, int vcpuToAdd, List<String> canDoActionMessages, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    if (quotaVdsGroup.getVirtualCpu() == 0 || quotaVdsGroup.getMemSizeMB() == 0) {
        return false;
    }
    double vcpuToAddPercentage = (double) vcpuToAdd / (double) quotaVdsGroup.getVirtualCpu() * 100;
    double vcpuCurrentPercentage = (double) quotaVdsGroup.getVirtualCpuUsage() / (double) quotaVdsGroup.getVirtualCpu() * 100;
    double newVcpuPercent = vcpuToAddPercentage + vcpuCurrentPercentage;
    double memToAddPercentage = (double) memToAdd / (double) quotaVdsGroup.getMemSizeMB() * 100;
    double memCurrentPercentage = (double) quotaVdsGroup.getMemSizeMBUsage() / (double) quotaVdsGroup.getMemSizeMB() * 100;
    double newMemoryPercent = memToAddPercentage + memCurrentPercentage;
    long newMemory = memToAdd + quotaVdsGroup.getMemSizeMBUsage();
    int newVcpu = vcpuToAdd + quotaVdsGroup.getVirtualCpuUsage();
    long memLimit = quotaVdsGroup.getMemSizeMB();
    int cpuLimit = quotaVdsGroup.getVirtualCpu();
    boolean requestIsApproved;
    if (memLimit == QuotaVdsGroup.UNLIMITED_MEM && cpuLimit == QuotaVdsGroup.UNLIMITED_VCPU) {
        // if both cpu and
        // mem are unlimited
        requestIsApproved = true;
    } else if ((// if cpu and mem usages are under the limit
    newVcpuPercent <= quota.getThresholdVdsGroupPercentage() && newMemoryPercent <= quota.getThresholdVdsGroupPercentage()) || (vcpuToAdd <= 0 && memToAdd <= 0)) {
        requestIsApproved = true;
    } else if (newVcpuPercent <= 100 && newMemoryPercent <= 100) {
        // passed the threshold (not the quota limit)
        auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_THRESHOLD);
        quotaManagerAuditLogger.addCustomValuesVdsGroup(auditLogPair.getSecond(), quota.getQuotaName(), quota.getId(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > quota.getThresholdVdsGroupPercentage(), newMemoryPercent > quota.getThresholdVdsGroupPercentage());
        requestIsApproved = true;
    } else if (newVcpuPercent <= quota.getGraceVdsGroupPercentage() + 100 && newMemoryPercent <= quota.getGraceVdsGroupPercentage() + 100) {
        // passed the quota limit (not the
        // grace)
        auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_LIMIT);
        quotaManagerAuditLogger.addCustomValuesVdsGroup(auditLogPair.getSecond(), quota.getQuotaName(), quota.getId(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > 100, newMemoryPercent > 100);
        requestIsApproved = true;
    } else {
        // passed the grace
        auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_GRACE_LIMIT);
        quotaManagerAuditLogger.addCustomValuesVdsGroup(auditLogPair.getSecond(), quota.getQuotaName(), quota.getId(), vcpuCurrentPercentage, vcpuToAddPercentage, memCurrentPercentage, memToAddPercentage, newVcpuPercent > quota.getGraceVdsGroupPercentage() + 100, newMemoryPercent > quota.getGraceVdsGroupPercentage() + 100);
        if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == quotaEnforcementTypeEnum) {
            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_VDS_GROUP_LIMIT_EXCEEDED.toString());
            requestIsApproved = false;
        } else {
            requestIsApproved = true;
        }
    }
    // cache
    if (requestIsApproved) {
        cacheNewValues(quotaVdsGroup, newMemory, newVcpu);
    } else {
        auditLogPair.getSecond().setQuotaIdForLog(quota.getId());
    }
    return requestIsApproved;
}
#end_block

#method_before
// In case this param is a QuotaStorageConsumptionParameter - check that it has a valid
private boolean checkStoragePoolMatchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param) {
    Quota quota = param.getQuota();
    QuotaStorageConsumptionParameter paramStorage = (QuotaStorageConsumptionParameter) param;
    if (paramStorage.getStorageDomainId() == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        log.errorFormat("Quota storage parameters from command: {0} are missing storage domain id", parameters.getAuditLogable().getClass().getName());
        return false;
    }
    boolean storageDomainInQuota = false;
    if (quota.getGlobalQuotaStorage() != null) {
        storageDomainInQuota = true;
    } else {
        for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
            if (quotaStorage.getStorageId().equals(paramStorage.getStorageDomainId())) {
                storageDomainInQuota = true;
                break;
            }
        }
    }
    if (!storageDomainInQuota) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        log.errorFormat("Quota storage parameters from command: {0}. Storage domain does not match quota", parameters.getAuditLogable().getClass().getName());
        return false;
    }
    return true;
}
#method_after
// In case this param is a QuotaStorageConsumptionParameter - check that it has a valid
private boolean checkStoragePoolMatchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param) {
    Quota quota = param.getQuota();
    QuotaStorageConsumptionParameter paramStorage = (QuotaStorageConsumptionParameter) param;
    if (paramStorage.getStorageDomainId() == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        log.errorFormat("Quota storage parameters from command: {0} are missing storage domain id", parameters.getAuditLogable().getClass().getName());
        return false;
    }
    boolean storageDomainInQuota = false;
    if (quota.getGlobalQuotaStorage() != null) {
        storageDomainInQuota = true;
    } else {
        for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
            if (quotaStorage.getStorageId().equals(paramStorage.getStorageDomainId())) {
                storageDomainInQuota = true;
                break;
            }
        }
    }
    if (!storageDomainInQuota) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_NO_QUOTA_SET_FOR_DOMAIN.toString());
        log.errorFormat("Quota storage parameters from command: {0}. Storage domain does not match quota", parameters.getAuditLogable().getClass().getName());
        return false;
    }
    return true;
}
#end_block

#method_before
private QuotaUsagePerUser addQuotaEntry(Quota quota) {
    // if quota is not null (found in cache or DB) - add entry to quotaPerUserUsageEntityMap
    if (quota != null) {
        double storageLimit = 0;
        double storageUsage = 0;
        int cpuLimit = 0;
        int cpuUsage = 0;
        long memLimit = 0;
        long memUsage = 0;
        // calc storage
        if (quota.getGlobalQuotaStorage() != null) {
            storageLimit = quota.getGlobalQuotaStorage().getStorageSizeGB();
            storageUsage = quota.getGlobalQuotaStorage().getStorageSizeGBUsage();
        } else {
            for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                if (storageLimit == QuotaStorage.UNLIMITED || QuotaStorage.UNLIMITED.equals(quotaStorage.getStorageSizeGB())) {
                    storageLimit = QuotaStorage.UNLIMITED;
                } else {
                    storageLimit += quotaStorage.getStorageSizeGB();
                }
                storageUsage += quotaStorage.getStorageSizeGBUsage();
            }
        }
        // calc cpu and mem
        if (quota.getGlobalQuotaVdsGroup() != null) {
            memLimit = quota.getGlobalQuotaVdsGroup().getMemSizeMB();
            memUsage = quota.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            cpuLimit = quota.getGlobalQuotaVdsGroup().getVirtualCpu();
            cpuUsage = quota.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
        } else {
            for (QuotaVdsGroup quotaVdsGroup : quota.getQuotaVdsGroups()) {
                if (memLimit == QuotaVdsGroup.UNLIMITED_MEM || QuotaVdsGroup.UNLIMITED_MEM.equals(quotaVdsGroup.getMemSizeMB())) {
                    memLimit = QuotaVdsGroup.UNLIMITED_MEM;
                } else {
                    memLimit += quotaVdsGroup.getMemSizeMB();
                }
                memUsage += quotaVdsGroup.getMemSizeMBUsage();
                if (cpuLimit == QuotaVdsGroup.UNLIMITED_VCPU || QuotaVdsGroup.UNLIMITED_VCPU.equals(quotaVdsGroup.getVirtualCpu())) {
                    cpuLimit = QuotaVdsGroup.UNLIMITED_VCPU;
                } else {
                    cpuLimit += quotaVdsGroup.getVirtualCpu();
                }
                cpuUsage += quotaVdsGroup.getVirtualCpuUsage();
            }
        }
        return new QuotaUsagePerUser(quota.getId(), quota.getQuotaName(), storageLimit, storageUsage, cpuLimit, cpuUsage, memLimit, memUsage);
    }
    return null;
}
#method_after
private QuotaUsagePerUser addQuotaEntry(Quota quota) {
    // if quota is not null (found in cache or DB) - add entry to quotaPerUserUsageEntityMap
    if (quota != null) {
        double storageLimit = 0;
        double storageUsage = 0;
        int cpuLimit = 0;
        int cpuUsage = 0;
        long memLimit = 0;
        long memUsage = 0;
        // calc storage
        if (quota.getGlobalQuotaStorage() != null) {
            storageLimit = quota.getGlobalQuotaStorage().getStorageSizeGB();
            storageUsage = quota.getGlobalQuotaStorage().getStorageSizeGBUsage();
        } else {
            for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                // once storage was set unlimited it will remain so
                if (QuotaStorage.UNLIMITED.equals(quotaStorage.getStorageSizeGB())) {
                    // Do not break because usage is still counting
                    storageLimit = QuotaStorage.UNLIMITED;
                }
                if (storageLimit != QuotaStorage.UNLIMITED) {
                    storageLimit += quotaStorage.getStorageSizeGB();
                }
                storageUsage += quotaStorage.getStorageSizeGBUsage();
            }
        }
        // calc cpu and mem
        if (quota.getGlobalQuotaVdsGroup() != null) {
            memLimit = quota.getGlobalQuotaVdsGroup().getMemSizeMB();
            memUsage = quota.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            cpuLimit = quota.getGlobalQuotaVdsGroup().getVirtualCpu();
            cpuUsage = quota.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
        } else {
            for (QuotaVdsGroup quotaVdsGroup : quota.getQuotaVdsGroups()) {
                // once mem was set unlimited it will remain so
                if (QuotaVdsGroup.UNLIMITED_MEM.equals(quotaVdsGroup.getMemSizeMB())) {
                    // Do not break because usage is still counting
                    memLimit = QuotaVdsGroup.UNLIMITED_MEM;
                }
                if (memLimit != QuotaVdsGroup.UNLIMITED_MEM) {
                    memLimit += quotaVdsGroup.getMemSizeMB();
                }
                // once cpu was set unlimited it will remain so
                if (QuotaVdsGroup.UNLIMITED_VCPU.equals(quotaVdsGroup.getVirtualCpu())) {
                    // Do not break because usage is still counting
                    cpuLimit = QuotaVdsGroup.UNLIMITED_VCPU;
                }
                if (cpuLimit != QuotaVdsGroup.UNLIMITED_VCPU) {
                    cpuLimit += quotaVdsGroup.getVirtualCpu();
                }
                memUsage += quotaVdsGroup.getMemSizeMBUsage();
                cpuUsage += quotaVdsGroup.getVirtualCpuUsage();
            }
        }
        return new QuotaUsagePerUser(quota.getId(), quota.getQuotaName(), storageLimit, storageUsage, cpuLimit, cpuUsage, memLimit, memUsage);
    }
    return null;
}
#end_block

#method_before
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new QuotaDcStatusColumn(), constants.empty(), "30px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getQuotaName() == null ? "" : object.getQuotaName();
        }
    }, constants.nameQuota(), // $NON-NLS-1$
    "120px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getDescription() == null ? "" : object.getDescription();
        }
    }, constants.descriptionQuota(), // $NON-NLS-1$
    "120px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getMemSizeMB();
                used = object.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    if (!QuotaVdsGroup.UNLIMITED_MEM.equals(quotaVdsGroup.getMemSizeMB())) {
                        allocated += quotaVdsGroup.getMemSizeMB();
                        used += quotaVdsGroup.getMemSizeMBUsage();
                    } else {
                        allocated = QuotaVdsGroup.UNLIMITED_MEM;
                        break;
                    }
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }

        @Override
        public ApplicationConstants getaApplicationConstants() {
            return constants;
        }
    }, constants.usedMemoryQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getMemSizeMB();
                used = object.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    if (!QuotaVdsGroup.UNLIMITED_MEM.equals(quotaVdsGroup.getMemSizeMB())) {
                        allocated += quotaVdsGroup.getMemSizeMB();
                        used += quotaVdsGroup.getMemSizeMBUsage();
                    } else {
                        allocated = QuotaVdsGroup.UNLIMITED_MEM;
                        break;
                    }
                }
            }
            value = (int) (allocated - used);
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 MB";
            } else if (value <= 5 * 1024) {
                // $NON-NLS-1$
                returnVal = value + "MB";
            } else {
                // $NON-NLS-1$
                returnVal = decimalFormat.format((double) value / 1024) + "GB";
            }
            return returnVal;
        }
    }, constants.freeMemory(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getVirtualCpu();
                used = object.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    if (!QuotaVdsGroup.UNLIMITED_VCPU.equals(quotaVdsGroup.getVirtualCpu())) {
                        allocated += quotaVdsGroup.getVirtualCpu();
                        used += quotaVdsGroup.getVirtualCpuUsage();
                    } else {
                        allocated = QuotaVdsGroup.UNLIMITED_VCPU;
                        break;
                    }
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }

        @Override
        public ApplicationConstants getaApplicationConstants() {
            return constants;
        }
    }, constants.runningCpuQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getVirtualCpu();
                used = object.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    if (!QuotaVdsGroup.UNLIMITED_VCPU.equals(quotaVdsGroup.getVirtualCpu())) {
                        allocated += quotaVdsGroup.getVirtualCpu();
                        used += quotaVdsGroup.getVirtualCpuUsage();
                    } else {
                        allocated = QuotaVdsGroup.UNLIMITED_VCPU;
                        break;
                    }
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0";
            } else {
                // $NON-NLS-1$
                returnVal = value + "";
            }
            return returnVal;
        }
    }, constants.freeVcpu(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    if (!QuotaStorage.UNLIMITED.equals(quotaStorage.getStorageSizeGB())) {
                        allocated += quotaStorage.getStorageSizeGB();
                        used += quotaStorage.getStorageSizeGBUsage();
                    } else {
                        allocated = QuotaStorage.UNLIMITED;
                        break;
                    }
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) ((used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }

        @Override
        public ApplicationConstants getaApplicationConstants() {
            return constants;
        }
    }, constants.usedStorageQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            double value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    if (!QuotaStorage.UNLIMITED.equals(quotaStorage.getStorageSizeGB())) {
                        allocated += quotaStorage.getStorageSizeGB();
                        used += quotaStorage.getStorageSizeGBUsage();
                    } else {
                        allocated = QuotaStorage.UNLIMITED;
                        break;
                    }
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 GB";
            } else {
                returnVal = diskSizeRenderer.render(value);
            }
            return returnVal;
        }
    }, constants.freeStorage(), // $NON-NLS-1$
    "80px");
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.addQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.editQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.copyQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.removeQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveQuotaCommand();
        }
    });
}
#method_after
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new QuotaDcStatusColumn(), constants.empty(), "30px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getQuotaName() == null ? "" : object.getQuotaName();
        }
    }, constants.nameQuota(), // $NON-NLS-1$
    "120px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getDescription() == null ? "" : object.getDescription();
        }
    }, constants.descriptionQuota(), // $NON-NLS-1$
    "120px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getMemSizeMB();
                used = object.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    if (!QuotaVdsGroup.UNLIMITED_MEM.equals(quotaVdsGroup.getMemSizeMB())) {
                        allocated += quotaVdsGroup.getMemSizeMB();
                        used += quotaVdsGroup.getMemSizeMBUsage();
                    } else {
                        allocated = QuotaVdsGroup.UNLIMITED_MEM;
                        break;
                    }
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }

        @Override
        public ApplicationConstants getaApplicationConstants() {
            return constants;
        }
    }, constants.usedMemoryQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getMemSizeMB();
                used = object.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    if (!QuotaVdsGroup.UNLIMITED_MEM.equals(quotaVdsGroup.getMemSizeMB())) {
                        allocated += quotaVdsGroup.getMemSizeMB();
                        used += quotaVdsGroup.getMemSizeMBUsage();
                    } else {
                        allocated = QuotaVdsGroup.UNLIMITED_MEM;
                        break;
                    }
                }
            }
            value = (int) (allocated - used);
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 MB";
            } else if (value <= 5 * 1024) {
                // $NON-NLS-1$
                returnVal = value + "MB";
            } else {
                // $NON-NLS-1$
                returnVal = decimalFormat.format((double) value / 1024) + "GB";
            }
            return returnVal;
        }
    }, constants.freeMemory(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getVirtualCpu();
                used = object.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    if (!QuotaVdsGroup.UNLIMITED_VCPU.equals(quotaVdsGroup.getVirtualCpu())) {
                        allocated += quotaVdsGroup.getVirtualCpu();
                        used += quotaVdsGroup.getVirtualCpuUsage();
                    } else {
                        allocated = QuotaVdsGroup.UNLIMITED_VCPU;
                        break;
                    }
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }

        @Override
        public ApplicationConstants getaApplicationConstants() {
            return constants;
        }
    }, constants.runningCpuQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getVirtualCpu();
                used = object.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    if (!QuotaVdsGroup.UNLIMITED_VCPU.equals(quotaVdsGroup.getVirtualCpu())) {
                        allocated += quotaVdsGroup.getVirtualCpu();
                        used += quotaVdsGroup.getVirtualCpuUsage();
                    } else {
                        allocated = QuotaVdsGroup.UNLIMITED_VCPU;
                        break;
                    }
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0";
            } else {
                // $NON-NLS-1$
                returnVal = value + "";
            }
            return returnVal;
        }
    }, constants.freeVcpu(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    if (!QuotaStorage.UNLIMITED.equals(quotaStorage.getStorageSizeGB())) {
                        allocated += quotaStorage.getStorageSizeGB();
                        used += quotaStorage.getStorageSizeGBUsage();
                    } else {
                        allocated = QuotaStorage.UNLIMITED;
                        break;
                    }
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) ((used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }

        @Override
        public ApplicationConstants getaApplicationConstants() {
            return constants;
        }
    }, constants.usedStorageQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            double value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    if (!QuotaStorage.UNLIMITED.equals(quotaStorage.getStorageSizeGB())) {
                        allocated += quotaStorage.getStorageSizeGB();
                        used += quotaStorage.getStorageSizeGBUsage();
                    } else {
                        allocated = QuotaStorage.UNLIMITED;
                        break;
                    }
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 GB";
            } else {
                returnVal = diskSizeRenderer.render(value);
            }
            return returnVal;
        }
    }, constants.freeStorage(), // $NON-NLS-1$
    "80px");
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.addQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.editQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.copyQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.removeQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
private void NewDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDomainTitle());
    // $NON-NLS-1$
    model.setHashName("new_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    ArrayList<IStorageModel> items = new ArrayList<IStorageModel>();
    // putting all Data domains at the beginning on purpose (so when choosing the
    // first selectable storage type/function, it will be a Data one, if relevant).
    NfsStorageModel nfsDataModel = new NfsStorageModel();
    nfsDataModel.setRole(StorageDomainType.Data);
    items.add(nfsDataModel);
    IscsiStorageModel iscsiDataModel = new IscsiStorageModel();
    iscsiDataModel.setRole(StorageDomainType.Data);
    iscsiDataModel.setIsGrouppedByTarget(true);
    items.add(iscsiDataModel);
    FcpStorageModel fcpDataModel = new FcpStorageModel();
    fcpDataModel.setRole(StorageDomainType.Data);
    items.add(fcpDataModel);
    LocalStorageModel localDataModel = new LocalStorageModel();
    localDataModel.setRole(StorageDomainType.Data);
    items.add(localDataModel);
    PosixStorageModel posixDataModel = new PosixStorageModel();
    posixDataModel.setRole(StorageDomainType.Data);
    items.add(posixDataModel);
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    nfsIsoModel.setRole(StorageDomainType.ISO);
    items.add(nfsIsoModel);
    NfsStorageModel nfsExportModel = new NfsStorageModel();
    nfsExportModel.setRole(StorageDomainType.ImportExport);
    items.add(nfsExportModel);
    IscsiStorageModel iscsiExportModel = new IscsiStorageModel();
    iscsiExportModel.setRole(StorageDomainType.ImportExport);
    iscsiExportModel.setIsGrouppedByTarget(true);
    items.add(iscsiExportModel);
    FcpStorageModel fcpExportModel = new FcpStorageModel();
    fcpExportModel.setRole(StorageDomainType.ImportExport);
    items.add(fcpExportModel);
    model.setItems(items);
    model.Initialize();
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand("OnSave", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#method_after
private void NewDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDomainTitle());
    // $NON-NLS-1$
    model.setHashName("new_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    ArrayList<IStorageModel> items = new ArrayList<IStorageModel>();
    // putting all Data domains at the beginning on purpose (so when choosing the
    // first selectable storage type/function, it will be a Data one, if relevant).
    NfsStorageModel nfsDataModel = new NfsStorageModel();
    nfsDataModel.setRole(StorageDomainType.Data);
    items.add(nfsDataModel);
    IscsiStorageModel iscsiDataModel = new IscsiStorageModel();
    iscsiDataModel.setRole(StorageDomainType.Data);
    iscsiDataModel.setIsGrouppedByTarget(true);
    items.add(iscsiDataModel);
    FcpStorageModel fcpDataModel = new FcpStorageModel();
    fcpDataModel.setRole(StorageDomainType.Data);
    items.add(fcpDataModel);
    LocalStorageModel localDataModel = new LocalStorageModel();
    localDataModel.setRole(StorageDomainType.Data);
    items.add(localDataModel);
    PosixStorageModel posixDataModel = new PosixStorageModel();
    posixDataModel.setRole(StorageDomainType.Data);
    items.add(posixDataModel);
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    nfsIsoModel.setRole(StorageDomainType.ISO);
    items.add(nfsIsoModel);
    NfsStorageModel nfsExportModel = new NfsStorageModel();
    nfsExportModel.setRole(StorageDomainType.ImportExport);
    items.add(nfsExportModel);
    IscsiStorageModel iscsiExportModel = new IscsiStorageModel();
    iscsiExportModel.setRole(StorageDomainType.ImportExport);
    iscsiExportModel.setIsGrouppedByTarget(true);
    items.add(iscsiExportModel);
    FcpStorageModel fcpExportModel = new FcpStorageModel();
    fcpExportModel.setRole(StorageDomainType.ImportExport);
    items.add(fcpExportModel);
    GlusterStorageModel GlusterDataModel = new GlusterStorageModel();
    GlusterDataModel.setRole(StorageDomainType.Data);
    items.add(GlusterDataModel);
    model.setItems(items);
    model.Initialize();
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand("OnSave", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#end_block

#method_before
private void Edit() {
    StorageDomain storage = (StorageDomain) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangable(false);
    model.getFormat().setIsChangable(false);
    boolean isStorageEditable = model.isStorageActive() || model.isNewStorage();
    model.getHost().setIsChangable(false);
    model.getName().setIsChangable(isStorageEditable);
    model.getDescription().setIsChangable(isStorageEditable);
    model.getAvailableStorageItems().setIsChangable(isStorageEditable);
    model.setIsChangable(isStorageEditable);
    IStorageModel item = null;
    switch(storage.getStorageType()) {
        case NFS:
            item = prepareNfsStorageForEdit(storage);
            boolean isNfsPathEditable = isNfsPathEditable(storage);
            isStorageEditable = isStorageEditable || isNfsPathEditable;
            break;
        case FCP:
            item = prepareFcpStorageForEdit(storage);
            break;
        case ISCSI:
            item = prepareIscsiStorageForEdit(storage);
            break;
        case LOCALFS:
            item = prepareLocalStorageForEdit(storage);
            break;
        case POSIXFS:
            item = preparePosixStorageForEdit(storage);
            break;
    }
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.Initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case Storage:
                {
                    model.getName().setIsChangable(false);
                    // $NON-NLS-1$
                    model.getName().setInfo("Cannot edit Storage Domains's Name in this tree context");
                }
                break;
        }
    }
    UICommand command;
    if (isStorageEditable) {
        // $NON-NLS-1$
        command = new UICommand("OnSave", this);
        command.setTitle(ConstantsManager.getInstance().getConstants().ok());
        command.setIsDefault(true);
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = new UICommand("Cancel", this);
        command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        command.setIsCancel(true);
        model.getCommands().add(command);
    } else {
        // $NON-NLS-1$
        command = new UICommand("Cancel", this);
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        command.setIsCancel(true);
        model.getCommands().add(command);
    }
}
#method_after
private void Edit() {
    StorageDomain storage = (StorageDomain) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangable(false);
    model.getFormat().setIsChangable(false);
    boolean isStorageEditable = model.isStorageActive() || model.isNewStorage();
    model.getHost().setIsChangable(false);
    model.getName().setIsChangable(isStorageEditable);
    model.getDescription().setIsChangable(isStorageEditable);
    model.getAvailableStorageItems().setIsChangable(isStorageEditable);
    model.setIsChangable(isStorageEditable);
    IStorageModel item = null;
    switch(storage.getStorageType()) {
        case NFS:
            item = prepareNfsStorageForEdit(storage);
            boolean isNfsPathEditable = isNfsPathEditable(storage);
            isStorageEditable = isStorageEditable || isNfsPathEditable;
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isNfsPathEditable);
            break;
        case FCP:
            item = prepareFcpStorageForEdit(storage);
            break;
        case ISCSI:
            item = prepareIscsiStorageForEdit(storage);
            break;
        case LOCALFS:
            item = prepareLocalStorageForEdit(storage);
            break;
        case POSIXFS:
            item = preparePosixStorageForEdit(storage);
            break;
        case GLUSTERFS:
            item = prepareGlusterStorageForEdit(storage);
            break;
    }
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.Initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case Storage:
                {
                    model.getName().setIsChangable(false);
                    // $NON-NLS-1$
                    model.getName().setInfo("Cannot edit Storage Domains's Name in this tree context");
                }
                break;
        }
    }
    UICommand command;
    if (isStorageEditable) {
        // $NON-NLS-1$
        command = new UICommand("OnSave", this);
        command.setTitle(ConstantsManager.getInstance().getConstants().ok());
        command.setIsDefault(true);
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = new UICommand("Cancel", this);
        command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        command.setIsCancel(true);
        model.getCommands().add(command);
    } else {
        // $NON-NLS-1$
        command = new UICommand("Cancel", this);
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        command.setIsCancel(true);
        model.getCommands().add(command);
    }
}
#end_block

#method_before
private void OnSavePostNameValidation() {
    StorageModel model = (StorageModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    if (model.getSelectedItem() instanceof NfsStorageModel) {
        saveNfsStorage();
    } else if (model.getSelectedItem() instanceof LocalStorageModel) {
        saveLocalStorage();
    } else if (model.getSelectedItem() instanceof PosixStorageModel) {
        savePosixStorage();
    } else {
        saveSanStorage();
    }
}
#method_after
private void OnSavePostNameValidation() {
    StorageModel model = (StorageModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    if (model.getSelectedItem() instanceof NfsStorageModel) {
        saveNfsStorage();
    } else if (model.getSelectedItem() instanceof LocalStorageModel) {
        saveLocalStorage();
    } else if (model.getSelectedItem() instanceof PosixStorageModel) {
        savePosixStorage();
    } else if (model.getSelectedItem() instanceof GlusterStorageModel) {
        saveGlusterStorage();
    } else {
        saveSanStorage();
    }
}
#end_block

#method_before
private void updateNfsPath() {
    StorageModel model = (StorageModel) getWindow();
    NfsStorageModel nfsModel = (NfsStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    connection.setconnection(path);
    connection.setstorage_type(nfsModel.getType());
    if ((Boolean) nfsModel.getOverride().getEntity()) {
        connection.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
        connection.setNfsRetrans(nfsModel.getRetransmissions().AsConvertible().nullableShort());
        connection.setNfsTimeo(nfsModel.getTimeout().AsConvertible().nullableShort());
    }
    StorageServerConnectionParametersBase parameters = new StorageServerConnectionParametersBase(connection, host.getId());
    parameters.setStoragePoolId(host.getStoragePoolId());
    Frontend.RunAction(VdcActionType.UpdateStorageServerConnection, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.OnFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    }, this);
}
#method_after
private void updateNfsPath() {
    StorageModel model = (StorageModel) getWindow();
    NfsStorageModel nfsModel = (NfsStorageModel) model.getSelectedItem();
    VDS host = (VDS) model.getHost().getSelectedItem();
    Guid hostId = Guid.Empty;
    Guid storagePoolId = Guid.Empty;
    if (host != null) {
        hostId = host.getId();
        storagePoolId = host.getStoragePoolId();
    }
    connection.setconnection(path);
    connection.setstorage_type(nfsModel.getType());
    if ((Boolean) nfsModel.getOverride().getEntity()) {
        connection.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
        connection.setNfsRetrans(nfsModel.getRetransmissions().AsConvertible().nullableShort());
        connection.setNfsTimeo(nfsModel.getTimeout().AsConvertible().nullableShort());
    }
    StorageServerConnectionParametersBase parameters = new StorageServerConnectionParametersBase(connection, hostId);
    parameters.setStoragePoolId(storagePoolId);
    Frontend.RunAction(VdcActionType.UpdateStorageServerConnection, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.OnFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    }, this);
}
#end_block

#method_before
@Override
public void run(TaskContext context) {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    String key = (String) data.get(0);
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SaveNfs")) {
        saveNfsStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SaveLocal")) {
        saveLocalStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SavePosix")) {
        savePosixStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SaveSan")) {
        saveSanStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "ImportNfs")) {
        ImportNfsStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "Finish")) {
        getWindow().StopProgress();
        if ((Boolean) data.get(1)) {
            Cancel();
        } else {
            ((Model) data.get(2)).setMessage((String) data.get(3));
        }
    }
}
#method_after
@Override
public void run(TaskContext context) {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    String key = (String) data.get(0);
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SaveNfs")) {
        saveNfsStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SaveLocal")) {
        saveLocalStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SavePosix")) {
        savePosixStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SaveGluster")) {
        saveGlusterStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "SaveSan")) {
        saveSanStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "ImportNfs")) {
        ImportNfsStorage(context);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(key, "Finish")) {
        getWindow().StopProgress();
        if ((Boolean) data.get(1)) {
            Cancel();
        } else {
            ((Model) data.get(2)).setMessage((String) data.get(3));
        }
    }
}
#end_block

#method_before
private boolean checkQuotaStorageLimits(QuotaEnforcementTypeEnum quotaEnforcementTypeEnum, Quota quota, double limit, double storageUsagePercentage, double storageRequestPercentage, List<String> canDoActionMessages, Pair<AuditLogType, AuditLogableBase> log) {
    double storageTotalPercentage = storageUsagePercentage + storageRequestPercentage;
    boolean requestIsApproved;
    if (limit == QuotaStorage.UNLIMITED || storageTotalPercentage <= quota.getThresholdStoragePercentage() || storageRequestPercentage <= 0) {
        requestIsApproved = true;
    } else if (storageTotalPercentage <= 100) {
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_THRESHOLD);
        quotaManagerAuditLogger.addCustomValuesStorage(log.getSecond(), quota.getQuotaName(), storageUsagePercentage + storageRequestPercentage, storageRequestPercentage);
        requestIsApproved = true;
    } else if (storageTotalPercentage <= quota.getGraceStoragePercentage() + 100) {
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_LIMIT);
        quotaManagerAuditLogger.addCustomValuesStorage(log.getSecond(), quota.getQuotaName(), storageUsagePercentage + storageRequestPercentage, storageRequestPercentage);
        requestIsApproved = true;
    } else {
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT);
        quotaManagerAuditLogger.addCustomValuesStorage(log.getSecond(), quota.getQuotaName(), storageUsagePercentage, storageRequestPercentage);
        if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == quotaEnforcementTypeEnum) {
            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_STORAGE_LIMIT_EXCEEDED.toString());
            requestIsApproved = false;
        } else {
            requestIsApproved = true;
        }
    }
    if (!requestIsApproved) {
        log.getSecond().setQuotaIdForLog(quota.getId());
    }
    return requestIsApproved;
}
#method_after
private boolean checkQuotaStorageLimits(QuotaEnforcementTypeEnum quotaEnforcementTypeEnum, Quota quota, double limit, double storageUsagePercentage, double storageRequestPercentage, List<String> canDoActionMessages, Pair<AuditLogType, AuditLogableBase> log) {
    double storageTotalPercentage = storageUsagePercentage + storageRequestPercentage;
    boolean requestIsApproved;
    if (limit == QuotaStorage.UNLIMITED || storageTotalPercentage <= quota.getThresholdStoragePercentage() || storageRequestPercentage <= 0) {
        requestIsApproved = true;
    } else if (storageTotalPercentage <= 100) {
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_THRESHOLD);
        quotaManagerAuditLogger.addCustomValuesStorage(log.getSecond(), quota.getQuotaName(), quota.getId(), storageUsagePercentage + storageRequestPercentage, storageRequestPercentage);
        requestIsApproved = true;
    } else if (storageTotalPercentage <= quota.getGraceStoragePercentage() + 100) {
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_LIMIT);
        quotaManagerAuditLogger.addCustomValuesStorage(log.getSecond(), quota.getQuotaName(), quota.getId(), storageUsagePercentage + storageRequestPercentage, storageRequestPercentage);
        requestIsApproved = true;
    } else {
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT);
        quotaManagerAuditLogger.addCustomValuesStorage(log.getSecond(), quota.getQuotaName(), quota.getId(), storageUsagePercentage, storageRequestPercentage);
        if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == quotaEnforcementTypeEnum) {
            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_STORAGE_LIMIT_EXCEEDED.toString());
            requestIsApproved = false;
        } else {
            requestIsApproved = true;
        }
    }
    if (!requestIsApproved) {
        log.getSecond().setQuotaIdForLog(quota.getId());
    }
    return requestIsApproved;
}
#end_block

#method_before
private boolean checkQuotaClusterLimits(QuotaEnforcementTypeEnum quotaEnforcementTypeEnum, Quota quota, QuotaVdsGroup quotaVdsGroup, long memToAdd, int vcpuToAdd, List<String> canDoActionMessages, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    if (quotaVdsGroup.getVirtualCpu() == 0 || quotaVdsGroup.getMemSizeMB() == 0) {
        return false;
    }
    double vcpuToAddPercentage = (double) vcpuToAdd / (double) quotaVdsGroup.getVirtualCpu() * 100;
    double vcpuCurrentPercentage = (double) quotaVdsGroup.getVirtualCpuUsage() / (double) quotaVdsGroup.getVirtualCpu() * 100;
    double newVcpuPercent = vcpuToAddPercentage + vcpuCurrentPercentage;
    double memToAddPercentage = (double) memToAdd / (double) quotaVdsGroup.getMemSizeMB() * 100;
    double memCurrentPercentage = (double) quotaVdsGroup.getMemSizeMBUsage() / (double) quotaVdsGroup.getMemSizeMB() * 100;
    double newMemoryPercent = memToAddPercentage + memCurrentPercentage;
    long newMemory = memToAdd + quotaVdsGroup.getMemSizeMBUsage();
    int newVcpu = vcpuToAdd + quotaVdsGroup.getVirtualCpuUsage();
    long memLimit = quotaVdsGroup.getMemSizeMB();
    int cpuLimit = quotaVdsGroup.getVirtualCpu();
    boolean requestIsApproved;
    if (memLimit == QuotaVdsGroup.UNLIMITED_MEM && cpuLimit == QuotaVdsGroup.UNLIMITED_VCPU) {
        // if both cpu and
        // mem are unlimited
        requestIsApproved = true;
    } else if ((// if cpu and mem usages are under the limit
    newVcpuPercent <= quota.getThresholdVdsGroupPercentage() && newMemoryPercent <= quota.getThresholdVdsGroupPercentage()) || (vcpuToAdd <= 0 && memToAdd <= 0)) {
        requestIsApproved = true;
    } else if (newVcpuPercent <= 100 && newMemoryPercent <= 100) {
        // passed the threshold (not the quota limit)
        auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_THRESHOLD);
        quotaManagerAuditLogger.addCustomValuesVdsGroup(auditLogPair.getSecond(), quota.getQuotaName(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > quota.getThresholdVdsGroupPercentage(), newMemoryPercent > quota.getThresholdVdsGroupPercentage());
        requestIsApproved = true;
    } else if (newVcpuPercent <= quota.getGraceVdsGroupPercentage() + 100 && newMemoryPercent <= quota.getGraceVdsGroupPercentage() + 100) {
        // passed the quota limit (not the
        // grace)
        auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_LIMIT);
        quotaManagerAuditLogger.addCustomValuesVdsGroup(auditLogPair.getSecond(), quota.getQuotaName(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > 100, newMemoryPercent > 100);
        requestIsApproved = true;
    } else {
        // passed the grace
        auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_GRACE_LIMIT);
        quotaManagerAuditLogger.addCustomValuesVdsGroup(auditLogPair.getSecond(), quota.getQuotaName(), vcpuCurrentPercentage, vcpuToAddPercentage, memCurrentPercentage, memToAddPercentage, newVcpuPercent > quota.getGraceVdsGroupPercentage() + 100, newMemoryPercent > quota.getGraceVdsGroupPercentage() + 100);
        if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == quotaEnforcementTypeEnum) {
            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_VDS_GROUP_LIMIT_EXCEEDED.toString());
            requestIsApproved = false;
        } else {
            requestIsApproved = true;
        }
    }
    // cache
    if (requestIsApproved) {
        cacheNewValues(quotaVdsGroup, newMemory, newVcpu);
    } else {
        auditLogPair.getSecond().setQuotaIdForLog(quota.getId());
    }
    return requestIsApproved;
}
#method_after
private boolean checkQuotaClusterLimits(QuotaEnforcementTypeEnum quotaEnforcementTypeEnum, Quota quota, QuotaVdsGroup quotaVdsGroup, long memToAdd, int vcpuToAdd, List<String> canDoActionMessages, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    if (quotaVdsGroup.getVirtualCpu() == 0 || quotaVdsGroup.getMemSizeMB() == 0) {
        return false;
    }
    double vcpuToAddPercentage = (double) vcpuToAdd / (double) quotaVdsGroup.getVirtualCpu() * 100;
    double vcpuCurrentPercentage = (double) quotaVdsGroup.getVirtualCpuUsage() / (double) quotaVdsGroup.getVirtualCpu() * 100;
    double newVcpuPercent = vcpuToAddPercentage + vcpuCurrentPercentage;
    double memToAddPercentage = (double) memToAdd / (double) quotaVdsGroup.getMemSizeMB() * 100;
    double memCurrentPercentage = (double) quotaVdsGroup.getMemSizeMBUsage() / (double) quotaVdsGroup.getMemSizeMB() * 100;
    double newMemoryPercent = memToAddPercentage + memCurrentPercentage;
    long newMemory = memToAdd + quotaVdsGroup.getMemSizeMBUsage();
    int newVcpu = vcpuToAdd + quotaVdsGroup.getVirtualCpuUsage();
    long memLimit = quotaVdsGroup.getMemSizeMB();
    int cpuLimit = quotaVdsGroup.getVirtualCpu();
    boolean requestIsApproved;
    if (memLimit == QuotaVdsGroup.UNLIMITED_MEM && cpuLimit == QuotaVdsGroup.UNLIMITED_VCPU) {
        // if both cpu and
        // mem are unlimited
        requestIsApproved = true;
    } else if ((// if cpu and mem usages are under the limit
    newVcpuPercent <= quota.getThresholdVdsGroupPercentage() && newMemoryPercent <= quota.getThresholdVdsGroupPercentage()) || (vcpuToAdd <= 0 && memToAdd <= 0)) {
        requestIsApproved = true;
    } else if (newVcpuPercent <= 100 && newMemoryPercent <= 100) {
        // passed the threshold (not the quota limit)
        auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_THRESHOLD);
        quotaManagerAuditLogger.addCustomValuesVdsGroup(auditLogPair.getSecond(), quota.getQuotaName(), quota.getId(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > quota.getThresholdVdsGroupPercentage(), newMemoryPercent > quota.getThresholdVdsGroupPercentage());
        requestIsApproved = true;
    } else if (newVcpuPercent <= quota.getGraceVdsGroupPercentage() + 100 && newMemoryPercent <= quota.getGraceVdsGroupPercentage() + 100) {
        // passed the quota limit (not the
        // grace)
        auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_LIMIT);
        quotaManagerAuditLogger.addCustomValuesVdsGroup(auditLogPair.getSecond(), quota.getQuotaName(), quota.getId(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > 100, newMemoryPercent > 100);
        requestIsApproved = true;
    } else {
        // passed the grace
        auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_GRACE_LIMIT);
        quotaManagerAuditLogger.addCustomValuesVdsGroup(auditLogPair.getSecond(), quota.getQuotaName(), quota.getId(), vcpuCurrentPercentage, vcpuToAddPercentage, memCurrentPercentage, memToAddPercentage, newVcpuPercent > quota.getGraceVdsGroupPercentage() + 100, newMemoryPercent > quota.getGraceVdsGroupPercentage() + 100);
        if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == quotaEnforcementTypeEnum) {
            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_VDS_GROUP_LIMIT_EXCEEDED.toString());
            requestIsApproved = false;
        } else {
            requestIsApproved = true;
        }
    }
    // cache
    if (requestIsApproved) {
        cacheNewValues(quotaVdsGroup, newMemory, newVcpu);
    } else {
        auditLogPair.getSecond().setQuotaIdForLog(quota.getId());
    }
    return requestIsApproved;
}
#end_block

#method_before
protected void setVds(final VDS value) {
    mVds = value;
    mVdsName = null;
}
#method_after
public void setVds(final VDS value) {
    mVds = value;
    mVdsName = null;
    if (value != null) {
        mVdsId = value.getId();
    }
}
#end_block

#method_before
public NGuid getGlusterVolumeId() {
    return glusterVolumeId;
}
#method_after
public NGuid getGlusterVolumeId() {
    return glusterVolumeId != null ? glusterVolumeId : Guid.Empty;
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    // External Events/Alerts
    severities.put(AuditLogType.EXTERNAL_EVENT_NORMAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.EXTERNAL_EVENT_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EXTERNAL_EVENT_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXTERNAL_ALERT, AuditLogSeverity.ALERT);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    // External Events/Alerts
    severities.put(AuditLogType.EXTERNAL_EVENT_NORMAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.EXTERNAL_EVENT_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EXTERNAL_EVENT_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXTERNAL_ALERT, AuditLogSeverity.ALERT);
}
#end_block

#method_before
protected void addCustomValuesStorage(AuditLogableBase auditLogableBase, String quotaName, double storageUsagePercentage, double storageRequestedPercentage) {
    auditLogableBase.addCustomValue("QuotaName", quotaName);
    auditLogableBase.addCustomValue("CurrentStorage", percentageFormatter.format(storageUsagePercentage));
    auditLogableBase.addCustomValue("Requested", percentageFormatter.format(storageRequestedPercentage));
    auditLogableBase.setQuotaNameForLog(quotaName);
}
#method_after
protected void addCustomValuesStorage(AuditLogableBase auditLogableBase, String quotaName, Guid quotaId, double storageUsagePercentage, double storageRequestedPercentage) {
    auditLogableBase.addCustomValue("QuotaName", quotaName);
    auditLogableBase.addCustomValue("CurrentStorage", percentageFormatter.format(storageUsagePercentage));
    auditLogableBase.addCustomValue("Requested", percentageFormatter.format(storageRequestedPercentage));
    auditLogableBase.setQuotaNameForLog(quotaName);
    auditLogableBase.setQuotaIdForLog(quotaId);
}
#end_block

#method_before
protected void addCustomValuesVdsGroup(AuditLogableBase auditLogableBase, String quotaName, double cpuCurrentPercentage, double cpuRequestPercentage, double memCurrentPercentage, double memRequestPercentage, boolean cpuOverLimit, boolean memOverLimit) {
    auditLogableBase.addCustomValue("QuotaName", quotaName);
    StringBuilder currentUtilization = new StringBuilder();
    if (cpuOverLimit) {
        currentUtilization.append("vcpu:").append(percentageFormatter.format(cpuCurrentPercentage)).append("% ");
    }
    if (memOverLimit) {
        currentUtilization.append("mem:").append(percentageFormatter.format(memCurrentPercentage)).append("%");
    }
    StringBuilder request = new StringBuilder();
    if (cpuOverLimit) {
        request.append("vcpu:").append(percentageFormatter.format(cpuRequestPercentage)).append("% ");
    }
    if (memOverLimit) {
        request.append("mem:").append(percentageFormatter.format(memRequestPercentage)).append("%");
    }
    auditLogableBase.addCustomValue("Utilization", currentUtilization.toString());
    auditLogableBase.addCustomValue("Requested", request.toString());
    auditLogableBase.setQuotaNameForLog(quotaName);
}
#method_after
protected void addCustomValuesVdsGroup(AuditLogableBase auditLogableBase, String quotaName, Guid quotaId, double cpuCurrentPercentage, double cpuRequestPercentage, double memCurrentPercentage, double memRequestPercentage, boolean cpuOverLimit, boolean memOverLimit) {
    auditLogableBase.addCustomValue("QuotaName", quotaName);
    StringBuilder currentUtilization = new StringBuilder();
    if (cpuOverLimit) {
        currentUtilization.append("vcpu:").append(percentageFormatter.format(cpuCurrentPercentage)).append("% ");
    }
    if (memOverLimit) {
        currentUtilization.append("mem:").append(percentageFormatter.format(memCurrentPercentage)).append("%");
    }
    StringBuilder request = new StringBuilder();
    if (cpuOverLimit) {
        request.append("vcpu:").append(percentageFormatter.format(cpuRequestPercentage)).append("% ");
    }
    if (memOverLimit) {
        request.append("mem:").append(percentageFormatter.format(memRequestPercentage)).append("%");
    }
    auditLogableBase.addCustomValue("Utilization", currentUtilization.toString());
    auditLogableBase.addCustomValue("Requested", request.toString());
    auditLogableBase.setQuotaNameForLog(quotaName);
    auditLogableBase.setQuotaIdForLog(quotaId);
}
#end_block

#method_before
private void setValues(double limit, double consumedByOthers, double consumedByUser) {
    int othersConsumptionPercent = (int) Math.round(consumedByOthers * 100 / limit);
    int userConsumptionPercent = (int) Math.round(consumedByUser * 100 / limit);
    double free = limit - consumedByOthers - consumedByUser;
    if (limit == UNLIMITED) {
        // unlimited
        setUnlimited();
    } else if (consumedByOthers + consumedByUser == 0) {
        // empty
        setZeroValue();
    } else if (consumedByOthers + consumedByUser > limit) {
        // exceeded
        setExceeded();
    } else {
        percentageBarA.setStyleName(style.percentageBarA());
        percentageLabelA.setStyleName(style.percentageLabelBlack());
        percentageBarB.setVisible(true);
        setValueA(othersConsumptionPercent);
        setValueB(userConsumptionPercent);
        setBars();
    }
}
#method_after
protected void setValues(double limit, double consumedByOthers, double consumedByUser) {
    int othersConsumptionPercent = (int) Math.round(consumedByOthers * 100 / limit);
    int userConsumptionPercent = (int) Math.round(consumedByUser * 100 / limit);
    if (limit == UNLIMITED) {
        // unlimited
        setUnlimited();
    } else if (consumedByOthers + consumedByUser == 0) {
        // empty
        setZeroValue();
    } else if (consumedByOthers + consumedByUser > limit) {
        // exceeded
        setExceeded();
    } else {
        percentageBarA.setStyleName(style.percentageBarA());
        percentageLabelA.setStyleName(style.percentageLabelBlack());
        percentageBarB.setVisible(true);
        setValueA(othersConsumptionPercent);
        setValueB(userConsumptionPercent);
        setBars();
    }
}
#end_block

#method_before
@Override
public void onMouseOver(MouseOverEvent event) {
    SafeHtml tooltipHtml = getTooltip();
    if (!"".equals(tooltipHtml.asString())) {
        // $NON-NLS-1$
        tooltip.setHTML(getTooltip());
        PopupUtils.adjustPopupLocationToFitScreenAndShow(tooltipPanel, event.getClientX(), event.getClientY() + 20);
    }
}
#method_after
@Override
public void onMouseOver(MouseOverEvent event) {
    SafeHtml tooltipHtml = getTooltip();
    if (!"".equals(tooltipHtml.asString())) {
        // $NON-NLS-1$
        tooltip.setHTML(tooltipHtml);
        PopupUtils.adjustPopupLocationToFitScreenAndShow(tooltipPanel, event.getClientX(), event.getClientY() + 20);
    }
}
#end_block

#method_before
private SafeHtml templateWithLabels(String quota, int totalUsagePercentage, String totalUsage, int usedByYouPercentage, String usedByYou, int usedByOthersPercentage, String usedByOthers, int freePercentage, String free) {
    return templates.quotaForUserBarToolTip(constants.tooltipQuotaLabel(), quota, constants.tooltipTotalUsageLabel(), totalUsagePercentage, totalUsage, constants.youUseQuota(), usedByYouPercentage, usedByYou, constants.othersUseQuota(), usedByOthersPercentage, usedByOthers, constants.freeQuota(), freePercentage, free);
}
#method_after
protected SafeHtml templateWithLabels(String quota, int totalUsagePercentage, String totalUsage, int usedByYouPercentage, String usedByYou, int usedByOthersPercentage, String usedByOthers, int freePercentage, String free) {
    return templates.quotaForUserBarToolTip(constants.tooltipQuotaLabel(), quota, constants.tooltipTotalUsageLabel(), totalUsagePercentage, totalUsage, constants.youUseQuota(), usedByYouPercentage, usedByYou, constants.othersUseQuota(), usedByOthersPercentage, usedByOthers, constants.freeQuota(), freePercentage, free);
}
#end_block

#method_before
private void addQuotaToVcpuQuotaList(QuotaUsagePerUser quotaPerUserUsageEntity) {
    QuotaProgressBar vcpuQuotaProgressBar = new QuotaProgressBar(templates, quotaPerUserUsageEntity, QuotaProgressBar.QuotaType.CPU);
    addQuotaRow(cpusQuotasList, quotaPerUserUsageEntity.getQuotaName(), vcpuQuotaProgressBar);
}
#method_after
private void addQuotaToVcpuQuotaList(QuotaUsagePerUser quotaPerUserUsageEntity) {
    QuotaProgressBar vcpuQuotaProgressBar = new QuotaCPUProgressBar(quotaPerUserUsageEntity);
    addQuotaRow(cpusQuotasList, quotaPerUserUsageEntity.getQuotaName(), vcpuQuotaProgressBar);
}
#end_block

#method_before
private void addQuotaToMemoryQuotaList(QuotaUsagePerUser quotaPerUserUsageEntity) {
    QuotaProgressBar memoryQuotaProgressBar = new QuotaProgressBar(templates, quotaPerUserUsageEntity, QuotaProgressBar.QuotaType.MEM);
    addQuotaRow(memoryQuotasList, quotaPerUserUsageEntity.getQuotaName(), memoryQuotaProgressBar);
}
#method_after
private void addQuotaToMemoryQuotaList(QuotaUsagePerUser quotaPerUserUsageEntity) {
    QuotaProgressBar memoryQuotaProgressBar = new QuotaMemoryProgressBar(quotaPerUserUsageEntity);
    addQuotaRow(memoryQuotasList, quotaPerUserUsageEntity.getQuotaName(), memoryQuotaProgressBar);
}
#end_block

#method_before
private void addQuotaToStorageQuotaList(QuotaUsagePerUser quotaPerUserUsageEntity) {
    QuotaProgressBar storageQuotaProgressBar = new QuotaProgressBar(templates, quotaPerUserUsageEntity, QuotaProgressBar.QuotaType.STORAGE);
    addQuotaRow(storageQuotasList, quotaPerUserUsageEntity.getQuotaName(), storageQuotaProgressBar);
}
#method_after
private void addQuotaToStorageQuotaList(QuotaUsagePerUser quotaPerUserUsageEntity) {
    QuotaProgressBar storageQuotaProgressBar = new QuotaStorageProgressBar(quotaPerUserUsageEntity);
    addQuotaRow(storageQuotasList, quotaPerUserUsageEntity.getQuotaName(), storageQuotaProgressBar);
}
#end_block

#method_before
@Override
protected void SyncSearch() {
    if (getEntity() == null) {
        return;
    }
    super.SyncSearch();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            SearchableListModel searchableListModel = (SearchableListModel) model;
            ArrayList<Network> newItems = (ArrayList<Network>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            Collections.sort(newItems, new Comparator<Network>() {

                private LexoNumericComparator lexoNumeric = new LexoNumericComparator();

                @Override
                public int compare(Network net1, Network net2) {
                    // management first
                    if (net1.getName().equals(HostInterfaceListModel.ENGINE_NETWORK_NAME)) {
                        return -1;
                    } else if (net2.getName().equals(HostInterfaceListModel.ENGINE_NETWORK_NAME)) {
                        return 1;
                    }
                    return lexoNumeric.compare(net1.getName(), net2.getName());
                }
            });
            searchableListModel.setItems(newItems);
        }
    };
    IdQueryParameters tempVar = new IdQueryParameters(getEntity().getId());
    tempVar.setRefresh(getIsQueryFirstTime());
    Frontend.RunQuery(VdcQueryType.GetAllNetworksByClusterId, tempVar, _asyncQuery);
}
#method_after
@Override
protected void SyncSearch() {
    if (getEntity() == null) {
        return;
    }
    super.SyncSearch();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            SearchableListModel searchableListModel = (SearchableListModel) model;
            ArrayList<Network> newItems = (ArrayList<Network>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            Collections.sort(newItems, new Linq.NetworkComparator());
            searchableListModel.setItems(newItems);
        }
    };
    IdQueryParameters tempVar = new IdQueryParameters(getEntity().getId());
    tempVar.setRefresh(getIsQueryFirstTime());
    Frontend.RunQuery(VdcQueryType.GetAllNetworksByClusterId, tempVar, _asyncQuery);
}
#end_block

#method_before
private ClusterNetworkManageModel createNetworkList(List<Network> dcNetworks) {
    List<ClusterNetworkModel> networkList = new ArrayList<ClusterNetworkModel>();
    java.util.ArrayList<Network> clusterNetworks = Linq.<Network>Cast(getItems());
    for (Network network : dcNetworks) {
        ClusterNetworkModel networkManageModel;
        int index = clusterNetworks.indexOf(network);
        if (index >= 0) {
            Network clusterNetwork = clusterNetworks.get(index);
            networkManageModel = new ClusterNetworkModel((Network) Cloner.clone(clusterNetwork));
        } else {
            networkManageModel = new ClusterNetworkModel((Network) Cloner.clone(network));
        }
        networkManageModel.setCluster((VDSGroup) Cloner.clone(getEntity()));
        networkList.add(networkManageModel);
    }
    Collections.sort(networkList, networkComparator);
    ClusterNetworkManageModel listModel = new ClusterNetworkManageModel();
    listModel.setItems(networkList);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    listModel.getCommands().add(cancelCommand);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnManage", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    listModel.getCommands().add(0, okCommand);
    return listModel;
}
#method_after
private ClusterNetworkManageModel createNetworkList(List<Network> dcNetworks) {
    List<ClusterNetworkModel> networkList = new ArrayList<ClusterNetworkModel>();
    java.util.ArrayList<Network> clusterNetworks = Linq.<Network>Cast(getItems());
    for (Network network : dcNetworks) {
        ClusterNetworkModel networkManageModel;
        int index = clusterNetworks.indexOf(network);
        if (index >= 0) {
            Network clusterNetwork = clusterNetworks.get(index);
            networkManageModel = new ClusterNetworkModel((Network) Cloner.clone(clusterNetwork));
        } else {
            networkManageModel = new ClusterNetworkModel((Network) Cloner.clone(network));
        }
        networkManageModel.setCluster((VDSGroup) Cloner.clone(getEntity()));
        networkList.add(networkManageModel);
    }
    Collections.sort(networkList, new Linq.ClusterNetworkModelComparator());
    ClusterNetworkManageModel listModel = new ClusterNetworkManageModel();
    listModel.setItems(networkList);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    listModel.getCommands().add(cancelCommand);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OnManage", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    listModel.getCommands().add(0, okCommand);
    return listModel;
}
#end_block

#method_before
protected void AddVmTemplateImages() {
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getImageId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        createParams.setStorageDomainId(diskImage.getStorageIds().get(0));
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0));
        createParams.setDiskAlias(diskInfoDestinationMap.get(diskImage.getId()).getDiskAlias());
        createParams.setParentParameters(getParameters());
        if (getParameters().getDiskInfoDestinationMap() != null && getParameters().getDiskInfoDestinationMap().get(diskImage.getId()) != null) {
            createParams.setQuotaId(getParameters().getDiskInfoDestinationMap().get(diskImage.getId()).getQuotaId() != null ? getParameters().getDiskInfoDestinationMap().get(diskImage.getId()).getQuotaId() : null);
        } else {
            createParams.setQuotaId(diskImage.getQuotaId());
        }
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
        newDiskImages.add((DiskImage) retValue.getActionReturnValue());
    }
}
#method_after
protected void AddVmTemplateImages() {
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getImageId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        createParams.setStorageDomainId(diskImage.getStorageIds().get(0));
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0));
        createParams.setDiskAlias(diskInfoDestinationMap.get(diskImage.getId()).getDiskAlias());
        createParams.setParentParameters(getParameters());
        createParams.setQuotaId(getQuotaIdForDisk(diskImage));
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
        newDiskImages.add((DiskImage) retValue.getActionReturnValue());
    }
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    Collection<DiskImage> disksList = diskInfoDestinationMap.values().size() > 0 ? diskInfoDestinationMap.values() : getVm().getDiskList();
    for (DiskImage disk : disksList) {
        list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes()));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (DiskImage disk : getVm().getDiskList()) {
        list.add(new QuotaStorageConsumptionParameter(getQuotaIdForDisk(disk), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes()));
    }
    return list;
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command, Object... parameters) {
    super.ExecuteCommand(command);
    if (command == getEditCommand()) {
        Edit();
    } else if (command == getEditManagementNetworkCommand()) {
        EditManagementNetwork();
    } else if (command == getSetupNetworksCommand()) {
        SetupNetworks();
    } else if (command == getBondCommand()) {
        executeBond();
    } else if (command == getDetachCommand()) {
        Detach();
    } else if (command == getSaveNetworkConfigCommand()) {
        SaveNetworkConfig();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnEditManagementNetwork")) {
        OnEditManagementNetwork();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnEditManagementNetworkConfirmation")) {
        OnEditManagementNetworkConfirmation(false);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnEditManagementNetworkConfirmation_Bond")) {
        OnEditManagementNetworkConfirmation(true);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnBond")) {
        OnBond();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnDetach")) {
        OnDetach();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnConfirmManagementDetach")) {
        OnConfirmManagementDetach();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirm")) {
        CancelConfirm();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveNetworkConfig")) {
        OnSaveNetworkConfig();
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command, Object... parameters) {
    super.ExecuteCommand(command);
    if (command == getEditCommand()) {
        Edit();
    } else if (command == getEditManagementNetworkCommand()) {
        EditManagementNetwork();
    } else if (command == getSetupNetworksCommand()) {
        SetupNetworks();
    } else if (command == getBondCommand()) {
        bond();
    } else if (command == getDetachCommand()) {
        Detach();
    } else if (command == getSaveNetworkConfigCommand()) {
        SaveNetworkConfig();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnEditManagementNetwork")) {
        OnEditManagementNetwork();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnEditManagementNetworkConfirmation")) {
        OnEditManagementNetworkConfirmation(false);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnEditManagementNetworkConfirmation_Bond")) {
        OnEditManagementNetworkConfirmation(true);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnBond")) {
        OnBond();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnDetach")) {
        OnDetach();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnConfirmManagementDetach")) {
        OnConfirmManagementDetach();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirm")) {
        CancelConfirm();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveNetworkConfig")) {
        OnSaveNetworkConfig();
    }
}
#end_block

#method_before
@Override
protected void setObjectName(Object object, String name, boolean isSuffix) {
    VmTemplate template = ((ImportTemplateData) object).getTemplate();
    if (isSuffix) {
        template.setName(template.getName() + name);
    } else {
        template.setName(name);
    }
}
#method_after
@Override
protected void setObjectName(Object object, String name) {
    ((ImportTemplateData) object).getTemplate().setName(name);
}
#end_block

#method_before
private void executeImportClone() {
    // TODO: support running numbers (for suffix)
    if (objectsToClone.size() == 0) {
        executeImport();
        return;
    }
    ImportCloneModel entity = new ImportCloneModel();
    Object object = objectsToClone.iterator().next();
    entity.setEntity(object);
    entity.setTitle(ConstantsManager.getInstance().getConstants().importConflictTitle());
    // $NON-NLS-1$
    entity.setHashName("import_conflict");
    // $NON-NLS-1$
    UICommand command = new UICommand("onClone", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    entity.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("closeClone", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    entity.getCommands().add(command);
    setConfirmWindow(entity);
}
#method_after
private void executeImportClone() {
    // TODO: support running numbers (for suffix)
    if (objectsToClone.size() == 0) {
        clearCachedAssignedVmNames();
        executeImport();
        return;
    }
    ImportCloneModel entity = new ImportCloneModel();
    Object object = objectsToClone.iterator().next();
    entity.setEntity(object);
    entity.setTitle(ConstantsManager.getInstance().getConstants().importConflictTitle());
    // $NON-NLS-1$
    entity.setHashName("import_conflict");
    // $NON-NLS-1$
    UICommand command = new UICommand("onClone", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    entity.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("closeClone", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    entity.getCommands().add(command);
    setConfirmWindow(entity);
}
#end_block

#method_before
protected void setObjectName(Object object, String name, boolean isSuffix) {
    VM vm = ((ImportVmData) object).getVm();
    String nameForTheClonedVm = isSuffix ? vm.getName() + name : name;
    vm.setName(nameForTheClonedVm);
    assignedVmNames.add(nameForTheClonedVm);
}
#method_after
private void setObjectName(Object object, String input, boolean isSuffix) {
    String nameForTheClonedVm = isSuffix ? getObjectName(object) + input : input;
    setObjectName(object, nameForTheClonedVm);
    assignedVmNames.add(nameForTheClonedVm);
}
#end_block

#method_before
protected void setObjectName(Object object, String name, boolean isSuffix) {
    VM vm = ((ImportVmData) object).getVm();
    String nameForTheClonedVm = isSuffix ? vm.getName() + name : name;
    vm.setName(nameForTheClonedVm);
    assignedVmNames.add(nameForTheClonedVm);
}
#method_after
protected void setObjectName(Object object, String name) {
    ((ImportVmData) object).getVm().setName(name);
}
#end_block

#method_before
protected IValidation[] getClonedNameValidators(Object object) {
    VM vm = ((ImportVmData) object).getVm();
    final int length = AsyncDataProvider.IsWindowsOsType(vm.getOs()) ? UnitVmModel.WINDOWS_VM_NAME_MAX_LIMIT : UnitVmModel.NON_WINDOWS_VM_NAME_MAX_LIMIT;
    return new IValidation[] { new NotEmptyValidation(), new LengthValidation(length), new I18NNameValidation() {

        @Override
        protected String composeMessage() {
            return ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(length);
        }
    }, new UniqueNameValidator(assignedVmNames) };
}
#method_after
protected IValidation[] getClonedNameValidators(Object object) {
    final int maxClonedNameLength = getMaxClonedNameLength(object);
    return new IValidation[] { new NotEmptyValidation(), new LengthValidation(maxClonedNameLength), new I18NNameValidation() {

        @Override
        protected String composeMessage() {
            return ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(maxClonedNameLength);
        }
    }, new UniqueClonedNameValidator(assignedVmNames) };
}
#end_block

#method_before
protected IValidation[] getClonedAppendedNameValidators(Object object) {
    VM vm = ((ImportVmData) object).getVm();
    final int length = AsyncDataProvider.IsWindowsOsType(vm.getOs()) ? UnitVmModel.WINDOWS_VM_NAME_MAX_LIMIT : UnitVmModel.NON_WINDOWS_VM_NAME_MAX_LIMIT;
    return new IValidation[] { new NotEmptyValidation(), new LengthValidation(length), new I18NNameValidation() {

        @Override
        protected String composeMessage() {
            return ConstantsManager.getInstance().getMessages().newNameWithSuffixCannotContainBlankOrSpecialChars(length);
        }
    }, new UniqueAppendedNameValidator(assignedVmNames) };
}
#method_after
protected IValidation[] getClonedAppendedNameValidators(Object object) {
    final int maxClonedNameLength = getMaxClonedNameLength(object);
    return new IValidation[] { new NotEmptyValidation(), new LengthValidation(maxClonedNameLength), new I18NNameValidation() {

        @Override
        protected String composeMessage() {
            return ConstantsManager.getInstance().getMessages().newNameWithSuffixCannotContainBlankOrSpecialChars(maxClonedNameLength);
        }
    }, new UniqueClonedAppendedNameValidator(assignedVmNames) };
}
#end_block

#method_before
protected void executeImport() {
    clearCachedAssignedVmNames();
    ArrayList<VdcActionParametersBase> prms = new ArrayList<VdcActionParametersBase>();
    for (Object item : importModel.getItems()) {
        VM vm = ((ImportVmData) item).getVm();
        ImportVmParameters prm = new ImportVmParameters(vm, getEntity().getId(), Guid.Empty, importModel.getStoragePool().getId(), ((VDSGroup) importModel.getCluster().getSelectedItem()).getId());
        if (importModel.getClusterQuota().getSelectedItem() != null && importModel.getClusterQuota().getIsAvailable()) {
            prm.setQuotaId(((Quota) importModel.getClusterQuota().getSelectedItem()).getId());
        }
        prm.setForceOverride(true);
        prm.setCopyCollapse((Boolean) ((ImportVmData) item).getCollapseSnapshots().getEntity());
        Map<Guid, Guid> map = new HashMap<Guid, Guid>();
        for (Map.Entry<Guid, Disk> entry : vm.getDiskMap().entrySet()) {
            DiskImage disk = (DiskImage) entry.getValue();
            map.put(disk.getId(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getId());
            disk.setvolumeFormat(AsyncDataProvider.GetDiskVolumeFormat(importModel.getDiskImportData(disk.getId()).getSelectedVolumeType(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getStorageType()));
            disk.setVolumeType(importModel.getDiskImportData(disk.getId()).getSelectedVolumeType());
            if (importModel.getDiskImportData(disk.getId()).getSelectedQuota() != null) {
                disk.setQuotaId(importModel.getDiskImportData(disk.getId()).getSelectedQuota().getId());
            }
        }
        prm.setImageToDestinationDomainMap(map);
        if (((ImportVmData) item).isExistsInSystem() || (Boolean) ((ImportVmData) item).getClone().getEntity()) {
            if (!cloneObjectMap.containsKey(vm.getId())) {
                continue;
            }
            prm.setImportAsNewEntity(true);
            prm.setCopyCollapse(true);
            prm.getVm().setName(((ImportVmData) cloneObjectMap.get(vm.getId())).getVm().getName());
        }
        prms.add(prm);
    }
    importModel.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.ImportVm, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            VmBackupModel vmBackupModel = (VmBackupModel) result.getState();
            vmBackupModel.getWindow().StopProgress();
            vmBackupModel.Cancel();
            ArrayList<VdcReturnValueBase> retVals = (ArrayList<VdcReturnValueBase>) result.getReturnValue();
            if (retVals != null && vmBackupModel.getSelectedItems().size() == retVals.size()) {
                // $NON-NLS-1$
                String importedVms = "";
                int counter = 0;
                boolean toShowConfirmWindow = false;
                for (Object item : vmBackupModel.getSelectedItems()) {
                    VM vm = (VM) item;
                    if (retVals.get(counter) != null && retVals.get(counter).getCanDoAction()) {
                        // $NON-NLS-1$
                        importedVms += vm.getName() + ", ";
                        toShowConfirmWindow = true;
                    }
                    counter++;
                }
                // VM
                if (toShowConfirmWindow) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    vmBackupModel.setConfirmWindow(confirmModel);
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().importVirtualMachinesTitle());
                    // $NON-NLS-1$
                    confirmModel.setHashName("import_virtual_machine");
                    importedVms = StringHelper.trimEnd(importedVms.trim(), ',');
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().importProcessHasBegunForVms(importedVms));
                    UICommand tempVar2 = new // $NON-NLS-1$
                    UICommand(// $NON-NLS-1$
                    "CancelConfirm", vmBackupModel);
                    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                    tempVar2.setIsDefault(true);
                    tempVar2.setIsCancel(true);
                    confirmModel.getCommands().add(tempVar2);
                }
            }
        }
    }, this);
}
#method_after
protected void executeImport() {
    ArrayList<VdcActionParametersBase> prms = new ArrayList<VdcActionParametersBase>();
    for (Object item : importModel.getItems()) {
        VM vm = ((ImportVmData) item).getVm();
        ImportVmParameters prm = new ImportVmParameters(vm, getEntity().getId(), Guid.Empty, importModel.getStoragePool().getId(), ((VDSGroup) importModel.getCluster().getSelectedItem()).getId());
        if (importModel.getClusterQuota().getSelectedItem() != null && importModel.getClusterQuota().getIsAvailable()) {
            prm.setQuotaId(((Quota) importModel.getClusterQuota().getSelectedItem()).getId());
        }
        prm.setForceOverride(true);
        prm.setCopyCollapse((Boolean) ((ImportVmData) item).getCollapseSnapshots().getEntity());
        Map<Guid, Guid> map = new HashMap<Guid, Guid>();
        for (Map.Entry<Guid, Disk> entry : vm.getDiskMap().entrySet()) {
            DiskImage disk = (DiskImage) entry.getValue();
            map.put(disk.getId(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getId());
            disk.setvolumeFormat(AsyncDataProvider.GetDiskVolumeFormat(importModel.getDiskImportData(disk.getId()).getSelectedVolumeType(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getStorageType()));
            disk.setVolumeType(importModel.getDiskImportData(disk.getId()).getSelectedVolumeType());
            if (importModel.getDiskImportData(disk.getId()).getSelectedQuota() != null) {
                disk.setQuotaId(importModel.getDiskImportData(disk.getId()).getSelectedQuota().getId());
            }
        }
        prm.setImageToDestinationDomainMap(map);
        if (((ImportVmData) item).isExistsInSystem() || (Boolean) ((ImportVmData) item).getClone().getEntity()) {
            if (!cloneObjectMap.containsKey(vm.getId())) {
                continue;
            }
            prm.setImportAsNewEntity(true);
            prm.setCopyCollapse(true);
            prm.getVm().setName(((ImportVmData) cloneObjectMap.get(vm.getId())).getVm().getName());
        }
        prms.add(prm);
    }
    importModel.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.ImportVm, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            VmBackupModel vmBackupModel = (VmBackupModel) result.getState();
            vmBackupModel.getWindow().StopProgress();
            vmBackupModel.Cancel();
            ArrayList<VdcReturnValueBase> retVals = (ArrayList<VdcReturnValueBase>) result.getReturnValue();
            if (retVals != null && vmBackupModel.getSelectedItems().size() == retVals.size()) {
                // $NON-NLS-1$
                String importedVms = "";
                int counter = 0;
                boolean toShowConfirmWindow = false;
                for (Object item : vmBackupModel.getSelectedItems()) {
                    VM vm = (VM) item;
                    if (retVals.get(counter) != null && retVals.get(counter).getCanDoAction()) {
                        // $NON-NLS-1$
                        importedVms += vm.getName() + ", ";
                        toShowConfirmWindow = true;
                    }
                    counter++;
                }
                // VM
                if (toShowConfirmWindow) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    vmBackupModel.setConfirmWindow(confirmModel);
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().importVirtualMachinesTitle());
                    // $NON-NLS-1$
                    confirmModel.setHashName("import_virtual_machine");
                    importedVms = StringHelper.trimEnd(importedVms.trim(), ',');
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().importProcessHasBegunForVms(importedVms));
                    UICommand tempVar2 = new // $NON-NLS-1$
                    UICommand(// $NON-NLS-1$
                    "CancelConfirm", vmBackupModel);
                    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                    tempVar2.setIsDefault(true);
                    tempVar2.setIsCancel(true);
                    confirmModel.getCommands().add(tempVar2);
                }
            }
        }
    }, this);
}
#end_block

#method_before
@Override
protected void Cancel() {
    super.Cancel();
    clearCachedAssignedVmNames();
}
#method_after
@Override
protected final void Cancel() {
    super.Cancel();
    clearCachedAssignedVmNames();
}
#end_block

#method_before
public VDSReturnValue runVdsCommand(VDSCommandType commandType, VDSParametersBase parameters) throws VdcBLLException {
    VDSReturnValue returnValue = getBackendResourceManager().RunVdsCommand(commandType, parameters);
    if (!returnValue.getSucceeded()) {
        throw new VdcBLLException(returnValue.getVdsError().getCode(), returnValue.getVdsError().getMessage());
    }
    return returnValue;
}
#method_after
protected VDSReturnValue runVdsCommand(VDSCommandType commandType, VDSParametersBase parameters) throws VdcBLLException {
    VDSReturnValue returnValue = getBackendResourceManager().RunVdsCommand(commandType, parameters);
    if (!returnValue.getSucceeded()) {
        throw new VdcBLLException(returnValue.getVdsError().getCode(), returnValue.getVdsError().getMessage());
    }
    return returnValue;
}
#end_block

#method_before
public String getHelpNote() {
    String s = "\n\n\n" + "### Notes:\n" + "## 1. Passwords: password can be set in interactive mode ie:\n" + "###        engine-config -s PasswordEntry=interactive\n" + "###    or via file with one of the following options:\n" + "###        engine-config -s PasswordEntry --admin-pass-file=/tmp/mypass\n" + "###        engine-config -s PasswordEntry=/tmp/mypass\n" + "### 2. In order for your change(s) to take effect,\n" + "###    restart the oVirt engine service (using: 'service ovirt-engine restart').\n" + "################################################################################\n\n";
    return s;
}
#method_after
public String getHelpNote() {
    return String.format("%n%n%n" + "### Notes:%n" + "### 1. Passwords: password can be set in interactive mode ie:%n" + "###        engine-config -s PasswordEntry=interactive%n" + "###    or via file with one of the following options:%n" + "###        engine-config -s PasswordEntry --admin-pass-file=/tmp/mypass%n" + "###        engine-config -s PasswordEntry=/tmp/mypass%n" + "### 2. In order for your change(s) to take effect,%n" + "###    restart the oVirt engine service (using: 'service ovirt-engine restart').%n" + "################################################################################%n%n");
}
#end_block

#method_before
@Override
public Clusters list() {
    return mapCollection(getBackendCollection(VdcQueryType.GetVdsGroupsByStoragePoolId, new StoragePoolQueryParametersBase(dataCenterId)));
}
#method_after
@Override
public Clusters list() {
    return mapCollection(getVdsGroups());
}
#end_block

#method_before
@Override
@SingleEntityResource
public ClusterResource getClusterSubResource(String id) {
    return inject(new BackendClusterResource(id));
}
#method_after
@Override
@SingleEntityResource
public ClusterResource getClusterSubResource(String id) {
    return inject(new BackendDataCenterClusterResource(this, id));
}
#end_block

#method_before
@Override
public Response add(Cluster cluster) {
    validateParameters(cluster, "name", "dataCenter.name|id");
    validateEnums(Cluster.class, cluster);
    storage_pool pool = getStoragePool(cluster, this);
    VDSGroup entity = map(cluster, map(pool));
    return performCreate(VdcActionType.AddVdsGroup, new VdsGroupOperationParameters(entity), new QueryIdResolver<Guid>(VdcQueryType.GetVdsGroupById, GetVdsGroupByIdParameters.class));
}
#method_after
@Override
public Response add(Cluster cluster) {
    validateParameters(cluster, "name");
    validateEnums(Cluster.class, cluster);
    DataCenter dataCenter = new DataCenter();
    dataCenter.setId(dataCenterId.toString());
    cluster.setDataCenter(dataCenter);
    storage_pool pool = getStoragePool(cluster, this);
    VDSGroup entity = map(cluster, map(pool));
    return performCreate(VdcActionType.AddVdsGroup, new VdsGroupOperationParameters(entity), new QueryIdResolver<Guid>(VdcQueryType.GetVdsGroupById, GetVdsGroupByIdParameters.class));
}
#end_block

#method_before
@Test
public void testRemove() throws Exception {
    setUpGetEntityExpectations();
    setUriInfo(setUpActionExpectations(VdcActionType.RemoveVdsGroup, VdsGroupParametersBase.class, new String[] { "VdsGroupId" }, new Object[] { GUIDS[0] }, true, true));
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#method_after
@Test
public void testRemove() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupsByStoragePoolId, StoragePoolQueryParametersBase.class, new String[] { "StoragePoolId" }, new Object[] { dataCenterId }, setUpVDSGroups(), null);
    setUriInfo(setUpActionExpectations(VdcActionType.RemoveVdsGroup, VdsGroupParametersBase.class, new String[] { "VdsGroupId" }, new Object[] { GUIDS[0] }, true, true));
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#end_block

#method_before
@Test
public void testRemoveNonExistant() throws Exception {
    setUpGetEntityExpectations(NON_EXISTANT_GUID, true);
    control.replay();
    try {
        collection.remove(NON_EXISTANT_GUID.toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        assertNotNull(wae.getResponse());
        assertEquals(404, wae.getResponse().getStatus());
    }
}
#method_after
@Test
public void testRemoveNonExistant() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupsByStoragePoolId, StoragePoolQueryParametersBase.class, new String[] { "StoragePoolId" }, new Object[] { dataCenterId }, setUpVDSGroups(), null);
    control.replay();
    try {
        collection.remove(NON_EXISTANT_GUID.toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        assertNotNull(wae.getResponse());
        assertEquals(404, wae.getResponse().getStatus());
    }
}
#end_block

#method_before
@Test
public void testRemoveCantDo() throws Exception {
    setUpGetEntityExpectations();
    doTestBadRemove(false, true, CANT_DO);
}
#method_after
@Test
public void testRemoveCantDo() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupsByStoragePoolId, StoragePoolQueryParametersBase.class, new String[] { "StoragePoolId" }, new Object[] { dataCenterId }, setUpVDSGroups(), null);
    doTestBadRemove(false, true, CANT_DO);
}
#end_block

#method_before
@Test
public void testRemoveFailed() throws Exception {
    setUpGetEntityExpectations();
    doTestBadRemove(true, false, FAILURE);
}
#method_after
@Test
public void testRemoveFailed() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupsByStoragePoolId, StoragePoolQueryParametersBase.class, new String[] { "StoragePoolId" }, new Object[] { dataCenterId }, setUpVDSGroups(), null);
    doTestBadRemove(true, false, FAILURE);
}
#end_block

#method_before
@Test
public void testAddIncompleteParameters() throws Exception {
    Cluster model = new Cluster();
    model.setName(NAMES[0]);
    setUriInfo(setUpBasicUriExpectations());
    control.replay();
    try {
        collection.add(model);
        fail("expected WebApplicationException on incomplete parameters");
    } catch (WebApplicationException wae) {
        verifyIncompleteException(wae, "Cluster", "add", "dataCenter.name|id");
    }
}
#method_after
@Test
public void testAddIncompleteParameters() throws Exception {
    Cluster model = new Cluster();
    setUriInfo(setUpBasicUriExpectations());
    control.replay();
    try {
        collection.add(model);
        fail("expected WebApplicationException on incomplete parameters");
    } catch (WebApplicationException wae) {
        verifyIncompleteException(wae, "Cluster", "add", "name");
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryStarted();
    } else if (ev.equals(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryComplete();
    } else if (ev.equals(ListModel.SelectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            DataCenter_SelectedItemChanged(sender, args);
        } else if (sender == getTemplate()) {
            Template_SelectedItemChanged(sender, args);
        } else if (sender == getCluster()) {
            Cluster_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getTimeZone()) {
            TimeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            DefaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            OSType_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            FirstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            DisplayProtocol_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            NumOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            CoresPerSocket_EntityChanged(sender, args);
        }
    } else if (ev.equals(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            MemSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            TotalCPUCores_EntityChanged(sender, args);
        } else if (sender == getRunVMOnSpecificHost()) {
            RunVMOnSpecificHost_EntityChanged(sender, args);
        } else if (sender == getDontMigrateVM()) {
            DontMigrateVM_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            IsAutoAssign_EntityChanged(sender, args);
        } else if (sender == getProvisioning()) {
            Provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.SelectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            DataCenter_SelectedItemChanged(sender, args);
        } else if (sender == getTemplate()) {
            Template_SelectedItemChanged(sender, args);
        } else if (sender == getCluster()) {
            Cluster_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getTimeZone()) {
            TimeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            DefaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            OSType_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            FirstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            DisplayProtocol_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            NumOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            CoresPerSocket_EntityChanged(sender, args);
        }
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            MemSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            TotalCPUCores_EntityChanged(sender, args);
        } else if (sender == getRunVMOnSpecificHost()) {
            RunVMOnSpecificHost_EntityChanged(sender, args);
        } else if (sender == getDontMigrateVM()) {
            DontMigrateVM_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            IsAutoAssign_EntityChanged(sender, args);
        } else if (sender == getProvisioning()) {
            Provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        }
    }
}
#end_block

#method_before
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#method_after
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                StorageDomain storage = (StorageDomain) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#end_block

#method_before
@Test
public void testValidNonPatternName() {
    // $NON-NLS-1$
    Assert.assertTrue(new TestablePoolNameValidation().Validate("pool-T4534f").getSuccess());
}
#method_after
@Test
public void testValidNonPatternName() {
    // $NON-NLS-1$
    assertTrue(new TestablePoolNameValidation().Validate("pool-T4534f").getSuccess());
}
#end_block

#method_before
@Test
public void testNonValidNonPatternName() {
    // $NON-NLS-1$
    Assert.assertFalse(new TestablePoolNameValidation().Validate("pool-T453&4f").getSuccess());
}
#method_after
@Test
public void testNonValidNonPatternName() {
    // $NON-NLS-1$
    assertFalse(new TestablePoolNameValidation().Validate("pool-T453&4f").getSuccess());
}
#end_block

#method_before
@Test
public void testNonValidNonPatternName2() {
    // $NON-NLS-1$
    Assert.assertFalse(new TestablePoolNameValidation().Validate("").getSuccess());
}
#method_after
@Test
public void testNonValidNonPatternName2() {
    // $NON-NLS-1$
    assertFalse(new TestablePoolNameValidation().Validate("").getSuccess());
}
#end_block

#method_before
@Test
public void testValidPatternName() {
    // $NON-NLS-1$
    Assert.assertTrue(new TestablePoolNameValidation().Validate("pool-T4534f??".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#method_after
@Test
public void testValidPatternName() {
    // $NON-NLS-1$
    assertTrue(new TestablePoolNameValidation().Validate("pool-T4534f??".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#end_block

#method_before
@Test
public void testValidPatternName2() {
    // $NON-NLS-1$
    Assert.assertTrue(new TestablePoolNameValidation().Validate("pool-T4534f?????rt".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#method_after
@Test
public void testValidPatternName2() {
    // $NON-NLS-1$
    assertTrue(new TestablePoolNameValidation().Validate("pool-T4534f?????rt".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#end_block

#method_before
@Test
public void testValidPatternName3() {
    // $NON-NLS-1$
    Assert.assertTrue(new TestablePoolNameValidation().Validate("??rt".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#method_after
@Test
public void testValidPatternName3() {
    // $NON-NLS-1$
    assertTrue(new TestablePoolNameValidation().Validate("??rt".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#end_block

#method_before
@Test
public void testNonValidPatternName() {
    // $NON-NLS-1$
    Assert.assertFalse(new TestablePoolNameValidation().Validate("???".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#method_after
@Test
public void testNonValidPatternName() {
    // $NON-NLS-1$
    assertFalse(new TestablePoolNameValidation().Validate("???".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#end_block

#method_before
@Test
public void testNonValidPatternName2() {
    // $NON-NLS-1$
    Assert.assertFalse(new TestablePoolNameValidation().Validate("pool-T4534f??r-t??".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#method_after
@Test
public void testNonValidPatternName2() {
    // $NON-NLS-1$
    assertFalse(new TestablePoolNameValidation().Validate("pool-T4534f??r-t??".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#end_block

#method_before
@Test
public void testNonValidPatternName3() {
    // $NON-NLS-1$
    Assert.assertFalse(new TestablePoolNameValidation().Validate("pool-T4534f??rt??asda".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#method_after
@Test
public void testNonValidPatternName3() {
    // $NON-NLS-1$
    assertFalse(new TestablePoolNameValidation().Validate("pool-T4534f??rt??asda".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#end_block

#method_before
@Test
public void testNonValidPatternName4() {
    // $NON-NLS-1$
    Assert.assertFalse(new TestablePoolNameValidation().Validate("??rt??asda".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#method_after
@Test
public void testNonValidPatternName4() {
    // $NON-NLS-1$
    assertFalse(new TestablePoolNameValidation().Validate("??rt??asda".replace('?', VmPool.MASK_CHARACTER)).getSuccess());
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((storage_pool) object).getname();
        }
    });
    clusterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDSGroup) object).getname();
        }
    });
    quotaEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Quota) object).getQuotaName();
        }
    });
    templateEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VmTemplate) object).getname();
        }
    });
    oSTypeEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return object.toString();
        }
    });
    timeZoneEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Entry<String, String>) object).getValue();
        }
    });
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    usbSupportEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return object.toString();
        }
    });
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    // $NON-NLS-1$
    isAutoAssignEditor = new EntityModelRadioButtonEditor("runVmOnHostGroup");
    defaultHostEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDS) object).getVdsName();
        }
    });
    // Resource Allocation
    // $NON-NLS-1$
    provisioningThinEditor = new EntityModelRadioButtonEditor("provisioningGroup");
    // $NON-NLS-1$
    provisioningCloneEditor = new EntityModelRadioButtonEditor("provisioningGroup");
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    secondBootDeviceEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    cdImageEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return (String) object;
        }
    });
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((storage_pool) object).getname();
        }
    });
    clusterEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDSGroup) object).getname();
        }
    });
    quotaEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Quota) object).getQuotaName();
        }
    });
    templateEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VmTemplate) object).getName();
        }
    });
    oSTypeEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return object.toString();
        }
    });
    timeZoneEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Entry<String, String>) object).getValue();
        }
    });
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    usbSupportEditor = new ListModelListBoxEditor<Object>(new EnumRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return object.toString();
        }
    });
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    // $NON-NLS-1$
    isAutoAssignEditor = new EntityModelRadioButtonEditor("runVmOnHostGroup");
    defaultHostEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((VDS) object).getName();
        }
    });
    // Resource Allocation
    // $NON-NLS-1$
    provisioningThinEditor = new EntityModelRadioButtonEditor("provisioningGroup");
    // $NON-NLS-1$
    provisioningCloneEditor = new EntityModelRadioButtonEditor("provisioningGroup");
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    secondBootDeviceEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((EntityModel) object).getTitle();
        }
    });
    cdImageEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return (String) object;
        }
    });
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setDomain(entity.getDomain());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOs(entity.getOs());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    entity.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setDomain(entity.getDomain());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOs(entity.getOs());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    entity.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setVmName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setVmtGuid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setOs(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setDomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.setTimeZone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setVmName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setVmtGuid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setOs(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setDomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.setTimeZone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getVmName());
    model.setDescription(entity.getVmDescription());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getVmOs() != null || entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getVmOs() != null) {
            OsType osType = VmMapper.map(entity.getOs(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        if (entity.getVmIp() != null && !entity.getVmIp().isEmpty()) {
            model.setGuestInfo(new GuestInfo());
            model.getGuestInfo().setIps(new IPs());
            for (String item : entity.getVmIp().split(" ")) {
                if (!item.equals("")) {
                    IP ip = new IP();
                    ip.setAddress(item.trim());
                    model.getGuestInfo().getIps().getIPs().add(ip);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.getTimeZone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getVmName());
    model.setDescription(entity.getVmDescription());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getVmOs() != null || entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getVmOs() != null) {
            OsType osType = VmMapper.map(entity.getOs(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        if (entity.getVmIp() != null && !entity.getVmIp().isEmpty()) {
            model.setGuestInfo(new GuestInfo());
            model.getGuestInfo().setIps(new IPs());
            for (String item : entity.getVmIp().split(" ")) {
                if (!item.equals("")) {
                    IP ip = new IP();
                    ip.setAddress(item.trim());
                    model.getGuestInfo().getIps().getIPs().add(ip);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.getTimeZone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#end_block

#method_before
@Test
public void testPreview() {
    setUriInfo(setUpBasicUriExpectations());
    setUpTryBackExpectations();
    control.replay();
    resource.preview(new Action());
}
#method_after
@Test
public void testPreview() throws Exception {
    setUriInfo(setUpActionExpectations(VdcActionType.TryBackToAllSnapshotsOfVm, TryBackToAllSnapshotsOfVmParameters.class, new String[] { "VmId", "DstSnapshotId" }, new Object[] { VM_ID, SNAPSHOT_ID }, asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished))));
    Response response = resource.preview(new Action());
    verifyActionResponse(response);
    Action action = (Action) response.getEntity();
    assertTrue(action.isSetStatus());
    assertEquals(CreationStatus.COMPLETE.value(), action.getStatus().getState());
}
#end_block

#method_before
@Test
public void testUndo() {
    setUriInfo(setUpBasicUriExpectations());
    setUpRestoreExpectations();
    control.replay();
    resource.undo(new Action());
}
#method_after
@Test
public void testUndo() throws Exception {
    setUriInfo(setUpActionExpectations(VdcActionType.RestoreAllSnapshots, RestoreAllSnapshotsParameters.class, new String[] { "VmId", "DstSnapshotId" }, new Object[] { VM_ID, SNAPSHOT_ID }, asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished))));
    Response response = resource.undo(new Action());
    verifyActionResponse(response);
    Action action = (Action) response.getEntity();
    assertTrue(action.isSetStatus());
    assertEquals(CreationStatus.COMPLETE.value(), action.getStatus().getState());
}
#end_block

#method_before
@Test
public void testCommit() {
    setUriInfo(setUpBasicUriExpectations());
    setUpRestoreExpectations();
    control.replay();
    resource.commit(new Action());
}
#method_after
@Test
public void testCommit() throws Exception {
    setUriInfo(setUpActionExpectations(VdcActionType.RestoreAllSnapshots, RestoreAllSnapshotsParameters.class, new String[] { "VmId", "DstSnapshotId" }, new Object[] { VM_ID, SNAPSHOT_ID }, asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished))));
    Response response = resource.commit(new Action());
    verifyActionResponse(response);
    Action action = (Action) response.getEntity();
    assertTrue(action.isSetStatus());
    assertEquals(CreationStatus.COMPLETE.value(), action.getStatus().getState());
}
#end_block

#method_before
@Override
public Response undo(Action action) {
    action.setAsync(false);
    RestoreAllSnapshotsParameters restoreParams = new RestoreAllSnapshotsParameters(parentId, guid);
    Response response = doAction(VdcActionType.RestoreAllSnapshots, restoreParams, action, PollingType.JOB);
    return response;
}
#method_after
@Override
public Response undo(Action action) {
    RestoreAllSnapshotsParameters restoreParams = new RestoreAllSnapshotsParameters(parentId, guid);
    Response response = doAction(VdcActionType.RestoreAllSnapshots, restoreParams, action);
    return response;
}
#end_block

#method_before
@Override
public Response commit(Action action) {
    action.setAsync(false);
    RestoreAllSnapshotsParameters restoreParams = new RestoreAllSnapshotsParameters(parentId, guid);
    Response response = doAction(VdcActionType.RestoreAllSnapshots, restoreParams, action, PollingType.JOB);
    return response;
}
#method_after
@Override
public Response commit(Action action) {
    RestoreAllSnapshotsParameters restoreParams = new RestoreAllSnapshotsParameters(parentId, guid);
    Response response = doAction(VdcActionType.RestoreAllSnapshots, restoreParams, action);
    return response;
}
#end_block

#method_before
@Override
public Response preview(Action action) {
    action.setAsync(false);
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(parentId, guid);
    Response response = doAction(VdcActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action, PollingType.JOB);
    return response;
}
#method_after
@Override
public Response preview(Action action) {
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(parentId, guid);
    Response response = doAction(VdcActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action);
    return response;
}
#end_block

#method_before
protected VmTemplate getEntity() {
    for (VmTemplate entity : parent.getEntitiesFromExportDomain()) {
        if (guid.equals(entity.getId())) {
            return entity;
        }
    }
    return entityNotFound();
}
#method_after
protected VmTemplate getEntity() {
    if (template != null) {
        return template;
    }
    for (VmTemplate entity : parent.getEntitiesFromExportDomain()) {
        if (guid.equals(entity.getId())) {
            template = entity;
            return entity;
        }
    }
    return entityNotFound();
}
#end_block

#method_before
@Override
public ReadOnlyDevicesResource getDisksResource() {
    return inject(new BackendExportDomainTemplateDisksResource(this, guid));
}
#method_after
@Override
public StorageDomainContentDisksResource getDisksResource() {
    return inject(new BackendExportDomainDisksResource(this));
}
#end_block

#method_before
@Override
public BackendExportDomainVmDisksResource getDisksResource() {
    return inject(new BackendExportDomainVmDisksResource(this, guid));
}
#method_after
@Override
public StorageDomainContentDisksResource getDisksResource() {
    return inject(new BackendExportDomainDisksResource(this));
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VM getEntity() {
    for (org.ovirt.engine.core.common.businessentities.VM entity : parent.getEntitiesFromExportDomain()) {
        if (guid.equals(entity.getId())) {
            return entity;
        }
    }
    return entityNotFound();
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VM getEntity() {
    if (vm != null) {
        return vm;
    }
    for (org.ovirt.engine.core.common.businessentities.VM entity : parent.getEntitiesFromExportDomain()) {
        if (guid.equals(entity.getId())) {
            vm = entity;
            return entity;
        }
    }
    return entityNotFound();
}
#end_block

