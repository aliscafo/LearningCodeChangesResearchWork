1514
#method_before
public Integer unresolvedCommentCount() throws OrmException {
    if (unresolvedCommentCount == null) {
        if (!lazyLoad) {
            return null;
        }
        List<Comment> comments = Stream.concat(publishedComments().stream(), robotComments().stream()).collect(toList());
        Set<String> nonLeafSet = new HashSet<>();
        for (Comment c : comments) {
            if (c.parentUuid != null) {
                nonLeafSet.add(c.parentUuid);
            }
        }
        Long count = comments.stream().filter(c -> (c.unresolved == Boolean.TRUE && !nonLeafSet.contains(c.key.uuid))).count();
        unresolvedCommentCount = count.intValue();
    }
    return unresolvedCommentCount;
}
#method_after
public Integer unresolvedCommentCount() throws OrmException {
    if (unresolvedCommentCount == null) {
        if (!lazyLoad) {
            return null;
        }
        List<Comment> comments = Stream.concat(publishedComments().stream(), robotComments().stream()).collect(toList());
        Set<String> nonLeafSet = comments.stream().map(c -> c.parentUuid).collect(Collectors.toSet());
        Long count = comments.stream().filter(c -> (c.unresolved == Boolean.TRUE && !nonLeafSet.contains(c.key.uuid))).count();
        unresolvedCommentCount = count.intValue();
    }
    return unresolvedCommentCount;
}
#end_block

#method_before
@Override
public BinaryResult apply(RevisionResource rsrc) throws RestApiException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null && format.equals("tgz")) {
        // Always allow tgz, even when the allowedFormats doesn't contain it.
        // Then we allow at least one format even if the list of allowed
        // formats is empty.
        f = ArchiveFormat.TGZ;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + Submit.status(change));
    }
    ChangeControl control = rsrc.getControl();
    if (!control.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    try (BinaryResult b = getBundles(rsrc, f)) {
        b.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return b;
    } catch (OrmException | IOException e) {
        throw new RestApiException("Error generating submit preview");
    }
}
#method_after
@Override
public BinaryResult apply(RevisionResource rsrc) throws OrmException, RestApiException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null && format.equals("tgz")) {
        // Always allow tgz, even when the allowedFormats doesn't contain it.
        // Then we allow at least one format even if the list of allowed
        // formats is empty.
        f = ArchiveFormat.TGZ;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + Submit.status(change));
    }
    ChangeControl control = rsrc.getControl();
    if (!control.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    return getBundles(rsrc, f);
}
#end_block

#method_before
private BinaryResult getBundles(RevisionResource rsrc, final ArchiveFormat f) throws OrmException, RestApiException {
    ReviewDb db = dbProvider.get();
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    BinaryResult bin;
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        final MergeOpRepoManager orm = op.getMergeOpRepoManager();
        final Set<Project.NameKey> projects = op.getAllProjects();
        bin = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try (ArchiveOutputStream aos = f.createArchiveOutputStream(out)) {
                    for (Project.NameKey p : projects) {
                        OpenRepo or = orm.getRepo(p);
                        BundleWriter bw = new BundleWriter(or.getRepo());
                        bw.setObjectCountCallback(null);
                        bw.setPackConfig(null);
                        Collection<ReceiveCommand> refs = or.getUpdate().getRefUpdates();
                        for (ReceiveCommand r : refs) {
                            bw.include(r.getRefName(), r.getNewId());
                            ObjectId oldId = r.getOldId();
                            if (!oldId.equals(ObjectId.zeroId())) {
                                bw.assume(or.getCodeReviewRevWalk().parseCommit(oldId));
                            }
                        }
                        // This naming scheme cannot produce directory/file conflicts
                        // as no projects contains ".git/":
                        String path = p.get() + ".git";
                        LimitedByteArrayOutputStream bos = new LimitedByteArrayOutputStream(maxBundleSize, 1024);
                        bw.writeBundle(NullProgressMonitor.INSTANCE, bos);
                        f.putEntry(aos, path, bos.toByteArray());
                    }
                } catch (NoSuchProjectException e) {
                    throw new IOException(e);
                } catch (LimitExceededException e) {
                    throw new NotImplementedException("The bundle is too big to " + "generate at the server");
                }
            }
        };
    }
    return bin;
}
#method_after
private BinaryResult getBundles(RevisionResource rsrc, ArchiveFormat f) throws OrmException, RestApiException {
    ReviewDb db = dbProvider.get();
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    final MergeOp op = mergeOpProvider.get();
    try {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        BinaryResult bin = new SubmitPreviewResult(op, f, maxBundleSize);
        bin.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return bin;
    } catch (OrmException | RestApiException | RuntimeException e) {
        op.close();
        throw e;
    }
}
#end_block

#method_before
@Override
public void close() {
    for (OpenRepo repo : openRepos.values()) {
        repo.close();
    }
}
#method_after
@Override
public void close() {
    for (OpenRepo repo : openRepos.values()) {
        repo.close();
    }
    openRepos.clear();
}
#end_block

#method_before
private void createSubmoduleCommitMsg(StringBuilder msgbuf, SubmoduleSubscription s, OpenRepo subOr, RevCommit newCommit, RevCommit oldCommit) throws SubmoduleException {
    msgbuf.append("* Update " + s.getPath());
    msgbuf.append(" from branch '" + s.getSubmodule().getShortName() + "'");
    // newly created submodule gitlink, do not append whole history
    if (oldCommit == null) {
        return;
    }
    try {
        subOr.rw.resetRetain(subOr.canMergeFlag);
        subOr.rw.markStart(newCommit);
        subOr.rw.markUninteresting(oldCommit);
        for (RevCommit c : subOr.rw) {
            subOr.rw.parseBody(c);
            if (verboseSuperProject == VerboseSuperprojectUpdate.SUBJECT_ONLY) {
                msgbuf.append("\n  - " + c.getShortMessage());
            } else if (verboseSuperProject == VerboseSuperprojectUpdate.TRUE) {
                msgbuf.append("\n  - " + c.getFullMessage().replace("\n", "\n    "));
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
    }
}
#method_after
private void createSubmoduleCommitMsg(StringBuilder msgbuf, SubmoduleSubscription s, OpenRepo subOr, RevCommit newCommit, RevCommit oldCommit) throws SubmoduleException {
    msgbuf.append("* Update " + s.getPath());
    msgbuf.append(" from branch '" + s.getSubmodule().getShortName() + "'");
    // newly created submodule gitlink, do not append whole history
    if (oldCommit == null) {
        return;
    }
    try {
        subOr.rw.resetRetain(subOr.canMergeFlag);
        subOr.rw.markStart(newCommit);
        subOr.rw.markUninteresting(oldCommit);
        for (RevCommit c : subOr.rw) {
            subOr.rw.parseBody(c);
            if (verboseSuperProject == VerboseSuperprojectUpdate.SUBJECT_ONLY) {
                msgbuf.append("\n  - " + c.getShortMessage());
            } else if (verboseSuperProject == VerboseSuperprojectUpdate.TRUE) {
                msgbuf.append("\n  - " + c.getFullMessage().replace("\n", "\n    "));
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not perform a revwalk to create superproject commit message", e);
    }
}
#end_block

#method_before
public static void checkSubmitRule(ChangeData cd) throws ResourceConflictException, OrmException {
    PatchSet patchSet = cd.currentPatchSet();
    if (patchSet == null) {
        throw new ResourceConflictException("missing current patch set for change " + cd.getId());
    }
    List<SubmitRecord> results = getSubmitRecords(cd);
    if (SubmitRecord.findOkRecord(results).isPresent()) {
        // Rules supplied a valid solution.
        return;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("SubmitRuleEvaluator.evaluate for change %s " + "returned empty list for %s in %s", cd.getId(), patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException("submit rule error: " + record.errorMessage);
            case NOT_READY:
                throw new ResourceConflictException(describeLabels(cd, record.labels));
            case FORCED:
            case OK:
            default:
                throw new IllegalStateException(String.format("Unexpected SubmitRecord status %s for %s in %s", record.status, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#method_after
public static void checkSubmitRule(ChangeData cd) throws ResourceConflictException, OrmException {
    PatchSet patchSet = cd.currentPatchSet();
    if (patchSet == null) {
        throw new ResourceConflictException("missing current patch set for change " + cd.getId());
    }
    List<SubmitRecord> results = getSubmitRecords(cd);
    if (SubmitRecord.findOkRecord(results).isPresent()) {
        // Rules supplied a valid solution.
        return;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("SubmitRuleEvaluator.evaluate for change %s returned empty list for %s in %s", cd.getId(), patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException("submit rule error: " + record.errorMessage);
            case NOT_READY:
                throw new ResourceConflictException(describeLabels(cd, record.labels));
            case FORCED:
            case OK:
            default:
                throw new IllegalStateException(String.format("Unexpected SubmitRecord status %s for %s in %s", record.status, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#end_block

#method_before
private OpenRepo openRepo(Project.NameKey project) throws IntegrationException {
    try {
        return orm.getRepo(project);
    } catch (NoSuchProjectException e) {
        logWarn("Project " + project + " no longer exists, " + "abandoning open changes.");
        abandonAllOpenChangeForDeletedProject(project);
    } catch (IOException e) {
        throw new IntegrationException("Error opening project " + project, e);
    }
    return null;
}
#method_after
private OpenRepo openRepo(Project.NameKey project) throws IntegrationException {
    try {
        return orm.getRepo(project);
    } catch (NoSuchProjectException e) {
        logWarn("Project " + project + " no longer exists, abandoning open changes.");
        abandonAllOpenChangeForDeletedProject(project);
    } catch (IOException e) {
        throw new IntegrationException("Error opening project " + project, e);
    }
    return null;
}
#end_block

#method_before
@Override
public BinaryResult apply(RevisionResource rsrc) throws RestApiException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null && format.equals("tgz")) {
        // Always allow tgz, even when the allowedFormats doesn't contain it.
        // Then we allow at least one format even if the list of allowed
        // formats is empty.
        f = ArchiveFormat.TGZ;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + Submit.status(change));
    }
    ChangeControl control = rsrc.getControl();
    if (!control.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    return getBundles(rsrc, f);
}
#method_after
@Override
public BinaryResult apply(RevisionResource rsrc) throws OrmException, RestApiException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null && format.equals("tgz")) {
        // Always allow tgz, even when the allowedFormats doesn't contain it.
        // Then we allow at least one format even if the list of allowed
        // formats is empty.
        f = ArchiveFormat.TGZ;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + Submit.status(change));
    }
    ChangeControl control = rsrc.getControl();
    if (!control.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    return getBundles(rsrc, f);
}
#end_block

#method_before
private BinaryResult getBundles(RevisionResource rsrc, ArchiveFormat f) throws RestApiException {
    ReviewDb db = dbProvider.get();
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    final MergeOp op = mergeOpProvider.get();
    try {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        BinaryResult bin = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try (ArchiveOutputStream aos = f.createArchiveOutputStream(out)) {
                    MergeOpRepoManager orm = op.getMergeOpRepoManager();
                    for (Project.NameKey p : op.getAllProjects()) {
                        OpenRepo or = orm.getRepo(p);
                        BundleWriter bw = new BundleWriter(or.getRepo());
                        bw.setObjectCountCallback(null);
                        bw.setPackConfig(null);
                        Collection<ReceiveCommand> refs = or.getUpdate().getRefUpdates();
                        for (ReceiveCommand r : refs) {
                            bw.include(r.getRefName(), r.getNewId());
                            ObjectId oldId = r.getOldId();
                            if (!oldId.equals(ObjectId.zeroId())) {
                                bw.assume(or.getCodeReviewRevWalk().parseCommit(oldId));
                            }
                        }
                        LimitedByteArrayOutputStream bos = new LimitedByteArrayOutputStream(maxBundleSize, 1024);
                        bw.writeBundle(NullProgressMonitor.INSTANCE, bos);
                        // This naming scheme cannot produce directory/file conflicts
                        // as no projects contains ".git/":
                        String path = p.get() + ".git";
                        f.putEntry(aos, path, bos.toByteArray());
                    }
                } catch (LimitExceededException e) {
                    throw new NotImplementedException("The bundle is too big to generate at the server");
                } finally {
                    op.close();
                }
            }
        };
        bin.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return bin;
    } catch (OrmException e) {
        op.close();
        throw new RestApiException("Error generating submit preview", e);
    }
}
#method_after
private BinaryResult getBundles(RevisionResource rsrc, ArchiveFormat f) throws OrmException, RestApiException {
    ReviewDb db = dbProvider.get();
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    final MergeOp op = mergeOpProvider.get();
    try {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        BinaryResult bin = new SubmitPreviewResult(op, f, maxBundleSize);
        bin.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return bin;
    } catch (OrmException | RestApiException | RuntimeException e) {
        op.close();
        throw e;
    }
}
#end_block

#method_before
@Override
public void close() {
    for (OpenRepo repo : openRepos.values()) {
        repo.close();
    }
}
#method_after
@Override
public void close() {
    for (OpenRepo repo : openRepos.values()) {
        repo.close();
    }
    openRepos.clear();
}
#end_block

#method_before
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        bu.addChangeEditMutationOp(notes.getChangeId());
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator).setUpdateRef(false);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#method_after
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        bu.addOp(notes.getChangeId(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws Exception {
                // return pseudo dirty state to trigger reindexing
                return true;
            }
        });
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator).setUpdateRef(false);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#end_block

#method_before
@Test
public void invalidRange() throws Exception {
    String changeId = createChange().getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(changeId).addReviewer(in);
    sender.clear();
    ReviewInput review = new ReviewInput();
    ReviewInput.CommentInput comment = new ReviewInput.CommentInput();
    comment.range = new Range();
    comment.range.startLine = 1;
    comment.range.endLine = 1;
    comment.range.startCharacter = -1;
    comment.range.endCharacter = 0;
    comment.path = PushOneCommit.FILE_NAME;
    comment.side = Side.REVISION;
    comment.message = "comment 1";
    review.comments = new HashMap<>();
    review.comments.put(comment.path, Lists.newArrayList(comment));
    exception.expect(BadRequestException.class);
    gApi.changes().id(changeId).current().review(review);
}
#method_after
@Test
public void invalidRange() throws Exception {
    String changeId = createChange().getChangeId();
    ReviewInput review = new ReviewInput();
    ReviewInput.CommentInput comment = new ReviewInput.CommentInput();
    comment.range = new Range();
    comment.range.startLine = 1;
    comment.range.endLine = 1;
    comment.range.startCharacter = -1;
    comment.range.endCharacter = 0;
    comment.path = PushOneCommit.FILE_NAME;
    comment.side = Side.REVISION;
    comment.message = "comment 1";
    review.comments = ImmutableMap.of(comment.path, Lists.newArrayList(comment));
    exception.expect(BadRequestException.class);
    gApi.changes().id(changeId).current().review(review);
}
#end_block

#method_before
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">" + "\n");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    // Dummy 0 approval on the change to block vote copying to this patch set.
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#method_after
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">\n");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    // Dummy 0 approval on the change to block vote copying to this patch set.
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#end_block

#method_before
@Test
public void checkLabelsForMergedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified", 0, 1);
    // ignore the new label by Prolog submit rule and assert that the label is
    // no longer returned
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Ignore Verified", "rules.pl", "submit_rule(submit(CR)) :-\n" + "  gerrit:max_with_block(-2, 2, 'Code-Review', CR).");
    push2.to(RefNames.REFS_CONFIG);
    change = gApi.changes().id(r.getChangeId()).get();
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // add an approval on the new label and assert that the label is now
    // returned although it is ignored by the Prolog submit rule and hence not
    // included in the submit records
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
}
#method_after
@Test
public void checkLabelsForMergedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified", 0, 1);
    // ignore the new label by Prolog submit rule and assert that the label is
    // no longer returned
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Ignore Verified", "rules.pl", "submit_rule(submit(CR)) :-\n  gerrit:max_with_block(-2, 2, 'Code-Review', CR).");
    push2.to(RefNames.REFS_CONFIG);
    change = gApi.changes().id(r.getChangeId()).get();
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // add an approval on the new label and assert that the label is now
    // returned although it is ignored by the Prolog submit rule and hence not
    // included in the submit records
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
}
#end_block

#method_before
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> commentsPerPath) throws BadRequestException, OrmException {
    ensureCommentsAreAddable(revision, commentsPerPath);
    for (Map.Entry<String, List<T>> e : commentsPerPath.entrySet()) {
        for (T comment : e.getValue()) {
            ensureRangeIsValid(e.getKey(), comment.range);
        }
    }
}
#method_after
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> commentsPerPath) throws OrmException, BadRequestException {
    Set<String> revisionFilePaths = getAffectedFilePaths(revision);
    for (Map.Entry<String, List<T>> entry : commentsPerPath.entrySet()) {
        String path = entry.getKey();
        PatchSet.Id patchSetId = revision.getChange().currentPatchSetId();
        ensurePathRefersToAvailableOrMagicFile(path, revisionFilePaths, patchSetId);
        List<T> comments = entry.getValue();
        for (T comment : comments) {
            ensureLineIsNonNegative(comment.line, path);
            ensureCommentNotOnMagicFilesOfAutoMerge(path, comment);
            ensureRangeIsValid(path, comment.range);
        }
    }
}
#end_block

#method_before
private void checkRobotComments(RevisionResource revision, Map<String, List<RobotCommentInput>> in) throws BadRequestException, OrmException {
    for (Map.Entry<String, List<RobotCommentInput>> e : in.entrySet()) {
        String commentPath = e.getKey();
        for (RobotCommentInput c : e.getValue()) {
            ensureRobotIdIsSet(c.robotId, commentPath);
            ensureRobotRunIdIsSet(c.robotRunId, commentPath);
            ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath);
        }
    }
    cleanUpComments(in);
    checkComments(revision, in);
}
#method_after
private void checkRobotComments(RevisionResource revision, Map<String, List<RobotCommentInput>> in) throws BadRequestException, OrmException {
    cleanUpComments(in);
    for (Map.Entry<String, List<RobotCommentInput>> e : in.entrySet()) {
        String commentPath = e.getKey();
        for (RobotCommentInput c : e.getValue()) {
            ensureRobotIdIsSet(c.robotId, commentPath);
            ensureRobotRunIdIsSet(c.robotRunId, commentPath);
            ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath);
        }
    }
    checkComments(revision, in);
}
#end_block

#method_before
private void ensureDescriptionIsSet(String commentPath, String description) throws BadRequestException {
    if (description == null) {
        throw new BadRequestException(String.format("A description is required " + "for the suggested fix of the robot comment on %s", commentPath));
    }
}
#method_after
private void ensureDescriptionIsSet(String commentPath, String description) throws BadRequestException {
    if (description == null) {
        throw new BadRequestException(String.format("A description is required for the suggested fix of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureReplacementPathIsSet(String commentPath, String replacementPath) throws BadRequestException {
    if (replacementPath == null) {
        throw new BadRequestException(String.format("A file path must be given " + "for the replacement of the robot comment on %s", commentPath));
    }
}
#method_after
private void ensureReplacementPathIsSet(String commentPath, String replacementPath) throws BadRequestException {
    if (replacementPath == null) {
        throw new BadRequestException(String.format("A file path must be given for the replacement of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureRangeIsSet(String commentPath, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        throw new BadRequestException(String.format("A range must be given " + "for the replacement of the robot comment on %s", commentPath));
    }
}
#method_after
private void ensureRangeIsSet(String commentPath, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        throw new BadRequestException(String.format("A range must be given for the replacement of the robot comment on %s", commentPath));
    }
}
#end_block

#method_before
private void ensureRangeIsValid(String commentPath, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        return;
    }
    if (!range.isValid()) {
        throw new BadRequestException(String.format("Range (%s:%s - %s:%s) is not" + " valid for the comment on %s", range.startLine, range.startCharacter, range.endLine, range.endCharacter, commentPath));
    }
}
#method_after
private void ensureRangeIsValid(String commentPath, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        return;
    }
    if (!range.isValid()) {
        throw new BadRequestException(String.format("Range (%s:%s - %s:%s) is not valid for the comment on %s", range.startLine, range.startCharacter, range.endLine, range.endCharacter, commentPath));
    }
}
#end_block

#method_before
private int search(final String fileName) {
    if (Patch.COMMIT_MSG.equals(fileName)) {
        return 0;
    }
    if (isMerge && Patch.MERGE_LIST.equals(fileName)) {
        return 1;
    }
    PatchListEntry want = PatchListEntry.empty(fileName);
    return Arrays.binarySearch(patches, isMerge ? 2 : 1, patches.length, want, PATCH_CMP);
}
#method_after
private int search(final String fileName) {
    PatchListEntry want = PatchListEntry.empty(fileName);
    return Arrays.binarySearch(patches, 0, patches.length, want, PATCH_CMP);
}
#end_block

#method_before
@Override
protected void configureServlets() {
    Class<? extends Filter> authFilter;
    if (authConfig.isTrustContainerAuth()) {
        authFilter = ContainerAuthFilter.class;
    } else if (authConfig.isGitBasicAuth()) {
        if (authConfig.getAuthType() == OAUTH) {
            authFilter = ProjectOAuthFilter.class;
        } else {
            authFilter = ProjectBasicAuthFilter.class;
        }
    } else {
        authFilter = ProjectDigestFilter.class;
    }
    if (isHttpEnabled()) {
        String git = GitOverHttpServlet.URL_REGEX;
        filterRegex(git).through(authFilter);
        serveRegex(git).with(GitOverHttpServlet.class);
    }
    filterRegex(LFS_URL_REGEX).through(ProjectBasicAuthFilter.class);
    filter("/a/*").through(authFilter);
}
#method_after
@Override
protected void configureServlets() {
    Class<? extends Filter> authFilter;
    if (authConfig.isTrustContainerAuth()) {
        authFilter = ContainerAuthFilter.class;
    } else if (authConfig.isGitBasicAuth()) {
        if (authConfig.getAuthType() == OAUTH) {
            authFilter = ProjectOAuthFilter.class;
        } else {
            authFilter = ProjectBasicAuthFilter.class;
        }
    } else {
        authFilter = ProjectDigestFilter.class;
    }
    if (isHttpEnabled()) {
        String git = GitOverHttpServlet.URL_REGEX;
        filterRegex(git).through(authFilter);
        serveRegex(git).with(GitOverHttpServlet.class);
    }
    filterRegex(LFS_URL_REGEX).through(authFilter);
    filter("/a/*").through(authFilter);
}
#end_block

#method_before
@Before
public void setup() throws Exception {
    PowerMockito.mockStatic(Project.NameKey.class);
    when(Project.NameKey.parse(PROJECT_NAME)).thenReturn(mockNameKey);
    Project.NameKey projectNameKey;
    projectNameKey = Project.NameKey.parse(PROJECT_NAME);
    // Setup mocks
    when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig);
    when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true);
    when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/");
    when(mockPluginConfig.getString("channel", "general")).thenReturn("test-channel");
    when(mockPluginConfig.getString("username", "gerrit")).thenReturn("test-user");
    when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*");
    when(mockPluginConfig.getBoolean("notify-on-patch-set-created", true)).thenReturn(true);
    when(mockPluginConfig.getBoolean("notify-on-change-merged", true)).thenReturn(true);
    when(mockPluginConfig.getBoolean("notify-on-comment-added", true)).thenReturn(true);
    config = new ProjectConfig(mockConfigFactory, PROJECT_NAME);
}
#method_after
@Before
public void setup() throws Exception {
    PowerMockito.mockStatic(Project.NameKey.class);
    when(Project.NameKey.parse(PROJECT_NAME)).thenReturn(mockNameKey);
    Project.NameKey projectNameKey;
    projectNameKey = Project.NameKey.parse(PROJECT_NAME);
    // Setup mocks
    when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig);
    when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true);
    when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/");
    when(mockPluginConfig.getString("channel", "general")).thenReturn("test-channel");
    when(mockPluginConfig.getString("username", "gerrit")).thenReturn("test-user");
    when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*");
    when(mockPluginConfig.getBoolean("publish-on-patch-set-created", true)).thenReturn(true);
    when(mockPluginConfig.getBoolean("publish-on-change-merged", true)).thenReturn(true);
    when(mockPluginConfig.getBoolean("publish-on-comment-added", true)).thenReturn(true);
    config = new ProjectConfig(mockConfigFactory, PROJECT_NAME);
}
#end_block

#method_before
private ProjectConfig getConfig(boolean notifyOnCommentAdded) throws Exception {
    Project.NameKey projectNameKey;
    projectNameKey = Project.NameKey.parse(PROJECT_NAME);
    // Setup mocks
    when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig);
    when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true);
    when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/");
    when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel");
    when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser");
    when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*");
    when(mockPluginConfig.getBoolean("notify-on-comment-added", true)).thenReturn(notifyOnCommentAdded);
    return new ProjectConfig(mockConfigFactory, PROJECT_NAME);
}
#method_after
private ProjectConfig getConfig(boolean publishOnCommentAdded) throws Exception {
    Project.NameKey projectNameKey;
    projectNameKey = Project.NameKey.parse(PROJECT_NAME);
    // Setup mocks
    when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig);
    when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true);
    when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/");
    when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel");
    when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser");
    when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*");
    when(mockPluginConfig.getBoolean("publish-on-comment-added", true)).thenReturn(publishOnCommentAdded);
    return new ProjectConfig(mockConfigFactory, PROJECT_NAME);
}
#end_block

#method_before
@Override
public boolean shouldPublish() {
    if (!config.isEnabled() || !config.shouldNotifyOnPatchSetCreated()) {
        return false;
    }
    boolean result;
    result = true;
    try {
        Pattern pattern;
        pattern = Pattern.compile(config.getIgnore(), Pattern.DOTALL);
        Matcher matcher;
        matcher = pattern.matcher(event.change.get().commitMessage);
        // If the ignore pattern matches, publishing should not happen
        result = !matcher.matches();
    } catch (Exception e) {
        LOGGER.warn("The specified ignore pattern was invalid", e);
    }
    return result;
}
#method_after
@Override
public boolean shouldPublish() {
    if (!config.isEnabled() || !config.shouldPublishOnPatchSetCreated()) {
        return false;
    }
    boolean result;
    result = true;
    try {
        Pattern pattern;
        pattern = Pattern.compile(config.getIgnore(), Pattern.DOTALL);
        Matcher matcher;
        matcher = pattern.matcher(event.change.get().commitMessage);
        // If the ignore pattern matches, publishing should not happen
        result = !matcher.matches();
    } catch (Exception e) {
        LOGGER.warn("The specified ignore pattern was invalid", e);
    }
    return result;
}
#end_block

#method_before
private ProjectConfig getConfig(String ignore, boolean notifyOnPatchSetCreated) throws Exception {
    Project.NameKey projectNameKey;
    projectNameKey = Project.NameKey.parse(PROJECT_NAME);
    // Setup mocks
    when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig);
    when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true);
    when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/");
    when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel");
    when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser");
    when(mockPluginConfig.getString("ignore", "")).thenReturn(ignore);
    when(mockPluginConfig.getBoolean("notify-on-patch-set-created", true)).thenReturn(notifyOnPatchSetCreated);
    return new ProjectConfig(mockConfigFactory, PROJECT_NAME);
}
#method_after
private ProjectConfig getConfig(String ignore, boolean publishOnPatchSetCreated) throws Exception {
    Project.NameKey projectNameKey;
    projectNameKey = Project.NameKey.parse(PROJECT_NAME);
    // Setup mocks
    when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig);
    when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true);
    when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/");
    when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel");
    when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser");
    when(mockPluginConfig.getString("ignore", "")).thenReturn(ignore);
    when(mockPluginConfig.getBoolean("publish-on-patch-set-created", true)).thenReturn(publishOnPatchSetCreated);
    return new ProjectConfig(mockConfigFactory, PROJECT_NAME);
}
#end_block

#method_before
private ProjectConfig getConfig(boolean notifyOnPatchSetCreated) throws Exception {
    return getConfig("^WIP.*", notifyOnPatchSetCreated);
}
#method_after
private ProjectConfig getConfig(boolean publishOnPatchSetCreated) throws Exception {
    return getConfig("^WIP.*", publishOnPatchSetCreated);
}
#end_block

#method_before
@Override
public boolean shouldPublish() {
    return config.isEnabled() && config.shouldNotifyOnChangeMerged();
}
#method_after
@Override
public boolean shouldPublish() {
    return config.isEnabled() && config.shouldPublishOnChangeMerged();
}
#end_block

#method_before
@Override
public boolean shouldPublish() {
    return config.isEnabled() && config.shouldNotifyOnCommentAdded();
}
#method_after
@Override
public boolean shouldPublish() {
    return config.isEnabled() && config.shouldPublishOnCommentAdded();
}
#end_block

#method_before
private ProjectConfig getConfig(boolean notifyOnChangeMerged) throws Exception {
    Project.NameKey projectNameKey;
    projectNameKey = Project.NameKey.parse(PROJECT_NAME);
    // Setup mocks
    when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig);
    when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true);
    when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/");
    when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel");
    when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser");
    when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*");
    when(mockPluginConfig.getBoolean("notify-on-change-merged", true)).thenReturn(notifyOnChangeMerged);
    return new ProjectConfig(mockConfigFactory, PROJECT_NAME);
}
#method_after
private ProjectConfig getConfig(boolean publishOnChangeMerged) throws Exception {
    Project.NameKey projectNameKey;
    projectNameKey = Project.NameKey.parse(PROJECT_NAME);
    // Setup mocks
    when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig);
    when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true);
    when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/");
    when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel");
    when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser");
    when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*");
    when(mockPluginConfig.getBoolean("publish-on-change-merged", true)).thenReturn(publishOnChangeMerged);
    return new ProjectConfig(mockConfigFactory, PROJECT_NAME);
}
#end_block

#method_before
@Override
protected void onRequestSuggestions(final Request req, final Callback cb) {
    ChangeApi.revision(changeId.get(), revision.name()).view("files").addParameter("q", req.getQuery() == null ? "" : req.getQuery()).background().get(new AsyncCallback<JsArrayString>() {

        @Override
        public void onSuccess(JsArrayString result) {
            List<Suggestion> r = new ArrayList<>();
            for (String path : Natives.asList(result)) {
                r.add(new PathSuggestion(path));
            }
            cb.onSuggestionsReady(req, new Response(r));
        }

        @Override
        public void onFailure(Throwable caught) {
            List<Suggestion> none = Collections.emptyList();
            cb.onSuggestionsReady(req, new Response(none));
        }
    });
}
#method_after
@Override
protected void onRequestSuggestions(final Request req, final Callback cb) {
    RestApi api = ChangeApi.revision(changeId.get(), revision.name()).view("files");
    if (req.getQuery() != null) {
        api.addParameter("q", req.getQuery() == null ? "" : req.getQuery());
    }
    api.background().get(new AsyncCallback<JsArrayString>() {

        @Override
        public void onSuccess(JsArrayString result) {
            List<Suggestion> r = new ArrayList<>();
            for (String path : Natives.asList(result)) {
                r.add(new PathSuggestion(path));
            }
            cb.onSuggestionsReady(req, new Response(r));
        }

        @Override
        public void onFailure(Throwable caught) {
            List<Suggestion> none = Collections.emptyList();
            cb.onSuggestionsReady(req, new Response(none));
        }
    });
}
#end_block

#method_before
private boolean isAlreadyMerged(CodeReviewCommit commit, Branch.NameKey dest) throws IOException {
    try (CodeReviewRevWalk mirw = CodeReviewCommit.newRevWalk(rw.getObjectReader())) {
        mirw.reset();
        mirw.markStart(commit);
        // check if the commit is merged in other branches
        for (RevCommit accepted : alreadyAccepted) {
            if (mirw.isMergedInto(mirw.parseCommit(accepted), mirw.parseCommit(commit))) {
                log.debug("Dependency {} merged into branch head {}.", commit.getName(), accepted.getName());
                return true;
            }
        }
        // check if the commit associated change is merged in the same branch
        List<ChangeData> changes = internalChangeQuery.byCommit(commit);
        for (ChangeData change : changes) {
            if (change.change().getStatus() == Status.MERGED && change.change().getDest().equals(dest) && !isRework(dest.getParentKey(), commit, change)) {
                log.debug("Dependency {} associate with merged change {}.", commit.getName(), change.getId());
                return true;
            }
        }
        return false;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private boolean isAlreadyMerged(CodeReviewCommit commit, Branch.NameKey dest) throws IOException {
    try (CodeReviewRevWalk mirw = CodeReviewCommit.newRevWalk(rw.getObjectReader())) {
        mirw.reset();
        mirw.markStart(commit);
        // check if the commit is merged in other branches
        for (RevCommit accepted : alreadyAccepted) {
            if (mirw.isMergedInto(mirw.parseCommit(accepted), mirw.parseCommit(commit))) {
                log.debug("Dependency {} merged into branch head {}.", commit.getName(), accepted.getName());
                return true;
            }
        }
        // check if the commit associated change is merged in the same branch
        List<ChangeData> changes = internalChangeQuery.byCommit(commit);
        for (ChangeData change : changes) {
            if (change.change().getStatus() == Status.MERGED && change.change().getDest().equals(dest) && !isRework(dest.getParentKey(), commit, change)) {
                log.debug("Dependency {} associated with merged change {}.", commit.getName(), change.getId());
                return true;
            }
        }
        return false;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
void start() {
    try {
        oracle.requestSuggestions(request, this);
    } catch (Exception e) {
        query = null;
    }
}
#method_after
void start() {
    if (request.getQuery() == null) {
        request.setQuery("");
    }
    oracle.requestSuggestions(request, this);
}
#end_block

#method_before
@Test
public void pushChangeBasedOnChangeOfOtherUserWithCreateNewChangeForAllNotInTarget() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    // create a change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    RevCommit commitChange1 = r.getCommit();
    // create a second change as user (depends on the change from admin)
    TestRepository<?> userRepo = cloneProject(project, user);
    GitUtil.fetch(userRepo, r.getPatchSet().getRefName() + ":change");
    userRepo.reset("change");
    push = pushFactory.create(db, user.getIdent(), userRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
    // assert that no new change was created for the commit of the predecessor
    // change
    assertThat(query(commitChange1.name())).hasSize(1);
}
#method_after
@Test
public void pushChangeBasedOnChangeOfOtherUserWithCreateNewChangeForAllNotInTarget() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    // create a change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    RevCommit commitChange1 = r.getCommit();
    // create a second change as user (depends on the change from admin)
    TestRepository<?> userRepo = cloneProject(project, user);
    GitUtil.fetch(userRepo, r.getPatchSet().getRefName() + ":change");
    userRepo.reset("change");
    push = pushFactory.create(db, user.getIdent(), userRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
    // assert that no new change was created for the commit of the predecessor change
    assertThat(query(commitChange1.name())).hasSize(1);
}
#end_block

#method_before
@Test
public void pushSameCommitTwice() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
    assertPushRejected(pushHead(testRepo, "refs/for/master", false), "refs/for/master", "commit(s) already exists (as current patchset)");
}
#method_after
@Test
public void pushSameCommitTwice() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
    assertPushRejected(pushHead(testRepo, "refs/for/master", false), "refs/for/master", "commit(s) already exists (as current patchset)");
}
#end_block

#method_before
@Test
public void pushSameCommitTwiceWhenIndexFailed() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
    indexer.delete(r.getChange().getId());
    assertPushRejected(pushHead(testRepo, "refs/for/master", false), "refs/for/master", "commit(s) already exists (as current patchset)");
}
#method_after
@Test
public void pushSameCommitTwiceWhenIndexFailed() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
    indexer.delete(r.getChange().getId());
    assertPushRejected(pushHead(testRepo, "refs/for/master", false), "refs/for/master", "commit(s) already exists (as current patchset)");
}
#end_block

#method_before
@Test
public void pushAFewChanges() throws Exception {
    int n = 10;
    String r = "refs/for/master";
    ObjectId initialHead = testRepo.getRepository().resolve("HEAD");
    List<RevCommit> commits = createChanges(n, r);
    // Check that a change was created for each.
    for (RevCommit c : commits) {
        assertThat(byCommit(c).change().getSubject()).named("change for " + c.name()).isEqualTo(c.getShortMessage());
    }
    List<RevCommit> commits2 = amendChanges(initialHead, commits, r);
    // Check that there are correct patch sets.
    for (int i = 0; i < n; i++) {
        RevCommit c = commits.get(i);
        RevCommit c2 = commits2.get(i);
        String name = "change for " + c2.name();
        ChangeData cd = byCommit(c);
        assertThat(cd.change().getSubject()).named(name).isEqualTo(c2.getShortMessage());
        assertThat(getPatchSetRevisions(cd)).named(name).containsExactlyEntriesIn(ImmutableMap.of(1, c.name(), 2, c2.name()));
    }
    // Pushing again results in "no new changes".
    assertPushRejected(pushHead(testRepo, r, false), r, "no new changes");
}
#method_after
@Test
public void pushAFewChanges() throws Exception {
    testPushAFewChanges();
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        Map<RevCommit, ChangeLookup> pending = new HashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            String idStr = !idList.isEmpty() ? idList.get(idList.size() - 1).trim() : null;
            if (idStr != null) {
                pending.put(c, new ChangeLookup(c, new Change.Key(idStr)));
            } else {
                pending.put(c, new ChangeLookup(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private boolean foundInExistingRef(Collection<Ref> existingRefs) throws OrmException {
    for (Ref ref : existingRefs) {
        ChangeNotes notes = notesFactory.create(db, project.getNameKey(), Change.Id.fromRef(ref.getName()));
        Change change = notes.getChange();
        if (change.getDest().equals(magicBranch.dest)) {
            logDebug("Found change {} from existing refs.", change.getKey());
            // reindex the change asynchronously
            indexer.indexAsync(project.getNameKey(), change.getId());
            return true;
        }
    }
    return false;
}
#method_after
private boolean foundInExistingRef(Collection<Ref> existingRefs) throws OrmException {
    for (Ref ref : existingRefs) {
        ChangeNotes notes = notesFactory.create(db, project.getNameKey(), Change.Id.fromRef(ref.getName()));
        Change change = notes.getChange();
        if (change.getDest().equals(magicBranch.dest)) {
            logDebug("Found change {} from existing refs.", change.getKey());
            // Reindex the change asynchronously, ignoring errors.
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = indexer.indexAsync(project.getNameKey(), change.getId());
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public static Map<Change.Id, ChangeData> asMap(List<ChangeData> changes) {
    Map<Change.Id, ChangeData> result = Maps.newHashMapWithExpectedSize(changes.size());
    for (ChangeData cd : changes) {
        result.put(cd.getId(), cd);
    }
    return result;
}
#method_after
public static Map<Change.Id, ChangeData> asMap(List<ChangeData> changes) {
    return changes.stream().collect(Collectors.toMap(ChangeData::getId, cd -> cd));
}
#end_block

#method_before
private Optional<DiffSummary> getDiffSummary(Change c, PatchSet ps) {
    Integer psId = ps.getId().get();
    if (diffSummaries == null) {
        diffSummaries = new HashMap<>();
    }
    Optional<DiffSummary> r = diffSummaries.get(psId);
    if (r == null) {
        if (!lazyLoad) {
            return Optional.absent();
        }
        try {
            r = Optional.of(patchListCache.getDiffSummary(c, ps));
        } catch (PatchListNotAvailableException e) {
            r = Optional.absent();
        }
        diffSummaries.put(psId, r);
    }
    return r;
}
#method_after
private Optional<DiffSummary> getDiffSummary(Change c, PatchSet ps) {
    Integer psId = ps.getId().get();
    if (diffSummaries == null) {
        diffSummaries = new HashMap<>();
    }
    Optional<DiffSummary> r = diffSummaries.get(psId);
    if (r == null) {
        if (!lazyLoad) {
            return Optional.empty();
        }
        try {
            r = Optional.of(patchListCache.getDiffSummary(c, ps));
        } catch (PatchListNotAvailableException e) {
            r = Optional.empty();
        }
        diffSummaries.put(psId, r);
    }
    return r;
}
#end_block

#method_before
private Optional<ChangedLines> computeChangedLines() throws OrmException {
    Change c = change();
    if (c == null) {
        return Optional.absent();
    }
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return Optional.absent();
    }
    Optional<DiffSummary> ds = getDiffSummary(c, ps);
    if (ds.isPresent()) {
        return Optional.of(ds.get().getChangedLines());
    }
    return Optional.absent();
}
#method_after
private Optional<ChangedLines> computeChangedLines() throws OrmException {
    Change c = change();
    if (c == null) {
        return Optional.empty();
    }
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return Optional.empty();
    }
    Optional<DiffSummary> ds = getDiffSummary(c, ps);
    if (ds.isPresent()) {
        return Optional.of(ds.get().getChangedLines());
    }
    return Optional.empty();
}
#end_block

#method_before
public Optional<ChangedLines> changedLines() throws OrmException {
    if (changedLines == null) {
        if (!lazyLoad) {
            return Optional.absent();
        }
        changedLines = computeChangedLines();
    }
    return changedLines;
}
#method_after
public Optional<ChangedLines> changedLines() throws OrmException {
    if (changedLines == null) {
        if (!lazyLoad) {
            return Optional.empty();
        }
        changedLines = computeChangedLines();
    }
    return changedLines;
}
#end_block

#method_before
public void setNoChangedLines() {
    changedLines = Optional.absent();
}
#method_after
public void setNoChangedLines() {
    changedLines = Optional.empty();
}
#end_block

#method_before
public Change reloadChange() throws OrmException {
    notes = notesFactory.create(db, project, legacyId);
    change = notes.getChange();
    if (change == null) {
        throw new OrmException("Unable to load change " + legacyId);
    }
    setPatchSets(null);
    return change;
}
#method_after
public Change reloadChange() throws OrmException {
    try {
        notes = notesFactory.createChecked(db, project, legacyId);
    } catch (NoSuchChangeException e) {
        throw new OrmException("Unable to load change " + legacyId, e);
    }
    change = notes.getChange();
    setPatchSets(null);
    return change;
}
#end_block

#method_before
public Collection<PatchSet> visiblePatchSets() throws OrmException {
    Predicate<PatchSet> predicate = ps -> {
        try {
            return changeControl().isPatchVisible(ps, db);
        } catch (OrmException e) {
            return false;
        }
    };
    return FluentIterable.from(patchSets()).filter(predicate).toList();
}
#method_after
public Collection<PatchSet> visiblePatchSets() throws OrmException {
    Predicate<? super PatchSet> predicate = ps -> {
        try {
            return changeControl().isPatchVisible(ps, db);
        } catch (OrmException e) {
            return false;
        }
    };
    return patchSets().stream().filter(predicate).collect(toList());
}
#end_block

#method_before
public Optional<PatchSetApproval> getSubmitApproval() throws OrmException {
    for (PatchSetApproval psa : currentApprovals()) {
        if (psa.isLegacySubmit()) {
            return Optional.fromNullable(psa);
        }
    }
    return Optional.absent();
}
#method_after
public Optional<PatchSetApproval> getSubmitApproval() throws OrmException {
    return currentApprovals().stream().filter(PatchSetApproval::isLegacySubmit).findFirst();
}
#end_block

#method_before
public List<SubmitRecord> getSubmitRecords() {
    return submitRecords;
}
#method_after
@Nullable
public List<SubmitRecord> getSubmitRecords(SubmitRuleOptions options) {
    return submitRecords.get(options);
}
#end_block

#method_before
public void setSubmitRecords(List<SubmitRecord> records) {
    submitRecords = records;
}
#method_after
public void setSubmitRecords(SubmitRuleOptions options, List<SubmitRecord> records) {
    submitRecords.put(options, records);
}
#end_block

#method_before
public Set<Account.Id> editsByUser() throws OrmException {
    if (editsByUser == null) {
        if (!lazyLoad) {
            return Collections.emptySet();
        }
        Change c = change();
        if (c == null) {
            return Collections.emptySet();
        }
        editsByUser = new HashSet<>();
        Change.Id id = checkNotNull(change.getId());
        try (Repository repo = repoManager.openRepository(project())) {
            for (String ref : repo.getRefDatabase().getRefs(RefNames.REFS_USERS).keySet()) {
                if (id.equals(Change.Id.fromEditRefPart(ref))) {
                    editsByUser.add(Account.Id.fromRefPart(ref));
                }
            }
        } catch (IOException e) {
            throw new OrmException(e);
        }
    }
    return editsByUser;
}
#method_after
public Set<Account.Id> editsByUser() throws OrmException {
    return editRefs().keySet();
}
#end_block

#method_before
public Set<Account.Id> draftsByUser() throws OrmException {
    if (draftsByUser == null) {
        if (!lazyLoad) {
            return Collections.emptySet();
        }
        Change c = change();
        if (c == null) {
            return Collections.emptySet();
        }
        draftsByUser = new HashSet<>();
        for (Comment sc : commentsUtil.draftByChange(db, notes)) {
            draftsByUser.add(sc.author.getId());
        }
    }
    return draftsByUser;
}
#method_after
public Set<Account.Id> draftsByUser() throws OrmException {
    return draftRefs().keySet();
}
#end_block

#method_before
public ImmutableMultimap<Account.Id, String> stars() throws OrmException {
    if (stars == null) {
        if (!lazyLoad) {
            return ImmutableMultimap.of();
        }
        stars = checkNotNull(starredChangesUtil).byChange(legacyId);
    }
    return stars;
}
#method_after
public ImmutableListMultimap<Account.Id, String> stars() throws OrmException {
    if (stars == null) {
        if (!lazyLoad) {
            return ImmutableListMultimap.of();
        }
        ImmutableListMultimap.Builder<Account.Id, String> b = ImmutableListMultimap.builder();
        for (Map.Entry<Account.Id, StarRef> e : starRefs().entrySet()) {
            b.putAll(e.getKey(), e.getValue().labels());
        }
        return b.build();
    }
    return stars;
}
#end_block

#method_before
public void setStars(Multimap<Account.Id, String> stars) {
    this.stars = ImmutableMultimap.copyOf(stars);
}
#method_after
public void setStars(ListMultimap<Account.Id, String> stars) {
    this.stars = ImmutableListMultimap.copyOf(stars);
}
#end_block

#method_before
@Override
public int weigh(DiffSummaryKey key, DiffSummary value) {
    int size = // Size of DiffSummaryKey, 64 bit JVM
    16 + 4 * 8 + 2 * 36 + 16 + 8 + // Size of DiffSummary
    2 * 4 + 16 + // String[]
    8;
    for (String p : value.getPaths()) {
        size += // String
        16 + 8 + 4 * 4 + 16 + 8 + // char[]
        p.length() * 2;
    }
    return size;
}
#method_after
@Override
public int weigh(DiffSummaryKey key, DiffSummary value) {
    int size = 16 + 4 * 8 + // Size of DiffSummaryKey, 64 bit JVM
    2 * 36 + 16 + 8 + // Size of DiffSummary
    2 * 4 + 16 + // String[]
    8;
    for (String p : value.getPaths()) {
        size += 16 + 8 + // String
        4 * 4 + 16 + 8 + // char[]
        p.length() * 2;
    }
    return size;
}
#end_block

#method_before
private void writeObject(ObjectOutputStream output) throws IOException {
    writeVarInt32(output, paths.length);
    try (DeflaterOutputStream out = new DeflaterOutputStream(output)) {
        for (String p : paths) {
            writeString(out, p);
        }
    }
    writeVarInt32(output, insertions);
    writeVarInt32(output, deletions);
}
#method_after
private void writeObject(ObjectOutputStream output) throws IOException {
    writeVarInt32(output, insertions);
    writeVarInt32(output, deletions);
    writeVarInt32(output, paths.length);
    try (DeflaterOutputStream out = new DeflaterOutputStream(output)) {
        for (String p : paths) {
            writeString(out, p);
        }
    }
}
#end_block

#method_before
private void readObject(ObjectInputStream input) throws IOException {
    paths = new String[readVarInt32(input)];
    try (InflaterInputStream in = new InflaterInputStream(input)) {
        for (int i = 0; i < paths.length; i++) {
            paths[i] = readString(in);
        }
    }
    insertions = readVarInt32(input);
    deletions = readVarInt32(input);
}
#method_after
private void readObject(ObjectInputStream input) throws IOException {
    insertions = readVarInt32(input);
    deletions = readVarInt32(input);
    paths = new String[readVarInt32(input)];
    try (InflaterInputStream in = new InflaterInputStream(input)) {
        for (int i = 0; i < paths.length; i++) {
            paths[i] = readString(in);
        }
    }
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, UnprocessableEntityException {
    changeControl = ctx.getControl();
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (patchSet == null) {
        throw new OrmException("patch set not found: " + psId);
    }
    String changeMsg = "Patch Set " + psId.get() + ":";
    if (parsedComments.get(0).type == MailComment.CommentType.CHANGE_MESSAGE) {
        if (parsedComments.size() > 1) {
            changeMsg += "\n\n" + numComments(parsedComments.size() - 1);
        }
        changeMsg += "\n\n" + parsedComments.get(0).message;
    } else {
        changeMsg += "\n\n" + numComments(parsedComments.size());
    }
    changeMessage = ChangeMessagesUtil.newMessage(ctx, changeMsg, tag);
    changeMessagesUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    comments = new ArrayList<>();
    for (MailComment c : parsedComments) {
        if (c.type == MailComment.CommentType.CHANGE_MESSAGE) {
            continue;
        }
        String fileName;
        // The patch set that this comment is based on is different if this
        // comment was sent in reply to a comment on a previous patch set.
        PatchSet psForComment;
        Side side;
        if (c.inReplyTo != null) {
            fileName = c.inReplyTo.key.filename;
            psForComment = psUtil.get(ctx.getDb(), ctx.getNotes(), new PatchSet.Id(ctx.getChange().getId(), c.inReplyTo.key.patchSetId));
            side = Side.fromShort(c.inReplyTo.side);
        } else {
            fileName = c.fileName;
            psForComment = patchSet;
            side = Side.REVISION;
        }
        Comment comment = commentsUtil.newComment(ctx, fileName, psForComment.getId(), (short) side.ordinal(), c.message, false, null);
        comment.tag = tag;
        if (c.inReplyTo != null) {
            comment.parentUuid = c.inReplyTo.key.uuid;
            comment.lineNbr = c.inReplyTo.lineNbr;
            comment.range = c.inReplyTo.range;
            comment.unresolved = c.inReplyTo.unresolved;
        }
        CommentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), psForComment);
        comments.add(comment);
    }
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), Status.PUBLISHED, comments);
    return true;
}
#method_after
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, UnprocessableEntityException {
    changeControl = ctx.getControl();
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (patchSet == null) {
        throw new OrmException("patch set not found: " + psId);
    }
    String changeMsg = "Patch Set " + psId.get() + ":";
    if (parsedComments.get(0).type == MailComment.CommentType.CHANGE_MESSAGE) {
        // Add a blank line after Patch Set to follow the default format
        if (parsedComments.size() > 1) {
            changeMsg += "\n\n" + numComments(parsedComments.size() - 1);
        }
        changeMsg += "\n\n" + parsedComments.get(0).message;
    } else {
        changeMsg += "\n\n" + numComments(parsedComments.size());
    }
    changeMessage = ChangeMessagesUtil.newMessage(ctx, changeMsg, tag);
    changeMessagesUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    comments = new ArrayList<>();
    for (MailComment c : parsedComments) {
        if (c.type == MailComment.CommentType.CHANGE_MESSAGE) {
            continue;
        }
        String fileName;
        // The patch set that this comment is based on is different if this
        // comment was sent in reply to a comment on a previous patch set.
        PatchSet psForComment;
        Side side;
        if (c.inReplyTo != null) {
            fileName = c.inReplyTo.key.filename;
            psForComment = psUtil.get(ctx.getDb(), ctx.getNotes(), new PatchSet.Id(ctx.getChange().getId(), c.inReplyTo.key.patchSetId));
            side = Side.fromShort(c.inReplyTo.side);
        } else {
            fileName = c.fileName;
            psForComment = patchSet;
            side = Side.REVISION;
        }
        Comment comment = commentsUtil.newComment(ctx, fileName, psForComment.getId(), (short) side.ordinal(), c.message, false, null);
        comment.tag = tag;
        if (c.inReplyTo != null) {
            comment.parentUuid = c.inReplyTo.key.uuid;
            comment.lineNbr = c.inReplyTo.lineNbr;
            comment.range = c.inReplyTo.range;
            comment.unresolved = c.inReplyTo.unresolved;
        }
        CommentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), psForComment);
        comments.add(comment);
    }
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), Status.PUBLISHED, comments);
    return true;
}
#end_block

#method_before
@Override
public void start() {
    graphiteReporter.start(rate, rateUnit);
}
#method_after
@Override
public void start() {
    graphiteReporter.start(rate, DEFAULT_RATE_UNIT);
}
#end_block

#method_before
@Test
public void userReceivesPlaintextEmail() throws Exception {
    // Set user preference to receive only plaintext content
    GeneralPreferencesInfo i = GeneralPreferencesInfo.defaults();
    i.emailFormat = EmailFormat.PLAINTEXT;
    gApi.accounts().id(admin.getId().toString()).setPreferences(i);
    // Create change as admin and review as user
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    // Check that user has received only plaintext content
    assertThat(sender.getMessages()).hasSize(1);
    assertThat(sender.getMessages().get(0).body()).isNotNull();
    assertThat(sender.getMessages().get(0).htmlBody()).isNull();
    // Reset user preference
    setApiUser(admin);
    i.emailFormat = EmailFormat.HTML_PLAINTEXT;
    gApi.accounts().id(admin.getId().toString()).setPreferences(i);
}
#method_after
@Test
public void userReceivesPlaintextEmail() throws Exception {
    // Set user preference to receive only plaintext content
    GeneralPreferencesInfo i = new GeneralPreferencesInfo();
    i.emailFormat = EmailFormat.PLAINTEXT;
    gApi.accounts().id(admin.getId().toString()).setPreferences(i);
    // Create change as admin and review as user
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    // Check that admin has received only plaintext content
    assertThat(sender.getMessages()).hasSize(1);
    assertThat(sender.getMessages().get(0).body()).isNotNull();
    assertThat(sender.getMessages().get(0).htmlBody()).isNull();
    // Reset user preference
    setApiUser(admin);
    i.emailFormat = EmailFormat.HTML_PLAINTEXT;
    gApi.accounts().id(admin.getId().toString()).setPreferences(i);
}
#end_block

#method_before
@Test
public void userReceivesHtmlAndPlaintextEmail() throws Exception {
    // Create change as admin and review as user
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    // Check that user has received only plaintext content
    assertThat(sender.getMessages()).hasSize(1);
    assertThat(sender.getMessages().get(0).body()).isNotNull();
    assertThat(sender.getMessages().get(0).htmlBody()).isNotNull();
}
#method_after
@Test
public void userReceivesHtmlAndPlaintextEmail() throws Exception {
    // Create change as admin and review as user
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    // Check that admin has received both HTML and plaintext content
    assertThat(sender.getMessages()).hasSize(1);
    assertThat(sender.getMessages().get(0).body()).isNotNull();
    assertThat(sender.getMessages().get(0).htmlBody()).isNotNull();
}
#end_block

#method_before
public boolean isSkipMerge(String fromBranch, String toBranch, String commitMessage) {
    // If regex matches always_blank_merge (DO NOT MERGE ANYWHERE), skip.
    if (alwaysBlankMergePattern != null && alwaysBlankMergePattern.matches(commitMessage)) {
        return true;
    }
    // If regex matches blank_merge (DO NOT MERGE), skip iff merge_all is false
    if (blankMergePattern != null && blankMergePattern.matches(commitMessage)) {
        Map<String, Object> mergePairConfig = getMergeConfig(fromBranch, toBranch);
        if (mergePairConfig != null) {
            boolean isMergeAll = (boolean) mergePairConfig.getOrDefault("merge_all", false);
            return !isMergeAll;
        }
    }
    return false;
}
#method_after
public boolean isSkipMerge(String fromBranch, String toBranch, String commitMessage) {
    // If regex matches always_blank_merge (DO NOT MERGE ANYWHERE), skip.
    if (alwaysBlankMergePattern != null && alwaysBlankMergePattern.matches(commitMessage)) {
        return true;
    }
    // If regex matches blank_merge (DO NOT MERGE), skip iff merge_all is false
    if (blankMergePattern != null && blankMergePattern.matches(commitMessage)) {
        Map<String, Object> mergePairConfig = getMergeConfig(fromBranch, toBranch);
        if (mergePairConfig != null) {
            boolean isMergeAll = (boolean) mergePairConfig.getOrDefault("merge_all", false);
            return !isMergeAll;
        }
        return true;
    }
    return false;
}
#end_block

#method_before
public Map<String, Map<String, Object>> getMergeConfig(String fromBranch) {
    return getBranches().get(fromBranch);
}
#method_after
public Map<String, Object> getMergeConfig(String fromBranch) {
    return getBranches().get(fromBranch);
}
#end_block

#method_before
public Map<String, Object> getMergeConfig(String fromBranch, String toBranch) {
    @SuppressWarnings("unchecked")
    Map<String, Map<String, Object>> fromBranchConfig = getBranches().get(fromBranch);
    if (fromBranchConfig == null) {
        return Collections.emptyMap();
    }
    return fromBranchConfig.get(toBranch);
}
#method_after
public Map<String, Object> getMergeConfig(String fromBranch, String toBranch) {
    Map<String, Object> fromBranchConfig = getBranches().get(fromBranch);
    if (fromBranchConfig == null) {
        return Collections.emptyMap();
    }
    return (Map<String, Object>) fromBranchConfig.get(toBranch);
}
#end_block

#method_before
public Map<String, Map<String, Map<String, Object>>> getBranches() {
    return (Map<String, Map<String, Map<String, Object>>>) config.getOrDefault("branches", Collections.emptyMap());
}
#method_after
public Map<String, Map<String, Object>> getBranches() {
    return (Map<String, Map<String, Object>>) config.getOrDefault("branches", Collections.<String, Map<String, Object>>emptyMap());
}
#end_block

#method_before
public Set<String> getDownstreamBranches(String fromBranch, String project) throws RestApiException, IOException {
    Set<String> downstreamBranches = new HashSet<String>();
    Map<String, Map<String, Object>> fromBranchConfig = config.getMergeConfig(fromBranch);
    if (fromBranchConfig != null) {
        for (String key : fromBranchConfig.keySet()) {
            if (!configOptionKeys.contains(key)) {
                // If it's not a config option, then the key is the toBranch
                Set<String> projectsInScope = getProjectsInScope(fromBranch, key);
                if (projectsInScope.contains(project)) {
                    downstreamBranches.add(key);
                }
            }
        }
    }
    return downstreamBranches;
}
#method_after
public Set<String> getDownstreamBranches(String fromBranch, String project) throws RestApiException, IOException {
    Set<String> downstreamBranches = new HashSet<String>();
    Map<String, Object> fromBranchConfig = config.getMergeConfig(fromBranch);
    if (fromBranchConfig != null) {
        for (String key : fromBranchConfig.keySet()) {
            if (!configOptionKeys.contains(key)) {
                // If it's not a config option, then the key is the toBranch
                Set<String> projectsInScope = getProjectsInScope(fromBranch, key);
                if (projectsInScope.contains(project)) {
                    downstreamBranches.add(key);
                }
            }
        }
    }
    return downstreamBranches;
}
#end_block

#method_before
// Returns contents of manifest file for the given branch.
private Set<String> getManifestProjects(String fromBranch) throws RestApiException, IOException {
    Map fromBranchConfig = config.getMergeConfig(fromBranch);
    if (fromBranchConfig == null) {
        return new HashSet<>();
    }
    Map<String, String> manifestProjectInfo = getManifestInfoFromConfig(fromBranchConfig);
    return getManifestProjectsForBranch(manifestProjectInfo, fromBranch);
}
#method_after
// Returns contents of manifest file for the given branch.
private Set<String> getManifestProjects(String fromBranch) throws RestApiException, IOException {
    Map<String, Object> fromBranchConfig = config.getMergeConfig(fromBranch);
    if (fromBranchConfig == null) {
        return new HashSet<>();
    }
    Map<String, String> manifestProjectInfo = getManifestInfoFromConfig(fromBranchConfig);
    return getManifestProjectsForBranch(manifestProjectInfo, fromBranch);
}
#end_block

#method_before
private void applyConfig(Set<String> projects, Map givenConfig) {
    if (givenConfig == null) {
        return;
    }
    if (givenConfig.containsKey("set_projects")) {
        List<String> setProjects = (ArrayList<String>) givenConfig.get("set_projects");
        projects.clear();
        projects.addAll(setProjects);
        // if we set projects we can ignore the rest
        return;
    }
    if (givenConfig.containsKey("add_projects")) {
        List<String> addProjects = (List<String>) givenConfig.get("add_projects");
        projects.addAll(addProjects);
    }
    if (givenConfig.containsKey("ignore_projects")) {
        List<String> ignoreProjects = (List<String>) givenConfig.get("ignore_projects");
        projects.removeAll(ignoreProjects);
    }
}
#method_after
private void applyConfig(Set<String> projects, Map<String, Object> givenConfig) {
    if (givenConfig == null) {
        return;
    }
    if (givenConfig.containsKey("set_projects")) {
        List<String> setProjects = (ArrayList<String>) givenConfig.get("set_projects");
        projects.clear();
        projects.addAll(setProjects);
        // if we set projects we can ignore the rest
        return;
    }
    if (givenConfig.containsKey("add_projects")) {
        List<String> addProjects = (List<String>) givenConfig.get("add_projects");
        projects.addAll(addProjects);
    }
    if (givenConfig.containsKey("ignore_projects")) {
        List<String> ignoreProjects = (List<String>) givenConfig.get("ignore_projects");
        projects.removeAll(ignoreProjects);
    }
}
#end_block

#method_before
private OwnersMap fetchOwners() {
    OwnersMap retMap = new OwnersMap();
    Map<String, PathOwnersEntry> entries = Maps.newHashMap();
    PathOwnersEntry rootEntry = new PathOwnersEntry();
    OwnersConfig rootConfig = getOwnersConfig("OWNERS");
    if (rootConfig != null) {
        rootEntry.setOwnersPath("OWNERS");
        rootEntry.setOwners(parser.getOwnersFromEmails(rootConfig.getOwners()));
        rootEntry.setMatchers(rootConfig.getMatchers());
    }
    Set<String> paths = getModifiedPaths();
    for (String path : paths) {
        String[] parts = path.split("/");
        PathOwnersEntry currentEntry = rootEntry;
        StringBuilder builder = new StringBuilder();
        // itself
        for (int i = 0, partsLength = parts.length - 1; i < partsLength; i++) {
            String part = parts[i];
            builder.append(part).append("/");
            String partial = builder.toString();
            // Skip if we already parsed this path
            if (!entries.containsKey(partial)) {
                String ownersPath = partial + "OWNERS";
                OwnersConfig config = getOwnersConfig(ownersPath);
                if (config != null) {
                    PathOwnersEntry entry = new PathOwnersEntry();
                    entry.setOwnersPath(ownersPath);
                    entry.setOwners(parser.getOwnersFromEmails(config.getOwners()));
                    entry.setMatchers(config.getMatchers());
                    if (config.isInherited()) {
                        entry.getOwners().addAll(currentEntry.getOwners());
                        for (Matcher m : currentEntry.getMatchers().values()) {
                            entry.addMatcher(m);
                        }
                    }
                    currentEntry = entry;
                }
                entries.put(partial, currentEntry);
            } else {
                currentEntry = entries.get(partial);
            }
        }
        // add owners to file for matcher predicates
        retMap.addFileOwners(path, currentEntry.getOwners());
        // entries in the result
        if (currentEntry.getOwnersPath() != null) {
            retMap.addPathOwners(currentEntry.getOwnersPath(), currentEntry.getOwners());
        }
        retMap.addMatchers(currentEntry.getMatchers());
    }
    Map<String, Matcher> matchers = retMap.getMatchers();
    if (matchers.size() > 0) {
        HashMap<String, Matcher> newMatchers = Maps.newHashMap();
        for (String path : paths) {
            Iterator<Matcher> it = matchers.values().iterator();
            while (it.hasNext()) {
                Matcher matcher = it.next();
                if (matcher.matches(path)) {
                    newMatchers.put(matcher.getPath(), matcher);
                    retMap.addFileOwners(path, matcher.getOwners());
                }
            }
        }
        if (matchers.size() != newMatchers.size()) {
            retMap.setMatchers(newMatchers);
        }
    }
    return retMap;
}
#method_after
private OwnersMap fetchOwners() {
    OwnersMap ownersMap = new OwnersMap();
    try {
        String rootPath = "OWNERS";
        PathOwnersEntry rootEntry = getOwnersConfig(rootPath).map(conf -> new PathOwnersEntry(rootPath, conf, parser, Collections.emptySet())).orElse(new PathOwnersEntry());
        Set<String> modifiedPaths = getModifiedPaths();
        Map<String, PathOwnersEntry> entries = new HashMap<>();
        PathOwnersEntry currentEntry = null;
        for (String path : modifiedPaths) {
            currentEntry = resolvePathEntry(path, rootEntry, entries);
            // add owners to file for matcher predicates
            ownersMap.addFileOwners(path, currentEntry.getOwners());
            // entries in the result
            if (currentEntry.getOwnersPath() != null) {
                ownersMap.addPathOwners(currentEntry.getOwnersPath(), currentEntry.getOwners());
            }
            ownersMap.addMatchers(currentEntry.getMatchers());
        }
        // We need to only keep matchers that match files in the patchset
        Map<String, Matcher> matchers = ownersMap.getMatchers();
        if (matchers.size() > 0) {
            HashMap<String, Matcher> newMatchers = Maps.newHashMap();
            // extra loop
            for (String path : modifiedPaths) {
                processMatcherPerPath(matchers, newMatchers, path, ownersMap);
            }
            if (matchers.size() != newMatchers.size()) {
                ownersMap.setMatchers(newMatchers);
            }
        }
        return ownersMap;
    } catch (IOException e) {
        log.warn("Invalid OWNERS file", e);
        return ownersMap;
    }
}
#end_block

#method_before
private OwnersConfig getOwnersConfig(String ownersPath) {
    try {
        return getBlobAsBytes(repository, "master", ownersPath).flatMap(bytes -> parser.getOwnersConfig(bytes)).orElse(null);
    } catch (Exception e) {
        log.warn("Invalid OWNERS file: {}", ownersPath, e);
        return null;
    }
}
#method_after
private Optional<OwnersConfig> getOwnersConfig(String ownersPath) throws IOException {
    return getBlobAsBytes(repository, "master", ownersPath).flatMap(bytes -> parser.getOwnersConfig(bytes));
}
#end_block

#method_before
public Term createFormattedList(Prolog engine, Term key) {
    String path = key.toString();
    PathOwners owners = OwnersStoredValues.PATH_OWNERS.get(engine);
    String userNames = StreamUtils.asStream(owners.getFileOwners().get(path).iterator()).map(id -> getFullNameFromId(engine, id)).collect(Collectors.joining(" "));
    return SymbolTerm.create((new File(path)).getName() + " " + userNames);
}
#method_after
public Term createFormattedList(Prolog engine, Term key) {
    String path = key.toString();
    PathOwners owners = OwnersStoredValues.PATH_OWNERS.get(engine);
    String userNames = iteratorStream(owners.getFileOwners().get(path).iterator()).map(id -> getFullNameFromId(engine, id)).collect(Collectors.joining(" "));
    return SymbolTerm.create((new File(path)).getName() + " " + userNames);
}
#end_block

#method_before
@Override
public void run() {
    addReviewers(reviewers, ps);
}
#method_after
@Override
public void run() {
    addReviewers(reviewers, change);
}
#end_block

#method_before
private void addReviewers(Set<Account> reviewers, PatchSet ps) {
    try {
        ReviewInput in = new ReviewInput();
        in.reviewers = new ArrayList<>(reviewers.size());
        for (Account account : reviewers) {
            AddReviewerInput addReviewerInput = new AddReviewerInput();
            addReviewerInput.reviewer = account.getId().toString();
            in.reviewers.add(addReviewerInput);
        }
        gApi.changes().id(ps.getId().getParentKey().get()).revision(ps.getPatchSetId()).review(in);
    } catch (RestApiException e) {
        log.error("Couldn't add reviewers to the change", e);
    }
}
#method_after
private void addReviewers(Set<Account> reviewers, Change change) {
    try {
        // TODO(davido): Switch back to using changes API again,
        // when it supports batch mode for adding reviewers
        ReviewInput in = new ReviewInput();
        in.reviewers = new ArrayList<>(reviewers.size());
        for (Account account : reviewers) {
            AddReviewerInput addReviewerInput = new AddReviewerInput();
            addReviewerInput.reviewer = account.getId().toString();
            in.reviewers.add(addReviewerInput);
        }
        gApi.changes().id(change.getId().get()).current().review(in);
    } catch (RestApiException e) {
        log.error("Couldn't add reviewers to the change", e);
    }
}
#end_block

#method_before
public static List<MailComment> parse(MailMessage email, Collection<Comment> comments, String changeUrl) {
    // TODO(hiesel) Add support for Gmail Mobile
    // TODO(hiesel) Add tests for other popular email clients
    // This parser goes though all html elements in the email and checks for
    // matching patterns. It keeps track of the last file and comments it
    // encountered to know in which context a parsed comment belongs.
    // It uses the href attributes of <a> tags to identify comments sent out by
    // Gerrit as these are generally more reliable then the text captions.
    List<MailComment> parsedComments = new ArrayList<>();
    Document d = Jsoup.parse(email.htmlContent());
    PeekingIterator<Comment> iter = Iterators.peekingIterator(comments.iterator());
    String lastEncounteredFileName = null;
    Comment lastEncounteredComment = null;
    for (Element e : d.body().getAllElements()) {
        String elementName = e.tagName();
        boolean isInBlockQuote = e.parents().stream().filter(p -> p.tagName().equals("blockquote")).findAny().isPresent();
        if (elementName.equals("a")) {
            String href = e.attr("href");
            // this <a> tag
            if (!iter.hasNext()) {
                continue;
            }
            Comment perspectiveComment = iter.peek();
            if (href.equals(ParserUtil.filePath(changeUrl, perspectiveComment))) {
                if (lastEncounteredFileName == null || !lastEncounteredFileName.equals(perspectiveComment.key.filename)) {
                    // Not a file-level comment, but users could have typed a comment
                    // right after this file annotation to create a new file-level
                    // comment. If this file has a file-level comment, we have already
                    // set lastEncounteredComment to that file-level comment when we
                    // encountered the file link and should not reset it now.
                    lastEncounteredFileName = perspectiveComment.key.filename;
                    lastEncounteredComment = null;
                } else if (perspectiveComment.lineNbr == 0) {
                    // This was originally a file-level comment
                    lastEncounteredComment = perspectiveComment;
                    iter.next();
                }
            } else if (ParserUtil.isCommentUrl(href, changeUrl, perspectiveComment)) {
                // This is a regular inline comment
                lastEncounteredComment = perspectiveComment;
                iter.next();
            }
        } else if (!isInBlockQuote && elementName.equals("div") && !e.className().startsWith("gmail")) {
            // This is a comment typed by the user
            // Replace non-breaking spaces and trim string
            String content = e.ownText().replaceAll("\\u00a0", " ").trim();
            if (!Strings.isNullOrEmpty(content)) {
                if (lastEncounteredComment == null && lastEncounteredFileName == null) {
                    // Remove quotation line, email signature and
                    // "Sent from my xyz device"
                    content = ParserUtil.trimQuotationLine(content);
                    // TODO(hiesel) Add more sanitizer
                    if (!Strings.isNullOrEmpty(content)) {
                        parsedComments.add(new MailComment(content, null, null, MailComment.CommentType.CHANGE_MESSAGE));
                    }
                } else if (lastEncounteredComment == null) {
                    parsedComments.add(new MailComment(content, lastEncounteredFileName, null, MailComment.CommentType.FILE_COMMENT));
                } else {
                    parsedComments.add(new MailComment(content, null, lastEncounteredComment, MailComment.CommentType.INLINE_COMMENT));
                }
            }
        }
    }
    return parsedComments;
}
#method_after
public static List<MailComment> parse(MailMessage email, Collection<Comment> comments, String changeUrl) {
    // TODO(hiesel) Add support for Gmail Mobile
    // TODO(hiesel) Add tests for other popular email clients
    // This parser goes though all html elements in the email and checks for
    // matching patterns. It keeps track of the last file and comments it
    // encountered to know in which context a parsed comment belongs.
    // It uses the href attributes of <a> tags to identify comments sent out by
    // Gerrit as these are generally more reliable then the text captions.
    List<MailComment> parsedComments = new ArrayList<>();
    Document d = Jsoup.parse(email.htmlContent());
    PeekingIterator<Comment> iter = Iterators.peekingIterator(comments.iterator());
    String lastEncounteredFileName = null;
    Comment lastEncounteredComment = null;
    for (Element e : d.body().getAllElements()) {
        String elementName = e.tagName();
        boolean isInBlockQuote = e.parents().stream().filter(p -> p.tagName().equals("blockquote")).findAny().isPresent();
        if (elementName.equals("a")) {
            String href = e.attr("href");
            // this <a> tag
            if (!iter.hasNext()) {
                continue;
            }
            Comment perspectiveComment = iter.peek();
            if (href.equals(ParserUtil.filePath(changeUrl, perspectiveComment))) {
                if (lastEncounteredFileName == null || !lastEncounteredFileName.equals(perspectiveComment.key.filename)) {
                    // Not a file-level comment, but users could have typed a comment
                    // right after this file annotation to create a new file-level
                    // comment. If this file has a file-level comment, we have already
                    // set lastEncounteredComment to that file-level comment when we
                    // encountered the file link and should not reset it now.
                    lastEncounteredFileName = perspectiveComment.key.filename;
                    lastEncounteredComment = null;
                } else if (perspectiveComment.lineNbr == 0) {
                    // This was originally a file-level comment
                    lastEncounteredComment = perspectiveComment;
                    iter.next();
                }
            } else if (ParserUtil.isCommentUrl(href, changeUrl, perspectiveComment)) {
                // This is a regular inline comment
                lastEncounteredComment = perspectiveComment;
                iter.next();
            }
        } else if (!isInBlockQuote && elementName.equals("div") && !e.className().startsWith("gmail")) {
            // This is a comment typed by the user
            // Replace non-breaking spaces and trim string
            String content = e.ownText().replace('\u00a0', ' ').trim();
            if (!Strings.isNullOrEmpty(content)) {
                if (lastEncounteredComment == null && lastEncounteredFileName == null) {
                    // Remove quotation line, email signature and
                    // "Sent from my xyz device"
                    content = ParserUtil.trimQuotationLine(content);
                    // TODO(hiesel) Add more sanitizer
                    if (!Strings.isNullOrEmpty(content)) {
                        parsedComments.add(new MailComment(content, null, null, MailComment.CommentType.CHANGE_MESSAGE));
                    }
                } else if (lastEncounteredComment == null) {
                    parsedComments.add(new MailComment(content, lastEncounteredFileName, null, MailComment.CommentType.FILE_COMMENT));
                } else {
                    parsedComments.add(new MailComment(content, null, lastEncounteredComment, MailComment.CommentType.INLINE_COMMENT));
                }
            }
        }
    }
    return parsedComments;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    try {
        Change.Status status = rsrc.getChange().getStatus();
        boolean visible = isActionAllowed(status) && rsrc.getControl().canDelete(db.get(), status);
        return new UiAction.Description().setLabel("Delete").setTitle("Delete change " + rsrc.getId()).setVisible(visible);
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    try {
        Change.Status status = rsrc.getChange().getStatus();
        ChangeControl changeControl = rsrc.getControl();
        boolean visible = isActionAllowed(changeControl, status) && changeControl.canDelete(db.get(), status);
        return new UiAction.Description().setLabel("Delete").setTitle("Delete change " + rsrc.getId()).setVisible(visible);
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
private boolean isActionAllowed(Change.Status status) {
    return status != Status.DRAFT || allowDrafts;
}
#method_after
private boolean isActionAllowed(ChangeControl changeControl, Status status) {
    return status != Status.DRAFT || allowDrafts || changeControl.isAdmin();
}
#end_block

#method_before
@Test
public void deleteDraftChangeWithNonDraftPatchSet() throws Exception {
    assume().that(isAllowDrafts()).isTrue();
    PushOneCommit.Result changeResult = createDraftChange();
    Change.Id id = changeResult.getChange().getId();
    setDraftStatusOfPatchSetsOfChange(id, false);
    String changeId = changeResult.getChangeId();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Cannot delete draft change 1: patch set 1 is not" + " a draft");
    gApi.changes().id(changeId).delete();
}
#method_after
@Test
public void deleteDraftChangeWithNonDraftPatchSet() throws Exception {
    assume().that(isAllowDrafts()).isTrue();
    PushOneCommit.Result changeResult = createDraftChange();
    Change.Id id = changeResult.getChange().getId();
    setDraftStatusOfPatchSetsOfChange(id, false);
    String changeId = changeResult.getChangeId();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage(String.format("Cannot delete draft change %s: patch set 1 is not a draft", id));
    gApi.changes().id(changeId).delete();
}
#end_block

#method_before
private void markChangeAsDraft(Change.Id id) throws OrmException, RestApiException {
    Change change = db.changes().get(id);
    change.setStatus(Change.Status.DRAFT);
    db.changes().update(Collections.singletonList(change));
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(ChangeStatus.DRAFT);
}
#method_after
private void markChangeAsDraft(Change.Id id) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate batchUpdate = updateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new MarkChangeAsDraftUpdateOp());
        batchUpdate.execute();
    }
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(ChangeStatus.DRAFT);
}
#end_block

#method_before
private void setDraftStatusOfPatchSetsOfChange(Change.Id id, boolean draftStatus) throws OrmException {
    Set<PatchSet> patchSets = ImmutableSet.copyOf(db.patchSets().byChange(id));
    patchSets.forEach(patchSet -> patchSet.setDraft(draftStatus));
    db.patchSets().update(patchSets);
}
#method_after
private void setDraftStatusOfPatchSetsOfChange(Change.Id id, boolean draftStatus) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate batchUpdate = updateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new DraftStatusOfPatchSetsUpdateOp(draftStatus));
        batchUpdate.execute();
    }
    Boolean expectedDraftStatus = draftStatus ? Boolean.TRUE : null;
    List<Boolean> patchSetDraftStatuses = getPatchSetDraftStatuses(id);
    patchSetDraftStatuses.forEach(status -> assertThat(status).isEqualTo(expectedDraftStatus));
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteChangeOp");
    id = ctx.getChange().getId();
    ImmutableList<PatchSet> patchSets = ImmutableList.copyOf(psUtil.byChange(ctx.getDb(), ctx.getNotes()));
    ensureDeletable(ctx, id, patchSets);
    // Cleaning up is only possible as long as the change and its elements are
    // still part of the database.
    cleanUpReferences(ctx, id, patchSets);
    deleteChangeElementsFromDb(ctx, id);
    ctx.deleteChange();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteChangeOp");
    id = ctx.getChange().getId();
    Collection<PatchSet> patchSets = psUtil.byChange(ctx.getDb(), ctx.getNotes());
    ensureDeletable(ctx, id, patchSets);
    // Cleaning up is only possible as long as the change and its elements are
    // still part of the database.
    cleanUpReferences(ctx, id, patchSets);
    deleteChangeElementsFromDb(ctx, id);
    ctx.deleteChange();
    return true;
}
#end_block

#method_before
private void ensureDeletable(ChangeContext ctx, Change.Id id, List<PatchSet> patchSets) throws ResourceConflictException, MethodNotAllowedException, OrmException, AuthException {
    Change.Status status = ctx.getChange().getStatus();
    if (!ctx.getControl().canDelete(ctx.getDb(), status)) {
        throw new AuthException("Not permitted to delete this change");
    }
    if (status == Change.Status.DRAFT) {
        if (!allowDrafts) {
            throw new MethodNotAllowedException("Draft workflow is disabled");
        }
        for (PatchSet ps : patchSets) {
            if (!ps.isDraft()) {
                throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
            }
        }
    }
}
#method_after
private void ensureDeletable(ChangeContext ctx, Change.Id id, Collection<PatchSet> patchSets) throws ResourceConflictException, MethodNotAllowedException, OrmException, AuthException {
    Change.Status status = ctx.getChange().getStatus();
    if (status == Change.Status.MERGED) {
        throw new MethodNotAllowedException("Deleting merged change " + id + " is not allowed");
    }
    if (!ctx.getControl().canDelete(ctx.getDb(), status)) {
        throw new AuthException("Deleting change " + id + " is not permitted");
    }
    if (status == Change.Status.DRAFT) {
        if (!allowDrafts && !ctx.getControl().isAdmin()) {
            throw new MethodNotAllowedException("Draft workflow is disabled");
        }
        for (PatchSet ps : patchSets) {
            if (!ps.isDraft()) {
                throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
            }
        }
    }
}
#end_block

#method_before
private void cleanUpReferences(ChangeContext ctx, Change.Id id, List<PatchSet> patchSets) throws OrmException, NoSuchChangeException {
    for (PatchSet ps : patchSets) {
        accountPatchReviewStore.get().clearReviewed(ps.getId());
    }
    // Non-atomic operation on Accounts table; not much we can do to make it
    // atomic.
    starredChangesUtil.unstarAll(ctx.getChange().getProject(), id);
}
#method_after
private void cleanUpReferences(ChangeContext ctx, Change.Id id, Collection<PatchSet> patchSets) throws OrmException, NoSuchChangeException {
    for (PatchSet ps : patchSets) {
        accountPatchReviewStore.get().clearReviewed(ps.getId());
    }
    // Non-atomic operation on Accounts table; not much we can do to make it
    // atomic.
    starredChangesUtil.unstarAll(ctx.getChange().getProject(), id);
}
#end_block

#method_before
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return isOwner() || isAdmin();
        case MERGED:
            return isAdmin();
        default:
            return false;
    }
}
#method_after
public boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return (isOwner() || getRefControl().canDeleteDrafts());
        case NEW:
        case ABANDONED:
            return isAdmin();
        case MERGED:
        default:
            return false;
    }
}
#end_block

#method_before
public boolean isAdmin() {
    return getUser().isIdentifiedUser() && getUser().getCapabilities().canAdministrateServer();
}
#method_after
public boolean isAdmin() {
    return getUser().getCapabilities().canAdministrateServer();
}
#end_block

#method_before
@Test
public void deleteNewChangeOfAnotherUserAsAdmin() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    changeResult.assertOkStatus();
    String changeId = changeResult.getChangeId();
    gApi.changes().id(changeId).delete();
    assertThat(query(changeId)).isEmpty();
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteNewChangeOfAnotherUserAsAdmin() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    changeResult.assertOkStatus();
    String changeId = changeResult.getChangeId();
    setApiUser(admin);
    gApi.changes().id(changeId).delete();
    assertThat(query(changeId)).isEmpty();
}
#end_block

#method_before
@Test
public void deleteMergedChange() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    merge(changeResult);
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("Not permitted to delete this change");
    gApi.changes().id(changeId).delete();
}
#method_after
@Test
public void deleteMergedChange() throws Exception {
    PushOneCommit.Result changeResult = createChange();
    String changeId = changeResult.getChangeId();
    Change.Id id = changeResult.getChange().getId();
    merge(changeResult);
    exception.expect(MethodNotAllowedException.class);
    exception.expectMessage(String.format("Deleting merged change %s is not allowed", id));
    gApi.changes().id(changeId).delete();
}
#end_block

#method_before
public Set<String> stars(Account.Id accountId) throws OrmException {
    if (starsOf != null) {
        if (!starsOf.accountId().equals(accountId)) {
            starsOf = null;
        }
    }
    if (starsOf == null) {
        if (stars != null) {
            starsOf = StarsOf.create(accountId, ImmutableSet.copyOf(stars.get(accountId)));
        } else {
            if (!lazyLoad) {
                return ImmutableSet.of();
            }
            starsOf = StarsOf.create(accountId, starredChangesUtil.getLabels(accountId, legacyId));
        }
    }
    return starsOf.stars();
}
#method_after
public Set<String> stars(Account.Id accountId) throws OrmException {
    if (starsOf != null) {
        if (!starsOf.accountId().equals(accountId)) {
            starsOf = null;
        }
    }
    if (starsOf == null) {
        if (stars != null) {
            starsOf = StarsOf.create(accountId, stars.get(accountId));
        } else {
            if (!lazyLoad) {
                return ImmutableSet.of();
            }
            starsOf = StarsOf.create(accountId, starredChangesUtil.getLabels(accountId, legacyId));
        }
    }
    return starsOf.stars();
}
#end_block

#method_before
private static StarsOf create(Account.Id accountId, Set<String> stars) {
    return new AutoValue_ChangeData_StarsOf(accountId, stars);
}
#method_after
private static StarsOf create(Account.Id accountId, Iterable<String> stars) {
    return new AutoValue_ChangeData_StarsOf(accountId, ImmutableSortedSet.copyOf(stars));
}
#end_block

#method_before
@Test
public void addEmail() throws Exception {
    List<String> emails = ImmutableList.of("new.email@example.com", "new.email@example.systems", // Not in the list of TLDs but added to override in OutgoingEmailValidator
    "new.email@example.local");
    Set<String> currentEmails = getEmails();
    for (String email : emails) {
        assertThat(currentEmails).doesNotContain(email);
        EmailInput input = new EmailInput();
        input.email = email;
        input.noConfirmation = true;
        gApi.accounts().self().addEmail(input);
    }
    newApiUser();
    assertThat(getEmails()).containsAllIn(emails);
}
#method_after
@Test
public void addEmail() throws Exception {
    List<String> emails = ImmutableList.of("new.email@example.com", "new.email@example.systems", // Not in the list of TLDs but added to override in OutgoingEmailValidator
    "new.email@example.local");
    Set<String> currentEmails = getEmails();
    for (String email : emails) {
        assertThat(currentEmails).doesNotContain(email);
        EmailInput input = new EmailInput();
        input.email = email;
        input.noConfirmation = true;
        gApi.accounts().self().addEmail(input);
    }
    resetCurrentApiUser();
    assertThat(getEmails()).containsAllIn(emails);
}
#end_block

#method_before
@Test
public void deleteEmail() throws Exception {
    String email = "foo.bar@example.com";
    EmailInput input = new EmailInput();
    input.email = email;
    input.noConfirmation = true;
    gApi.accounts().self().addEmail(input);
    newApiUser();
    assertThat(getEmails()).contains(email);
    gApi.accounts().self().deleteEmail(input.email);
    newApiUser();
    assertThat(getEmails()).doesNotContain(email);
}
#method_after
@Test
public void deleteEmail() throws Exception {
    String email = "foo.bar@example.com";
    EmailInput input = new EmailInput();
    input.email = email;
    input.noConfirmation = true;
    gApi.accounts().self().addEmail(input);
    resetCurrentApiUser();
    assertThat(getEmails()).contains(email);
    gApi.accounts().self().deleteEmail(input.email);
    resetCurrentApiUser();
    assertThat(getEmails()).doesNotContain(email);
}
#end_block

#method_before
@Test
public void deleteEmailFromCustomExternalIdSchemes() throws Exception {
    String email = "foo.bar@example.com";
    String extId1 = "foo:bar";
    String extId2 = "foo:baz";
    db.accountExternalIds().insert(ImmutableList.of(createExternalIdWithEmail(extId1, email), createExternalIdWithEmail(extId2, email)));
    accountCache.evict(admin.id);
    assertThat(gApi.accounts().self().getExternalIds().stream().map(e -> e.identity).collect(toSet())).containsAllOf(extId1, extId2);
    newApiUser();
    assertThat(getEmails()).contains(email);
    gApi.accounts().self().deleteEmail(email);
    newApiUser();
    assertThat(getEmails()).doesNotContain(email);
    assertThat(gApi.accounts().self().getExternalIds().stream().map(e -> e.identity).collect(toSet())).containsNoneOf(extId1, extId2);
}
#method_after
@Test
public void deleteEmailFromCustomExternalIdSchemes() throws Exception {
    String email = "foo.bar@example.com";
    String extId1 = "foo:bar";
    String extId2 = "foo:baz";
    db.accountExternalIds().insert(ImmutableList.of(createExternalIdWithEmail(extId1, email), createExternalIdWithEmail(extId2, email)));
    accountCache.evict(admin.id);
    assertThat(gApi.accounts().self().getExternalIds().stream().map(e -> e.identity).collect(toSet())).containsAllOf(extId1, extId2);
    resetCurrentApiUser();
    assertThat(getEmails()).contains(email);
    gApi.accounts().self().deleteEmail(email);
    resetCurrentApiUser();
    assertThat(getEmails()).doesNotContain(email);
    assertThat(gApi.accounts().self().getExternalIds().stream().map(e -> e.identity).collect(toSet())).containsNoneOf(extId1, extId2);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, UnprocessableEntityException {
    changeControl = ctx.getControl();
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (patchSet == null) {
        throw new OrmException("patch set not found: " + psId);
    }
    String changeMsg = "Patch Set " + psId.get() + ":";
    if (parsedComments.get(0).type == MailComment.CommentType.CHANGE_MESSAGE) {
        if (parsedComments.size() > 1) {
            changeMsg += "\n" + numComments(parsedComments.size() - 1);
        }
        changeMsg += "\n" + parsedComments.get(0).message;
    } else {
        changeMsg += "\n" + numComments(parsedComments.size());
    }
    changeMessage = ChangeMessagesUtil.newMessage(ctx, changeMsg, tag);
    changeMessagesUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    comments = new ArrayList<>();
    for (MailComment c : parsedComments) {
        if (c.type == MailComment.CommentType.CHANGE_MESSAGE) {
            continue;
        }
        String fileName;
        // The patch set that this comment is based on is different if this
        // comment was sent in reply to a comment on a previous patch set.
        PatchSet psForComment;
        Side side;
        if (c.inReplyTo != null) {
            fileName = c.inReplyTo.key.filename;
            psForComment = psUtil.get(ctx.getDb(), ctx.getNotes(), new PatchSet.Id(ctx.getChange().getId(), c.inReplyTo.key.patchSetId));
            side = Side.fromShort(c.inReplyTo.side);
        } else {
            fileName = c.fileName;
            psForComment = patchSet;
            side = Side.REVISION;
        }
        Comment comment = commentsUtil.newComment(ctx, fileName, psForComment.getId(), (short) side.ordinal(), c.message, false, null);
        comment.tag = tag;
        if (c.inReplyTo != null) {
            comment.parentUuid = c.inReplyTo.key.uuid;
            comment.lineNbr = c.inReplyTo.lineNbr;
            comment.range = c.inReplyTo.range;
            comment.unresolved = c.inReplyTo.unresolved;
        }
        CommentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), psForComment);
        comments.add(comment);
    }
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), Status.PUBLISHED, comments);
    return true;
}
#method_after
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, UnprocessableEntityException {
    changeControl = ctx.getControl();
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (patchSet == null) {
        throw new OrmException("patch set not found: " + psId);
    }
    String changeMsg = "Patch Set " + psId.get() + ":";
    if (parsedComments.get(0).type == MailComment.CommentType.CHANGE_MESSAGE) {
        if (parsedComments.size() > 1) {
            changeMsg += "\n" + numComments(parsedComments.size() - 1);
        }
        changeMsg += "\n" + parsedComments.get(0).message;
    } else {
        changeMsg += "\n" + numComments(parsedComments.size());
    }
    changeMessage = ChangeMessagesUtil.newMessage(ctx, changeMsg, tag);
    changeMessagesUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    comments = new ArrayList<>();
    for (MailComment c : parsedComments) {
        if (c.type == MailComment.CommentType.CHANGE_MESSAGE) {
            continue;
        }
        String fileName;
        // The patch set that this comment is based on is different if this
        // comment was sent in reply to a comment on a previous patch set.
        PatchSet psForComment;
        Side side;
        if (c.inReplyTo != null) {
            fileName = c.inReplyTo.key.filename;
            psForComment = psUtil.get(ctx.getDb(), ctx.getNotes(), new PatchSet.Id(ctx.getChange().getId(), c.inReplyTo.key.patchSetId));
            side = Side.fromShort(c.inReplyTo.side);
        } else {
            fileName = c.fileName;
            psForComment = patchSet;
            side = Side.REVISION;
        }
        Comment comment = commentsUtil.newComment(ctx, fileName, psForComment.getId(), (short) side.ordinal(), c.message, false, null);
        comment.tag = tag;
        if (c.inReplyTo != null) {
            comment.parentUuid = c.inReplyTo.key.uuid;
            comment.lineNbr = c.inReplyTo.lineNbr;
            comment.range = c.inReplyTo.range;
            comment.unresolved = c.inReplyTo.unresolved;
        }
        CommentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), psForComment);
        comments.add(comment);
    }
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), Status.PUBLISHED, comments);
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    // Send email notifications
    outgoingMailFactory.create(NotifyHandling.ALL, ArrayListMultimap.create(), changeControl.getNotes(), patchSet, ctx.getUser().asIdentifiedUser(), changeMessage, comments, null, ImmutableList.of()).sendAsync();
    // Get previous approvals from this user
    Map<String, Short> approvals = new HashMap<>();
    approvalsUtil.byPatchSetUser(ctx.getDb(), changeControl, psId, ctx.getAccountId()).forEach(a -> approvals.put(a.getLabel(), a.getValue()));
    // Fire Gerrit event. Note that approvals can't be granted via email, so old and new approvals
    // are always the same here.
    commentAdded.fire(changeControl.getChange(), patchSet, ctx.getAccount(), changeMessage.getMessage(), approvals, approvals, ctx.getWhen());
}
#method_after
@Override
public void postUpdate(BatchUpdate.Context ctx) throws Exception {
    // Send email notifications
    outgoingMailFactory.create(NotifyHandling.ALL, ArrayListMultimap.create(), changeControl.getNotes(), patchSet, ctx.getUser().asIdentifiedUser(), changeMessage, comments, null, ImmutableList.of()).sendAsync();
    // Get previous approvals from this user
    Map<String, Short> approvals = new HashMap<>();
    approvalsUtil.byPatchSetUser(ctx.getDb(), changeControl, psId, ctx.getAccountId()).forEach(a -> approvals.put(a.getLabel(), a.getValue()));
    // Fire Gerrit event. Note that approvals can't be granted via email, so old and new approvals
    // are always the same here.
    commentAdded.fire(changeControl.getChange(), patchSet, ctx.getAccount(), changeMessage.getMessage(), approvals, approvals, ctx.getWhen());
}
#end_block

#method_before
public void sendAsync() {
    sendEmailsExecutor.submit(this);
}
#method_after
public void sendAsync() {
    @SuppressWarnings("unused")
    Future<?> possiblyIgnoredError = sendEmailsExecutor.submit(this);
}
#end_block

#method_before
@Test
public void sendNotificationAfterPersistingComments() throws Exception {
    String changeId = createChangeWithReview();
    ChangeInfo changeInfo = gApi.changes().id(changeId).get();
    List<CommentInfo> comments = gApi.changes().id(changeId).current().commentsAsList();
    String ts = MailUtil.rfcDateformatter.format(ZonedDateTime.ofInstant(comments.get(0).updated.toInstant(), ZoneId.of("UTC")));
    // Build Message
    MailMessage.Builder b = messageBuilderWithDefaultFields();
    b.from(user.emailAddress);
    String txt = newPlaintextBody(canonicalWebUrl.get() + "#/c/" + changeInfo._number + "/1", "Test Message", null, null, null);
    b.textContent(txt + textFooterForChange(changeId, ts));
    sender.clear();
    mailProcessor.process(b.build());
    assertNotifyTo(admin);
}
#method_after
@Test
public void sendNotificationAfterPersistingComments() throws Exception {
    String changeId = createChangeWithReview();
    ChangeInfo changeInfo = gApi.changes().id(changeId).get();
    List<CommentInfo> comments = gApi.changes().id(changeId).current().commentsAsList();
    assertThat(comments).hasSize(2);
    String ts = MailUtil.rfcDateformatter.format(ZonedDateTime.ofInstant(comments.get(0).updated.toInstant(), ZoneId.of("UTC")));
    // Build Message
    String txt = newPlaintextBody(canonicalWebUrl.get() + "#/c/" + changeInfo._number + "/1", "Test Message", null, null, null);
    MailMessage.Builder b = messageBuilderWithDefaultFields().from(user.emailAddress).textContent(txt + textFooterForChange(changeId, ts));
    sender.clear();
    mailProcessor.process(b.build());
    assertNotifyTo(admin);
}
#end_block

#method_before
@Override
protected void configureServlets() {
    PluginConfig cfg = cfgFactory.getFromGerritConfig(pluginName + GoogleOAuthService.CONFIG_SUFFIX);
    if (cfg.getString(InitOAuth.CLIENT_ID) != null) {
        bind(OAuthServiceProvider.class).annotatedWith(Exports.named(GoogleOAuthService.CONFIG_SUFFIX)).to(GoogleOAuthService.class);
    }
    cfg = cfgFactory.getFromGerritConfig(pluginName + GitHubOAuthService.CONFIG_SUFFIX);
    if (cfg.getString("client-id") != null) {
        bind(OAuthServiceProvider.class).annotatedWith(Exports.named(GitHubOAuthService.CONFIG_SUFFIX)).to(GitHubOAuthService.class);
    }
    cfg = cfgFactory.getFromGerritConfig(pluginName + BitbucketOAuthService.CONFIG_SUFFIX);
    if (cfg.getString(InitOAuth.CLIENT_ID) != null) {
        bind(OAuthServiceProvider.class).annotatedWith(Exports.named(BitbucketOAuthService.CONFIG_SUFFIX)).to(BitbucketOAuthService.class);
    }
    cfg = cfgFactory.getFromGerritConfig(pluginName + CasOAuthService.CONFIG_SUFFIX);
    if (cfg.getString(InitOAuth.CLIENT_ID) != null) {
        bind(OAuthServiceProvider.class).annotatedWith(Exports.named(CasOAuthService.CONFIG_SUFFIX)).to(CasOAuthService.class);
    }
    cfg = cfgFactory.getFromGerritConfig(pluginName + FacebookOAuthService.CONFIG_SUFFIX);
    if (cfg.getString("client-id") != null) {
        bind(OAuthServiceProvider.class).annotatedWith(Exports.named(FacebookOAuthService.CONFIG_SUFFIX)).to(FacebookOAuthService.class);
    }
}
#method_after
@Override
protected void configureServlets() {
    PluginConfig cfg = cfgFactory.getFromGerritConfig(pluginName + GoogleOAuthService.CONFIG_SUFFIX);
    if (cfg.getString(InitOAuth.CLIENT_ID) != null) {
        bind(OAuthServiceProvider.class).annotatedWith(Exports.named(GoogleOAuthService.CONFIG_SUFFIX)).to(GoogleOAuthService.class);
    }
    cfg = cfgFactory.getFromGerritConfig(pluginName + GitHubOAuthService.CONFIG_SUFFIX);
    if (cfg.getString("client-id") != null) {
        bind(OAuthServiceProvider.class).annotatedWith(Exports.named(GitHubOAuthService.CONFIG_SUFFIX)).to(GitHubOAuthService.class);
    }
    cfg = cfgFactory.getFromGerritConfig(pluginName + BitbucketOAuthService.CONFIG_SUFFIX);
    if (cfg.getString(InitOAuth.CLIENT_ID) != null) {
        bind(OAuthServiceProvider.class).annotatedWith(Exports.named(BitbucketOAuthService.CONFIG_SUFFIX)).to(BitbucketOAuthService.class);
    }
    cfg = cfgFactory.getFromGerritConfig(pluginName + CasOAuthService.CONFIG_SUFFIX);
    if (cfg.getString(InitOAuth.CLIENT_ID) != null) {
        bind(OAuthServiceProvider.class).annotatedWith(Exports.named(CasOAuthService.CONFIG_SUFFIX)).to(CasOAuthService.class);
    }
    cfg = cfgFactory.getFromGerritConfig(pluginName + FacebookOAuthService.CONFIG_SUFFIX);
    if (cfg.getString(InitOAuth.CLIENT_ID) != null) {
        bind(OAuthServiceProvider.class).annotatedWith(Exports.named(FacebookOAuthService.CONFIG_SUFFIX)).to(FacebookOAuthService.class);
    }
}
#end_block

#method_before
@Test
public void testVerifyAgainstDifferentOperation() throws Exception {
    String token = auth.generateToken("o", zeroId(), 1);
    assertThat(auth.verifyAgainstToken(token, "p", zeroId())).isFalse();
}
#method_after
@Test
public void testVerifyAgainstDifferentOperation() throws Exception {
    AuthInfo info = auth.generateAuthInfo("o", zeroId(), 1);
    assertThat(auth.verifyAuthInfo(info.authToken, "p", zeroId())).isFalse();
}
#end_block

#method_before
@Test
public void testVerifyAgainstDifferentObjectId() throws Exception {
    String token = auth.generateToken("o", zeroId(), 1);
    assertThat(auth.verifyAgainstToken(token, "o", LongObjectId.fromString("123456789012345678901234567890" + "123456789012345678901234567890" + "1234"))).isFalse();
}
#method_after
@Test
public void testVerifyAgainstDifferentObjectId() throws Exception {
    AuthInfo info = auth.generateAuthInfo("o", zeroId(), 1);
    assertThat(auth.verifyAuthInfo(info.authToken, "o", LongObjectId.fromString("123456789012345678901234567890" + "123456789012345678901234567890" + "1234"))).isFalse();
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    AccountApi.getExternalIds(new GerritCallback<JsArray<ExternalIdInfo>>() {

        @Override
        public void onSuccess(JsArray<ExternalIdInfo> results) {
            display();
            identites.display(results);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    AccountApi.getExternalIds(new GerritCallback<JsArray<ExternalIdInfo>>() {

        @Override
        public void onSuccess(JsArray<ExternalIdInfo> results) {
            identites.display(results);
            display();
        }
    });
}
#end_block

#method_before
void display(final JsArray<ExternalIdInfo> results) {
    List<ExternalIdInfo> idList = Natives.asList(results);
    Collections.sort(idList, new Comparator<ExternalIdInfo>() {

        @Override
        public int compare(ExternalIdInfo a, ExternalIdInfo b) {
            return emailOf(a).compareTo(emailOf(b));
        }

        private String emailOf(final ExternalIdInfo a) {
            return a.emailAddress() != null ? a.emailAddress() : "";
        }
    });
    while (1 < table.getRowCount()) {
        table.removeRow(table.getRowCount() - 1);
    }
    for (final ExternalIdInfo k : idList) {
        addOneId(k);
    }
    updateDeleteButton();
}
#method_after
void display(final JsArray<ExternalIdInfo> results) {
    List<ExternalIdInfo> idList = Natives.asList(results);
    Collections.sort(idList);
    while (1 < table.getRowCount()) {
        table.removeRow(table.getRowCount() - 1);
    }
    for (final ExternalIdInfo k : idList) {
        addOneId(k);
    }
    updateDeleteButton();
}
#end_block

#method_before
void addOneId(final ExternalIdInfo k) {
    if (ExternalIdScheme.isScheme(k.identity(), ExternalIdScheme.SCHEME_USERNAME)) {
        // Don't display the username as an identity here.
        return;
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    final int row = table.getRowCount();
    table.insertRow(row);
    applyDataRowStyle(row);
    if (k.canDelete()) {
        final CheckBox sel = new CheckBox();
        sel.addValueChangeHandler(updateDeleteHandler);
        table.setWidget(row, 1, sel);
    } else {
        table.setText(row, 1, "");
    }
    if (k.trusted()) {
        table.setText(row, 2, "");
    } else {
        table.setText(row, 2, Util.C.untrustedProvider());
        fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().identityUntrustedExternalId());
    }
    if (k.emailAddress() != null && k.emailAddress().length() > 0) {
        table.setText(row, 3, k.emailAddress());
    } else {
        table.setText(row, 3, "");
    }
    table.setText(row, 4, describe(k));
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#method_after
void addOneId(final ExternalIdInfo k) {
    if (k.isUsername()) {
        // Don't display the username as an identity here.
        return;
    }
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    final int row = table.getRowCount();
    table.insertRow(row);
    applyDataRowStyle(row);
    if (k.canDelete()) {
        final CheckBox sel = new CheckBox();
        sel.addValueChangeHandler(updateDeleteHandler);
        table.setWidget(row, 1, sel);
    } else {
        table.setText(row, 1, "");
    }
    if (k.isTrusted()) {
        table.setText(row, 2, "");
    } else {
        table.setText(row, 2, Util.C.untrustedProvider());
        fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().identityUntrustedExternalId());
    }
    if (k.emailAddress() != null && k.emailAddress().length() > 0) {
        table.setText(row, 3, k.emailAddress());
    } else {
        table.setText(row, 3, "");
    }
    table.setText(row, 4, k.describe());
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, k);
}
#end_block

#method_before
@Test
public void submitWithRebaseMergeCommit() throws Exception {
    /*
        *  (HEAD, origin/master, origin/HEAD) Merge changes X,Y
        |\
        | *   Merge branch 'master' into origin/master
        | |\
        | | * SHA Added a
        | |/
        * | Before
        |/
        * Initial empty repository
     */
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange("Added a", "a.txt", "");
    PushOneCommit change2Push = pushFactory.create(db, admin.getIdent(), testRepo, "Merge to master", "m.txt", "");
    change2Push.setParents(ImmutableList.of(initialHead, change1.getCommit()));
    PushOneCommit.Result change2 = change2Push.to("refs/for/master");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Before", "b.txt", "");
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    submit(change2.getChangeId());
    RevCommit newHead = getRemoteHead();
    assertThat(newHead.getParentCount()).isEqualTo(2);
    RevCommit headParent1 = parse(newHead.getParent(0).getId());
    RevCommit headParent2 = parse(newHead.getParent(1).getId());
    if (getSubmitType() == SubmitType.REBASE_ALWAYS) {
        assertCurrentRevision(change3.getChangeId(), 2, headParent1.getId());
    } else {
        assertThat(change3.getCommit().getId()).isEqualTo(headParent1.getId());
    }
    assertThat(headParent1.getParentCount()).isEqualTo(1);
    assertThat(headParent1.getParent(0)).isEqualTo(initialHead);
    assertThat(headParent2.getId()).isEqualTo(change2.getCommit().getId());
    assertThat(headParent2.getParentCount()).isEqualTo(2);
    RevCommit headGrandparent1 = parse(headParent2.getParent(0).getId());
    RevCommit headGrandparent2 = parse(headParent2.getParent(1).getId());
    assertThat(headGrandparent1.getId()).isEqualTo(initialHead.getId());
    assertThat(headGrandparent2.getId()).isEqualTo(change1.getCommit().getId());
}
#method_after
@Test
public void submitWithRebaseMergeCommit() throws Exception {
    /*
       *  (HEAD, origin/master, origin/HEAD) Merge changes X,Y
       |\
       | *   Merge branch 'master' into origin/master
       | |\
       | | * SHA Added a
       | |/
       * | Before
       |/
       * Initial empty repository
    */
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange("Added a", "a.txt", "");
    PushOneCommit change2Push = pushFactory.create(db, admin.getIdent(), testRepo, "Merge to master", "m.txt", "");
    change2Push.setParents(ImmutableList.of(initialHead, change1.getCommit()));
    PushOneCommit.Result change2 = change2Push.to("refs/for/master");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Before", "b.txt", "");
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    submit(change2.getChangeId());
    RevCommit newHead = getRemoteHead();
    assertThat(newHead.getParentCount()).isEqualTo(2);
    RevCommit headParent1 = parse(newHead.getParent(0).getId());
    RevCommit headParent2 = parse(newHead.getParent(1).getId());
    if (getSubmitType() == SubmitType.REBASE_ALWAYS) {
        assertCurrentRevision(change3.getChangeId(), 2, headParent1.getId());
    } else {
        assertThat(change3.getCommit().getId()).isEqualTo(headParent1.getId());
    }
    assertThat(headParent1.getParentCount()).isEqualTo(1);
    assertThat(headParent1.getParent(0)).isEqualTo(initialHead);
    assertThat(headParent2.getId()).isEqualTo(change2.getCommit().getId());
    assertThat(headParent2.getParentCount()).isEqualTo(2);
    RevCommit headGrandparent1 = parse(headParent2.getParent(0).getId());
    RevCommit headGrandparent2 = parse(headParent2.getParent(1).getId());
    assertThat(headGrandparent1.getId()).isEqualTo(initialHead.getId());
    assertThat(headGrandparent2.getId()).isEqualTo(change1.getCommit().getId());
}
#end_block

#method_before
@UiHandler("publish")
void onPublish(@SuppressWarnings("unused") ClickEvent e) {
    DraftActions.publish(changeId, revision, publish, deleteRevision);
}
#method_after
@UiHandler("publish")
void onPublish(@SuppressWarnings("unused") ClickEvent e) {
    ChangeActions.publish(changeId, revision, publish, deleteRevision);
}
#end_block

#method_before
@UiHandler("deleteRevision")
void onDeleteRevision(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftRevision())) {
        DraftActions.delete(changeId, revision, publish, deleteRevision);
    }
}
#method_after
@UiHandler("deleteRevision")
void onDeleteRevision(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftRevision())) {
        ChangeActions.delete(changeId, revision, publish, deleteRevision);
    }
}
#end_block

#method_before
@UiHandler("deleteChange")
void onDeleteChange(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteChange())) {
        DraftActions.delete(changeId, deleteChange);
    }
}
#method_after
@UiHandler("deleteChange")
void onDeleteChange(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteChange())) {
        ChangeActions.delete(changeId, deleteChange);
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    String url = Gerrit.info().auth().httpPasswordUrl();
    if (url != null) {
        Anchor link = new Anchor();
        link.setText(Util.C.linkObtainPassword());
        link.setHref(url);
        link.setTarget("_blank");
        add(link);
        return;
    }
    password = new CopyableLabel("");
    password.addStyleName(Gerrit.RESOURCES.css().accountPassword());
    generatePassword = new Button(Util.C.buttonGeneratePassword());
    generatePassword.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doGeneratePassword();
        }
    });
    final Grid userInfo = new Grid(2, 2);
    final CellFormatter fmt = userInfo.getCellFormatter();
    userInfo.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    userInfo.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    add(userInfo);
    row(userInfo, 0, Util.C.userName(), new UsernameField());
    row(userInfo, 1, Util.C.password(), password);
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel buttons = new FlowPanel();
    buttons.add(generatePassword);
    add(buttons);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    String url = Gerrit.info().auth().httpPasswordUrl();
    if (url != null) {
        Anchor link = new Anchor();
        link.setText(Util.C.linkObtainPassword());
        link.setHref(url);
        link.setTarget("_blank");
        add(link);
        return;
    }
    password = new CopyableLabel("(click 'generate' to revoke an old password)");
    password.addStyleName(Gerrit.RESOURCES.css().accountPassword());
    generatePassword = new Button(Util.C.buttonGeneratePassword());
    generatePassword.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doGeneratePassword();
        }
    });
    final Grid userInfo = new Grid(2, 2);
    final CellFormatter fmt = userInfo.getCellFormatter();
    userInfo.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    userInfo.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    add(userInfo);
    row(userInfo, 0, Util.C.userName(), new UsernameField());
    row(userInfo, 1, Util.C.password(), password);
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel buttons = new FlowPanel();
    buttons.add(generatePassword);
    add(buttons);
}
#end_block

#method_before
private void enableUI(boolean on) {
    on &= Gerrit.getUserAccount().username() != null;
    generatePassword.setEnabled(on);
    clearPassword.setVisible(on && !"".equals(password.getText()));
}
#method_after
private void enableUI(boolean on) {
    on &= Gerrit.getUserAccount().username() != null;
    generatePassword.setEnabled(on);
}
#end_block

#method_before
@Override
protected void addToString(ToStringHelper helper) {
    helper.addValue(psa);
}
#method_after
@Override
protected void addToString(ToStringHelper helper) {
    helper.add("approval", psa);
}
#end_block

#method_before
public static MailMetadata parse(MailMessage m) {
    MailMetadata metadata = new MailMetadata();
    // Find author
    metadata.author = m.from().getEmail();
    // Check email headers for X-Gerrit-<Name>
    for (String header : m.additionalHeaders()) {
        if (header.startsWith(toHeaderWithDelimiter(MetadataName.CHANGE_ID))) {
            metadata.changeId = header.substring(toHeaderWithDelimiter(MetadataName.CHANGE_ID).length());
        } else if (header.startsWith(toHeaderWithDelimiter(MetadataName.PATCH_SET))) {
            String ps = header.substring(toHeaderWithDelimiter(MetadataName.PATCH_SET).length());
            metadata.patchSet = Ints.tryParse(ps);
        } else if (header.startsWith(toHeaderWithDelimiter(MetadataName.TIMESTAMP))) {
            String ts = header.substring(toHeaderWithDelimiter(MetadataName.TIMESTAMP).length()).trim();
            try {
                metadata.timestamp = Timestamp.from(MailUtil.rfcDateformatter.parse(ts, Instant::from));
            } catch (DateTimeParseException e) {
                log.error("Error while parsing timestamp from email header", e);
            }
        } else if (header.startsWith(toHeaderWithDelimiter(MetadataName.MESSAGE_TYPE))) {
            metadata.messageType = header.substring(toHeaderWithDelimiter(MetadataName.MESSAGE_TYPE).length());
        }
    }
    if (metadata.hasRequiredFields()) {
        return metadata;
    }
    // If the required fields were not yet found, continue to parse the text
    if (!Strings.isNullOrEmpty(m.textContent())) {
        String[] lines = m.textContent().split("\n");
        extractFooters(lines, metadata);
        if (metadata.hasRequiredFields()) {
            return metadata;
        }
    }
    // HTML footer are contained inside a <p> tag
    if (!Strings.isNullOrEmpty(m.htmlContent())) {
        String[] lines = m.htmlContent().split("</p>");
        extractFooters(lines, metadata);
        if (metadata.hasRequiredFields()) {
            return metadata;
        }
    }
    return metadata;
}
#method_after
public static MailMetadata parse(MailMessage m) {
    MailMetadata metadata = new MailMetadata();
    // Find author
    metadata.author = m.from().getEmail();
    // Check email headers for X-Gerrit-<Name>
    for (String header : m.additionalHeaders()) {
        if (header.startsWith(toHeaderWithDelimiter(MetadataName.CHANGE_ID))) {
            metadata.changeId = header.substring(toHeaderWithDelimiter(MetadataName.CHANGE_ID).length());
        } else if (header.startsWith(toHeaderWithDelimiter(MetadataName.PATCH_SET))) {
            String ps = header.substring(toHeaderWithDelimiter(MetadataName.PATCH_SET).length());
            metadata.patchSet = Ints.tryParse(ps);
        } else if (header.startsWith(toHeaderWithDelimiter(MetadataName.TIMESTAMP))) {
            String ts = header.substring(toHeaderWithDelimiter(MetadataName.TIMESTAMP).length()).trim();
            try {
                metadata.timestamp = Timestamp.from(MailUtil.rfcDateformatter.parse(ts, Instant::from));
            } catch (DateTimeParseException e) {
                log.error("Mail: Error while parsing timestamp from header of message " + m.id(), e);
            }
        } else if (header.startsWith(toHeaderWithDelimiter(MetadataName.MESSAGE_TYPE))) {
            metadata.messageType = header.substring(toHeaderWithDelimiter(MetadataName.MESSAGE_TYPE).length());
        }
    }
    if (metadata.hasRequiredFields()) {
        return metadata;
    }
    // If the required fields were not yet found, continue to parse the text
    if (!Strings.isNullOrEmpty(m.textContent())) {
        String[] lines = m.textContent().replace("\r\n", "\n").split("\n");
        extractFooters(lines, metadata, m);
        if (metadata.hasRequiredFields()) {
            return metadata;
        }
    }
    // HTML footer are contained inside a <div> tag
    if (!Strings.isNullOrEmpty(m.htmlContent())) {
        String[] lines = m.htmlContent().replace("\r\n", "\n").split("</div>");
        extractFooters(lines, metadata, m);
        if (metadata.hasRequiredFields()) {
            return metadata;
        }
    }
    return metadata;
}
#end_block

#method_before
private static void extractFooters(String[] lines, MailMetadata metadata) {
    for (String line : lines) {
        if (metadata.changeId == null && line.contains(MetadataName.CHANGE_ID)) {
            metadata.changeId = extractFooter(toFooterWithDelimiter(MetadataName.CHANGE_ID), line);
        } else if (metadata.patchSet == null && line.contains(MetadataName.PATCH_SET)) {
            metadata.patchSet = Ints.tryParse(extractFooter(toFooterWithDelimiter(MetadataName.PATCH_SET), line));
        } else if (metadata.timestamp == null && line.contains(MetadataName.TIMESTAMP)) {
            String ts = extractFooter(toFooterWithDelimiter(MetadataName.TIMESTAMP), line);
            try {
                metadata.timestamp = Timestamp.from(MailUtil.rfcDateformatter.parse(ts, Instant::from));
            } catch (DateTimeParseException e) {
                log.error("Error while parsing timestamp from email footer: " + e);
            }
        } else if (metadata.messageType == null && line.contains(MetadataName.MESSAGE_TYPE)) {
            metadata.messageType = extractFooter(toFooterWithDelimiter(MetadataName.MESSAGE_TYPE), line);
        }
    }
}
#method_after
private static void extractFooters(String[] lines, MailMetadata metadata, MailMessage m) {
    for (String line : lines) {
        if (metadata.changeId == null && line.contains(MetadataName.CHANGE_ID)) {
            metadata.changeId = extractFooter(toFooterWithDelimiter(MetadataName.CHANGE_ID), line);
        } else if (metadata.patchSet == null && line.contains(MetadataName.PATCH_SET)) {
            metadata.patchSet = Ints.tryParse(extractFooter(toFooterWithDelimiter(MetadataName.PATCH_SET), line));
        } else if (metadata.timestamp == null && line.contains(MetadataName.TIMESTAMP)) {
            String ts = extractFooter(toFooterWithDelimiter(MetadataName.TIMESTAMP), line);
            try {
                metadata.timestamp = Timestamp.from(MailUtil.rfcDateformatter.parse(ts, Instant::from));
            } catch (DateTimeParseException e) {
                log.error("Mail: Error while parsing timestamp from footer of message " + m.id(), e);
            }
        } else if (metadata.messageType == null && line.contains(MetadataName.MESSAGE_TYPE)) {
            metadata.messageType = extractFooter(toFooterWithDelimiter(MetadataName.MESSAGE_TYPE), line);
        }
    }
}
#end_block

#method_before
@Test
public void diffChangesIgnoresLeadingAndTrailingWhitespaceInReviewDbTopics() throws Exception {
    Change c1 = TestChanges.newChange(new Project.NameKey("project"), new Account.Id(100));
    c1.setTopic(" abc ");
    Change c2 = clone(c1);
    c2.setTopic("abc");
    // Both ReviewDb, exact match required.
    ChangeBundle b1 = new ChangeBundle(c1, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    ChangeBundle b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "topic differs for Change.Id " + c1.getId() + ":" + " { abc } != {abc}");
    // Leading whitespace in ReviewDb topic is ignored.
    b1 = new ChangeBundle(c1, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), NOTE_DB);
    assertNoDiffs(b1, b2);
    assertNoDiffs(b2, b1);
    // Must match except for the leading whitespace.
    Change c3 = clone(c1);
    c3.setTopic("cba");
    b1 = new ChangeBundle(c1, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c3, messages(), patchSets(), approvals(), comments(), reviewers(), NOTE_DB);
    assertDiffs(b1, b2, "topic differs for Change.Id " + c1.getId() + ":" + " { abc } != {cba}");
}
#method_after
@Test
public void diffChangesIgnoresLeadingAndTrailingWhitespaceInReviewDbTopics() throws Exception {
    Change c1 = TestChanges.newChange(new Project.NameKey("project"), new Account.Id(100));
    c1.setTopic(" abc ");
    Change c2 = clone(c1);
    c2.setTopic("abc");
    // Both ReviewDb, exact match required.
    ChangeBundle b1 = new ChangeBundle(c1, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    ChangeBundle b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "topic differs for Change.Id " + c1.getId() + ":" + " { abc } != {abc}");
    // Leading whitespace in ReviewDb topic is ignored.
    b1 = new ChangeBundle(c1, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), NOTE_DB);
    assertNoDiffs(b1, b2);
    assertNoDiffs(b2, b1);
    // Must match except for the leading/trailing whitespace.
    Change c3 = clone(c1);
    c3.setTopic("cba");
    b1 = new ChangeBundle(c1, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c3, messages(), patchSets(), approvals(), comments(), reviewers(), NOTE_DB);
    assertDiffs(b1, b2, "topic differs for Change.Id " + c1.getId() + ":" + " { abc } != {cba}");
}
#end_block

#method_before
@Test
public void diffPatchSetsIgnoresLeadingAndTrailingWhitespaceInReviewDbDescriptions() throws Exception {
    Change c = TestChanges.newChange(project, accountId);
    PatchSet ps1 = new PatchSet(new PatchSet.Id(c.getId(), 1));
    ps1.setRevision(new RevId("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"));
    ps1.setUploader(accountId);
    ps1.setCreatedOn(TimeUtil.nowTs());
    ps1.setDescription(" abc ");
    PatchSet ps2 = clone(ps1);
    ps2.setDescription("abc");
    // Both ReviewDb, exact match required.
    ChangeBundle b1 = new ChangeBundle(c, messages(), patchSets(ps1), approvals(), comments(), reviewers(), REVIEW_DB);
    ChangeBundle b2 = new ChangeBundle(c, messages(), patchSets(ps2), approvals(), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "description differs for PatchSet.Id " + ps1.getId() + ":" + " { abc } != {abc}");
    // Whitespace in ReviewDb description is ignored.
    b1 = new ChangeBundle(c, messages(), patchSets(ps1), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c, messages(), patchSets(ps2), approvals(), comments(), reviewers(), NOTE_DB);
    assertNoDiffs(b1, b2);
    assertNoDiffs(b2, b1);
    // Must match except for the leading whitespace.
    PatchSet ps3 = clone(ps1);
    ps3.setDescription("cba");
    b1 = new ChangeBundle(c, messages(), patchSets(ps1), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c, messages(), patchSets(ps3), approvals(), comments(), reviewers(), NOTE_DB);
    assertDiffs(b1, b2, "description differs for PatchSet.Id " + ps1.getId() + ":" + " { abc } != {cba}");
}
#method_after
@Test
public void diffPatchSetsIgnoresLeadingAndTrailingWhitespaceInReviewDbDescriptions() throws Exception {
    Change c = TestChanges.newChange(project, accountId);
    PatchSet ps1 = new PatchSet(new PatchSet.Id(c.getId(), 1));
    ps1.setRevision(new RevId("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"));
    ps1.setUploader(accountId);
    ps1.setCreatedOn(TimeUtil.nowTs());
    ps1.setDescription(" abc ");
    PatchSet ps2 = clone(ps1);
    ps2.setDescription("abc");
    // Both ReviewDb, exact match required.
    ChangeBundle b1 = new ChangeBundle(c, messages(), patchSets(ps1), approvals(), comments(), reviewers(), REVIEW_DB);
    ChangeBundle b2 = new ChangeBundle(c, messages(), patchSets(ps2), approvals(), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "description differs for PatchSet.Id " + ps1.getId() + ":" + " { abc } != {abc}");
    // Whitespace in ReviewDb description is ignored.
    b1 = new ChangeBundle(c, messages(), patchSets(ps1), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c, messages(), patchSets(ps2), approvals(), comments(), reviewers(), NOTE_DB);
    assertNoDiffs(b1, b2);
    assertNoDiffs(b2, b1);
    // Must match except for the leading/trailing whitespace.
    PatchSet ps3 = clone(ps1);
    ps3.setDescription("cba");
    b1 = new ChangeBundle(c, messages(), patchSets(ps1), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c, messages(), patchSets(ps3), approvals(), comments(), reviewers(), NOTE_DB);
    assertDiffs(b1, b2, "description differs for PatchSet.Id " + ps1.getId() + ":" + " { abc } != {cba}");
}
#end_block

#method_before
@Override
protected Change.Id updateProjectConfig(CurrentUser user, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, OrmException {
    md.setInsertChangeId(true);
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
    if (commit.getId().equals(base)) {
        return null;
    }
    try (RevWalk rw = new RevWalk(md.getRepository());
        ObjectInserter objInserter = md.getRepository().newObjectInserter();
        BatchUpdate bu = updateFactory.create(db, config.getProject().getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(md.getRepository(), rw, objInserter);
        bu.insertChange(changeInserterFactory.create(changeId, commit, RefNames.REFS_CONFIG).setValidatePolicy(CommitValidators.Policy.NONE).setUpdateRef(// Created by commitToNewRef.
        false));
        bu.execute();
    } catch (UpdateException | RestApiException e) {
        throw new IOException(e);
    }
    ChangeResource rsrc;
    try {
        rsrc = changes.parse(changeId);
    } catch (ResourceNotFoundException e) {
        throw new IOException(e);
    }
    addProjectOwnersAsReviewers(rsrc);
    if (parentProjectUpdate) {
        addAdministratorsAsReviewers(rsrc);
    }
    return changeId;
}
#method_after
@Override
protected Change.Id updateProjectConfig(ProjectControl projectControl, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, OrmException, PermissionDeniedException {
    RefControl refsMetaConfigControl = projectControl.controlForRef(RefNames.REFS_CONFIG);
    if (!refsMetaConfigControl.isVisible()) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!projectControl.isOwner() && !refsMetaConfigControl.canUpload()) {
        throw new PermissionDeniedException("cannot upload to " + RefNames.REFS_CONFIG);
    }
    md.setInsertChangeId(true);
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
    if (commit.getId().equals(base)) {
        return null;
    }
    try (RevWalk rw = new RevWalk(md.getRepository());
        ObjectInserter objInserter = md.getRepository().newObjectInserter();
        BatchUpdate bu = updateFactory.create(db, config.getProject().getNameKey(), projectControl.getUser(), TimeUtil.nowTs())) {
        bu.setRepository(md.getRepository(), rw, objInserter);
        bu.insertChange(changeInserterFactory.create(changeId, commit, RefNames.REFS_CONFIG).setValidatePolicy(CommitValidators.Policy.NONE).setUpdateRef(// Created by commitToNewRef.
        false));
        bu.execute();
    } catch (UpdateException | RestApiException e) {
        throw new IOException(e);
    }
    ChangeResource rsrc;
    try {
        rsrc = changes.parse(changeId);
    } catch (ResourceNotFoundException e) {
        throw new IOException(e);
    }
    addProjectOwnersAsReviewers(rsrc);
    if (parentProjectUpdate) {
        addAdministratorsAsReviewers(rsrc);
    }
    return changeId;
}
#end_block

#method_before
@Override
public RevisionApi current() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public RevisionApi current() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public RevisionApi revision(int id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public RevisionApi revision(int id) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ReviewerApi reviewer(String id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ReviewerApi reviewer(String id) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public RevisionApi revision(String id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public RevisionApi revision(String id) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void abandon() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void abandon() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void abandon(AbandonInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void restore() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void restore() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void restore(RestoreInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void move(String destination) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void move(String destination) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void move(MoveInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void move(MoveInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi revert() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi revert() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi revert(RevertInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void publish() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void publish() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void delete() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public String topic() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public String topic() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void topic(String topic) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void topic(String topic) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void addReviewer(AddReviewerInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void addReviewer(String in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void addReviewer(String in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SuggestedReviewersRequest suggestReviewers() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SuggestedReviewersRequest suggestReviewers(String query) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers(String query) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> options) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> options) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo get() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo get() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo info() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo info() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public EditInfo getEdit() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public EditInfo getEdit() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void setHashtags(HashtagsInput input) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Set<String> getHashtags() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Set<String> getHashtags() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountInfo setAssignee(AssigneeInput input) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public AccountInfo getAssignee() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountInfo getAssignee() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountInfo deleteAssignee() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo check() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo check() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo check(FixInput fix) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void index() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void index() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<ChangeInfo> submittedTogether() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<ChangeInfo> submittedTogether() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<SubmittedTogetherOption> options) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<SubmittedTogetherOption> options) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> a, EnumSet<SubmittedTogetherOption> b) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> a, EnumSet<SubmittedTogetherOption> b) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
protected void configure() {
    // Do NOT bind @RemotePeer, as it is bound in a child injector of
    // ChangeMergeQueue (bound via GerritGlobalModule below), so there cannot be
    // a binding in the parent injector. If you need @RemotePeer, you must bind
    // it in a child injector of the one containing InMemoryModule. But unless
    // you really need to test something request-scoped, you likely don't
    // actually need it.
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    install(new SearchingChangeCacheImpl.Module());
    factory(GarbageCollection.Factory.class);
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    // TODO(dborowitz): Use jimfs.
    bind(Path.class).annotatedWith(SitePath.class).toInstance(Paths.get("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(GerritOptions.class).toInstance(new GerritOptions(cfg, false, false, false));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(NotesMigration.class).toInstance(notesMigration);
    bind(ListeningExecutorService.class).annotatedWith(ChangeUpdateExecutor.class).toInstance(MoreExecutors.newDirectExecutorService());
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }).to(InMemoryDatabase.class);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    bind(SecureStore.class).to(DefaultSecureStore.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    // Replacement of DiffExecutorModule to not use thread pool in the tests
    install(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @DiffExecutor
        public ExecutorService createDiffExecutor() {
            return MoreExecutors.newDirectExecutorService();
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new FakeEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new GpgModule(cfg));
    install(new H2AccountPatchReviewStore.InMemoryModule());
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            case ELASTICSEARCH:
                install(elasticIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
}
#method_after
@Override
protected void configure() {
    // Do NOT bind @RemotePeer, as it is bound in a child injector of
    // ChangeMergeQueue (bound via GerritGlobalModule below), so there cannot be
    // a binding in the parent injector. If you need @RemotePeer, you must bind
    // it in a child injector of the one containing InMemoryModule. But unless
    // you really need to test something request-scoped, you likely don't
    // actually need it.
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    install(new SearchingChangeCacheImpl.Module());
    factory(GarbageCollection.Factory.class);
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    // TODO(dborowitz): Use jimfs.
    bind(Path.class).annotatedWith(SitePath.class).toInstance(Paths.get("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(GerritOptions.class).toInstance(new GerritOptions(cfg, false, false, false));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(NotesMigration.class).toInstance(notesMigration);
    bind(ListeningExecutorService.class).annotatedWith(ChangeUpdateExecutor.class).toInstance(MoreExecutors.newDirectExecutorService());
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }).to(InMemoryDatabase.class);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    bind(SecureStore.class).to(DefaultSecureStore.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    // Replacement of DiffExecutorModule to not use thread pool in the tests
    install(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @DiffExecutor
        public ExecutorService createDiffExecutor() {
            return MoreExecutors.newDirectExecutorService();
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new FakeEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new GpgModule(cfg));
    install(new H2AccountPatchReviewStore.InMemoryModule());
    bind(AllAccountsIndexer.class).toProvider(Providers.of(null));
    bind(AllChangesIndexer.class).toProvider(Providers.of(null));
    bind(AllGroupsIndexer.class).toProvider(Providers.of(null));
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            case ELASTICSEARCH:
                install(elasticIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
}
#end_block

#method_before
@Provides
@Singleton
InMemoryDatabase getInMemoryDatabase(SchemaCreator schemaCreator) throws OrmException {
    return new InMemoryDatabase(schemaCreator);
}
#method_after
@Provides
@Singleton
InMemoryDatabase getInMemoryDatabase(SchemaCreator schemaCreator, SingleVersionListener singleVersionListener) throws OrmException {
    return new InMemoryDatabase(schemaCreator, singleVersionListener);
}
#end_block

#method_before
@Override
public Object apply(TopLevelResource resource) {
    return display(null);
}
#method_after
@Override
public Object apply(TopLevelResource resource) {
    format = OutputFormat.JSON;
    return display(null);
}
#end_block

#method_before
public JsonElement display(PrintWriter stdout) {
    List<Plugin> plugins = Lists.newArrayList(pluginLoader.getPlugins(all));
    Collections.sort(plugins, new Comparator<Plugin>() {

        @Override
        public int compare(Plugin a, Plugin b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (stdout == null) {
        Map<String, PluginInfo> output = new TreeMap<>();
        for (Plugin p : plugins) {
            PluginInfo info = new PluginInfo(p);
            output.put(p.getName(), info);
        }
        return OutputFormat.JSON.newGson().toJsonTree(output, new TypeToken<Map<String, Object>>() {
        }.getType());
    }
    stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File");
    stdout.print("-------------------------------------------------------------------------------\n");
    for (Plugin p : plugins) {
        PluginInfo info = new PluginInfo(p);
        stdout.format("%-30s %-10s %-8s %s\n", p.getName(), Strings.nullToEmpty(info.version), p.isDisabled() ? "DISABLED" : "ENABLED", p.getSrcFile().getFileName());
        stdout.print('\n');
    }
    stdout.flush();
    return null;
}
#method_after
public JsonElement display(PrintWriter stdout) {
    Map<String, PluginInfo> output = new TreeMap<>();
    List<Plugin> plugins = Lists.newArrayList(pluginLoader.getPlugins(all));
    Collections.sort(plugins, new Comparator<Plugin>() {

        @Override
        public int compare(Plugin a, Plugin b) {
            return a.getName().compareTo(b.getName());
        }
    });
    if (!format.isJson()) {
        stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File");
        stdout.print("-------------------------------------------------------------------------------\n");
    }
    for (Plugin p : plugins) {
        PluginInfo info = new PluginInfo(p);
        if (format.isJson()) {
            output.put(p.getName(), info);
        } else {
            stdout.format("%-30s %-10s %-8s %s\n", p.getName(), Strings.nullToEmpty(info.version), p.isDisabled() ? "DISABLED" : "ENABLED", p.getSrcFile().getFileName());
        }
    }
    if (stdout == null) {
        return OutputFormat.JSON.newGson().toJsonTree(output, new TypeToken<Map<String, Object>>() {
        }.getType());
    } else if (format.isJson()) {
        format.newGson().toJson(output, new TypeToken<Map<String, PluginInfo>>() {
        }.getType(), stdout);
        stdout.print('\n');
    }
    stdout.flush();
    return null;
}
#end_block

#method_before
@Test
public void tagInlineCommenrts() throws Exception {
    String tag = "jenkins";
    Change c = newChange();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.setTag(tag);
    update.commit();
    ChangeNotes notes = newNotes(c);
    ImmutableListMultimap<RevId, Comment> comments = notes.getComments();
    assertThat(comments).hasSize(1);
    assertThat(comments.entries().asList().get(0).getValue().tag).isEqualTo(tag);
}
#method_after
@Test
public void tagInlineCommenrts() throws Exception {
    String tag = "jenkins";
    Change c = newChange();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name(), false));
    update.setTag(tag);
    update.commit();
    ChangeNotes notes = newNotes(c);
    ImmutableListMultimap<RevId, Comment> comments = notes.getComments();
    assertThat(comments).hasSize(1);
    assertThat(comments.entries().asList().get(0).getValue().tag).isEqualTo(tag);
}
#end_block

#method_before
@Test
public void multipleTags() throws Exception {
    String ipTag = "ip";
    String coverageTag = "coverage";
    String integrationTag = "integration";
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Verified", (short) -1);
    update.setChangeMessage("integration verification");
    update.setTag(integrationTag);
    update.commit();
    RevCommit commit = tr.commit().message("PS2").create();
    update = newUpdate(c, changeOwner);
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.setChangeMessage("coverage verification");
    update.setTag(coverageTag);
    update.commit();
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("ip clear");
    update.setTag(ipTag);
    update.commit();
    ChangeNotes notes = newNotes(c);
    ImmutableListMultimap<PatchSet.Id, PatchSetApproval> approvals = notes.getApprovals();
    assertThat(approvals).hasSize(1);
    PatchSetApproval approval = approvals.entries().asList().get(0).getValue();
    assertThat(approval.getTag()).isEqualTo(integrationTag);
    assertThat(approval.getValue()).isEqualTo(-1);
    ImmutableListMultimap<RevId, Comment> comments = notes.getComments();
    assertThat(comments).hasSize(1);
    assertThat(comments.entries().asList().get(0).getValue().tag).isEqualTo(coverageTag);
    ImmutableList<ChangeMessage> messages = notes.getChangeMessages();
    assertThat(messages).hasSize(3);
    assertThat(messages.get(0).getTag()).isEqualTo(integrationTag);
    assertThat(messages.get(1).getTag()).isEqualTo(coverageTag);
    assertThat(messages.get(2).getTag()).isEqualTo(ipTag);
}
#method_after
@Test
public void multipleTags() throws Exception {
    String ipTag = "ip";
    String coverageTag = "coverage";
    String integrationTag = "integration";
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Verified", (short) -1);
    update.setChangeMessage("integration verification");
    update.setTag(integrationTag);
    update.commit();
    RevCommit commit = tr.commit().message("PS2").create();
    update = newUpdate(c, changeOwner);
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name(), false));
    update.setChangeMessage("coverage verification");
    update.setTag(coverageTag);
    update.commit();
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("ip clear");
    update.setTag(ipTag);
    update.commit();
    ChangeNotes notes = newNotes(c);
    ImmutableListMultimap<PatchSet.Id, PatchSetApproval> approvals = notes.getApprovals();
    assertThat(approvals).hasSize(1);
    PatchSetApproval approval = approvals.entries().asList().get(0).getValue();
    assertThat(approval.getTag()).isEqualTo(integrationTag);
    assertThat(approval.getValue()).isEqualTo(-1);
    ImmutableListMultimap<RevId, Comment> comments = notes.getComments();
    assertThat(comments).hasSize(1);
    assertThat(comments.entries().asList().get(0).getValue().tag).isEqualTo(coverageTag);
    ImmutableList<ChangeMessage> messages = notes.getChangeMessages();
    assertThat(messages).hasSize(3);
    assertThat(messages.get(0).getTag()).isEqualTo(integrationTag);
    assertThat(messages.get(1).getTag()).isEqualTo(coverageTag);
    assertThat(messages.get(2).getTag()).isEqualTo(ipTag);
}
#end_block

#method_before
@Test
public void approvalsTombstone() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId().get()).isEqualTo(1);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApproval("Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).containsExactlyEntriesIn(ImmutableMultimap.of(psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen())));
}
#method_after
@Test
public void approvalsTombstone() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId().get()).isEqualTo(1);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApproval("Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).containsExactlyEntriesIn(ImmutableListMultimap.of(psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen())));
}
#end_block

#method_before
@Test
public void removeOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApprovalFor(otherUserId, "Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).containsExactlyEntriesIn(ImmutableMultimap.of(psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen())));
    // Add back approval on same label.
    update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 2);
    update.commit();
    notes = newNotes(c);
    psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 2);
}
#method_after
@Test
public void removeOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApprovalFor(otherUserId, "Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).containsExactlyEntriesIn(ImmutableListMultimap.of(psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen())));
    // Add back approval on same label.
    update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 2);
    update.commit();
    notes = newNotes(c);
    psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 2);
}
#end_block

#method_before
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementCurrentPatchSetFieldOnly(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.setPatchSetState(PatchSetState.DRAFT);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isTrue();
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isFalse();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#method_after
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementCurrentPatchSetFieldOnly(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.setPatchSetState(PatchSetState.DRAFT);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name(), false));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isTrue();
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isFalse();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#end_block

#method_before
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementCurrentPatchSetFieldOnly(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    if (!testJson()) {
        assertThat(note).isEqualTo(pushCert);
    }
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(Status.PUBLISHED, newComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
    if (!testJson()) {
        assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    }
}
#method_after
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementCurrentPatchSetFieldOnly(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    if (!testJson()) {
        assertThat(note).isEqualTo(pushCert);
    }
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(Status.PUBLISHED, newComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name(), false));
    update.commit();
    notes = newNotes(c);
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
    if (!testJson()) {
        assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "Unresolved: false\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    }
}
#end_block

#method_before
@Test
public void multipleUpdatesIncludingComments() throws Exception {
    Change c = newChange();
    ChangeUpdate update1 = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String message1 = "comment 1";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    RevCommit tipCommit;
    try (NoteDbUpdateManager updateManager = updateManagerFactory.create(project)) {
        Comment comment1 = newComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
        update1.setPatchSetId(psId);
        update1.putComment(Status.PUBLISHED, comment1);
        updateManager.add(update1);
        ChangeUpdate update2 = newUpdate(c, otherUser);
        update2.putApproval("Code-Review", (short) 2);
        updateManager.add(update2);
        updateManager.execute();
    }
    ChangeNotes notes = newNotes(c);
    ObjectId tip = notes.getRevision();
    tipCommit = rw.parseCommit(tip);
    RevCommit commitWithApprovals = tipCommit;
    assertThat(commitWithApprovals).isNotNull();
    RevCommit commitWithComments = commitWithApprovals.getParent(0);
    assertThat(commitWithComments).isNotNull();
    try (ChangeNotesRevWalk rw = ChangeNotesCommit.newRevWalk(repo)) {
        ChangeNotesParser notesWithComments = new ChangeNotesParser(c.getId(), commitWithComments.copy(), rw, noteUtil, args.metrics);
        ChangeNotesState state = notesWithComments.parseAll();
        assertThat(state.approvals()).isEmpty();
        assertThat(state.publishedComments()).hasSize(1);
    }
    try (ChangeNotesRevWalk rw = ChangeNotesCommit.newRevWalk(repo)) {
        ChangeNotesParser notesWithApprovals = new ChangeNotesParser(c.getId(), commitWithApprovals.copy(), rw, noteUtil, args.metrics);
        ChangeNotesState state = notesWithApprovals.parseAll();
        assertThat(state.approvals()).hasSize(1);
        assertThat(state.publishedComments()).hasSize(1);
    }
}
#method_after
@Test
public void multipleUpdatesIncludingComments() throws Exception {
    Change c = newChange();
    ChangeUpdate update1 = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String message1 = "comment 1";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    RevCommit tipCommit;
    try (NoteDbUpdateManager updateManager = updateManagerFactory.create(project)) {
        Comment comment1 = newComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234", false);
        update1.setPatchSetId(psId);
        update1.putComment(Status.PUBLISHED, comment1);
        updateManager.add(update1);
        ChangeUpdate update2 = newUpdate(c, otherUser);
        update2.putApproval("Code-Review", (short) 2);
        updateManager.add(update2);
        updateManager.execute();
    }
    ChangeNotes notes = newNotes(c);
    ObjectId tip = notes.getRevision();
    tipCommit = rw.parseCommit(tip);
    RevCommit commitWithApprovals = tipCommit;
    assertThat(commitWithApprovals).isNotNull();
    RevCommit commitWithComments = commitWithApprovals.getParent(0);
    assertThat(commitWithComments).isNotNull();
    try (ChangeNotesRevWalk rw = ChangeNotesCommit.newRevWalk(repo)) {
        ChangeNotesParser notesWithComments = new ChangeNotesParser(c.getId(), commitWithComments.copy(), rw, noteUtil, args.metrics);
        ChangeNotesState state = notesWithComments.parseAll();
        assertThat(state.approvals()).isEmpty();
        assertThat(state.publishedComments()).hasSize(1);
    }
    try (ChangeNotesRevWalk rw = ChangeNotesCommit.newRevWalk(repo)) {
        ChangeNotesParser notesWithApprovals = new ChangeNotesParser(c.getId(), commitWithApprovals.copy(), rw, noteUtil, args.metrics);
        ChangeNotesState state = notesWithApprovals.parseAll();
        assertThat(state.approvals()).hasSize(1);
        assertThat(state.publishedComments()).hasSize(1);
    }
}
#end_block

#method_before
@Test
public void patchLineCommentsFileComment() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    Comment comment = newComment(psId, "file1", "uuid", null, 0, otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#method_after
@Test
public void patchLineCommentsFileComment() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    Comment comment = newComment(psId, "file1", "uuid", null, 0, otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get(), false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableListMultimap.of(revId, comment));
}
#end_block

#method_before
@Test
public void patchLineCommentsZeroColumns() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 0, 2, 0);
    Comment comment = newComment(psId, "file1", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#method_after
@Test
public void patchLineCommentsZeroColumns() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 0, 2, 0);
    Comment comment = newComment(psId, "file1", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get(), false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableListMultimap.of(revId, comment));
}
#end_block

#method_before
@Test
public void patchLineCommentZeroRange() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(0, 0, 0, 0);
    Comment comment = newComment(psId, "file", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#method_after
@Test
public void patchLineCommentZeroRange() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(0, 0, 0, 0);
    Comment comment = newComment(psId, "file", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get(), false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableListMultimap.of(revId, comment));
}
#end_block

#method_before
@Test
public void patchLineCommentEmptyFilename() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 2, 3, 4);
    Comment comment = newComment(psId, "", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#method_after
@Test
public void patchLineCommentEmptyFilename() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 2, 3, 4);
    Comment comment = newComment(psId, "", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get(), false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableListMultimap.of(revId, comment));
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment1 = newComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Comment comment2 = newComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    Comment comment3 = newComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment1 = newComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234", false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Comment comment2 = newComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234", false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    Comment comment3 = newComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234", false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "Unresolved: false\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "Unresolved: false\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "Unresolved: false\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment1 = newComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Comment comment2 = newComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
        }
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment1 = newComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234", false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Comment comment2 = newComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234", false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "Unresolved: false\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "Unresolved: false\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    Comment comment1 = newComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    Comment comment2 = newComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    Comment comment3 = newComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(Status.PUBLISHED, comment3);
    update.putComment(Status.PUBLISHED, comment2);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#method_after
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    Comment comment1 = newComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get(), false);
    Comment comment2 = newComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get(), false);
    Comment comment3 = newComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get(), false);
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(Status.PUBLISHED, comment3);
    update.putComment(Status.PUBLISHED, comment2);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "Unresolved: false\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "Unresolved: false\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "Unresolved: false\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableListMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatRealAuthor() throws Exception {
    Change c = newChange();
    CurrentUser ownerAsOtherUser = userFactory.runAs(null, otherUserId, changeOwner);
    ChangeUpdate update = newUpdate(c, ownerAsOtherUser);
    String uuid = "uuid";
    String message = "comment";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    Comment comment = newComment(psId, "file", uuid, range, range.getEndLine(), otherUser, null, time, message, (short) 1, revId.get());
    comment.setRealAuthor(changeOwner.getAccountId());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time) + "\n" + "Author: Other Account <2@gerrit>\n" + "Real-author: Change Owner <1@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#method_after
@Test
public void patchLineCommentNotesFormatRealAuthor() throws Exception {
    Change c = newChange();
    CurrentUser ownerAsOtherUser = userFactory.runAs(null, otherUserId, changeOwner);
    ChangeUpdate update = newUpdate(c, ownerAsOtherUser);
    String uuid = "uuid";
    String message = "comment";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    Comment comment = newComment(psId, "file", uuid, range, range.getEndLine(), otherUser, null, time, message, (short) 1, revId.get(), false);
    comment.setRealAuthor(changeOwner.getAccountId());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time) + "\n" + "Author: Other Account <2@gerrit>\n" + "Real-author: Change Owner <1@gerrit>\n" + "Unresolved: false\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableListMultimap.of(revId, comment));
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment = newComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(new RevId(comment.revId), comment));
}
#method_after
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment = newComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234", false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "Unresolved: false\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableListMultimap.of(new RevId(comment.revId), comment));
}
#end_block

#method_before
@Test
public void patchLineCommentMultipleOnePatchsetOneFileBothSides() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    String messageForBase = "comment for base";
    String messageForPS = "comment for ps";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment commentForBase = newComment(psId, "filename", uuid1, range, range.getEndLine(), otherUser, null, now, messageForBase, (short) 0, rev1);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, commentForBase);
    update.commit();
    update = newUpdate(c, otherUser);
    Comment commentForPS = newComment(psId, "filename", uuid2, range, range.getEndLine(), otherUser, null, now, messageForPS, (short) 1, rev2);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, commentForPS);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), commentForBase, new RevId(rev2), commentForPS));
}
#method_after
@Test
public void patchLineCommentMultipleOnePatchsetOneFileBothSides() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    String messageForBase = "comment for base";
    String messageForPS = "comment for ps";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment commentForBase = newComment(psId, "filename", uuid1, range, range.getEndLine(), otherUser, null, now, messageForBase, (short) 0, rev1, false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, commentForBase);
    update.commit();
    update = newUpdate(c, otherUser);
    Comment commentForPS = newComment(psId, "filename", uuid2, range, range.getEndLine(), otherUser, null, now, messageForPS, (short) 1, rev2, false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, commentForPS);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableListMultimap.of(new RevId(rev1), commentForBase, new RevId(rev2), commentForPS));
}
#end_block

#method_before
@Test
public void patchLineCommentMultipleOnePatchsetOneFile() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp timeForComment1 = TimeUtil.nowTs();
    Timestamp timeForComment2 = TimeUtil.nowTs();
    Comment comment1 = newComment(psId, filename, uuid1, range, range.getEndLine(), otherUser, null, timeForComment1, "comment 1", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    Comment comment2 = newComment(psId, filename, uuid2, range, range.getEndLine(), otherUser, null, timeForComment2, "comment 2", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
}
#method_after
@Test
public void patchLineCommentMultipleOnePatchsetOneFile() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp timeForComment1 = TimeUtil.nowTs();
    Timestamp timeForComment2 = TimeUtil.nowTs();
    Comment comment1 = newComment(psId, filename, uuid1, range, range.getEndLine(), otherUser, null, timeForComment1, "comment 1", side, rev, false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    Comment comment2 = newComment(psId, filename, uuid2, range, range.getEndLine(), otherUser, null, timeForComment2, "comment 2", side, rev, false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableListMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
}
#end_block

#method_before
@Test
public void patchLineCommentMultipleOnePatchsetMultipleFiles() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename1 = "filename1";
    String filename2 = "filename2";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(psId, filename1, uuid, range, range.getEndLine(), otherUser, null, now, "comment 1", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    Comment comment2 = newComment(psId, filename2, uuid, range, range.getEndLine(), otherUser, null, now, "comment 2", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
}
#method_after
@Test
public void patchLineCommentMultipleOnePatchsetMultipleFiles() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename1 = "filename1";
    String filename2 = "filename2";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(psId, filename1, uuid, range, range.getEndLine(), otherUser, null, now, "comment 1", side, rev, false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    Comment comment2 = newComment(psId, filename2, uuid, range, range.getEndLine(), otherUser, null, now, "comment 2", side, rev, false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableListMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
}
#end_block

#method_before
@Test
public void patchLineCommentMultiplePatchsets() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    Comment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2);
    update.setPatchSetId(ps2);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), comment1, new RevId(rev2), comment2));
}
#method_after
@Test
public void patchLineCommentMultiplePatchsets() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1, false);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    Comment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2, false);
    update.setPatchSetId(ps2);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableListMultimap.of(new RevId(rev1), comment1, new RevId(rev2), comment2));
}
#end_block

#method_before
@Test
public void patchLineCommentSingleDraftToPublished() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    update.setPatchSetId(ps1);
    update.putComment(Status.DRAFT, comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
}
#method_after
@Test
public void patchLineCommentSingleDraftToPublished() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, false);
    update.setPatchSetId(ps1);
    update.putComment(Status.DRAFT, comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableListMultimap.of(new RevId(rev), comment1));
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableListMultimap.of(new RevId(rev), comment1));
}
#end_block

#method_before
@Test
public void patchLineCommentMultipleDraftsSameSidePublishOne() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    short side = (short) 1;
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts on the same side of one patch set.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    Comment comment1 = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    Comment comment2 = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "other on ps1", side, rev);
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
    assertThat(notes.getComments()).isEmpty();
    // Publish first draft.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment2));
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
}
#method_after
@Test
public void patchLineCommentMultipleDraftsSameSidePublishOne() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    short side = (short) 1;
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts on the same side of one patch set.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    Comment comment1 = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, false);
    Comment comment2 = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "other on ps1", side, rev, false);
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableListMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
    assertThat(notes.getComments()).isEmpty();
    // Publish first draft.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableListMultimap.of(new RevId(rev), comment2));
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableListMultimap.of(new RevId(rev), comment1));
}
#end_block

#method_before
@Test
public void patchLineCommentsMultipleDraftsBothSidesPublishAll() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts, one on each side of the patchset.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    Comment baseComment = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on base", (short) 0, rev1);
    Comment psComment = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "comment on ps", (short) 1, rev2);
    update.putComment(Status.DRAFT, baseComment);
    update.putComment(Status.DRAFT, psComment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
    assertThat(notes.getComments()).isEmpty();
    // Publish both comments.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, baseComment);
    update.putComment(Status.PUBLISHED, psComment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
}
#method_after
@Test
public void patchLineCommentsMultipleDraftsBothSidesPublishAll() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts, one on each side of the patchset.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    Comment baseComment = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on base", (short) 0, rev1, false);
    Comment psComment = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "comment on ps", (short) 1, rev2, false);
    update.putComment(Status.DRAFT, baseComment);
    update.putComment(Status.DRAFT, psComment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableListMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
    assertThat(notes.getComments()).isEmpty();
    // Publish both comments.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, baseComment);
    update.putComment(Status.PUBLISHED, psComment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableListMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
}
#end_block

#method_before
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.DRAFT, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#method_after
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, false);
    update.setPatchSetId(psId);
    update.putComment(Status.DRAFT, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#end_block

#method_before
@Test
public void patchLineCommentsDeleteAllDraftsForOneRevision() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    ObjectId objId1 = ObjectId.fromString(rev1);
    ObjectId objId2 = ObjectId.fromString(rev2);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1);
    update.setPatchSetId(ps1);
    update.putComment(Status.DRAFT, comment1);
    update.commit();
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    Comment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2);
    update.setPatchSetId(ps2);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(2);
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(ps2);
    update.deleteComment(comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    NoteMap noteMap = notes.getDraftCommentNotes().getNoteMap();
    assertThat(noteMap.contains(objId1)).isTrue();
    assertThat(noteMap.contains(objId2)).isFalse();
}
#method_after
@Test
public void patchLineCommentsDeleteAllDraftsForOneRevision() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    ObjectId objId1 = ObjectId.fromString(rev1);
    ObjectId objId2 = ObjectId.fromString(rev2);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1, false);
    update.setPatchSetId(ps1);
    update.putComment(Status.DRAFT, comment1);
    update.commit();
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    Comment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2, false);
    update.setPatchSetId(ps2);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(2);
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(ps2);
    update.deleteComment(comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    NoteMap noteMap = notes.getDraftCommentNotes().getNoteMap();
    assertThat(noteMap.contains(objId1)).isTrue();
    assertThat(noteMap.contains(objId2)).isFalse();
}
#end_block

#method_before
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnEmptyDraftRef() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    assertThat(repo.exactRef(changeMetaRef(c.getId()))).isNotNull();
    String draftRef = refsDraftComments(c.getId(), otherUser.getAccountId());
    assertThat(exactRefAllUsers(draftRef)).isNull();
}
#method_after
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnEmptyDraftRef() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, false);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    assertThat(repo.exactRef(changeMetaRef(c.getId()))).isNotNull();
    String draftRef = refsDraftComments(c.getId(), otherUser.getAccountId());
    assertThat(exactRefAllUsers(draftRef)).isNull();
}
#end_block

#method_before
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnNonEmptyDraftRef() throws Exception {
    Change c = newChange();
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment draft = newComment(ps1, filename, "uuid1", range, range.getEndLine(), otherUser, null, now, "draft comment on ps1", side, rev);
    update.putComment(Status.DRAFT, draft);
    update.commit();
    String draftRef = refsDraftComments(c.getId(), otherUser.getAccountId());
    ObjectId old = exactRefAllUsers(draftRef);
    assertThat(old).isNotNull();
    update = newUpdate(c, otherUser);
    Comment pub = newComment(ps1, filename, "uuid2", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    update.putComment(Status.PUBLISHED, pub);
    update.commit();
    assertThat(exactRefAllUsers(draftRef)).isEqualTo(old);
}
#method_after
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnNonEmptyDraftRef() throws Exception {
    Change c = newChange();
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment draft = newComment(ps1, filename, "uuid1", range, range.getEndLine(), otherUser, null, now, "draft comment on ps1", side, rev, false);
    update.putComment(Status.DRAFT, draft);
    update.commit();
    String draftRef = refsDraftComments(c.getId(), otherUser.getAccountId());
    ObjectId old = exactRefAllUsers(draftRef);
    assertThat(old).isNotNull();
    update = newUpdate(c, otherUser);
    Comment pub = newComment(ps1, filename, "uuid2", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, false);
    update.putComment(Status.PUBLISHED, pub);
    update.commit();
    assertThat(exactRefAllUsers(draftRef)).isEqualTo(old);
}
#end_block

#method_before
@Test
public void fileComment() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String messageForBase = "comment for base";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment = newComment(psId, "filename", uuid, null, 0, otherUser, null, now, messageForBase, (short) 0, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment));
}
#method_after
@Test
public void fileComment() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String messageForBase = "comment for base";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment = newComment(psId, "filename", uuid, null, 0, otherUser, null, now, messageForBase, (short) 0, rev, false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableListMultimap.of(new RevId(rev), comment));
}
#end_block

#method_before
@Test
public void patchLineCommentNoRange() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String messageForBase = "comment for base";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment = newComment(psId, "filename", uuid, null, 1, otherUser, null, now, messageForBase, (short) 0, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment));
}
#method_after
@Test
public void patchLineCommentNoRange() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String messageForBase = "comment for base";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment = newComment(psId, "filename", uuid, null, 1, otherUser, null, now, messageForBase, (short) 0, rev, false);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableListMultimap.of(new RevId(rev), comment));
}
#end_block

#method_before
@Test
public void putCommentsForMultipleRevisions() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(ps2);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1);
    Comment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2);
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(2);
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps2);
    update.putComment(Status.PUBLISHED, comment1);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).hasSize(2);
}
#method_after
@Test
public void putCommentsForMultipleRevisions() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(ps2);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1, false);
    Comment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2, false);
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(2);
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps2);
    update.putComment(Status.PUBLISHED, comment1);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).hasSize(2);
}
#end_block

#method_before
@Test
public void publishSubsetOfCommentsOnRevision() throws Exception {
    Change c = newChange();
    RevId rev1 = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, "file1", "uuid1", range, range.getEndLine(), otherUser, null, now, "comment1", side, rev1.get());
    Comment comment2 = newComment(ps1, "file2", "uuid2", range, range.getEndLine(), otherUser, null, now, "comment2", side, rev1.get());
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1, comment2);
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1);
    assertThat(notes.getComments().get(rev1)).containsExactly(comment2);
}
#method_after
@Test
public void publishSubsetOfCommentsOnRevision() throws Exception {
    Change c = newChange();
    RevId rev1 = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, "file1", "uuid1", range, range.getEndLine(), otherUser, null, now, "comment1", side, rev1.get(), false);
    Comment comment2 = newComment(ps1, "file2", "uuid2", range, range.getEndLine(), otherUser, null, now, "comment2", side, rev1.get(), false);
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1, comment2);
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1);
    assertThat(notes.getComments().get(rev1)).containsExactly(comment2);
}
#end_block

#method_before
@Test
public void filterOutAndFixUpZombieDraftComments() throws Exception {
    Change c = newChange();
    RevId rev1 = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, "file1", "uuid1", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1.get());
    Comment comment2 = newComment(ps1, "file2", "uuid2", range, range.getEndLine(), otherUser, null, now, "another comment", side, rev1.get());
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    String refName = refsDraftComments(c.getId(), otherUserId);
    ObjectId oldDraftId = exactRefAllUsers(refName);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(exactRefAllUsers(refName)).isNotNull();
    assertThat(exactRefAllUsers(refName)).isNotEqualTo(oldDraftId);
    // Re-add draft version of comment2 back to draft ref without updating
    // change ref. Simulates the case where deleting the draft failed
    // non-atomically after adding the published comment succeeded.
    ChangeDraftUpdate draftUpdate = newUpdate(c, otherUser).createDraftUpdateIfNull();
    draftUpdate.putComment(comment2);
    try (NoteDbUpdateManager manager = updateManagerFactory.create(c.getProject())) {
        manager.add(draftUpdate);
        manager.execute();
    }
    // Looking at drafts directly shows the zombie comment.
    DraftCommentNotes draftNotes = draftNotesFactory.create(c, otherUserId);
    assertThat(draftNotes.load().getComments().get(rev1)).containsExactly(comment1, comment2);
    // Zombie comment is filtered out of drafts via ChangeNotes.
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1);
    assertThat(notes.getComments().get(rev1)).containsExactly(comment2);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    // Updating an unrelated comment causes the zombie comment to get fixed up.
    assertThat(exactRefAllUsers(refName)).isNull();
}
#method_after
@Test
public void filterOutAndFixUpZombieDraftComments() throws Exception {
    Change c = newChange();
    RevId rev1 = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, "file1", "uuid1", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1.get(), false);
    Comment comment2 = newComment(ps1, "file2", "uuid2", range, range.getEndLine(), otherUser, null, now, "another comment", side, rev1.get(), false);
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    String refName = refsDraftComments(c.getId(), otherUserId);
    ObjectId oldDraftId = exactRefAllUsers(refName);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(exactRefAllUsers(refName)).isNotNull();
    assertThat(exactRefAllUsers(refName)).isNotEqualTo(oldDraftId);
    // Re-add draft version of comment2 back to draft ref without updating
    // change ref. Simulates the case where deleting the draft failed
    // non-atomically after adding the published comment succeeded.
    ChangeDraftUpdate draftUpdate = newUpdate(c, otherUser).createDraftUpdateIfNull();
    draftUpdate.putComment(comment2);
    try (NoteDbUpdateManager manager = updateManagerFactory.create(c.getProject())) {
        manager.add(draftUpdate);
        manager.execute();
    }
    // Looking at drafts directly shows the zombie comment.
    DraftCommentNotes draftNotes = draftNotesFactory.create(c, otherUserId);
    assertThat(draftNotes.load().getComments().get(rev1)).containsExactly(comment1, comment2);
    // Zombie comment is filtered out of drafts via ChangeNotes.
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1);
    assertThat(notes.getComments().get(rev1)).containsExactly(comment2);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    // Updating an unrelated comment causes the zombie comment to get fixed up.
    assertThat(exactRefAllUsers(refName)).isNull();
}
#end_block

#method_before
@Test
public void updateCommentsInSequentialUpdates() throws Exception {
    Change c = newChange();
    CommentRange range = new CommentRange(1, 1, 2, 1);
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ChangeUpdate update1 = newUpdate(c, otherUser);
    Comment comment1 = newComment(c.currentPatchSetId(), "filename", "uuid1", range, range.getEndLine(), otherUser, null, new Timestamp(update1.getWhen().getTime()), "comment 1", (short) 1, rev);
    update1.putComment(Status.PUBLISHED, comment1);
    ChangeUpdate update2 = newUpdate(c, otherUser);
    Comment comment2 = newComment(c.currentPatchSetId(), "filename", "uuid2", range, range.getEndLine(), otherUser, null, new Timestamp(update2.getWhen().getTime()), "comment 2", (short) 1, rev);
    update2.putComment(Status.PUBLISHED, comment2);
    try (NoteDbUpdateManager manager = updateManagerFactory.create(project)) {
        manager.add(update1);
        manager.add(update2);
        manager.execute();
    }
    ChangeNotes notes = newNotes(c);
    List<Comment> comments = notes.getComments().get(new RevId(rev));
    assertThat(comments).hasSize(2);
    assertThat(comments.get(0).message).isEqualTo("comment 1");
    assertThat(comments.get(1).message).isEqualTo("comment 2");
}
#method_after
@Test
public void updateCommentsInSequentialUpdates() throws Exception {
    Change c = newChange();
    CommentRange range = new CommentRange(1, 1, 2, 1);
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ChangeUpdate update1 = newUpdate(c, otherUser);
    Comment comment1 = newComment(c.currentPatchSetId(), "filename", "uuid1", range, range.getEndLine(), otherUser, null, new Timestamp(update1.getWhen().getTime()), "comment 1", (short) 1, rev, false);
    update1.putComment(Status.PUBLISHED, comment1);
    ChangeUpdate update2 = newUpdate(c, otherUser);
    Comment comment2 = newComment(c.currentPatchSetId(), "filename", "uuid2", range, range.getEndLine(), otherUser, null, new Timestamp(update2.getWhen().getTime()), "comment 2", (short) 1, rev, false);
    update2.putComment(Status.PUBLISHED, comment2);
    try (NoteDbUpdateManager manager = updateManagerFactory.create(project)) {
        manager.add(update1);
        manager.add(update2);
        manager.execute();
    }
    ChangeNotes notes = newNotes(c);
    List<Comment> comments = notes.getComments().get(new RevId(rev));
    assertThat(comments).hasSize(2);
    assertThat(comments.get(0).message).isEqualTo("comment 1");
    assertThat(comments.get(1).message).isEqualTo("comment 2");
}
#end_block

#method_before
@Test
public void ignoreEntitiesBeyondCurrentPatchSet() throws Exception {
    Change c = newChange();
    ChangeNotes notes = newNotes(c);
    int numMessages = notes.getChangeMessages().size();
    int numPatchSets = notes.getPatchSets().size();
    int numApprovals = notes.getApprovals().size();
    int numComments = notes.getComments().size();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(new PatchSet.Id(c.getId(), c.currentPatchSetId().get() + 1));
    update.setChangeMessage("Should be ignored");
    update.putApproval("Code-Review", (short) 2);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Comment comment = newComment(update.getPatchSetId(), "filename", "uuid", range, range.getEndLine(), changeOwner, null, new Timestamp(update.getWhen().getTime()), "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getChangeMessages()).hasSize(numMessages);
    assertThat(notes.getPatchSets()).hasSize(numPatchSets);
    assertThat(notes.getApprovals()).hasSize(numApprovals);
    assertThat(notes.getComments()).hasSize(numComments);
}
#method_after
@Test
public void ignoreEntitiesBeyondCurrentPatchSet() throws Exception {
    Change c = newChange();
    ChangeNotes notes = newNotes(c);
    int numMessages = notes.getChangeMessages().size();
    int numPatchSets = notes.getPatchSets().size();
    int numApprovals = notes.getApprovals().size();
    int numComments = notes.getComments().size();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(new PatchSet.Id(c.getId(), c.currentPatchSetId().get() + 1));
    update.setChangeMessage("Should be ignored");
    update.putApproval("Code-Review", (short) 2);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Comment comment = newComment(update.getPatchSetId(), "filename", "uuid", range, range.getEndLine(), changeOwner, null, new Timestamp(update.getWhen().getTime()), "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234", false);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getChangeMessages()).hasSize(numMessages);
    assertThat(notes.getPatchSets()).hasSize(numPatchSets);
    assertThat(notes.getApprovals()).hasSize(numApprovals);
    assertThat(notes.getComments()).hasSize(numComments);
}
#end_block

#method_before
@Override
public Response<?> apply(ProjectResource project, DeleteBranchesInput input) throws OrmException, IOException, ResourceConflictException {
    if (input == null) {
        input = new DeleteBranchesInput();
    }
    if (input.branches == null) {
        input.branches = Lists.newArrayListWithCapacity(1);
    }
    try (Repository r = repoManager.openRepository(project.getNameKey())) {
        BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate();
        for (String branch : input.branches) {
            batchUpdate.addCommand(createDeleteCommand(project, r, branch));
        }
        try (RevWalk rw = new RevWalk(r)) {
            batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        }
        StringBuilder errorMessages = new StringBuilder();
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() == Result.OK) {
                postDeletion(project, command);
            } else {
                appendAndLogErrorMessage(errorMessages, command);
            }
        }
        if (errorMessages.length() > 0) {
            throw new ResourceConflictException(errorMessages.toString());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ProjectResource project, DeleteBranchesInput input) throws OrmException, IOException, RestApiException {
    if (input == null || input.branches == null || input.branches.isEmpty()) {
        throw new BadRequestException("branches must be specified");
    }
    deleteRefFactory.create(project).refs(input.branches).delete();
    return Response.none();
}
#end_block

#method_before
private static void admin(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            if (matchExact(ADMIN_GROUPS, token) || matchExact("/admin/groups", token)) {
                Gerrit.display(token, new GroupListScreen());
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                } else {
                    group();
                }
            } else if (matchPrefix("/admin/groups", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                }
            } else if (matchExact(ADMIN_PROJECTS, token) || matchExact("/admin/projects", token)) {
                Gerrit.display(token, new ProjectListScreen());
            } else if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                } else {
                    Gerrit.display(token, selectProject());
                }
            } else if (matchPrefix("/admin/projects", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                }
            } else if (matchPrefix(ADMIN_PLUGINS, token) || matchExact("/admin/plugins", token)) {
                Gerrit.display(token, new PluginListScreen());
            } else if (matchExact(ADMIN_CREATE_PROJECT, token) || matchExact("/admin/create-project", token)) {
                Gerrit.display(token, new CreateProjectScreen());
            } else if (matchExact(ADMIN_CREATE_GROUP, token) || matchExact("/admin/create-group", token)) {
                Gerrit.display(token, new CreateGroupScreen());
            } else {
                Gerrit.display(token, new NotFoundScreen());
            }
        }

        private void group() {
            final String panel;
            final String group;
            if (matchPrefix("/admin/groups/uuid-", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else {
                Gerrit.display(token, new NotFoundScreen());
                return;
            }
            GroupApi.getGroupDetail(group, new GerritCallback<GroupInfo>() {

                @Override
                public void onSuccess(GroupInfo group) {
                    if (panel == null || panel.isEmpty()) {
                        // 
                        if (AccountGroup.isInternalGroup(group.getGroupUUID())) {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.MEMBERS), new AccountGroupMembersScreen(group, token));
                        } else {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.INFO), new AccountGroupInfoScreen(group, token));
                        }
                    } else if (AccountGroupScreen.INFO.equals(panel)) {
                        Gerrit.display(token, new AccountGroupInfoScreen(group, token));
                    } else if (AccountGroupScreen.MEMBERS.equals(panel)) {
                        Gerrit.display(token, new AccountGroupMembersScreen(group, token));
                    } else if (AccountGroupScreen.AUDIT_LOG.equals(panel)) {
                        Gerrit.display(token, new AccountGroupAuditLogScreen(group, token));
                    } else {
                        Gerrit.display(token, new NotFoundScreen());
                    }
                }
            });
        }

        private Screen selectProject() {
            if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                int c = rest.lastIndexOf(',');
                if (c < 0) {
                    return new ProjectInfoScreen(Project.NameKey.parse(rest));
                } else if (c == 0) {
                    return new NotFoundScreen();
                }
                int q = rest.lastIndexOf('?');
                if (q > 0 && rest.lastIndexOf(',', q) > 0) {
                    c = rest.substring(0, q - 1).lastIndexOf(',');
                }
                Project.NameKey k = Project.NameKey.parse(rest.substring(0, c));
                String panel = rest.substring(c + 1);
                if (ProjectScreen.INFO.equals(panel)) {
                    return new ProjectInfoScreen(k);
                }
                if (ProjectScreen.BRANCHES.equals(panel) || matchPrefix(ProjectScreen.BRANCHES, panel)) {
                    return new ProjectBranchesScreen(k);
                }
                if (ProjectScreen.TAGS.equals(panel) || matchPrefix(ProjectScreen.TAGS, panel)) {
                    return new ProjectTagsScreen(k);
                }
                if (ProjectScreen.ACCESS.equals(panel)) {
                    return new ProjectAccessScreen(k);
                }
                if (ProjectScreen.DASHBOARDS.equals(panel)) {
                    return new ProjectDashboardsScreen(k);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
private static void admin(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            if (matchExact(ADMIN_GROUPS, token) || matchExact("/admin/groups", token)) {
                Gerrit.display(token, new GroupListScreen());
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                } else {
                    group();
                }
            } else if (matchPrefix("/admin/groups", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                }
            } else if (matchExact(ADMIN_PROJECTS, token) || matchExact("/admin/projects", token)) {
                Gerrit.display(token, new ProjectListScreen());
            } else if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                } else {
                    Gerrit.display(token, selectProject());
                }
            } else if (matchPrefix("/admin/projects", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                }
            } else if (matchPrefix(ADMIN_PLUGINS, token) || matchExact("/admin/plugins", token)) {
                Gerrit.display(token, new PluginListScreen());
            } else if (matchExact(ADMIN_CREATE_PROJECT, token) || matchExact("/admin/create-project", token)) {
                Gerrit.display(token, new CreateProjectScreen());
            } else if (matchExact(ADMIN_CREATE_GROUP, token) || matchExact("/admin/create-group", token)) {
                Gerrit.display(token, new CreateGroupScreen());
            } else {
                Gerrit.display(token, new NotFoundScreen());
            }
        }

        private void group() {
            final String panel;
            final String group;
            if (matchPrefix("/admin/groups/uuid-", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else {
                Gerrit.display(token, new NotFoundScreen());
                return;
            }
            GroupApi.getGroupDetail(group, new GerritCallback<GroupInfo>() {

                @Override
                public void onSuccess(GroupInfo group) {
                    if (panel == null || panel.isEmpty()) {
                        // 
                        if (AccountGroup.isInternalGroup(group.getGroupUUID())) {
                            String newToken = toGroup(group.getGroupId(), AccountGroupScreen.MEMBERS);
                            Gerrit.display(newToken, new AccountGroupMembersScreen(group, newToken));
                        } else {
                            String newToken = toGroup(group.getGroupId(), AccountGroupScreen.INFO);
                            Gerrit.display(newToken, new AccountGroupInfoScreen(group, newToken));
                        }
                    } else if (AccountGroupScreen.INFO.equals(panel)) {
                        Gerrit.display(token, new AccountGroupInfoScreen(group, token));
                    } else if (AccountGroupScreen.MEMBERS.equals(panel)) {
                        Gerrit.display(token, new AccountGroupMembersScreen(group, token));
                    } else if (AccountGroupScreen.AUDIT_LOG.equals(panel)) {
                        Gerrit.display(token, new AccountGroupAuditLogScreen(group, token));
                    } else {
                        Gerrit.display(token, new NotFoundScreen());
                    }
                }
            });
        }

        private Screen selectProject() {
            if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                int c = rest.lastIndexOf(',');
                if (c < 0) {
                    return new ProjectInfoScreen(Project.NameKey.parse(rest));
                } else if (c == 0) {
                    return new NotFoundScreen();
                }
                int q = rest.lastIndexOf('?');
                if (q > 0 && rest.lastIndexOf(',', q) > 0) {
                    c = rest.substring(0, q - 1).lastIndexOf(',');
                }
                Project.NameKey k = Project.NameKey.parse(rest.substring(0, c));
                String panel = rest.substring(c + 1);
                if (ProjectScreen.INFO.equals(panel)) {
                    return new ProjectInfoScreen(k);
                }
                if (ProjectScreen.BRANCHES.equals(panel) || matchPrefix(ProjectScreen.BRANCHES, panel)) {
                    return new ProjectBranchesScreen(k);
                }
                if (ProjectScreen.TAGS.equals(panel) || matchPrefix(ProjectScreen.TAGS, panel)) {
                    return new ProjectTagsScreen(k);
                }
                if (ProjectScreen.ACCESS.equals(panel)) {
                    return new ProjectAccessScreen(k);
                }
                if (ProjectScreen.DASHBOARDS.equals(panel)) {
                    return new ProjectDashboardsScreen(k);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#end_block

#method_before
protected LoadHandle openHandle(Repository repo) throws IOException {
    return openHandle(repo, readRef(repo));
}
#method_after
protected LoadHandle openHandle(Repository repo) throws NoSuchChangeException, IOException {
    return openHandle(repo, readRef(repo));
}
#end_block

#method_before
public T reload() throws OrmException {
    loaded = false;
    return load();
}
#method_after
public T reload() throws NoSuchChangeException, OrmException {
    loaded = false;
    return load();
}
#end_block

#method_before
private List<AccountInfo> getPastAssignees(PushOneCommit.Result r) throws Exception {
    return gApi.changes().id(r.getChange().getId().get()).getPastAssignees();
}
#method_after
@Test
public void getPastAssignees() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    PushOneCommit.Result r = createChange();
    setAssignee(r, user.email);
    setAssignee(r, admin.email);
    List<AccountInfo> assignees = getPastAssignees(r);
    assertThat(assignees).hasSize(2);
    Iterator<AccountInfo> itr = assignees.iterator();
    assertThat(itr.next()._accountId).isEqualTo(user.getId().get());
    assertThat(itr.next()._accountId).isEqualTo(admin.getId().get());
}
#end_block

#method_before
private AccountInfo deleteAssignee(PushOneCommit.Result r) throws Exception {
    return gApi.changes().id(r.getChange().getId().get()).deleteAssignee();
}
#method_after
@Test
public void deleteAssignee() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(setAssignee(r, user.email)._accountId).isEqualTo(user.getId().get());
    assertThat(deleteAssignee(r)._accountId).isEqualTo(user.getId().get());
    assertThat(getAssignee(r)).isNull();
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(ChangeResource rsrc) throws OrmException {
    Optional<Account.Id> assignee = Optional.ofNullable(rsrc.getChange().getAssignee());
    if (assignee.isPresent()) {
        Account account = accountInfo.create().get(assignee.get());
        return Response.ok(AccountJson.toAccountInfo(account));
    }
    return Response.none();
}
#method_after
@Override
public Response<AccountInfo> apply(ChangeResource rsrc) throws OrmException {
    Optional<Account.Id> assignee = Optional.ofNullable(rsrc.getChange().getAssignee());
    if (assignee.isPresent()) {
        return Response.ok(accountLoaderFactory.create(true).fillOne(assignee.get()));
    }
    return Response.none();
}
#end_block

#method_before
@Override
public void name(String name) throws RestApiException {
    PutName.Input in = new PutName.Input();
    in.name = name;
    try {
        putName.apply(rsrc, in);
    } catch (NoSuchGroupException e) {
        throw new ResourceNotFoundException(name, e);
    } catch (OrmException e) {
        throw new RestApiException("Cannot put group name", e);
    }
}
#method_after
@Override
public void name(String name) throws RestApiException {
    PutName.Input in = new PutName.Input();
    in.name = name;
    try {
        putName.apply(rsrc, in);
    } catch (NoSuchGroupException e) {
        throw new ResourceNotFoundException(name, e);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot put group name", e);
    }
}
#end_block

#method_before
@Override
public void owner(String owner) throws RestApiException {
    PutOwner.Input in = new PutOwner.Input();
    in.owner = owner;
    try {
        putOwner.apply(rsrc, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot put group owner", e);
    }
}
#method_after
@Override
public void owner(String owner) throws RestApiException {
    PutOwner.Input in = new PutOwner.Input();
    in.owner = owner;
    try {
        putOwner.apply(rsrc, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot put group owner", e);
    }
}
#end_block

#method_before
@Override
public void description(String description) throws RestApiException {
    PutDescription.Input in = new PutDescription.Input();
    in.description = description;
    try {
        putDescription.apply(rsrc, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot put group description", e);
    }
}
#method_after
@Override
public void description(String description) throws RestApiException {
    PutDescription.Input in = new PutDescription.Input();
    in.description = description;
    try {
        putDescription.apply(rsrc, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot put group description", e);
    }
}
#end_block

#method_before
@Override
public void options(GroupOptionsInfo options) throws RestApiException {
    try {
        putOptions.apply(rsrc, options);
    } catch (OrmException e) {
        throw new RestApiException("Cannot put group options", e);
    }
}
#method_after
@Override
public void options(GroupOptionsInfo options) throws RestApiException {
    try {
        putOptions.apply(rsrc, options);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot put group options", e);
    }
}
#end_block

#method_before
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = bu.getUser().getAccountId();
        boolean ccOrReviewer = input.labels != null;
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(bu.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify);
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = bu.getUser().getAccountId();
        boolean ccOrReviewer = input.labels != null && !input.labels.isEmpty();
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(bu.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify, accountsToNotify);
    }
    return Response.ok(output);
}
#end_block

#method_before
private void emailReviewers(Change change, List<PostReviewers.Addition> reviewerAdditions, NotifyHandling notify) {
    List<Account.Id> to = new ArrayList<>();
    List<Account.Id> cc = new ArrayList<>();
    for (PostReviewers.Addition addition : reviewerAdditions) {
        if (addition.op.state == ReviewerState.REVIEWER) {
            to.addAll(addition.op.reviewers.keySet());
        } else if (addition.op.state == ReviewerState.CC) {
            cc.addAll(addition.op.reviewers.keySet());
        }
    }
    postReviewers.emailReviewers(change, to, cc, notify);
}
#method_after
private void emailReviewers(Change change, List<PostReviewers.Addition> reviewerAdditions, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) {
    List<Account.Id> to = new ArrayList<>();
    List<Account.Id> cc = new ArrayList<>();
    for (PostReviewers.Addition addition : reviewerAdditions) {
        if (addition.op.state == ReviewerState.REVIEWER) {
            to.addAll(addition.op.reviewers.keySet());
        } else if (addition.op.state == ReviewerState.CC) {
            cc.addAll(addition.op.reviewers.keySet());
        }
    }
    postReviewers.emailReviewers(change, to, cc, notify, accountsToNotify);
}
#end_block

#method_before
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> in) throws BadRequestException, OrmException {
    Iterator<? extends Map.Entry<String, List<T>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getControl()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<T>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.isMagic(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, revision.getChange().currentPatchSetId()));
        }
        List<T> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        if (Patch.isMagic(path)) {
            for (T comment : list) {
                if (comment.side == Side.PARENT && comment.parent == null) {
                    throw new BadRequestException(String.format("cannot comment on %s on auto-merge", path));
                }
            }
        }
        Iterator<T> listItr = list.iterator();
        while (listItr.hasNext()) {
            T c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line != null && c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.nullToEmpty(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#method_after
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> commentsPerPath) throws BadRequestException, OrmException {
    cleanUpComments(commentsPerPath);
    ensureCommentsAreAddable(revision, commentsPerPath);
}
#end_block

#method_before
private void checkRobotComments(RevisionResource revision, Map<String, List<RobotCommentInput>> in) throws BadRequestException, OrmException {
    for (Map.Entry<String, List<RobotCommentInput>> e : in.entrySet()) {
        String path = e.getKey();
        for (RobotCommentInput c : e.getValue()) {
            if (c.robotId == null) {
                throw new BadRequestException(String.format("robotId is missing for robot comment on %s", path));
            }
            if (c.robotRunId == null) {
                throw new BadRequestException(String.format("robotRunId is missing for robot comment on %s", path));
            }
        }
    }
    checkComments(revision, in);
}
#method_after
private void checkRobotComments(RevisionResource revision, Map<String, List<RobotCommentInput>> in) throws BadRequestException, OrmException {
    for (Map.Entry<String, List<RobotCommentInput>> e : in.entrySet()) {
        String commentPath = e.getKey();
        for (RobotCommentInput c : e.getValue()) {
            ensureRobotIdIsSet(c.robotId, commentPath);
            ensureRobotRunIdIsSet(c.robotRunId, commentPath);
            ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath);
        }
    }
    checkComments(revision, in);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= insertRobotComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, UnprocessableEntityException {
    user = ctx.getIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= insertRobotComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, notes, ps, user, message, comments).sendAsync();
    }
    commentAdded.fire(notes.getChange(), ps, user.getAccount(), message.getMessage(), approvals, oldApprovals, ctx.getWhen());
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0 || !accountsToNotify.isEmpty()) {
        email.create(in.notify, accountsToNotify, notes, ps, user, message, comments, in.message, labelDelta).sendAsync();
    }
    commentAdded.fire(notes.getChange(), ps, user.getAccount(), message.getMessage(), approvals, oldApprovals, ctx.getWhen());
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, Comment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<Comment> toDel = new ArrayList<>();
    List<Comment> toPublish = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            Comment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = commentsUtil.newComment(ctx, path, psId, c.side(), c.message);
            } else {
                e.writtenOn = ctx.getWhen();
                e.side = c.side();
                e.message = c.message;
            }
            if (parent != null) {
                e.parentUuid = parent;
            }
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toPublish.add(e);
        }
    }
    switch(in.drafts) {
        case KEEP:
        default:
            break;
        case DELETE:
            toDel.addAll(drafts.values());
            break;
        case PUBLISH:
            for (Comment e : drafts.values()) {
                toPublish.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, toPublish);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    commentsUtil.deleteComments(ctx.getDb(), u, toDel);
    commentsUtil.putComments(ctx.getDb(), u, Status.PUBLISHED, toPublish);
    comments.addAll(toPublish);
    return !toDel.isEmpty() || !toPublish.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException, UnprocessableEntityException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, Comment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<Comment> toDel = new ArrayList<>();
    List<Comment> toPublish = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            Comment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = commentsUtil.newComment(ctx, path, psId, c.side(), c.message, c.unresolved, parent);
            } else {
                e.writtenOn = ctx.getWhen();
                e.side = c.side();
                e.message = c.message;
            }
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toPublish.add(e);
        }
    }
    switch(in.drafts) {
        case KEEP:
        default:
            break;
        case DELETE:
            toDel.addAll(drafts.values());
            break;
        case PUBLISH:
            for (Comment e : drafts.values()) {
                toPublish.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, toPublish);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    commentsUtil.deleteComments(ctx.getDb(), u, toDel);
    commentsUtil.putComments(ctx.getDb(), u, Status.PUBLISHED, toPublish);
    comments.addAll(toPublish);
    return !toDel.isEmpty() || !toPublish.isEmpty();
}
#end_block

#method_before
private boolean insertRobotComments(ChangeContext ctx) throws OrmException {
    if (in.robotComments == null) {
        return false;
    }
    List<RobotComment> toAdd = new ArrayList<>(in.robotComments.size());
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingRobotComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<RobotCommentInput>> ent : in.robotComments.entrySet()) {
        String path = ent.getKey();
        for (RobotCommentInput c : ent.getValue()) {
            RobotComment e = commentsUtil.newRobotComment(ctx, path, psId, c.side(), c.message, c.robotId, c.robotRunId);
            e.parentUuid = Url.decode(c.inReplyTo);
            e.url = c.url;
            e.properties = c.properties;
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toAdd.add(e);
        }
    }
    commentsUtil.putRobotComments(ctx.getUpdate(psId), toAdd);
    comments.addAll(toAdd);
    return !toAdd.isEmpty();
}
#method_after
private boolean insertRobotComments(ChangeContext ctx) throws OrmException {
    if (in.robotComments == null) {
        return false;
    }
    List<RobotComment> newRobotComments = getNewRobotComments(ctx);
    commentsUtil.putRobotComments(ctx.getUpdate(psId), newRobotComments);
    comments.addAll(newRobotComments);
    return !newRobotComments.isEmpty();
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ctx.getUser().updateRealAccountId(c::setRealAccountId);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = ApprovalsUtil.newApproval(psId, user, lt.getLabelId(), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    validatePostSubmitLabels(ctx, labelTypes, previous, ups, del);
    // This allows us to preserve their CC status.
    if (current.isEmpty() && del.isEmpty() && ups.isEmpty() && !isReviewer(ctx)) {
        return false;
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    if (PrimaryStorage.of(update.getChange()) == REVIEW_DB) {
        // Avoid OrmConcurrencyException trying to delete non-existent entities.
        ctx.getDb().patchSetApprovals().delete(del);
        ctx.getDb().patchSetApprovals().upsert(ups);
    }
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ctx.getUser().updateRealAccountId(c::setRealAccountId);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = ApprovalsUtil.newApproval(psId, user, lt.getLabelId(), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    validatePostSubmitLabels(ctx, labelTypes, previous, ups, del);
    // This allows us to preserve their CC status.
    if (current.isEmpty() && del.isEmpty() && ups.isEmpty() && !isReviewer(ctx)) {
        return false;
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void validatePostSubmitLabels(ChangeContext ctx, LabelTypes labelTypes, Map<String, Short> previous, List<PatchSetApproval> ups, List<PatchSetApproval> del) throws ResourceConflictException {
    if (ctx.getChange().getStatus().isOpen()) {
        // Not closed, nothing to validate.
        return;
    } else if (del.isEmpty() && ups.isEmpty()) {
        // No new votes.
        return;
    } else if (ctx.getChange().getStatus() != Change.Status.MERGED) {
        throw new ResourceConflictException("change is closed");
    }
    // Disallow reducing votes on any labels post-submit. This assumes the
    // high values were broadly necessary to submit, so reducing them would
    // make it possible to take a merged change and make it no longer
    // submittable.
    List<PatchSetApproval> reduced = new ArrayList<>(ups.size() + del.size());
    reduced.addAll(del);
    for (PatchSetApproval psa : ups) {
        LabelType lt = checkNotNull(labelTypes.byLabel(psa.getLabel()));
        String normName = lt.getName();
        Short prev = previous.get(normName);
        if (prev == null) {
            continue;
        }
        // Should be filtered out above.
        checkState(prev != psa.getValue());
        if (prev > psa.getValue()) {
            reduced.add(psa);
        } else {
            // Set postSubmit bit in ReviewDb; not required for NoteDb, which sets
            // it automatically.
            psa.setPostSubmit(true);
        }
    }
    if (!reduced.isEmpty()) {
        throw new ResourceConflictException("Cannot reduce vote on labels for closed change: " + reduced.stream().map(p -> p.getLabel()).distinct().sorted().collect(joining(", ")));
    }
}
#method_after
private void validatePostSubmitLabels(ChangeContext ctx, LabelTypes labelTypes, Map<String, Short> previous, List<PatchSetApproval> ups, List<PatchSetApproval> del) throws ResourceConflictException {
    if (ctx.getChange().getStatus().isOpen()) {
        // Not closed, nothing to validate.
        return;
    } else if (del.isEmpty() && ups.isEmpty()) {
        // No new votes.
        return;
    } else if (ctx.getChange().getStatus() != Change.Status.MERGED) {
        throw new ResourceConflictException("change is closed");
    }
    // Disallow reducing votes on any labels post-submit. This assumes the
    // high values were broadly necessary to submit, so reducing them would
    // make it possible to take a merged change and make it no longer
    // submittable.
    List<PatchSetApproval> reduced = new ArrayList<>(ups.size() + del.size());
    List<String> disallowed = new ArrayList<>(labelTypes.getLabelTypes().size());
    for (PatchSetApproval psa : del) {
        LabelType lt = checkNotNull(labelTypes.byLabel(psa.getLabel()));
        String normName = lt.getName();
        if (!lt.allowPostSubmit()) {
            disallowed.add(normName);
        }
        Short prev = previous.get(normName);
        if (prev != null && prev != 0) {
            reduced.add(psa);
        }
    }
    for (PatchSetApproval psa : ups) {
        LabelType lt = checkNotNull(labelTypes.byLabel(psa.getLabel()));
        String normName = lt.getName();
        if (!lt.allowPostSubmit()) {
            disallowed.add(normName);
        }
        Short prev = previous.get(normName);
        if (prev == null) {
            continue;
        }
        // Should be filtered out above.
        checkState(prev != psa.getValue());
        if (prev > psa.getValue()) {
            reduced.add(psa);
        } else {
            // Set postSubmit bit in ReviewDb; not required for NoteDb, which sets
            // it automatically.
            psa.setPostSubmit(true);
        }
    }
    if (!disallowed.isEmpty()) {
        throw new ResourceConflictException("Voting on labels disallowed after submit: " + disallowed.stream().distinct().sorted().collect(joining(", ")));
    }
    if (!reduced.isEmpty()) {
        throw new ResourceConflictException("Cannot reduce vote on labels for closed change: " + reduced.stream().map(p -> p.getLabel()).distinct().sorted().collect(joining(", ")));
    }
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, user, ctx.getWhen(), "Patch Set " + psId.get() + ":" + buf, in.tag);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (LabelVote d : labelDelta) {
        buf.append(" ").append(d.format());
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = ChangeMessagesUtil.newMessage(psId, user, ctx.getWhen(), "Patch Set " + psId.get() + ":" + buf, in.tag);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
private void addLabelDelta(String name, short value) {
    labelDelta.add(LabelVote.create(name, value).format());
}
#method_after
private void addLabelDelta(String name, short value) {
    labelDelta.add(LabelVote.create(name, value));
}
#end_block

#method_before
private CheckResult checkIdsForArbitraryUser(PGPPublicKey key) throws PGPException, OrmException {
    IdentifiedUser user;
    if (accountIndexes.getSearchIndex() != null) {
        List<AccountState> accountStates = accountQueryProvider.get().byExternalId(toExtIdKey(key).get());
        if (accountStates.isEmpty()) {
            return CheckResult.bad("Key is not associated with any users");
        }
        if (accountStates.size() > 1) {
            return CheckResult.bad("Key is associated with multiple users");
        }
        user = userFactory.create(accountStates.get(0));
    } else {
        AccountExternalId extId = db.get().accountExternalIds().get(toExtIdKey(key));
        if (extId == null) {
            return CheckResult.bad("Key is not associated with any users");
        }
        user = userFactory.create(extId.getAccountId());
    }
    Set<String> allowedUserIds = getAllowedUserIds(user);
    if (allowedUserIds.isEmpty()) {
        return CheckResult.bad("No identities found for user");
    }
    if (hasAllowedUserId(key, allowedUserIds)) {
        return CheckResult.trusted();
    }
    return CheckResult.bad("Key does not contain any valid certifications for user's identities");
}
#method_after
private CheckResult checkIdsForArbitraryUser(PGPPublicKey key) throws PGPException, OrmException {
    List<AccountState> accountStates = accountQueryProvider.get().byExternalId(toExtIdKey(key).get());
    if (accountStates.isEmpty()) {
        return CheckResult.bad("Key is not associated with any users");
    }
    if (accountStates.size() > 1) {
        return CheckResult.bad("Key is associated with multiple users");
    }
    IdentifiedUser user = userFactory.create(accountStates.get(0));
    Set<String> allowedUserIds = getAllowedUserIds(user);
    if (allowedUserIds.isEmpty()) {
        return CheckResult.bad("No identities found for user");
    }
    if (hasAllowedUserId(key, allowedUserIds)) {
        return CheckResult.trusted();
    }
    return CheckResult.bad("Key does not contain any valid certifications for user's identities");
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    if (!control.canAbandon(dbProvider.get())) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message, input.notify);
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    if (!control.canAbandon(dbProvider.get())) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message, input.notify, notifyUtil.resolveAccounts(input.notifyDetails));
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#end_block

#method_before
public Change abandon(ChangeControl control) throws RestApiException, UpdateException {
    return abandon(control, "", NotifyHandling.ALL);
}
#method_after
public Change abandon(ChangeControl control) throws RestApiException, UpdateException {
    return abandon(control, "", NotifyHandling.ALL, ImmutableListMultimap.of());
}
#end_block

#method_before
public Change abandon(ChangeControl control, String msgTxt) throws RestApiException, UpdateException {
    return abandon(control, msgTxt, NotifyHandling.ALL);
}
#method_after
public Change abandon(ChangeControl control, String msgTxt) throws RestApiException, UpdateException {
    return abandon(control, msgTxt, NotifyHandling.ALL, ImmutableListMultimap.of());
}
#end_block

#method_before
public Change abandon(ChangeControl control, String msgTxt, NotifyHandling notifyHandling) throws RestApiException, UpdateException {
    CurrentUser user = control.getUser();
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    AbandonOp op = abandonOpFactory.create(account, msgTxt, notifyHandling);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.getChange();
}
#method_after
public Change abandon(ChangeControl control, String msgTxt, NotifyHandling notifyHandling, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws RestApiException, UpdateException {
    CurrentUser user = control.getUser();
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    AbandonOp op = abandonOpFactory.create(account, msgTxt, notifyHandling, accountsToNotify);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.getChange();
}
#end_block

#method_before
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, "", NotifyHandling.ALL);
}
#method_after
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls, String msgTxt, NotifyHandling notifyHandling, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws RestApiException, UpdateException {
    if (controls.isEmpty()) {
        return;
    }
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), project, user, TimeUtil.nowTs())) {
        for (ChangeControl control : controls) {
            if (!project.equals(control.getProject().getNameKey())) {
                throw new ResourceConflictException(String.format("Project name \"%s\" doesn't match \"%s\"", control.getProject().getNameKey().get(), project.get()));
            }
            u.addOp(control.getId(), abandonOpFactory.create(account, msgTxt, notifyHandling, accountsToNotify));
        }
        u.execute();
    }
}
#end_block

#method_before
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls, String msgTxt) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, msgTxt, NotifyHandling.ALL);
}
#method_after
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls, String msgTxt) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, msgTxt, NotifyHandling.ALL, ImmutableListMultimap.of());
}
#end_block

#method_before
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, "", NotifyHandling.ALL);
}
#method_after
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, "", NotifyHandling.ALL, ImmutableListMultimap.of());
}
#end_block

#method_before
public ConfigInfo apply(ProjectControl ctrl, ConfigInput input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = ctrl.getProject().getNameKey();
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(projectName)) {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.createNewChangeForAllNotInTarget != null) {
            p.setCreateNewChangeForAllNotInTarget(input.createNewChangeForAllNotInTarget);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (serverEnableSignedPush) {
            if (input.enableSignedPush != null) {
                p.setEnableSignedPush(input.enableSignedPush);
            }
            if (input.requireSignedPush != null) {
                p.setRequireSignedPush(input.requireSignedPush);
            }
        }
        if (input.rejectImplicitMerges != null) {
            p.setRejectImplicitMerges(input.rejectImplicitMerges);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(ctrl.getProjectState(), projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            projectCache.evict(projectConfig.getProject());
            gitMgr.setProjectDescription(projectName, p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            }
            log.warn(String.format("Failed to update config of project %s.", projectName), e);
            throw new ResourceConflictException("Cannot update " + projectName);
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfoImpl(serverEnableSignedPush, state.controlFor(user.get()), config, pluginConfigEntries, cfgFactory, allProjects, views);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    }
}
#method_after
public ConfigInfo apply(ProjectControl ctrl, ConfigInput input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = ctrl.getProject().getNameKey();
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(projectName)) {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.createNewChangeForAllNotInTarget != null) {
            p.setCreateNewChangeForAllNotInTarget(input.createNewChangeForAllNotInTarget);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (serverEnableSignedPush) {
            if (input.enableSignedPush != null) {
                p.setEnableSignedPush(input.enableSignedPush);
            }
            if (input.requireSignedPush != null) {
                p.setRequireSignedPush(input.requireSignedPush);
            }
        }
        if (input.rejectImplicitMerges != null) {
            p.setRejectImplicitMerges(input.rejectImplicitMerges);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(ctrl.getProjectState(), projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            projectCache.evict(projectConfig.getProject());
            md.getRepository().setGitwebDescription(p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            }
            log.warn(String.format("Failed to update config of project %s.", projectName), e);
            throw new ResourceConflictException("Cannot update " + projectName);
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfoImpl(serverEnableSignedPush, state.controlFor(user.get()), config, pluginConfigEntries, cfgFactory, allProjects, views);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    }
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    String pkg = "gerrit-gwtui";
    String target = "ui_" + rule.select((HttpServletRequest) request);
    if (gwtuiRecompile || !uaInitialized.contains(target)) {
        String rule = "//" + pkg + ":" + target;
        // TODO(davido): instead of assuming specific Buck's internal
        // target directory for gwt_binary() artifacts, ask Buck for
        // the location of user agent permutation GWT zip, e. g.:
        // $ buck targets --show_output //gerrit-gwtui:ui_safari \
        // | awk '{print $2}'
        String child = String.format("%s/__gwt_binary_%s__", pkg, target);
        File zip = gen.resolve(child).resolve(target + ".zip").toFile();
        synchronized (this) {
            try {
                BuckUtils.build(root, gen, rule);
            } catch (BuildFailureException e) {
                BuckUtils.displayFailure(rule, e.why, (HttpServletResponse) res);
                return;
            }
            if (!target.equals(lastTarget) || lastTime != zip.lastModified()) {
                lastTarget = target;
                lastTime = zip.lastModified();
                unpack(zip, unpackedWar.toFile());
            }
        }
        uaInitialized.add(target);
    }
    chain.doFilter(request, res);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    String agent = rule.select((HttpServletRequest) request);
    if (unpackedWar != null && (gwtuiRecompile || !uaInitialized.contains(agent))) {
        Label label = builder.gwtZipLabel(agent);
        File zip = builder.targetPath(label).toFile();
        synchronized (this) {
            try {
                builder.build(label);
            } catch (BuildSystem.BuildFailureException e) {
                e.display(label.toString(), (HttpServletResponse) res);
                return;
            }
            if (!agent.equals(lastAgent) || lastTime != zip.lastModified()) {
                lastAgent = agent;
                lastTime = zip.lastModified();
                unpack(zip, unpackedWar.toFile());
            }
        }
        uaInitialized.add(agent);
    }
    chain.doFilter(request, res);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    sshUrl = adminSshSession.getUrl();
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    patchSetLock = Util.patchSetLock();
    cfg.getLabelSections().put(patchSetLock.getName(), patchSetLock);
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(patchSetLock.getName()), 0, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(cfg);
    grant(Permission.LABEL + "Patch-Set-Lock", project, "refs/heads/*");
}
#method_after
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    patchSetLock = Util.patchSetLock();
    cfg.getLabelSections().put(patchSetLock.getName(), patchSetLock);
    AccountGroup.UUID anonymousUsers = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(patchSetLock.getName()), 0, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(cfg);
    grant(Permission.LABEL + "Patch-Set-Lock", project, "refs/heads/*");
}
#end_block

#method_before
protected void selectProtocol(Protocol p) throws Exception {
    String url;
    switch(p) {
        case SSH:
            url = sshUrl;
            break;
        case HTTP:
            url = admin.getHttpUrl(server);
            break;
        default:
            throw new IllegalArgumentException("unexpected protocol: " + p);
    }
    testRepo = GitUtil.cloneProject(project, url + "/" + project.get());
}
#method_after
protected void selectProtocol(Protocol p) throws Exception {
    String url;
    switch(p) {
        case SSH:
            url = adminSshSession.getUrl();
            break;
        case HTTP:
            url = admin.getHttpUrl(server);
            break;
        default:
            throw new IllegalArgumentException("unexpected protocol: " + p);
    }
    testRepo = GitUtil.cloneProject(project, url + "/" + project.get());
}
#end_block

#method_before
@Test
public void pushForMasterWithNotify() throws Exception {
    TestAccount user2 = accounts.user2();
    String pushSpec = "refs/for/master" + "%reviewer=" + user.email + ",cc=" + user2.email;
    sender.clear();
    PushOneCommit.Result r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE);
    r.assertOkStatus();
    assertThat(sender.getMessages()).hasSize(0);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.OWNER);
    r.assertOkStatus();
    // no email notification about own changes
    assertThat(sender.getMessages()).hasSize(0);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.OWNER_REVIEWERS);
    r.assertOkStatus();
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.ALL);
    r.assertOkStatus();
    assertThat(sender.getMessages()).hasSize(1);
    m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress, user2.emailAddress);
}
#method_after
@Test
public void pushForMasterWithNotify() throws Exception {
    // create a user that watches the project
    TestAccount user3 = accounts.create("user3", "user3@example.com", "User3");
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = project.get();
    pwi.filter = "*";
    pwi.notifyNewChanges = true;
    projectsToWatch.add(pwi);
    setApiUser(user3);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    TestAccount user2 = accounts.user2();
    String pushSpec = "refs/for/master" + "%reviewer=" + user.email + ",cc=" + user2.email;
    sender.clear();
    PushOneCommit.Result r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE);
    r.assertOkStatus();
    assertThat(sender.getMessages()).isEmpty();
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.OWNER);
    r.assertOkStatus();
    // no email notification about own changes
    assertThat(sender.getMessages()).isEmpty();
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.OWNER_REVIEWERS);
    r.assertOkStatus();
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.ALL);
    r.assertOkStatus();
    assertThat(sender.getMessages()).hasSize(1);
    m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress, user2.emailAddress, user3.emailAddress);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-to=" + user3.email);
    r.assertOkStatus();
    assertNotifyTo(user3);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-cc=" + user3.email);
    r.assertOkStatus();
    assertNotifyCc(user3);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-bcc=" + user3.email);
    r.assertOkStatus();
    assertNotifyBcc(user3);
    // request that sender gets notified as TO, CC and BCC, email should be sent
    // even if the sender is the only recipient
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-to=" + admin.email);
    assertNotifyTo(admin);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-cc=" + admin.email);
    r.assertOkStatus();
    assertNotifyCc(admin);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-bcc=" + admin.email);
    r.assertOkStatus();
    assertNotifyBcc(admin);
}
#end_block

#method_before
@Test
public void pushForMasterAsEdit() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    EditInfo edit = getEdit(r.getChangeId());
    assertThat(edit).isNull();
    // specify edit as option
    r = amendChange(r.getChangeId(), "refs/for/master%edit");
    r.assertOkStatus();
    edit = getEdit(r.getChangeId());
    assertThat(edit).isNotNull();
    r.assertMessage("Updated Changes:\n  " + canonicalWebUrl.get() + r.getChange().getId() + " " + edit.commit.subject + " [EDIT]\n");
}
#method_after
@Test
public void pushForMasterAsEdit() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    Optional<EditInfo> edit = getEdit(r.getChangeId());
    assertThat(edit).isAbsent();
    // specify edit as option
    r = amendChange(r.getChangeId(), "refs/for/master%edit");
    r.assertOkStatus();
    edit = getEdit(r.getChangeId());
    assertThat(edit).isPresent();
    EditInfo editInfo = edit.get();
    r.assertMessage("Updated Changes:\n  " + canonicalWebUrl.get() + r.getChange().getId() + " " + editInfo.commit.subject + " [EDIT]\n");
}
#end_block

#method_before
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
}
#method_after
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
}
#end_block

#method_before
@Override
public String apply(GroupResource rsrc, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, ResourceConflictException, OrmException, NoSuchGroupException {
    if (rsrc.toAccountGroup() == null) {
        throw new MethodNotAllowedException();
    } else if (!rsrc.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    } else if (input == null || Strings.isNullOrEmpty(input.name)) {
        throw new BadRequestException("name is required");
    }
    String newName = input.name.trim();
    if (newName.isEmpty()) {
        throw new BadRequestException("name is required");
    }
    if (rsrc.toAccountGroup().getName().equals(newName)) {
        return newName;
    }
    return renameGroup(rsrc.toAccountGroup(), newName).group.getName();
}
#method_after
@Override
public String apply(GroupResource rsrc, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, ResourceConflictException, OrmException, NoSuchGroupException, IOException {
    if (rsrc.toAccountGroup() == null) {
        throw new MethodNotAllowedException();
    } else if (!rsrc.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    } else if (input == null || Strings.isNullOrEmpty(input.name)) {
        throw new BadRequestException("name is required");
    }
    String newName = input.name.trim();
    if (newName.isEmpty()) {
        throw new BadRequestException("name is required");
    }
    if (rsrc.toAccountGroup().getName().equals(newName)) {
        return newName;
    }
    return renameGroup(rsrc.toAccountGroup(), newName).group.getName();
}
#end_block

#method_before
private GroupDetail renameGroup(AccountGroup group, String newName) throws ResourceConflictException, OrmException, NoSuchGroupException {
    AccountGroup.Id groupId = group.getId();
    AccountGroup.NameKey old = group.getNameKey();
    AccountGroup.NameKey key = new AccountGroup.NameKey(newName);
    try {
        AccountGroupName id = new AccountGroupName(key, groupId);
        db.get().accountGroupNames().insert(Collections.singleton(id));
    } catch (OrmException e) {
        AccountGroupName other = db.get().accountGroupNames().get(key);
        if (other != null) {
            // 
            if (other.getId().equals(groupId)) {
                return groupDetailFactory.create(groupId).call();
            }
            // 
            throw new ResourceConflictException("group with name " + newName + "already exists");
        }
        throw e;
    }
    group.setNameKey(key);
    db.get().accountGroups().update(Collections.singleton(group));
    AccountGroupName priorName = db.get().accountGroupNames().get(old);
    if (priorName != null) {
        db.get().accountGroupNames().delete(Collections.singleton(priorName));
    }
    groupCache.evict(group);
    groupCache.evictAfterRename(old, key);
    renameGroupOpFactory.create(currentUser.get().newCommitterIdent(new Date(), TimeZone.getDefault()), group.getGroupUUID(), old.get(), newName).start(0, TimeUnit.MILLISECONDS);
    return groupDetailFactory.create(groupId).call();
}
#method_after
private GroupDetail renameGroup(AccountGroup group, String newName) throws ResourceConflictException, OrmException, NoSuchGroupException, IOException {
    AccountGroup.Id groupId = group.getId();
    AccountGroup.NameKey old = group.getNameKey();
    AccountGroup.NameKey key = new AccountGroup.NameKey(newName);
    try {
        AccountGroupName id = new AccountGroupName(key, groupId);
        db.get().accountGroupNames().insert(Collections.singleton(id));
    } catch (OrmException e) {
        AccountGroupName other = db.get().accountGroupNames().get(key);
        if (other != null) {
            // 
            if (other.getId().equals(groupId)) {
                return groupDetailFactory.create(groupId).call();
            }
            // 
            throw new ResourceConflictException("group with name " + newName + "already exists");
        }
        throw e;
    }
    group.setNameKey(key);
    db.get().accountGroups().update(Collections.singleton(group));
    AccountGroupName priorName = db.get().accountGroupNames().get(old);
    if (priorName != null) {
        db.get().accountGroupNames().delete(Collections.singleton(priorName));
    }
    groupCache.evict(group);
    groupCache.evictAfterRename(old, key);
    renameGroupOpFactory.create(currentUser.get().newCommitterIdent(new Date(), TimeZone.getDefault()), group.getGroupUUID(), old.get(), newName).start(0, TimeUnit.MILLISECONDS);
    return groupDetailFactory.create(groupId).call();
}
#end_block

#method_before
public static GroupReference getGroup(AccountGroup.UUID uuid) {
    return checkNotNull(uuids.get(uuid), "group %s not found", uuid.get());
}
#method_after
public GroupReference getGroup(AccountGroup.UUID uuid) {
    return checkNotNull(uuids.get(uuid), "group %s not found", uuid.get());
}
#end_block

#method_before
public static List<String> getNames() {
    List<String> names = new ArrayList<>();
    for (AccountGroup.UUID uuid : all) {
        int c = uuid.get().indexOf(':');
        names.add(uuid.get().substring(c + 1).replace('-', ' '));
    }
    return names;
}
#method_after
public Set<String> getNames() {
    return names.values().stream().map(r -> r.getName()).collect(toSet());
}
#end_block

#method_before
@Override
public GroupDescription.Basic get(AccountGroup.UUID uuid) {
    final GroupReference ref = getGroup(uuid);
    return new GroupDescription.Basic() {

        @Override
        public String getName() {
            return ref.getName();
        }

        @Override
        public AccountGroup.UUID getGroupUUID() {
            return ref.getUUID();
        }

        @Override
        public String getUrl() {
            return null;
        }

        @Override
        public String getEmailAddress() {
            return null;
        }
    };
}
#method_after
@Override
public GroupDescription.Basic get(AccountGroup.UUID uuid) {
    final GroupReference ref = uuids.get(uuid);
    if (ref == null) {
        return null;
    }
    return new GroupDescription.Basic() {

        @Override
        public String getName() {
            return ref.getName();
        }

        @Override
        public AccountGroup.UUID getGroupUUID() {
            return ref.getUUID();
        }

        @Override
        public String getUrl() {
            return null;
        }

        @Override
        public String getEmailAddress() {
            return null;
        }
    };
}
#end_block

#method_before
public MetaDataUpdate create(Project.NameKey name, IdentifiedUser user, BatchRefUpdate batch) throws RepositoryNotFoundException, IOException {
    return create(name, mgr.openRepository(name), user, batch);
}
#method_after
public MetaDataUpdate create(Project.NameKey name, IdentifiedUser user, BatchRefUpdate batch) throws RepositoryNotFoundException, IOException {
    Repository repo = mgr.openRepository(name);
    MetaDataUpdate md = create(name, repo, user, batch);
    md.setCloseRepository(true);
    return md;
}
#end_block

#method_before
public MetaDataUpdate create(Project.NameKey name, BatchRefUpdate batch) throws RepositoryNotFoundException, IOException {
    MetaDataUpdate md = factory.create(name, mgr.openRepository(name), batch);
    md.getCommitBuilder().setAuthor(serverIdent);
    md.getCommitBuilder().setCommitter(serverIdent);
    return md;
}
#method_after
public MetaDataUpdate create(Project.NameKey name, BatchRefUpdate batch) throws RepositoryNotFoundException, IOException {
    Repository repo = mgr.openRepository(name);
    MetaDataUpdate md = factory.create(name, repo, batch);
    md.setCloseRepository(true);
    md.getCommitBuilder().setAuthor(serverIdent);
    md.getCommitBuilder().setCommitter(serverIdent);
    return md;
}
#end_block

#method_before
@Override
public void close() {
    getRepository().close();
}
#method_after
@Override
public void close() {
    if (closeRepository) {
        getRepository().close();
    }
}
#end_block

#method_before
public Repository getRepository() {
    return db;
}
#method_after
public Repository getRepository() {
    return repository;
}
#end_block

#method_before
void fireGitRefUpdatedEvent(RefUpdate ru) {
    gitRefUpdated.fire(projectName, ru, author == null ? null : author.getAccount());
}
#method_after
protected void fireGitRefUpdatedEvent(RefUpdate ru) {
    gitRefUpdated.fire(projectName, ru, author == null ? null : author.getAccount());
}
#end_block

#method_before
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    return ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_ABANDON);
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    return ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_ABANDON);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(ctx.getProject(), change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message.getMessage(), ctx.getWhen());
        cm.setNotify(notifyHandling);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeAbandoned.fire(change, patchSet, account, msgTxt, ctx.getWhen(), notifyHandling);
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(ctx.getProject(), change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message.getMessage(), ctx.getWhen());
        cm.setNotify(notifyHandling);
        cm.setAccountsToNotify(accountsToNotify);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeAbandoned.fire(change, patchSet, account, msgTxt, ctx.getWhen(), notifyHandling);
}
#end_block

#method_before
@Test
public void moveChangeToBranchWithoutUploadPerms() throws Exception {
    // Move change to a destination where user doesn't have upload permissions
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "blocked_branch");
    createBranch(newBranch);
    block(Permission.PUSH, SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID(), "refs/for/" + newBranch.get());
    exception.expect(AuthException.class);
    exception.expectMessage("Move not permitted");
    move(r.getChangeId(), newBranch.get());
}
#method_after
@Test
public void moveChangeToBranchWithoutUploadPerms() throws Exception {
    // Move change to a destination where user doesn't have upload permissions
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "blocked_branch");
    createBranch(newBranch);
    block(Permission.PUSH, systemGroupBackend.getGroup(REGISTERED_USERS).getUUID(), "refs/for/" + newBranch.get());
    exception.expect(AuthException.class);
    exception.expectMessage("Move not permitted");
    move(r.getChangeId(), newBranch.get());
}
#end_block

#method_before
@Test
public void moveChangeFromBranchWithoutAbandonPerms() throws Exception {
    // Move change for which user does not have abandon permissions
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    block(Permission.ABANDON, SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID(), r.getChange().change().getDest().get());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("Move not permitted");
    move(r.getChangeId(), newBranch.get());
}
#method_after
@Test
public void moveChangeFromBranchWithoutAbandonPerms() throws Exception {
    // Move change for which user does not have abandon permissions
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    block(Permission.ABANDON, systemGroupBackend.getGroup(REGISTERED_USERS).getUUID(), r.getChange().change().getDest().get());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("Move not permitted");
    move(r.getChangeId(), newBranch.get());
}
#end_block

#method_before
@Test
public void moveChangeWithCurrentPatchSetLocked() throws Exception {
    // Move change that is locked
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType patchSetLock = Util.patchSetLock();
    cfg.getLabelSections().put(patchSetLock.getName(), patchSetLock);
    AccountGroup.UUID registeredUsers = SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(patchSetLock.getName()), 0, 1, registeredUsers, "refs/heads/*");
    saveProjectConfig(cfg);
    grant(Permission.LABEL + "Patch-Set-Lock", project, "refs/heads/*");
    revision(r).review(new ReviewInput().label("Patch-Set-Lock", 1));
    exception.expect(AuthException.class);
    exception.expectMessage("Move not permitted");
    move(r.getChangeId(), newBranch.get());
}
#method_after
@Test
public void moveChangeWithCurrentPatchSetLocked() throws Exception {
    // Move change that is locked
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType patchSetLock = Util.patchSetLock();
    cfg.getLabelSections().put(patchSetLock.getName(), patchSetLock);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(patchSetLock.getName()), 0, 1, registeredUsers, "refs/heads/*");
    saveProjectConfig(cfg);
    grant(Permission.LABEL + "Patch-Set-Lock", project, "refs/heads/*");
    revision(r).review(new ReviewInput().label("Patch-Set-Lock", 1));
    exception.expect(AuthException.class);
    exception.expectMessage("Move not permitted");
    move(r.getChangeId(), newBranch.get());
}
#end_block

#method_before
@Override
public boolean containsAnyOf(Iterable<AccountGroup.UUID> uuids) {
    Multimap<GroupMembership, AccountGroup.UUID> lookups = ArrayListMultimap.create();
    for (AccountGroup.UUID uuid : uuids) {
        if (uuid == null) {
            continue;
        }
        GroupMembership m = membership(uuid);
        if (m == null) {
            log.debug("Unknown GroupMembership for UUID: " + uuid);
            continue;
        }
        lookups.put(m, uuid);
    }
    for (Map.Entry<GroupMembership, Collection<AccountGroup.UUID>> entry : lookups.asMap().entrySet()) {
        GroupMembership m = entry.getKey();
        Collection<AccountGroup.UUID> ids = entry.getValue();
        if (ids.size() == 1) {
            if (m.contains(Iterables.getOnlyElement(ids))) {
                return true;
            }
        } else if (m.containsAnyOf(ids)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean containsAnyOf(Iterable<AccountGroup.UUID> uuids) {
    ListMultimap<GroupMembership, AccountGroup.UUID> lookups = MultimapBuilder.hashKeys().arrayListValues().build();
    for (AccountGroup.UUID uuid : uuids) {
        if (uuid == null) {
            continue;
        }
        GroupMembership m = membership(uuid);
        if (m == null) {
            log.debug("Unknown GroupMembership for UUID: " + uuid);
            continue;
        }
        lookups.put(m, uuid);
    }
    for (Map.Entry<GroupMembership, Collection<AccountGroup.UUID>> entry : lookups.asMap().entrySet()) {
        GroupMembership m = entry.getKey();
        Collection<AccountGroup.UUID> ids = entry.getValue();
        if (ids.size() == 1) {
            if (m.contains(Iterables.getOnlyElement(ids))) {
                return true;
            }
        } else if (m.containsAnyOf(ids)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public Set<AccountGroup.UUID> intersection(Iterable<AccountGroup.UUID> uuids) {
    Multimap<GroupMembership, AccountGroup.UUID> lookups = ArrayListMultimap.create();
    for (AccountGroup.UUID uuid : uuids) {
        if (uuid == null) {
            continue;
        }
        GroupMembership m = membership(uuid);
        if (m == null) {
            log.debug("Unknown GroupMembership for UUID: " + uuid);
            continue;
        }
        lookups.put(m, uuid);
    }
    Set<AccountGroup.UUID> groups = new HashSet<>();
    for (Map.Entry<GroupMembership, Collection<AccountGroup.UUID>> entry : lookups.asMap().entrySet()) {
        groups.addAll(entry.getKey().intersection(entry.getValue()));
    }
    return groups;
}
#method_after
@Override
public Set<AccountGroup.UUID> intersection(Iterable<AccountGroup.UUID> uuids) {
    ListMultimap<GroupMembership, AccountGroup.UUID> lookups = MultimapBuilder.hashKeys().arrayListValues().build();
    for (AccountGroup.UUID uuid : uuids) {
        if (uuid == null) {
            continue;
        }
        GroupMembership m = membership(uuid);
        if (m == null) {
            log.debug("Unknown GroupMembership for UUID: " + uuid);
            continue;
        }
        lookups.put(m, uuid);
    }
    Set<AccountGroup.UUID> groups = new HashSet<>();
    for (Map.Entry<GroupMembership, Collection<AccountGroup.UUID>> entry : lookups.asMap().entrySet()) {
        groups.addAll(entry.getKey().intersection(entry.getValue()));
    }
    return groups;
}
#end_block

#method_before
public Map<String, ActionInfo> format(RevisionResource rsrc) {
    return toActionMap(rsrc);
}
#method_after
public Map<String, ActionInfo> format(RevisionResource rsrc) throws OrmException {
    ChangeInfo changeInfo = null;
    RevisionInfo revisionInfo = null;
    List<ActionVisitor> visitors = visitors();
    if (!visitors.isEmpty()) {
        changeInfo = changeJson().format(rsrc);
        revisionInfo = checkNotNull(Iterables.getOnlyElement(changeInfo.revisions.values()));
        changeInfo.revisions = null;
    }
    return toActionMap(rsrc, visitors, changeInfo, revisionInfo);
}
#end_block

#method_before
public ChangeInfo addChangeActions(ChangeInfo to, ChangeControl ctl) {
    to.actions = toActionMap(ctl);
    return to;
}
#method_after
public ChangeInfo addChangeActions(ChangeInfo to, ChangeControl ctl) {
    List<ActionVisitor> visitors = visitors();
    to.actions = toActionMap(ctl, visitors, copy(visitors, to));
    return to;
}
#end_block

#method_before
public RevisionInfo addRevisionActions(RevisionInfo to, RevisionResource rsrc) {
    to.actions = toActionMap(rsrc);
    return to;
}
#method_after
public RevisionInfo addRevisionActions(@Nullable ChangeInfo changeInfo, RevisionInfo to, RevisionResource rsrc) throws OrmException {
    List<ActionVisitor> visitors = visitors();
    if (!visitors.isEmpty()) {
        if (changeInfo != null) {
            changeInfo = copy(visitors, changeInfo);
        } else {
            changeInfo = changeJson().format(rsrc);
        }
    }
    to.actions = toActionMap(rsrc, visitors, changeInfo, copy(visitors, to));
    return to;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (rsrc.getControl().getUser().isIdentifiedUser()) {
        Provider<CurrentUser> userProvider = Providers.of(rsrc.getControl().getUser());
        for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider)) {
            out.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(ChangeControl ctl, List<ActionVisitor> visitors, ChangeInfo changeInfo) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (!ctl.getUser().isIdentifiedUser()) {
        return out;
    }
    Provider<CurrentUser> userProvider = Providers.of(ctl.getUser());
    FluentIterable<UiAction.Description> descs = UiActions.from(changeViews, changeResourceFactory.create(ctl), userProvider);
    // resulting action map.
    if (ctl.getChange().getStatus().isOpen()) {
        UiAction.Description descr = new UiAction.Description();
        PrivateInternals_UiActionDescription.setId(descr, "followup");
        PrivateInternals_UiActionDescription.setMethod(descr, "POST");
        descr.setTitle("Create follow-up change");
        descr.setLabel("Follow-Up");
        descs = descs.append(descr);
    }
    ACTION: for (UiAction.Description d : descs) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#end_block

#method_before
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        Multimap<String, String> external = ArrayListMultimap.create();
        for (ExternalIncludedIn ext : includedIn) {
            Multimap<String, String> extIncludedIns = ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches());
            if (extIncludedIns != null) {
                external.putAll(extIncludedIns);
            }
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external.asMap() : null));
    }
}
#method_after
public IncludedInInfo apply(Project.NameKey project, String revisionId) throws RestApiException, IOException {
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(revisionId));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        ListMultimap<String, String> external = MultimapBuilder.hashKeys().arrayListValues().build();
        for (ExternalIncludedIn ext : externalIncludedIn) {
            ListMultimap<String, String> extIncludedIns = ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches());
            if (extIncludedIns != null) {
                external.putAll(extIncludedIns);
            }
        }
        return new IncludedInInfo(d.getBranches(), d.getTags(), (!external.isEmpty() ? external.asMap() : null));
    }
}
#end_block

#method_before
@Override
public Set<Account.Id> load(String email) throws Exception {
    try (ReviewDb db = schema.open()) {
        Set<Account.Id> r = new HashSet<>();
        for (Account a : db.accounts().byPreferredEmail(email)) {
            r.add(a.getId());
        }
        if (accountIndexes.getSearchIndex() != null) {
            for (AccountState accountState : accountQueryProvider.get().byExternalId((new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email)).get())) {
                r.add(accountState.getAccount().getId());
            }
        } else {
            for (AccountExternalId a : db.accountExternalIds().byEmailAddress(email)) {
                r.add(a.getAccountId());
            }
        }
        return ImmutableSet.copyOf(r);
    }
}
#method_after
@Override
public Set<Account.Id> load(String email) throws Exception {
    try (ReviewDb db = schema.open()) {
        Set<Account.Id> r = new HashSet<>();
        for (Account a : db.accounts().byPreferredEmail(email)) {
            r.add(a.getId());
        }
        for (AccountState accountState : accountQueryProvider.get().byExternalId((new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email)).get())) {
            r.add(accountState.getAccount().getId());
        }
        return ImmutableSet.copyOf(r);
    }
}
#end_block

#method_before
private List<BlameInfo> blame(ObjectId id, String path, Repository repository, RevWalk revWalk) throws IOException {
    ListMultimap<BlameInfo, RangeInfo> ranges = ArrayListMultimap.create();
    List<BlameInfo> result = new ArrayList<>();
    if (blameCache.findLastCommit(repository, id, path) == null) {
        return result;
    }
    List<Region> blameRegions = blameCache.get(repository, id, path);
    int from = 1;
    for (Region region : blameRegions) {
        RevCommit commit = revWalk.parseCommit(region.getSourceCommit());
        BlameInfo blameInfo = toBlameInfo(commit, region.getSourceAuthor());
        ranges.put(blameInfo, new RangeInfo(from, from + region.getCount() - 1));
        from += region.getCount();
    }
    for (BlameInfo key : ranges.keySet()) {
        key.ranges = ranges.get(key);
        result.add(key);
    }
    return result;
}
#method_after
private List<BlameInfo> blame(ObjectId id, String path, Repository repository, RevWalk revWalk) throws IOException {
    ListMultimap<BlameInfo, RangeInfo> ranges = MultimapBuilder.hashKeys().arrayListValues().build();
    List<BlameInfo> result = new ArrayList<>();
    if (blameCache.findLastCommit(repository, id, path) == null) {
        return result;
    }
    List<Region> blameRegions = blameCache.get(repository, id, path);
    int from = 1;
    for (Region region : blameRegions) {
        RevCommit commit = revWalk.parseCommit(region.getSourceCommit());
        BlameInfo blameInfo = toBlameInfo(commit, region.getSourceAuthor());
        ranges.put(blameInfo, new RangeInfo(from, from + region.getCount() - 1));
        from += region.getCount();
    }
    for (BlameInfo key : ranges.keySet()) {
        key.ranges = ranges.get(key);
        result.add(key);
    }
    return result;
}
#end_block

#method_before
@Override
public Response<List<AccountInfo>> apply(ChangeResource rsrc) throws OrmException {
    Set<Account.Id> pastAssignees = rsrc.getControl().getNotes().load().getPastAssignees();
    if (pastAssignees == null) {
        return Response.ok(Collections.emptyList());
    }
    AccountInfoCacheFactory accountInfoFactory = accountInfos.create();
    return Response.ok(pastAssignees.stream().map(accountInfoFactory::get).map(AccountJson::toAccountInfo).collect(toList()));
}
#method_after
@Override
public Response<List<AccountInfo>> apply(ChangeResource rsrc) throws OrmException {
    Set<Account.Id> pastAssignees = rsrc.getControl().getNotes().load().getPastAssignees();
    if (pastAssignees == null) {
        return Response.ok(Collections.emptyList());
    }
    AccountLoader accountLoader = accountLoaderFactory.create(true);
    List<AccountInfo> infos = pastAssignees.stream().map(accountLoader::get).collect(toList());
    accountLoader.fill();
    return Response.ok(infos);
}
#end_block

#method_before
public void parseOptionMap(Map<String, String[]> parameters) throws CmdLineException {
    Multimap<String, String> map = LinkedHashMultimap.create();
    for (Map.Entry<String, String[]> ent : parameters.entrySet()) {
        for (String val : ent.getValue()) {
            map.put(ent.getKey(), val);
        }
    }
    parseOptionMap(map);
}
#method_after
public void parseOptionMap(Map<String, String[]> parameters) throws CmdLineException {
    ListMultimap<String, String> map = MultimapBuilder.hashKeys().arrayListValues().build();
    for (Map.Entry<String, String[]> ent : parameters.entrySet()) {
        for (String val : ent.getValue()) {
            map.put(ent.getKey(), val);
        }
    }
    parseOptionMap(map);
}
#end_block

#method_before
public void parseOptionMap(Multimap<String, String> params) throws CmdLineException {
    List<String> tmp = Lists.newArrayListWithCapacity(2 * params.size());
    for (final String key : params.keySet()) {
        String name = makeOption(key);
        if (isBoolean(name)) {
            boolean on = false;
            for (String value : params.get(key)) {
                on = toBoolean(key, value);
            }
            if (on) {
                tmp.add(name);
            }
        } else {
            for (String value : params.get(key)) {
                tmp.add(name);
                tmp.add(value);
            }
        }
    }
    parser.parseArgument(tmp.toArray(new String[tmp.size()]));
}
#method_after
public void parseOptionMap(ListMultimap<String, String> params) throws CmdLineException {
    List<String> tmp = Lists.newArrayListWithCapacity(2 * params.size());
    for (final String key : params.keySet()) {
        String name = makeOption(key);
        if (isBoolean(name)) {
            boolean on = false;
            for (String value : params.get(key)) {
                on = toBoolean(key, value);
            }
            if (on) {
                tmp.add(name);
            }
        } else {
            for (String value : params.get(key)) {
                tmp.add(name);
                tmp.add(value);
            }
        }
    }
    parser.parseArgument(tmp.toArray(new String[tmp.size()]));
}
#end_block

#method_before
@Test
public void setAndDeleteWatchedProjects() throws Exception {
    String projectName1 = createProject(NEW_PROJECT_NAME).get();
    String projectName2 = createProject(NEW_PROJECT_NAME + "2").get();
    List<ProjectWatchInfo> projectsToWatch = new LinkedList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName1;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    pwi = new ProjectWatchInfo();
    pwi.project = projectName2;
    pwi.filter = "branch:master";
    pwi.notifySubmittedChanges = true;
    pwi.notifyNewPatchSets = true;
    projectsToWatch.add(pwi);
    // Persist watched projects
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    List<ProjectWatchInfo> d = Lists.newArrayList(pwi);
    gApi.accounts().self().deleteWatchedProjects(d);
    projectsToWatch.remove(pwi);
    List<ProjectWatchInfo> persistedWatchedProjects = gApi.accounts().self().getWatchedProjects();
    assertThat(persistedWatchedProjects).doesNotContain(pwi);
    assertThat(persistedWatchedProjects).containsAllIn(projectsToWatch);
}
#method_after
@Test
public void setAndDeleteWatchedProjects() throws Exception {
    String projectName1 = createProject(NEW_PROJECT_NAME).get();
    String projectName2 = createProject(NEW_PROJECT_NAME + "2").get();
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName1;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    pwi = new ProjectWatchInfo();
    pwi.project = projectName2;
    pwi.filter = "branch:master";
    pwi.notifySubmittedChanges = true;
    pwi.notifyNewPatchSets = true;
    projectsToWatch.add(pwi);
    // Persist watched projects
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    List<ProjectWatchInfo> d = Lists.newArrayList(pwi);
    gApi.accounts().self().deleteWatchedProjects(d);
    projectsToWatch.remove(pwi);
    List<ProjectWatchInfo> persistedWatchedProjects = gApi.accounts().self().getWatchedProjects();
    assertThat(persistedWatchedProjects).doesNotContain(pwi);
    assertThat(persistedWatchedProjects).containsAllIn(projectsToWatch);
}
#end_block

#method_before
@Test
public void setConflictingWatches() throws Exception {
    String projectName = createProject(NEW_PROJECT_NAME).get();
    List<ProjectWatchInfo> projectsToWatch = new LinkedList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifySubmittedChanges = true;
    pwi.notifyNewPatchSets = true;
    projectsToWatch.add(pwi);
    exception.expect(BadRequestException.class);
    exception.expectMessage("duplicate entry for project " + projectName);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
}
#method_after
@Test
public void setConflictingWatches() throws Exception {
    String projectName = createProject(NEW_PROJECT_NAME).get();
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifySubmittedChanges = true;
    pwi.notifyNewPatchSets = true;
    projectsToWatch.add(pwi);
    exception.expect(BadRequestException.class);
    exception.expectMessage("duplicate entry for project " + projectName);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
}
#end_block

#method_before
@Test
public void setAndGetEmptyWatch() throws Exception {
    String projectName = createProject(NEW_PROJECT_NAME).get();
    List<ProjectWatchInfo> projectsToWatch = new LinkedList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    List<ProjectWatchInfo> persistedWatchedProjects = gApi.accounts().self().getWatchedProjects();
    assertThat(persistedWatchedProjects).containsAllIn(projectsToWatch);
}
#method_after
@Test
public void setAndGetEmptyWatch() throws Exception {
    String projectName = createProject(NEW_PROJECT_NAME).get();
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    List<ProjectWatchInfo> persistedWatchedProjects = gApi.accounts().self().getWatchedProjects();
    assertThat(persistedWatchedProjects).containsAllIn(projectsToWatch);
}
#end_block

#method_before
@Test
public void deleteNonExistingProjectWatch() throws Exception {
    String projectName = project.get();
    // Let another user watch a project
    setApiUser(admin);
    List<ProjectWatchInfo> projectsToWatch = new LinkedList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    // Try to delete a watched project using a different user
    List<ProjectWatchInfo> d = Lists.newArrayList(pwi);
    gApi.accounts().self().deleteWatchedProjects(d);
    // Check that trying to delete a non-existing watch doesn't fail
    setApiUser(user);
    gApi.accounts().self().deleteWatchedProjects(d);
}
#method_after
@Test
public void deleteNonExistingProjectWatch() throws Exception {
    String projectName = project.get();
    // Let another user watch a project
    setApiUser(admin);
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    // Try to delete a watched project using a different user
    List<ProjectWatchInfo> d = Lists.newArrayList(pwi);
    gApi.accounts().self().deleteWatchedProjects(d);
    // Check that trying to delete a non-existing watch doesn't fail
    setApiUser(user);
    gApi.accounts().self().deleteWatchedProjects(d);
}
#end_block

#method_before
@Test
public void modifyProjectWatchUsingOmittedValues() throws Exception {
    String projectName = project.get();
    // Let another user watch a project
    setApiUser(admin);
    List<ProjectWatchInfo> projectsToWatch = new LinkedList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    // Persist a defined state
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    // Omit previously set value - will set it to false on the server
    // The response will not carry this field then as we omit sending
    // false values in JSON
    pwi.notifyNewChanges = null;
    // Perform update
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    List<ProjectWatchInfo> watchedProjects = gApi.accounts().self().getWatchedProjects();
    assertThat(watchedProjects).containsAllIn(projectsToWatch);
}
#method_after
@Test
public void modifyProjectWatchUsingOmittedValues() throws Exception {
    String projectName = project.get();
    // Let another user watch a project
    setApiUser(admin);
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    // Persist a defined state
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    // Omit previously set value - will set it to false on the server
    // The response will not carry this field then as we omit sending
    // false values in JSON
    pwi.notifyNewChanges = null;
    // Perform update
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    List<ProjectWatchInfo> watchedProjects = gApi.accounts().self().getWatchedProjects();
    assertThat(watchedProjects).containsAllIn(projectsToWatch);
}
#end_block

#method_before
@Test
public void setAndDeleteWatchedProjectsWithDifferentFilter() throws Exception {
    String projectName = project.get();
    List<ProjectWatchInfo> projectsToWatch = new LinkedList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.filter = "branch:stable";
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.filter = "branch:master";
    pwi.notifySubmittedChanges = true;
    pwi.notifyNewPatchSets = true;
    projectsToWatch.add(pwi);
    // Persist watched projects
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    List<ProjectWatchInfo> d = Lists.newArrayList(pwi);
    gApi.accounts().self().deleteWatchedProjects(d);
    projectsToWatch.remove(pwi);
    List<ProjectWatchInfo> persistedWatchedProjects = gApi.accounts().self().getWatchedProjects();
    assertThat(persistedWatchedProjects).doesNotContain(pwi);
    assertThat(persistedWatchedProjects).containsAllIn(projectsToWatch);
}
#method_after
@Test
public void setAndDeleteWatchedProjectsWithDifferentFilter() throws Exception {
    String projectName = project.get();
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.filter = "branch:stable";
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    pwi = new ProjectWatchInfo();
    pwi.project = projectName;
    pwi.filter = "branch:master";
    pwi.notifySubmittedChanges = true;
    pwi.notifyNewPatchSets = true;
    projectsToWatch.add(pwi);
    // Persist watched projects
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    List<ProjectWatchInfo> d = Lists.newArrayList(pwi);
    gApi.accounts().self().deleteWatchedProjects(d);
    projectsToWatch.remove(pwi);
    List<ProjectWatchInfo> persistedWatchedProjects = gApi.accounts().self().getWatchedProjects();
    assertThat(persistedWatchedProjects).doesNotContain(pwi);
    assertThat(persistedWatchedProjects).containsAllIn(projectsToWatch);
}
#end_block

#method_before
@Test
public void addCcAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    in.state = CC;
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(user.email);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
        assertThat(result.ccs).hasSize(1);
        AccountInfo ai = result.ccs.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(1);
        AccountInfo ai = result.reviewers.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, REVIEWER, user);
    }
    // Verify email was sent to CCed account.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    if (notesMigration.readChanges()) {
        assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review.");
    } else {
        assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
}
#method_after
@Test
public void addCcAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    in.state = CC;
    AddReviewerResult result = addReviewer(changeId, in);
    assertThat(result.input).isEqualTo(user.email);
    assertThat(result.confirm).isNull();
    assertThat(result.error).isNull();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    if (notesMigration.readChanges()) {
        assertThat(result.reviewers).isNull();
        assertThat(result.ccs).hasSize(1);
        AccountInfo ai = result.ccs.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, CC, user);
    } else {
        assertThat(result.ccs).isNull();
        assertThat(result.reviewers).hasSize(1);
        AccountInfo ai = result.reviewers.get(0);
        assertThat(ai._accountId).isEqualTo(user.id.get());
        assertReviewers(c, REVIEWER, user);
    }
    // Verify email was sent to CCed account.
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    if (notesMigration.readChanges()) {
        assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review.");
    } else {
        assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
        assertThat(m.body()).contains("I'd like you to do a code review.");
    }
}
#end_block

#method_before
@Override
public Result rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    if (failNextUpdate.getAndSet(false)) {
        throw new IOException("Update failed");
    }
    Result result = delegate.rebuild(db, changeId);
    if (stealNextUpdate.getAndSet(false)) {
        throw new IOException("Update stolen");
    }
    return result;
}
#method_after
@Override
public Result rebuild(ReviewDb db, Change.Id changeId) throws IOException, OrmException {
    return rebuild(db, changeId, true);
}
#end_block

#method_before
@Override
public Result rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    // here.
    return delegate.rebuild(manager, bundle);
}
#method_after
private Result rebuild(ReviewDb db, Change.Id changeId, boolean checkReadOnly) throws IOException, OrmException {
    if (failNextUpdate.getAndSet(false)) {
        throw new IOException("Update failed");
    }
    Result result = checkReadOnly ? delegate.rebuild(db, changeId) : delegate.rebuildEvenIfReadOnly(db, changeId);
    if (stealNextUpdate.getAndSet(false)) {
        throw new IOException("Update stolen");
    }
    return result;
}
#end_block

#method_before
@Override
public Result rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    // here.
    return delegate.rebuild(manager, bundle);
}
#method_after
@Override
public Result rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    // here.
    return delegate.rebuild(manager, bundle);
}
#end_block

#method_before
@Override
public NoteDbUpdateManager stage(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException {
    // Don't inspect stealNextUpdate; that happens in execute() below.
    return delegate.stage(db, changeId);
}
#method_after
@Override
public NoteDbUpdateManager stage(ReviewDb db, Change.Id changeId) throws IOException, OrmException {
    // Don't inspect stealNextUpdate; that happens in execute() below.
    return delegate.stage(db, changeId);
}
#end_block

#method_before
@Override
public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    if (failNextUpdate.getAndSet(false)) {
        throw new IOException("Update failed");
    }
    Result result = delegate.execute(db, changeId, manager);
    if (stealNextUpdate.getAndSet(false)) {
        throw new IOException("Update stolen");
    }
    return result;
}
#method_after
@Override
public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws OrmException, IOException {
    if (failNextUpdate.getAndSet(false)) {
        throw new IOException("Update failed");
    }
    Result result = delegate.execute(db, changeId, manager);
    if (stealNextUpdate.getAndSet(false)) {
        throw new IOException("Update stolen");
    }
    return result;
}
#end_block

#method_before
@Test
public void onlyPatchSetObjectMissingWithFix() throws Exception {
    Change c = TestChanges.newChange(project, admin.getId(), sequences.nextChangeId());
    PatchSet.Id psId = c.currentPatchSetId();
    String rev = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    PatchSet ps = newPatchSet(psId, rev, adminId);
    db.changes().insert(singleton(c));
    db.patchSets().insert(singleton(ps));
    addNoteDbCommit(c.getId(), "Create change\n" + "\n" + "Patch-set: 1\n" + "Branch: " + c.getDest().get() + "\n" + "Change-id: " + c.getKey().get() + "\n" + "Subject: Bogus subject\n" + "Commit: " + rev + "\n" + "Groups: " + rev + "\n");
    indexer.index(db, c.getProject(), c.getId());
    IdentifiedUser user = userFactory.create(admin.getId());
    ChangeControl ctl = changeControlFactory.controlFor(db, c.getProject(), c.getId(), user);
    FixInput fix = new FixInput();
    fix.deletePatchSetIfCommitMissing = true;
    assertProblems(ctl, fix, problem("Ref missing: " + ps.getId().toRefName()), problem("Object missing: patch set 1: " + rev, FIX_FAILED, "Cannot delete patch set; no patch sets would remain"));
    ctl = reload(ctl);
    assertThat(ctl.getChange().currentPatchSetId().get()).isEqualTo(1);
    assertThat(psUtil.current(db, ctl.getNotes())).isNotNull();
}
#method_after
@Test
public void onlyPatchSetObjectMissingWithFix() throws Exception {
    Change c = TestChanges.newChange(project, admin.getId(), sequences.nextChangeId());
    PatchSet.Id psId = c.currentPatchSetId();
    String rev = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    PatchSet ps = newPatchSet(psId, rev, adminId);
    if (notesMigration.changePrimaryStorage() == PrimaryStorage.REVIEW_DB) {
        db.changes().insert(singleton(c));
        db.patchSets().insert(singleton(ps));
    }
    addNoteDbCommit(c.getId(), "Create change\n" + "\n" + "Patch-set: 1\n" + "Branch: " + c.getDest().get() + "\n" + "Change-id: " + c.getKey().get() + "\n" + "Subject: Bogus subject\n" + "Commit: " + rev + "\n" + "Groups: " + rev + "\n");
    indexer.index(db, c.getProject(), c.getId());
    IdentifiedUser user = userFactory.create(admin.getId());
    ChangeControl ctl = changeControlFactory.controlFor(db, c.getProject(), c.getId(), user);
    FixInput fix = new FixInput();
    fix.deletePatchSetIfCommitMissing = true;
    assertProblems(ctl, fix, problem("Ref missing: " + ps.getId().toRefName()), problem("Object missing: patch set 1: " + rev, FIX_FAILED, "Cannot delete patch set; no patch sets would remain"));
    ctl = reload(ctl);
    assertThat(ctl.getChange().currentPatchSetId().get()).isEqualTo(1);
    assertThat(psUtil.current(db, ctl.getNotes())).isNotNull();
}
#end_block

#method_before
private PatchSet insertMissingPatchSet(ChangeControl ctl, String rev) throws Exception {
    // Don't use BatchUpdate since we're manually updating the meta ref rather
    // than using ChangeUpdate.
    String subject = "Subject for missing commit";
    Change c = new Change(ctl.getChange());
    PatchSet.Id psId = nextPatchSetId(ctl);
    c.setCurrentPatchSet(psId, subject, c.getOriginalSubject());
    PatchSet ps = newPatchSet(psId, rev, adminId);
    db.patchSets().insert(singleton(ps));
    db.changes().update(singleton(c));
    addNoteDbCommit(c.getId(), "Update patch set " + psId.get() + "\n" + "\n" + "Patch-set: " + psId.get() + "\n" + "Commit: " + rev + "\n" + "Subject: " + subject + "\n");
    indexer.index(db, c.getProject(), c.getId());
    return ps;
}
#method_after
private PatchSet insertMissingPatchSet(ChangeControl ctl, String rev) throws Exception {
    // Don't use BatchUpdate since we're manually updating the meta ref rather
    // than using ChangeUpdate.
    String subject = "Subject for missing commit";
    Change c = new Change(ctl.getChange());
    PatchSet.Id psId = nextPatchSetId(ctl);
    c.setCurrentPatchSet(psId, subject, c.getOriginalSubject());
    PatchSet ps = newPatchSet(psId, rev, adminId);
    if (PrimaryStorage.of(c) == PrimaryStorage.REVIEW_DB) {
        db.patchSets().insert(singleton(ps));
        db.changes().update(singleton(c));
    }
    addNoteDbCommit(c.getId(), "Update patch set " + psId.get() + "\n" + "\n" + "Patch-set: " + psId.get() + "\n" + "Commit: " + rev + "\n" + "Subject: " + subject + "\n");
    indexer.index(db, c.getProject(), c.getId());
    return ps;
}
#end_block

#method_before
@Override
public void update(final int completed) {
    boolean w = false;
    synchronized (this) {
        count += completed;
        if (total != UNKNOWN) {
            int percent = count * 100 / total;
            if (percent > lastPercent) {
                lastPercent = percent;
                w = true;
            }
        }
    }
    if (w) {
        wakeUp();
    }
}
#method_after
@Override
public void update(final int completed) {
    boolean w = false;
    synchronized (MultiProgressMonitor.this) {
        count += completed;
        if (total != UNKNOWN) {
            int percent = count * 100 / total;
            if (percent > lastPercent) {
                lastPercent = percent;
                w = true;
            }
        }
    }
    if (w) {
        wakeUp();
    }
}
#end_block

#method_before
public synchronized int getCount() {
    return count;
}
#method_after
public int getCount() {
    synchronized (MultiProgressMonitor.this) {
        return count;
    }
}
#end_block

#method_before
public static void setAssignee(int id, String user, AsyncCallback<AccountInfo> cb) {
    AssigneeInput input = AssigneeInput.create();
    input.assignee(user);
    change(id).view("assignee").put(user, cb);
}
#method_after
public static void setAssignee(int id, String user, AsyncCallback<AccountInfo> cb) {
    AssigneeInput input = AssigneeInput.create();
    input.assignee(user);
    change(id).view("assignee").put(input, cb);
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (Repository git = repoManager.openRepository(allUsersName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git)) {
        ProjectConfig config = ProjectConfig.read(md);
        String refsUsersShardedId = RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}";
        config.remove(config.getAccessSection(refsUsersShardedId));
        GroupReference registered = SystemGroupBackend.getGroup(REGISTERED_USERS);
        AccessSection users = config.getAccessSection(refsUsersShardedId, true);
        grant(config, users, Permission.READ, false, true, registered);
        grant(config, users, Permission.PUSH, false, true, registered);
        grant(config, users, Permission.SUBMIT, false, true, registered);
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(COMMIT_MSG);
        config.commit(md);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (Repository git = repoManager.openRepository(allUsersName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git)) {
        ProjectConfig config = ProjectConfig.read(md);
        String refsUsersShardedId = RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}";
        config.remove(config.getAccessSection(refsUsersShardedId));
        GroupReference registered = systemGroupBackend.getGroup(REGISTERED_USERS);
        AccessSection users = config.getAccessSection(refsUsersShardedId, true);
        grant(config, users, Permission.READ, false, true, registered);
        grant(config, users, Permission.PUSH, false, true, registered);
        grant(config, users, Permission.SUBMIT, false, true, registered);
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(COMMIT_MSG);
        config.commit(md);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (Repository git = repoManager.openRepository(allProjectsName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allProjectsName, git)) {
        ProjectConfig config = ProjectConfig.read(md);
        GroupReference registered = SystemGroupBackend.getGroup(REGISTERED_USERS);
        AccessSection refsFor = config.getAccessSection("refs/for/*", true);
        grant(config, refsFor, Permission.ADD_PATCH_SET, false, false, registered);
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(COMMIT_MSG);
        config.commit(md);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (Repository git = repoManager.openRepository(allProjectsName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allProjectsName, git)) {
        ProjectConfig config = ProjectConfig.read(md);
        GroupReference registered = systemGroupBackend.getGroup(REGISTERED_USERS);
        AccessSection refsFor = config.getAccessSection("refs/for/*", true);
        grant(config, refsFor, Permission.ADD_PATCH_SET, false, false, registered);
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(COMMIT_MSG);
        config.commit(md);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    sysInjector.injectMembers(this);
    if (!notesMigration.enabled()) {
        throw die("NoteDb is not enabled.");
    }
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    ListeningExecutorService executor = newExecutor();
    System.out.println("Rebuilding the NoteDb");
    final ImmutableMultimap<Project.NameKey, Change.Id> changesByProject = getChangesByProject();
    boolean ok;
    Stopwatch sw = Stopwatch.createStarted();
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        deleteRefs(RefNames.REFS_DRAFT_COMMENTS, allUsersRepo);
        List<ListenableFuture<Boolean>> futures = new ArrayList<>();
        List<Project.NameKey> projectNames = Ordering.usingToString().sortedCopy(changesByProject.keySet());
        for (final Project.NameKey project : projectNames) {
            ListenableFuture<Boolean> future = executor.submit(new Callable<Boolean>() {

                @Override
                public Boolean call() {
                    try (ReviewDb db = unwrapDb(schemaFactory.open())) {
                        return rebuildProject(db, changesByProject, project, allUsersRepo);
                    } catch (Exception e) {
                        log.error("Error rebuilding project " + project, e);
                        return false;
                    }
                }
            });
            futures.add(future);
        }
        try {
            ok = Iterables.all(Futures.allAsList(futures).get(), Predicates.equalTo(true));
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error rebuilding projects", e);
            ok = false;
        }
    }
    double t = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Rebuild %d changes in %.01fs (%.01f/s)\n", changesByProject.size(), t, changesByProject.size() / t);
    return ok ? 0 : 1;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    sysInjector.injectMembers(this);
    if (!notesMigration.enabled()) {
        throw die("NoteDb is not enabled.");
    }
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    ListeningExecutorService executor = newExecutor();
    System.out.println("Rebuilding the NoteDb");
    ImmutableListMultimap<Project.NameKey, Change.Id> changesByProject = getChangesByProject();
    boolean ok;
    Stopwatch sw = Stopwatch.createStarted();
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        deleteRefs(RefNames.REFS_DRAFT_COMMENTS, allUsersRepo);
        List<ListenableFuture<Boolean>> futures = new ArrayList<>();
        List<Project.NameKey> projectNames = Ordering.usingToString().sortedCopy(changesByProject.keySet());
        for (final Project.NameKey project : projectNames) {
            ListenableFuture<Boolean> future = executor.submit(new Callable<Boolean>() {

                @Override
                public Boolean call() {
                    try (ReviewDb db = unwrapDb(schemaFactory.open())) {
                        return rebuildProject(db, changesByProject, project, allUsersRepo);
                    } catch (Exception e) {
                        log.error("Error rebuilding project " + project, e);
                        return false;
                    }
                }
            });
            futures.add(future);
        }
        try {
            ok = Iterables.all(Futures.allAsList(futures).get(), Predicates.equalTo(true));
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error rebuilding projects", e);
            ok = false;
        }
    }
    double t = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Rebuild %d changes in %.01fs (%.01f/s)\n", changesByProject.size(), t, changesByProject.size() / t);
    return ok ? 0 : 1;
}
#end_block

#method_before
private ImmutableMultimap<Project.NameKey, Change.Id> getChangesByProject() throws OrmException {
    // Memorize all changes so we can close the db connection and allow
    // rebuilder threads to use the full connection pool.
    Multimap<Project.NameKey, Change.Id> changesByProject = ArrayListMultimap.create();
    try (ReviewDb db = schemaFactory.open()) {
        if (projects.isEmpty() && !changes.isEmpty()) {
            Iterable<Change> todo = unwrapDb(db).changes().get(Iterables.transform(changes, Change.Id::new));
            for (Change c : todo) {
                changesByProject.put(c.getProject(), c.getId());
            }
        } else {
            for (Change c : unwrapDb(db).changes().all()) {
                boolean include = false;
                if (projects.isEmpty() && changes.isEmpty()) {
                    include = true;
                } else if (!projects.isEmpty() && projects.contains(c.getProject().get())) {
                    include = true;
                } else if (!changes.isEmpty() && changes.contains(c.getId().get())) {
                    include = true;
                }
                if (include) {
                    changesByProject.put(c.getProject(), c.getId());
                }
            }
        }
        return ImmutableMultimap.copyOf(changesByProject);
    }
}
#method_after
private ImmutableListMultimap<Project.NameKey, Change.Id> getChangesByProject() throws OrmException {
    // Memorize all changes so we can close the db connection and allow
    // rebuilder threads to use the full connection pool.
    ListMultimap<Project.NameKey, Change.Id> changesByProject = MultimapBuilder.hashKeys().arrayListValues().build();
    try (ReviewDb db = schemaFactory.open()) {
        if (projects.isEmpty() && !changes.isEmpty()) {
            Iterable<Change> todo = unwrapDb(db).changes().get(Iterables.transform(changes, Change.Id::new));
            for (Change c : todo) {
                changesByProject.put(c.getProject(), c.getId());
            }
        } else {
            for (Change c : unwrapDb(db).changes().all()) {
                boolean include = false;
                if (projects.isEmpty() && changes.isEmpty()) {
                    include = true;
                } else if (!projects.isEmpty() && projects.contains(c.getProject().get())) {
                    include = true;
                } else if (!changes.isEmpty() && changes.contains(c.getId().get())) {
                    include = true;
                }
                if (include) {
                    changesByProject.put(c.getProject(), c.getId());
                }
            }
        }
        return ImmutableListMultimap.copyOf(changesByProject);
    }
}
#end_block

#method_before
private boolean rebuildProject(ReviewDb db, ImmutableMultimap<Project.NameKey, Change.Id> allChanges, Project.NameKey project, Repository allUsersRepo) throws IOException, OrmException {
    checkArgument(allChanges.containsKey(project));
    boolean ok = true;
    ProgressMonitor pm = new TextProgressMonitor(new PrintWriter(System.out));
    pm.beginTask(FormatUtil.elide(project.get(), 50), allChanges.get(project).size());
    try (NoteDbUpdateManager manager = updateManagerFactory.create(project);
        ObjectInserter allUsersInserter = allUsersRepo.newObjectInserter();
        RevWalk allUsersRw = new RevWalk(allUsersInserter.newReader())) {
        manager.setAllUsersRepo(allUsersRepo, allUsersRw, allUsersInserter, new ChainedReceiveCommands(allUsersRepo));
        for (Change.Id changeId : allChanges.get(project)) {
            try {
                rebuilder.buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
            } catch (NoPatchSetsException e) {
                log.warn(e.getMessage());
            } catch (Throwable t) {
                log.error("Failed to rebuild change " + changeId, t);
                ok = false;
            }
            pm.update(1);
        }
        manager.execute();
    } finally {
        pm.endTask();
    }
    return ok;
}
#method_after
private boolean rebuildProject(ReviewDb db, ImmutableListMultimap<Project.NameKey, Change.Id> allChanges, Project.NameKey project, Repository allUsersRepo) throws IOException, OrmException {
    checkArgument(allChanges.containsKey(project));
    boolean ok = true;
    ProgressMonitor pm = new TextProgressMonitor(new PrintWriter(System.out));
    pm.beginTask(FormatUtil.elide(project.get(), 50), allChanges.get(project).size());
    try (NoteDbUpdateManager manager = updateManagerFactory.create(project);
        ObjectInserter allUsersInserter = allUsersRepo.newObjectInserter();
        RevWalk allUsersRw = new RevWalk(allUsersInserter.newReader())) {
        manager.setAllUsersRepo(allUsersRepo, allUsersRw, allUsersInserter, new ChainedReceiveCommands(allUsersRepo));
        for (Change.Id changeId : allChanges.get(project)) {
            try {
                rebuilder.buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
            } catch (NoPatchSetsException e) {
                log.warn(e.getMessage());
            } catch (Throwable t) {
                log.error("Failed to rebuild change " + changeId, t);
                ok = false;
            }
            pm.update(1);
        }
        manager.execute();
    } finally {
        pm.endTask();
    }
    return ok;
}
#end_block

#method_before
@Test
public void watchFile() throws Exception {
    // watch file in project
    String watchedProject = createProject("watchedProject").get();
    setApiUser(user);
    watch(watchedProject, "file:a.txt");
    // push a change to watched file -> should trigger email notification
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // push a change to non-watched file -> should not trigger email
    // notification
    r = pushFactory.create(db, admin.getIdent(), testRepo, "DONT_TRIGGER", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchFile() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    String otherWatchedProject = createProject("otherWatchedProject").get();
    setApiUser(user);
    // watch file in project as user
    watch(watchedProject, "file:a.txt");
    // watch other project as user
    watch(otherWatchedProject, null);
    // push a change to watched file -> should trigger email notification for
    // user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification for user
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
    sender.clear();
    // watch project as user2
    TestAccount user2 = accounts.create("user2", "user2@test.com", "User2");
    setApiUser(user2);
    watch(watchedProject, null);
    // push a change to non-watched file -> should not trigger email
    // notification for user, only for user2
    r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER_USER2", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user2.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER_USER2\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
private RobotCommentInput createRobotCommentInput() {
    RobotCommentInput in = createRobotCommentInputWithMandatoryFields();
    in.url = "http://www.happy-robot.com";
    in.properties = new HashMap<>();
    in.properties.put("key1", "value1");
    in.properties.put("key2", "value2");
    return in;
}
#method_after
private RobotCommentInput createRobotCommentInput(FixSuggestionInfo... fixSuggestionInfos) {
    RobotCommentInput in = createRobotCommentInputWithMandatoryFields();
    in.url = "http://www.happy-robot.com";
    in.properties = new HashMap<>();
    in.properties.put("key1", "value1");
    in.properties.put("key2", "value2");
    in.fixSuggestions = Arrays.asList(fixSuggestionInfos);
    return in;
}
#end_block

#method_before
public LabelValue getMax() {
    if (values.isEmpty()) {
        return null;
    }
    final LabelValue v = values.get(values.size() - 1);
    return v.getValue() > 0 ? v : null;
}
#method_after
public LabelValue getMax() {
    if (values.isEmpty()) {
        return null;
    }
    return values.get(values.size() - 1);
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    Optional<Account.Id> oldAssigneeId = Optional.ofNullable(change.getAssignee());
    oldAssignee = null;
    if (oldAssigneeId.isPresent()) {
        oldAssignee = accountInfosFactory.create().get(oldAssigneeId.get());
    }
    IdentifiedUser newAssigneeUser = accounts.parse(assignee);
    if (oldAssigneeId.isPresent() && oldAssigneeId.get().equals(newAssigneeUser.getAccountId())) {
        newAssignee = oldAssignee;
        return false;
    }
    if (!newAssigneeUser.getAccount().isActive()) {
        throw new UnprocessableEntityException(String.format("Account of %s is not active", assignee));
    }
    if (!ctx.getControl().forUser(newAssigneeUser).isRefVisible()) {
        throw new AuthException(String.format("Change %s is not visible to %s.", change.getChangeId(), assignee));
    }
    try {
        for (AssigneeValidationListener validator : validationListeners) {
            validator.validateAssignee(change, newAssigneeUser.getAccount());
        }
    } catch (ValidationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    // notedb
    update.setAssignee(newAssigneeUser.getAccountId());
    // reviewdb
    change.setAssignee(newAssigneeUser.getAccountId());
    this.newAssignee = newAssigneeUser.getAccount();
    addMessage(ctx, update, oldAssignee);
    return true;
}
#method_after
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    IdentifiedUser newAssigneeUser = accounts.parse(assignee);
    newAssignee = newAssigneeUser.getAccount();
    IdentifiedUser oldAssigneeUser = null;
    if (change.getAssignee() != null) {
        oldAssigneeUser = userFactory.create(change.getAssignee());
        oldAssignee = oldAssigneeUser.getAccount();
        if (newAssignee.equals(oldAssignee)) {
            return false;
        }
    }
    if (!newAssignee.isActive()) {
        throw new UnprocessableEntityException(String.format("Account of %s is not active", assignee));
    }
    if (!ctx.getControl().forUser(newAssigneeUser).isRefVisible()) {
        throw new AuthException(String.format("Change %s is not visible to %s.", change.getChangeId(), assignee));
    }
    try {
        for (AssigneeValidationListener validator : validationListeners) {
            validator.validateAssignee(change, newAssignee);
        }
    } catch (ValidationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    // notedb
    update.setAssignee(newAssignee.getId());
    // reviewdb
    change.setAssignee(newAssignee.getId());
    addMessage(ctx, update, oldAssigneeUser, newAssigneeUser);
    return true;
}
#end_block

#method_before
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account previousAssignee) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Assignee ");
    if (previousAssignee == null) {
        msg.append("added: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    } else {
        msg.append("changed from: ");
        msg.append(previousAssignee.getName(anonymousCowardName));
        msg.append(" to: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_SET_ASSIGNEE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, IdentifiedUser previousAssignee, IdentifiedUser newAssignee) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Assignee ");
    if (previousAssignee == null) {
        msg.append("added: ");
        msg.append(newAssignee.getNameEmail());
    } else {
        msg.append("changed from: ");
        msg.append(previousAssignee.getNameEmail());
        msg.append(" to: ");
        msg.append(newAssignee.getNameEmail());
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_SET_ASSIGNEE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    assigneeChanged.fire(change, ctx.getAccount(), oldAssignee, ctx.getWhen());
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        SetAssigneeSender cm = setAssigneeSenderFactory.create(change.getProject(), change.getId(), newAssignee.getId());
        cm.setFrom(user.get().getAccountId());
        cm.send();
    } catch (Exception err) {
        log.error("Cannot send email to new assignee of change " + change.getId(), err);
    }
    assigneeChanged.fire(change, ctx.getAccount(), oldAssignee, ctx.getWhen());
}
#end_block

#method_before
public Account getNewAssignee() {
    return newAssignee;
}
#method_after
public Account.Id getNewAssignee() {
    return newAssignee != null ? newAssignee.getId() : null;
}
#end_block

#method_before
@Override
public String toString() {
    return new StringBuilder().append("RobotComment{").append("key=").append(key).append(',').append("robotId=").append(robotId).append(',').append("robotRunId=").append(robotRunId).append(',').append("lineNbr=").append(lineNbr).append(',').append("author=").append(author.getId().get()).append(',').append("realAuthor=").append(realAuthor != null ? realAuthor.getId().get() : "").append(',').append("writtenOn=").append(writtenOn.toString()).append(',').append("side=").append(side).append(',').append("message=").append(Objects.toString(message, "")).append(',').append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',').append("range=").append(Objects.toString(range, "")).append(',').append("revId=").append(revId != null ? revId : "").append(',').append("tag=").append(Objects.toString(tag, "")).append(',').append("url=").append(url).append(',').append("properties=").append(properties != null ? properties : "").append('}').toString();
}
#method_after
@Override
public String toString() {
    return new StringBuilder().append("RobotComment{").append("key=").append(key).append(',').append("robotId=").append(robotId).append(',').append("robotRunId=").append(robotRunId).append(',').append("lineNbr=").append(lineNbr).append(',').append("author=").append(author.getId().get()).append(',').append("realAuthor=").append(realAuthor != null ? realAuthor.getId().get() : "").append(',').append("writtenOn=").append(writtenOn.toString()).append(',').append("side=").append(side).append(',').append("message=").append(Objects.toString(message, "")).append(',').append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',').append("range=").append(Objects.toString(range, "")).append(',').append("revId=").append(revId != null ? revId : "").append(',').append("tag=").append(Objects.toString(tag, "")).append(',').append("unresolved=").append(unresolved).append(',').append("url=").append(url).append(',').append("properties=").append(properties != null ? properties : "").append("fixSuggestions=").append(fixSuggestions != null ? fixSuggestions : "").append('}').toString();
}
#end_block

#method_before
public synchronized Config getGlobalPluginConfig(String pluginName) {
    if (pluginConfigs.containsKey(pluginName)) {
        return pluginConfigs.get(pluginName);
    }
    Path pluginConfigFile = site.etc_dir.resolve(pluginName + ".config");
    FileBasedConfig cfg = new FileBasedConfig(pluginConfigFile.toFile(), FS.DETECTED);
    GlobalPluginConfig pluginConfig = new GlobalPluginConfig(pluginName, cfg, secureStore);
    pluginConfigs.put(pluginName, pluginConfig);
    if (!cfg.getFile().exists()) {
        log.info("No " + pluginConfigFile.toAbsolutePath() + "; assuming defaults");
        return pluginConfig;
    }
    try {
        cfg.load();
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + pluginConfigFile.toAbsolutePath(), e);
    }
    return pluginConfig;
}
#method_after
public synchronized Config getGlobalPluginConfig(String pluginName) {
    if (pluginConfigs.containsKey(pluginName)) {
        return pluginConfigs.get(pluginName);
    }
    Path pluginConfigFile = site.etc_dir.resolve(pluginName + ".config");
    FileBasedConfig cfg = new FileBasedConfig(pluginConfigFile.toFile(), FS.DETECTED);
    GlobalPluginConfig pluginConfig = new GlobalPluginConfig(pluginName, cfg, secureStore);
    pluginConfigs.put(pluginName, pluginConfig);
    if (!cfg.getFile().exists()) {
        log.info("No " + pluginConfigFile.toAbsolutePath() + "; assuming defaults");
        return pluginConfig;
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        // This is an error in user input, don't spam logs with a stack trace.
        log.warn("Failed to load " + pluginConfigFile.toAbsolutePath() + ": " + e);
    } catch (IOException e) {
        log.warn("Failed to load " + pluginConfigFile.toAbsolutePath(), e);
    }
    return pluginConfig;
}
#end_block

#method_before
@Override
public void remove(final Project p) {
    listLock.lock();
    try {
        SortedSet<Project.NameKey> n = Sets.newTreeSet(list.get(ListKey.ALL));
        n.remove(p.getNameKey());
        list.put(ListKey.ALL, Collections.unmodifiableSortedSet(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list avaliable projects", e);
    } finally {
        listLock.unlock();
    }
    evict(p);
}
#method_after
@Override
public void remove(final Project p) {
    listLock.lock();
    try {
        SortedSet<Project.NameKey> n = Sets.newTreeSet(list.get(ListKey.ALL));
        n.remove(p.getNameKey());
        list.put(ListKey.ALL, Collections.unmodifiableSortedSet(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list available projects", e);
    } finally {
        listLock.unlock();
    }
    evict(p);
}
#end_block

#method_before
@Override
public void onCreateProject(Project.NameKey newProjectName) {
    listLock.lock();
    try {
        SortedSet<Project.NameKey> n = Sets.newTreeSet(list.get(ListKey.ALL));
        n.add(newProjectName);
        list.put(ListKey.ALL, Collections.unmodifiableSortedSet(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list avaliable projects", e);
    } finally {
        listLock.unlock();
    }
}
#method_after
@Override
public void onCreateProject(Project.NameKey newProjectName) {
    listLock.lock();
    try {
        SortedSet<Project.NameKey> n = Sets.newTreeSet(list.get(ListKey.ALL));
        n.add(newProjectName);
        list.put(ListKey.ALL, Collections.unmodifiableSortedSet(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list available projects", e);
    } finally {
        listLock.unlock();
    }
}
#end_block

#method_before
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(show, false);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(false);
    suggestBox.setFocus(true);
    if (currentAssignee != null) {
        suggestBox.setText(FormatUtil.nameEmail(currentAssignee));
        suggestBox.selectAll();
    }
}
#method_after
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(show, false);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(false);
    suggestBox.setFocus(true);
    if (currentAssignee != null) {
        suggestBox.setText(FormatUtil.nameEmail(currentAssignee));
        suggestBox.selectAll();
    } else {
        suggestBox.setText("");
    }
}
#end_block

#method_before
private void editAssignee(final String assignee) {
    if (assignee.isEmpty()) {
        ChangeApi.deleteAssignee(changeId.get(), new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                setAssignee(null);
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    } else {
        ChangeApi.setAssignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                setAssignee(result);
                Reviewers reviewers = getReviewers();
                if (reviewers != null) {
                    reviewers.updateReviewerList();
                }
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    }
}
#method_after
private void editAssignee(final String assignee) {
    if (assignee.trim().isEmpty()) {
        ChangeApi.deleteAssignee(changeId.get(), new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                setAssignee(null);
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    } else {
        ChangeApi.setAssignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                setAssignee(result);
                Reviewers reviewers = getReviewers();
                if (reviewers != null) {
                    reviewers.updateReviewerList();
                }
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    }
}
#end_block

#method_before
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException, NoSuchChangeException {
    Change c = getChange().change();
    assertThat(c.getSubject()).isEqualTo(resSubj);
    assertThat(c.getStatus()).isEqualTo(expectedStatus);
    assertThat(Strings.emptyToNull(c.getTopic())).isEqualTo(expectedTopic);
    assertReviewers(c, expectedReviewers);
}
#method_after
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    Change c = getChange().change();
    assertThat(c.getSubject()).isEqualTo(resSubj);
    assertThat(c.getStatus()).isEqualTo(expectedStatus);
    assertThat(Strings.emptyToNull(c.getTopic())).isEqualTo(expectedTopic);
    assertReviewers(c, expectedReviewers);
}
#end_block

#method_before
private void assertReviewers(Change c, TestAccount... expectedReviewers) throws OrmException, NoSuchChangeException {
    Iterable<Account.Id> actualIds = approvalsUtil.getReviewers(db, notesFactory.createChecked(db, c)).all();
    assertThat(actualIds).containsExactlyElementsIn(Sets.newHashSet(TestAccount.ids(expectedReviewers)));
}
#method_after
private void assertReviewers(Change c, TestAccount... expectedReviewers) throws OrmException {
    Iterable<Account.Id> actualIds = approvalsUtil.getReviewers(db, notesFactory.createChecked(db, c)).all();
    assertThat(actualIds).containsExactlyElementsIn(Sets.newHashSet(TestAccount.ids(expectedReviewers)));
}
#end_block

#method_before
@Override
public GpgKeyInfo get() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public GpgKeyInfo get() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void delete() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult submitPreview() throws RestApiException {
    submitPreview.setFormat("zip");
    return submitPreview.apply(revision);
}
#method_after
@Override
public BinaryResult submitPreview() throws RestApiException {
    return submitPreview("zip");
}
#end_block

#method_before
@Override
public BinaryResult submitPreview() throws RestApiException {
    submitPreview.setFormat("zip");
    return submitPreview.apply(revision);
}
#method_after
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    submitPreview.setFormat(format);
    return submitPreview.apply(revision);
}
#end_block

#method_before
@Override
public ChangeApi rebase(RebaseInput in) throws RestApiException {
    try {
        return changes.id(rebase.apply(revision, in)._number);
    } catch (OrmException | EmailException | UpdateException | IOException | NoSuchChangeException e) {
        throw new RestApiException("Cannot rebase ps", e);
    }
}
#method_after
@Override
public ChangeApi rebase(RebaseInput in) throws RestApiException {
    try {
        return changes.id(rebase.apply(revision, in)._number);
    } catch (OrmException | EmailException | UpdateException | IOException e) {
        throw new RestApiException("Cannot rebase ps", e);
    }
}
#end_block

#method_before
@Override
public Map<String, ActionInfo> actions() throws RestApiException {
    return revisionActions.apply(revision).value();
}
#method_after
@Override
public Map<String, ActionInfo> actions() throws RestApiException {
    try {
        return revisionActions.apply(revision).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get actions", e);
    }
}
#end_block

#method_before
@Test
public void parseReviewDbWithoutDrafts() {
    NoteDbChangeState state = parse(new Change.Id(1), SHA1.name());
    assertThat(state.getPrimaryStorage()).isEqualTo(REVIEW_DB);
    assertThat(state.getChangeId()).isEqualTo(new Change.Id(1));
    assertThat(state.getChangeMetaId()).isEqualTo(SHA1);
    assertThat(state.getDraftIds()).isEmpty();
    assertThat(state.toString()).isEqualTo(SHA1.name());
    state = parse(new Change.Id(1), "R," + SHA1.name());
    assertThat(state.getPrimaryStorage()).isEqualTo(REVIEW_DB);
    assertThat(state.getChangeId()).isEqualTo(new Change.Id(1));
    assertThat(state.getChangeMetaId()).isEqualTo(SHA1);
    assertThat(state.getDraftIds()).isEmpty();
    assertThat(state.toString()).isEqualTo(SHA1.name());
}
#method_after
@Test
public void parseReviewDbWithoutDrafts() {
    NoteDbChangeState state = parse(new Change.Id(1), SHA1.name());
    assertThat(state.getPrimaryStorage()).isEqualTo(REVIEW_DB);
    assertThat(state.getChangeId()).isEqualTo(new Change.Id(1));
    assertThat(state.getChangeMetaId()).isEqualTo(SHA1);
    assertThat(state.getDraftIds()).isEmpty();
    assertThat(state.getReadOnlyUntil().isPresent()).isFalse();
    assertThat(state.toString()).isEqualTo(SHA1.name());
    state = parse(new Change.Id(1), "R," + SHA1.name());
    assertThat(state.getPrimaryStorage()).isEqualTo(REVIEW_DB);
    assertThat(state.getChangeId()).isEqualTo(new Change.Id(1));
    assertThat(state.getChangeMetaId()).isEqualTo(SHA1);
    assertThat(state.getDraftIds()).isEmpty();
    assertThat(state.getReadOnlyUntil().isPresent()).isFalse();
    assertThat(state.toString()).isEqualTo(SHA1.name());
}
#end_block

#method_before
@Test
public void parseReviewDbWithDrafts() {
    String str = SHA1.name() + ",2003=" + SHA2.name() + ",1001=" + SHA3.name();
    String expected = SHA1.name() + ",1001=" + SHA3.name() + ",2003=" + SHA2.name();
    NoteDbChangeState state = parse(new Change.Id(1), str);
    assertThat(state.getPrimaryStorage()).isEqualTo(REVIEW_DB);
    assertThat(state.getChangeId()).isEqualTo(new Change.Id(1));
    assertThat(state.getChangeMetaId()).isEqualTo(SHA1);
    assertThat(state.getDraftIds()).containsExactly(new Account.Id(1001), SHA3, new Account.Id(2003), SHA2);
    assertThat(state.toString()).isEqualTo(expected);
    state = parse(new Change.Id(1), "R," + str);
    assertThat(state.getPrimaryStorage()).isEqualTo(REVIEW_DB);
    assertThat(state.getChangeId()).isEqualTo(new Change.Id(1));
    assertThat(state.getChangeMetaId()).isEqualTo(SHA1);
    assertThat(state.getDraftIds()).containsExactly(new Account.Id(1001), SHA3, new Account.Id(2003), SHA2);
    assertThat(state.toString()).isEqualTo(expected);
}
#method_after
@Test
public void parseReviewDbWithDrafts() {
    String str = SHA1.name() + ",2003=" + SHA2.name() + ",1001=" + SHA3.name();
    String expected = SHA1.name() + ",1001=" + SHA3.name() + ",2003=" + SHA2.name();
    NoteDbChangeState state = parse(new Change.Id(1), str);
    assertThat(state.getPrimaryStorage()).isEqualTo(REVIEW_DB);
    assertThat(state.getChangeId()).isEqualTo(new Change.Id(1));
    assertThat(state.getChangeMetaId()).isEqualTo(SHA1);
    assertThat(state.getDraftIds()).containsExactly(new Account.Id(1001), SHA3, new Account.Id(2003), SHA2);
    assertThat(state.getReadOnlyUntil().isPresent()).isFalse();
    assertThat(state.toString()).isEqualTo(expected);
    state = parse(new Change.Id(1), "R," + str);
    assertThat(state.getPrimaryStorage()).isEqualTo(REVIEW_DB);
    assertThat(state.getChangeId()).isEqualTo(new Change.Id(1));
    assertThat(state.getChangeMetaId()).isEqualTo(SHA1);
    assertThat(state.getDraftIds()).containsExactly(new Account.Id(1001), SHA3, new Account.Id(2003), SHA2);
    assertThat(state.getReadOnlyUntil().isPresent()).isFalse();
    assertThat(state.toString()).isEqualTo(expected);
}
#end_block

#method_before
@Test
public void applyDeltaToNullWithNoNewMetaId() {
    Change c = newChange();
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, Delta.create(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(1001), zeroId())));
    assertThat(c.getNoteDbState()).isNull();
}
#method_after
@Test
public void applyDeltaToNullWithNoNewMetaId() throws Exception {
    Change c = newChange();
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, Delta.create(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(1001), zeroId())));
    assertThat(c.getNoteDbState()).isNull();
}
#end_block

#method_before
@Test
public void applyDeltaToMetaId() {
    Change c = newChange();
    applyDelta(c, Delta.create(c.getId(), metaId(SHA1), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name());
    applyDelta(c, Delta.create(c.getId(), metaId(SHA2), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // No-op delta.
    applyDelta(c, Delta.create(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // Set to zero clears the field.
    applyDelta(c, Delta.create(c.getId(), metaId(zeroId()), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
}
#method_after
@Test
public void applyDeltaToMetaId() throws Exception {
    Change c = newChange();
    applyDelta(c, Delta.create(c.getId(), metaId(SHA1), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name());
    applyDelta(c, Delta.create(c.getId(), metaId(SHA2), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // No-op delta.
    applyDelta(c, Delta.create(c.getId(), noMetaId(), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA2.name());
    // Set to zero clears the field.
    applyDelta(c, Delta.create(c.getId(), metaId(zeroId()), noDrafts()));
    assertThat(c.getNoteDbState()).isNull();
}
#end_block

#method_before
@Test
public void applyDeltaToDrafts() {
    Change c = newChange();
    applyDelta(c, Delta.create(c.getId(), metaId(SHA1), drafts(new Account.Id(1001), SHA2)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(2003), SHA3)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name() + ",2003=" + SHA3.name());
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(2003), zeroId())));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, Delta.create(c.getId(), metaId(SHA3), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA3.name() + ",1001=" + SHA2.name());
}
#method_after
@Test
public void applyDeltaToDrafts() throws Exception {
    Change c = newChange();
    applyDelta(c, Delta.create(c.getId(), metaId(SHA1), drafts(new Account.Id(1001), SHA2)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(2003), SHA3)));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name() + ",2003=" + SHA3.name());
    applyDelta(c, Delta.create(c.getId(), noMetaId(), drafts(new Account.Id(2003), zeroId())));
    assertThat(c.getNoteDbState()).isEqualTo(SHA1.name() + ",1001=" + SHA2.name());
    applyDelta(c, Delta.create(c.getId(), metaId(SHA3), noDrafts()));
    assertThat(c.getNoteDbState()).isEqualTo(SHA3.name() + ",1001=" + SHA2.name());
}
#end_block

#method_before
@Test
public void parseNoteDbPrimary() {
    NoteDbChangeState state = parse(new Change.Id(1), "N");
    assertThat(state.getPrimaryStorage()).isEqualTo(NOTE_DB);
    assertThat(state.getRefState().isPresent()).isFalse();
}
#method_after
@Test
public void parseNoteDbPrimary() {
    NoteDbChangeState state = parse(new Change.Id(1), "N");
    assertThat(state.getPrimaryStorage()).isEqualTo(NOTE_DB);
    assertThat(state.getRefState().isPresent()).isFalse();
    assertThat(state.getReadOnlyUntil().isPresent()).isFalse();
}
#end_block

#method_before
@Test
public void applyDeltaToNoteDbPrimaryIsNoOp() {
    Change c = newChange();
    c.setNoteDbState("N");
    applyDelta(c, Delta.create(c.getId(), metaId(SHA1), drafts(new Account.Id(1001), SHA2)));
    assertThat(c.getNoteDbState()).isEqualTo("N");
}
#method_after
@Test
public void applyDeltaToNoteDbPrimaryIsNoOp() throws Exception {
    Change c = newChange();
    c.setNoteDbState("N");
    applyDelta(c, Delta.create(c.getId(), metaId(SHA1), drafts(new Account.Id(1001), SHA2)));
    assertThat(c.getNoteDbState()).isEqualTo("N");
}
#end_block

#method_before
@Override
protected void configure() {
    install(new FactoryModuleBuilder().implement(ChangeIndex.class, ElasticChangeIndex.class).build(ChangeIndex.Factory.class));
    install(new FactoryModuleBuilder().implement(AccountIndex.class, LuceneAccountIndex.class).build(AccountIndex.Factory.class));
    install(new IndexModule(threads));
    install(new SingleVersionModule(singleVersions));
}
#method_after
@Override
protected void configure() {
    install(new FactoryModuleBuilder().implement(AccountIndex.class, ElasticAccountIndex.class).build(AccountIndex.Factory.class));
    install(new FactoryModuleBuilder().implement(ChangeIndex.class, ElasticChangeIndex.class).build(ChangeIndex.Factory.class));
    install(new FactoryModuleBuilder().implement(GroupIndex.class, ElasticGroupIndex.class).build(GroupIndex.Factory.class));
    install(new IndexModule(threads));
    install(new SingleVersionModule(singleVersions));
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    CodeReviewCommit newTipCommit = args.mergeUtil.getFirstFastForward(args.mergeTip.getInitialTip(), args.rw, sorted);
    if (!newTipCommit.equals(args.mergeTip.getInitialTip())) {
        ops.add(new FastForwardOp(args, newTipCommit));
    }
    while (!sorted.isEmpty()) {
        ops.add(new NotFastForwardOp(sorted.remove(0)));
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge, args.incoming);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    CodeReviewCommit newTipCommit = args.mergeUtil.getFirstFastForward(args.mergeTip.getInitialTip(), args.rw, sorted);
    if (!newTipCommit.equals(args.mergeTip.getInitialTip())) {
        ops.add(new FastForwardOp(args, newTipCommit));
    }
    while (!sorted.isEmpty()) {
        ops.add(new NotFastForwardOp(sorted.remove(0)));
    }
    return ops;
}
#end_block

#method_before
Side getStoredSideFromDisplaySide(DisplaySide side) {
    if (side == DisplaySide.A && base.isBaseOrAutoMerge() || base.isParent()) {
        return Side.PARENT;
    }
    return Side.REVISION;
}
#method_after
Side getStoredSideFromDisplaySide(DisplaySide side) {
    if (side == DisplaySide.A && (base.isBaseOrAutoMerge() || base.isParent())) {
        return Side.PARENT;
    }
    return Side.REVISION;
}
#end_block

#method_before
void insertNewDraft(DisplaySide side, int line) {
    if (line == 0) {
        host.skipManager.ensureFirstLineIsVisible();
    }
    CommentGroup group = group(side, line);
    if (0 < group.getBoxCount()) {
        CommentBox last = group.getCommentBox(group.getBoxCount() - 1);
        if (last instanceof DraftBox) {
            ((DraftBox) last).setEdit(true);
        } else {
            ((PublishedBox) last).doReply();
        }
    } else {
        addDraftBox(side, CommentInfo.create(getPath(), getStoredSideFromDisplaySide(side), getParentNumFromDisplaySide(side), line, null)).setEdit(true);
    }
}
#method_after
void insertNewDraft(DisplaySide side, int line) {
    if (line == 0) {
        host.skipManager.ensureFirstLineIsVisible();
    }
    CommentGroup group = group(side, line);
    if (0 < group.getBoxCount()) {
        CommentBox last = group.getCommentBox(group.getBoxCount() - 1);
        if (last instanceof DraftBox) {
            ((DraftBox) last).setEdit(true);
        } else {
            ((PublishedBox) last).doReply();
        }
    } else {
        addDraftBox(side, CommentInfo.create(getPath(), getStoredSideFromDisplaySide(side), getParentNumFromDisplaySide(side), line, null, false)).setEdit(true);
    }
}
#end_block

#method_before
private static void checkConfig(Config cfg) {
    Set<String> keys = new HashSet<>();
    for (NoteDbTable t : NoteDbTable.values()) {
        keys.add(t.key());
    }
    Set<String> allowed = ImmutableSet.of(READ, WRITE, SEQUENCE);
    for (String t : cfg.getSubsections(NOTE_DB)) {
        checkArgument(keys.contains(t.toLowerCase()), "invalid NoteDb table: %s", t);
        for (String key : cfg.getNames(NOTE_DB, t)) {
            checkArgument(allowed.contains(key.toLowerCase()), "invalid NoteDb key: %s.%s", t, key);
        }
    }
}
#method_after
private static void checkConfig(Config cfg) {
    Set<String> keys = new HashSet<>();
    for (NoteDbTable t : NoteDbTable.values()) {
        keys.add(t.key().toLowerCase());
    }
    Set<String> allowed = ImmutableSet.of(PRIMARY_STORAGE.toLowerCase(), READ.toLowerCase(), WRITE.toLowerCase(), SEQUENCE.toLowerCase());
    for (String t : cfg.getSubsections(NOTE_DB)) {
        checkArgument(keys.contains(t.toLowerCase()), "invalid NoteDb table: %s", t);
        for (String key : cfg.getNames(NOTE_DB, t)) {
            checkArgument(allowed.contains(key.toLowerCase()), "invalid NoteDb key: %s.%s", t, key);
        }
    }
}
#end_block

#method_before
@Override
protected void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // If there is only one parent, a cherry-pick can be done by taking the
    // delta relative to that one parent and redoing that on the current merge
    // tip.
    args.rw.parseBody(toMerge);
    psId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
    String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(toMerge);
    PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
    try {
        newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0);
    } catch (MergeConflictException mce) {
        // Keep going in the case of a single merge failure; the goal is to
        // cherry-pick as many commits as possible.
        toMerge.setStatusCode(CommitMergeStatus.PATH_CONFLICT);
        return;
    } catch (MergeIdenticalTreeException mie) {
        toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
        return;
    }
    // Initial copy doesn't have new patch set ID since change hasn't been
    // updated yet.
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(psId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commits.put(newCommit);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, psId.toRefName()));
    patchSetInfo = args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, psId);
}
#method_after
@Override
protected void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // If there is only one parent, a cherry-pick can be done by taking the
    // delta relative to that one parent and redoing that on the current merge
    // tip.
    args.rw.parseBody(toMerge);
    psId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
    RevCommit mergeTip = args.mergeTip.getCurrentTip();
    args.rw.parseBody(mergeTip);
    String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
    PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
    try {
        newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, false);
    } catch (MergeConflictException mce) {
        // Keep going in the case of a single merge failure; the goal is to
        // cherry-pick as many commits as possible.
        toMerge.setStatusCode(CommitMergeStatus.PATH_CONFLICT);
        return;
    } catch (MergeIdenticalTreeException mie) {
        toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
        return;
    }
    // Initial copy doesn't have new patch set ID since change hasn't been
    // updated yet.
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(psId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(newCommit);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, psId.toRefName()));
    patchSetInfo = args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, psId);
}
#end_block

#method_before
public SortedMap<String, ProjectInfo> display(OutputStream displayOutputStream) throws BadRequestException {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, UTF_8)));
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Set<String> rejected = new HashSet<>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (groupUuid != null) {
                try {
                    if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                        break;
                    }
                } catch (NoSuchGroupException ex) {
                    break;
                }
                if (!pctl.getLocalGroups().contains(GroupReference.forGroup(groupsCollection.parseId(groupUuid.get())))) {
                    continue;
                }
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = Iterables.getFirst(e.parents(), null);
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.name = parentState.getProject().getName();
                        info.description = Strings.emptyToNull(parentState.getProject().getDescription());
                        info.state = parentState.getProject().getState();
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.name = projectName.get();
                if (showTree && format.isJson()) {
                    ProjectState parent = Iterables.getFirst(e.parents(), null);
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription) {
                    info.description = Strings.emptyToNull(e.getProject().getDescription());
                }
                info.state = e.getProject().getState();
                try {
                    if (!showBranch.isEmpty()) {
                        try (Repository git = repoManager.openRepository(projectName)) {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = new LinkedHashMap<>();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        try (Repository git = repoManager.openRepository(projectName)) {
                            if (!type.matches(git)) {
                                continue;
                            }
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
                FluentIterable<WebLinkInfo> links = webLinks.getProjectLinks(projectName.get());
                info.webLinks = links.isEmpty() ? null : links.toList();
            }
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#method_after
public SortedMap<String, ProjectInfo> display(OutputStream displayOutputStream) throws BadRequestException {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, UTF_8)));
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Set<String> rejected = new HashSet<>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (groupUuid != null) {
                try {
                    if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                        break;
                    }
                } catch (NoSuchGroupException ex) {
                    break;
                }
                if (!pctl.getLocalGroups().contains(GroupReference.forGroup(groupsCollection.parseId(groupUuid.get())))) {
                    continue;
                }
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = Iterables.getFirst(e.parents(), null);
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.name = parentState.getProject().getName();
                        info.description = Strings.emptyToNull(parentState.getProject().getDescription());
                        info.state = parentState.getProject().getState();
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.name = projectName.get();
                if (showTree && format.isJson()) {
                    ProjectState parent = Iterables.getFirst(e.parents(), null);
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription) {
                    info.description = Strings.emptyToNull(e.getProject().getDescription());
                }
                info.state = e.getProject().getState();
                try {
                    if (!showBranch.isEmpty()) {
                        try (Repository git = repoManager.openRepository(projectName)) {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = new LinkedHashMap<>();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        try (Repository git = repoManager.openRepository(projectName)) {
                            if (!type.matches(git)) {
                                continue;
                            }
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
                List<WebLinkInfo> links = webLinks.getProjectLinks(projectName.get());
                info.webLinks = links.isEmpty() ? null : links;
            }
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
private Path webappSourcePath(String name) {
    Paths p = getPaths();
    if (p.unpackedWar != null) {
        return p.unpackedWar.resolve(name);
    }
    return p.buckOut.resolveSibling("gerrit-war").resolve("src").resolve("main").resolve("webapp").resolve(name);
}
#method_after
private Path webappSourcePath(String name) {
    Paths p = getPaths();
    if (p.unpackedWar != null) {
        return p.unpackedWar.resolve(name);
    }
    return p.sourceRoot.resolve("gerrit-war/src/main/webapp/" + name);
}
#end_block

#method_before
@Override
public void configureServlets() {
    serveRegex("^/gerrit_ui/(?!rpc/)(.*)$").with(Key.get(HttpServlet.class, Names.named(GWT_UI_SERVLET)));
    Paths p = getPaths();
    if (p.isDev()) {
        filter("/").through(new RecompileGwtUiFilter(p.buckOut, p.unpackedWar));
    }
}
#method_after
@Override
public void configureServlets() {
    serveRegex("^/gerrit_ui/(?!rpc/)(.*)$").with(Key.get(HttpServlet.class, Names.named(GWT_UI_SERVLET)));
    Paths p = getPaths();
    if (p.isDev()) {
        filter("/").through(new RecompileGwtUiFilter(p.builder, p.unpackedWar));
    }
}
#end_block

#method_before
@Provides
@Singleton
BowerComponentsDevServlet getBowerComponentsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return getPaths().isDev() ? new BowerComponentsDevServlet(cache, getPaths().buckOut) : null;
}
#method_after
@Provides
@Singleton
BowerComponentsDevServlet getBowerComponentsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return getPaths().isDev() ? new BowerComponentsDevServlet(cache, getPaths().builder) : null;
}
#end_block

#method_before
@Provides
@Singleton
FontsDevServlet getFontsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return getPaths().isDev() ? new FontsDevServlet(cache, getPaths().buckOut) : null;
}
#method_after
@Provides
@Singleton
FontsDevServlet getFontsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return getPaths().isDev() ? new FontsDevServlet(cache, getPaths().builder) : null;
}
#end_block

#method_before
private Path polyGerritBasePath() {
    Paths p = getPaths();
    if (options.forcePolyGerritDev()) {
        checkArgument(p.buckOut != null, "no buck-out directory found for PolyGerrit developer mode");
    }
    if (p.isDev()) {
        return p.buckOut.getParent().resolve("polygerrit-ui").resolve("app");
    }
    return p.warFs != null ? p.warFs.getPath("/polygerrit_ui") : p.unpackedWar.resolve("polygerrit_ui");
}
#method_after
private Path polyGerritBasePath() {
    Paths p = getPaths();
    if (options.forcePolyGerritDev()) {
        checkArgument(p.sourceRoot != null, "no source root directory found for PolyGerrit developer mode");
    }
    if (p.isDev()) {
        return p.sourceRoot.resolve("polygerrit-ui").resolve("app");
    }
    return p.warFs != null ? p.warFs.getPath("/polygerrit_ui") : p.unpackedWar.resolve("polygerrit_ui");
}
#end_block

#method_before
public Multimap<String, String> extract(List<FooterLine> lines) {
    Multimap<String, String> r = ArrayListMultimap.create();
    if (lines == null) {
        return r;
    }
    for (FooterLine footer : lines) {
        for (TrackingFooter config : trackingFooters) {
            if (footer.matches(config.footerKey())) {
                Matcher m = config.match().matcher(footer.getValue());
                while (m.find()) {
                    String id = m.groupCount() > 0 ? m.group(1) : m.group();
                    if (!id.isEmpty()) {
                        r.put(config.system(), id);
                    }
                }
            }
        }
    }
    return r;
}
#method_after
public ListMultimap<String, String> extract(List<FooterLine> lines) {
    ListMultimap<String, String> r = MultimapBuilder.hashKeys().arrayListValues().build();
    if (lines == null) {
        return r;
    }
    for (FooterLine footer : lines) {
        for (TrackingFooter config : trackingFooters) {
            if (footer.matches(config.footerKey())) {
                Matcher m = config.match().matcher(footer.getValue());
                while (m.find()) {
                    String id = m.groupCount() > 0 ? m.group(1) : m.group();
                    if (!id.isEmpty()) {
                        r.put(config.system(), id);
                    }
                }
            }
        }
    }
    return r;
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, PublishChangeEditInput in) throws NoSuchChangeException, IOException, OrmException, RestApiException, UpdateException {
    Capable r = rsrc.getControl().getProjectControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        throw new ResourceConflictException(String.format("no edit exists for change %s", rsrc.getChange().getChangeId()));
    }
    if (in == null) {
        in = new PublishChangeEditInput();
    }
    editUtil.publish(edit.get(), in.notify);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, PublishChangeEditInput in) throws IOException, OrmException, RestApiException, UpdateException {
    Capable r = rsrc.getControl().getProjectControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        throw new ResourceConflictException(String.format("no edit exists for change %s", rsrc.getChange().getChangeId()));
    }
    if (in == null) {
        in = new PublishChangeEditInput();
    }
    editUtil.publish(edit.get(), in.notify, notifyUtil.resolveAccounts(in.notifyDetails));
    return Response.none();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountIndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    factory(AccountIndexerImpl.Factory.class);
    bind(ChangeIndexRewriter.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountIndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    factory(AccountIndexerImpl.Factory.class);
    bind(ChangeIndexRewriter.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
    bind(GroupIndexRewriter.class);
    bind(GroupIndexCollection.class);
    listener().to(GroupIndexCollection.class);
    factory(GroupIndexerImpl.Factory.class);
}
#end_block

#method_before
@Provides
Collection<IndexDefinition<?, ?, ?>> getIndexDefinitions(AccountIndexDefinition accounts, ChangeIndexDefinition changes) {
    Collection<IndexDefinition<?, ?, ?>> result = ImmutableList.<IndexDefinition<?, ?, ?>>of(accounts, changes);
    Set<String> expected = FluentIterable.from(ALL_SCHEMA_DEFS).transform(SchemaDefinitions::getName).toSet();
    Set<String> actual = FluentIterable.from(result).transform(IndexDefinition::getName).toSet();
    if (!expected.equals(actual)) {
        throw new ProvisionException("need index definitions for all schemas: " + expected + " != " + actual);
    }
    return result;
}
#method_after
@Provides
Collection<IndexDefinition<?, ?, ?>> getIndexDefinitions(AccountIndexDefinition accounts, ChangeIndexDefinition changes, GroupIndexDefinition groups) {
    Collection<IndexDefinition<?, ?, ?>> result = ImmutableList.<IndexDefinition<?, ?, ?>>of(accounts, groups, changes);
    Set<String> expected = FluentIterable.from(ALL_SCHEMA_DEFS).transform(SchemaDefinitions::getName).toSet();
    Set<String> actual = FluentIterable.from(result).transform(IndexDefinition::getName).toSet();
    if (!expected.equals(actual)) {
        throw new ProvisionException("need index definitions for all schemas: " + expected + " != " + actual);
    }
    return result;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(label.getName()), -1, 1, anonymousUsers, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(P.getName()), 0, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(project, cfg);
    eventListenerRegistration = source.add(new CommentAddedListener() {

        @Override
        public void onCommentAdded(Event event) {
            lastCommentAddedEvent = event;
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anonymousUsers = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(label.getName()), -1, 1, anonymousUsers, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(P.getName()), 0, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(project, cfg);
    eventListenerRegistration = source.add(new CommentAddedListener() {

        @Override
        public void onCommentAdded(Event event) {
            lastCommentAddedEvent = event;
        }
    });
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.changeId());
    idText.setPreviewText(change.changeId());
    formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change);
    formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change);
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(revInfo);
    if (revInfo.commit().parents().length() > 1) {
        mergeCommit.setVisible(true);
    }
    setParents(revInfo.commit().parents());
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.changeId());
    idText.setPreviewText(change.changeId());
    formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change);
    formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change);
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(webLinkPanel, revInfo.commit());
    if (revInfo.commit().parents().length() > 1) {
        mergeCommit.setVisible(true);
    }
    setParents(revInfo.commit().parents());
}
#end_block

#method_before
private void setWebLinks(RevisionInfo revInfo) {
    JsArray<WebLinkInfo> links = revInfo.commit().webLinks();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            webLinkPanel.add(link.toAnchor());
        }
    }
}
#method_after
private void setWebLinks(FlowPanel panel, CommitInfo commit) {
    JsArray<WebLinkInfo> links = commit.webLinks();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            panel.add(link.toAnchor());
        }
    }
}
#end_block

#method_before
private void setParents(JsArray<CommitInfo> commits) {
    setVisible(firstParent, true);
    TableRowElement next = firstParent;
    TableRowElement previous = null;
    for (CommitInfo c : Natives.asList(commits)) {
        if (next == firstParent) {
            CopyableLabel copyLabel = getCommitLabel(c);
            parentCommits.add(copyLabel);
        } else {
            next.appendChild(DOM.createTD());
            Element td1 = DOM.createTD();
            td1.appendChild(getCommitLabel(c).getElement());
            next.appendChild(td1);
            previous.getParentElement().insertAfter(next, previous);
        }
        previous = next;
        next = DOM.createTR().cast();
    }
}
#method_after
private void setParents(JsArray<CommitInfo> commits) {
    setVisible(firstParent, true);
    TableRowElement next = firstParent;
    TableRowElement previous = null;
    for (CommitInfo c : Natives.asList(commits)) {
        if (next == firstParent) {
            CopyableLabel copyLabel = getCommitLabel(c);
            parentCommits.add(copyLabel);
            setWebLinks(parentWebLinks, c);
        } else {
            next.appendChild(DOM.createTD());
            Element td1 = DOM.createTD();
            td1.appendChild(getCommitLabel(c).getElement());
            next.appendChild(td1);
            FlowPanel linksPanel = new FlowPanel();
            linksPanel.addStyleName(style.parentWebLink());
            setWebLinks(linksPanel, c);
            Element td2 = DOM.createTD();
            td2.appendChild(linksPanel.getElement());
            next.appendChild(td2);
            previous.getParentElement().insertAfter(next, previous);
        }
        previous = next;
        next = DOM.createTR().cast();
    }
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = new LinkedList<>();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup()) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = new ArrayList<>();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup()) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#end_block

#method_before
public Collection<ChangeData> unmergeableChanges(ChangeSet cs) throws OrmException, IOException {
    Set<ChangeData> mergeabilityMap = new HashSet<>();
    for (ChangeData change : cs.changes()) {
        mergeabilityMap.add(change);
    }
    Multimap<Branch.NameKey, ChangeData> cbb = cs.changesByBranch();
    for (Branch.NameKey branch : cbb.keySet()) {
        Collection<ChangeData> targetBranch = cbb.get(branch);
        HashMap<Change.Id, RevCommit> commits = findCommits(targetBranch, branch.getParentKey());
        Set<ObjectId> allParents = Sets.newHashSetWithExpectedSize(cs.size());
        for (RevCommit commit : commits.values()) {
            for (RevCommit parent : commit.getParents()) {
                allParents.add(parent.getId());
            }
        }
        for (ChangeData change : targetBranch) {
            RevCommit commit = commits.get(change.getId());
            boolean isMergeCommit = commit.getParentCount() > 1;
            boolean isLastInChain = !allParents.contains(commit.getId());
            // Recheck mergeability rather than using value stored in the index,
            // which may be stale.
            // TODO(dborowitz): This is ugly; consider providing a way to not read
            // stored fields from the index in the first place.
            change.setMergeable(null);
            Boolean mergeable = change.isMergeable();
            if (mergeable == null) {
                // Skip whole check, cannot determine if mergeable
                return null;
            }
            if (mergeable) {
                mergeabilityMap.remove(change);
            }
            if (isLastInChain && isMergeCommit && mergeable) {
                for (ChangeData c : targetBranch) {
                    mergeabilityMap.remove(c);
                }
                break;
            }
        }
    }
    return mergeabilityMap;
}
#method_after
public Collection<ChangeData> unmergeableChanges(ChangeSet cs) throws OrmException, IOException {
    Set<ChangeData> mergeabilityMap = new HashSet<>();
    for (ChangeData change : cs.changes()) {
        mergeabilityMap.add(change);
    }
    ListMultimap<Branch.NameKey, ChangeData> cbb = cs.changesByBranch();
    for (Branch.NameKey branch : cbb.keySet()) {
        Collection<ChangeData> targetBranch = cbb.get(branch);
        HashMap<Change.Id, RevCommit> commits = findCommits(targetBranch, branch.getParentKey());
        Set<ObjectId> allParents = Sets.newHashSetWithExpectedSize(cs.size());
        for (RevCommit commit : commits.values()) {
            for (RevCommit parent : commit.getParents()) {
                allParents.add(parent.getId());
            }
        }
        for (ChangeData change : targetBranch) {
            RevCommit commit = commits.get(change.getId());
            boolean isMergeCommit = commit.getParentCount() > 1;
            boolean isLastInChain = !allParents.contains(commit.getId());
            // Recheck mergeability rather than using value stored in the index,
            // which may be stale.
            // TODO(dborowitz): This is ugly; consider providing a way to not read
            // stored fields from the index in the first place.
            change.setMergeable(null);
            Boolean mergeable = change.isMergeable();
            if (mergeable == null) {
                // Skip whole check, cannot determine if mergeable
                return null;
            }
            if (mergeable) {
                mergeabilityMap.remove(change);
            }
            if (isLastInChain && isMergeCommit && mergeable) {
                for (ChangeData c : targetBranch) {
                    mergeabilityMap.remove(c);
                }
                break;
            }
        }
    }
    return mergeabilityMap;
}
#end_block

#method_before
@Override
public final T call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmException, UpdateParentFailedException, PermissionDeniedException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    Capable r = projectControl.canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new PermissionDeniedException(r.getMessage());
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (checkIfOwner && !projectControl.isOwner()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValid(name)) {
                if (checkIfOwner && !projectControl.controlForRef(name).isOwner()) {
                    continue;
                }
                RefPattern.validate(name);
                replace(config, toDelete, section);
            }
        }
        for (String name : toDelete) {
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!checkIfOwner || projectControl.isOwner()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (!checkIfOwner || projectControl.controlForRef(name).isOwner()) {
                config.remove(config.getAccessSection(name));
            }
        }
        boolean parentProjectUpdate = false;
        if (!config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(parentProjectName)) {
            parentProjectUpdate = true;
            try {
                setParent.get().validateParentUpdate(projectControl, MoreObjects.firstNonNull(parentProjectName, allProjects).get(), checkIfOwner);
            } catch (AuthException e) {
                throw new UpdateParentFailedException("You are not allowed to change the parent project since you are " + "not an administrator. You may save the modifications for review " + "so that an administrator can approve them.", e);
            } catch (ResourceConflictException | UnprocessableEntityException e) {
                throw new UpdateParentFailedException(e.getMessage(), e);
            }
            config.getProject().setParentName(parentProjectName);
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        return updateProjectConfig(projectControl.getUser(), config, md, parentProjectUpdate);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
}
#method_after
@Override
public final T call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmException, UpdateParentFailedException, PermissionDeniedException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    Capable r = projectControl.canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new PermissionDeniedException(r.getMessage());
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (checkIfOwner && !projectControl.isOwner()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValid(name)) {
                if (checkIfOwner && !projectControl.controlForRef(name).isOwner()) {
                    continue;
                }
                RefPattern.validate(name);
                replace(config, toDelete, section);
            }
        }
        for (String name : toDelete) {
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!checkIfOwner || projectControl.isOwner()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (!checkIfOwner || projectControl.controlForRef(name).isOwner()) {
                config.remove(config.getAccessSection(name));
            }
        }
        boolean parentProjectUpdate = false;
        if (!config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(parentProjectName)) {
            parentProjectUpdate = true;
            try {
                setParent.get().validateParentUpdate(projectControl, MoreObjects.firstNonNull(parentProjectName, allProjects).get(), checkIfOwner);
            } catch (AuthException e) {
                throw new UpdateParentFailedException("You are not allowed to change the parent project since you are " + "not an administrator. You may save the modifications for review " + "so that an administrator can approve them.", e);
            } catch (ResourceConflictException | UnprocessableEntityException e) {
                throw new UpdateParentFailedException(e.getMessage(), e);
            }
            config.getProject().setParentName(parentProjectName);
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        return updateProjectConfig(projectControl, config, md, parentProjectUpdate);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
}
#end_block

#method_before
public String passwordForKey(String key, String password) {
    String ov = getSecure(password);
    if (ov != null) {
        // 
        if (ui.isBatch() || !ui.yesno(false, "Change %s", key)) {
            return ov;
        }
    }
    final String nv = ui.password("%s", key);
    if (!eq(ov, nv)) {
        setSecure(password, nv);
    }
    return nv;
}
#method_after
public String passwordForKey(String prompt, String passwordKey) {
    String ov = getSecure(passwordKey);
    if (ov != null) {
        // 
        if (ui.isBatch() || !ui.yesno(false, "Change %s", passwordKey)) {
            return ov;
        }
    }
    final String nv = ui.password("%s", prompt);
    if (!eq(ov, nv)) {
        setSecure(passwordKey, nv);
    }
    return nv;
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (Repository git = repoManager.openRepository(allProjectsName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allProjectsName, git)) {
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection meta = config.getAccessSection(RefNames.REFS_CONFIG, true);
        Permission createRefsMetaConfigPermission = meta.getPermission(Permission.CREATE, true);
        Set<GroupReference> groups = Stream.concat(config.getAccessSection(AccessSection.GLOBAL_CAPABILITIES, true).getPermission(GlobalCapability.ADMINISTRATE_SERVER, true).getRules().stream().map(PermissionRule::getGroup), Stream.of(SystemGroupBackend.getGroup(PROJECT_OWNERS))).filter(g -> createRefsMetaConfigPermission.getRule(g) == null).collect(toSet());
        for (GroupReference group : groups) {
            createRefsMetaConfigPermission.add(new PermissionRule(config.resolve(group)));
        }
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(COMMIT_MSG);
        config.commit(md);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (Repository git = repoManager.openRepository(allProjectsName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allProjectsName, git)) {
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection meta = config.getAccessSection(RefNames.REFS_CONFIG, true);
        Permission createRefsMetaConfigPermission = meta.getPermission(Permission.CREATE, true);
        Set<GroupReference> groups = Stream.concat(config.getAccessSection(AccessSection.GLOBAL_CAPABILITIES, true).getPermission(GlobalCapability.ADMINISTRATE_SERVER, true).getRules().stream().map(PermissionRule::getGroup), Stream.of(systemGroupBackend.getGroup(PROJECT_OWNERS))).filter(g -> createRefsMetaConfigPermission.getRule(g) == null).collect(toSet());
        for (GroupReference group : groups) {
            createRefsMetaConfigPermission.add(new PermissionRule(config.resolve(group)));
        }
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(COMMIT_MSG);
        config.commit(md);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#end_block

#method_before
@Override
public GroupOptionsInfo apply(GroupResource resource, GroupOptionsInfo input) throws MethodNotAllowedException, AuthException, BadRequestException, ResourceNotFoundException, OrmException {
    if (resource.toAccountGroup() == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    if (input == null) {
        throw new BadRequestException("options are required");
    }
    if (input.visibleToAll == null) {
        input.visibleToAll = false;
    }
    AccountGroup group = db.get().accountGroups().get(resource.toAccountGroup().getId());
    if (group == null) {
        throw new ResourceNotFoundException();
    }
    group.setVisibleToAll(input.visibleToAll);
    db.get().accountGroups().update(Collections.singleton(group));
    groupCache.evict(group);
    GroupOptionsInfo options = new GroupOptionsInfo();
    if (group.isVisibleToAll()) {
        options.visibleToAll = true;
    }
    return options;
}
#method_after
@Override
public GroupOptionsInfo apply(GroupResource resource, GroupOptionsInfo input) throws MethodNotAllowedException, AuthException, BadRequestException, ResourceNotFoundException, OrmException, IOException {
    if (resource.toAccountGroup() == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    if (input == null) {
        throw new BadRequestException("options are required");
    }
    if (input.visibleToAll == null) {
        input.visibleToAll = false;
    }
    AccountGroup group = db.get().accountGroups().get(resource.toAccountGroup().getId());
    if (group == null) {
        throw new ResourceNotFoundException();
    }
    group.setVisibleToAll(input.visibleToAll);
    db.get().accountGroups().update(Collections.singleton(group));
    groupCache.evict(group);
    GroupOptionsInfo options = new GroupOptionsInfo();
    if (group.isVisibleToAll()) {
        options.visibleToAll = true;
    }
    return options;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    DynamicMap.mapOf(binder(), STAR_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects").to(PostWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects:delete").to(DeleteWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    get(ACCOUNT_KIND, "agreements").to(GetAgreements.class);
    put(ACCOUNT_KIND, "agreements").to(PutAgreement.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    child(ACCOUNT_KIND, "stars.changes").to(Stars.class);
    get(STAR_KIND).to(Stars.Get.class);
    post(STAR_KIND).to(Stars.Post.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    DynamicMap.mapOf(binder(), STAR_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    post(ACCOUNT_KIND, "index").to(Index.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "status").to(GetStatus.class);
    put(ACCOUNT_KIND, "status").to(PutStatus.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects").to(PostWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects:delete").to(DeleteWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    get(ACCOUNT_KIND, "agreements").to(GetAgreements.class);
    put(ACCOUNT_KIND, "agreements").to(PutAgreement.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    child(ACCOUNT_KIND, "stars.changes").to(Stars.class);
    get(STAR_KIND).to(Stars.Get.class);
    post(STAR_KIND).to(Stars.Post.class);
    get(ACCOUNT_KIND, "external.ids").to(GetExternalIds.class);
    post(ACCOUNT_KIND, "external.ids:delete").to(DeleteExternalIds.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
Collection<CodeReviewCommit> sort(final Collection<CodeReviewCommit> incoming) throws IOException {
    final Set<CodeReviewCommit> heads = new HashSet<>();
    final Set<CodeReviewCommit> sort = new HashSet<>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        for (RevCommit c : accepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        RevCommitList<RevCommit> contents = new RevCommitList<>();
        while ((c = rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                // 
                if (n.missing == null) {
                    n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY);
                    n.missing = new ArrayList<>();
                }
                n.missing.add(c);
            } else {
                contents.add(c);
            }
        }
        if (n.getStatusCode() == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        // Anything reachable through us is better merged by just
        // merging us directly. So prune our ancestors out and let
        // us merge instead.
        // 
        sort.removeAll(contents);
        heads.removeAll(contents);
        heads.add(n);
    }
    return heads;
}
#method_after
Collection<CodeReviewCommit> sort(final Collection<CodeReviewCommit> toMerge) throws IOException {
    return sort(toMerge, toMerge);
}
#end_block

#method_before
Collection<CodeReviewCommit> sort(final Collection<CodeReviewCommit> incoming) throws IOException {
    final Set<CodeReviewCommit> heads = new HashSet<>();
    final Set<CodeReviewCommit> sort = new HashSet<>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        for (RevCommit c : accepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        RevCommitList<RevCommit> contents = new RevCommitList<>();
        while ((c = rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                // 
                if (n.missing == null) {
                    n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY);
                    n.missing = new ArrayList<>();
                }
                n.missing.add(c);
            } else {
                contents.add(c);
            }
        }
        if (n.getStatusCode() == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        // Anything reachable through us is better merged by just
        // merging us directly. So prune our ancestors out and let
        // us merge instead.
        // 
        sort.removeAll(contents);
        heads.removeAll(contents);
        heads.add(n);
    }
    return heads;
}
#method_after
Collection<CodeReviewCommit> sort(final Collection<CodeReviewCommit> toMerge, final Collection<CodeReviewCommit> incoming) throws IOException {
    final Set<CodeReviewCommit> heads = new HashSet<>();
    final Set<CodeReviewCommit> sort = new HashSet<>(toMerge);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        for (RevCommit c : accepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        RevCommitList<RevCommit> contents = new RevCommitList<>();
        while ((c = rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                // We cannot merge n as it would bring something we
                // aren't permitted to merge at this time. Drop n.
                // 
                n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY);
                break;
            }
            contents.add(c);
        }
        if (n.getStatusCode() == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        // Anything reachable through us is better merged by just
        // merging us directly. So prune our ancestors out and let
        // us merge instead.
        // 
        sort.removeAll(contents);
        heads.removeAll(contents);
        heads.add(n);
    }
    return heads;
}
#end_block

#method_before
public ChangeInfo format(Project.NameKey project, Change.Id id) throws OrmException, NoSuchChangeException {
    ChangeNotes notes;
    try {
        notes = notesFactory.createChecked(db.get(), project, id);
    } catch (OrmException | NoSuchChangeException e) {
        if (!has(CHECK)) {
            throw e;
        }
        return checkOnly(changeDataFactory.create(db.get(), project, id));
    }
    return format(changeDataFactory.create(db.get(), notes));
}
#method_after
public ChangeInfo format(Project.NameKey project, Change.Id id) throws OrmException {
    ChangeNotes notes;
    try {
        notes = notesFactory.createChecked(db.get(), project, id);
    } catch (OrmException e) {
        if (!has(CHECK)) {
            throw e;
        }
        return checkOnly(changeDataFactory.create(db.get(), project, id));
    }
    return format(changeDataFactory.create(db.get(), notes));
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(ctl, cd) : ImmutableMap.of();
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(ctl, cd) : ImmutableMap.of();
        }
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(ctl, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, tag, date));
        }
    }
}
#method_after
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        Map<String, VotingRangeInfo> pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            VotingRangeInfo permittedVotingRange = pvr.getOrDefault(lt.getName(), null);
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, permittedVotingRange, tag, date));
        }
    }
}
#end_block

#method_before
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    Set<String> labelNames = new HashSet<>();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    Map<String, LabelWithStatus> labels;
    if (cd.change().getStatus() == Change.Status.MERGED) {
        // Since voting on merged changes is allowed all labels which apply to
        // the change must be returned. All applying labels can be retrieved from
        // the submit records, which is what initLabels does.
        // It's not possible to only compute the labels based on the approvals
        // since merged changes may not have approvals for all labels (e.g. if not
        // all labels are required for submit or if the change was auto-closed due
        // to direct push or if new labels were defined after the change was
        // merged).
        labels = initLabels(cd, labelTypes, standard);
        // it wouldn't be included in the submit records.
        for (String name : labelNames) {
            if (!labels.containsKey(name)) {
                labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
            }
        }
    } else {
        // For abandoned changes return only labels for which approvals exist.
        // Other labels are not needed since voting on abandoned changes is not
        // allowed.
        labels = new TreeMap<>(labelTypes.nameComparator());
        for (String name : labelNames) {
            labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
        }
    }
    if (detailed) {
        labels.entrySet().stream().forEach(e -> setLabelValues(labelTypes.byLabel(e.getKey()), e.getValue()));
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        if (detailed) {
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
                if (psa.isPostSubmit()) {
                    info.postSubmit = true;
                }
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeControl baseCtrl, ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    Set<String> labelNames = new HashSet<>();
    SetMultimap<Account.Id, PatchSetApproval> current = MultimapBuilder.hashKeys().hashSetValues().build();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    Map<String, LabelWithStatus> labels;
    if (cd.change().getStatus() == Change.Status.MERGED) {
        // Since voting on merged changes is allowed all labels which apply to
        // the change must be returned. All applying labels can be retrieved from
        // the submit records, which is what initLabels does.
        // It's not possible to only compute the labels based on the approvals
        // since merged changes may not have approvals for all labels (e.g. if not
        // all labels are required for submit or if the change was auto-closed due
        // to direct push or if new labels were defined after the change was
        // merged).
        labels = initLabels(cd, labelTypes, standard);
        // it wouldn't be included in the submit records.
        for (String name : labelNames) {
            if (!labels.containsKey(name)) {
                labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
            }
        }
    } else {
        // For abandoned changes return only labels for which approvals exist.
        // Other labels are not needed since voting on abandoned changes is not
        // allowed.
        labels = new TreeMap<>(labelTypes.nameComparator());
        for (String name : labelNames) {
            labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
        }
    }
    if (detailed) {
        labels.entrySet().stream().filter(e -> labelTypes.byLabel(e.getKey()) != null).forEach(e -> setLabelValues(labelTypes.byLabel(e.getKey()), e.getValue()));
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        Map<String, VotingRangeInfo> pvr = Collections.emptyMap();
        if (detailed) {
            ChangeControl ctl = baseCtrl.forUser(userFactory.create(accountId));
            pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.permittedVotingRange = pvr.getOrDefault(type.getName(), null);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
                if (psa.isPostSubmit()) {
                    info.postSubmit = true;
                }
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#end_block

#method_before
private ApprovalInfo approvalInfo(Account.Id id, Integer value, String tag, Timestamp date) {
    ApprovalInfo ai = getApprovalInfo(id, value, tag, date);
    accountLoader.put(ai);
    return ai;
}
#method_after
private ApprovalInfo approvalInfo(Account.Id id, Integer value, VotingRangeInfo permittedVotingRange, String tag, Timestamp date) {
    ApprovalInfo ai = getApprovalInfo(id, value, permittedVotingRange, tag, date);
    accountLoader.put(ai);
    return ai;
}
#end_block

#method_before
public static ApprovalInfo getApprovalInfo(Account.Id id, Integer value, String tag, Timestamp date) {
    ApprovalInfo ai = new ApprovalInfo(id.get());
    ai.value = value;
    ai.date = date;
    ai.tag = tag;
    return ai;
}
#method_after
public static ApprovalInfo getApprovalInfo(Account.Id id, Integer value, VotingRangeInfo permittedVotingRange, String tag, Timestamp date) {
    ApprovalInfo ai = new ApprovalInfo(id.get());
    ai.value = value;
    ai.permittedVotingRange = permittedVotingRange;
    ai.date = date;
    ai.tag = tag;
    return ai;
}
#end_block

#method_before
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                if (range.contains(v.getValue())) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#method_after
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null || !ctl.getUser().isIdentifiedUser()) {
        return null;
    }
    Map<String, Short> labels = null;
    boolean isMerged = ctl.getChange().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                boolean ok = range.contains(v.getValue());
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(ctl);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, Collection<LabelInfo> labels) {
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, 0)) {
                removable.add(id);
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, false));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, false, changeInfo));
            }
        }
        return res;
    }
}
#end_block

#method_before
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, true);
        accountLoader.fill();
        return rev;
    }
}
#method_after
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, true, null);
        accountLoader.fill();
        return rev;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, boolean fillCommit) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
            }
            if (addFooters) {
                Ref ref = repo.exactRef(ctl.getChange().getDest().get());
                RevCommit mergeTip = null;
                if (ref != null) {
                    mergeTip = rw.parseCommit(ref.getObjectId());
                    rw.parseBody(mergeTip);
                }
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getParentLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
private void makeSiteConfig(SitePaths site, Config cfg, SshInfo sshInfo) throws IOException {
    if (!Files.exists(site.tmp_dir)) {
        Files.createDirectories(site.tmp_dir);
    }
    Path myconf = Files.createTempFile(site.tmp_dir, "gitweb_config", ".perl");
    // To make our configuration file only readable or writable by us;
    // this reduces the chances of someone tampering with the file.
    // 
    // TODO(dborowitz): Is there a portable way to do this with NIO?
    File myconfFile = myconf.toFile();
    myconfFile.setWritable(false, false);
    myconfFile.setReadable(false, false);
    myconfFile.setExecutable(false, false);
    myconfFile.setWritable(true, true);
    myconfFile.setReadable(true, true);
    myconfFile.deleteOnExit();
    _env.set("GIT_DIR", ".");
    _env.set("GITWEB_CONFIG", myconf.toAbsolutePath().toString());
    try (PrintWriter p = new PrintWriter(Files.newBufferedWriter(myconf, UTF_8))) {
        p.print("# Autogenerated by Gerrit Code Review \n");
        p.print("# DO NOT EDIT\n");
        p.print("\n");
        // We are mounted at the same level in the context as the main
        // UI, so we can include the same header and footer scheme.
        // 
        Path hdr = site.site_header;
        if (Files.isRegularFile(hdr)) {
            p.print("$site_header = " + quoteForPerl(hdr) + ";\n");
        }
        Path ftr = site.site_footer;
        if (Files.isRegularFile(ftr)) {
            p.print("$site_footer = " + quoteForPerl(ftr) + ";\n");
        }
        // Top level should return to Gerrit's UI.
        // 
        p.print("$home_link = $ENV{'GERRIT_CONTEXT_PATH'};\n");
        p.print("$home_link_str = 'Code Review';\n");
        p.print("$favicon = 'favicon.ico';\n");
        p.print("$logo = 'gitweb-logo.png';\n");
        p.print("$javascript = 'gitweb.js';\n");
        p.print("@stylesheets = ('gitweb-default.css');\n");
        Path css = site.site_css;
        if (Files.isRegularFile(css)) {
            p.print("push @stylesheets, 'gitweb-site.css';\n");
        }
        // Try to make the title match Gerrit's normal window title
        // scheme of host followed by 'Code Review'.
        // 
        p.print("$site_name = $home_link_str;\n");
        p.print("$site_name = qq{$1 $site_name} if ");
        p.print("$ENV{'SERVER_NAME'} =~ m,^([^.]+(?:\\.[^.]+)?)(?:\\.|$),;\n");
        // Assume by default that XSS is a problem, and try to prevent it.
        // 
        p.print("$prevent_xss = 1;\n");
        // Generate URLs using smart http://
        // 
        p.print("{\n");
        p.print("  my $secure = $ENV{'HTTPS'} =~ /^ON$/i;\n");
        p.print("  my $http_url = $secure ? 'https://' : 'http://';\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_USER_NAME'}@}\n");
        p.print("    unless $ENV{'GERRIT_ANONYMOUS_READ'};\n");
        p.print("  $http_url .= $ENV{'SERVER_NAME'};\n");
        p.print("  $http_url .= qq{:$ENV{'SERVER_PORT'}}\n");
        p.print("    if (( $secure && $ENV{'SERVER_PORT'} != 443)\n");
        p.print("     || (!$secure && $ENV{'SERVER_PORT'} != 80)\n");
        p.print("    );\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_CONTEXT_PATH'}p};\n");
        p.print("  push @git_base_url_list, $http_url;\n");
        p.print("}\n");
        // Generate URLs using anonymous git://
        // 
        String url = cfg.getString("gerrit", null, "canonicalGitUrl");
        if (url != null) {
            if (url.endsWith("/")) {
                url = url.substring(0, url.length() - 1);
            }
            p.print("if ($ENV{'GERRIT_ANONYMOUS_READ'}) {\n");
            p.print("  push @git_base_url_list, ");
            p.print(quoteForPerl(url));
            p.print(";\n");
            p.print("}\n");
        }
        // 
        if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
            String sshAddr = sshInfo.getHostKeys().get(0).getHost();
            p.print("if ($ENV{'GERRIT_USER_NAME'}) {\n");
            p.print("  push @git_base_url_list, join('', 'ssh://'");
            p.print(", $ENV{'GERRIT_USER_NAME'}");
            p.print(", '@'");
            if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
                p.print(", $ENV{'SERVER_NAME'}");
            }
            if (sshAddr.startsWith("*")) {
                sshAddr = sshAddr.substring(1);
            }
            p.print(", " + quoteForPerl(sshAddr));
            p.print(");\n");
            p.print("}\n");
        }
        // Link back to Gerrit (when possible, to matching review record).
        // Supported gitweb's hash values are:
        // - (missing),
        // - HEAD,
        // - refs/heads/<branch>,
        // - refs/changes/*/<change>/*,
        // - <revision>.
        // 
        p.print("sub add_review_link {\n");
        p.print("  my $h = shift;\n");
        p.print("  my $q;\n");
        p.print("  if (!$h || $h eq 'HEAD') {\n");
        p.print("    $q = qq{#/q/project:$ENV{'GERRIT_PROJECT_NAME'}};\n");
        p.print("  } elsif ($h =~ /^refs\\/heads\\/([-\\w]+)$/) {\n");
        p.print("    $q = qq{#/q/project:$ENV{'GERRIT_PROJECT_NAME'}");
        // wrapped
        p.print("+branch:$1};\n");
        p.print("  } elsif ($h =~ /^refs\\/changes\\/\\d{2}\\/(\\d+)\\/\\d+$/) ");
        // wrapped
        p.print("{\n");
        p.print("    $q = qq{#/c/$1};\n");
        p.print("  } else {\n");
        p.print("    $q = qq{#/q/$h};\n");
        p.print("  }\n");
        p.print("  my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}$q};\n");
        p.print("  push @{$feature{'actions'}{'default'}},\n");
        p.print("      ('review',$r,'commitdiff');\n");
        p.print("}\n");
        p.print("if ($cgi->param('hb')) {\n");
        p.print("  add_review_link($cgi->param('hb'));\n");
        p.print("} elsif ($cgi->param('h')) {\n");
        p.print("  add_review_link($cgi->param('h'));\n");
        p.print("} else {\n");
        p.print("  add_review_link();\n");
        p.print("}\n");
        // If the administrator has created a site-specific gitweb_config,
        // load that before we perform any final overrides.
        // 
        Path sitecfg = site.site_gitweb;
        if (Files.isRegularFile(sitecfg)) {
            p.print("$GITWEB_CONFIG = " + quoteForPerl(sitecfg) + ";\n");
            p.print("if (-e $GITWEB_CONFIG) {\n");
            p.print("  do " + quoteForPerl(sitecfg) + ";\n");
            p.print("}\n");
        }
        p.print("$projectroot = $ENV{'GITWEB_PROJECTROOT'};\n");
        // Permit exporting only the project we were started for.
        // We use the name under $projectroot in case symlinks
        // were involved in the path.
        // 
        p.print("$export_auth_hook = sub {\n");
        p.print("    my $dir = shift;\n");
        p.print("    my $name = $ENV{'GERRIT_PROJECT_NAME'};\n");
        p.print("    my $allow = qq{$projectroot/$name.git};\n");
        p.print("    return $dir eq $allow;\n");
        p.print("  };\n");
        // Do not allow the administrator to enable path info, its
        // not a URL format we currently support.
        // 
        p.print("$feature{'pathinfo'}{'override'} = 0;\n");
        p.print("$feature{'pathinfo'}{'default'} = [0];\n");
        // We don't do forking, so don't allow it to be enabled.
        // 
        p.print("$feature{'forks'}{'override'} = 0;\n");
        p.print("$feature{'forks'}{'default'} = [0];\n");
    }
    myconfFile.setReadOnly();
}
#method_after
private void makeSiteConfig(SitePaths site, Config cfg, SshInfo sshInfo) throws IOException {
    if (!Files.exists(site.tmp_dir)) {
        Files.createDirectories(site.tmp_dir);
    }
    Path myconf = Files.createTempFile(site.tmp_dir, "gitweb_config", ".perl");
    // To make our configuration file only readable or writable by us;
    // this reduces the chances of someone tampering with the file.
    // 
    // TODO(dborowitz): Is there a portable way to do this with NIO?
    File myconfFile = myconf.toFile();
    myconfFile.setWritable(false, false);
    myconfFile.setReadable(false, false);
    myconfFile.setExecutable(false, false);
    myconfFile.setWritable(true, true);
    myconfFile.setReadable(true, true);
    myconfFile.deleteOnExit();
    _env.set("GIT_DIR", ".");
    _env.set("GITWEB_CONFIG", myconf.toAbsolutePath().toString());
    try (PrintWriter p = new PrintWriter(Files.newBufferedWriter(myconf, UTF_8))) {
        p.print("# Autogenerated by Gerrit Code Review \n");
        p.print("# DO NOT EDIT\n");
        p.print("\n");
        // We are mounted at the same level in the context as the main
        // UI, so we can include the same header and footer scheme.
        // 
        Path hdr = site.site_header;
        if (Files.isRegularFile(hdr)) {
            p.print("$site_header = " + quoteForPerl(hdr) + ";\n");
        }
        Path ftr = site.site_footer;
        if (Files.isRegularFile(ftr)) {
            p.print("$site_footer = " + quoteForPerl(ftr) + ";\n");
        }
        // Top level should return to Gerrit's UI.
        // 
        p.print("$home_link = $ENV{'GERRIT_CONTEXT_PATH'};\n");
        p.print("$home_link_str = 'Code Review';\n");
        p.print("$favicon = 'favicon.ico';\n");
        p.print("$logo = 'gitweb-logo.png';\n");
        p.print("$javascript = 'gitweb.js';\n");
        p.print("@stylesheets = ('gitweb-default.css');\n");
        Path css = site.site_css;
        if (Files.isRegularFile(css)) {
            p.print("push @stylesheets, 'gitweb-site.css';\n");
        }
        // Try to make the title match Gerrit's normal window title
        // scheme of host followed by 'Code Review'.
        // 
        p.print("$site_name = $home_link_str;\n");
        p.print("$site_name = qq{$1 $site_name} if ");
        p.print("$ENV{'SERVER_NAME'} =~ m,^([^.]+(?:\\.[^.]+)?)(?:\\.|$),;\n");
        // Assume by default that XSS is a problem, and try to prevent it.
        // 
        p.print("$prevent_xss = 1;\n");
        // Generate URLs using smart http://
        // 
        p.print("{\n");
        p.print("  my $secure = $ENV{'HTTPS'} =~ /^ON$/i;\n");
        p.print("  my $http_url = $secure ? 'https://' : 'http://';\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_USER_NAME'}@}\n");
        p.print("    unless $ENV{'GERRIT_ANONYMOUS_READ'};\n");
        p.print("  $http_url .= $ENV{'SERVER_NAME'};\n");
        p.print("  $http_url .= qq{:$ENV{'SERVER_PORT'}}\n");
        p.print("    if (( $secure && $ENV{'SERVER_PORT'} != 443)\n");
        p.print("     || (!$secure && $ENV{'SERVER_PORT'} != 80)\n");
        p.print("    );\n");
        p.print("  my $context = $ENV{'GERRIT_CONTEXT_PATH'};\n");
        p.print("  chop($context);\n");
        p.print("  $http_url .= qq{$context};\n");
        p.print("  $http_url .= qq{/a}\n");
        p.print("    unless $ENV{'GERRIT_ANONYMOUS_READ'};\n");
        p.print("  push @git_base_url_list, $http_url;\n");
        p.print("}\n");
        // Generate URLs using anonymous git://
        // 
        String url = cfg.getString("gerrit", null, "canonicalGitUrl");
        if (url != null) {
            if (url.endsWith("/")) {
                url = url.substring(0, url.length() - 1);
            }
            p.print("if ($ENV{'GERRIT_ANONYMOUS_READ'}) {\n");
            p.print("  push @git_base_url_list, ");
            p.print(quoteForPerl(url));
            p.print(";\n");
            p.print("}\n");
        }
        // 
        if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
            String sshAddr = sshInfo.getHostKeys().get(0).getHost();
            p.print("if ($ENV{'GERRIT_USER_NAME'}) {\n");
            p.print("  push @git_base_url_list, join('', 'ssh://'");
            p.print(", $ENV{'GERRIT_USER_NAME'}");
            p.print(", '@'");
            if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
                p.print(", $ENV{'SERVER_NAME'}");
            }
            if (sshAddr.startsWith("*")) {
                sshAddr = sshAddr.substring(1);
            }
            p.print(", " + quoteForPerl(sshAddr));
            p.print(");\n");
            p.print("}\n");
        }
        // Link back to Gerrit (when possible, to matching review record).
        // Supported gitweb's hash values are:
        // - (missing),
        // - HEAD,
        // - refs/heads/<branch>,
        // - refs/changes/*/<change>/*,
        // - <revision>.
        // 
        p.print("sub add_review_link {\n");
        p.print("  my $h = shift;\n");
        p.print("  my $q;\n");
        p.print("  if (!$h || $h eq 'HEAD') {\n");
        p.print("    $q = qq{#/q/project:$ENV{'GERRIT_PROJECT_NAME'}};\n");
        p.print("  } elsif ($h =~ /^refs\\/heads\\/([-\\w]+)$/) {\n");
        p.print("    $q = qq{#/q/project:$ENV{'GERRIT_PROJECT_NAME'}");
        // wrapped
        p.print("+branch:$1};\n");
        p.print("  } elsif ($h =~ /^refs\\/changes\\/\\d{2}\\/(\\d+)\\/\\d+$/) ");
        // wrapped
        p.print("{\n");
        p.print("    $q = qq{#/c/$1};\n");
        p.print("  } else {\n");
        p.print("    $q = qq{#/q/$h};\n");
        p.print("  }\n");
        p.print("  my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}$q};\n");
        p.print("  push @{$feature{'actions'}{'default'}},\n");
        p.print("      ('review',$r,'commitdiff');\n");
        p.print("}\n");
        p.print("if ($cgi->param('hb')) {\n");
        p.print("  add_review_link($cgi->param('hb'));\n");
        p.print("} elsif ($cgi->param('h')) {\n");
        p.print("  add_review_link($cgi->param('h'));\n");
        p.print("} else {\n");
        p.print("  add_review_link();\n");
        p.print("}\n");
        // If the administrator has created a site-specific gitweb_config,
        // load that before we perform any final overrides.
        // 
        Path sitecfg = site.site_gitweb;
        if (Files.isRegularFile(sitecfg)) {
            p.print("$GITWEB_CONFIG = " + quoteForPerl(sitecfg) + ";\n");
            p.print("if (-e $GITWEB_CONFIG) {\n");
            p.print("  do " + quoteForPerl(sitecfg) + ";\n");
            p.print("}\n");
        }
        p.print("$projectroot = $ENV{'GITWEB_PROJECTROOT'};\n");
        // Permit exporting only the project we were started for.
        // We use the name under $projectroot in case symlinks
        // were involved in the path.
        // 
        p.print("$export_auth_hook = sub {\n");
        p.print("    my $dir = shift;\n");
        p.print("    my $name = $ENV{'GERRIT_PROJECT_NAME'};\n");
        p.print("    my $allow = qq{$projectroot/$name.git};\n");
        p.print("    return $dir eq $allow;\n");
        p.print("  };\n");
        // Do not allow the administrator to enable path info, its
        // not a URL format we currently support.
        // 
        p.print("$feature{'pathinfo'}{'override'} = 0;\n");
        p.print("$feature{'pathinfo'}{'default'} = [0];\n");
        // We don't do forking, so don't allow it to be enabled.
        // 
        p.print("$feature{'forks'}{'override'} = 0;\n");
        p.print("$feature{'forks'}{'default'} = [0];\n");
    }
    myconfFile.setReadOnly();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    put(GROUP_KIND).to(PutGroup.class);
    get(GROUP_KIND, "detail").to(GetDetail.class);
    post(GROUP_KIND, "members").to(AddMembers.class);
    post(GROUP_KIND, "members.add").to(AddMembers.class);
    post(GROUP_KIND, "members.delete").to(DeleteMembers.class);
    post(GROUP_KIND, "groups").to(AddIncludedGroups.class);
    post(GROUP_KIND, "groups.add").to(AddIncludedGroups.class);
    post(GROUP_KIND, "groups.delete").to(DeleteIncludedGroups.class);
    get(GROUP_KIND, "description").to(GetDescription.class);
    put(GROUP_KIND, "description").to(PutDescription.class);
    delete(GROUP_KIND, "description").to(PutDescription.class);
    get(GROUP_KIND, "name").to(GetName.class);
    put(GROUP_KIND, "name").to(PutName.class);
    get(GROUP_KIND, "owner").to(GetOwner.class);
    put(GROUP_KIND, "owner").to(PutOwner.class);
    get(GROUP_KIND, "options").to(GetOptions.class);
    put(GROUP_KIND, "options").to(PutOptions.class);
    get(GROUP_KIND, "log.audit").to(GetAuditLog.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(MEMBER_KIND).to(UpdateMember.class);
    delete(MEMBER_KIND).to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
    put(INCLUDED_GROUP_KIND).to(UpdateIncludedGroup.class);
    delete(INCLUDED_GROUP_KIND).to(DeleteIncludedGroup.class);
    factory(CreateGroup.Factory.class);
    DynamicSet.bind(binder(), GroupMemberAuditListener.class).to(DbGroupMemberAuditListener.class);
}
#method_after
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    put(GROUP_KIND).to(PutGroup.class);
    get(GROUP_KIND, "detail").to(GetDetail.class);
    post(GROUP_KIND, "index").to(Index.class);
    post(GROUP_KIND, "members").to(AddMembers.class);
    post(GROUP_KIND, "members.add").to(AddMembers.class);
    post(GROUP_KIND, "members.delete").to(DeleteMembers.class);
    post(GROUP_KIND, "groups").to(AddIncludedGroups.class);
    post(GROUP_KIND, "groups.add").to(AddIncludedGroups.class);
    post(GROUP_KIND, "groups.delete").to(DeleteIncludedGroups.class);
    get(GROUP_KIND, "description").to(GetDescription.class);
    put(GROUP_KIND, "description").to(PutDescription.class);
    delete(GROUP_KIND, "description").to(PutDescription.class);
    get(GROUP_KIND, "name").to(GetName.class);
    put(GROUP_KIND, "name").to(PutName.class);
    get(GROUP_KIND, "owner").to(GetOwner.class);
    put(GROUP_KIND, "owner").to(PutOwner.class);
    get(GROUP_KIND, "options").to(GetOptions.class);
    put(GROUP_KIND, "options").to(PutOptions.class);
    get(GROUP_KIND, "log.audit").to(GetAuditLog.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(MEMBER_KIND).to(UpdateMember.class);
    delete(MEMBER_KIND).to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
    put(INCLUDED_GROUP_KIND).to(UpdateIncludedGroup.class);
    delete(INCLUDED_GROUP_KIND).to(DeleteIncludedGroup.class);
    factory(CreateGroup.Factory.class);
    DynamicSet.bind(binder(), GroupMemberAuditListener.class).to(DbGroupMemberAuditListener.class);
}
#end_block

#method_before
public ChangeControl controlFor(ReviewDb db, Project.NameKey project, Change.Id changeId, CurrentUser user) throws NoSuchChangeException, OrmException {
    return controlFor(notesFactory.create(db, project, changeId), user);
}
#method_after
public ChangeControl controlFor(ReviewDb db, Project.NameKey project, Change.Id changeId, CurrentUser user) throws OrmException {
    return controlFor(notesFactory.create(db, project, changeId), user);
}
#end_block

#method_before
public ChangeControl controlFor(ReviewDb db, Change change, CurrentUser user) throws NoSuchChangeException, OrmException {
    final Project.NameKey projectKey = change.getProject();
    try {
        return projectControl.controlFor(projectKey, user).controlFor(db, change);
    } catch (NoSuchProjectException e) {
        throw new NoSuchChangeException(change.getId(), e);
    } catch (IOException e) {
        // TODO: propagate this exception
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#method_after
public ChangeControl controlFor(ReviewDb db, Change change, CurrentUser user) throws OrmException {
    final Project.NameKey projectKey = change.getProject();
    try {
        return projectControl.controlFor(projectKey, user).controlFor(db, change);
    } catch (NoSuchProjectException e) {
        throw new NoSuchChangeException(change.getId(), e);
    } catch (IOException e) {
        // TODO: propagate this exception
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#end_block

#method_before
public ChangeControl validateFor(ReviewDb db, Change.Id changeId, CurrentUser user) throws NoSuchChangeException, OrmException {
    return validateFor(db, notesFactory.createChecked(changeId), user);
}
#method_after
public ChangeControl validateFor(ReviewDb db, Change.Id changeId, CurrentUser user) throws OrmException {
    return validateFor(db, notesFactory.createChecked(changeId), user);
}
#end_block

#method_before
public ChangeControl validateFor(ReviewDb db, ChangeNotes notes, CurrentUser user) throws NoSuchChangeException, OrmException {
    ChangeControl c = controlFor(notes, user);
    if (!c.isVisible(db)) {
        throw new NoSuchChangeException(c.getId());
    }
    return c;
}
#method_after
public ChangeControl validateFor(ReviewDb db, ChangeNotes notes, CurrentUser user) throws OrmException {
    ChangeControl c = controlFor(notes, user);
    if (!c.isVisible(db)) {
        throw new NoSuchChangeException(c.getId());
    }
    return c;
}
#end_block

#method_before
public void validatePreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch, PatchSet.Id patchSetId, IdentifiedUser caller) throws MergeValidationException {
    List<MergeValidationListener> validators = new LinkedList<>();
    validators.add(new PluginMergeValidationListener(mergeValidationListeners));
    validators.add(projectConfigValidatorFactory.create());
    for (MergeValidationListener validator : validators) {
        validator.onPreMerge(repo, commit, destProject, destBranch, patchSetId, caller);
    }
}
#method_after
public void validatePreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch, PatchSet.Id patchSetId, IdentifiedUser caller) throws MergeValidationException {
    List<MergeValidationListener> validators = ImmutableList.of(new PluginMergeValidationListener(mergeValidationListeners), projectConfigValidatorFactory.create());
    for (MergeValidationListener validator : validators) {
        validator.onPreMerge(repo, commit, destProject, destBranch, patchSetId, caller);
    }
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    String parentName = MoreObjects.firstNonNull(Strings.emptyToNull(input.parent), allProjects.get());
    args.newParent = projectsCollection.get().parse(parentName).getControl();
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProject(args);
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), identifiedUser.get());
            ConfigInput in = new ConfigInput();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(projectControl, in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    String parentName = MoreObjects.firstNonNull(Strings.emptyToNull(input.parent), allProjects.get());
    args.newParent = projectsCollection.get().parse(parentName, false).getControl();
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProject(args);
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), identifiedUser.get());
            ConfigInput in = new ConfigInput();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(projectControl, in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#end_block

#method_before
private void createProjectConfig(CreateProjectArgs args) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(args.getProject())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project newProject = config.getProject();
        newProject.setDescription(args.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(args.submitType, repositoryCfg.getDefaultSubmitType(args.getProject())));
        newProject.setUseContributorAgreements(args.contributorAgreements);
        newProject.setUseSignedOffBy(args.signedOffBy);
        newProject.setUseContentMerge(args.contentMerge);
        newProject.setCreateNewChangeForAllNotInTarget(args.newChangeForAllNotInTarget);
        newProject.setRequireChangeID(args.changeIdRequired);
        newProject.setMaxObjectSizeLimit(args.maxObjectSizeLimit);
        if (args.newParent != null) {
            newProject.setParentName(args.newParent.getProject().getNameKey());
        }
        if (!args.ownerIds.isEmpty()) {
            AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : args.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    }
    projectCache.onCreateProject(args.getProject());
    repoManager.setProjectDescription(args.getProject(), args.projectDescription);
}
#method_after
private void createProjectConfig(CreateProjectArgs args) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(args.getProject())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project newProject = config.getProject();
        newProject.setDescription(args.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(args.submitType, repositoryCfg.getDefaultSubmitType(args.getProject())));
        newProject.setUseContributorAgreements(args.contributorAgreements);
        newProject.setUseSignedOffBy(args.signedOffBy);
        newProject.setUseContentMerge(args.contentMerge);
        newProject.setCreateNewChangeForAllNotInTarget(args.newChangeForAllNotInTarget);
        newProject.setRequireChangeID(args.changeIdRequired);
        newProject.setMaxObjectSizeLimit(args.maxObjectSizeLimit);
        if (args.newParent != null) {
            newProject.setParentName(args.newParent.getProject().getNameKey());
        }
        if (!args.ownerIds.isEmpty()) {
            AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : args.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
        md.getRepository().setGitwebDescription(args.projectDescription);
    }
    projectCache.onCreateProject(args.getProject());
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    if (args.mergeTip.getInitialTip() == null && !sorted.isEmpty()) {
        // The branch is unborn. Take a fast-forward resolution to
        // create the branch.
        CodeReviewCommit first = sorted.remove(0);
        ops.add(new FastForwardOp(args, first));
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        ops.add(new MergeOneOp(args, n));
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge, args.incoming);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    if (args.mergeTip.getInitialTip() == null && !sorted.isEmpty()) {
        // The branch is unborn. Take a fast-forward resolution to
        // create the branch.
        CodeReviewCommit first = sorted.remove(0);
        ops.add(new FastForwardOp(args, first));
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        ops.add(new MergeOneOp(args, n));
    }
    return ops;
}
#end_block

#method_before
@Option(name = "-q", usage = "group to inspect")
public void addGroup(AccountGroup.UUID id) {
    groupsToInspect.add(id);
}
#method_after
@Option(name = "--group", aliases = { "-g" }, usage = "group to inspect")
public void addGroup(AccountGroup.UUID uuid) {
    groupsToInspect.add(uuid);
}
#end_block

#method_before
private List<AccountGroup> filterGroups(Collection<AccountGroup> groups) {
    List<AccountGroup> filteredGroups = new ArrayList<>(groups.size());
    boolean isAdmin = identifiedUser.get().getCapabilities().canAdministrateServer();
    for (AccountGroup group : groups) {
        if (!Strings.isNullOrEmpty(matchSubstring)) {
            if (!group.getName().toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US))) {
                continue;
            }
        }
        if (!isAdmin) {
            GroupControl c = groupControlFactory.controlFor(group);
            if (!c.isVisible()) {
                continue;
            }
        }
        if (visibleToAll && !group.isVisibleToAll()) {
            continue;
        }
        if (!groupsToInspect.isEmpty() && !groupsToInspect.contains(group.getGroupUUID())) {
            continue;
        }
        filteredGroups.add(group);
    }
    Collections.sort(filteredGroups, new GroupComparator());
    return filteredGroups;
}
#method_after
private List<AccountGroup> filterGroups(Collection<AccountGroup> groups) {
    List<AccountGroup> filteredGroups = new ArrayList<>(groups.size());
    boolean isAdmin = identifiedUser.get().getCapabilities().canAdministrateServer();
    for (AccountGroup group : groups) {
        if (!Strings.isNullOrEmpty(matchSubstring)) {
            if (!group.getName().toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US))) {
                continue;
            }
        }
        if (visibleToAll && !group.isVisibleToAll()) {
            continue;
        }
        if (!groupsToInspect.isEmpty() && !groupsToInspect.contains(group.getGroupUUID())) {
            continue;
        }
        if (!isAdmin) {
            GroupControl c = groupControlFactory.controlFor(group);
            if (!c.isVisible()) {
                continue;
            }
        }
        filteredGroups.add(group);
    }
    Collections.sort(filteredGroups, new GroupComparator());
    return filteredGroups;
}
#end_block

#method_before
@Override
public void evict(final AccountGroup group) {
    if (group.getId() != null) {
        byId.invalidate(group.getId());
    }
    if (group.getNameKey() != null) {
        byName.invalidate(group.getNameKey().get());
    }
    if (group.getGroupUUID() != null) {
        byUUID.invalidate(group.getGroupUUID().get());
    }
}
#method_after
@Override
public void evict(final AccountGroup group) throws IOException {
    if (group.getId() != null) {
        byId.invalidate(group.getId());
    }
    if (group.getNameKey() != null) {
        byName.invalidate(group.getNameKey().get());
    }
    if (group.getGroupUUID() != null) {
        byUUID.invalidate(group.getGroupUUID().get());
    }
    indexer.get().index(group.getGroupUUID());
}
#end_block

#method_before
@Override
public void evictAfterRename(final AccountGroup.NameKey oldName, final AccountGroup.NameKey newName) {
    if (oldName != null) {
        byName.invalidate(oldName.get());
    }
    if (newName != null) {
        byName.invalidate(newName.get());
    }
}
#method_after
@Override
public void evictAfterRename(final AccountGroup.NameKey oldName, final AccountGroup.NameKey newName) throws IOException {
    if (oldName != null) {
        byName.invalidate(oldName.get());
    }
    if (newName != null) {
        byName.invalidate(newName.get());
    }
    indexer.get().index(get(newName).getGroupUUID());
}
#end_block

#method_before
@Override
public void onCreateGroup(AccountGroup.NameKey newGroupName) {
    byName.invalidate(newGroupName.get());
}
#method_after
@Override
public void onCreateGroup(AccountGroup.NameKey newGroupName) throws IOException {
    byName.invalidate(newGroupName.get());
    indexer.get().index(get(newGroupName).getGroupUUID());
}
#end_block

#method_before
@Override
public RobotCommentInfo get() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public RobotCommentInfo get() {
    throw new NotImplementedException();
}
#end_block

#method_before
public void delete(ReviewDb db, ChangeUpdate update, PatchSet ps) throws OrmException {
    ensurePatchSetMatches(ps.getId(), update);
    checkArgument(ps.isDraft(), "cannot delete non-draft patch set %s", ps.getId());
    update.setPatchSetState(PatchSetState.DELETED);
    if (PrimaryStorage.of(update.getChange()) == REVIEW_DB) {
        // Avoid OrmConcurrencyException trying to delete non-existent entities.
        db.patchSets().delete(Collections.singleton(ps));
    }
}
#method_after
public void delete(ReviewDb db, ChangeUpdate update, PatchSet ps) throws OrmException {
    ensurePatchSetMatches(ps.getId(), update);
    checkArgument(ps.isDraft(), "cannot delete non-draft patch set %s", ps.getId());
    update.setPatchSetState(PatchSetState.DELETED);
    db.patchSets().delete(Collections.singleton(ps));
}
#end_block

#method_before
void sort() {
    // First pass: sort by natural order.
    PriorityQueue<Event> todo = new PriorityQueue<>(out);
    // Populate waiting map after initial sort to preserve natural order.
    waiting = ArrayListMultimap.create();
    deps = HashMultimap.create();
    for (Event e : todo) {
        for (Event d : e.deps) {
            deps.put(e, d);
            waiting.put(d, e);
        }
    }
    // Second pass: enforce dependencies.
    int size = out.size();
    while (!todo.isEmpty()) {
        process(todo.remove(), todo);
    }
    checkState(sorted.size() == size, "event sort expected %s elements, got %s", size, sorted.size());
    // Modify out in-place a la Collections#sort.
    out.clear();
    out.addAll(sorted);
}
#method_after
void sort() {
    // First pass: sort by natural order.
    PriorityQueue<Event> todo = new PriorityQueue<>(out);
    // Populate waiting map after initial sort to preserve natural order.
    waiting = MultimapBuilder.hashKeys().arrayListValues().build();
    deps = MultimapBuilder.hashKeys().hashSetValues().build();
    for (Event e : todo) {
        for (Event d : e.deps) {
            deps.put(e, d);
            waiting.put(d, e);
        }
    }
    // Second pass: enforce dependencies.
    int size = out.size();
    while (!todo.isEmpty()) {
        process(todo.remove(), todo);
    }
    checkState(sorted.size() == size, "event sort expected %s elements, got %s", size, sorted.size());
    // Modify out in-place a la Collections#sort.
    out.clear();
    out.addAll(sorted);
}
#end_block

#method_before
private DataSource open(final Config cfg, final Context context, final DataSourceType dst) {
    ConfigSection dbs = new ConfigSection(cfg, "database");
    String driver = dbs.optional("driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = dbs.optional("url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = dbs.optional("username");
    String password = dbs.optional("password");
    String interceptor = dbs.optional("dataSourceInterceptorClass");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        int poolLimit = threadSettingsConfig.getDatabasePoolLimit();
        ds.setMaxActive(poolLimit);
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", Math.min(poolLimit, 16)));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        exportPoolMetrics(ds);
        return intercept(interceptor, ds);
    }
    // 
    try {
        final Properties p = new Properties();
        p.setProperty("driver", driver);
        p.setProperty("url", url);
        if (username != null) {
            p.setProperty("user", username);
        }
        if (password != null) {
            p.setProperty("password", password);
        }
        return intercept(interceptor, new SimpleDataSource(p));
    } catch (SQLException se) {
        throw new ProvisionException("Database unavailable", se);
    }
}
#method_after
private DataSource open(final Config cfg, final Context context, final DataSourceType dst) {
    ConfigSection dbs = new ConfigSection(cfg, "database");
    String driver = dbs.optional("driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = dbs.optional("url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = dbs.optional("username");
    String password = dbs.optional("password");
    String interceptor = dbs.optional("dataSourceInterceptorClass");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        int poolLimit = threadSettingsConfig.getDatabasePoolLimit();
        ds.setMaxActive(poolLimit);
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", Math.min(poolLimit, 16)));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        ds.setValidationQuery(dst.getValidationQuery());
        ds.setValidationQueryTimeout(5);
        exportPoolMetrics(ds);
        return intercept(interceptor, ds);
    }
    // 
    try {
        final Properties p = new Properties();
        p.setProperty("driver", driver);
        p.setProperty("url", url);
        if (username != null) {
            p.setProperty("user", username);
        }
        if (password != null) {
            p.setProperty("password", password);
        }
        return intercept(interceptor, new SimpleDataSource(p));
    } catch (SQLException se) {
        throw new ProvisionException("Database unavailable", se);
    }
}
#end_block

#method_before
public static Set<String> getPersonParts(PersonIdent person) {
    if (person == null) {
        return ImmutableSet.of();
    }
    return getPersonParts(person.getName(), Collections.singleton(person.getEmailAddress()));
}
#method_after
public static Set<String> getPersonParts(PersonIdent person) {
    if (person == null) {
        return ImmutableSet.of();
    }
    return getNameParts(person.getName(), Collections.singleton(person.getEmailAddress()));
}
#end_block

#method_before
private void sendAutoIndex(PluginContentScanner scanner, final String prefix, final String pluginName, PluginResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = new ArrayList<>();
    List<PluginEntry> servlets = new ArrayList<>();
    List<PluginEntry> restApis = new ArrayList<>();
    List<PluginEntry> docs = new ArrayList<>();
    PluginEntry about = null;
    Predicate<PluginEntry> filter = entry -> {
        String name = entry.getName();
        Optional<Long> size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent()) {
            if (size.get() <= 0 || size.get() > SMALL_RESOURCE) {
                log.warn(String.format("Plugin %s: %s omitted from document index. " + "Size %d out of range (0,%d).", pluginName, name.substring(prefix.length()), size.get(), SMALL_RESOURCE));
                return false;
            }
            return true;
        }
        return false;
    };
    List<PluginEntry> entries = Collections.list(scanner.entries()).stream().filter(filter).collect(toList());
    for (PluginEntry entry : entries) {
        String name = entry.getName().substring(prefix.length());
        if (name.startsWith("cmd-")) {
            cmds.add(entry);
        } else if (name.startsWith("servlet-")) {
            servlets.add(entry);
        } else if (name.startsWith("rest-api-")) {
            restApis.add(entry);
        } else if (name.startsWith("about.")) {
            if (about == null) {
                about = entry;
            } else {
                log.warn(String.format("Plugin %s: Multiple 'about' documents found; using %s", pluginName, about.getName().substring(prefix.length())));
            }
        } else {
            docs.add(entry);
        }
    }
    Collections.sort(cmds, PluginEntry.COMPARATOR_BY_NAME);
    Collections.sort(docs, PluginEntry.COMPARATOR_BY_NAME);
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about));
        StringBuilder aboutContent = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(isr)) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) {
                    aboutContent.append("\n");
                } else {
                    aboutContent.append(line).append("\n");
                }
            }
        }
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#method_after
private void sendAutoIndex(PluginContentScanner scanner, final String prefix, final String pluginName, PluginResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = new ArrayList<>();
    List<PluginEntry> servlets = new ArrayList<>();
    List<PluginEntry> restApis = new ArrayList<>();
    List<PluginEntry> docs = new ArrayList<>();
    PluginEntry about = null;
    Predicate<PluginEntry> filter = entry -> {
        String name = entry.getName();
        Optional<Long> size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent()) {
            if (size.get() <= 0 || size.get() > SMALL_RESOURCE) {
                log.warn(String.format("Plugin %s: %s omitted from document index. " + "Size %d out of range (0,%d).", pluginName, name.substring(prefix.length()), size.get(), SMALL_RESOURCE));
                return false;
            }
            return true;
        }
        return false;
    };
    List<PluginEntry> entries = Collections.list(scanner.entries()).stream().filter(filter).collect(toList());
    for (PluginEntry entry : entries) {
        String name = entry.getName().substring(prefix.length());
        if (name.startsWith("cmd-")) {
            cmds.add(entry);
        } else if (name.startsWith("servlet-")) {
            servlets.add(entry);
        } else if (name.startsWith("rest-api-")) {
            restApis.add(entry);
        } else if (name.startsWith("about.")) {
            if (about == null) {
                about = entry;
            } else {
                log.warn(String.format("Plugin %s: Multiple 'about' documents found; using %s", pluginName, about.getName().substring(prefix.length())));
            }
        } else {
            docs.add(entry);
        }
    }
    Collections.sort(cmds, PluginEntry.COMPARATOR_BY_NAME);
    Collections.sort(docs, PluginEntry.COMPARATOR_BY_NAME);
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about), UTF_8);
        StringBuilder aboutContent = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(isr)) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) {
                    aboutContent.append("\n");
                } else {
                    aboutContent.append(line).append("\n");
                }
            }
        }
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#end_block

#method_before
@Override
public Response<?> apply(TaskResource rsrc, Input input) {
    rsrc.getTask().cancel(true);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(TaskResource rsrc, Input input) {
    Task<?> task = rsrc.getTask();
    boolean taskDeleted = task.cancel(true);
    return taskDeleted ? Response.none() : Response.withStatusCode(SC_INTERNAL_SERVER_ERROR, "Unable to kill task " + task);
}
#end_block

#method_before
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (psDescription != null) {
        addFooter(msg, FOOTER_PATCH_SET_DESCRIPTION, psDescription);
    }
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        msg.append(": ");
                        addIdent(msg, label.appliedBy);
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(accountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#method_after
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (currentPatchSet) {
        addFooter(msg, FOOTER_CURRENT, Boolean.TRUE);
    }
    if (psDescription != null) {
        addFooter(msg, FOOTER_PATCH_SET_DESCRIPTION, psDescription);
    }
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        msg.append(": ");
                        addIdent(msg, label.appliedBy);
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(accountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#end_block

#method_before
@Override
public boolean isEmpty() {
    return commitSubject == null && approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && changeId == null && branch == null && status == null && submissionId == null && submitRecords == null && assignee == null && hashtags == null && topic == null && commit == null && psState == null && groups == null && tag == null && psDescription == null;
}
#method_after
@Override
public boolean isEmpty() {
    return commitSubject == null && approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && changeId == null && branch == null && status == null && submissionId == null && submitRecords == null && assignee == null && hashtags == null && topic == null && commit == null && psState == null && groups == null && tag == null && psDescription == null && !currentPatchSet;
}
#end_block

#method_before
private ChangeInfo assertCreateSucceeds(ChangeInput in) throws Exception {
    ChangeInfo out = gApi.changes().create(in).get();
    assertThat(out.branch).isEqualTo(in.branch);
    assertThat(out.subject).isEqualTo(in.subject);
    assertThat(out.topic).isEqualTo(in.topic);
    assertThat(out.status).isEqualTo(in.status);
    assertThat(out.revisions).hasSize(1);
    assertThat(out.submitted).isNull();
    Boolean draft = Iterables.getOnlyElement(out.revisions.values()).draft;
    assertThat(booleanToDraftStatus(draft)).isEqualTo(in.status);
    return out;
}
#method_after
private ChangeInfo assertCreateSucceeds(ChangeInput in) throws Exception {
    ChangeInfo out = gApi.changes().create(in).get();
    assertThat(out.project).isEqualTo(in.project);
    assertThat(out.branch).isEqualTo(in.branch);
    assertThat(out.subject).isEqualTo(in.subject);
    assertThat(out.topic).isEqualTo(in.topic);
    assertThat(out.status).isEqualTo(in.status);
    assertThat(out.revisions).hasSize(1);
    assertThat(out.submitted).isNull();
    Boolean draft = Iterables.getOnlyElement(out.revisions.values()).draft;
    assertThat(booleanToDraftStatus(draft)).isEqualTo(in.status);
    return out;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    site = new SitePaths(TempFileUtil.createTempDirectory().toPath());
    site.resolve("git").toFile().mkdir();
    cfg = new Config();
    cfg.setString("gerrit", null, "basePath", "git");
    repoManager = new LocalDiskRepositoryManager(site, cfg);
    repoManager.start();
}
#method_after
@Before
public void setUp() throws Exception {
    site = new SitePaths(TempFileUtil.createTempDirectory().toPath());
    site.resolve("git").toFile().mkdir();
    cfg = new Config();
    cfg.setString("gerrit", null, "basePath", "git");
    repoManager = new LocalDiskRepositoryManager(site, cfg);
}
#end_block

#method_before
@Override
public Map<String, Short> votes() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, Short> votes() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void deleteVote(String label) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void deleteVote(String label) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void deleteVote(DeleteVoteInput input) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void deleteVote(DeleteVoteInput input) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void remove() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void remove() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void remove(DeleteReviewerInput input) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void remove(DeleteReviewerInput input) {
    throw new NotImplementedException();
}
#end_block

#method_before
private Multimap<String, ?> extractParameters(DispatchCommand dcmd) {
    if (dcmd == null) {
        return ArrayListMultimap.create(0, 0);
    }
    String[] cmdArgs = dcmd.getArguments();
    String paramName = null;
    int argPos = 0;
    Multimap<String, String> parms = ArrayListMultimap.create();
    for (int i = 2; i < cmdArgs.length; i++) {
        String arg = cmdArgs[i];
        // -- stop parameters parsing
        if (arg.equals("--")) {
            for (i++; i < cmdArgs.length; i++) {
                parms.put("$" + argPos++, cmdArgs[i]);
            }
            break;
        }
        // --param=value
        int eqPos = arg.indexOf('=');
        if (arg.startsWith("--") && eqPos > 0) {
            parms.put(arg.substring(0, eqPos), arg.substring(eqPos + 1));
            continue;
        }
        // -p value or --param value
        if (arg.startsWith("-")) {
            if (paramName != null) {
                parms.put(paramName, null);
            }
            paramName = arg;
            continue;
        }
        // value
        if (paramName == null) {
            parms.put("$" + argPos++, arg);
        } else {
            parms.put(paramName, arg);
            paramName = null;
        }
    }
    if (paramName != null) {
        parms.put(paramName, null);
    }
    return parms;
}
#method_after
private ListMultimap<String, ?> extractParameters(DispatchCommand dcmd) {
    if (dcmd == null) {
        return MultimapBuilder.hashKeys(0).arrayListValues(0).build();
    }
    String[] cmdArgs = dcmd.getArguments();
    String paramName = null;
    int argPos = 0;
    ListMultimap<String, String> parms = MultimapBuilder.hashKeys().arrayListValues().build();
    for (int i = 2; i < cmdArgs.length; i++) {
        String arg = cmdArgs[i];
        // -- stop parameters parsing
        if (arg.equals("--")) {
            for (i++; i < cmdArgs.length; i++) {
                parms.put("$" + argPos++, cmdArgs[i]);
            }
            break;
        }
        // --param=value
        int eqPos = arg.indexOf('=');
        if (arg.startsWith("--") && eqPos > 0) {
            parms.put(arg.substring(0, eqPos), arg.substring(eqPos + 1));
            continue;
        }
        // -p value or --param value
        if (arg.startsWith("-")) {
            if (paramName != null) {
                parms.put(paramName, null);
            }
            paramName = arg;
            continue;
        }
        // value
        if (paramName == null) {
            parms.put("$" + argPos++, arg);
        } else {
            parms.put(paramName, arg);
            paramName = null;
        }
    }
    if (paramName != null) {
        parms.put(paramName, null);
    }
    return parms;
}
#end_block

#method_before
private void audit(Context ctx, Object result, String cmd, Multimap<String, ?> params) {
    String sessionId;
    CurrentUser currentUser;
    long created;
    if (ctx == null) {
        sessionId = null;
        currentUser = null;
        created = TimeUtil.nowMs();
    } else {
        SshSession session = ctx.getSession();
        sessionId = IdGenerator.format(session.getSessionId());
        currentUser = session.getUser();
        created = ctx.created;
    }
    auditService.dispatch(new SshAuditEvent(sessionId, currentUser, cmd, created, params, result));
}
#method_after
private void audit(Context ctx, Object result, String cmd, ListMultimap<String, ?> params) {
    String sessionId;
    CurrentUser currentUser;
    long created;
    if (ctx == null) {
        sessionId = null;
        currentUser = null;
        created = TimeUtil.nowMs();
    } else {
        SshSession session = ctx.getSession();
        sessionId = IdGenerator.format(session.getSessionId());
        currentUser = session.getUser();
        created = ctx.created;
    }
    auditService.dispatch(new SshAuditEvent(sessionId, currentUser, cmd, created, params, result));
}
#end_block

#method_before
private Map<Account.Id, MutableDouble> baseRankingForEmptyQuery(double baseWeight) throws OrmException {
    // Get the user's last 50 changes, check approvals
    try {
        List<ChangeData> result = internalChangeQuery.setLimit(50).setRequestedFields(ImmutableSet.of(ChangeField.REVIEWER.getName())).query(changeQueryBuilder.owner("self"));
        Map<Account.Id, MutableDouble> suggestions = new HashMap<>();
        for (ChangeData cd : result) {
            for (PatchSetApproval approval : cd.currentApprovals()) {
                Account.Id id = approval.getAccountId();
                if (suggestions.containsKey(id)) {
                    suggestions.get(id).add(baseWeight);
                } else {
                    suggestions.put(id, new MutableDouble(baseWeight));
                }
            }
        }
        return suggestions;
    } catch (QueryParseException e) {
        // Unhandled, because owner:self will never provoke a QueryParseException
        log.error("Exception while suggesting reviewers", e);
        return ImmutableMap.of();
    }
}
#method_after
private Map<Account.Id, MutableDouble> baseRankingForEmptyQuery(double baseWeight) throws OrmException {
    // Get the user's last 25 changes, check approvals
    try {
        List<ChangeData> result = internalChangeQuery.setLimit(25).setRequestedFields(ImmutableSet.of(ChangeField.REVIEWER.getName())).query(changeQueryBuilder.owner("self"));
        Map<Account.Id, MutableDouble> suggestions = new HashMap<>();
        for (ChangeData cd : result) {
            for (PatchSetApproval approval : cd.currentApprovals()) {
                Account.Id id = approval.getAccountId();
                if (suggestions.containsKey(id)) {
                    suggestions.get(id).add(baseWeight);
                } else {
                    suggestions.put(id, new MutableDouble(baseWeight));
                }
            }
        }
        return suggestions;
    } catch (QueryParseException e) {
        // Unhandled, because owner:self will never provoke a QueryParseException
        log.error("Exception while suggesting reviewers", e);
        return ImmutableMap.of();
    }
}
#end_block

#method_before
private Map<Account.Id, MutableDouble> baseRankingForCandidateList(List<Account.Id> candidates, ProjectControl projectControl, double baseWeight) throws OrmException {
    // Get each reviewer's activity based on number of applied labels
    // (weighted 10d), number of comments (weighted 0.5d) and number of owned
    // changes (weighted 1d).
    Map<Account.Id, MutableDouble> reviewers = new LinkedHashMap<>();
    if (candidates.size() == 0) {
        return reviewers;
    }
    List<Predicate<ChangeData>> predicates = new ArrayList<>();
    for (Account.Id id : candidates) {
        try {
            Predicate<ChangeData> projectQuery = changeQueryBuilder.project(projectControl.getProject().getName());
            // Get all labels for this project and create a compound OR query to
            // fetch all changes where users have applied one of these labels
            List<LabelType> labelTypes = projectControl.getLabelTypes().getLabelTypes();
            List<Predicate<ChangeData>> labelPredicates = new ArrayList<>(labelTypes.size());
            for (LabelType type : labelTypes) {
                labelPredicates.add(changeQueryBuilder.label(type.getName() + ",user=" + id));
            }
            Predicate<ChangeData> reviewerQuery = Predicate.and(projectQuery, Predicate.or(labelPredicates));
            Predicate<ChangeData> ownerQuery = Predicate.and(projectQuery, changeQueryBuilder.owner(id.toString()));
            Predicate<ChangeData> commentedByQuery = Predicate.and(projectQuery, changeQueryBuilder.commentby(id.toString()));
            predicates.add(reviewerQuery);
            predicates.add(ownerQuery);
            predicates.add(commentedByQuery);
            reviewers.put(id, new MutableDouble());
        } catch (QueryParseException e) {
            // Unhandled: If an exception is thrown, we won't increase the
            // candidates's score
            log.error("Exception while suggesting reviewers", e);
        }
    }
    List<List<ChangeData>> result = internalChangeQuery.setLimit(100 * predicates.size()).setRequestedFields(ImmutableSet.of()).query(predicates);
    Iterator<List<ChangeData>> queryResultIterator = result.iterator();
    Iterator<Account.Id> reviewersIterator = reviewers.keySet().iterator();
    int i = 0;
    Account.Id currentId = null;
    while (queryResultIterator.hasNext()) {
        List<ChangeData> currentResult = queryResultIterator.next();
        if (i % WEIGHTS.length == 0) {
            currentId = reviewersIterator.next();
        }
        reviewers.get(currentId).add(WEIGHTS[i % WEIGHTS.length] * baseWeight * currentResult.size());
        i++;
    }
    return reviewers;
}
#method_after
private Map<Account.Id, MutableDouble> baseRankingForCandidateList(List<Account.Id> candidates, ProjectControl projectControl, double baseWeight) throws OrmException {
    // Get each reviewer's activity based on number of applied labels
    // (weighted 10d), number of comments (weighted 0.5d) and number of owned
    // changes (weighted 1d).
    Map<Account.Id, MutableDouble> reviewers = new LinkedHashMap<>();
    if (candidates.size() == 0) {
        return reviewers;
    }
    List<Predicate<ChangeData>> predicates = new ArrayList<>();
    for (Account.Id id : candidates) {
        try {
            Predicate<ChangeData> projectQuery = changeQueryBuilder.project(projectControl.getProject().getName());
            // Get all labels for this project and create a compound OR query to
            // fetch all changes where users have applied one of these labels
            List<LabelType> labelTypes = projectControl.getLabelTypes().getLabelTypes();
            List<Predicate<ChangeData>> labelPredicates = new ArrayList<>(labelTypes.size());
            for (LabelType type : labelTypes) {
                labelPredicates.add(changeQueryBuilder.label(type.getName() + ",user=" + id));
            }
            Predicate<ChangeData> reviewerQuery = Predicate.and(projectQuery, Predicate.or(labelPredicates));
            Predicate<ChangeData> ownerQuery = Predicate.and(projectQuery, changeQueryBuilder.owner(id.toString()));
            Predicate<ChangeData> commentedByQuery = Predicate.and(projectQuery, changeQueryBuilder.commentby(id.toString()));
            predicates.add(reviewerQuery);
            predicates.add(ownerQuery);
            predicates.add(commentedByQuery);
            reviewers.put(id, new MutableDouble());
        } catch (QueryParseException e) {
            // Unhandled: If an exception is thrown, we won't increase the
            // candidates's score
            log.error("Exception while suggesting reviewers", e);
        }
    }
    List<List<ChangeData>> result = internalChangeQuery.setLimit(25).setRequestedFields(ImmutableSet.of()).query(predicates);
    Iterator<List<ChangeData>> queryResultIterator = result.iterator();
    Iterator<Account.Id> reviewersIterator = reviewers.keySet().iterator();
    int i = 0;
    Account.Id currentId = null;
    while (queryResultIterator.hasNext()) {
        List<ChangeData> currentResult = queryResultIterator.next();
        if (i % WEIGHTS.length == 0) {
            currentId = reviewersIterator.next();
        }
        reviewers.get(currentId).add(WEIGHTS[i % WEIGHTS.length] * baseWeight * currentResult.size());
        i++;
    }
    return reviewers;
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> has(String value) throws QueryParseException {
    if ("star".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("stars".equalsIgnoreCase(value)) {
        return new HasStarsPredicate(self());
    }
    if ("draft".equalsIgnoreCase(value)) {
        return draftby(self());
    }
    if ("edit".equalsIgnoreCase(value)) {
        return new EditByPredicate(self());
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> has(String value) throws QueryParseException {
    if ("star".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("stars".equalsIgnoreCase(value)) {
        return new HasStarsPredicate(self());
    }
    if ("draft".equalsIgnoreCase(value)) {
        return draftby(self());
    }
    if ("edit".equalsIgnoreCase(value)) {
        return new EditByPredicate(self());
    }
    // for plugins the value will be operandName_pluginName
    String[] names = value.split("_");
    if (names.length == 2) {
        ChangeHasOperandFactory op = args.hasOperands.get(names[1], names[0]);
        if (op != null) {
            return op.create(this);
        }
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Test
public void postComment() throws Exception {
    for (Integer line : lines) {
        String file = "file";
        String contents = "contents " + line;
        PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "first subject", file, contents);
        PushOneCommit.Result r = push.to("refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        CommentInput comment = newComment(file, Side.REVISION, line, "comment 1");
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        assertThat(comment).isEqualTo(infoToInput(file).apply(actual));
        assertThat(comment).isEqualTo(infoToInput(file).apply(getPublishedComment(changeId, revId, actual.id)));
    }
}
#method_after
@Test
public void postComment() throws Exception {
    for (Integer line : lines) {
        String file = "file";
        String contents = "contents " + line;
        PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "first subject", file, contents);
        PushOneCommit.Result r = push.to("refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        CommentInput comment = newComment(file, Side.REVISION, line, "comment 1", false);
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        assertThat(comment).isEqualTo(infoToInput(file).apply(actual));
        assertThat(comment).isEqualTo(infoToInput(file).apply(getPublishedComment(changeId, revId, actual.id)));
    }
}
#end_block

#method_before
@Test
public void postCommentOnMergeCommitChange() throws Exception {
    for (Integer line : lines) {
        String file = "foo";
        PushOneCommit.Result r = createMergeCommitChange("refs/for/master", file);
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        CommentInput c1 = newComment(file, Side.REVISION, line, "ps-1");
        CommentInput c2 = newComment(file, Side.PARENT, line, "auto-merge of ps-1");
        CommentInput c3 = newCommentOnParent(file, 1, line, "parent-1 of ps-1");
        CommentInput c4 = newCommentOnParent(file, 2, line, "parent-2 of ps-1");
        input.comments = new HashMap<>();
        input.comments.put(file, ImmutableList.of(c1, c2, c3, c4));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        assertThat(Lists.transform(result.get(file), infoToInput(file))).containsExactly(c1, c2, c3, c4);
    }
    // for the commit message comments on the auto-merge are not possible
    for (Integer line : lines) {
        String file = Patch.COMMIT_MSG;
        PushOneCommit.Result r = createMergeCommitChange("refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        CommentInput c1 = newComment(file, Side.REVISION, line, "ps-1");
        CommentInput c2 = newCommentOnParent(file, 1, line, "parent-1 of ps-1");
        CommentInput c3 = newCommentOnParent(file, 2, line, "parent-2 of ps-1");
        input.comments = new HashMap<>();
        input.comments.put(file, ImmutableList.of(c1, c2, c3));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        assertThat(Lists.transform(result.get(file), infoToInput(file))).containsExactly(c1, c2, c3);
    }
}
#method_after
@Test
public void postCommentOnMergeCommitChange() throws Exception {
    for (Integer line : lines) {
        String file = "foo";
        PushOneCommit.Result r = createMergeCommitChange("refs/for/master", file);
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        CommentInput c1 = newComment(file, Side.REVISION, line, "ps-1", false);
        CommentInput c2 = newComment(file, Side.PARENT, line, "auto-merge of ps-1", false);
        CommentInput c3 = newCommentOnParent(file, 1, line, "parent-1 of ps-1");
        CommentInput c4 = newCommentOnParent(file, 2, line, "parent-2 of ps-1");
        input.comments = new HashMap<>();
        input.comments.put(file, ImmutableList.of(c1, c2, c3, c4));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        assertThat(Lists.transform(result.get(file), infoToInput(file))).containsExactly(c1, c2, c3, c4);
    }
    // for the commit message comments on the auto-merge are not possible
    for (Integer line : lines) {
        String file = Patch.COMMIT_MSG;
        PushOneCommit.Result r = createMergeCommitChange("refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        CommentInput c1 = newComment(file, Side.REVISION, line, "ps-1", false);
        CommentInput c2 = newCommentOnParent(file, 1, line, "parent-1 of ps-1");
        CommentInput c3 = newCommentOnParent(file, 2, line, "parent-2 of ps-1");
        input.comments = new HashMap<>();
        input.comments.put(file, ImmutableList.of(c1, c2, c3));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        assertThat(Lists.transform(result.get(file), infoToInput(file))).containsExactly(c1, c2, c3);
    }
}
#end_block

#method_before
@Test
public void postCommentOnCommitMessageOnAutoMerge() throws Exception {
    PushOneCommit.Result r = createMergeCommitChange("refs/for/master");
    ReviewInput input = new ReviewInput();
    CommentInput c = newComment(Patch.COMMIT_MSG, Side.PARENT, 0, "comment on auto-merge");
    input.comments = new HashMap<>();
    input.comments.put(Patch.COMMIT_MSG, ImmutableList.of(c));
    exception.expect(BadRequestException.class);
    exception.expectMessage("cannot comment on " + Patch.COMMIT_MSG + " on auto-merge");
    revision(r).review(input);
}
#method_after
@Test
public void postCommentOnCommitMessageOnAutoMerge() throws Exception {
    PushOneCommit.Result r = createMergeCommitChange("refs/for/master");
    ReviewInput input = new ReviewInput();
    CommentInput c = newComment(Patch.COMMIT_MSG, Side.PARENT, 0, "comment on auto-merge", false);
    input.comments = new HashMap<>();
    input.comments.put(Patch.COMMIT_MSG, ImmutableList.of(c));
    exception.expect(BadRequestException.class);
    exception.expectMessage("cannot comment on " + Patch.COMMIT_MSG + " on auto-merge");
    revision(r).review(input);
}
#end_block

#method_before
@Test
public void listComments() throws Exception {
    String file = "file";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "first subject", file, "contents");
    PushOneCommit.Result r = push.to("refs/for/master");
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    assertThat(getPublishedComments(changeId, revId)).isEmpty();
    List<CommentInput> expectedComments = new ArrayList<>();
    for (Integer line : lines) {
        ReviewInput input = new ReviewInput();
        CommentInput comment = newComment(file, Side.REVISION, line, "comment " + line);
        expectedComments.add(comment);
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        revision(r).review(input);
    }
    Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
    assertThat(result).isNotEmpty();
    List<CommentInfo> actualComments = result.get(file);
    assertThat(Lists.transform(actualComments, infoToInput(file))).containsExactlyElementsIn(expectedComments);
}
#method_after
@Test
public void listComments() throws Exception {
    String file = "file";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "first subject", file, "contents");
    PushOneCommit.Result r = push.to("refs/for/master");
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    assertThat(getPublishedComments(changeId, revId)).isEmpty();
    List<CommentInput> expectedComments = new ArrayList<>();
    for (Integer line : lines) {
        ReviewInput input = new ReviewInput();
        CommentInput comment = newComment(file, Side.REVISION, line, "comment " + line, false);
        expectedComments.add(comment);
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        revision(r).review(input);
    }
    Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
    assertThat(result).isNotEmpty();
    List<CommentInfo> actualComments = result.get(file);
    assertThat(Lists.transform(actualComments, infoToInput(file))).containsExactlyElementsIn(expectedComments);
}
#end_block

#method_before
@Test
public void insertCommentsWithHistoricTimestamp() throws Exception {
    Timestamp timestamp = new Timestamp(0);
    for (Integer line : lines) {
        String file = "file";
        String contents = "contents " + line;
        PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "first subject", file, contents);
        PushOneCommit.Result r = push.to("refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        Timestamp origLastUpdated = r.getChange().change().getLastUpdatedOn();
        ReviewInput input = new ReviewInput();
        CommentInput comment = newComment(file, Side.REVISION, line, "comment 1");
        comment.updated = timestamp;
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        ChangeResource changeRsrc = changes.get().parse(TopLevelResource.INSTANCE, IdString.fromDecoded(changeId));
        RevisionResource revRsrc = revisions.parse(changeRsrc, IdString.fromDecoded(revId));
        postReview.get().apply(revRsrc, input, timestamp);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        CommentInput ci = infoToInput(file).apply(actual);
        ci.updated = comment.updated;
        assertThat(comment).isEqualTo(ci);
        assertThat(actual.updated).isEqualTo(gApi.changes().id(r.getChangeId()).info().created);
        // Updating historic comments doesn't cause lastUpdatedOn to regress.
        assertThat(r.getChange().change().getLastUpdatedOn()).isEqualTo(origLastUpdated);
    }
}
#method_after
@Test
public void insertCommentsWithHistoricTimestamp() throws Exception {
    Timestamp timestamp = new Timestamp(0);
    for (Integer line : lines) {
        String file = "file";
        String contents = "contents " + line;
        PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "first subject", file, contents);
        PushOneCommit.Result r = push.to("refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        Timestamp origLastUpdated = r.getChange().change().getLastUpdatedOn();
        ReviewInput input = new ReviewInput();
        CommentInput comment = newComment(file, Side.REVISION, line, "comment 1", false);
        comment.updated = timestamp;
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        ChangeResource changeRsrc = changes.get().parse(TopLevelResource.INSTANCE, IdString.fromDecoded(changeId));
        RevisionResource revRsrc = revisions.parse(changeRsrc, IdString.fromDecoded(revId));
        postReview.get().apply(revRsrc, input, timestamp);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        CommentInput ci = infoToInput(file).apply(actual);
        ci.updated = comment.updated;
        assertThat(comment).isEqualTo(ci);
        assertThat(actual.updated).isEqualTo(gApi.changes().id(r.getChangeId()).info().created);
        // Updating historic comments doesn't cause lastUpdatedOn to regress.
        assertThat(r.getChange().change().getLastUpdatedOn()).isEqualTo(origLastUpdated);
    }
}
#end_block

#method_before
@Test
public void publishCommentsAllRevisions() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new\ncntent\n", r1.getChangeId()).to("refs/for/master");
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "nit: trailing whitespace"));
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "what happened to this?"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "join lines"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "typo: content"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 1, "comment 1 on base"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "comment 2 on base"));
    PushOneCommit.Result other = createChange();
    // Drafts on other changes aren't returned.
    addDraft(other.getChangeId(), other.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "unrelated comment"));
    setApiUser(admin);
    // Drafts by other users aren't returned.
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "oops"));
    setApiUser(user);
    ReviewInput reviewInput = new ReviewInput();
    reviewInput.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    reviewInput.message = "comments";
    gApi.changes().id(r2.getChangeId()).current().review(reviewInput);
    assertThat(gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps1Map = gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).comments();
    assertThat(ps1Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps1List = ps1Map.get(FILE_NAME);
    assertThat(ps1List).hasSize(2);
    assertThat(ps1List.get(0).message).isEqualTo("what happened to this?");
    assertThat(ps1List.get(0).side).isEqualTo(Side.PARENT);
    assertThat(ps1List.get(1).message).isEqualTo("nit: trailing whitespace");
    assertThat(ps1List.get(1).side).isNull();
    assertThat(gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps2Map = gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).comments();
    assertThat(ps2Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps2List = ps2Map.get(FILE_NAME);
    assertThat(ps2List).hasSize(4);
    assertThat(ps2List.get(0).message).isEqualTo("comment 1 on base");
    assertThat(ps2List.get(1).message).isEqualTo("comment 2 on base");
    assertThat(ps2List.get(2).message).isEqualTo("join lines");
    assertThat(ps2List.get(3).message).isEqualTo("typo: content");
    List<Message> messages = email.getMessages(r2.getChangeId(), "comment");
    assertThat(messages).hasSize(1);
    String url = canonicalWebUrl.get();
    int c = r1.getChange().getId().get();
    assertThat(extractComments(messages.get(0).body())).isEqualTo("Patch Set 2:\n" + "\n" + "(6 comments)\n" + "\n" + "comments\n" + "\n" + url + "#/c/" + c + "/1/a.txt\n" + "File a.txt:\n" + "\n" + url + "#/c/12/1/a.txt@a2\n" + "PS1, Line 2: \n" + "what happened to this?\n" + "\n" + "\n" + url + "#/c/12/1/a.txt@1\n" + "PS1, Line 1: ew\n" + "nit: trailing whitespace\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt\n" + "File a.txt:\n" + "\n" + url + "#/c/12/2/a.txt@a1\n" + "PS2, Line 1: \n" + "comment 1 on base\n" + "\n" + "\n" + url + "#/c/12/2/a.txt@a2\n" + "PS2, Line 2: \n" + "comment 2 on base\n" + "\n" + "\n" + url + "#/c/12/2/a.txt@1\n" + "PS2, Line 1: ew\n" + "join lines\n" + "\n" + "\n" + url + "#/c/12/2/a.txt@2\n" + "PS2, Line 2: nten\n" + "typo: content\n" + "\n" + "\n");
}
#method_after
@Test
public void publishCommentsAllRevisions() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new\ncntent\n", r1.getChangeId()).to("refs/for/master");
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "nit: trailing whitespace"));
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "what happened to this?"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "join lines"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "typo: content"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 1, "comment 1 on base"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "comment 2 on base"));
    PushOneCommit.Result other = createChange();
    // Drafts on other changes aren't returned.
    addDraft(other.getChangeId(), other.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "unrelated comment"));
    setApiUser(admin);
    // Drafts by other users aren't returned.
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "oops"));
    setApiUser(user);
    ReviewInput reviewInput = new ReviewInput();
    reviewInput.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    reviewInput.message = "comments";
    gApi.changes().id(r2.getChangeId()).current().review(reviewInput);
    assertThat(gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps1Map = gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).comments();
    assertThat(ps1Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps1List = ps1Map.get(FILE_NAME);
    assertThat(ps1List).hasSize(2);
    assertThat(ps1List.get(0).message).isEqualTo("what happened to this?");
    assertThat(ps1List.get(0).side).isEqualTo(Side.PARENT);
    assertThat(ps1List.get(1).message).isEqualTo("nit: trailing whitespace");
    assertThat(ps1List.get(1).side).isNull();
    assertThat(gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps2Map = gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).comments();
    assertThat(ps2Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps2List = ps2Map.get(FILE_NAME);
    assertThat(ps2List).hasSize(4);
    assertThat(ps2List.get(0).message).isEqualTo("comment 1 on base");
    assertThat(ps2List.get(1).message).isEqualTo("comment 2 on base");
    assertThat(ps2List.get(2).message).isEqualTo("join lines");
    assertThat(ps2List.get(3).message).isEqualTo("typo: content");
    List<Message> messages = email.getMessages(r2.getChangeId(), "comment");
    assertThat(messages).hasSize(1);
    String url = canonicalWebUrl.get();
    int c = r1.getChange().getId().get();
    assertThat(extractComments(messages.get(0).body())).isEqualTo("Patch Set 2:\n" + "\n" + "(6 comments)\n" + "\n" + "comments\n" + "\n" + url + "#/c/" + c + "/1/a.txt\n" + "File a.txt:\n" + "\n" + url + "#/c/" + c + "/1/a.txt@a2\n" + "PS1, Line 2: \n" + "what happened to this?\n" + "\n" + "\n" + url + "#/c/" + c + "/1/a.txt@1\n" + "PS1, Line 1: ew\n" + "nit: trailing whitespace\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt\n" + "File a.txt:\n" + "\n" + url + "#/c/" + c + "/2/a.txt@a1\n" + "PS2, Line 1: \n" + "comment 1 on base\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt@a2\n" + "PS2, Line 2: \n" + "comment 2 on base\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt@1\n" + "PS2, Line 1: ew\n" + "join lines\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt@2\n" + "PS2, Line 2: nten\n" + "typo: content\n" + "\n" + "\n");
}
#end_block

#method_before
private static CommentInput newComment(String path, Side side, int line, String message) {
    CommentInput c = new CommentInput();
    return populate(c, path, side, null, line, message);
}
#method_after
private static CommentInput newComment(String path, Side side, int line, String message, Boolean unresolved) {
    CommentInput c = new CommentInput();
    return populate(c, path, side, null, line, message, unresolved);
}
#end_block

#method_before
private static CommentInput newCommentOnParent(String path, int parent, int line, String message) {
    CommentInput c = new CommentInput();
    return populate(c, path, Side.PARENT, Integer.valueOf(parent), line, message);
}
#method_after
private static CommentInput newCommentOnParent(String path, int parent, int line, String message) {
    CommentInput c = new CommentInput();
    return populate(c, path, Side.PARENT, Integer.valueOf(parent), line, message, false);
}
#end_block

#method_before
private DraftInput newDraft(String path, Side side, int line, String message) {
    DraftInput d = new DraftInput();
    return populate(d, path, side, null, line, message);
}
#method_after
private DraftInput newDraft(String path, Side side, int line, String message) {
    DraftInput d = new DraftInput();
    return populate(d, path, side, null, line, message, false);
}
#end_block

#method_before
private DraftInput newDraftOnParent(String path, int parent, int line, String message) {
    DraftInput d = new DraftInput();
    return populate(d, path, Side.PARENT, Integer.valueOf(parent), line, message);
}
#method_after
private DraftInput newDraftOnParent(String path, int parent, int line, String message) {
    DraftInput d = new DraftInput();
    return populate(d, path, Side.PARENT, Integer.valueOf(parent), line, message, false);
}
#end_block

#method_before
private static <C extends Comment> C populate(C c, String path, Side side, Integer parent, int line, String message) {
    c.path = path;
    c.side = side;
    c.parent = parent;
    c.line = line != 0 ? line : null;
    c.message = message;
    if (line != 0) {
        Comment.Range range = new Comment.Range();
        range.startLine = line;
        range.startCharacter = 1;
        range.endLine = line;
        range.endCharacter = 5;
        c.range = range;
    }
    return c;
}
#method_after
private static <C extends Comment> C populate(C c, String path, Side side, Integer parent, int line, String message, Boolean unresolved) {
    c.path = path;
    c.side = side;
    c.parent = parent;
    c.line = line != 0 ? line : null;
    c.message = message;
    c.unresolved = unresolved;
    if (line != 0) {
        Comment.Range range = new Comment.Range();
        range.startLine = line;
        range.startCharacter = 1;
        range.endLine = line;
        range.endCharacter = 5;
        c.range = range;
    }
    return c;
}
#end_block

#method_before
private static void copy(Comment from, Comment to) {
    to.side = from.side == null ? Side.REVISION : from.side;
    to.parent = from.parent;
    to.line = from.line;
    to.message = from.message;
    to.range = from.range;
}
#method_after
private static void copy(Comment from, Comment to) {
    to.side = from.side == null ? Side.REVISION : from.side;
    to.parent = from.parent;
    to.line = from.line;
    to.message = from.message;
    to.range = from.range;
    to.unresolved = from.unresolved;
    to.inReplyTo = from.inReplyTo;
}
#end_block

#method_before
@Override
public long getDateHeader(String name) {
    String v = getHeader(name);
    return v != null ? DateUtils.parseDate(v).getTime() : 0;
}
#method_after
@Override
public long getDateHeader(String name) {
    String v = getHeader(name);
    return v == null ? 0 : rfcDateformatter.parse(v, Instant::from).getEpochSecond();
}
#end_block

#method_before
@Override
public Result rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = ReviewDbUtil.unwrapDb(db);
    // Read change just to get project; this instance is then discarded so we
    // can read a consistent ChangeBundle inside a transaction.
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    try (NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject())) {
        buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
        return execute(db, changeId, manager);
    }
}
#method_after
@Override
public Result rebuild(ReviewDb db, Change.Id changeId) throws IOException, OrmException {
    return rebuild(db, changeId, true);
}
#end_block

#method_before
@Override
public Result rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    buildUpdates(manager, bundle);
    return manager.stageAndApplyDelta(change);
}
#method_after
private Result rebuild(ReviewDb db, Change.Id changeId, boolean checkReadOnly) throws IOException, OrmException {
    db = ReviewDbUtil.unwrapDb(db);
    // Read change just to get project; this instance is then discarded so we
    // can read a consistent ChangeBundle inside a transaction.
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    try (NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject())) {
        buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
        return execute(db, changeId, manager, checkReadOnly);
    }
}
#end_block

#method_before
@Override
public Result rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    buildUpdates(manager, bundle);
    return manager.stageAndApplyDelta(change);
}
#method_after
@Override
public Result rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) throws NoSuchChangeException, IOException, OrmException {
    Change change = new Change(bundle.getChange());
    buildUpdates(manager, bundle);
    return manager.stageAndApplyDelta(change);
}
#end_block

#method_before
@Override
public NoteDbUpdateManager stage(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = checkNoteDbState(ChangeNotes.readOneReviewDbChange(db, changeId));
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
    manager.stage();
    return manager;
}
#method_after
@Override
public NoteDbUpdateManager stage(ReviewDb db, Change.Id changeId) throws IOException, OrmException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = checkNoteDbState(ChangeNotes.readOneReviewDbChange(db, changeId));
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
    manager.stage();
    return manager;
}
#end_block

#method_before
@Override
public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = checkNoteDbState(ChangeNotes.readOneReviewDbChange(db, changeId));
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    Result r = manager.stageAndApplyDelta(change);
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                String currNoteDbState = change.getNoteDbState();
                if (Objects.equals(currNoteDbState, newNoteDbState)) {
                    // Another thread completed the same rebuild we were about to.
                    throw new AbortUpdateException();
                } else if (!Objects.equals(oldNoteDbState, currNoteDbState)) {
                    // Another thread updated the state to something else.
                    throw new ConflictingUpdateException(change, oldNoteDbState);
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
    } catch (ConflictingUpdateException e) {
        // the other thread.
        throw new OrmException(e.getMessage());
    } catch (AbortUpdateException e) {
        if (NoteDbChangeState.parse(changeId, newNoteDbState).isUpToDate(manager.getChangeRepo().cmds.getRepoRefCache(), manager.getAllUsersRepo().cmds.getRepoRefCache())) {
            // Result was flushed to the repo by whatever thread won the race.
            return r;
        }
    // If the state doesn't match, that means another thread attempted this
    // rebuild, but failed. Fall through and try to update the ref again.
    }
    if (migration.failChangeWrites()) {
        // results instead of reading from the repo.
        throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
    }
    manager.execute();
    return r;
}
#method_after
@Override
public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws OrmException, IOException {
    return execute(db, changeId, manager, true);
}
#end_block

#method_before
@Override
public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = checkNoteDbState(ChangeNotes.readOneReviewDbChange(db, changeId));
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    Result r = manager.stageAndApplyDelta(change);
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                String currNoteDbState = change.getNoteDbState();
                if (Objects.equals(currNoteDbState, newNoteDbState)) {
                    // Another thread completed the same rebuild we were about to.
                    throw new AbortUpdateException();
                } else if (!Objects.equals(oldNoteDbState, currNoteDbState)) {
                    // Another thread updated the state to something else.
                    throw new ConflictingUpdateException(change, oldNoteDbState);
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
    } catch (ConflictingUpdateException e) {
        // the other thread.
        throw new OrmException(e.getMessage());
    } catch (AbortUpdateException e) {
        if (NoteDbChangeState.parse(changeId, newNoteDbState).isUpToDate(manager.getChangeRepo().cmds.getRepoRefCache(), manager.getAllUsersRepo().cmds.getRepoRefCache())) {
            // Result was flushed to the repo by whatever thread won the race.
            return r;
        }
    // If the state doesn't match, that means another thread attempted this
    // rebuild, but failed. Fall through and try to update the ref again.
    }
    if (migration.failChangeWrites()) {
        // results instead of reading from the repo.
        throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
    }
    manager.execute();
    return r;
}
#method_after
public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager, boolean checkReadOnly) throws OrmException, IOException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = checkNoteDbState(ChangeNotes.readOneReviewDbChange(db, changeId));
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    Result r = manager.stageAndApplyDelta(change);
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (checkReadOnly) {
                    NoteDbChangeState.checkNotReadOnly(change, skewMs);
                }
                String currNoteDbState = change.getNoteDbState();
                if (Objects.equals(currNoteDbState, newNoteDbState)) {
                    // Another thread completed the same rebuild we were about to.
                    throw new AbortUpdateException();
                } else if (!Objects.equals(oldNoteDbState, currNoteDbState)) {
                    // Another thread updated the state to something else.
                    throw new ConflictingUpdateException(change, oldNoteDbState);
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
    } catch (ConflictingUpdateException e) {
        // the other thread.
        throw new OrmException(e.getMessage());
    } catch (AbortUpdateException e) {
        if (NoteDbChangeState.parse(changeId, newNoteDbState).isUpToDate(manager.getChangeRepo().cmds.getRepoRefCache(), manager.getAllUsersRepo().cmds.getRepoRefCache())) {
            // Result was flushed to the repo by whatever thread won the race.
            return r;
        }
    // If the state doesn't match, that means another thread attempted this
    // rebuild, but failed. Fall through and try to update the ref again.
    }
    if (migration.failChangeWrites()) {
        // results instead of reading from the repo.
        throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
    }
    manager.execute();
    return r;
}
#end_block

#method_before
@Override
public void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false);
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    PatchSet.Id currPsId = change.currentPatchSetId();
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = new ArrayList<>();
    Multimap<Account.Id, DraftCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    Map<PatchSet.Id, PatchSetEvent> patchSetEvents = Maps.newHashMapWithExpectedSize(bundle.getPatchSets().size());
    for (PatchSet ps : bundle.getPatchSets()) {
        if (ps.getId().get() > currPsId.get()) {
            log.info("Skipping patch set {}, which is higher than current patch set {}", ps.getId(), currPsId);
            continue;
        }
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        List<Event> msgEvents = parseChangeMessage(msg, change, noteDbChange);
        if (msg.getPatchSetId() != null) {
            PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
            if (pse == null) {
                // Ignore events for missing patch sets.
                continue;
            }
            for (Event e : msgEvents) {
                e.addDep(pse);
            }
        }
        events.addAll(msgEvents);
    }
    sortAndFillEvents(change, noteDbChange, events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#method_after
@Override
public void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false).setRefLogMessage("Rebuilding change");
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = new ArrayList<>();
    ListMultimap<Account.Id, DraftCommentEvent> draftCommentEvents = MultimapBuilder.hashKeys().arrayListValues().build();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    Map<PatchSet.Id, PatchSetEvent> patchSetEvents = Maps.newHashMapWithExpectedSize(bundle.getPatchSets().size());
    for (PatchSet ps : bundle.getPatchSets()) {
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        List<Event> msgEvents = parseChangeMessage(msg, change, noteDbChange);
        if (msg.getPatchSetId() != null) {
            PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
            if (pse == null) {
                // Ignore events for missing patch sets.
                continue;
            }
            for (Event e : msgEvents) {
                e.addDep(pse);
            }
        }
        events.addAll(msgEvents);
    }
    sortAndFillEvents(change, noteDbChange, bundle.getPatchSets(), events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#end_block

#method_before
private void sortAndFillEvents(Change change, Change noteDbChange, List<Event> events, Integer minPsNum) {
    Event finalUpdates = new FinalUpdatesEvent(change, noteDbChange);
    events.add(finalUpdates);
    setPostSubmitDeps(events);
    new EventSorter(events).sort();
    // Ensure the first event in the list creates the change, setting the author
    // and any required footers.
    Event first = events.get(0);
    if (first instanceof PatchSetEvent && change.getOwner().equals(first.user)) {
        ((PatchSetEvent) first).createChange = true;
    } else {
        events.add(0, new CreateChangeEvent(change, minPsNum));
    }
    // Final pass to correct some inconsistencies.
    // 
    // First, fill in any missing patch set IDs using the latest patch set of
    // the change at the time of the event, because NoteDb can't represent
    // actions with no associated patch set ID. This workaround is as if a user
    // added a ChangeMessage on the change by replying from the latest patch
    // set.
    // 
    // Start with the first patch set that actually exists. If there are no
    // patch sets at all, minPsNum will be null, so just bail and use 1 as the
    // patch set ID. The corresponding patch set won't exist, but this change is
    // probably corrupt anyway, as deleting the last draft patch set should have
    // deleted the whole change.
    // 
    // Second, ensure timestamps are nondecreasing, by copying the previous
    // timestamp if this happens. This assumes that the only way this can happen
    // is due to dependency constraints, and it is ok to give an event the same
    // timestamp as one of its dependencies.
    int ps = firstNonNull(minPsNum, 1);
    for (int i = 0; i < events.size(); i++) {
        Event e = events.get(i);
        if (e.psId == null) {
            e.psId = new PatchSet.Id(change.getId(), ps);
        } else {
            ps = Math.max(ps, e.psId.get());
        }
        if (i > 0) {
            Event p = events.get(i - 1);
            if (e.when.before(p.when)) {
                e.when = p.when;
            }
        }
    }
}
#method_after
private void sortAndFillEvents(Change change, Change noteDbChange, ImmutableCollection<PatchSet> patchSets, List<Event> events, Integer minPsNum) {
    Event finalUpdates = new FinalUpdatesEvent(change, noteDbChange, patchSets);
    events.add(finalUpdates);
    setPostSubmitDeps(events);
    new EventSorter(events).sort();
    // Ensure the first event in the list creates the change, setting the author
    // and any required footers.
    Event first = events.get(0);
    if (first instanceof PatchSetEvent && change.getOwner().equals(first.user)) {
        ((PatchSetEvent) first).createChange = true;
    } else {
        events.add(0, new CreateChangeEvent(change, minPsNum));
    }
    // Final pass to correct some inconsistencies.
    // 
    // First, fill in any missing patch set IDs using the latest patch set of
    // the change at the time of the event, because NoteDb can't represent
    // actions with no associated patch set ID. This workaround is as if a user
    // added a ChangeMessage on the change by replying from the latest patch
    // set.
    // 
    // Start with the first patch set that actually exists. If there are no
    // patch sets at all, minPsNum will be null, so just bail and use 1 as the
    // patch set ID. The corresponding patch set won't exist, but this change is
    // probably corrupt anyway, as deleting the last draft patch set should have
    // deleted the whole change.
    // 
    // Second, ensure timestamps are nondecreasing, by copying the previous
    // timestamp if this happens. This assumes that the only way this can happen
    // is due to dependency constraints, and it is ok to give an event the same
    // timestamp as one of its dependencies.
    int ps = firstNonNull(minPsNum, 1);
    for (int i = 0; i < events.size(); i++) {
        Event e = events.get(i);
        if (e.psId == null) {
            e.psId = new PatchSet.Id(change.getId(), ps);
        } else {
            ps = Math.max(ps, e.psId.get());
        }
        if (i > 0) {
            Event p = events.get(i - 1);
            if (e.when.before(p.when)) {
                e.when = p.when;
            }
        }
    }
}
#end_block

#method_before
@Override
public GroupApi id(String id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public GroupApi id(String id) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public GroupApi create(String name) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public GroupApi create(String name) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public GroupApi create(GroupInput input) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public GroupApi create(GroupInput input) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o != null && getClass() == o.getClass()) {
        Comment c = (Comment) o;
        return Objects.equals(patchSet, c.patchSet) && Objects.equals(id, c.id) && Objects.equals(path, c.path) && Objects.equals(side, c.side) && Objects.equals(parent, c.parent) && Objects.equals(line, c.line) && Objects.equals(range, c.range) && Objects.equals(inReplyTo, c.inReplyTo) && Objects.equals(updated, c.updated) && Objects.equals(message, c.message);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o != null && getClass() == o.getClass()) {
        Comment c = (Comment) o;
        return Objects.equals(patchSet, c.patchSet) && Objects.equals(id, c.id) && Objects.equals(path, c.path) && Objects.equals(side, c.side) && Objects.equals(parent, c.parent) && Objects.equals(line, c.line) && Objects.equals(range, c.range) && Objects.equals(inReplyTo, c.inReplyTo) && Objects.equals(updated, c.updated) && Objects.equals(message, c.message) && Objects.equals(unresolved, c.unresolved);
    }
    return false;
}
#end_block

#method_before
static Delta create(Change.Id changeId, Optional<ObjectId> newChangeMetaId, Map<Account.Id, ObjectId> newDraftIds) {
    if (newDraftIds == null) {
        newDraftIds = ImmutableMap.of();
    }
    return new AutoValue_NoteDbChangeState_Delta(changeId, newChangeMetaId, ImmutableMap.copyOf(newDraftIds));
}
#method_after
@VisibleForTesting
public static Delta create(Change.Id changeId, Optional<ObjectId> newChangeMetaId, Map<Account.Id, ObjectId> newDraftIds) {
    if (newDraftIds == null) {
        newDraftIds = ImmutableMap.of();
    }
    return new AutoValue_NoteDbChangeState_Delta(changeId, newChangeMetaId, ImmutableMap.copyOf(newDraftIds));
}
#end_block

#method_before
@VisibleForTesting
public static RefState create(ObjectId changeMetaId, Map<Account.Id, ObjectId> draftIds) {
    return new AutoValue_NoteDbChangeState_RefState(changeMetaId.copy(), ImmutableMap.copyOf(Maps.filterValues(draftIds, id -> !zeroId().equals(id))));
}
#method_after
@VisibleForTesting
public static RefState create(ObjectId changeMetaId, Map<Account.Id, ObjectId> draftIds) {
    return new AutoValue_NoteDbChangeState_RefState(changeMetaId.copy(), ImmutableMap.copyOf(Maps.filterValues(draftIds, id -> !ObjectId.zeroId().equals(id))));
}
#end_block

#method_before
@VisibleForTesting
public static NoteDbChangeState parse(Change.Id id, String str) {
    if (Strings.isNullOrEmpty(str)) {
        // ReviewDb.
        return null;
    }
    List<String> parts = Splitter.on(',').splitToList(str);
    // Only valid NOTE_DB state is "N".
    String first = parts.get(0);
    if (parts.size() == 1 && first.charAt(0) == NOTE_DB.code) {
        return new NoteDbChangeState(id, NOTE_DB, Optional.empty());
    }
    // "<RefState>". Allow length > 0 for forward compatibility.
    if (first.length() > 0) {
        Optional<RefState> refState;
        if (first.charAt(0) == REVIEW_DB.code) {
            refState = RefState.parse(id, parts.subList(1, parts.size()));
        } else {
            refState = RefState.parse(id, parts);
        }
        return new NoteDbChangeState(id, REVIEW_DB, refState);
    }
    throw new IllegalArgumentException("invalid state string for change " + id + ": " + str);
}
#method_after
@VisibleForTesting
public static NoteDbChangeState parse(Change.Id id, String str) {
    if (Strings.isNullOrEmpty(str)) {
        // ReviewDb.
        return null;
    }
    List<String> parts = Splitter.on(',').splitToList(str);
    String first = parts.get(0);
    Optional<Timestamp> readOnlyUntil = parseReadOnlyUntil(id, str, first);
    // Only valid NOTE_DB state is "N".
    if (parts.size() == 1 && first.charAt(0) == NOTE_DB.code) {
        return new NoteDbChangeState(id, NOTE_DB, Optional.empty(), readOnlyUntil);
    }
    // "<RefState>". Allow length > 0 for forward compatibility.
    if (first.length() > 0) {
        Optional<RefState> refState;
        if (first.charAt(0) == REVIEW_DB.code) {
            refState = RefState.parse(id, parts.subList(1, parts.size()));
        } else {
            refState = RefState.parse(id, parts);
        }
        return new NoteDbChangeState(id, REVIEW_DB, refState, readOnlyUntil);
    }
    throw invalidState(id, str);
}
#end_block

#method_before
public static NoteDbChangeState applyDelta(Change change, Delta delta) {
    if (delta == null) {
        return null;
    }
    String oldStr = change.getNoteDbState();
    if (oldStr == null && !delta.newChangeMetaId().isPresent()) {
        // point in proceeding.
        return null;
    }
    NoteDbChangeState oldState = parse(change.getId(), oldStr);
    if (oldState != null && oldState.getPrimaryStorage() == NOTE_DB) {
        // NOTE_DB state doesn't include RefState, so applying a delta is a no-op.
        return oldState;
    }
    ObjectId changeMetaId;
    if (delta.newChangeMetaId().isPresent()) {
        changeMetaId = delta.newChangeMetaId().get();
        if (changeMetaId.equals(ObjectId.zeroId())) {
            change.setNoteDbState(null);
            return null;
        }
    } else {
        changeMetaId = oldState.getChangeMetaId();
    }
    Map<Account.Id, ObjectId> draftIds = new HashMap<>();
    if (oldState != null) {
        draftIds.putAll(oldState.getDraftIds());
    }
    for (Map.Entry<Account.Id, ObjectId> e : delta.newDraftIds().entrySet()) {
        if (e.getValue().equals(ObjectId.zeroId())) {
            draftIds.remove(e.getKey());
        } else {
            draftIds.put(e.getKey(), e.getValue());
        }
    }
    NoteDbChangeState state = new NoteDbChangeState(change.getId(), oldState != null ? oldState.getPrimaryStorage() : REVIEW_DB, Optional.of(RefState.create(changeMetaId, draftIds)));
    change.setNoteDbState(state.toString());
    return state;
}
#method_after
public static NoteDbChangeState applyDelta(Change change, Delta delta) {
    if (delta == null) {
        return null;
    }
    String oldStr = change.getNoteDbState();
    if (oldStr == null && !delta.newChangeMetaId().isPresent()) {
        // point in proceeding.
        return null;
    }
    NoteDbChangeState oldState = parse(change.getId(), oldStr);
    if (oldState != null && oldState.getPrimaryStorage() == NOTE_DB) {
        // NOTE_DB state doesn't include RefState, so applying a delta is a no-op.
        return oldState;
    }
    ObjectId changeMetaId;
    if (delta.newChangeMetaId().isPresent()) {
        changeMetaId = delta.newChangeMetaId().get();
        if (changeMetaId.equals(ObjectId.zeroId())) {
            change.setNoteDbState(null);
            return null;
        }
    } else {
        changeMetaId = oldState.getChangeMetaId();
    }
    Map<Account.Id, ObjectId> draftIds = new HashMap<>();
    if (oldState != null) {
        draftIds.putAll(oldState.getDraftIds());
    }
    for (Map.Entry<Account.Id, ObjectId> e : delta.newDraftIds().entrySet()) {
        if (e.getValue().equals(ObjectId.zeroId())) {
            draftIds.remove(e.getKey());
        } else {
            draftIds.put(e.getKey(), e.getValue());
        }
    }
    NoteDbChangeState state = new NoteDbChangeState(change.getId(), oldState != null ? oldState.getPrimaryStorage() : REVIEW_DB, Optional.of(RefState.create(changeMetaId, draftIds)), // runs out.
    oldState != null ? oldState.getReadOnlyUntil() : Optional.empty());
    change.setNoteDbState(state.toString());
    return state;
}
#end_block

#method_before
public static boolean isChangeUpToDate(@Nullable NoteDbChangeState state, RefCache changeRepoRefs, Change.Id changeId) throws IOException {
    if (PrimaryStorage.of(state) == NOTE_DB) {
        // Primary storage is NoteDb, up to date by definition.
        return true;
    }
    if (state == null) {
        return !changeRepoRefs.get(changeMetaRef(changeId)).isPresent();
    }
    return state.isChangeUpToDate(changeRepoRefs);
}
#method_after
// TODO(dborowitz): Ugly. Refactor these static methods into a Checker class
// or something. They do not belong in NoteDbChangeState itself because:
// - need to inject Config but don't want a whole Factory
// - can't be methods on NoteDbChangeState because state is nullable (though
// we could also solve this by inventing an empty-but-non-null state)
public static boolean isChangeUpToDate(@Nullable NoteDbChangeState state, RefCache changeRepoRefs, Change.Id changeId) throws IOException {
    if (PrimaryStorage.of(state) == NOTE_DB) {
        // Primary storage is NoteDb, up to date by definition.
        return true;
    }
    if (state == null) {
        return !changeRepoRefs.get(changeMetaRef(changeId)).isPresent();
    }
    return state.isChangeUpToDate(changeRepoRefs);
}
#end_block

#method_before
@VisibleForTesting
Change.Id getChangeId() {
    return changeId;
}
#method_after
public Change.Id getChangeId() {
    return changeId;
}
#end_block

#method_before
@VisibleForTesting
public ObjectId getChangeMetaId() {
    return refState().changeMetaId();
}
#method_after
public ObjectId getChangeMetaId() {
    return refState().changeMetaId();
}
#end_block

#method_before
@VisibleForTesting
ImmutableMap<Account.Id, ObjectId> getDraftIds() {
    return refState().draftIds();
}
#method_after
public ImmutableMap<Account.Id, ObjectId> getDraftIds() {
    return refState().draftIds();
}
#end_block

#method_before
@VisibleForTesting
Optional<RefState> getRefState() {
    return refState;
}
#method_after
public Optional<RefState> getRefState() {
    return refState;
}
#end_block

#method_before
@Override
public String toString() {
    switch(primaryStorage) {
        case REVIEW_DB:
            // Don't include enum field, just IDs (though parse would accept it).
            return refState().toString();
        case NOTE_DB:
            return NOTE_DB_PRIMARY_STATE;
        default:
            throw new IllegalArgumentException("Unsupported PrimaryStorage: " + primaryStorage);
    }
}
#method_after
@Override
public String toString() {
    switch(primaryStorage) {
        case REVIEW_DB:
            if (!readOnlyUntil.isPresent()) {
                // Don't include enum field, just IDs (though parse would accept it).
                return refState().toString();
            }
            return primaryStorage.code + "=" + readOnlyUntil.get().getTime() + "," + refState.get();
        case NOTE_DB:
            if (!readOnlyUntil.isPresent()) {
                return NOTE_DB_PRIMARY_STATE;
            }
            return primaryStorage.code + "=" + readOnlyUntil.get().getTime();
        default:
            throw new IllegalArgumentException("Unsupported PrimaryStorage: " + primaryStorage);
    }
}
#end_block

#method_before
@Override
public AccountApi id(String id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountApi id(String id) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public AccountApi id(int id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountApi id(int id) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public AccountApi self() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountApi self() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public AccountApi create(String username) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountApi create(String username) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public AccountApi create(AccountInput input) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountApi create(AccountInput input) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SuggestAccountsRequest suggestAccounts() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestAccountsRequest suggestAccounts() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SuggestAccountsRequest suggestAccounts(String query) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestAccountsRequest suggestAccounts(String query) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public QueryRequest query() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public QueryRequest query() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public QueryRequest query(String query) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public QueryRequest query(String query) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
void newDraft(CodeMirror cm) {
    int line = cm.getLineNumber(cm.extras().activeLine()) + 1;
    if (cm.somethingSelected()) {
        FromTo fromTo = adjustSelection(cm);
        addDraftBox(cm.side(), CommentInfo.create(getPath(), getStoredSideFromDisplaySide(cm.side()), getParentNumFromDisplaySide(cm.side()), line, CommentRange.create(fromTo))).setEdit(true);
        cm.setCursor(fromTo.to());
        cm.setSelection(cm.getCursor());
    } else {
        insertNewDraft(cm.side(), line);
    }
}
#method_after
@Override
void newDraft(CodeMirror cm) {
    int line = cm.getLineNumber(cm.extras().activeLine()) + 1;
    if (cm.somethingSelected()) {
        FromTo fromTo = adjustSelection(cm);
        addDraftBox(cm.side(), CommentInfo.create(getPath(), getStoredSideFromDisplaySide(cm.side()), getParentNumFromDisplaySide(cm.side()), line, CommentRange.create(fromTo), false)).setEdit(true);
        cm.setCursor(fromTo.to());
        cm.setSelection(cm.getCursor());
    } else {
        insertNewDraft(cm.side(), line);
    }
}
#end_block

#method_before
public void abandonInactiveOpenChanges() {
    if (cfg.getAbandonAfter() <= 0) {
        return;
    }
    try {
        String query = "status:new age:" + TimeUnit.MILLISECONDS.toMinutes(cfg.getAbandonAfter()) + "m";
        if (!cfg.getAbandonIfMergeable()) {
            query += " -is:mergeable";
        }
        List<ChangeData> changesToAbandon = queryProcessor.enforceVisibility(false).query(queryBuilder.parse(query)).entities();
        ImmutableMultimap.Builder<Project.NameKey, ChangeControl> builder = ImmutableMultimap.builder();
        for (ChangeData cd : changesToAbandon) {
            ChangeControl control = cd.changeControl(internalUser);
            builder.put(control.getProject().getNameKey(), control);
        }
        int count = 0;
        Multimap<Project.NameKey, ChangeControl> abandons = builder.build();
        String message = cfg.getAbandonMessage();
        for (Project.NameKey project : abandons.keySet()) {
            Collection<ChangeControl> changes = getValidChanges(abandons.get(project), query);
            try {
                abandon.batchAbandon(project, internalUser, changes, message);
                count += changes.size();
            } catch (Throwable e) {
                StringBuilder msg = new StringBuilder("Failed to auto-abandon inactive change(s):");
                for (ChangeControl change : changes) {
                    msg.append(" ").append(change.getId().get());
                }
                msg.append(".");
                log.error(msg.toString(), e);
            }
        }
        log.info(String.format("Auto-Abandoned %d of %d changes.", count, changesToAbandon.size()));
    } catch (QueryParseException | OrmException e) {
        log.error("Failed to query inactive open changes for auto-abandoning.", e);
    }
}
#method_after
public void abandonInactiveOpenChanges() {
    if (cfg.getAbandonAfter() <= 0) {
        return;
    }
    try {
        String query = "status:new age:" + TimeUnit.MILLISECONDS.toMinutes(cfg.getAbandonAfter()) + "m";
        if (!cfg.getAbandonIfMergeable()) {
            query += " -is:mergeable";
        }
        List<ChangeData> changesToAbandon = queryProcessor.enforceVisibility(false).query(queryBuilder.parse(query)).entities();
        ImmutableListMultimap.Builder<Project.NameKey, ChangeControl> builder = ImmutableListMultimap.builder();
        for (ChangeData cd : changesToAbandon) {
            ChangeControl control = cd.changeControl(internalUser);
            builder.put(control.getProject().getNameKey(), control);
        }
        int count = 0;
        ListMultimap<Project.NameKey, ChangeControl> abandons = builder.build();
        String message = cfg.getAbandonMessage();
        for (Project.NameKey project : abandons.keySet()) {
            Collection<ChangeControl> changes = getValidChanges(abandons.get(project), query);
            try {
                abandon.batchAbandon(project, internalUser, changes, message);
                count += changes.size();
            } catch (Throwable e) {
                StringBuilder msg = new StringBuilder("Failed to auto-abandon inactive change(s):");
                for (ChangeControl change : changes) {
                    msg.append(" ").append(change.getId().get());
                }
                msg.append(".");
                log.error(msg.toString(), e);
            }
        }
        log.info(String.format("Auto-Abandoned %d of %d changes.", count, changesToAbandon.size()));
    } catch (QueryParseException | OrmException e) {
        log.error("Failed to query inactive open changes for auto-abandoning.", e);
    }
}
#end_block

#method_before
@Inject(optional = true)
void set(SchemaFactory<ReviewDb> dbFactory) {
    this.dbFactory = dbFactory;
}
#method_after
@Inject(optional = true)
void set(AccountIndexCollection indexCollection) {
    this.indexCollection = indexCollection;
}
#end_block

#method_before
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(httpPassword);
                }
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroup = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroup.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user\n");
                }
            }
        }
    }
}
#method_after
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                List<AccountExternalId> extIds = new ArrayList<>(2);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(httpPassword);
                }
                extIds.add(extUser);
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    extIds.add(extMailto);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroupName = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroupName.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user\n");
                }
                AccountGroup adminGroup = db.accountGroups().get(adminGroupName.getId());
                AccountState as = new AccountState(a, Collections.singleton(adminGroup.getGroupUUID()), extIds, new HashMap<>());
                for (AccountIndex accountIndex : indexCollection.getWriteIndexes()) {
                    accountIndex.replace(as);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public BranchApi create(BranchInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public BranchApi create(BranchInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BranchInfo get() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public BranchInfo get() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void delete() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult file(String path) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult file(String path) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public VoteResource parse(ReviewerResource reviewer, IdString id) throws ResourceNotFoundException, OrmException, AuthException {
    return new VoteResource(reviewer, id.get());
}
#method_after
@Override
public VoteResource parse(ReviewerResource reviewer, IdString id) throws ResourceNotFoundException, OrmException, AuthException, MethodNotAllowedException {
    if (reviewer.getRevisionResource() != null && !reviewer.getRevisionResource().isCurrent()) {
        throw new MethodNotAllowedException("Cannot access on non-current patch set");
    }
    return new VoteResource(reviewer, id.get());
}
#end_block

#method_before
@Override
public Map<String, Short> apply(ReviewerResource rsrc) throws OrmException {
    Map<String, Short> votes = new TreeMap<>();
    Iterable<PatchSetApproval> byPatchSetUser = approvalsUtil.byPatchSetUser(db.get(), rsrc.getControl(), rsrc.getChange().currentPatchSetId(), rsrc.getReviewerUser().getAccountId());
    for (PatchSetApproval psa : byPatchSetUser) {
        votes.put(psa.getLabel(), psa.getValue());
    }
    return votes;
}
#method_after
@Override
public Map<String, Short> apply(ReviewerResource rsrc) throws OrmException, MethodNotAllowedException {
    if (rsrc.getRevisionResource() != null && !rsrc.getRevisionResource().isCurrent()) {
        throw new MethodNotAllowedException("Cannot list votes on non-current patch set");
    }
    Map<String, Short> votes = new TreeMap<>();
    Iterable<PatchSetApproval> byPatchSetUser = approvalsUtil.byPatchSetUser(db.get(), rsrc.getControl(), rsrc.getChange().currentPatchSetId(), rsrc.getReviewerUser().getAccountId());
    for (PatchSetApproval psa : byPatchSetUser) {
        votes.put(psa.getLabel(), psa.getValue());
    }
    return votes;
}
#end_block

#method_before
@Override
public void start() {
    // compress log once and then schedule compression every day at 11:00pm
    queue.getDefaultQueue().execute(compressor);
    DateTime now = DateTime.now();
    long milliSecondsUntil11am = new Duration(now, now.withTimeAtStartOfDay().plusHours(23)).getMillis();
    queue.getDefaultQueue().scheduleAtFixedRate(compressor, milliSecondsUntil11am, HOURS.toMillis(24), MILLISECONDS);
}
#method_after
@Override
public void start() {
    // compress log once and then schedule compression every day at 11:00pm
    queue.getDefaultQueue().execute(compressor);
    ZoneId zone = ZoneId.systemDefault();
    LocalDate now = LocalDate.now(zone);
    long milliSecondsUntil11pm = now.atStartOfDay(zone).plusHours(23).toInstant().toEpochMilli();
    queue.getDefaultQueue().scheduleAtFixedRate(compressor, milliSecondsUntil11pm, HOURS.toMillis(24), MILLISECONDS);
}
#end_block

#method_before
protected void fillCommentInfo(Comment c, CommentInfo r, AccountLoader loader) {
    if (fillPatchSet) {
        r.patchSet = c.key.patchSetId;
    }
    r.id = Url.encode(c.key.uuid);
    r.path = c.key.filename;
    if (c.side <= 0) {
        r.side = Side.PARENT;
        if (c.side < 0) {
            r.parent = -c.side;
        }
    }
    if (c.lineNbr > 0) {
        r.line = c.lineNbr;
    }
    r.inReplyTo = Url.encode(c.parentUuid);
    r.message = Strings.emptyToNull(c.message);
    r.updated = c.writtenOn;
    r.range = toRange(c.range);
    r.tag = c.tag;
    if (loader != null) {
        r.author = loader.get(c.author.getId());
    }
}
#method_after
protected void fillCommentInfo(Comment c, CommentInfo r, AccountLoader loader) {
    if (fillPatchSet) {
        r.patchSet = c.key.patchSetId;
    }
    r.id = Url.encode(c.key.uuid);
    r.path = c.key.filename;
    if (c.side <= 0) {
        r.side = Side.PARENT;
        if (c.side < 0) {
            r.parent = -c.side;
        }
    }
    if (c.lineNbr > 0) {
        r.line = c.lineNbr;
    }
    r.inReplyTo = Url.encode(c.parentUuid);
    r.message = Strings.emptyToNull(c.message);
    r.updated = c.writtenOn;
    r.range = toRange(c.range);
    r.tag = c.tag;
    r.unresolved = c.unresolved;
    if (loader != null) {
        r.author = loader.get(c.author.getId());
    }
}
#end_block

#method_before
private Range toRange(Comment.Range commentRange) {
    Range range = null;
    if (commentRange != null) {
        range = new Range();
        range.startLine = commentRange.startLine;
        range.startCharacter = commentRange.startChar;
        range.endLine = commentRange.endLine;
        range.endCharacter = commentRange.endChar;
    }
    return range;
}
#method_after
protected Range toRange(Comment.Range commentRange) {
    Range range = null;
    if (commentRange != null) {
        range = new Range();
        range.startLine = commentRange.startLine;
        range.startCharacter = commentRange.startChar;
        range.endLine = commentRange.endLine;
        range.endCharacter = commentRange.endChar;
    }
    return range;
}
#end_block

#method_before
@Override
protected RobotCommentInfo toInfo(RobotComment c, AccountLoader loader) {
    RobotCommentInfo rci = new RobotCommentInfo();
    rci.robotId = c.robotId;
    rci.robotRunId = c.robotRunId;
    rci.url = c.url;
    rci.properties = c.properties;
    fillCommentInfo(c, rci, loader);
    return rci;
}
#method_after
@Override
protected RobotCommentInfo toInfo(RobotComment c, AccountLoader loader) {
    RobotCommentInfo rci = new RobotCommentInfo();
    rci.robotId = c.robotId;
    rci.robotRunId = c.robotRunId;
    rci.url = c.url;
    rci.properties = c.properties;
    rci.fixSuggestions = toFixSuggestionInfos(c.fixSuggestions);
    fillCommentInfo(c, rci, loader);
    return rci;
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Multimap<Account.Id, AccountSshKey> imports = ArrayListMultimap.create();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT " + "account_id, " + "seq, " + "ssh_public_key, " + "valid " + "FROM account_ssh_keys")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            int seq = rs.getInt(2);
            String sshPublicKey = rs.getString(3);
            AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq), sshPublicKey);
            boolean valid = toBoolean(rs.getString(4));
            if (!valid) {
                key.setInvalid();
            }
            imports.put(accountId, key);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        for (Map.Entry<Account.Id, Collection<AccountSshKey>> e : imports.asMap().entrySet()) {
            try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git, bru)) {
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(new SimpleSshKeyCreator(), e.getKey());
                authorizedKeys.load(md);
                authorizedKeys.setKeys(fixInvalidSequenceNumbers(e.getValue()));
                authorizedKeys.commit(md);
            }
        }
        bru.execute(rw, NullProgressMonitor.INSTANCE);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    ListMultimap<Account.Id, AccountSshKey> imports = MultimapBuilder.hashKeys().arrayListValues().build();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT " + "account_id, " + "seq, " + "ssh_public_key, " + "valid " + "FROM account_ssh_keys")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            int seq = rs.getInt(2);
            String sshPublicKey = rs.getString(3);
            AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq), sshPublicKey);
            boolean valid = toBoolean(rs.getString(4));
            if (!valid) {
                key.setInvalid();
            }
            imports.put(accountId, key);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        for (Map.Entry<Account.Id, Collection<AccountSshKey>> e : imports.asMap().entrySet()) {
            try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git, bru)) {
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(new SimpleSshKeyCreator(), e.getKey());
                authorizedKeys.load(md);
                authorizedKeys.setKeys(fixInvalidSequenceNumbers(e.getValue()));
                authorizedKeys.commit(md);
            }
        }
        bru.execute(rw, NullProgressMonitor.INSTANCE);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#end_block

#method_before
public ProjectInfo format(Project p) {
    ProjectInfo info = new ProjectInfo();
    info.name = p.getName();
    Project.NameKey parentName = p.getParent(allProjects);
    info.parent = parentName != null ? parentName.get() : null;
    info.description = Strings.emptyToNull(p.getDescription());
    info.state = p.getState();
    info.id = Url.encode(info.name);
    FluentIterable<WebLinkInfo> links = webLinks.getProjectLinks(p.getName());
    info.webLinks = links.isEmpty() ? null : links.toList();
    return info;
}
#method_after
public ProjectInfo format(Project p) {
    ProjectInfo info = new ProjectInfo();
    info.name = p.getName();
    Project.NameKey parentName = p.getParent(allProjects);
    info.parent = parentName != null ? parentName.get() : null;
    info.description = Strings.emptyToNull(p.getDescription());
    info.state = p.getState();
    info.id = Url.encode(info.name);
    List<WebLinkInfo> links = webLinks.getProjectLinks(p.getName());
    info.webLinks = links.isEmpty() ? null : links;
    return info;
}
#end_block

#method_before
@Override
void newDraft(CodeMirror cm) {
    if (cm.somethingSelected()) {
        FromTo fromTo = adjustSelection(cm);
        Pos from = fromTo.from();
        Pos to = fromTo.to();
        Unified unified = (Unified) host;
        UnifiedChunkManager manager = unified.getChunkManager();
        LineRegionInfo fromInfo = unified.getLineRegionInfoFromCmLine(from.line());
        LineRegionInfo toInfo = unified.getLineRegionInfoFromCmLine(to.line());
        DisplaySide side = toInfo.getSide();
        // start line to be on the same side as the end line.
        if ((fromInfo.type == RegionType.INSERT || fromInfo.type == RegionType.COMMON) && toInfo.type == RegionType.DELETE) {
            LineOnOtherInfo infoOnSideA = manager.lineMapper.lineOnOther(DisplaySide.B, fromInfo.line);
            int startLineOnSideA = infoOnSideA.getLine();
            if (infoOnSideA.isAligned()) {
                from.line(startLineOnSideA);
            } else {
                from.line(startLineOnSideA + 1);
            }
            from.ch(0);
            to.line(toInfo.line);
        } else if (fromInfo.type == RegionType.DELETE && toInfo.type == RegionType.INSERT) {
            LineOnOtherInfo infoOnSideB = manager.lineMapper.lineOnOther(DisplaySide.A, fromInfo.line);
            int startLineOnSideB = infoOnSideB.getLine();
            if (infoOnSideB.isAligned()) {
                from.line(startLineOnSideB);
            } else {
                from.line(startLineOnSideB + 1);
            }
            from.ch(0);
            to.line(toInfo.line);
        } else if (fromInfo.type == RegionType.DELETE && toInfo.type == RegionType.COMMON) {
            int toLineOnSideA = manager.lineMapper.lineOnOther(DisplaySide.B, toInfo.line).getLine();
            from.line(fromInfo.line);
            // Force the end line to be on the same side as the start line.
            to.line(toLineOnSideA);
            side = DisplaySide.A;
        } else {
            // Common case
            from.line(fromInfo.line);
            to.line(toInfo.line);
        }
        addDraftBox(side, CommentInfo.create(getPath(), getStoredSideFromDisplaySide(side), to.line() + 1, CommentRange.create(fromTo))).setEdit(true);
        cm.setCursor(Pos.create(host.getCmLine(to.line(), side), to.ch()));
        cm.setSelection(cm.getCursor());
    } else {
        int cmLine = cm.getLineNumber(cm.extras().activeLine());
        LineRegionInfo info = ((Unified) host).getLineRegionInfoFromCmLine(cmLine);
        insertNewDraft(info.getSide(), cmLine + 1);
    }
}
#method_after
@Override
void newDraft(CodeMirror cm) {
    if (cm.somethingSelected()) {
        FromTo fromTo = adjustSelection(cm);
        Pos from = fromTo.from();
        Pos to = fromTo.to();
        Unified unified = (Unified) host;
        UnifiedChunkManager manager = unified.getChunkManager();
        LineRegionInfo fromInfo = unified.getLineRegionInfoFromCmLine(from.line());
        LineRegionInfo toInfo = unified.getLineRegionInfoFromCmLine(to.line());
        DisplaySide side = toInfo.getSide();
        // start line to be on the same side as the end line.
        if ((fromInfo.type == RegionType.INSERT || fromInfo.type == RegionType.COMMON) && toInfo.type == RegionType.DELETE) {
            LineOnOtherInfo infoOnSideA = manager.lineMapper.lineOnOther(DisplaySide.B, fromInfo.line);
            int startLineOnSideA = infoOnSideA.getLine();
            if (infoOnSideA.isAligned()) {
                from.line(startLineOnSideA);
            } else {
                from.line(startLineOnSideA + 1);
            }
            from.ch(0);
            to.line(toInfo.line);
        } else if (fromInfo.type == RegionType.DELETE && toInfo.type == RegionType.INSERT) {
            LineOnOtherInfo infoOnSideB = manager.lineMapper.lineOnOther(DisplaySide.A, fromInfo.line);
            int startLineOnSideB = infoOnSideB.getLine();
            if (infoOnSideB.isAligned()) {
                from.line(startLineOnSideB);
            } else {
                from.line(startLineOnSideB + 1);
            }
            from.ch(0);
            to.line(toInfo.line);
        } else if (fromInfo.type == RegionType.DELETE && toInfo.type == RegionType.COMMON) {
            int toLineOnSideA = manager.lineMapper.lineOnOther(DisplaySide.B, toInfo.line).getLine();
            from.line(fromInfo.line);
            // Force the end line to be on the same side as the start line.
            to.line(toLineOnSideA);
            side = DisplaySide.A;
        } else {
            // Common case
            from.line(fromInfo.line);
            to.line(toInfo.line);
        }
        addDraftBox(side, CommentInfo.create(getPath(), getStoredSideFromDisplaySide(side), to.line() + 1, CommentRange.create(fromTo), false)).setEdit(true);
        cm.setCursor(Pos.create(host.getCmLine(to.line(), side), to.ch()));
        cm.setSelection(cm.getCursor());
    } else {
        int cmLine = cm.getLineNumber(cm.extras().activeLine());
        LineRegionInfo info = ((Unified) host).getLineRegionInfoFromCmLine(cmLine);
        insertNewDraft(info.getSide(), cmLine + 1);
    }
}
#end_block

#method_before
public RestResponse get(String endPoint) throws IOException {
    return getWithHeader(endPoint, null);
}
#method_after
public RestResponse get(String endPoint, int expectedStatus) throws Exception {
    RestResponse r = get(endPoint);
    r.assertStatus(expectedStatus);
    return r;
}
#end_block

#method_before
public RestResponse post(String endPoint, Object content) throws IOException {
    return postWithHeader(endPoint, content, null);
}
#method_after
public RestResponse post(String endPoint, Object content, int expectedStatus) throws Exception {
    RestResponse r = post(endPoint, content);
    r.assertStatus(expectedStatus);
    return r;
}
#end_block

#method_before
public FluentIterable<WebLinkInfo> getPatchSetLinks(Project.NameKey project, String commit) {
    return filterLinks(patchSetLinks, webLink -> webLink.getPatchSetWebLink(project.get(), commit));
}
#method_after
public List<WebLinkInfo> getPatchSetLinks(Project.NameKey project, String commit) {
    return filterLinks(patchSetLinks, webLink -> webLink.getPatchSetWebLink(project.get(), commit));
}
#end_block

#method_before
public FluentIterable<WebLinkInfo> getFileLinks(String project, String revision, String file) {
    return filterLinks(fileLinks, webLink -> webLink.getFileWebLink(project, revision, file));
}
#method_after
public List<WebLinkInfo> getFileLinks(String project, String revision, String file) {
    return filterLinks(fileLinks, webLink -> webLink.getFileWebLink(project, revision, file));
}
#end_block

#method_before
public FluentIterable<WebLinkInfo> getFileHistoryLinks(String project, String revision, String file) {
    return filterLinks(fileHistoryLinks, webLink -> webLink.getFileHistoryWebLink(project, revision, file));
}
#method_after
public List<WebLinkInfoCommon> getFileHistoryLinks(String project, String revision, String file) {
    return FluentIterable.from(fileHistoryLinks).transform(webLink -> {
        WebLinkInfo info = webLink.getFileHistoryWebLink(project, revision, file);
        if (info == null) {
            return null;
        }
        WebLinkInfoCommon commonInfo = new WebLinkInfoCommon();
        commonInfo.name = info.name;
        commonInfo.imageUrl = info.imageUrl;
        commonInfo.url = info.url;
        commonInfo.target = info.target;
        return commonInfo;
    }).filter(INVALID_WEBLINK_COMMON).toList();
}
#end_block

#method_before
public FluentIterable<DiffWebLinkInfo> getDiffLinks(final String project, final int changeId, final Integer patchSetIdA, final String revisionA, final String fileA, final int patchSetIdB, final String revisionB, final String fileB) {
    return FluentIterable.from(diffLinks).transform(webLink -> webLink.getDiffLink(project, changeId, patchSetIdA, revisionA, fileA, patchSetIdB, revisionB, fileB)).filter(INVALID_WEBLINK);
}
#method_after
public List<DiffWebLinkInfo> getDiffLinks(final String project, final int changeId, final Integer patchSetIdA, final String revisionA, final String fileA, final int patchSetIdB, final String revisionB, final String fileB) {
    return FluentIterable.from(diffLinks).transform(webLink -> webLink.getDiffLink(project, changeId, patchSetIdA, revisionA, fileA, patchSetIdB, revisionB, fileB)).filter(INVALID_WEBLINK).toList();
}
#end_block

#method_before
public FluentIterable<WebLinkInfo> getProjectLinks(final String project) {
    return filterLinks(projectLinks, webLink -> webLink.getProjectWeblink(project));
}
#method_after
public List<WebLinkInfo> getProjectLinks(final String project) {
    return filterLinks(projectLinks, webLink -> webLink.getProjectWeblink(project));
}
#end_block

#method_before
public FluentIterable<WebLinkInfo> getBranchLinks(final String project, final String branch) {
    return filterLinks(branchLinks, webLink -> webLink.getBranchWebLink(project, branch));
}
#method_after
public List<WebLinkInfo> getBranchLinks(final String project, final String branch) {
    return filterLinks(branchLinks, webLink -> webLink.getBranchWebLink(project, branch));
}
#end_block

#method_before
private <T extends WebLink> FluentIterable<WebLinkInfo> filterLinks(DynamicSet<T> links, Function<T, WebLinkInfo> transformer) {
    return FluentIterable.from(links).transform(transformer).filter(INVALID_WEBLINK);
}
#method_after
private <T extends WebLink> List<WebLinkInfo> filterLinks(DynamicSet<T> links, Function<T, WebLinkInfo> transformer) {
    return FluentIterable.from(links).transform(transformer).filter(INVALID_WEBLINK).toList();
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException, IOException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<Account.Id, AccountGroupMember> members = getMembers(internalGroup.getId());
    final List<AccountGroupMember> toRemove = new LinkedList<>();
    for (final String nameOrEmail : input.members) {
        Account a = accounts.parse(nameOrEmail).getAccount();
        if (!control.canRemoveMember()) {
            throw new AuthException("Cannot delete member: " + a.getFullName());
        }
        final AccountGroupMember m = members.remove(a.getId());
        if (m != null) {
            toRemove.add(m);
        }
    }
    writeAudits(toRemove);
    db.get().accountGroupMembers().delete(toRemove);
    for (final AccountGroupMember m : toRemove) {
        accountCache.evict(m.getAccountId());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException, IOException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<Account.Id, AccountGroupMember> members = getMembers(internalGroup.getId());
    final List<AccountGroupMember> toRemove = new ArrayList<>();
    for (final String nameOrEmail : input.members) {
        Account a = accounts.parse(nameOrEmail).getAccount();
        if (!control.canRemoveMember()) {
            throw new AuthException("Cannot delete member: " + a.getFullName());
        }
        final AccountGroupMember m = members.remove(a.getId());
        if (m != null) {
            toRemove.add(m);
        }
    }
    writeAudits(toRemove);
    db.get().accountGroupMembers().delete(toRemove);
    for (final AccountGroupMember m : toRemove) {
        accountCache.evict(m.getAccountId());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username, fetchMemberOfEagerly);
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword()).close();
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // 
            if (fetchMemberOfEagerly) {
                membershipCache.put(username, helper.queryForGroups(ctx, username, m));
            }
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#method_after
@Override
public AuthRequest authenticate(final AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username, fetchMemberOfEagerly);
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword()).close();
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // 
            if (fetchMemberOfEagerly || mandatoryGroup != null) {
                Set<AccountGroup.UUID> groups = helper.queryForGroups(ctx, username, m);
                if (mandatoryGroup != null) {
                    GroupReference mandatoryGroupRef = GroupBackends.findExactSuggestion(groupBackend, mandatoryGroup);
                    if (mandatoryGroupRef == null) {
                        throw new AccountException("Could not identify mandatory group: " + mandatoryGroup);
                    }
                    if (!groups.contains(mandatoryGroupRef.getUUID())) {
                        throw new AccountException("Not member of mandatory LDAP group: " + mandatoryGroupRef.getName());
                    }
                }
                // Regardless if we enabled fetchMemberOfEagerly, we already have the
                // groups and it would be a waste not to cache them.
                membershipCache.put(username, groups);
            }
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
private BinaryResult getBundles(RevisionResource rsrc, final ArchiveFormat f) throws OrmException, RestApiException {
    ReviewDb db = dbProvider.get();
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    BinaryResult bin;
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        final MergeOpRepoManager orm = op.getMergeOpRepoManager();
        final Set<Project.NameKey> projects = op.getAllProjects();
        bin = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                ArchiveOutputStream aos = f.createArchiveOutputStream(out);
                for (Project.NameKey p : projects) {
                    OpenRepo or = orm.getRepo(p);
                    BundleWriter bw = new BundleWriter(or.getRepo());
                    bw.setObjectCountCallback(null);
                    bw.setPackConfig(null);
                    Collection<ReceiveCommand> refs = or.getUpdate().getRefUpdates();
                    for (ReceiveCommand r : refs) {
                        bw.include(r.getRefName(), r.getNewId());
                        if (!r.getOldId().equals(ObjectId.zeroId())) {
                            bw.assume(or.getCodeReviewRevWalk().parseCommit(r.getOldId()));
                        }
                    }
                    // This naming scheme cannot produce directory/file conflicts
                    // as no projects contains ".git/":
                    aos.putArchiveEntry(f.prepareArchiveEntry(p.get() + ".git"));
                    bw.writeBundle(NullProgressMonitor.INSTANCE, aos);
                    aos.closeArchiveEntry();
                }
                aos.finish();
            }
        };
    }
    return bin;
}
#method_after
private BinaryResult getBundles(RevisionResource rsrc, final ArchiveFormat f) throws OrmException, RestApiException {
    ReviewDb db = dbProvider.get();
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    BinaryResult bin;
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        final MergeOpRepoManager orm = op.getMergeOpRepoManager();
        final Set<Project.NameKey> projects = op.getAllProjects();
        bin = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try (ArchiveOutputStream aos = f.createArchiveOutputStream(out)) {
                    for (Project.NameKey p : projects) {
                        OpenRepo or = orm.getRepo(p);
                        BundleWriter bw = new BundleWriter(or.getRepo());
                        bw.setObjectCountCallback(null);
                        bw.setPackConfig(null);
                        Collection<ReceiveCommand> refs = or.getUpdate().getRefUpdates();
                        for (ReceiveCommand r : refs) {
                            bw.include(r.getRefName(), r.getNewId());
                            ObjectId oldId = r.getOldId();
                            if (!oldId.equals(ObjectId.zeroId())) {
                                bw.assume(or.getCodeReviewRevWalk().parseCommit(oldId));
                            }
                        }
                        // This naming scheme cannot produce directory/file conflicts
                        // as no projects contains ".git/":
                        String path = p.get() + ".git";
                        LimitedByteArrayOutputStream bos = new LimitedByteArrayOutputStream(maxBundleSize, 1024);
                        bw.writeBundle(NullProgressMonitor.INSTANCE, bos);
                        f.putEntry(aos, path, bos.toByteArray());
                    }
                } catch (LimitExceededException e) {
                    throw new NotImplementedException("The bundle is too big to " + "generate at the server");
                }
            }
        };
    }
    return bin;
}
#end_block

#method_before
public AccountInfo accountInfo(Account a) {
    if (a == null || a.getId() == null) {
        return null;
    }
    return AccountJson.toAccountInfo(a);
}
#method_after
public AccountInfo accountInfo(Account a) {
    if (a == null || a.getId() == null) {
        return null;
    }
    AccountInfo accountInfo = new AccountInfo(a.getId().get());
    accountInfo.email = a.getPreferredEmail();
    accountInfo.name = a.getFullName();
    accountInfo.username = a.getUserName();
    return accountInfo;
}
#end_block

#method_before
public Map<String, ApprovalInfo> approvals(Account a, Map<String, Short> approvals, Timestamp ts) {
    Map<String, ApprovalInfo> result = new HashMap<>();
    for (Map.Entry<String, Short> e : approvals.entrySet()) {
        Integer value = e.getValue() != null ? Integer.valueOf(e.getValue()) : null;
        result.put(e.getKey(), ChangeJson.getApprovalInfo(a.getId(), value, null, ts));
    }
    return result;
}
#method_after
public Map<String, ApprovalInfo> approvals(Account a, Map<String, Short> approvals, Timestamp ts) {
    Map<String, ApprovalInfo> result = new HashMap<>();
    for (Map.Entry<String, Short> e : approvals.entrySet()) {
        Integer value = e.getValue() != null ? Integer.valueOf(e.getValue()) : null;
        result.put(e.getKey(), ChangeJson.getApprovalInfo(a.getId(), value, null, null, ts));
    }
    return result;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.get()).isEqualTo(NoteDbMode.READ_WRITE);
    db = ReviewDbUtil.unwrapDb(db);
}
#method_after
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.get()).isEqualTo(NoteDbMode.READ_WRITE);
    db = ReviewDbUtil.unwrapDb(db);
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    migrator = newMigrator(null);
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    if (args.mergeTip.getInitialTip() == null || !args.submoduleOp.hasSubscription(args.destBranch)) {
        CodeReviewCommit firstFastForward = args.mergeUtil.getFirstFastForward(args.mergeTip.getInitialTip(), args.rw, sorted);
        if (firstFastForward != null && !firstFastForward.equals(args.mergeTip.getInitialTip())) {
            ops.add(new FastForwardOp(args, firstFastForward));
        }
    }
    // For every other commit do a pair-wise merge.
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        ops.add(new MergeOneOp(args, n));
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge, args.incoming);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    if (args.mergeTip.getInitialTip() == null || !args.submoduleOp.hasSubscription(args.destBranch)) {
        CodeReviewCommit firstFastForward = args.mergeUtil.getFirstFastForward(args.mergeTip.getInitialTip(), args.rw, sorted);
        if (firstFastForward != null && !firstFastForward.equals(args.mergeTip.getInitialTip())) {
            ops.add(new FastForwardOp(args, firstFastForward));
        }
    }
    // For every other commit do a pair-wise merge.
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        ops.add(new MergeOneOp(args, n));
    }
    return ops;
}
#end_block

#method_before
public BatchMetaDataUpdate openUpdate(final MetaDataUpdate update) throws IOException {
    final Repository db = update.getRepository();
    reader = db.newObjectReader();
    inserter = db.newObjectInserter();
    final RevWalk rw = new RevWalk(reader);
    final RevTree tree = revision != null ? rw.parseTree(revision) : null;
    newTree = readTree(tree);
    return new BatchMetaDataUpdate() {

        AnyObjectId src = revision;

        AnyObjectId srcTree = tree;

        @Override
        public void write(CommitBuilder commit) throws IOException {
            write(VersionedMetaData.this, commit);
        }

        private boolean doSave(VersionedMetaData config, CommitBuilder commit) throws IOException {
            DirCache nt = config.newTree;
            ObjectReader r = config.reader;
            ObjectInserter i = config.inserter;
            try {
                config.newTree = newTree;
                config.reader = reader;
                config.inserter = inserter;
                return config.onSave(commit);
            } catch (ConfigInvalidException e) {
                throw new IOException("Cannot update " + getRefName() + " in " + db.getDirectory() + ": " + e.getMessage(), e);
            } finally {
                config.newTree = nt;
                config.reader = r;
                config.inserter = i;
            }
        }

        @Override
        public void write(VersionedMetaData config, CommitBuilder commit) throws IOException {
            if (!doSave(config, commit)) {
                return;
            }
            // Reuse tree from parent commit unless there are contents in newTree or
            // there is no tree for a parent commit.
            ObjectId res = newTree.getEntryCount() != 0 || srcTree == null ? newTree.writeTree(inserter) : srcTree.copy();
            if (res.equals(srcTree) && !update.allowEmpty() && (commit.getTreeId() == null)) {
                // If there are no changes to the content, don't create the commit.
                return;
            }
            // the tree for the updated DirCache.
            if (commit.getTreeId() == null) {
                commit.setTreeId(res);
            } else {
                // In this case, the caller populated the tree without using DirCache.
                res = commit.getTreeId();
            }
            if (src != null) {
                commit.addParentId(src);
            }
            if (update.insertChangeId()) {
                ObjectId id = ChangeIdUtil.computeChangeId(res, getRevision(), commit.getAuthor(), commit.getCommitter(), commit.getMessage());
                commit.setMessage(ChangeIdUtil.insertId(commit.getMessage(), id));
            }
            src = inserter.insert(commit);
            srcTree = res;
        }

        @Override
        public RevCommit createRef(String refName) throws IOException {
            if (Objects.equals(src, revision)) {
                return revision;
            }
            return updateRef(ObjectId.zeroId(), src, refName);
        }

        @Override
        public void removeRef(String refName) throws IOException {
            RefUpdate ru = db.updateRef(refName);
            ru.setForceUpdate(true);
            if (revision != null) {
                ru.setExpectedOldObjectId(revision);
            }
            RefUpdate.Result result = ru.delete();
            switch(result) {
                case FORCED:
                    update.fireGitRefUpdatedEvent(ru);
                    return;
                case FAST_FORWARD:
                case IO_FAILURE:
                case LOCK_FAILURE:
                case NEW:
                case NOT_ATTEMPTED:
                case NO_CHANGE:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    throw new IOException("Cannot delete " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
            }
        }

        @Override
        public RevCommit commit() throws IOException {
            return commitAt(revision);
        }

        @Override
        public RevCommit commitAt(ObjectId expected) throws IOException {
            if (Objects.equals(src, expected)) {
                return revision;
            }
            return updateRef(MoreObjects.firstNonNull(expected, ObjectId.zeroId()), src, getRefName());
        }

        @Override
        public void close() {
            newTree = null;
            rw.close();
            if (inserter != null) {
                inserter.close();
                inserter = null;
            }
            if (reader != null) {
                reader.close();
                reader = null;
            }
        }

        private RevCommit updateRef(AnyObjectId oldId, AnyObjectId newId, String refName) throws IOException {
            BatchRefUpdate bru = update.getBatch();
            if (bru != null) {
                bru.addCommand(new ReceiveCommand(oldId.toObjectId(), newId.toObjectId(), refName));
                inserter.flush();
                revision = rw.parseCommit(newId);
                return revision;
            }
            RefUpdate ru = db.updateRef(refName);
            ru.setExpectedOldObjectId(oldId);
            ru.setNewObjectId(src);
            ru.setRefLogIdent(update.getCommitBuilder().getAuthor());
            String message = update.getCommitBuilder().getMessage();
            if (message == null) {
                message = "meta data update";
            }
            try (BufferedReader reader = new BufferedReader(new StringReader(message))) {
                // read the subject line and use it as reflog message
                ru.setRefLogMessage("commit: " + reader.readLine(), true);
            }
            inserter.flush();
            RefUpdate.Result result = ru.update();
            switch(result) {
                case NEW:
                case FAST_FORWARD:
                    revision = rw.parseCommit(ru.getNewObjectId());
                    update.fireGitRefUpdatedEvent(ru);
                    return revision;
                case FORCED:
                case IO_FAILURE:
                case LOCK_FAILURE:
                case NOT_ATTEMPTED:
                case NO_CHANGE:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    throw new IOException("Cannot update " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
            }
        }
    };
}
#method_after
public BatchMetaDataUpdate openUpdate(final MetaDataUpdate update) throws IOException {
    final Repository db = update.getRepository();
    reader = db.newObjectReader();
    inserter = db.newObjectInserter();
    final RevWalk rw = new RevWalk(reader);
    final RevTree tree = revision != null ? rw.parseTree(revision) : null;
    newTree = readTree(tree);
    return new BatchMetaDataUpdate() {

        AnyObjectId src = revision;

        AnyObjectId srcTree = tree;

        @Override
        public void write(CommitBuilder commit) throws IOException {
            write(VersionedMetaData.this, commit);
        }

        private boolean doSave(VersionedMetaData config, CommitBuilder commit) throws IOException {
            DirCache nt = config.newTree;
            ObjectReader r = config.reader;
            ObjectInserter i = config.inserter;
            try {
                config.newTree = newTree;
                config.reader = reader;
                config.inserter = inserter;
                return config.onSave(commit);
            } catch (ConfigInvalidException e) {
                throw new IOException("Cannot update " + getRefName() + " in " + db.getDirectory() + ": " + e.getMessage(), e);
            } finally {
                config.newTree = nt;
                config.reader = r;
                config.inserter = i;
            }
        }

        @Override
        public void write(VersionedMetaData config, CommitBuilder commit) throws IOException {
            if (!doSave(config, commit)) {
                return;
            }
            // Reuse tree from parent commit unless there are contents in newTree or
            // there is no tree for a parent commit.
            ObjectId res = newTree.getEntryCount() != 0 || srcTree == null ? newTree.writeTree(inserter) : srcTree.copy();
            if (res.equals(srcTree) && !update.allowEmpty() && (commit.getTreeId() == null)) {
                // If there are no changes to the content, don't create the commit.
                return;
            }
            // the tree for the updated DirCache.
            if (commit.getTreeId() == null) {
                commit.setTreeId(res);
            } else {
                // In this case, the caller populated the tree without using DirCache.
                res = commit.getTreeId();
            }
            if (src != null) {
                commit.addParentId(src);
            }
            if (update.insertChangeId()) {
                ObjectId id = ChangeIdUtil.computeChangeId(res, getRevision(), commit.getAuthor(), commit.getCommitter(), commit.getMessage());
                commit.setMessage(ChangeIdUtil.insertId(commit.getMessage(), id));
            }
            src = inserter.insert(commit);
            srcTree = res;
        }

        @Override
        public RevCommit createRef(String refName) throws IOException {
            if (Objects.equals(src, revision)) {
                return revision;
            }
            return updateRef(ObjectId.zeroId(), src, refName);
        }

        @Override
        public void removeRef(String refName) throws IOException {
            RefUpdate ru = db.updateRef(refName);
            ru.setForceUpdate(true);
            if (revision != null) {
                ru.setExpectedOldObjectId(revision);
            }
            RefUpdate.Result result = ru.delete();
            switch(result) {
                case FORCED:
                    update.fireGitRefUpdatedEvent(ru);
                    return;
                case LOCK_FAILURE:
                    throw new LockFailureException("Cannot delete " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
                case FAST_FORWARD:
                case IO_FAILURE:
                case NEW:
                case NOT_ATTEMPTED:
                case NO_CHANGE:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    throw new IOException("Cannot delete " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
            }
        }

        @Override
        public RevCommit commit() throws IOException {
            return commitAt(revision);
        }

        @Override
        public RevCommit commitAt(ObjectId expected) throws IOException {
            if (Objects.equals(src, expected)) {
                return revision;
            }
            return updateRef(MoreObjects.firstNonNull(expected, ObjectId.zeroId()), src, getRefName());
        }

        @Override
        public void close() {
            newTree = null;
            rw.close();
            if (inserter != null) {
                inserter.close();
                inserter = null;
            }
            if (reader != null) {
                reader.close();
                reader = null;
            }
        }

        private RevCommit updateRef(AnyObjectId oldId, AnyObjectId newId, String refName) throws IOException {
            BatchRefUpdate bru = update.getBatch();
            if (bru != null) {
                bru.addCommand(new ReceiveCommand(oldId.toObjectId(), newId.toObjectId(), refName));
                inserter.flush();
                revision = rw.parseCommit(newId);
                return revision;
            }
            RefUpdate ru = db.updateRef(refName);
            ru.setExpectedOldObjectId(oldId);
            ru.setNewObjectId(src);
            ru.setRefLogIdent(update.getCommitBuilder().getAuthor());
            String message = update.getCommitBuilder().getMessage();
            if (message == null) {
                message = "meta data update";
            }
            try (BufferedReader reader = new BufferedReader(new StringReader(message))) {
                // read the subject line and use it as reflog message
                ru.setRefLogMessage("commit: " + reader.readLine(), true);
            }
            inserter.flush();
            RefUpdate.Result result = ru.update();
            switch(result) {
                case NEW:
                case FAST_FORWARD:
                    revision = rw.parseCommit(ru.getNewObjectId());
                    update.fireGitRefUpdatedEvent(ru);
                    return revision;
                case LOCK_FAILURE:
                    throw new LockFailureException("Cannot update " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case NO_CHANGE:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    throw new IOException("Cannot update " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
            }
        }
    };
}
#end_block

#method_before
protected Config readConfig(String fileName) throws IOException, ConfigInvalidException {
    Config rc = new Config();
    String text = readUTF8(fileName);
    if (!text.isEmpty()) {
        try {
            rc.fromText(text);
        } catch (ConfigInvalidException err) {
            throw new ConfigInvalidException("Invalid config file " + fileName + " in commit " + revision.name(), err);
        }
    }
    return rc;
}
#method_after
protected Config readConfig(String fileName) throws IOException, ConfigInvalidException {
    Config rc = new Config();
    String text = readUTF8(fileName);
    if (!text.isEmpty()) {
        try {
            rc.fromText(text);
        } catch (ConfigInvalidException err) {
            StringBuilder msg = new StringBuilder("Invalid config file ").append(fileName).append(" in commit ").append(revision.name());
            if (err.getCause() != null) {
                msg.append(": ").append(err.getCause());
            }
            throw new ConfigInvalidException(msg.toString(), err);
        }
    }
    return rc;
}
#end_block

#method_before
public List<PathInfo> getPathInfos(boolean recursive) throws IOException {
    TreeWalk tw = new TreeWalk(reader);
    tw.addTree(revision.getTree());
    tw.setRecursive(recursive);
    List<PathInfo> paths = new ArrayList<>();
    while (tw.next()) {
        paths.add(new PathInfo(tw));
    }
    return paths;
}
#method_after
public List<PathInfo> getPathInfos(boolean recursive) throws IOException {
    try (TreeWalk tw = new TreeWalk(reader)) {
        tw.addTree(revision.getTree());
        tw.setRecursive(recursive);
        List<PathInfo> paths = new ArrayList<>();
        while (tw.next()) {
            paths.add(new PathInfo(tw));
        }
        return paths;
    }
}
#end_block

#method_before
@Override
public SiteIndexer.Result indexAll(final AccountIndex index) {
    ProgressMonitor progress = new TextProgressMonitor(new PrintWriter(progressOut));
    progress.start(2);
    Stopwatch sw = Stopwatch.createStarted();
    List<Account.Id> ids;
    try {
        ids = collectAccounts(progress);
    } catch (OrmException e) {
        log.error("Error collecting accounts", e);
        return new Result(sw, false, 0, 0);
    }
    return reindexAccounts(index, ids, progress);
}
#method_after
@Override
public SiteIndexer.Result indexAll(final AccountIndex index) {
    ProgressMonitor progress = new TextProgressMonitor(new PrintWriter(progressOut));
    progress.start(2);
    Stopwatch sw = Stopwatch.createStarted();
    List<Account.Id> ids;
    try {
        ids = collectAccounts(progress);
    } catch (OrmException e) {
        log.error("Error collecting accounts", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    return reindexAccounts(index, ids, progress);
}
#end_block

#method_before
private SiteIndexer.Result reindexAccounts(final AccountIndex index, List<Account.Id> ids, ProgressMonitor progress) {
    progress.beginTask("Reindexing accounts", ids.size());
    List<ListenableFuture<?>> futures = new ArrayList<>(ids.size());
    AtomicBoolean ok = new AtomicBoolean(true);
    final AtomicInteger done = new AtomicInteger();
    final AtomicInteger failed = new AtomicInteger();
    Stopwatch sw = Stopwatch.createStarted();
    for (final Account.Id id : ids) {
        final String desc = "account " + id;
        ListenableFuture<?> future = executor.submit(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                try {
                    accountCache.evict(id);
                    index.replace(accountCache.get(id));
                    if (verboseWriter != null) {
                        verboseWriter.println("Reindexed " + desc);
                    }
                    done.incrementAndGet();
                } catch (Exception e) {
                    failed.incrementAndGet();
                    throw e;
                }
                return null;
            }
        });
        addErrorListener(future, desc, progress, ok);
        futures.add(future);
    }
    try {
        Futures.successfulAsList(futures).get();
    } catch (ExecutionException | InterruptedException e) {
        log.error("Error waiting on account futures", e);
        return new Result(sw, false, 0, 0);
    }
    progress.endTask();
    return new Result(sw, ok.get(), done.get(), failed.get());
}
#method_after
private SiteIndexer.Result reindexAccounts(final AccountIndex index, List<Account.Id> ids, ProgressMonitor progress) {
    progress.beginTask("Reindexing accounts", ids.size());
    List<ListenableFuture<?>> futures = new ArrayList<>(ids.size());
    AtomicBoolean ok = new AtomicBoolean(true);
    final AtomicInteger done = new AtomicInteger();
    final AtomicInteger failed = new AtomicInteger();
    Stopwatch sw = Stopwatch.createStarted();
    for (final Account.Id id : ids) {
        final String desc = "account " + id;
        ListenableFuture<?> future = executor.submit(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                try {
                    accountCache.evict(id);
                    index.replace(accountCache.get(id));
                    verboseWriter.println("Reindexed " + desc);
                    done.incrementAndGet();
                } catch (Exception e) {
                    failed.incrementAndGet();
                    throw e;
                }
                return null;
            }
        });
        addErrorListener(future, desc, progress, ok);
        futures.add(future);
    }
    try {
        Futures.successfulAsList(futures).get();
    } catch (ExecutionException | InterruptedException e) {
        log.error("Error waiting on account futures", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    progress.endTask();
    return new SiteIndexer.Result(sw, ok.get(), done.get(), failed.get());
}
#end_block

#method_before
@Override
protected String getRefName() {
    return RefNames.refsDraftComments(getChangeId(), author);
}
#method_after
@Override
protected String getRefName() {
    return refsDraftComments(getChangeId(), author);
}
#end_block

#method_before
@Override
protected void onLoad(LoadHandle handle) throws IOException, ConfigInvalidException {
    ObjectId rev = handle.id();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevCommit tipCommit = handle.walk().parseCommit(rev);
    ObjectReader reader = handle.walk().getObjectReader();
    revisionNoteMap = RevisionNoteMap.parse(args.noteUtil, getChangeId(), reader, NoteMap.read(reader, tipCommit), PatchLineComment.Status.DRAFT);
    Multimap<RevId, Comment> cs = ArrayListMultimap.create();
    for (ChangeRevisionNote rn : revisionNoteMap.revisionNotes.values()) {
        for (Comment c : rn.getComments()) {
            cs.put(new RevId(c.revId), c);
        }
    }
    comments = ImmutableListMultimap.copyOf(cs);
}
#method_after
@Override
protected void onLoad(LoadHandle handle) throws IOException, ConfigInvalidException {
    ObjectId rev = handle.id();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevCommit tipCommit = handle.walk().parseCommit(rev);
    ObjectReader reader = handle.walk().getObjectReader();
    revisionNoteMap = RevisionNoteMap.parse(args.noteUtil, getChangeId(), reader, NoteMap.read(reader, tipCommit), PatchLineComment.Status.DRAFT);
    ListMultimap<RevId, Comment> cs = MultimapBuilder.hashKeys().arrayListValues().build();
    for (ChangeRevisionNote rn : revisionNoteMap.revisionNotes.values()) {
        for (Comment c : rn.getComments()) {
            cs.put(new RevId(c.revId), c);
        }
    }
    comments = ImmutableListMultimap.copyOf(cs);
}
#end_block

#method_before
@Override
protected LoadHandle openHandle(Repository repo) throws IOException {
    if (rebuildResult != null) {
        StagedResult sr = checkNotNull(rebuildResult.staged());
        return LoadHandle.create(ChangeNotesCommit.newStagedRevWalk(repo, sr.allUsersObjects()), findNewId(sr.allUsersCommands(), getRefName()));
    } else if (change != null && autoRebuild) {
        NoteDbChangeState state = NoteDbChangeState.parse(change);
        // reading unnecessary refs.
        if (!NoteDbChangeState.areDraftsUpToDate(state, new RepoRefCache(repo), getChangeId(), author)) {
            return rebuildAndOpen(repo);
        }
    }
    return super.openHandle(repo);
}
#method_after
@Override
protected LoadHandle openHandle(Repository repo) throws NoSuchChangeException, IOException {
    if (rebuildResult != null) {
        StagedResult sr = checkNotNull(rebuildResult.staged());
        return LoadHandle.create(ChangeNotesCommit.newStagedRevWalk(repo, sr.allUsersObjects()), findNewId(sr.allUsersCommands(), getRefName()));
    } else if (change != null && autoRebuild) {
        NoteDbChangeState state = NoteDbChangeState.parse(change);
        // reading unnecessary refs.
        if (!NoteDbChangeState.areDraftsUpToDate(state, new RepoRefCache(repo), getChangeId(), author)) {
            return rebuildAndOpen(repo);
        }
    }
    return super.openHandle(repo);
}
#end_block

#method_before
private LoadHandle rebuildAndOpen(Repository repo) throws IOException {
    Timer1.Context timer = args.metrics.autoRebuildLatency.start(CHANGES);
    try {
        Change.Id cid = getChangeId();
        ReviewDb db = args.db.get();
        ChangeRebuilder rebuilder = args.rebuilder.get();
        NoteDbUpdateManager.Result r;
        try (NoteDbUpdateManager manager = rebuilder.stage(db, cid)) {
            if (manager == null) {
                // May be null in tests.
                return super.openHandle(repo);
            }
            r = manager.stageAndApplyDelta(change);
            try {
                rebuilder.execute(db, cid, manager);
                repo.scanForRepoChanges();
            } catch (OrmException | IOException e) {
                // See ChangeNotes#rebuildAndOpen.
                log.debug("Rebuilding change {} via drafts failed: {}", getChangeId(), e.getMessage());
                args.metrics.autoRebuildFailureCount.increment(CHANGES);
                checkNotNull(r.staged());
                return LoadHandle.create(ChangeNotesCommit.newStagedRevWalk(repo, r.staged().allUsersObjects()), draftsId(r));
            }
        }
        return LoadHandle.create(ChangeNotesCommit.newRevWalk(repo), draftsId(r));
    } catch (NoSuchChangeException e) {
        return super.openHandle(repo);
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        log.debug("Rebuilt change {} in {} in {} ms via drafts", getChangeId(), change != null ? "project " + change.getProject() : "unknown project", TimeUnit.MILLISECONDS.convert(timer.stop(), TimeUnit.NANOSECONDS));
    }
}
#method_after
private LoadHandle rebuildAndOpen(Repository repo) throws NoSuchChangeException, IOException {
    Timer1.Context timer = args.metrics.autoRebuildLatency.start(CHANGES);
    try {
        Change.Id cid = getChangeId();
        ReviewDb db = args.db.get();
        ChangeRebuilder rebuilder = args.rebuilder.get();
        NoteDbUpdateManager.Result r;
        try (NoteDbUpdateManager manager = rebuilder.stage(db, cid)) {
            if (manager == null) {
                // May be null in tests.
                return super.openHandle(repo);
            }
            r = manager.stageAndApplyDelta(change);
            try {
                rebuilder.execute(db, cid, manager);
                repo.scanForRepoChanges();
            } catch (OrmException | IOException e) {
                // See ChangeNotes#rebuildAndOpen.
                log.debug("Rebuilding change {} via drafts failed: {}", getChangeId(), e.getMessage());
                args.metrics.autoRebuildFailureCount.increment(CHANGES);
                checkNotNull(r.staged());
                return LoadHandle.create(ChangeNotesCommit.newStagedRevWalk(repo, r.staged().allUsersObjects()), draftsId(r));
            }
        }
        return LoadHandle.create(ChangeNotesCommit.newRevWalk(repo), draftsId(r));
    } catch (NoSuchChangeException e) {
        return super.openHandle(repo);
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        log.debug("Rebuilt change {} in {} in {} ms via drafts", getChangeId(), change != null ? "project " + change.getProject() : "unknown project", TimeUnit.MILLISECONDS.convert(timer.stop(), TimeUnit.NANOSECONDS));
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    for (Project.NameKey projectName : repoManager.list()) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfig config = ProjectConfig.read(md);
            if (config.hasLegacyPermissions()) {
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                md.setMessage(COMMIT_MSG);
                config.commit(md);
            }
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException("Cannot migrate project " + projectName, ex);
        }
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    SortedSet<Project.NameKey> repoList = repoManager.list();
    SortedSet<Project.NameKey> repoUpgraded = new TreeSet<>();
    ui.message("\tMigrating " + repoList.size() + " repositories ...");
    for (Project.NameKey projectName : repoList) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfig config = ProjectConfig.read(md);
            if (config.hasLegacyPermissions()) {
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                md.setMessage(COMMIT_MSG);
                config.commit(md);
                repoUpgraded.add(projectName);
            }
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException("Cannot migrate project " + projectName, ex);
        }
    }
    ui.message("\tMigration completed:  " + repoUpgraded.size() + " repositories updated:");
    ui.message("\t" + repoUpgraded.stream().map(n -> n.get()).collect(Collectors.joining(" ")));
}
#end_block

#method_before
@Before
public void setup() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    // Overwrite "Code-Review" label that is inherited from All-Projects.
    // This way changes to the "Code Review" label don't affect other tests.
    LabelType codeReview = category("Code-Review", value(2, "Looks good to me, approved"), value(1, "Looks good to me, but someone else must approve"), value(0, "No score"), value(-1, "I would prefer that you didn't submit this"), value(-2, "Do not submit"));
    cfg.getLabelSections().put(codeReview.getName(), codeReview);
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(Util.codeReview().getName()), -2, 2, registeredUsers, heads);
    Util.allow(cfg, Permission.forLabel(Util.verified().getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
}
#method_after
@Before
public void setup() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    // Overwrite "Code-Review" label that is inherited from All-Projects.
    // This way changes to the "Code Review" label don't affect other tests.
    LabelType codeReview = category("Code-Review", value(2, "Looks good to me, approved"), value(1, "Looks good to me, but someone else must approve"), value(0, "No score"), value(-1, "I would prefer that you didn't submit this"), value(-2, "Do not submit"));
    codeReview.setCopyAllScoresIfNoChange(false);
    cfg.getLabelSections().put(codeReview.getName(), codeReview);
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    verified.setCopyAllScoresIfNoChange(false);
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(Util.codeReview().getName()), -2, 2, registeredUsers, heads);
    Util.allow(cfg, Permission.forLabel(Util.verified().getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
}
#end_block

#method_before
@Test
public void notSticky() throws Exception {
    assertNotSticky(EnumSet.of(REWORK, TRIVIAL_REBASE, NO_CODE_CHANGE, MERGE_FIRST_PARENT_UPDATE));
}
#method_after
@Test
public void notSticky() throws Exception {
    assertNotSticky(EnumSet.of(REWORK, TRIVIAL_REBASE, NO_CODE_CHANGE, MERGE_FIRST_PARENT_UPDATE, NO_CHANGE));
}
#end_block

#method_before
@Test
public void stickyOnMinScore() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyMinScore(true);
    saveProjectConfig(project, cfg);
    for (ChangeKind changeKind : EnumSet.of(REWORK, TRIVIAL_REBASE, NO_CODE_CHANGE, MERGE_FIRST_PARENT_UPDATE)) {
        testRepo.reset(getRemoteHead());
        String changeId = createChange(changeKind);
        vote(admin, changeId, -1, 1);
        vote(user, changeId, -2, -1);
        updateChange(changeId, changeKind);
        ChangeInfo c = detailedChange(changeId);
        assertVotes(c, admin, 0, 0, changeKind);
        assertVotes(c, user, -2, 0, changeKind);
    }
}
#method_after
@Test
public void stickyOnMinScore() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyMinScore(true);
    saveProjectConfig(project, cfg);
    for (ChangeKind changeKind : EnumSet.of(REWORK, TRIVIAL_REBASE, NO_CODE_CHANGE, MERGE_FIRST_PARENT_UPDATE, NO_CHANGE)) {
        testRepo.reset(getRemoteHead());
        String changeId = createChange(changeKind);
        vote(admin, changeId, -1, 1);
        vote(user, changeId, -2, -1);
        updateChange(changeId, changeKind);
        ChangeInfo c = detailedChange(changeId);
        assertVotes(c, admin, 0, 0, changeKind);
        assertVotes(c, user, -2, 0, changeKind);
    }
}
#end_block

#method_before
@Test
public void stickyOnMaxScore() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyMaxScore(true);
    saveProjectConfig(project, cfg);
    for (ChangeKind changeKind : EnumSet.of(REWORK, TRIVIAL_REBASE, NO_CODE_CHANGE, MERGE_FIRST_PARENT_UPDATE)) {
        testRepo.reset(getRemoteHead());
        String changeId = createChange(changeKind);
        vote(admin, changeId, 2, 1);
        vote(user, changeId, 1, -1);
        updateChange(changeId, changeKind);
        ChangeInfo c = detailedChange(changeId);
        assertVotes(c, admin, 2, 0, changeKind);
        assertVotes(c, user, 0, 0, changeKind);
    }
}
#method_after
@Test
public void stickyOnMaxScore() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyMaxScore(true);
    saveProjectConfig(project, cfg);
    for (ChangeKind changeKind : EnumSet.of(REWORK, TRIVIAL_REBASE, NO_CODE_CHANGE, MERGE_FIRST_PARENT_UPDATE, NO_CHANGE)) {
        testRepo.reset(getRemoteHead());
        String changeId = createChange(changeKind);
        vote(admin, changeId, 2, 1);
        vote(user, changeId, 1, -1);
        updateChange(changeId, changeKind);
        ChangeInfo c = detailedChange(changeId);
        assertVotes(c, admin, 2, 0, changeKind);
        assertVotes(c, user, 0, 0, changeKind);
    }
}
#end_block

#method_before
@Test
public void stickyOnTrivialRebase() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyAllScoresOnTrivialRebase(true);
    saveProjectConfig(project, cfg);
    String changeId = createChange(TRIVIAL_REBASE);
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    updateChange(changeId, TRIVIAL_REBASE);
    ChangeInfo c = detailedChange(changeId);
    assertVotes(c, admin, 2, 0, TRIVIAL_REBASE);
    assertVotes(c, user, -2, 0, TRIVIAL_REBASE);
    assertNotSticky(EnumSet.of(REWORK, NO_CODE_CHANGE, MERGE_FIRST_PARENT_UPDATE));
    // check that votes are sticky when trivial rebase is done by cherry-pick
    testRepo.reset(getRemoteHead());
    changeId = createChange().getChangeId();
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    String cherryPickChangeId = cherryPick(changeId, TRIVIAL_REBASE);
    c = detailedChange(cherryPickChangeId);
    assertVotes(c, admin, 2, 0);
    assertVotes(c, user, -2, 0);
    // check that votes are not sticky when rework is done by cherry-pick
    testRepo.reset(getRemoteHead());
    changeId = createChange().getChangeId();
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    cherryPickChangeId = cherryPick(changeId, REWORK);
    c = detailedChange(cherryPickChangeId);
    assertVotes(c, admin, 0, 0);
    assertVotes(c, user, 0, 0);
}
#method_after
@Test
public void stickyOnTrivialRebase() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyAllScoresOnTrivialRebase(true);
    saveProjectConfig(project, cfg);
    String changeId = createChange(TRIVIAL_REBASE);
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    updateChange(changeId, NO_CHANGE);
    ChangeInfo c = detailedChange(changeId);
    assertVotes(c, admin, 2, 0, NO_CHANGE);
    assertVotes(c, user, -2, 0, NO_CHANGE);
    updateChange(changeId, TRIVIAL_REBASE);
    c = detailedChange(changeId);
    assertVotes(c, admin, 2, 0, TRIVIAL_REBASE);
    assertVotes(c, user, -2, 0, TRIVIAL_REBASE);
    assertNotSticky(EnumSet.of(REWORK, NO_CODE_CHANGE, MERGE_FIRST_PARENT_UPDATE));
    // check that votes are sticky when trivial rebase is done by cherry-pick
    testRepo.reset(getRemoteHead());
    changeId = createChange().getChangeId();
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    String cherryPickChangeId = cherryPick(changeId, TRIVIAL_REBASE);
    c = detailedChange(cherryPickChangeId);
    assertVotes(c, admin, 2, 0);
    assertVotes(c, user, -2, 0);
    // check that votes are not sticky when rework is done by cherry-pick
    testRepo.reset(getRemoteHead());
    changeId = createChange().getChangeId();
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    cherryPickChangeId = cherryPick(changeId, REWORK);
    c = detailedChange(cherryPickChangeId);
    assertVotes(c, admin, 0, 0);
    assertVotes(c, user, 0, 0);
}
#end_block

#method_before
@Test
public void stickyOnNoCodeChange() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Verified").setCopyAllScoresIfNoCodeChange(true);
    saveProjectConfig(project, cfg);
    String changeId = createChange(NO_CODE_CHANGE);
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    updateChange(changeId, NO_CODE_CHANGE);
    ChangeInfo c = detailedChange(changeId);
    assertVotes(c, admin, 0, 1, NO_CODE_CHANGE);
    assertVotes(c, user, 0, -1, NO_CODE_CHANGE);
    assertNotSticky(EnumSet.of(REWORK, TRIVIAL_REBASE, MERGE_FIRST_PARENT_UPDATE));
}
#method_after
@Test
public void stickyOnNoCodeChange() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Verified").setCopyAllScoresIfNoCodeChange(true);
    saveProjectConfig(project, cfg);
    String changeId = createChange(NO_CODE_CHANGE);
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    updateChange(changeId, NO_CHANGE);
    ChangeInfo c = detailedChange(changeId);
    assertVotes(c, admin, 0, 1, NO_CHANGE);
    assertVotes(c, user, 0, -1, NO_CHANGE);
    updateChange(changeId, NO_CODE_CHANGE);
    c = detailedChange(changeId);
    assertVotes(c, admin, 0, 1, NO_CODE_CHANGE);
    assertVotes(c, user, 0, -1, NO_CODE_CHANGE);
    assertNotSticky(EnumSet.of(REWORK, TRIVIAL_REBASE, MERGE_FIRST_PARENT_UPDATE));
}
#end_block

#method_before
@Test
public void stickyOnMergeFirstParentUpdate() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyAllScoresOnMergeFirstParentUpdate(true);
    saveProjectConfig(project, cfg);
    String changeId = createChange(MERGE_FIRST_PARENT_UPDATE);
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    updateChange(changeId, MERGE_FIRST_PARENT_UPDATE);
    ChangeInfo c = detailedChange(changeId);
    assertVotes(c, admin, 2, 0, MERGE_FIRST_PARENT_UPDATE);
    assertVotes(c, user, -2, 0, MERGE_FIRST_PARENT_UPDATE);
    assertNotSticky(EnumSet.of(REWORK, NO_CODE_CHANGE, TRIVIAL_REBASE));
}
#method_after
@Test
public void stickyOnMergeFirstParentUpdate() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyAllScoresOnMergeFirstParentUpdate(true);
    saveProjectConfig(project, cfg);
    String changeId = createChange(MERGE_FIRST_PARENT_UPDATE);
    vote(admin, changeId, 2, 1);
    vote(user, changeId, -2, -1);
    updateChange(changeId, NO_CHANGE);
    ChangeInfo c = detailedChange(changeId);
    assertVotes(c, admin, 2, 0, NO_CHANGE);
    assertVotes(c, user, -2, 0, NO_CHANGE);
    updateChange(changeId, MERGE_FIRST_PARENT_UPDATE);
    c = detailedChange(changeId);
    assertVotes(c, admin, 2, 0, MERGE_FIRST_PARENT_UPDATE);
    assertVotes(c, user, -2, 0, MERGE_FIRST_PARENT_UPDATE);
    assertNotSticky(EnumSet.of(REWORK, NO_CODE_CHANGE, TRIVIAL_REBASE));
}
#end_block

#method_before
@Test
public void removedVotesNotSticky() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyAllScoresOnTrivialRebase(true);
    cfg.getLabelSections().get("Verified").setCopyAllScoresIfNoCodeChange(true);
    saveProjectConfig(project, cfg);
    for (ChangeKind changeKind : EnumSet.of(REWORK, TRIVIAL_REBASE, NO_CODE_CHANGE, MERGE_FIRST_PARENT_UPDATE)) {
        testRepo.reset(getRemoteHead());
        String changeId = createChange(changeKind);
        vote(admin, changeId, 2, 1);
        vote(user, changeId, -2, -1);
        // Remove votes by re-voting with 0
        vote(admin, changeId, 0, 0);
        vote(user, changeId, 0, 0);
        ChangeInfo c = detailedChange(changeId);
        assertVotes(c, admin, 0, 0, null);
        assertVotes(c, user, 0, 0, null);
        updateChange(changeId, changeKind);
        c = detailedChange(changeId);
        assertVotes(c, admin, 0, 0, changeKind);
        assertVotes(c, user, 0, 0, changeKind);
    }
}
#method_after
@Test
public void removedVotesNotSticky() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().get("Code-Review").setCopyAllScoresOnTrivialRebase(true);
    cfg.getLabelSections().get("Verified").setCopyAllScoresIfNoCodeChange(true);
    saveProjectConfig(project, cfg);
    for (ChangeKind changeKind : EnumSet.of(REWORK, TRIVIAL_REBASE, NO_CODE_CHANGE, MERGE_FIRST_PARENT_UPDATE, NO_CHANGE)) {
        testRepo.reset(getRemoteHead());
        String changeId = createChange(changeKind);
        vote(admin, changeId, 2, 1);
        vote(user, changeId, -2, -1);
        // Remove votes by re-voting with 0
        vote(admin, changeId, 0, 0);
        vote(user, changeId, 0, 0);
        ChangeInfo c = detailedChange(changeId);
        assertVotes(c, admin, 0, 0, null);
        assertVotes(c, user, 0, 0, null);
        updateChange(changeId, changeKind);
        c = detailedChange(changeId);
        assertVotes(c, admin, 0, 0, changeKind);
        assertVotes(c, user, 0, 0, changeKind);
    }
}
#end_block

#method_before
private void updateChange(String changeId, ChangeKind changeKind) throws Exception {
    switch(changeKind) {
        case NO_CODE_CHANGE:
            noCodeChange(changeId);
            return;
        case REWORK:
            rework(changeId);
            return;
        case TRIVIAL_REBASE:
            trivialRebase(changeId);
            return;
        case MERGE_FIRST_PARENT_UPDATE:
            updateFirstParent(changeId);
            return;
        case NO_CHANGE:
        default:
            fail("unexpected change kind: " + changeKind);
    }
}
#method_after
private void updateChange(String changeId, ChangeKind changeKind) throws Exception {
    switch(changeKind) {
        case NO_CODE_CHANGE:
            noCodeChange(changeId);
            return;
        case REWORK:
            rework(changeId);
            return;
        case TRIVIAL_REBASE:
            trivialRebase(changeId);
            return;
        case MERGE_FIRST_PARENT_UPDATE:
            updateFirstParent(changeId);
            return;
        case NO_CHANGE:
            noChange(changeId);
            return;
        default:
            fail("unexpected change kind: " + changeKind);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    correctBranch = refName.equals(change.getDest().get());
    if (!correctBranch) {
        return false;
    }
    if (patchSetProvider != null) {
        // Caller might have also arranged for construction of a new patch set
        // that is not present in the old notes so we can't use PatchSetUtil.
        patchSet = patchSetProvider.get();
    } else {
        patchSet = checkNotNull(psUtil.get(ctx.getDb(), ctx.getNotes(), psId), "patch set %s not found", psId);
    }
    info = getPatchSetInfo(ctx);
    ChangeUpdate update = ctx.getUpdate(psId);
    if (change.getStatus().isOpen()) {
        change.setCurrentPatchSet(info);
        change.setStatus(Change.Status.MERGED);
        // we cannot reconstruct the submit records for when this change was
        // submitted, this is why we must fix the status
        update.fixStatus(Change.Status.MERGED);
    }
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!refName.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (refName.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(refName));
        } else {
            msgBuf.append(refName);
        }
    }
    msgBuf.append(".");
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), msgBuf.toString(), ChangeMessagesUtil.TAG_MERGED);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    PatchSetApproval submitter = ApprovalsUtil.newApproval(change.currentPatchSetId(), ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    correctBranch = refName.equals(change.getDest().get());
    if (!correctBranch) {
        return false;
    }
    if (patchSetProvider != null) {
        // Caller might have also arranged for construction of a new patch set
        // that is not present in the old notes so we can't use PatchSetUtil.
        patchSet = patchSetProvider.get();
    } else {
        patchSet = checkNotNull(psUtil.get(ctx.getDb(), ctx.getNotes(), psId), "patch set %s not found", psId);
    }
    info = getPatchSetInfo(ctx);
    ChangeUpdate update = ctx.getUpdate(psId);
    if (change.getStatus().isOpen()) {
        change.setCurrentPatchSet(info);
        change.setStatus(Change.Status.MERGED);
        // we cannot reconstruct the submit records for when this change was
        // submitted, this is why we must fix the status
        update.fixStatus(Change.Status.MERGED);
        update.setCurrentPatchSet();
    }
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!refName.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (refName.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(refName));
        } else {
            msgBuf.append(refName);
        }
    }
    msgBuf.append(".");
    ChangeMessage msg = ChangeMessagesUtil.newMessage(psId, ctx.getUser(), ctx.getWhen(), msgBuf.toString(), ChangeMessagesUtil.TAG_MERGED);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    PatchSetApproval submitter = ApprovalsUtil.newApproval(change.currentPatchSetId(), ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
    return true;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Override
void apply(ChangeUpdate update) throws OrmException {
    if (!Objects.equals(change.getTopic(), noteDbChange.getTopic())) {
        update.setTopic(change.getTopic());
    }
    if (!Objects.equals(change.getStatus(), noteDbChange.getStatus())) {
        // TODO(dborowitz): Stamp approximate approvals at this time.
        update.fixStatus(change.getStatus());
    }
    if (change.getSubmissionId() != null && noteDbChange.getSubmissionId() == null) {
        update.setSubmissionId(change.getSubmissionId());
    }
    if (!Objects.equals(change.getAssignee(), noteDbChange.getAssignee())) {
        // TODO(dborowitz): Parse intermediate values out from messages.
        update.setAssignee(change.getAssignee());
    }
    if (!update.isEmpty()) {
        update.setSubjectForCommit("Final NoteDb migration updates");
    }
}
#method_after
@SuppressWarnings("deprecation")
@Override
void apply(ChangeUpdate update) throws OrmException {
    if (!Objects.equals(change.getTopic(), noteDbChange.getTopic())) {
        update.setTopic(change.getTopic());
    }
    if (!Objects.equals(change.getStatus(), noteDbChange.getStatus())) {
        // TODO(dborowitz): Stamp approximate approvals at this time.
        update.fixStatus(change.getStatus());
    }
    if (change.getSubmissionId() != null && noteDbChange.getSubmissionId() == null) {
        update.setSubmissionId(change.getSubmissionId());
    }
    if (!Objects.equals(change.getAssignee(), noteDbChange.getAssignee())) {
        // TODO(dborowitz): Parse intermediate values out from messages.
        update.setAssignee(change.getAssignee());
    }
    if (!patchSets.isEmpty() && !highestNumberedPatchSetIsCurrent()) {
        update.setCurrentPatchSet();
    }
    if (!update.isEmpty()) {
        update.setSubjectForCommit("Final NoteDb migration updates");
    }
}
#end_block

#method_before
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectControl projectControl, VisibilityControl visibilityControl, boolean excludeGroups) throws IOException, OrmException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        return Collections.emptyList();
    }
    List<Account.Id> candidateList = new ArrayList<>();
    if (!Strings.isNullOrEmpty(query)) {
        candidateList = suggestAccounts(suggestReviewers, visibilityControl);
    }
    List<Account.Id> sortedRecommendations = recommendAccounts(changeNotes, suggestReviewers, projectControl, candidateList);
    List<SuggestedReviewerInfo> suggestedReviewer = loadAccounts(sortedRecommendations);
    if (!excludeGroups && !Strings.isNullOrEmpty(query)) {
        // Add groups at the end as individual accounts are usually more
        // important.
        suggestedReviewer.addAll(suggestAccountGroups(suggestReviewers, projectControl, visibilityControl));
    }
    if (suggestedReviewer.size() <= limit) {
        return suggestedReviewer;
    }
    return suggestedReviewer.subList(0, limit);
}
#method_after
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectControl projectControl, VisibilityControl visibilityControl, boolean excludeGroups) throws IOException, OrmException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        return Collections.emptyList();
    }
    List<Account.Id> candidateList = new ArrayList<>();
    if (!Strings.isNullOrEmpty(query)) {
        candidateList = suggestAccounts(suggestReviewers, visibilityControl);
    }
    List<Account.Id> sortedRecommendations = recommendAccounts(changeNotes, suggestReviewers, projectControl, candidateList);
    List<SuggestedReviewerInfo> suggestedReviewer = loadAccounts(sortedRecommendations);
    if (!excludeGroups && suggestedReviewer.size() < limit && !Strings.isNullOrEmpty(query)) {
        // Add groups at the end as individual accounts are usually more
        // important.
        suggestedReviewer.addAll(suggestAccountGroups(suggestReviewers, projectControl, visibilityControl, limit - suggestedReviewer.size()));
    }
    if (suggestedReviewer.size() <= limit) {
        return suggestedReviewer;
    }
    return suggestedReviewer.subList(0, limit);
}
#end_block

#method_before
private List<Account.Id> suggestAccounts(SuggestReviewers suggestReviewers, VisibilityControl visibilityControl) throws OrmException {
    try (Timer0.Context ctx = metrics.queryAccountsLatency.start()) {
        AccountIndex searchIndex = accountIndexes.getSearchIndex();
        if (searchIndex != null) {
            return suggestAccountsFromIndex(suggestReviewers);
        }
        return suggestAccountsFromDb(suggestReviewers, visibilityControl);
    }
}
#method_after
private List<Account.Id> suggestAccounts(SuggestReviewers suggestReviewers, VisibilityControl visibilityControl) throws OrmException {
    try (Timer0.Context ctx = metrics.queryAccountsLatency.start()) {
        try {
            Set<Account.Id> matches = new HashSet<>();
            QueryResult<AccountState> result = accountQueryProcessor.setLimit(suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER).query(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery()));
            for (AccountState accountState : result.entities()) {
                Account.Id id = accountState.getAccount().getId();
                if (visibilityControl.isVisibleTo(id)) {
                    matches.add(id);
                }
            }
            return new ArrayList<>(matches);
        } catch (QueryParseException e) {
            return ImmutableList.of();
        }
    }
}
#end_block

#method_before
private List<GroupReference> suggestAccountGroups(SuggestReviewers suggestReviewers, ProjectControl ctl) {
    return Lists.newArrayList(Iterables.limit(groupBackend.suggest(suggestReviewers.getQuery(), ctl), suggestReviewers.getLimit()));
}
#method_after
private List<SuggestedReviewerInfo> suggestAccountGroups(SuggestReviewers suggestReviewers, ProjectControl projectControl, VisibilityControl visibilityControl, int limit) throws OrmException, IOException {
    try (Timer0.Context ctx = metrics.queryGroupsLatency.start()) {
        List<SuggestedReviewerInfo> groups = new ArrayList<>();
        for (GroupReference g : suggestAccountGroups(suggestReviewers, projectControl)) {
            GroupAsReviewer result = suggestGroupAsReviewer(suggestReviewers, projectControl.getProject(), g, visibilityControl);
            if (result.allowed || result.allowedWithConfirmation) {
                GroupBaseInfo info = new GroupBaseInfo();
                info.id = Url.encode(g.getUUID().get());
                info.name = g.getName();
                SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
                suggestedReviewerInfo.group = info;
                suggestedReviewerInfo.count = result.size;
                if (result.allowedWithConfirmation) {
                    suggestedReviewerInfo.confirm = true;
                }
                groups.add(suggestedReviewerInfo);
                if (groups.size() >= limit) {
                    break;
                }
            }
        }
        return groups;
    }
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    List<AccountExternalId> externalIds = new ArrayList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
static LdapType guessType(final DirContext ctx) throws NamingException {
    final Attributes rootAtts = ctx.getAttributes("");
    Attribute supported = rootAtts.get("supportedCapabilities");
    if (supported != null && (supported.contains("1.2.840.113556.1.4.800") || supported.contains("1.2.840.113556.1.4.1851"))) {
        return new ActiveDirectory();
    }
    return RFC_2307;
}
#method_after
static LdapType guessType(final DirContext ctx) throws NamingException {
    final Attributes rootAtts = ctx.getAttributes("");
    Attribute supported = rootAtts.get("supportedCapabilities");
    if (supported != null && (supported.contains("1.2.840.113556.1.4.800") || supported.contains("1.2.840.113556.1.4.1851"))) {
        return new ActiveDirectory();
    }
    supported = rootAtts.get("supportedExtension");
    if (supported != null && supported.contains("2.16.840.1.113730.3.8.10.1")) {
        return new FreeIPA();
    }
    return RFC_2307;
}
#end_block

#method_before
@Override
public Response<String> apply(ProjectResource resource, DescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new DescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try (MetaDataUpdate md = updateFactory.create(resource.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription(Strings.emptyToNull(input.description));
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(user);
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
        return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Response<String> apply(ProjectResource resource, DescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new DescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try (MetaDataUpdate md = updateFactory.create(resource.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription(Strings.emptyToNull(input.description));
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(user);
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        md.getRepository().setGitwebDescription(project.getDescription());
        return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException, IOException, ConfigInvalidException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // Account no longer exists? They are anonymous.
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = readFromGit ? watchConfig.get().getProjectWatches(who) : GetWatchedProjects.readProjectWatchesFromDb(db, who);
    return new AccountState(account, internalGroups, externalIds, projectWatches);
}
#method_after
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException, IOException, ConfigInvalidException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // Account no longer exists? They are anonymous.
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    return new AccountState(account, internalGroups, externalIds, watchConfig.get().getProjectWatches(who));
}
#end_block

#method_before
@Override
public Optional<Account.Id> load(String username) throws Exception {
    AccountExternalId.Key key = new // 
    AccountExternalId.Key(// 
    AccountExternalId.SCHEME_USERNAME, username);
    if (accountIndexes.getSearchIndex() != null) {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(key.get());
        return Optional.ofNullable(accountState).map(s -> s.getAccount().getId());
    }
    try (ReviewDb db = schema.open()) {
        return Optional.ofNullable(db.accountExternalIds().get(key)).map(AccountExternalId::getAccountId);
    }
}
#method_after
@Override
public Optional<Account.Id> load(String username) throws Exception {
    AccountExternalId.Key key = new // 
    AccountExternalId.Key(// 
    AccountExternalId.SCHEME_USERNAME, username);
    AccountState accountState = accountQueryProvider.get().oneByExternalId(key.get());
    return Optional.ofNullable(accountState).map(s -> s.getAccount().getId());
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
    } else {
        projectState = null;
    }
    if (patchSet == null) {
        try {
            patchSet = changeData.currentPatchSet();
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null && patchSetInfo == null) {
        try {
            patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId());
        } catch (PatchSetInfoNotAvailableException | OrmException err) {
            patchSetInfo = null;
        }
    }
    authors = getAuthors();
    super.init();
    if (timestamp != null) {
        setHeader("Date", new Date(timestamp.getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setChangeUrlHeader();
    setCommitIdHeader();
}
#method_after
@Override
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
    } else {
        projectState = null;
    }
    if (patchSet == null) {
        try {
            patchSet = changeData.currentPatchSet();
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null) {
        setHeader("X-Gerrit-PatchSet", patchSet.getPatchSetId() + "");
        if (patchSetInfo == null) {
            try {
                patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId());
            } catch (PatchSetInfoNotAvailableException | OrmException err) {
                patchSetInfo = null;
            }
        }
    }
    authors = getAuthors();
    super.init();
    if (timestamp != null) {
        setHeader("Date", new Date(timestamp.getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setHeader("X-Gerrit-Change-Number", "" + change.getChangeId());
    setChangeUrlHeader();
    setCommitIdHeader();
}
#end_block

#method_before
protected void bccStarredBy() {
    if (!NotifyHandling.ALL.equals(notify)) {
        return;
    }
    try {
        // BCC anyone who has starred this change
        // and remove anyone who has ignored this change.
        // 
        Multimap<Account.Id, String> stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
        for (Map.Entry<Account.Id, Collection<String>> e : stars.asMap().entrySet()) {
            if (e.getValue().contains(StarredChangesUtil.DEFAULT_LABEL)) {
                super.add(RecipientType.BCC, e.getKey());
            }
            if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) {
                AccountState accountState = args.accountCache.get(e.getKey());
                if (accountState != null) {
                    removeUser(accountState.getAccount());
                }
            }
        }
    } catch (OrmException | NoSuchChangeException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot BCC users that starred updated change", err);
    }
}
#method_after
protected void bccStarredBy() {
    if (!NotifyHandling.ALL.equals(notify)) {
        return;
    }
    try {
        // BCC anyone who has starred this change
        // and remove anyone who has ignored this change.
        // 
        ListMultimap<Account.Id, String> stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
        for (Map.Entry<Account.Id, Collection<String>> e : stars.asMap().entrySet()) {
            if (e.getValue().contains(StarredChangesUtil.DEFAULT_LABEL)) {
                super.add(RecipientType.BCC, e.getKey());
            }
            if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) {
                AccountState accountState = args.accountCache.get(e.getKey());
                if (accountState != null) {
                    removeUser(accountState.getAccount());
                }
            }
        }
    } catch (OrmException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot BCC users that starred updated change", err);
    }
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    changeData.put("changeNumber", Integer.toString(change.getChangeId()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    soyContext.put("reviewerEmails", getEmailsByState(ReviewerStateInternal.REVIEWER));
    soyContext.put("ccEmails", getEmailsByState(ReviewerStateInternal.CC));
// TODO(wyatta): patchSetInfo
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    changeData.put("changeNumber", Integer.toString(change.getChangeId()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    // TODO(wyatta): patchSetInfo
    footers.add("Gerrit-MessageType: " + messageClass);
    footers.add("Gerrit-Change-Id: " + change.getKey().get());
    footers.add("Gerrit-Change-Number: " + Integer.toString(change.getChangeId()));
    footers.add("Gerrit-PatchSet: " + patchSet.getPatchSetId());
    footers.add("Gerrit-Owner: " + getNameEmailFor(change.getOwner()));
    for (String reviewer : getEmailsByState(ReviewerStateInternal.REVIEWER)) {
        footers.add("Gerrit-Reviewer: " + reviewer);
    }
    for (String reviewer : getEmailsByState(ReviewerStateInternal.CC)) {
        footers.add("Gerrit-CC: " + reviewer);
    }
}
#end_block

#method_before
private void allowCodeReviewOnBehalfOf() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReviewType = Util.codeReview();
    String forCodeReviewAs = Permission.forLabelAs(codeReviewType.getName());
    String heads = "refs/heads/*";
    AccountGroup.UUID uuid = SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    Util.allow(cfg, forCodeReviewAs, -1, 1, uuid, heads);
    saveProjectConfig(project, cfg);
}
#method_after
private void allowCodeReviewOnBehalfOf() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReviewType = Util.codeReview();
    String forCodeReviewAs = Permission.forLabelAs(codeReviewType.getName());
    String heads = "refs/heads/*";
    AccountGroup.UUID uuid = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    Util.allow(cfg, forCodeReviewAs, -1, 1, uuid, heads);
    saveProjectConfig(project, cfg);
}
#end_block

#method_before
private void allowSubmitOnBehalfOf() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    String heads = "refs/heads/*";
    AccountGroup.UUID uuid = SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    Util.allow(cfg, Permission.SUBMIT_AS, uuid, heads);
    Util.allow(cfg, Permission.SUBMIT, uuid, heads);
    LabelType codeReviewType = Util.codeReview();
    Util.allow(cfg, Permission.forLabel(codeReviewType.getName()), -2, 2, uuid, heads);
    saveProjectConfig(project, cfg);
}
#method_after
private void allowSubmitOnBehalfOf() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    String heads = "refs/heads/*";
    AccountGroup.UUID uuid = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    Util.allow(cfg, Permission.SUBMIT_AS, uuid, heads);
    Util.allow(cfg, Permission.SUBMIT, uuid, heads);
    LabelType codeReviewType = Util.codeReview();
    Util.allow(cfg, Permission.forLabel(codeReviewType.getName()), -2, 2, uuid, heads);
    saveProjectConfig(project, cfg);
}
#end_block

#method_before
private void allowRunAs() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    Util.allow(cfg, GlobalCapability.RUN_AS, SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID());
    saveProjectConfig(allProjects, cfg);
}
#method_after
private void allowRunAs() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    Util.allow(cfg, GlobalCapability.RUN_AS, systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID());
    saveProjectConfig(allProjects, cfg);
}
#end_block

#method_before
private void removeRunAs() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    Util.remove(cfg, GlobalCapability.RUN_AS, SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID());
    saveProjectConfig(allProjects, cfg);
}
#method_after
private void removeRunAs() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    Util.remove(cfg, GlobalCapability.RUN_AS, systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID());
    saveProjectConfig(allProjects, cfg);
}
#end_block

#method_before
public static Id fromRef(String ref) {
    int cs = startIndex(ref);
    if (cs < 0) {
        return null;
    }
    int ce = nextNonDigit(ref, cs);
    if (ref.substring(ce).equals(RefNames.META_SUFFIX) || ref.substring(ce).equals(RefNames.ROBOT_COMMENTS_SUFFIX) || PatchSet.Id.fromRef(ref, ce) >= 0) {
        return new Change.Id(Integer.parseInt(ref.substring(cs, ce)));
    }
    return null;
}
#method_after
public static Id fromRef(String ref) {
    if (RefNames.isRefsEdit(ref)) {
        return fromEditRefPart(ref);
    }
    int cs = startIndex(ref);
    if (cs < 0) {
        return null;
    }
    int ce = nextNonDigit(ref, cs);
    if (ref.substring(ce).equals(RefNames.META_SUFFIX) || ref.substring(ce).equals(RefNames.ROBOT_COMMENTS_SUFFIX) || PatchSet.Id.fromRef(ref, ce) >= 0) {
        return new Change.Id(Integer.parseInt(ref.substring(cs, ce)));
    }
    return null;
}
#end_block

#method_before
static int startIndex(String ref) {
    if (ref == null || !ref.startsWith(REFS_CHANGES)) {
        return -1;
    }
    // Last 2 digits.
    int ls = REFS_CHANGES.length();
    int le = nextNonDigit(ref, ls);
    if (le - ls != 2 || le >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    // Change ID.
    int cs = le + 1;
    if (cs >= ref.length() || ref.charAt(cs) == '0') {
        return -1;
    }
    int ce = nextNonDigit(ref, cs);
    if (ce >= ref.length() || ref.charAt(ce) != '/') {
        return -1;
    }
    switch(ce - cs) {
        case 0:
            return -1;
        case 1:
            if (ref.charAt(ls) != '0' || ref.charAt(ls + 1) != ref.charAt(cs)) {
                return -1;
            }
            break;
        default:
            if (ref.charAt(ls) != ref.charAt(ce - 2) || ref.charAt(ls + 1) != ref.charAt(ce - 1)) {
                return -1;
            }
            break;
    }
    return cs;
}
#method_after
static int startIndex(String ref) {
    return startIndex(ref, REFS_CHANGES);
}
#end_block

#method_before
static int startIndex(String ref) {
    if (ref == null || !ref.startsWith(REFS_CHANGES)) {
        return -1;
    }
    // Last 2 digits.
    int ls = REFS_CHANGES.length();
    int le = nextNonDigit(ref, ls);
    if (le - ls != 2 || le >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    // Change ID.
    int cs = le + 1;
    if (cs >= ref.length() || ref.charAt(cs) == '0') {
        return -1;
    }
    int ce = nextNonDigit(ref, cs);
    if (ce >= ref.length() || ref.charAt(ce) != '/') {
        return -1;
    }
    switch(ce - cs) {
        case 0:
            return -1;
        case 1:
            if (ref.charAt(ls) != '0' || ref.charAt(ls + 1) != ref.charAt(cs)) {
                return -1;
            }
            break;
        default:
            if (ref.charAt(ls) != ref.charAt(ce - 2) || ref.charAt(ls + 1) != ref.charAt(ce - 1)) {
                return -1;
            }
            break;
    }
    return cs;
}
#method_after
static int startIndex(String ref, String expectedPrefix) {
    if (ref == null || !ref.startsWith(expectedPrefix)) {
        return -1;
    }
    // Last 2 digits.
    int ls = expectedPrefix.length();
    int le = nextNonDigit(ref, ls);
    if (le - ls != 2 || le >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    // Change ID.
    int cs = le + 1;
    if (cs >= ref.length() || ref.charAt(cs) == '0') {
        return -1;
    }
    int ce = nextNonDigit(ref, cs);
    if (ce >= ref.length() || ref.charAt(ce) != '/') {
        return -1;
    }
    switch(ce - cs) {
        case 0:
            return -1;
        case 1:
            if (ref.charAt(ls) != '0' || ref.charAt(ls + 1) != ref.charAt(cs)) {
                return -1;
            }
            break;
        default:
            if (ref.charAt(ls) != ref.charAt(ce - 2) || ref.charAt(ls + 1) != ref.charAt(ce - 1)) {
                return -1;
            }
            break;
    }
    return cs;
}
#end_block

#method_before
public Result normalize(Change change, Collection<PatchSetApproval> approvals) throws NoSuchChangeException, OrmException {
    IdentifiedUser user = userFactory.create(change.getOwner());
    return normalize(changeFactory.controlFor(db.get(), change, user), approvals);
}
#method_after
public Result normalize(Change change, Collection<PatchSetApproval> approvals) throws OrmException {
    IdentifiedUser user = userFactory.create(change.getOwner());
    return normalize(changeFactory.controlFor(db.get(), change, user), approvals);
}
#end_block

#method_before
private void grantApproveToChangeOwner() throws Exception {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Grant approve to change owner"));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection("refs/heads/*", true);
        Permission p = s.getPermission(LABEL + "Code-Review", true);
        PermissionRule rule = new PermissionRule(config.resolve(SystemGroupBackend.getGroup(SystemGroupBackend.CHANGE_OWNER)));
        rule.setMin(-2);
        rule.setMax(+2);
        p.add(rule);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#method_after
private void grantApproveToChangeOwner() throws Exception {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Grant approve to change owner"));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection("refs/heads/*", true);
        Permission p = s.getPermission(LABEL + "Code-Review", true);
        PermissionRule rule = new PermissionRule(config.resolve(systemGroupBackend.getGroup(SystemGroupBackend.CHANGE_OWNER)));
        rule.setMin(-2);
        rule.setMax(+2);
        p.add(rule);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#end_block

#method_before
public static GroupCollector create(Multimap<ObjectId, Ref> changeRefsById, final ReviewDb db, final PatchSetUtil psUtil, final ChangeNotes.Factory notesFactory, final Project.NameKey project) {
    return new GroupCollector(transformRefs(changeRefsById), new Lookup() {

        @Override
        public List<String> lookup(PatchSet.Id psId) throws OrmException, NoSuchChangeException {
            // TODO(dborowitz): Reuse open repository from caller.
            ChangeNotes notes = notesFactory.createChecked(db, project, psId.getParentKey());
            PatchSet ps = psUtil.get(db, notes, psId);
            return ps != null ? ps.getGroups() : null;
        }
    });
}
#method_after
public static GroupCollector create(ListMultimap<ObjectId, Ref> changeRefsById, ReviewDb db, PatchSetUtil psUtil, ChangeNotes.Factory notesFactory, Project.NameKey project) {
    return new GroupCollector(transformRefs(changeRefsById), new Lookup() {

        @Override
        public List<String> lookup(PatchSet.Id psId) throws OrmException {
            // TODO(dborowitz): Reuse open repository from caller.
            ChangeNotes notes = notesFactory.createChecked(db, project, psId.getParentKey());
            PatchSet ps = psUtil.get(db, notes, psId);
            return ps != null ? ps.getGroups() : null;
        }
    });
}
#end_block

#method_before
public static GroupCollector createForSchemaUpgradeOnly(Multimap<ObjectId, Ref> changeRefsById, final ReviewDb db) {
    return new GroupCollector(transformRefs(changeRefsById), new Lookup() {

        @Override
        public List<String> lookup(PatchSet.Id psId) throws OrmException {
            PatchSet ps = db.patchSets().get(psId);
            return ps != null ? ps.getGroups() : null;
        }
    });
}
#method_after
public static GroupCollector createForSchemaUpgradeOnly(ListMultimap<ObjectId, Ref> changeRefsById, ReviewDb db) {
    return new GroupCollector(transformRefs(changeRefsById), new Lookup() {

        @Override
        public List<String> lookup(PatchSet.Id psId) throws OrmException {
            PatchSet ps = db.patchSets().get(psId);
            return ps != null ? ps.getGroups() : null;
        }
    });
}
#end_block

#method_before
private static Multimap<ObjectId, PatchSet.Id> transformRefs(Multimap<ObjectId, Ref> refs) {
    return Multimaps.transformValues(refs, r -> PatchSet.Id.fromRef(r.getName()));
}
#method_after
private static ListMultimap<ObjectId, PatchSet.Id> transformRefs(ListMultimap<ObjectId, Ref> refs) {
    return Multimaps.transformValues(refs, r -> PatchSet.Id.fromRef(r.getName()));
}
#end_block

#method_before
public SortedSetMultimap<ObjectId, String> getGroups() throws OrmException, NoSuchChangeException {
    done = true;
    SortedSetMultimap<ObjectId, String> result = MultimapBuilder.hashKeys(groups.keySet().size()).treeSetValues().build();
    for (Map.Entry<ObjectId, Collection<String>> e : groups.asMap().entrySet()) {
        ObjectId id = e.getKey();
        result.putAll(id.copy(), resolveGroups(id, e.getValue()));
    }
    return result;
}
#method_after
public SortedSetMultimap<ObjectId, String> getGroups() throws OrmException {
    done = true;
    SortedSetMultimap<ObjectId, String> result = MultimapBuilder.hashKeys(groups.keySet().size()).treeSetValues().build();
    for (Map.Entry<ObjectId, Collection<String>> e : groups.asMap().entrySet()) {
        ObjectId id = e.getKey();
        result.putAll(id.copy(), resolveGroups(id, e.getValue()));
    }
    return result;
}
#end_block

#method_before
private Set<String> resolveGroups(ObjectId forCommit, Collection<String> candidates) throws OrmException, NoSuchChangeException {
    Set<String> actual = Sets.newTreeSet();
    Set<String> done = Sets.newHashSetWithExpectedSize(candidates.size());
    Set<String> seen = Sets.newHashSetWithExpectedSize(candidates.size());
    Deque<String> todo = new ArrayDeque<>(candidates);
    // else.
    while (!todo.isEmpty()) {
        String g = todo.removeFirst();
        if (!seen.add(g)) {
            continue;
        }
        Set<String> aliases = groupAliases.get(g);
        if (aliases.isEmpty()) {
            if (!done.contains(g)) {
                Iterables.addAll(actual, resolveGroup(forCommit, g));
                done.add(g);
            }
        } else {
            todo.addAll(aliases);
        }
    }
    return actual;
}
#method_after
private Set<String> resolveGroups(ObjectId forCommit, Collection<String> candidates) throws OrmException {
    Set<String> actual = Sets.newTreeSet();
    Set<String> done = Sets.newHashSetWithExpectedSize(candidates.size());
    Set<String> seen = Sets.newHashSetWithExpectedSize(candidates.size());
    Deque<String> todo = new ArrayDeque<>(candidates);
    // else.
    while (!todo.isEmpty()) {
        String g = todo.removeFirst();
        if (!seen.add(g)) {
            continue;
        }
        Set<String> aliases = groupAliases.get(g);
        if (aliases.isEmpty()) {
            if (!done.contains(g)) {
                Iterables.addAll(actual, resolveGroup(forCommit, g));
                done.add(g);
            }
        } else {
            todo.addAll(aliases);
        }
    }
    return actual;
}
#end_block

#method_before
private Iterable<String> resolveGroup(ObjectId forCommit, String group) throws OrmException, NoSuchChangeException {
    ObjectId id = parseGroup(forCommit, group);
    if (id != null) {
        PatchSet.Id psId = Iterables.getFirst(patchSetsBySha.get(id), null);
        if (psId != null) {
            List<String> groups = groupLookup.lookup(psId);
            // been migrated yet.
            if (groups != null && !groups.isEmpty()) {
                return groups;
            }
        }
    }
    return ImmutableList.of(group);
}
#method_after
private Iterable<String> resolveGroup(ObjectId forCommit, String group) throws OrmException {
    ObjectId id = parseGroup(forCommit, group);
    if (id != null) {
        PatchSet.Id psId = Iterables.getFirst(patchSetsBySha.get(id), null);
        if (psId != null) {
            List<String> groups = groupLookup.lookup(psId);
            // been migrated yet.
            if (groups != null && !groups.isEmpty()) {
                return groups;
            }
        }
    }
    return ImmutableList.of(group);
}
#end_block

#method_before
void onStopPlugin(Plugin plugin) {
    for (StopPluginListener l : onStop) {
        l.onStopPlugin(plugin);
    }
}
#method_after
public void onStopPlugin(Plugin plugin) {
    for (StopPluginListener l : onStop) {
        l.onStopPlugin(plugin);
    }
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = sort(toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    for (CodeReviewCommit c : sorted) {
        if (c.getParentCount() > 1) {
            // Since there is a merge commit, sort and prune again using
            // MERGE_IF_NECESSARY semantics to avoid creating duplicate
            // commits.
            // 
            sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, sorted);
            break;
        }
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            // TODO(tandrii): Cherry-Pick strategy does this too, but it's wrong
            // and can be fixed.
            ops.add(new FastForwardOp(args, n));
        } else if (n.getParentCount() == 0) {
            ops.add(new RebaseRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new RebaseOneOp(n));
        } else {
            ops.add(new RebaseMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = sort(toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    for (CodeReviewCommit c : sorted) {
        if (c.getParentCount() > 1) {
            // Since there is a merge commit, sort and prune again using
            // MERGE_IF_NECESSARY semantics to avoid creating duplicate
            // commits.
            // 
            sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, sorted, args.incoming);
            break;
        }
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            // TODO(tandrii): Cherry-Pick strategy does this too, but it's wrong
            // and can be fixed.
            ops.add(new FastForwardOp(args, n));
        } else if (n.getParentCount() == 0) {
            ops.add(new RebaseRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new RebaseOneOp(n));
        } else {
            ops.add(new RebaseMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // BatchUpdate how to produce CodeReviewRevWalks.
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
        // TODO(tandrii): add extension point to customize this commit message.
        String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(toMerge);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName()));
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getControl().getNotes(), toMerge.getPatchsetId());
        // TODO(tandrii): add extension point to customize commit message while
        // rebasing.
        rebaseOp = args.rebaseFactory.create(toMerge.getControl(), origPs, args.mergeTip.getCurrentTip().name()).setFireRevisionCreated(false).setCopyApprovals(false).setValidatePolicy(CommitValidators.Policy.NONE).setPostMessage(false);
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commits.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // BatchUpdate how to produce CodeReviewRevWalks.
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
        RevCommit mergeTip = args.mergeTip.getCurrentTip();
        args.rw.parseBody(mergeTip);
        String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, true);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            // this should not happen
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName()));
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getControl().getNotes(), toMerge.getPatchsetId());
        rebaseOp = args.rebaseFactory.create(toMerge.getControl(), origPs, args.mergeTip.getCurrentTip().name()).setFireRevisionCreated(false).setCopyApprovals(false).setValidatePolicy(CommitValidators.Policy.NONE).setCheckAddPatchSetPermission(false).setDetailedCommitMessage(rebaseAlways).setPostMessage(false);
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#end_block

#method_before
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws NoSuchChangeException, ResourceConflictException, OrmException, IOException {
    if (newCommit == null) {
        checkState(!rebaseAlways, "RebaseAlways must never fast forward");
        // Took the fast-forward option, nothing to do.
        return null;
    }
    PatchSet newPs;
    if (rebaseOp != null) {
        rebaseOp.updateChange(ctx);
        newPs = rebaseOp.getPatchSet();
    } else {
        // CherryPick
        PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
        newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(newPatchSetId), newPatchSetId, newCommit, false, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    }
    ctx.getChange().setCurrentPatchSet(args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, newPatchSetId));
    newCommit.setControl(ctx.getControl());
    return newPs;
}
#method_after
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws NoSuchChangeException, ResourceConflictException, OrmException, IOException {
    if (newCommit == null) {
        checkState(!rebaseAlways, "RebaseAlways must never fast forward");
        // otherwise, took the fast-forward option, nothing to do.
        return null;
    }
    PatchSet newPs;
    if (rebaseOp != null) {
        rebaseOp.updateChange(ctx);
        newPs = rebaseOp.getPatchSet();
    } else {
        // CherryPick
        PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
        newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(newPatchSetId), newPatchSetId, newCommit, false, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    }
    ctx.getChange().setCurrentPatchSet(args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, newPatchSetId));
    newCommit.setControl(ctx.getControl());
    return newPs;
}
#end_block

#method_before
private List<CodeReviewCommit> sort(Collection<CodeReviewCommit> toSort) throws IntegrationException {
    try {
        return new RebaseSorter(args.rw, args.alreadyAccepted, args.canMergeFlag).sort(toSort);
    } catch (IOException e) {
        throw new IntegrationException("Commit sorting failed", e);
    }
}
#method_after
private List<CodeReviewCommit> sort(Collection<CodeReviewCommit> toSort) throws IntegrationException {
    try {
        return new RebaseSorter(args.rw, args.mergeTip.getInitialTip(), args.alreadyAccepted, args.canMergeFlag, args.internalChangeQuery, args.changeKindCache, args.repo).sort(toSort);
    } catch (IOException e) {
        throw new IntegrationException("Commit sorting failed", e);
    }
}
#end_block

#method_before
@Test
public void getRelatedEdit() throws Exception {
    // 1,1---2,1---3,1
    // \---2,E---/
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    RevCommit c3_1 = commitBuilder().add("c.txt", "3").message("subject: 3").create();
    pushHead(testRepo, "refs/for/master", false);
    Change ch2 = getChange(c2_1).change();
    editModifier.createEdit(ch2, getPatchSet(ch2.currentPatchSetId()));
    editModifier.modifyFile(editUtil.byChange(ch2).get(), "a.txt", RawInputUtil.create(new byte[] { 'a' }));
    ObjectId editRev = ObjectId.fromString(editUtil.byChange(ch2).get().getRevision().get());
    PatchSet.Id ps1_1 = getPatchSetId(c1_1);
    PatchSet.Id ps2_1 = getPatchSetId(c2_1);
    PatchSet.Id ps2_edit = new PatchSet.Id(ch2.getId(), 0);
    PatchSet.Id ps3_1 = getPatchSetId(c3_1);
    for (PatchSet.Id ps : ImmutableList.of(ps1_1, ps2_1, ps3_1)) {
        assertRelated(ps, changeAndCommit(ps3_1, c3_1, 1), changeAndCommit(ps2_1, c2_1, 1), changeAndCommit(ps1_1, c1_1, 1));
    }
    assertRelated(ps2_edit, changeAndCommit(ps3_1, c3_1, 1), changeAndCommit(new PatchSet.Id(ch2.getId(), 0), editRev, 1), changeAndCommit(ps1_1, c1_1, 1));
}
#method_after
@Test
public void getRelatedEdit() throws Exception {
    // 1,1---2,1---3,1
    // \---2,E---/
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    RevCommit c3_1 = commitBuilder().add("c.txt", "3").message("subject: 3").create();
    pushHead(testRepo, "refs/for/master", false);
    Change ch2 = getChange(c2_1).change();
    String changeId2 = ch2.getKey().get();
    gApi.changes().id(changeId2).edit().create();
    gApi.changes().id(changeId2).edit().modifyFile("a.txt", RawInputUtil.create(new byte[] { 'a' }));
    Optional<EditInfo> edit = getEdit(changeId2);
    assertThat(edit).isPresent();
    ObjectId editRev = ObjectId.fromString(edit.get().commit.commit);
    PatchSet.Id ps1_1 = getPatchSetId(c1_1);
    PatchSet.Id ps2_1 = getPatchSetId(c2_1);
    PatchSet.Id ps2_edit = new PatchSet.Id(ch2.getId(), 0);
    PatchSet.Id ps3_1 = getPatchSetId(c3_1);
    for (PatchSet.Id ps : ImmutableList.of(ps1_1, ps2_1, ps3_1)) {
        assertRelated(ps, changeAndCommit(ps3_1, c3_1, 1), changeAndCommit(ps2_1, c2_1, 1), changeAndCommit(ps1_1, c1_1, 1));
    }
    assertRelated(ps2_edit, changeAndCommit(ps3_1, c3_1, 1), changeAndCommit(new PatchSet.Id(ch2.getId(), 0), editRev, 1), changeAndCommit(ps1_1, c1_1, 1));
}
#end_block

#method_before
@Test
public void getRelatedForStaleChange() throws Exception {
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    RevCommit c2_1 = commitBuilder().add("b.txt", "1").message("subject: 1").create();
    pushHead(testRepo, "refs/for/master", false);
    RevCommit c2_2 = testRepo.amend(c2_1).add("b.txt", "2").create();
    testRepo.reset(c2_2);
    disableChangeIndexWrites();
    try {
        pushHead(testRepo, "refs/for/master", false);
    } finally {
        enableChangeIndexWrites();
    }
    PatchSet.Id psId1_1 = getPatchSetId(c1_1);
    PatchSet.Id psId2_1 = getPatchSetId(c2_1);
    PatchSet.Id psId2_2 = new PatchSet.Id(psId2_1.changeId, psId2_1.get() + 1);
    assertRelated(psId2_2, changeAndCommit(psId2_2, c2_2, 2), changeAndCommit(psId1_1, c1_1, 1));
}
#method_after
@Test
@GerritConfig(name = "index.testReindexAfterUpdate", value = "false")
public void getRelatedForStaleChange() throws Exception {
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    RevCommit c2_1 = commitBuilder().add("b.txt", "1").message("subject: 1").create();
    pushHead(testRepo, "refs/for/master", false);
    RevCommit c2_2 = testRepo.amend(c2_1).add("b.txt", "2").create();
    testRepo.reset(c2_2);
    disableChangeIndexWrites();
    try {
        pushHead(testRepo, "refs/for/master", false);
    } finally {
        enableChangeIndexWrites();
    }
    PatchSet.Id psId1_1 = getPatchSetId(c1_1);
    PatchSet.Id psId2_1 = getPatchSetId(c2_1);
    PatchSet.Id psId2_2 = new PatchSet.Id(psId2_1.changeId, psId2_1.get() + 1);
    assertRelated(psId2_2, changeAndCommit(psId2_2, c2_2, 2), changeAndCommit(psId1_1, c1_1, 1));
}
#end_block

#method_before
@Override
protected void configure() {
    bind(GitRepositoryManager.class).to(LocalDiskRepositoryManager.class);
    listener().to(LocalDiskRepositoryManager.class);
    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
}
#method_after
@Override
protected void configure() {
    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
}
#end_block

#method_before
@Override
public Repository createRepository(Project.NameKey name) throws RepositoryNotFoundException, RepositoryCaseMismatchException {
    Path path = getBasePath(name);
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    File dir = FileKey.resolve(path.resolve(name.get()).toFile(), FS.DETECTED);
    FileKey loc;
    if (dir != null) {
        // Already exists on disk, use the repository we found.
        // 
        loc = FileKey.exact(dir, FS.DETECTED);
        if (!names.contains(name)) {
            throw new RepositoryCaseMismatchException(name);
        }
    } else {
        // It doesn't exist under any of the standard permutations
        // of the repository name, so prefer the standard bare name.
        // 
        String n = name.get() + Constants.DOT_GIT_EXT;
        loc = FileKey.exact(path.resolve(n).toFile(), FS.DETECTED);
    }
    try {
        Repository db = RepositoryCache.open(loc, false);
        db.create(true);
        StoredConfig config = db.getConfig();
        config.setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_LOGALLREFUPDATES, true);
        config.save();
        // JGit only writes to the reflog for refs/meta/config if the log file
        // already exists.
        // 
        File metaConfigLog = new File(db.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
        if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
            log.error(String.format("Failed to create ref log for %s in repository %s", RefNames.REFS_CONFIG, name));
        }
        onCreateProject(name);
        return db;
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot create repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#method_after
@Override
public Repository createRepository(Project.NameKey name) throws RepositoryNotFoundException, RepositoryCaseMismatchException, IOException {
    Path path = getBasePath(name);
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    File dir = FileKey.resolve(path.resolve(name.get()).toFile(), FS.DETECTED);
    FileKey loc;
    if (dir != null) {
        // Already exists on disk, use the repository we found.
        // 
        Project.NameKey onDiskName = getProjectName(path, dir.getCanonicalFile().toPath());
        onCreateProject(onDiskName);
        loc = FileKey.exact(dir, FS.DETECTED);
        if (!names.contains(name)) {
            throw new RepositoryCaseMismatchException(name);
        }
    } else {
        // It doesn't exist under any of the standard permutations
        // of the repository name, so prefer the standard bare name.
        // 
        String n = name.get() + Constants.DOT_GIT_EXT;
        loc = FileKey.exact(path.resolve(n).toFile(), FS.DETECTED);
    }
    try {
        Repository db = RepositoryCache.open(loc, false);
        db.create(true);
        StoredConfig config = db.getConfig();
        config.setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_LOGALLREFUPDATES, true);
        config.save();
        // JGit only writes to the reflog for refs/meta/config if the log file
        // already exists.
        // 
        File metaConfigLog = new File(db.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
        if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
            log.error(String.format("Failed to create ref log for %s in repository %s", RefNames.REFS_CONFIG, name));
        }
        onCreateProject(name);
        return db;
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot create repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#end_block

#method_before
@Override
public SortedSet<Project.NameKey> list() {
    // The results of this method are cached by ProjectCacheImpl. Control only
    // enters here if the cache was flushed by the administrator to force
    // scanning the filesystem. Don't rely on the cached names collection.
    namesUpdateLock.lock();
    try {
        ProjectVisitor visitor = new ProjectVisitor(basePath);
        scanProjects(visitor);
        return Collections.unmodifiableSortedSet(visitor.found);
    } finally {
        namesUpdateLock.unlock();
    }
}
#method_after
@Override
public SortedSet<Project.NameKey> list() {
    // The results of this method are cached by ProjectCacheImpl. Control only
    // enters here if the cache was flushed by the administrator to force
    // scanning the filesystem.
    // Don't rely on the cached names collection but update it to contain
    // the set of found project names
    ProjectVisitor visitor = new ProjectVisitor(basePath);
    scanProjects(visitor);
    namesUpdateLock.lock();
    try {
        names = Collections.unmodifiableSortedSet(visitor.found);
    } finally {
        namesUpdateLock.unlock();
    }
    return names;
}
#end_block

#method_before
private void addProject(Path p) {
    Project.NameKey nameKey = getProjectName(p);
    if (getBasePath(nameKey).equals(startFolder)) {
        if (isUnreasonableName(nameKey)) {
            log.warn("Ignoring unreasonably named repository " + p.toAbsolutePath());
        } else {
            found.add(nameKey);
        }
    }
}
#method_after
private void addProject(Path p) {
    Project.NameKey nameKey = getProjectName(startFolder, p);
    if (getBasePath(nameKey).equals(startFolder)) {
        if (isUnreasonableName(nameKey)) {
            log.warn("Ignoring unreasonably named repository " + p.toAbsolutePath());
        } else {
            found.add(nameKey);
        }
    }
}
#end_block

#method_before
@Override
public CommentInfo get() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public CommentInfo get() {
    throw new NotImplementedException();
}
#end_block

#method_before
public List<CommitValidationMessage> validate(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#method_after
public List<CommitValidationMessage> validate(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationMessage> messages = new ArrayList<>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (!shouldValidateChangeId(receiveEvent)) {
        return Collections.emptyList();
    }
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        if (!CHANGE_ID.matcher(v).matches()) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (!shouldValidateChangeId(receiveEvent)) {
        return Collections.emptyList();
    }
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new ArrayList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        // Egit (I0000000000000000000000000000000000000000).
        if (!CHANGE_ID.matcher(v).matches() || v.matches("^I00*$")) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    if (REFS_CONFIG.equals(refControl.getRefName())) {
        List<CommitValidationMessage> messages = new LinkedList<>();
        try {
            ProjectConfig cfg = new ProjectConfig(receiveEvent.project.getNameKey());
            cfg.load(repo, receiveEvent.command.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:", messages);
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage(), messages);
                }
                throw new ConfigInvalidException("invalid project configuration");
            }
        } catch (ConfigInvalidException | IOException e) {
            log.error("User " + currentUser.getUserName() + " tried to push an invalid project configuration " + receiveEvent.command.getNewId().name() + " for project " + receiveEvent.project.getName(), e);
            throw new CommitValidationException("invalid project configuration", messages);
        }
    }
    if (allUsers.equals(refControl.getProjectControl().getProject().getNameKey()) && RefNames.isRefsUsers(refControl.getRefName())) {
        List<CommitValidationMessage> messages = new LinkedList<>();
        Account.Id accountId = Account.Id.fromRef(refControl.getRefName());
        if (accountId != null) {
            try {
                WatchConfig wc = new WatchConfig(accountId);
                wc.load(repo, receiveEvent.command.getNewId());
                if (!wc.getValidationErrors().isEmpty()) {
                    addError("Invalid project configuration:", messages);
                    for (ValidationError err : wc.getValidationErrors()) {
                        addError("  " + err.getMessage(), messages);
                    }
                    throw new ConfigInvalidException("invalid watch configuration");
                }
            } catch (IOException | ConfigInvalidException e) {
                log.error("User " + currentUser.getUserName() + " tried to push an invalid watch configuration " + receiveEvent.command.getNewId().name() + " for account " + accountId.get(), e);
                throw new CommitValidationException("invalid watch configuration", messages);
            }
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    if (REFS_CONFIG.equals(refControl.getRefName())) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        try {
            ProjectConfig cfg = new ProjectConfig(receiveEvent.project.getNameKey());
            cfg.load(repo, receiveEvent.command.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:", messages);
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage(), messages);
                }
                throw new ConfigInvalidException("invalid project configuration");
            }
        } catch (ConfigInvalidException | IOException e) {
            log.error("User " + currentUser.getUserName() + " tried to push an invalid project configuration " + receiveEvent.command.getNewId().name() + " for project " + receiveEvent.project.getName(), e);
            throw new CommitValidationException("invalid project configuration", messages);
        }
    }
    if (allUsers.equals(refControl.getProjectControl().getProject().getNameKey()) && RefNames.isRefsUsers(refControl.getRefName())) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        Account.Id accountId = Account.Id.fromRef(refControl.getRefName());
        if (accountId != null) {
            try {
                WatchConfig wc = new WatchConfig(accountId);
                wc.load(repo, receiveEvent.command.getNewId());
                if (!wc.getValidationErrors().isEmpty()) {
                    addError("Invalid project configuration:", messages);
                    for (ValidationError err : wc.getValidationErrors()) {
                        addError("  " + err.getMessage(), messages);
                    }
                    throw new ConfigInvalidException("invalid watch configuration");
                }
            } catch (IOException | ConfigInvalidException e) {
                log.error("User " + currentUser.getUserName() + " tried to push an invalid watch configuration " + receiveEvent.command.getNewId().name() + " for account " + accountId.get(), e);
                throw new CommitValidationException("invalid watch configuration", messages);
            }
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationMessage> messages = new LinkedList<>();
    for (CommitValidationListener validator : commitValidationListeners) {
        try {
            messages.addAll(validator.onCommitReceived(receiveEvent));
        } catch (CommitValidationException e) {
            messages.addAll(e.getMessages());
            throw new CommitValidationException(e.getMessage(), messages);
        }
    }
    return messages;
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationMessage> messages = new ArrayList<>();
    for (CommitValidationListener validator : commitValidationListeners) {
        try {
            messages.addAll(validator.onCommitReceived(receiveEvent));
        } catch (CommitValidationException e) {
            messages.addAll(e.getMessages());
            throw new CommitValidationException(e.getMessage(), messages);
        }
    }
    return messages;
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    final PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (!currentUser.hasEmailAddress(author.getEmailAddress()) && !refControl.canForgeAuthor()) {
        List<CommitValidationMessage> messages = new LinkedList<>();
        messages.add(getInvalidEmailError(receiveEvent.commit, "author", author, currentUser, canonicalWebUrl));
        throw new CommitValidationException("invalid author", messages);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    final PersonIdent author = receiveEvent.commit.getAuthorIdent();
    if (!currentUser.hasEmailAddress(author.getEmailAddress()) && !refControl.canForgeAuthor()) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        messages.add(getInvalidEmailError(receiveEvent.commit, "author", author, currentUser, canonicalWebUrl));
        throw new CommitValidationException("invalid author", messages);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    final PersonIdent committer = receiveEvent.commit.getCommitterIdent();
    if (!currentUser.hasEmailAddress(committer.getEmailAddress()) && !refControl.canForgeCommitter()) {
        List<CommitValidationMessage> messages = new LinkedList<>();
        messages.add(getInvalidEmailError(receiveEvent.commit, "committer", committer, currentUser, canonicalWebUrl));
        throw new CommitValidationException("invalid committer", messages);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser();
    final PersonIdent committer = receiveEvent.commit.getCommitterIdent();
    if (!currentUser.hasEmailAddress(committer.getEmailAddress()) && !refControl.canForgeCommitter()) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        messages.add(getInvalidEmailError(receiveEvent.commit, "committer", committer, currentUser, canonicalWebUrl));
        throw new CommitValidationException("invalid committer", messages);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc, List<ProjectWatchInfo> input) throws OrmException, RestApiException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to edit project watches");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    updateInDb(accountId, input);
    updateInGit(accountId, input);
    accountCache.evict(accountId);
    return getWatchedProjects.apply(rsrc);
}
#method_after
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc, List<ProjectWatchInfo> input) throws OrmException, RestApiException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to edit project watches");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    watchConfig.upsertProjectWatches(accountId, asMap(input));
    accountCache.evict(accountId);
    return getWatchedProjects.apply(rsrc);
}
#end_block

#method_before
private static String format(String project, String filter) {
    return project + (filter != null && !AccountProjectWatch.FILTER_ALL.equals(filter) ? " and filter " + filter : "");
}
#method_after
private static String format(String project, String filter) {
    return project + (filter != null && !WatchConfig.FILTER_ALL.equals(filter) ? " and filter " + filter : "");
}
#end_block

#method_before
public List<PatchSetData> sort(List<ChangeData> in, PatchSet startPs) throws OrmException, IOException {
    checkArgument(!in.isEmpty(), "Input may not be empty");
    // Map of all patch sets, keyed by commit SHA-1.
    Map<String, PatchSetData> byId = collectById(in);
    PatchSetData start = byId.get(startPs.getRevision().get());
    checkArgument(start != null, "%s not found in %s", startPs, in);
    ProjectControl ctl = start.data().changeControl().getProjectControl();
    // Map of patch set -> immediate parent.
    ListMultimap<PatchSetData, PatchSetData> parents = ArrayListMultimap.create(in.size(), 3);
    // Map of patch set -> immediate children.
    ListMultimap<PatchSetData, PatchSetData> children = ArrayListMultimap.create(in.size(), 3);
    // All other patch sets of the same change as startPs.
    List<PatchSetData> otherPatchSetsOfStart = new ArrayList<>();
    for (ChangeData cd : in) {
        for (PatchSet ps : cd.patchSets()) {
            PatchSetData thisPsd = checkNotNull(byId.get(ps.getRevision().get()));
            if (cd.getId().equals(start.id()) && !ps.getId().equals(start.psId())) {
                otherPatchSetsOfStart.add(thisPsd);
            }
            for (RevCommit p : thisPsd.commit().getParents()) {
                PatchSetData parentPsd = byId.get(p.name());
                if (parentPsd != null) {
                    parents.put(thisPsd, parentPsd);
                    children.put(parentPsd, thisPsd);
                }
            }
        }
    }
    Collection<PatchSetData> ancestors = walkAncestors(ctl, parents, start);
    List<PatchSetData> descendants = walkDescendants(ctl, children, start, otherPatchSetsOfStart, ancestors);
    List<PatchSetData> result = new ArrayList<>(ancestors.size() + descendants.size() - 1);
    result.addAll(Lists.reverse(descendants));
    result.addAll(ancestors);
    return result;
}
#method_after
public List<PatchSetData> sort(List<ChangeData> in, PatchSet startPs) throws OrmException, IOException {
    checkArgument(!in.isEmpty(), "Input may not be empty");
    // Map of all patch sets, keyed by commit SHA-1.
    Map<String, PatchSetData> byId = collectById(in);
    PatchSetData start = byId.get(startPs.getRevision().get());
    checkArgument(start != null, "%s not found in %s", startPs, in);
    ProjectControl ctl = start.data().changeControl().getProjectControl();
    // Map of patch set -> immediate parent.
    ListMultimap<PatchSetData, PatchSetData> parents = MultimapBuilder.hashKeys(in.size()).arrayListValues(3).build();
    // Map of patch set -> immediate children.
    ListMultimap<PatchSetData, PatchSetData> children = MultimapBuilder.hashKeys(in.size()).arrayListValues(3).build();
    // All other patch sets of the same change as startPs.
    List<PatchSetData> otherPatchSetsOfStart = new ArrayList<>();
    for (ChangeData cd : in) {
        for (PatchSet ps : cd.patchSets()) {
            PatchSetData thisPsd = checkNotNull(byId.get(ps.getRevision().get()));
            if (cd.getId().equals(start.id()) && !ps.getId().equals(start.psId())) {
                otherPatchSetsOfStart.add(thisPsd);
            }
            for (RevCommit p : thisPsd.commit().getParents()) {
                PatchSetData parentPsd = byId.get(p.name());
                if (parentPsd != null) {
                    parents.put(thisPsd, parentPsd);
                    children.put(parentPsd, thisPsd);
                }
            }
        }
    }
    Collection<PatchSetData> ancestors = walkAncestors(ctl, parents, start);
    List<PatchSetData> descendants = walkDescendants(ctl, children, start, otherPatchSetsOfStart, ancestors);
    List<PatchSetData> result = new ArrayList<>(ancestors.size() + descendants.size() - 1);
    result.addAll(Lists.reverse(descendants));
    result.addAll(ancestors);
    return result;
}
#end_block

#method_before
private void findUnmergedChanges(List<Change.Id> alreadyMerged) throws ResourceConflictException, IntegrationException {
    for (SubmitStrategy strategy : strategies) {
        if (strategy instanceof CherryPick) {
            // Might have picked a subset of changes, can't do this sanity check.
            continue;
        }
        SubmitStrategy.Arguments args = strategy.args;
        Set<Change.Id> unmerged = args.mergeUtil.findUnmergedChanges(args.commits.getChangeIds(args.destBranch), args.rw, args.canMergeFlag, args.mergeTip.getInitialTip(), args.mergeTip.getCurrentTip(), alreadyMerged);
        for (Change.Id id : unmerged) {
            commits.problem(id, "internal error: change not reachable from new branch tip");
        }
    }
    commits.maybeFailVerbose();
}
#method_after
private void findUnmergedChanges(List<Change.Id> alreadyMerged) throws ResourceConflictException, IntegrationException {
    for (SubmitStrategy strategy : strategies) {
        if (strategy instanceof CherryPick) {
            // * CherryPick might have status SKIPPED_IDENTICAL_TREE
            continue;
        }
        SubmitStrategy.Arguments args = strategy.args;
        Set<Change.Id> unmerged = args.mergeUtil.findUnmergedChanges(args.commitStatus.getChangeIds(args.destBranch), args.rw, args.canMergeFlag, args.mergeTip.getInitialTip(), args.mergeTip.getCurrentTip(), alreadyMerged);
        for (Change.Id id : unmerged) {
            commitStatus.problem(id, "internal error: change not reachable from new branch tip");
        }
    }
    commitStatus.maybeFailVerbose();
}
#end_block

#method_before
private List<Change.Id> checkCommitStatus() throws ResourceConflictException {
    List<Change.Id> alreadyMerged = new ArrayList<>(commits.getChangeIds().size());
    for (Change.Id id : commits.getChangeIds()) {
        CodeReviewCommit commit = commits.get(id);
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            commits.problem(id, "internal error: change not processed by merge strategy");
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
            case CLEAN_REBASE:
            case CLEAN_PICK:
            case SKIPPED_IDENTICAL_TREE:
                // Merge strategy accepted this change.
                break;
            case ALREADY_MERGED:
                // Already an ancestor of tip.
                alreadyMerged.add(commit.getPatchsetId().getParentKey());
                break;
            case PATH_CONFLICT:
            case REBASE_MERGE_CONFLICT:
            case MANUAL_RECURSIVE_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case CANNOT_REBASE_ROOT:
            case NOT_FAST_FORWARD:
                // TODO(dborowitz): Reformat these messages to be more appropriate for
                // short problem descriptions.
                commits.problem(id, CharMatcher.is('\n').collapseFrom(s.getMessage(), ' '));
                break;
            case MISSING_DEPENDENCY:
                commits.problem(id, "depends on change that was not submitted");
                break;
            default:
                commits.problem(id, "unspecified merge failure: " + s);
                break;
        }
    }
    commits.maybeFailVerbose();
    return alreadyMerged;
}
#method_after
private List<Change.Id> checkCommitStatus() throws ResourceConflictException {
    List<Change.Id> alreadyMerged = new ArrayList<>(commitStatus.getChangeIds().size());
    for (Change.Id id : commitStatus.getChangeIds()) {
        CodeReviewCommit commit = commitStatus.get(id);
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            commitStatus.problem(id, "internal error: change not processed by merge strategy");
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
            case CLEAN_REBASE:
            case CLEAN_PICK:
            case SKIPPED_IDENTICAL_TREE:
                // Merge strategy accepted this change.
                break;
            case ALREADY_MERGED:
                // Already an ancestor of tip.
                alreadyMerged.add(commit.getPatchsetId().getParentKey());
                break;
            case PATH_CONFLICT:
            case REBASE_MERGE_CONFLICT:
            case MANUAL_RECURSIVE_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case CANNOT_REBASE_ROOT:
            case NOT_FAST_FORWARD:
                // TODO(dborowitz): Reformat these messages to be more appropriate for
                // short problem descriptions.
                commitStatus.problem(id, CharMatcher.is('\n').collapseFrom(s.getMessage(), ' '));
                break;
            case MISSING_DEPENDENCY:
                commitStatus.problem(id, "depends on change that was not submitted");
                break;
            default:
                commitStatus.problem(id, "unspecified merge failure: " + s);
                break;
        }
    }
    commitStatus.maybeFailVerbose();
    return alreadyMerged;
}
#end_block

#method_before
@Override
public void afterUpdateChanges() throws ResourceConflictException {
    commits.maybeFail("Error updating status");
}
#method_after
@Override
public void afterUpdateChanges() throws ResourceConflictException {
    commitStatus.maybeFail("Error updating status");
}
#end_block

#method_before
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    DiffPreferencesInfo prefs = new DiffPreferencesInfo();
    if (whitespace != null) {
        prefs.ignoreWhitespace = whitespace;
    } else if (ignoreWhitespace != null) {
        prefs.ignoreWhitespace = ignoreWhitespace.whitespace;
    } else {
        prefs.ignoreWhitespace = Whitespace.IGNORE_LEADING_AND_TRAILING;
    }
    prefs.context = context;
    prefs.intralineDifference = intraline;
    PatchScriptFactory psf;
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet.getId(), resource.getPatchKey().getParentKey(), prefs);
    } else if (parentNum > 0) {
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), parentNum - 1, resource.getPatchKey().getParentKey(), prefs);
    } else {
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), null, resource.getPatchKey().getParentKey(), prefs);
    }
    try {
        psf.setLoadHistory(false);
        psf.setLoadComments(context != DiffPreferencesInfo.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %s; want %s", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %s; want %s", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        // TODO referring to the parent commit by refs/changes/12/60012/1^1
        // will likely not work for inline edits
        String revA = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        FluentIterable<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getProject().getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links.toList();
        if (!webLinksOnly) {
            if (ps.isBinary()) {
                result.binary = true;
            }
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                result.metaA.contentType = FileContentUtil.resolveContentType(state, result.metaA.name, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
                result.metaA.commitId = content.commitIdA;
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                result.metaB.contentType = FileContentUtil.resolveContentType(state, result.metaB.name, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
                result.metaB.commitId = content.commitIdB;
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    }
}
#method_after
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    DiffPreferencesInfo prefs = new DiffPreferencesInfo();
    if (whitespace != null) {
        prefs.ignoreWhitespace = whitespace;
    } else if (ignoreWhitespace != null) {
        prefs.ignoreWhitespace = ignoreWhitespace.whitespace;
    } else {
        prefs.ignoreWhitespace = Whitespace.IGNORE_LEADING_AND_TRAILING;
    }
    prefs.context = context;
    prefs.intralineDifference = intraline;
    PatchScriptFactory psf;
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet.getId(), resource.getPatchKey().getParentKey(), prefs);
    } else if (parentNum > 0) {
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), parentNum - 1, resource.getPatchKey().getParentKey(), prefs);
    } else {
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), null, resource.getPatchKey().getParentKey(), prefs);
    }
    try {
        psf.setLoadHistory(false);
        psf.setLoadComments(context != DiffPreferencesInfo.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %s; want %s", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %s; want %s", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        // TODO referring to the parent commit by refs/changes/12/60012/1^1
        // will likely not work for inline edits
        String revA = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        List<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getProject().getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links;
        if (!webLinksOnly) {
            if (ps.isBinary()) {
                result.binary = true;
            }
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                result.metaA.contentType = FileContentUtil.resolveContentType(state, result.metaA.name, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
                result.metaA.commitId = content.commitIdA;
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                result.metaB.contentType = FileContentUtil.resolveContentType(state, result.metaB.name, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
                result.metaB.commitId = content.commitIdB;
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    }
}
#end_block

#method_before
private List<WebLinkInfo> getFileWebLinks(Project project, String rev, String file) {
    FluentIterable<WebLinkInfo> links = webLinks.getFileLinks(project.getName(), rev, file);
    return links.isEmpty() ? null : links.toList();
}
#method_after
private List<WebLinkInfo> getFileWebLinks(Project project, String rev, String file) {
    List<WebLinkInfo> links = webLinks.getFileLinks(project.getName(), rev, file);
    return links.isEmpty() ? null : links;
}
#end_block

#method_before
@Override
public CommentInfo update(DraftInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public CommentInfo update(DraftInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void delete() {
    throw new NotImplementedException();
}
#end_block

#method_before
private void checkExpectMergedAs() {
    ObjectId objId = parseObjectId(fix.expectMergedAs, "expected merged commit");
    RevCommit commit = parseCommit(objId, "expected merged commit");
    if (commit == null) {
        return;
    }
    try {
        if (!rw.isMergedInto(commit, tip)) {
            problem(String.format("Expected merged commit %s is not merged into" + " destination ref %s (%s)", commit.name(), change().getDest().get(), tip.name()));
            return;
        }
        List<PatchSet.Id> thisCommitPsIds = new ArrayList<>();
        for (Ref ref : repo.getRefDatabase().getRefs(REFS_CHANGES).values()) {
            if (!ref.getObjectId().equals(commit)) {
                continue;
            }
            PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
            if (psId == null) {
                continue;
            }
            try {
                Change c = notesFactory.createChecked(db.get(), change().getProject(), psId.getParentKey()).getChange();
                if (!c.getDest().equals(change().getDest())) {
                    continue;
                }
            } catch (OrmException | NoSuchChangeException e) {
                warn(e);
            // Include this patch set; should cause an error below, which is good.
            }
            thisCommitPsIds.add(psId);
        }
        switch(thisCommitPsIds.size()) {
            case 0:
                // No patch set for this commit; insert one.
                rw.parseBody(commit);
                String changeId = Iterables.getFirst(commit.getFooterLines(FooterConstants.CHANGE_ID), null);
                // Missing Change-Id footer is ok, but mismatched is not.
                if (changeId != null && !changeId.equals(change().getKey().get())) {
                    problem(String.format("Expected merged commit %s has Change-Id: %s," + " but expected %s", commit.name(), changeId, change().getKey().get()));
                    return;
                }
                insertMergedPatchSet(commit, null, false);
                break;
            case 1:
                // Existing patch set ref pointing to this commit.
                PatchSet.Id id = thisCommitPsIds.get(0);
                if (id.equals(change().currentPatchSetId())) {
                    // If it's the current patch set, we can just fix the status.
                    fixMerged(wrongChangeStatus(id, commit));
                } else if (id.get() > change().currentPatchSetId().get()) {
                    // If it's newer than the current patch set, reuse this patch set
                    // ID when inserting a new merged patch set.
                    insertMergedPatchSet(commit, id, true);
                } else {
                    // If it's older than the current patch set, just delete the old
                    // ref, and use a new ID when inserting a new merged patch set.
                    insertMergedPatchSet(commit, id, false);
                }
                break;
            default:
                problem(String.format("Multiple patch sets for expected merged commit %s: %s", commit.name(), intKeyOrdering().sortedCopy(thisCommitPsIds)));
                break;
        }
    } catch (IOException e) {
        error("Error looking up expected merged commit " + fix.expectMergedAs, e);
    }
}
#method_after
private void checkExpectMergedAs() {
    ObjectId objId = parseObjectId(fix.expectMergedAs, "expected merged commit");
    RevCommit commit = parseCommit(objId, "expected merged commit");
    if (commit == null) {
        return;
    }
    try {
        if (!rw.isMergedInto(commit, tip)) {
            problem(String.format("Expected merged commit %s is not merged into" + " destination ref %s (%s)", commit.name(), change().getDest().get(), tip.name()));
            return;
        }
        List<PatchSet.Id> thisCommitPsIds = new ArrayList<>();
        for (Ref ref : repo.getRefDatabase().getRefs(REFS_CHANGES).values()) {
            if (!ref.getObjectId().equals(commit)) {
                continue;
            }
            PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
            if (psId == null) {
                continue;
            }
            try {
                Change c = notesFactory.createChecked(db.get(), change().getProject(), psId.getParentKey()).getChange();
                if (!c.getDest().equals(change().getDest())) {
                    continue;
                }
            } catch (OrmException e) {
                warn(e);
            // Include this patch set; should cause an error below, which is good.
            }
            thisCommitPsIds.add(psId);
        }
        switch(thisCommitPsIds.size()) {
            case 0:
                // No patch set for this commit; insert one.
                rw.parseBody(commit);
                String changeId = Iterables.getFirst(commit.getFooterLines(FooterConstants.CHANGE_ID), null);
                // Missing Change-Id footer is ok, but mismatched is not.
                if (changeId != null && !changeId.equals(change().getKey().get())) {
                    problem(String.format("Expected merged commit %s has Change-Id: %s," + " but expected %s", commit.name(), changeId, change().getKey().get()));
                    return;
                }
                insertMergedPatchSet(commit, null, false);
                break;
            case 1:
                // Existing patch set ref pointing to this commit.
                PatchSet.Id id = thisCommitPsIds.get(0);
                if (id.equals(change().currentPatchSetId())) {
                    // If it's the current patch set, we can just fix the status.
                    fixMerged(wrongChangeStatus(id, commit));
                } else if (id.get() > change().currentPatchSetId().get()) {
                    // If it's newer than the current patch set, reuse this patch set
                    // ID when inserting a new merged patch set.
                    insertMergedPatchSet(commit, id, true);
                } else {
                    // If it's older than the current patch set, just delete the old
                    // ref, and use a new ID when inserting a new merged patch set.
                    insertMergedPatchSet(commit, id, false);
                }
                break;
            default:
                problem(String.format("Multiple patch sets for expected merged commit %s: %s", commit.name(), intKeyOrdering().sortedCopy(thisCommitPsIds)));
                break;
        }
    } catch (IOException e) {
        error("Error looking up expected merged commit " + fix.expectMergedAs, e);
    }
}
#end_block

#method_before
private void insertMergedPatchSet(final RevCommit commit, @Nullable final PatchSet.Id psIdToDelete, boolean reuseOldPsId) {
    ProblemInfo notFound = problem("No patch set found for merged commit " + commit.name());
    if (!user.get().isIdentifiedUser()) {
        notFound.status = Status.FIX_FAILED;
        notFound.outcome = "Must be called by an identified user to insert new patch set";
        return;
    }
    ProblemInfo insertPatchSetProblem;
    ProblemInfo deleteOldPatchSetProblem;
    if (psIdToDelete == null) {
        insertPatchSetProblem = problem(String.format("Expected merged commit %s has no associated patch set", commit.name()));
        deleteOldPatchSetProblem = null;
    } else {
        String msg = String.format("Expected merge commit %s corresponds to patch set %s," + " not the current patch set %s", commit.name(), psIdToDelete.get(), change().currentPatchSetId().get());
        // Maybe an identical problem, but different fix.
        deleteOldPatchSetProblem = reuseOldPsId ? null : problem(msg);
        insertPatchSetProblem = problem(msg);
    }
    List<ProblemInfo> currProblems = new ArrayList<>(3);
    currProblems.add(notFound);
    if (deleteOldPatchSetProblem != null) {
        currProblems.add(insertPatchSetProblem);
    }
    currProblems.add(insertPatchSetProblem);
    try {
        PatchSet.Id psId = (psIdToDelete != null && reuseOldPsId) ? psIdToDelete : ChangeUtil.nextPatchSetId(repo, change().currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, commit);
        try (BatchUpdate bu = newBatchUpdate();
            ObjectInserter oi = repo.newObjectInserter()) {
            bu.setRepository(repo, rw, oi);
            if (psIdToDelete != null) {
                // Delete the given patch set ref. If reuseOldPsId is true,
                // PatchSetInserter will reinsert the same ref, making it a no-op.
                bu.addOp(ctl.getId(), new BatchUpdate.Op() {

                    @Override
                    public void updateRepo(RepoContext ctx) throws IOException {
                        ctx.addRefUpdate(new ReceiveCommand(commit, ObjectId.zeroId(), psIdToDelete.toRefName()));
                    }
                });
                if (!reuseOldPsId) {
                    bu.addOp(ctl.getId(), new DeletePatchSetFromDbOp(checkNotNull(deleteOldPatchSetProblem), psIdToDelete));
                }
            }
            bu.addOp(ctl.getId(), inserter.setValidatePolicy(CommitValidators.Policy.NONE).setFireRevisionCreated(false).setNotify(NotifyHandling.NONE).setAllowClosed(true).setMessage("Patch set for merged commit inserted by consistency checker"));
            bu.addOp(ctl.getId(), new FixMergedOp(notFound));
            bu.execute();
        }
        ctl = changeControlFactory.controlFor(db.get(), inserter.getChange(), ctl.getUser());
        insertPatchSetProblem.status = Status.FIXED;
        insertPatchSetProblem.outcome = "Inserted as patch set " + psId.get();
    } catch (OrmException | IOException | NoSuchChangeException | UpdateException | RestApiException e) {
        warn(e);
        for (ProblemInfo pi : currProblems) {
            pi.status = Status.FIX_FAILED;
            pi.outcome = "Error inserting merged patch set";
        }
        return;
    }
}
#method_after
private void insertMergedPatchSet(final RevCommit commit, @Nullable final PatchSet.Id psIdToDelete, boolean reuseOldPsId) {
    ProblemInfo notFound = problem("No patch set found for merged commit " + commit.name());
    if (!user.get().isIdentifiedUser()) {
        notFound.status = Status.FIX_FAILED;
        notFound.outcome = "Must be called by an identified user to insert new patch set";
        return;
    }
    ProblemInfo insertPatchSetProblem;
    ProblemInfo deleteOldPatchSetProblem;
    if (psIdToDelete == null) {
        insertPatchSetProblem = problem(String.format("Expected merged commit %s has no associated patch set", commit.name()));
        deleteOldPatchSetProblem = null;
    } else {
        String msg = String.format("Expected merge commit %s corresponds to patch set %s," + " not the current patch set %s", commit.name(), psIdToDelete.get(), change().currentPatchSetId().get());
        // Maybe an identical problem, but different fix.
        deleteOldPatchSetProblem = reuseOldPsId ? null : problem(msg);
        insertPatchSetProblem = problem(msg);
    }
    List<ProblemInfo> currProblems = new ArrayList<>(3);
    currProblems.add(notFound);
    if (deleteOldPatchSetProblem != null) {
        currProblems.add(insertPatchSetProblem);
    }
    currProblems.add(insertPatchSetProblem);
    try {
        PatchSet.Id psId = (psIdToDelete != null && reuseOldPsId) ? psIdToDelete : ChangeUtil.nextPatchSetId(repo, change().currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, commit);
        try (BatchUpdate bu = newBatchUpdate();
            ObjectInserter oi = repo.newObjectInserter()) {
            bu.setRepository(repo, rw, oi);
            if (psIdToDelete != null) {
                // Delete the given patch set ref. If reuseOldPsId is true,
                // PatchSetInserter will reinsert the same ref, making it a no-op.
                bu.addOp(ctl.getId(), new BatchUpdate.Op() {

                    @Override
                    public void updateRepo(RepoContext ctx) throws IOException {
                        ctx.addRefUpdate(new ReceiveCommand(commit, ObjectId.zeroId(), psIdToDelete.toRefName()));
                    }
                });
                if (!reuseOldPsId) {
                    bu.addOp(ctl.getId(), new DeletePatchSetFromDbOp(checkNotNull(deleteOldPatchSetProblem), psIdToDelete));
                }
            }
            bu.addOp(ctl.getId(), inserter.setValidatePolicy(CommitValidators.Policy.NONE).setFireRevisionCreated(false).setNotify(NotifyHandling.NONE).setAllowClosed(true).setMessage("Patch set for merged commit inserted by consistency checker"));
            bu.addOp(ctl.getId(), new FixMergedOp(notFound));
            bu.execute();
        }
        ctl = changeControlFactory.controlFor(db.get(), inserter.getChange(), ctl.getUser());
        insertPatchSetProblem.status = Status.FIXED;
        insertPatchSetProblem.outcome = "Inserted as patch set " + psId.get();
    } catch (OrmException | IOException | UpdateException | RestApiException e) {
        warn(e);
        for (ProblemInfo pi : currProblems) {
            pi.status = Status.FIX_FAILED;
            pi.outcome = "Error inserting merged patch set";
        }
        return;
    }
}
#end_block

#method_before
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    Injector injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
@Before
public void setUpInjector() throws Exception {
    lifecycle = new LifecycleManager();
    injector = createInjector();
    lifecycle.add(injector);
    injector.injectMembers(this);
    lifecycle.start();
    setUpDatabase();
}
#end_block

#method_before
@Before
public void setTimeForTesting() {
    resetTimeWithClockStep(1, MILLISECONDS);
}
#method_after
@Before
public void setTimeForTesting() {
    resetTimeWithClockStep(1, SECONDS);
}
#end_block

#method_before
@Test
public void byOwner() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    assertQuery("owner:" + userId.get(), change1);
    assertQuery("owner:" + user2, change2);
}
#method_after
@Test
public void byOwner() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo), userId);
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId();
    Change change2 = insert(repo, newChange(repo), user2);
    assertQuery("owner:" + userId.get(), change1);
    assertQuery("owner:" + user2, change2);
    String nameEmail = user.asIdentifiedUser().getNameEmail();
    assertQuery("owner: \"" + nameEmail + "\"", change1);
}
#end_block

#method_before
@Test
@TestProjectInput(createEmptyCommit = false)
public void listBranchesOfEmptyProject() throws Exception {
    assertBranches(ImmutableList.of(branch("HEAD", null, false), branch(RefNames.REFS_CONFIG, null, false)), list().get());
}
#method_after
@Test
@TestProjectInput(createEmptyCommit = false)
public void listBranchesOfEmptyProject() throws Exception {
    assertRefs(ImmutableList.of(branch("HEAD", null, false), branch(RefNames.REFS_CONFIG, null, false)), list().get());
}
#end_block

#method_before
@Test
public void listBranches() throws Exception {
    String master = pushTo("refs/heads/master").getCommit().name();
    String dev = pushTo("refs/heads/dev").getCommit().name();
    assertBranches(ImmutableList.of(branch("HEAD", "master", false), branch(RefNames.REFS_CONFIG, null, false), branch("refs/heads/dev", dev, true), branch("refs/heads/master", master, false)), list().get());
}
#method_after
@Test
public void listBranches() throws Exception {
    String master = pushTo("refs/heads/master").getCommit().name();
    String dev = pushTo("refs/heads/dev").getCommit().name();
    assertRefs(ImmutableList.of(branch("HEAD", "master", false), branch(RefNames.REFS_CONFIG, null, false), branch("refs/heads/dev", dev, true), branch("refs/heads/master", master, false)), list().get());
}
#end_block

#method_before
@Test
public void listBranchesSomeHidden() throws Exception {
    blockRead("refs/heads/dev");
    String master = pushTo("refs/heads/master").getCommit().name();
    pushTo("refs/heads/dev");
    setApiUser(user);
    // refs/meta/config is hidden since user is no project owner
    assertBranches(ImmutableList.of(branch("HEAD", "master", false), branch("refs/heads/master", master, false)), list().get());
}
#method_after
@Test
public void listBranchesSomeHidden() throws Exception {
    blockRead("refs/heads/dev");
    String master = pushTo("refs/heads/master").getCommit().name();
    pushTo("refs/heads/dev");
    setApiUser(user);
    // refs/meta/config is hidden since user is no project owner
    assertRefs(ImmutableList.of(branch("HEAD", "master", false), branch("refs/heads/master", master, false)), list().get());
}
#end_block

#method_before
@Test
public void listBranchesHeadHidden() throws Exception {
    blockRead("refs/heads/master");
    pushTo("refs/heads/master");
    String dev = pushTo("refs/heads/dev").getCommit().name();
    setApiUser(user);
    // refs/meta/config is hidden since user is no project owner
    assertBranches(ImmutableList.of(branch("refs/heads/dev", dev, false)), list().get());
}
#method_after
@Test
public void listBranchesHeadHidden() throws Exception {
    blockRead("refs/heads/master");
    pushTo("refs/heads/master");
    String dev = pushTo("refs/heads/dev").getCommit().name();
    setApiUser(user);
    // refs/meta/config is hidden since user is no project owner
    assertRefs(ImmutableList.of(branch("refs/heads/dev", dev, false)), list().get());
}
#end_block

#method_before
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, CurrentUser user) {
    if (isRE(ref)) {
        ref = RefPattern.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    boolean perUser = false;
    Map<AccessSection, Project.NameKey> sectionToProject = new LinkedHashMap<>();
    for (SectionMatcher sm : matcherList) {
        // 
        if (sm.matcher instanceof RefPatternMatcher.ExpandParameters) {
            if (!((RefPatternMatcher.ExpandParameters) sm.matcher).matchPrefix(ref)) {
                continue;
            }
            perUser = true;
            if (sm.match(ref, user)) {
                sectionToProject.put(sm.section, sm.project);
                break;
            }
        } else if (sm.match(ref, null)) {
            sectionToProject.put(sm.section, sm.project);
        }
    }
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    sorter.sort(ref, sections);
    Set<SeenRule> seen = new HashSet<>();
    Set<String> exclusiveGroupPermissions = new HashSet<>();
    HashMap<String, List<PermissionRule>> permissions = new HashMap<>();
    HashMap<String, List<PermissionRule>> overridden = new HashMap<>();
    Map<PermissionRule, ProjectRef> ruleProps = Maps.newIdentityHashMap();
    Multimap<Project.NameKey, String> exclusivePermissionsByProject = ArrayListMultimap.create();
    for (AccessSection section : sections) {
        Project.NameKey project = sectionToProject.get(section);
        for (Permission permission : section.getPermissions()) {
            boolean exclusivePermissionExists = exclusiveGroupPermissions.contains(permission.getName());
            for (PermissionRule rule : permission.getRules()) {
                SeenRule s = SeenRule.create(section, permission, rule);
                boolean addRule;
                if (rule.isBlock()) {
                    addRule = !exclusivePermissionsByProject.containsEntry(project, permission.getName());
                } else {
                    addRule = seen.add(s) && !rule.isDeny() && !exclusivePermissionExists;
                }
                HashMap<String, List<PermissionRule>> p = null;
                if (addRule) {
                    p = permissions;
                } else if (!rule.isDeny() && !exclusivePermissionExists) {
                    p = overridden;
                }
                if (p != null) {
                    List<PermissionRule> r = p.get(permission.getName());
                    if (r == null) {
                        r = new ArrayList<>(2);
                        p.put(permission.getName(), r);
                    }
                    r.add(rule);
                    ruleProps.put(rule, ProjectRef.create(project, section.getName()));
                }
            }
            if (permission.getExclusiveGroup()) {
                exclusivePermissionsByProject.put(project, permission.getName());
                exclusiveGroupPermissions.add(permission.getName());
            }
        }
    }
    return new PermissionCollection(permissions, overridden, ruleProps, perUser);
}
#method_after
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, CurrentUser user) {
    if (isRE(ref)) {
        ref = RefPattern.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    boolean perUser = false;
    Map<AccessSection, Project.NameKey> sectionToProject = new LinkedHashMap<>();
    for (SectionMatcher sm : matcherList) {
        // 
        if (sm.matcher instanceof RefPatternMatcher.ExpandParameters) {
            if (!((RefPatternMatcher.ExpandParameters) sm.matcher).matchPrefix(ref)) {
                continue;
            }
            perUser = true;
            if (sm.match(ref, user)) {
                sectionToProject.put(sm.section, sm.project);
                break;
            }
        } else if (sm.match(ref, null)) {
            sectionToProject.put(sm.section, sm.project);
        }
    }
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    sorter.sort(ref, sections);
    Set<SeenRule> seen = new HashSet<>();
    Set<String> exclusiveGroupPermissions = new HashSet<>();
    HashMap<String, List<PermissionRule>> permissions = new HashMap<>();
    HashMap<String, List<PermissionRule>> overridden = new HashMap<>();
    Map<PermissionRule, ProjectRef> ruleProps = Maps.newIdentityHashMap();
    ListMultimap<Project.NameKey, String> exclusivePermissionsByProject = MultimapBuilder.hashKeys().arrayListValues().build();
    for (AccessSection section : sections) {
        Project.NameKey project = sectionToProject.get(section);
        for (Permission permission : section.getPermissions()) {
            boolean exclusivePermissionExists = exclusiveGroupPermissions.contains(permission.getName());
            for (PermissionRule rule : permission.getRules()) {
                SeenRule s = SeenRule.create(section, permission, rule);
                boolean addRule;
                if (rule.isBlock()) {
                    addRule = !exclusivePermissionsByProject.containsEntry(project, permission.getName());
                } else {
                    addRule = seen.add(s) && !rule.isDeny() && !exclusivePermissionExists;
                }
                HashMap<String, List<PermissionRule>> p = null;
                if (addRule) {
                    p = permissions;
                } else if (!rule.isDeny() && !exclusivePermissionExists) {
                    p = overridden;
                }
                if (p != null) {
                    List<PermissionRule> r = p.get(permission.getName());
                    if (r == null) {
                        r = new ArrayList<>(2);
                        p.put(permission.getName(), r);
                    }
                    r.add(rule);
                    ruleProps.put(rule, ProjectRef.create(project, section.getName()));
                }
            }
            if (permission.getExclusiveGroup()) {
                exclusivePermissionsByProject.put(project, permission.getName());
                exclusiveGroupPermissions.add(permission.getName());
            }
        }
    }
    return new PermissionCollection(permissions, overridden, ruleProps, perUser);
}
#end_block

#method_before
void set(final ChangeInfo info, final String revision) {
    if (info.status().isOpen()) {
        setForOpenChange(info, revision);
    }
    ChangeApi.revision(info.legacyId().get(), revision).view("related").get(new TabCallback<RelatedInfo>(Tab.RELATED_CHANGES, info.project(), revision) {

        @Override
        public JsArray<ChangeAndCommit> convert(RelatedInfo result) {
            return result.changes();
        }
    });
    StringBuilder cherryPicksQuery = new StringBuilder();
    cherryPicksQuery.append(op("project", info.project()));
    cherryPicksQuery.append(" ").append(op("change", info.changeId()));
    cherryPicksQuery.append(" ").append(op("-change", info.legacyId().get()));
    cherryPicksQuery.append(" -is:abandoned");
    ChangeList.query(cherryPicksQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT), new TabChangeListCallback(Tab.CHERRY_PICKS, info.project(), revision));
    if (info.currentRevision().equals(revision)) {
        ChangeApi.change(info.legacyId().get()).view("submitted_together").get(new TabChangeListCallback(Tab.SUBMITTED_TOGETHER, info.project(), revision));
    }
    if (!Gerrit.info().change().isSubmitWholeTopicEnabled() && info.topic() != null && !"".equals(info.topic())) {
        StringBuilder topicQuery = new StringBuilder();
        topicQuery.append("status:open");
        topicQuery.append(" ").append(op("topic", info.topic()));
        ChangeList.query(topicQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT, ListChangesOption.DETAILED_LABELS, ListChangesOption.LABELS), new TabChangeListCallback(Tab.SAME_TOPIC, info.project(), revision));
    }
}
#method_after
void set(final ChangeInfo info, final String revision) {
    if (info.status().isOpen()) {
        setForOpenChange(info, revision);
    }
    ChangeApi.revision(info.legacyId().get(), revision).view("related").get(new TabCallback<RelatedInfo>(Tab.RELATED_CHANGES, info.project(), revision) {

        @Override
        public JsArray<ChangeAndCommit> convert(RelatedInfo result) {
            return result.changes();
        }
    });
    StringBuilder cherryPicksQuery = new StringBuilder();
    cherryPicksQuery.append(op("project", info.project()));
    cherryPicksQuery.append(" ").append(op("change", info.changeId()));
    cherryPicksQuery.append(" ").append(op("-change", info.legacyId().get()));
    cherryPicksQuery.append(" -is:abandoned");
    ChangeList.query(cherryPicksQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT), new TabChangeListCallback(Tab.CHERRY_PICKS, info.project(), revision));
    if (info.currentRevision() != null && info.currentRevision().equals(revision)) {
        ChangeApi.change(info.legacyId().get()).view("submitted_together").get(new TabChangeListCallback(Tab.SUBMITTED_TOGETHER, info.project(), revision));
    }
    if (!Gerrit.info().change().isSubmitWholeTopicEnabled() && info.topic() != null && !"".equals(info.topic())) {
        StringBuilder topicQuery = new StringBuilder();
        topicQuery.append("status:open");
        topicQuery.append(" ").append(op("topic", info.topic()));
        ChangeList.query(topicQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT, ListChangesOption.DETAILED_LABELS, ListChangesOption.LABELS), new TabChangeListCallback(Tab.SAME_TOPIC, info.project(), revision));
    }
}
#end_block

#method_before
@Override
public TagApi create(TagInput input) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public TagApi create(TagInput input) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public TagInfo get() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public TagInfo get() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource rsrc, List<ProjectWatchInfo> input) throws AuthException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to edit project watches " + "of other users");
    }
    if (input == null) {
        return Response.none();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    deleteFromDb(accountId, input);
    deleteFromGit(accountId, input);
    accountCache.evict(accountId);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource rsrc, List<ProjectWatchInfo> input) throws AuthException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to edit project watches " + "of other users");
    }
    if (input == null) {
        return Response.none();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    watchConfig.deleteProjectWatches(accountId, input.stream().map(w -> ProjectWatchKey.create(new Project.NameKey(w.project), w.filter)).collect(toList()));
    accountCache.evict(accountId);
    return Response.none();
}
#end_block

#method_before
@Override
protected void configure() {
    install(new FactoryModuleBuilder().implement(ChangeIndex.class, LuceneChangeIndex.class).build(ChangeIndex.Factory.class));
    install(new FactoryModuleBuilder().implement(AccountIndex.class, LuceneAccountIndex.class).build(AccountIndex.Factory.class));
    install(new IndexModule(threads));
    if (singleVersions == null) {
        install(new MultiVersionModule());
    } else {
        install(new SingleVersionModule(singleVersions));
    }
}
#method_after
@Override
protected void configure() {
    install(new FactoryModuleBuilder().implement(AccountIndex.class, LuceneAccountIndex.class).build(AccountIndex.Factory.class));
    install(new FactoryModuleBuilder().implement(ChangeIndex.class, LuceneChangeIndex.class).build(ChangeIndex.Factory.class));
    install(new FactoryModuleBuilder().implement(GroupIndex.class, LuceneGroupIndex.class).build(GroupIndex.Factory.class));
    install(new IndexModule(threads));
    if (singleVersions == null) {
        install(new MultiVersionModule());
    } else {
        install(new SingleVersionModule(singleVersions));
    }
}
#end_block

#method_before
Base parseBase(RevisionResource rsrc, String base) throws OrmException, NoSuchChangeException {
    ReviewDb db = dbProvider.get();
    // Try parsing the base as a ref string.
    PatchSet.Id basePatchSetId = PatchSet.Id.fromRef(base);
    if (basePatchSetId != null) {
        Change.Id baseChangeId = basePatchSetId.getParentKey();
        ChangeControl baseCtl = controlFor(rsrc, baseChangeId);
        if (baseCtl != null) {
            return Base.create(controlFor(rsrc, basePatchSetId.getParentKey()), psUtil.get(db, baseCtl.getNotes(), basePatchSetId));
        }
    }
    // Try parsing base as a change number (assume current patch set).
    Integer baseChangeId = Ints.tryParse(base);
    if (baseChangeId != null) {
        ChangeControl baseCtl = controlFor(rsrc, new Change.Id(baseChangeId));
        if (baseCtl != null) {
            return Base.create(baseCtl, psUtil.current(db, baseCtl.getNotes()));
        }
    }
    // Try parsing as SHA-1.
    Base ret = null;
    for (ChangeData cd : queryProvider.get().byProjectCommit(rsrc.getProject(), base)) {
        for (PatchSet ps : cd.patchSets()) {
            if (!ps.getRevision().matches(base)) {
                continue;
            }
            if (ret == null || ret.patchSet().getId().get() < ps.getId().get()) {
                ret = Base.create(rsrc.getControl().getProjectControl().controlFor(cd.notes()), ps);
            }
        }
    }
    return ret;
}
#method_after
Base parseBase(RevisionResource rsrc, String base) throws OrmException {
    ReviewDb db = dbProvider.get();
    // Try parsing the base as a ref string.
    PatchSet.Id basePatchSetId = PatchSet.Id.fromRef(base);
    if (basePatchSetId != null) {
        Change.Id baseChangeId = basePatchSetId.getParentKey();
        ChangeControl baseCtl = controlFor(rsrc, baseChangeId);
        if (baseCtl != null) {
            return Base.create(controlFor(rsrc, basePatchSetId.getParentKey()), psUtil.get(db, baseCtl.getNotes(), basePatchSetId));
        }
    }
    // Try parsing base as a change number (assume current patch set).
    Integer baseChangeId = Ints.tryParse(base);
    if (baseChangeId != null) {
        ChangeControl baseCtl = controlFor(rsrc, new Change.Id(baseChangeId));
        if (baseCtl != null) {
            return Base.create(baseCtl, psUtil.current(db, baseCtl.getNotes()));
        }
    }
    // Try parsing as SHA-1.
    Base ret = null;
    for (ChangeData cd : queryProvider.get().byProjectCommit(rsrc.getProject(), base)) {
        for (PatchSet ps : cd.patchSets()) {
            if (!ps.getRevision().matches(base)) {
                continue;
            }
            if (ret == null || ret.patchSet().getId().get() < ps.getId().get()) {
                ret = Base.create(rsrc.getControl().getProjectControl().controlFor(cd.notes()), ps);
            }
        }
    }
    return ret;
}
#end_block

#method_before
private ChangeControl controlFor(RevisionResource rsrc, Change.Id id) throws OrmException, NoSuchChangeException {
    if (rsrc.getChange().getId().equals(id)) {
        return rsrc.getControl();
    }
    ChangeNotes notes = notesFactory.createChecked(dbProvider.get(), rsrc.getProject(), id);
    return rsrc.getControl().getProjectControl().controlFor(notes);
}
#method_after
private ChangeControl controlFor(RevisionResource rsrc, Change.Id id) throws OrmException {
    if (rsrc.getChange().getId().equals(id)) {
        return rsrc.getControl();
    }
    ChangeNotes notes = notesFactory.createChecked(dbProvider.get(), rsrc.getProject(), id);
    return rsrc.getControl().getProjectControl().controlFor(notes);
}
#end_block

#method_before
private AccountGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException, IOException {
    // Do not allow creating groups with the same name as system groups
    List<String> sysGroupNames = SystemGroupBackend.getNames();
    for (String name : sysGroupNames) {
        if (name.toLowerCase(Locale.US).equals(createGroupArgs.getGroupName().toLowerCase(Locale.US))) {
            throw new ResourceConflictException("group '" + name + "' already exists");
        }
    }
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    AccountGroup group = new AccountGroup(createGroupArgs.getGroup(), groupId, uuid);
    group.setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        AccountGroup ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        if (ownerGroup != null) {
            group.setOwnerGroupUUID(ownerGroup.getGroupUUID());
        }
    }
    if (createGroupArgs.groupDescription != null) {
        group.setDescription(createGroupArgs.groupDescription);
    }
    AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers.addMembers(groupId, createGroupArgs.initialMembers);
    groupCache.onCreateGroup(createGroupArgs.getGroup());
    return group;
}
#method_after
private AccountGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException, IOException {
    // Do not allow creating groups with the same name as system groups
    for (String name : systemGroupBackend.getNames()) {
        if (name.toLowerCase(Locale.US).equals(createGroupArgs.getGroupName().toLowerCase(Locale.US))) {
            throw new ResourceConflictException("group '" + name + "' already exists");
        }
    }
    for (String name : systemGroupBackend.getReservedNames()) {
        if (name.toLowerCase(Locale.US).equals(createGroupArgs.getGroupName().toLowerCase(Locale.US))) {
            throw new ResourceConflictException("group name '" + name + "' is reserved");
        }
    }
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    AccountGroup group = new AccountGroup(createGroupArgs.getGroup(), groupId, uuid);
    group.setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        AccountGroup ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        if (ownerGroup != null) {
            group.setOwnerGroupUUID(ownerGroup.getGroupUUID());
        }
    }
    if (createGroupArgs.groupDescription != null) {
        group.setDescription(createGroupArgs.groupDescription);
    }
    AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers.addMembers(groupId, createGroupArgs.initialMembers);
    groupCache.onCreateGroup(createGroupArgs.getGroup());
    return group;
}
#end_block

#method_before
public PersonIdent newRefLogIdent(final Date when, final TimeZone tz) {
    final Account ua = getAccount();
    String name = ua.getFullName();
    if (name == null || name.isEmpty()) {
        name = ua.getPreferredEmail();
    }
    if (name == null || name.isEmpty()) {
        name = anonymousCowardName;
    }
    String user = getUserName();
    if (user == null) {
        user = "";
    }
    user = user + "|" + "account-" + ua.getId().toString();
    String host = null;
    SocketAddress remotePeer = remotePeerProvider.get();
    if (remotePeer instanceof InetSocketAddress) {
        InetSocketAddress sa = (InetSocketAddress) remotePeer;
        InetAddress in = sa.getAddress();
        host = in != null ? getHost(in) : sa.getHostName();
    }
    if (host == null || host.isEmpty()) {
        host = "unknown";
    }
    return new PersonIdent(name, user + "@" + host, when, tz);
}
#method_after
public PersonIdent newRefLogIdent(final Date when, final TimeZone tz) {
    final Account ua = getAccount();
    String name = ua.getFullName();
    if (name == null || name.isEmpty()) {
        name = ua.getPreferredEmail();
    }
    if (name == null || name.isEmpty()) {
        name = anonymousCowardName;
    }
    String user = getUserName();
    if (user == null) {
        user = "";
    }
    user = user + "|" + "account-" + ua.getId().toString();
    return new PersonIdent(name, user + "@" + guessHost(), when, tz);
}
#end_block

#method_before
@Override
protected String getRefName() {
    return RefNames.robotCommentsRef(getChangeId());
}
#method_after
@Override
public String getRefName() {
    return RefNames.robotCommentsRef(getChangeId());
}
#end_block

#method_before
@Override
protected void onLoad(LoadHandle handle) throws IOException, ConfigInvalidException {
    ObjectId rev = handle.id();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevCommit tipCommit = handle.walk().parseCommit(rev);
    ObjectReader reader = handle.walk().getObjectReader();
    revisionNoteMap = RevisionNoteMap.parseRobotComments(args.noteUtil, reader, NoteMap.read(reader, tipCommit));
    Multimap<RevId, RobotComment> cs = ArrayListMultimap.create();
    for (RobotCommentsRevisionNote rn : revisionNoteMap.revisionNotes.values()) {
        for (RobotComment c : rn.getComments()) {
            cs.put(new RevId(c.revId), c);
        }
    }
    comments = ImmutableListMultimap.copyOf(cs);
}
#method_after
@Override
protected void onLoad(LoadHandle handle) throws IOException, ConfigInvalidException {
    metaId = handle.id();
    if (metaId == null) {
        loadDefaults();
        return;
    }
    metaId = metaId.copy();
    RevCommit tipCommit = handle.walk().parseCommit(metaId);
    ObjectReader reader = handle.walk().getObjectReader();
    revisionNoteMap = RevisionNoteMap.parseRobotComments(args.noteUtil, reader, NoteMap.read(reader, tipCommit));
    ListMultimap<RevId, RobotComment> cs = MultimapBuilder.hashKeys().arrayListValues().build();
    for (RobotCommentsRevisionNote rn : revisionNoteMap.revisionNotes.values()) {
        for (RobotComment c : rn.getComments()) {
            cs.put(new RevId(c.revId), c);
        }
    }
    comments = ImmutableListMultimap.copyOf(cs);
}
#end_block

#method_before
private static Comment update(Comment e, DraftInput in, Timestamp when) {
    if (in.side != null) {
        e.side = in.side();
    }
    if (in.inReplyTo != null) {
        e.parentUuid = Url.decode(in.inReplyTo);
    }
    e.setLineNbrAndRange(in.line, in.range);
    e.message = in.message.trim();
    e.writtenOn = when;
    if (in.tag != null) {
        // TODO(dborowitz): Can we support changing tags via PUT?
        e.tag = in.tag;
    }
    return e;
}
#method_after
private static Comment update(Comment e, DraftInput in, Timestamp when) {
    if (in.side != null) {
        e.side = in.side();
    }
    if (in.inReplyTo != null) {
        e.parentUuid = Url.decode(in.inReplyTo);
    }
    e.setLineNbrAndRange(in.line, in.range);
    e.message = in.message.trim();
    e.writtenOn = when;
    if (in.tag != null) {
        // TODO(dborowitz): Can we support changing tags via PUT?
        e.tag = in.tag;
    }
    if (in.unresolved != null) {
        e.unresolved = in.unresolved;
    }
    return e;
}
#end_block

#method_before
public void add(Injector... injectors) {
    for (Injector i : injectors) {
        add(i);
    }
}
#method_after
public void add(Injector injector) {
    Preconditions.checkState(startedIndex < 0, "Already started");
    for (Binding<LifecycleListener> binding : get(injector)) {
        add(binding.getProvider());
    }
}
#end_block

#method_before
public static GeneralPreferencesInfo defaults() {
    GeneralPreferencesInfo p = new GeneralPreferencesInfo();
    p.changesPerPage = DEFAULT_PAGESIZE;
    p.showSiteHeader = true;
    p.useFlashClipboard = true;
    p.emailStrategy = EmailStrategy.ENABLED;
    p.reviewCategoryStrategy = ReviewCategoryStrategy.NONE;
    p.downloadScheme = null;
    p.downloadCommand = DownloadCommand.CHECKOUT;
    p.dateFormat = DateFormat.STD;
    p.timeFormat = TimeFormat.HHMM_12;
    p.highlightAssigneeInChangeTable = true;
    p.relativeDateInChangeTable = false;
    p.diffView = DiffView.SIDE_BY_SIDE;
    p.sizeBarInChangeTable = true;
    p.legacycidInChangeTable = false;
    p.muteCommonPathPrefixes = true;
    p.signedOffBy = false;
    p.defaultBaseForMerges = DefaultBase.FIRST_PARENT;
    return p;
}
#method_after
public static GeneralPreferencesInfo defaults() {
    GeneralPreferencesInfo p = new GeneralPreferencesInfo();
    p.changesPerPage = DEFAULT_PAGESIZE;
    p.showSiteHeader = true;
    p.useFlashClipboard = true;
    p.emailStrategy = EmailStrategy.ENABLED;
    p.reviewCategoryStrategy = ReviewCategoryStrategy.NONE;
    p.downloadScheme = null;
    p.downloadCommand = DownloadCommand.CHECKOUT;
    p.dateFormat = DateFormat.STD;
    p.timeFormat = TimeFormat.HHMM_12;
    p.expandInlineDiffs = false;
    p.highlightAssigneeInChangeTable = true;
    p.relativeDateInChangeTable = false;
    p.diffView = DiffView.SIDE_BY_SIDE;
    p.sizeBarInChangeTable = true;
    p.legacycidInChangeTable = false;
    p.muteCommonPathPrefixes = true;
    p.signedOffBy = false;
    p.defaultBaseForMerges = DefaultBase.FIRST_PARENT;
    return p;
}
#end_block

#method_before
public SiteIndexer.Result indexAll(ChangeIndex index, Iterable<ProjectHolder> projects) {
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", (projects instanceof Collection) ? ((Collection<?>) projects).size() : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, totalWork >= 0 ? totalWork : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = new ArrayList<>();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final ProjectHolder project : projects) {
        ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(executor, index), project.name, doneTask, failedTask, verboseWriter));
        addErrorListener(future, "project " + project.name, projTask, ok);
        futures.add(future);
    }
    try {
        mpm.waitFor(Futures.transformAsync(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
    } catch (ExecutionException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    // If too many changes failed, maybe there was a bug in the indexer. Don't
    // trust the results. This is not an exact percentage since we bump the same
    // failure counter if a project can't be read, but close enough.
    int nFailed = failedTask.getCount();
    int nTotal = nFailed + doneTask.getCount();
    double pctFailed = ((double) nFailed) / nTotal * 100;
    if (pctFailed > 10) {
        log.error("Failed {}/{} changes ({}%); not marking new index as ready", nFailed, nTotal, Math.round(pctFailed));
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#method_after
public SiteIndexer.Result indexAll(ChangeIndex index, Iterable<ProjectHolder> projects) {
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", (projects instanceof Collection) ? ((Collection<?>) projects).size() : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, totalWork >= 0 ? totalWork : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = new ArrayList<>();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final ProjectHolder project : projects) {
        ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(executor, index), project.name, doneTask, failedTask, verboseWriter));
        addErrorListener(future, "project " + project.name, projTask, ok);
        futures.add(future);
    }
    try {
        mpm.waitFor(transform(successfulAsList(futures), x -> {
            mpm.end();
            return null;
        }, directExecutor()));
    } catch (ExecutionException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    // If too many changes failed, maybe there was a bug in the indexer. Don't
    // trust the results. This is not an exact percentage since we bump the same
    // failure counter if a project can't be read, but close enough.
    int nFailed = failedTask.getCount();
    int nDone = doneTask.getCount();
    int nTotal = nFailed + nDone;
    double pctFailed = ((double) nFailed) / nTotal * 100;
    if (pctFailed > 10) {
        log.error("Failed {}/{} changes ({}%); not marking new index as ready", nFailed, nTotal, Math.round(pctFailed));
        ok.set(false);
    }
    return new Result(sw, ok.get(), nDone, nFailed);
}
#end_block

#method_before
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            // with RepositoryCache.close(repo).
            try (Repository repo = repoManager.openRepository(project);
                ReviewDb db = schemaFactory.open()) {
                Map<String, Ref> refs = repo.getRefDatabase().getRefs(ALL);
                // change IDs.
                for (ChangeNotes cn : notesFactory.scan(repo, db, project)) {
                    Ref r = refs.get(cn.getChange().currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), changeDataFactory.create(db, cn));
                    }
                }
                new ProjectIndexer(indexer, mergeStrategy, autoMerger, byId, repo, done, failed, verboseWriter).call();
            } catch (RepositoryNotFoundException rnfe) {
                log.error(rnfe.getMessage());
            }
            return null;
        }

        @Override
        public String toString() {
            return "Index all changes of project " + project.get();
        }
    };
}
#method_after
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            ListMultimap<ObjectId, ChangeData> byId = MultimapBuilder.hashKeys().arrayListValues().build();
            // with RepositoryCache.close(repo).
            try (Repository repo = repoManager.openRepository(project);
                ReviewDb db = schemaFactory.open()) {
                Map<String, Ref> refs = repo.getRefDatabase().getRefs(ALL);
                // change IDs.
                for (ChangeNotes cn : notesFactory.scan(repo, db, project)) {
                    Ref r = refs.get(cn.getChange().currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), changeDataFactory.create(db, cn));
                    }
                }
                new ProjectIndexer(indexer, mergeStrategy, autoMerger, byId, repo, done, failed, verboseWriter).call();
            } catch (RepositoryNotFoundException rnfe) {
                log.error(rnfe.getMessage());
            }
            return null;
        }

        @Override
        public String toString() {
            return "Index all changes of project " + project.get();
        }
    };
}
#end_block

#method_before
private void getPathsAndIndex(RevWalk walk, ObjectInserter ins, ObjectId b) throws Exception {
    List<ChangeData> cds = Lists.newArrayList(byId.get(b));
    try (DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        RevCommit bCommit = walk.parseCommit(b);
        RevTree bTree = bCommit.getTree();
        RevTree aTree = aFor(bCommit, walk, ins);
        df.setRepository(repo);
        if (!cds.isEmpty()) {
            List<String> paths = (aTree != null) ? getPaths(df.scan(aTree, bTree)) : Collections.<String>emptyList();
            Iterator<ChangeData> cdit = cds.iterator();
            for (ChangeData cd; cdit.hasNext(); cdit.remove()) {
                cd = cdit.next();
                try {
                    cd.setCurrentFilePaths(paths);
                    indexer.index(cd);
                    done.update(1);
                    if (verboseWriter != null) {
                        verboseWriter.println("Reindexed change " + cd.getId());
                    }
                } catch (Exception e) {
                    fail("Failed to index change " + cd.getId(), true, e);
                }
            }
        }
    } catch (Exception e) {
        fail("Failed to index commit " + b.name(), false, e);
        for (ChangeData cd : cds) {
            fail("Failed to index change " + cd.getId(), true, null);
        }
    }
}
#method_after
private void getPathsAndIndex(RevWalk walk, ObjectInserter ins, ObjectId b) throws Exception {
    List<ChangeData> cds = Lists.newArrayList(byId.get(b));
    try (DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        RevCommit bCommit = walk.parseCommit(b);
        RevTree bTree = bCommit.getTree();
        RevTree aTree = aFor(bCommit, walk, ins);
        df.setRepository(repo);
        if (!cds.isEmpty()) {
            List<String> paths = (aTree != null) ? getPaths(df.scan(aTree, bTree)) : Collections.<String>emptyList();
            Iterator<ChangeData> cdit = cds.iterator();
            for (ChangeData cd; cdit.hasNext(); cdit.remove()) {
                cd = cdit.next();
                try {
                    cd.setCurrentFilePaths(paths);
                    indexer.index(cd);
                    done.update(1);
                    verboseWriter.println("Reindexed change " + cd.getId());
                } catch (Exception e) {
                    fail("Failed to index change " + cd.getId(), true, e);
                }
            }
        }
    } catch (Exception e) {
        fail("Failed to index commit " + b.name(), false, e);
        for (ChangeData cd : cds) {
            fail("Failed to index change " + cd.getId(), true, null);
        }
    }
}
#end_block

#method_before
private void fail(String error, boolean failed, Exception e) {
    if (failed) {
        this.failed.update(1);
    }
    if (e != null) {
        log.warn(error, e);
    } else {
        log.warn(error);
    }
    if (verboseWriter != null) {
        verboseWriter.println(error);
    }
}
#method_after
private void fail(String error, boolean failed, Exception e) {
    if (failed) {
        this.failed.update(1);
    }
    if (e != null) {
        log.warn(error, e);
    } else {
        log.warn(error);
    }
    verboseWriter.println(error);
}
#end_block

#method_before
@Override
public synchronized void handleEmails() {
    POP3Client pop3;
    if (mailSettings.encryption != Encryption.NONE) {
        pop3 = new POP3SClient(mailSettings.encryption.name());
    } else {
        pop3 = new POP3Client();
    }
    if (mailSettings.port > 0) {
        pop3.setDefaultPort(mailSettings.port);
    }
    try {
        pop3.connect(mailSettings.host);
    } catch (IOException e) {
        log.error("Could not connect to POP3 email server", e);
        return;
    }
    try {
        try {
            if (!pop3.login(mailSettings.username, mailSettings.password)) {
                log.error("Could not login to POP3 email server." + " Check username and password");
                return;
            }
            try {
                POP3MessageInfo[] messages = pop3.listMessages();
                if (messages == null) {
                    log.error("Could not retrieve message list via POP3");
                    return;
                }
                log.info("Received " + messages.length + " messages via POP3");
                // Fetch messages
                List<MailMessage> mailMessages = new ArrayList<>();
                for (POP3MessageInfo msginfo : messages) {
                    if (msginfo == null) {
                        // Message was deleted
                        continue;
                    }
                    try (BufferedReader reader = (BufferedReader) pop3.retrieveMessage(msginfo.number)) {
                        if (reader == null) {
                            log.error("Could not retrieve POP3 message header for message {}", msginfo.identifier);
                            return;
                        }
                        int[] message = fetchMessage(reader);
                        MailMessage mailMessage = RawMailParser.parse(message);
                        // 822 and delete the message if deletion is pending.
                        if (pendingDeletion.contains(mailMessage.id())) {
                            if (pop3.deleteMessage(msginfo.number)) {
                                pendingDeletion.remove(mailMessage.id());
                            } else {
                                log.error("Could not delete message " + msginfo.number);
                            }
                        } else {
                            // Process message further
                            mailMessages.add(mailMessage);
                        }
                    } catch (MailParsingException e) {
                        log.error("Could not parse message " + msginfo.number);
                    }
                }
            // TODO(hiesel) Call processing logic with mailMessages
            } finally {
                pop3.logout();
            }
        } finally {
            pop3.disconnect();
        }
    } catch (IOException e) {
        log.error("Error while issuing POP3 command", e);
    }
}
#method_after
@Override
public synchronized void handleEmails(boolean async) {
    POP3Client pop3;
    if (mailSettings.encryption != Encryption.NONE) {
        pop3 = new POP3SClient(mailSettings.encryption.name());
    } else {
        pop3 = new POP3Client();
    }
    if (mailSettings.port > 0) {
        pop3.setDefaultPort(mailSettings.port);
    }
    try {
        pop3.connect(mailSettings.host);
    } catch (IOException e) {
        log.error("Could not connect to POP3 email server", e);
        return;
    }
    try {
        try {
            if (!pop3.login(mailSettings.username, mailSettings.password)) {
                log.error("Could not login to POP3 email server." + " Check username and password");
                return;
            }
            try {
                POP3MessageInfo[] messages = pop3.listMessages();
                if (messages == null) {
                    log.error("Could not retrieve message list via POP3");
                    return;
                }
                log.info("Received " + messages.length + " messages via POP3");
                // Fetch messages
                List<MailMessage> mailMessages = new ArrayList<>();
                for (POP3MessageInfo msginfo : messages) {
                    if (msginfo == null) {
                        // Message was deleted
                        continue;
                    }
                    try (BufferedReader reader = (BufferedReader) pop3.retrieveMessage(msginfo.number)) {
                        if (reader == null) {
                            log.error("Could not retrieve POP3 message header for message {}", msginfo.identifier);
                            return;
                        }
                        int[] message = fetchMessage(reader);
                        MailMessage mailMessage = RawMailParser.parse(message);
                        // 822 and delete the message if deletion is pending.
                        if (pendingDeletion.contains(mailMessage.id())) {
                            if (pop3.deleteMessage(msginfo.number)) {
                                pendingDeletion.remove(mailMessage.id());
                            } else {
                                log.error("Could not delete message " + msginfo.number);
                            }
                        } else {
                            // Process message further
                            mailMessages.add(mailMessage);
                        }
                    } catch (MailParsingException e) {
                        log.error("Could not parse message " + msginfo.number);
                    }
                }
                dispatchMailProcessor(mailMessages, async);
            } finally {
                pop3.logout();
            }
        } finally {
            pop3.disconnect();
        }
    } catch (IOException e) {
        log.error("Error while issuing POP3 command", e);
    }
}
#end_block

#method_before
@Override
public Response<Map<String, ActionInfo>> apply(RevisionResource rsrc) {
    return Response.withMustRevalidate(delegate.format(rsrc));
}
#method_after
@Override
public Response<Map<String, ActionInfo>> apply(RevisionResource rsrc) throws OrmException {
    return Response.withMustRevalidate(delegate.format(rsrc));
}
#end_block

#method_before
@Test
public void getAndSetPreferences() throws Exception {
    GeneralPreferencesInfo o = gApi.accounts().id(user42.id.toString()).getPreferences();
    assertPrefs(o, GeneralPreferencesInfo.defaults(), "my");
    assertThat(o.my).hasSize(7);
    GeneralPreferencesInfo i = GeneralPreferencesInfo.defaults();
    // change all default values
    i.changesPerPage *= -1;
    i.showSiteHeader ^= true;
    i.useFlashClipboard ^= true;
    i.downloadCommand = DownloadCommand.REPO_DOWNLOAD;
    i.dateFormat = DateFormat.US;
    i.timeFormat = TimeFormat.HHMM_24;
    i.emailStrategy = EmailStrategy.DISABLED;
    i.defaultBaseForMerges = DefaultBase.AUTO_MERGE;
    i.highlightAssigneeInChangeTable ^= true;
    i.relativeDateInChangeTable ^= true;
    i.sizeBarInChangeTable ^= true;
    i.legacycidInChangeTable ^= true;
    i.muteCommonPathPrefixes ^= true;
    i.signedOffBy ^= true;
    i.reviewCategoryStrategy = ReviewCategoryStrategy.ABBREV;
    i.diffView = DiffView.UNIFIED_DIFF;
    i.my = new ArrayList<>();
    i.my.add(new MenuItem("name", "url"));
    i.urlAliases = new HashMap<>();
    i.urlAliases.put("foo", "bar");
    o = gApi.accounts().id(user42.getId().toString()).setPreferences(i);
    assertPrefs(o, i, "my");
    assertThat(o.my).hasSize(1);
}
#method_after
@Test
public void getAndSetPreferences() throws Exception {
    GeneralPreferencesInfo o = gApi.accounts().id(user42.id.toString()).getPreferences();
    assertPrefs(o, GeneralPreferencesInfo.defaults(), "my", "changeTable");
    assertThat(o.my).hasSize(7);
    assertThat(o.changeTable).isEmpty();
    GeneralPreferencesInfo i = GeneralPreferencesInfo.defaults();
    // change all default values
    i.changesPerPage *= -1;
    i.showSiteHeader ^= true;
    i.useFlashClipboard ^= true;
    i.downloadCommand = DownloadCommand.REPO_DOWNLOAD;
    i.dateFormat = DateFormat.US;
    i.timeFormat = TimeFormat.HHMM_24;
    i.emailStrategy = EmailStrategy.DISABLED;
    i.defaultBaseForMerges = DefaultBase.AUTO_MERGE;
    i.expandInlineDiffs ^= true;
    i.highlightAssigneeInChangeTable ^= true;
    i.relativeDateInChangeTable ^= true;
    i.sizeBarInChangeTable ^= true;
    i.legacycidInChangeTable ^= true;
    i.muteCommonPathPrefixes ^= true;
    i.signedOffBy ^= true;
    i.reviewCategoryStrategy = ReviewCategoryStrategy.ABBREV;
    i.diffView = DiffView.UNIFIED_DIFF;
    i.my = new ArrayList<>();
    i.my.add(new MenuItem("name", "url"));
    i.changeTable = new ArrayList<>();
    i.changeTable.add("Status");
    i.urlAliases = new HashMap<>();
    i.urlAliases.put("foo", "bar");
    o = gApi.accounts().id(user42.getId().toString()).setPreferences(i);
    assertPrefs(o, i, "my");
    assertThat(o.my).hasSize(1);
    assertThat(o.changeTable).hasSize(1);
}
#end_block

#method_before
@Test
public void getPreferencesWithConfiguredDefaults() throws Exception {
    GeneralPreferencesInfo d = GeneralPreferencesInfo.defaults();
    int newChangesPerPage = d.changesPerPage * 2;
    GeneralPreferencesInfo update = new GeneralPreferencesInfo();
    update.changesPerPage = newChangesPerPage;
    gApi.config().server().setDefaultPreferences(update);
    GeneralPreferencesInfo o = gApi.accounts().id(user42.getId().toString()).getPreferences();
    // assert configured defaults
    assertThat(o.changesPerPage).isEqualTo(newChangesPerPage);
    // assert hard-coded defaults
    assertPrefs(o, d, "my", "changesPerPage");
}
#method_after
@Test
public void getPreferencesWithConfiguredDefaults() throws Exception {
    GeneralPreferencesInfo d = GeneralPreferencesInfo.defaults();
    int newChangesPerPage = d.changesPerPage * 2;
    GeneralPreferencesInfo update = new GeneralPreferencesInfo();
    update.changesPerPage = newChangesPerPage;
    gApi.config().server().setDefaultPreferences(update);
    GeneralPreferencesInfo o = gApi.accounts().id(user42.getId().toString()).getPreferences();
    // assert configured defaults
    assertThat(o.changesPerPage).isEqualTo(newChangesPerPage);
    // assert hard-coded defaults
    assertPrefs(o, d, "my", "changeTable", "changesPerPage");
}
#end_block

#method_before
private boolean includedInOne(final Collection<Ref> refs) throws IOException {
    parseCommits(refs);
    List<RevCommit> before = new LinkedList<>();
    List<RevCommit> after = new LinkedList<>();
    partition(before, after);
    rw.reset();
    // Within the "before" set we are trying to handle cases arising from clock skew
    return !includedIn(after, 1).isEmpty() || !includedIn(before, 1).isEmpty();
}
#method_after
private boolean includedInOne(final Collection<Ref> refs) throws IOException {
    parseCommits(refs);
    List<RevCommit> before = new ArrayList<>();
    List<RevCommit> after = new ArrayList<>();
    partition(before, after);
    rw.reset();
    // Within the "before" set we are trying to handle cases arising from clock skew
    return !includedIn(after, 1).isEmpty() || !includedIn(before, 1).isEmpty();
}
#end_block

#method_before
public ImmutableSortedSet<String> getLabels(Account.Id accountId, Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        return ImmutableSortedSet.copyOf(readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)));
    } catch (IOException e) {
        throw new OrmException(String.format("Reading stars from change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public ImmutableSortedSet<String> getLabels(Account.Id accountId, Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        return readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)).labels();
    } catch (IOException e) {
        throw new OrmException(String.format("Reading stars from change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public ImmutableSortedSet<String> star(Account.Id accountId, Project.NameKey project, Change.Id changeId, Set<String> labelsToAdd, Set<String> labelsToRemove) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        if (labelsToAdd != null) {
            labels.addAll(labelsToAdd);
        }
        if (labelsToRemove != null) {
            labels.removeAll(labelsToRemove);
        }
        if (labels.isEmpty()) {
            deleteRef(repo, refName, oldObjectId);
        } else {
            checkMutuallyExclusiveLabels(labels);
            updateLabels(repo, refName, oldObjectId, labels);
        }
        indexer.index(dbProvider.get(), project, changeId);
        return ImmutableSortedSet.copyOf(labels);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public ImmutableSortedSet<String> star(Account.Id accountId, Project.NameKey project, Change.Id changeId, Set<String> labelsToAdd, Set<String> labelsToRemove) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        StarRef old = readLabels(repo, refName);
        Set<String> labels = new HashSet<>(old.labels());
        if (labelsToAdd != null) {
            labels.addAll(labelsToAdd);
        }
        if (labelsToRemove != null) {
            labels.removeAll(labelsToRemove);
        }
        if (labels.isEmpty()) {
            deleteRef(repo, refName, old.objectId());
        } else {
            checkMutuallyExclusiveLabels(labels);
            updateLabels(repo, refName, old.objectId(), labels);
        }
        indexer.index(dbProvider.get(), project, changeId);
        return ImmutableSortedSet.copyOf(labels);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public void unstarAll(Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate batchUpdate = repo.getRefDatabase().newBatchUpdate();
        batchUpdate.setAllowNonFastForwards(true);
        batchUpdate.setRefLogIdent(serverIdent);
        batchUpdate.setRefLogMessage("Unstar change " + changeId.get(), true);
        for (Account.Id accountId : byChangeFromIndex(changeId).keySet()) {
            String refName = RefNames.refsStarredChanges(changeId, accountId);
            Ref ref = repo.getRefDatabase().getRef(refName);
            batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName));
        }
        batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult()));
            }
        }
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d failed", changeId.get()), e);
    }
}
#method_after
public void unstarAll(Project.NameKey project, Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate batchUpdate = repo.getRefDatabase().newBatchUpdate();
        batchUpdate.setAllowNonFastForwards(true);
        batchUpdate.setRefLogIdent(serverIdent);
        batchUpdate.setRefLogMessage("Unstar change " + changeId.get(), true);
        for (Account.Id accountId : byChangeFromIndex(changeId).keySet()) {
            String refName = RefNames.refsStarredChanges(changeId, accountId);
            Ref ref = repo.getRefDatabase().getRef(refName);
            batchUpdate.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), refName));
        }
        batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult()));
            }
        }
        indexer.index(dbProvider.get(), project, changeId);
    } catch (IOException e) {
        throw new OrmException(String.format("Unstar change %d failed", changeId.get()), e);
    }
}
#end_block

#method_before
public ImmutableMultimap<Account.Id, String> byChange(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        ImmutableMultimap.Builder<Account.Id, String> builder = new ImmutableMultimap.Builder<>();
        for (String refPart : getRefNames(repo, RefNames.refsStarredChangesPrefix(changeId))) {
            Integer id = Ints.tryParse(refPart);
            if (id == null) {
                continue;
            }
            Account.Id accountId = new Account.Id(id);
            builder.putAll(accountId, readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)));
        }
        return builder.build();
    } catch (IOException e) {
        throw new OrmException(String.format("Get accounts that starred change %d failed", changeId.get()), e);
    }
}
#method_after
public ImmutableMap<Account.Id, StarRef> byChange(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        ImmutableMap.Builder<Account.Id, StarRef> builder = ImmutableMap.builder();
        for (String refPart : getRefNames(repo, RefNames.refsStarredChangesPrefix(changeId))) {
            Integer id = Ints.tryParse(refPart);
            if (id == null) {
                continue;
            }
            Account.Id accountId = new Account.Id(id);
            builder.put(accountId, readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)));
        }
        return builder.build();
    } catch (IOException e) {
        throw new OrmException(String.format("Get accounts that starred change %d failed", changeId.get()), e);
    }
}
#end_block

#method_before
public Set<Account.Id> byChange(final Change.Id changeId, final String label) throws OrmException {
    try (final Repository repo = repoManager.openRepository(allUsers)) {
        return getRefNames(repo, RefNames.refsStarredChangesPrefix(changeId)).stream().map(Account.Id::parse).filter(accountId -> hasStar(repo, changeId, accountId, label)).collect(toSet());
    } catch (IOException e) {
        throw new OrmException(String.format("Get accounts that starred change %d failed", changeId.get()), e);
    }
}
#method_after
public Set<Account.Id> byChange(final Change.Id changeId, final String label) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        return getRefNames(repo, RefNames.refsStarredChangesPrefix(changeId)).stream().map(Account.Id::parse).filter(accountId -> hasStar(repo, changeId, accountId, label)).collect(toSet());
    } catch (IOException e) {
        throw new OrmException(String.format("Get accounts that starred change %d failed", changeId.get()), e);
    }
}
#end_block

#method_before
private boolean hasStar(Repository repo, Change.Id changeId, Account.Id accountId, String label) {
    try {
        return readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)).contains(label);
    } catch (IOException e) {
        log.error(String.format("Cannot query stars by account %d on change %d", accountId.get(), changeId.get()), e);
        return false;
    }
}
#method_after
private boolean hasStar(Repository repo, Change.Id changeId, Account.Id accountId, String label) {
    try {
        return readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)).labels().contains(label);
    } catch (IOException e) {
        log.error(String.format("Cannot query stars by account %d on change %d", accountId.get(), changeId.get()), e);
        return false;
    }
}
#end_block

#method_before
public ImmutableMultimap<Account.Id, String> byChangeFromIndex(Change.Id changeId) throws OrmException, NoSuchChangeException {
    Set<String> fields = ImmutableSet.of(ChangeField.ID.getName(), ChangeField.STAR.getName());
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(fields).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).stars();
}
#method_after
public ImmutableListMultimap<Account.Id, String> byChangeFromIndex(Change.Id changeId) throws OrmException {
    Set<String> fields = ImmutableSet.of(ChangeField.ID.getName(), ChangeField.STAR.getName());
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(fields).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).stars();
}
#end_block

#method_before
public ObjectId getObjectId(Account.Id accountId, Change.Id changeId) {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        return getObjectId(repo, RefNames.refsStarredChanges(changeId, accountId));
    } catch (IOException e) {
        log.error(String.format("Getting star object ID for account %d on change %d failed", accountId.get(), changeId.get()), e);
        return ObjectId.zeroId();
    }
}
#method_after
public ObjectId getObjectId(Account.Id accountId, Change.Id changeId) {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        Ref ref = repo.exactRef(RefNames.refsStarredChanges(changeId, accountId));
        return ref != null ? ref.getObjectId() : ObjectId.zeroId();
    } catch (IOException e) {
        log.error(String.format("Getting star object ID for account %d on change %d failed", accountId.get(), changeId.get()), e);
        return ObjectId.zeroId();
    }
}
#end_block

#method_before
private static SortedSet<String> readLabels(Repository repo, String refName) throws IOException {
    return readLabels(repo, getObjectId(repo, refName));
}
#method_after
private static StarRef readLabels(Repository repo, String refName) throws IOException {
    Ref ref = repo.exactRef(refName);
    if (ref == null) {
        return StarRef.MISSING;
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(ref.getObjectId(), Constants.OBJ_BLOB);
        return StarRef.create(ref, Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().split(new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8)));
    }
}
#end_block

#method_before
public static ObjectId writeLabels(Repository repo, SortedSet<String> labels) throws IOException {
    validateLabels(labels);
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, Joiner.on("\n").join(labels).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#method_after
public static ObjectId writeLabels(Repository repo, Collection<String> labels) throws IOException {
    validateLabels(labels);
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, labels.stream().sorted().distinct().collect(joining("\n")).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#end_block

#method_before
private static void validateLabels(Set<String> labels) {
    if (labels == null) {
        return;
    }
    SortedSet<String> invalidLabels = new TreeSet<>();
    for (String label : labels) {
        if (CharMatcher.whitespace().matchesAnyOf(label)) {
            invalidLabels.add(label);
        }
    }
    if (!invalidLabels.isEmpty()) {
        throw IllegalLabelException.invalidLabels(invalidLabels);
    }
}
#method_after
private static void validateLabels(Collection<String> labels) {
    if (labels == null) {
        return;
    }
    SortedSet<String> invalidLabels = new TreeSet<>();
    for (String label : labels) {
        if (CharMatcher.whitespace().matchesAnyOf(label)) {
            invalidLabels.add(label);
        }
    }
    if (!invalidLabels.isEmpty()) {
        throw IllegalLabelException.invalidLabels(invalidLabels);
    }
}
#end_block

#method_before
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, SortedSet<String> labels) throws IOException, OrmException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#method_after
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, Collection<String> labels) throws IOException, OrmException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#end_block

#method_before
@Test
public void uploadPackSubsetOfBranchesVisibleWithEdit() throws Exception {
    allow(Permission.READ, REGISTERED_USERS, "refs/heads/master");
    deny(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
    Change c = notesFactory.createChecked(db, project, c1.getId()).getChange();
    PatchSet ps1 = getPatchSet(new PatchSet.Id(c1.getId(), 1));
    // Admin's edit is not visible.
    setApiUser(admin);
    editModifier.createEdit(c, ps1);
    // User's edit is visible.
    setApiUser(user);
    editModifier.createEdit(c, ps1);
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r3 + "1", r3 + "meta", "refs/heads/master", "refs/tags/master-tag", "refs/users/01/1000001/edit-" + c1.getId() + "/1");
}
#method_after
@Test
public void uploadPackSubsetOfBranchesVisibleWithEdit() throws Exception {
    allow(Permission.READ, REGISTERED_USERS, "refs/heads/master");
    deny(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
    Change c = notesFactory.createChecked(db, project, c1.getId()).getChange();
    String changeId = c.getKey().get();
    // Admin's edit is not visible.
    setApiUser(admin);
    gApi.changes().id(changeId).edit().create();
    // User's edit is visible.
    setApiUser(user);
    gApi.changes().id(changeId).edit().create();
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r3 + "1", r3 + "meta", "refs/heads/master", "refs/tags/master-tag", "refs/users/01/1000001/edit-" + c1.getId() + "/1");
}
#end_block

#method_before
@Test
public void uploadPackSubsetOfRefsVisibleWithAccessDatabase() throws Exception {
    allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    try {
        deny(Permission.READ, REGISTERED_USERS, "refs/heads/master");
        allow(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
        PatchSet ps1 = getPatchSet(new PatchSet.Id(c1.getId(), 1));
        setApiUser(admin);
        editModifier.createEdit(c1.change(), ps1);
        setApiUser(user);
        assertUploadPackRefs(// refs/heads/master is not.
        r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/tags/branch-tag", // See comment in subsetOfBranchesVisibleNotIncludingHead.
        "refs/tags/master-tag", // All edits are visible due to accessDatabase capability.
        "refs/users/00/1000000/edit-" + c1.getId() + "/1");
    } finally {
        removeGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    }
}
#method_after
@Test
public void uploadPackSubsetOfRefsVisibleWithAccessDatabase() throws Exception {
    allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    try {
        deny(Permission.READ, REGISTERED_USERS, "refs/heads/master");
        allow(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
        String changeId = c1.change().getKey().get();
        setApiUser(admin);
        gApi.changes().id(changeId).edit().create();
        setApiUser(user);
        assertUploadPackRefs(// refs/heads/master is not.
        r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/tags/branch-tag", // See comment in subsetOfBranchesVisibleNotIncludingHead.
        "refs/tags/master-tag", // All edits are visible due to accessDatabase capability.
        "refs/users/00/1000000/edit-" + c1.getId() + "/1");
    } finally {
        removeGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    }
}
#end_block

#method_before
@Test
public void receivePackOmitsMissingObject() throws Exception {
    // Use the tactic from ConsistencyCheckerIT to insert a new patch set with a
    // missing object.
    String rev = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    try (Repository repo = repoManager.openRepository(project)) {
        TestRepository<?> tr = new TestRepository<>(repo);
        String subject = "Subject for missing commit";
        Change c = new Change(c3.change());
        PatchSet.Id psId = new PatchSet.Id(c3.getId(), 2);
        c.setCurrentPatchSet(psId, subject, c.getOriginalSubject());
        PatchSet ps = TestChanges.newPatchSet(psId, rev, admin.getId());
        db.patchSets().insert(Collections.singleton(ps));
        db.changes().update(Collections.singleton(c));
        if (notesMigration.commitChangeWrites()) {
            PersonIdent committer = serverIdent.get();
            PersonIdent author = noteUtil.newIdent(accountCache.get(admin.getId()).getAccount(), committer.getWhen(), committer, anonymousCowardName);
            tr.branch(RefNames.changeMetaRef(c3.getId())).commit().author(author).committer(committer).message("Update patch set " + psId.get() + "\n" + "\n" + "Patch-set: " + psId.get() + "\n" + "Commit: " + rev + "\n" + "Subject: " + subject + "\n").create();
        }
        indexer.index(db, c.getProject(), c.getId());
    }
    assertThat(getReceivePackRefs().additionalHaves()).containsExactly(obj(c4, 1));
}
#method_after
@Test
public void receivePackOmitsMissingObject() throws Exception {
    String rev = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    try (Repository repo = repoManager.openRepository(project)) {
        TestRepository<?> tr = new TestRepository<>(repo);
        String subject = "Subject for missing commit";
        Change c = new Change(c3.change());
        PatchSet.Id psId = new PatchSet.Id(c3.getId(), 2);
        c.setCurrentPatchSet(psId, subject, c.getOriginalSubject());
        if (notesMigration.changePrimaryStorage() == PrimaryStorage.REVIEW_DB) {
            PatchSet ps = TestChanges.newPatchSet(psId, rev, admin.getId());
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().update(Collections.singleton(c));
        }
        if (notesMigration.commitChangeWrites()) {
            PersonIdent committer = serverIdent.get();
            PersonIdent author = noteUtil.newIdent(accountCache.get(admin.getId()).getAccount(), committer.getWhen(), committer, anonymousCowardName);
            tr.branch(RefNames.changeMetaRef(c3.getId())).commit().author(author).committer(committer).message("Update patch set " + psId.get() + "\n" + "\n" + "Patch-set: " + psId.get() + "\n" + "Commit: " + rev + "\n" + "Subject: " + subject + "\n").create();
        }
        indexer.index(db, c.getProject(), c.getId());
    }
    assertThat(getReceivePackRefs().additionalHaves()).containsExactly(obj(c4, 1));
}
#end_block

#method_before
@Override
public void onAddAccountsToGroup(Account.Id me, Collection<AccountGroupMember> added) {
    List<AccountGroupMemberAudit> auditInserts = new LinkedList<>();
    for (AccountGroupMember m : added) {
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs());
        auditInserts.add(audit);
    }
    try (ReviewDb db = schema.open()) {
        db.accountGroupMembersAudit().insert(auditInserts);
    } catch (OrmException e) {
        logOrmExceptionForAccounts("Cannot log add accounts to group event performed by user", me, added, e);
    }
}
#method_after
@Override
public void onAddAccountsToGroup(Account.Id me, Collection<AccountGroupMember> added) {
    List<AccountGroupMemberAudit> auditInserts = new ArrayList<>();
    for (AccountGroupMember m : added) {
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs());
        auditInserts.add(audit);
    }
    try (ReviewDb db = schema.open()) {
        db.accountGroupMembersAudit().insert(auditInserts);
    } catch (OrmException e) {
        logOrmExceptionForAccounts("Cannot log add accounts to group event performed by user", me, added, e);
    }
}
#end_block

#method_before
@Override
public void onDeleteAccountsFromGroup(Account.Id me, Collection<AccountGroupMember> removed) {
    List<AccountGroupMemberAudit> auditInserts = new LinkedList<>();
    List<AccountGroupMemberAudit> auditUpdates = new LinkedList<>();
    try (ReviewDb db = schema.open()) {
        for (AccountGroupMember m : removed) {
            AccountGroupMemberAudit audit = null;
            for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                if (a.isActive()) {
                    audit = a;
                    break;
                }
            }
            if (audit != null) {
                audit.removed(me, TimeUtil.nowTs());
                auditUpdates.add(audit);
            } else {
                audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs());
                audit.removedLegacy();
                auditInserts.add(audit);
            }
        }
        db.accountGroupMembersAudit().update(auditUpdates);
        db.accountGroupMembersAudit().insert(auditInserts);
    } catch (OrmException e) {
        logOrmExceptionForAccounts("Cannot log delete accounts from group event performed by user", me, removed, e);
    }
}
#method_after
@Override
public void onDeleteAccountsFromGroup(Account.Id me, Collection<AccountGroupMember> removed) {
    List<AccountGroupMemberAudit> auditInserts = new ArrayList<>();
    List<AccountGroupMemberAudit> auditUpdates = new ArrayList<>();
    try (ReviewDb db = schema.open()) {
        for (AccountGroupMember m : removed) {
            AccountGroupMemberAudit audit = null;
            for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                if (a.isActive()) {
                    audit = a;
                    break;
                }
            }
            if (audit != null) {
                audit.removed(me, TimeUtil.nowTs());
                auditUpdates.add(audit);
            } else {
                audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs());
                audit.removedLegacy();
                auditInserts.add(audit);
            }
        }
        db.accountGroupMembersAudit().update(auditUpdates);
        db.accountGroupMembersAudit().insert(auditInserts);
    } catch (OrmException e) {
        logOrmExceptionForAccounts("Cannot log delete accounts from group event performed by user", me, removed, e);
    }
}
#end_block

#method_before
@Override
public void onDeleteGroupsFromGroup(Account.Id me, Collection<AccountGroupById> removed) {
    final List<AccountGroupByIdAud> auditUpdates = new LinkedList<>();
    try (ReviewDb db = schema.open()) {
        for (final AccountGroupById g : removed) {
            AccountGroupByIdAud audit = null;
            for (AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(g.getGroupId(), g.getIncludeUUID())) {
                if (a.isActive()) {
                    audit = a;
                    break;
                }
            }
            if (audit != null) {
                audit.removed(me, TimeUtil.nowTs());
                auditUpdates.add(audit);
            }
        }
        db.accountGroupByIdAud().update(auditUpdates);
    } catch (OrmException e) {
        logOrmExceptionForGroups("Cannot log delete groups from group event performed by user", me, removed, e);
    }
}
#method_after
@Override
public void onDeleteGroupsFromGroup(Account.Id me, Collection<AccountGroupById> removed) {
    final List<AccountGroupByIdAud> auditUpdates = new ArrayList<>();
    try (ReviewDb db = schema.open()) {
        for (final AccountGroupById g : removed) {
            AccountGroupByIdAud audit = null;
            for (AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(g.getGroupId(), g.getIncludeUUID())) {
                if (a.isActive()) {
                    audit = a;
                    break;
                }
            }
            if (audit != null) {
                audit.removed(me, TimeUtil.nowTs());
                auditUpdates.add(audit);
            }
        }
        db.accountGroupByIdAud().update(auditUpdates);
    } catch (OrmException e) {
        logOrmExceptionForGroups("Cannot log delete groups from group event performed by user", me, removed, e);
    }
}
#end_block

#method_before
public Multimap<Branch.NameKey, ChangeData> changesByBranch() throws OrmException {
    ListMultimap<Branch.NameKey, ChangeData> ret = ArrayListMultimap.create();
    for (ChangeData cd : changeData.values()) {
        ret.put(cd.change().getDest(), cd);
    }
    return ret;
}
#method_after
public ListMultimap<Branch.NameKey, ChangeData> changesByBranch() throws OrmException {
    ListMultimap<Branch.NameKey, ChangeData> ret = MultimapBuilder.hashKeys().arrayListValues().build();
    for (ChangeData cd : changeData.values()) {
        ret.put(cd.change().getDest(), cd);
    }
    return ret;
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    notesMigration.setFromEnv();
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(user);
    atrScope.set(ctx);
    userSshSession = ctx.getSession();
    userSshSession.open();
    ctx = newRequestContext(admin);
    atrScope.set(ctx);
    adminSshSession = ctx.getSession();
    adminSshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    notesMigration.setFromEnv();
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    if (classDesc.useSsh() || methodDesc.useSsh()) {
        useSsh = true;
        if (SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
            // Create Ssh sessions
            initSsh(admin);
            Context ctx = newRequestContext(user);
            atrScope.set(ctx);
            userSshSession = ctx.getSession();
            userSshSession.open();
            ctx = newRequestContext(admin);
            atrScope.set(ctx);
            adminSshSession = ctx.getSession();
            adminSshSession.open();
        }
    } else {
        useSsh = false;
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
private void afterTest() throws Exception {
    Transport.unregister(inProcessProtocol);
    for (Repository repo : toClose) {
        repo.close();
    }
    db.close();
    adminSshSession.close();
    userSshSession.close();
    if (server != commonServer) {
        server.stop();
    }
}
#method_after
private void afterTest() throws Exception {
    Transport.unregister(inProcessProtocol);
    for (Repository repo : toClose) {
        repo.close();
    }
    db.close();
    if (adminSshSession != null) {
        adminSshSession.close();
    }
    if (userSshSession != null) {
        userSshSession.close();
    }
    if (server != commonServer) {
        server.stop();
    }
}
#end_block

#method_before
protected EditInfo getEdit(String id) throws RestApiException {
    return gApi.changes().id(id).getEdit();
}
#method_after
protected Optional<EditInfo> getEdit(String id) throws RestApiException {
    return gApi.changes().id(id).edit().get();
}
#end_block

#method_before
public static ChangeMessage newMessage(BatchUpdate.ChangeContext ctx, String body, @Nullable String tag) throws OrmException {
    return newMessage(ctx.getDb(), ctx.getChange().currentPatchSetId(), ctx.getUser(), ctx.getWhen(), body, tag);
}
#method_after
public static ChangeMessage newMessage(BatchUpdate.ChangeContext ctx, String body, @Nullable String tag) {
    return newMessage(ctx.getChange().currentPatchSetId(), ctx.getUser(), ctx.getWhen(), body, tag);
}
#end_block

#method_before
public static ChangeMessage newMessage(ReviewDb db, PatchSet.Id psId, CurrentUser user, Timestamp when, String body, @Nullable String tag) throws OrmException {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(db)), accountId, when, psId);
    m.setMessage(body);
    m.setTag(tag);
    user.updateRealAccountId(m::setRealAuthor);
    return m;
}
#method_after
public static ChangeMessage newMessage(PatchSet.Id psId, CurrentUser user, Timestamp when, String body, @Nullable String tag) {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUuid()), accountId, when, psId);
    m.setMessage(body);
    m.setTag(tag);
    user.updateRealAccountId(m::setRealAuthor);
    return m;
}
#end_block

#method_before
private CodeReviewCommit getAlreadyMergedCommit(RepoContext ctx) throws IOException {
    CodeReviewCommit tip = args.mergeTip.getInitialTip();
    if (tip == null) {
        return null;
    }
    CodeReviewRevWalk rw = (CodeReviewRevWalk) ctx.getRevWalk();
    Change.Id id = getId();
    Collection<Ref> refs = ctx.getRepository().getRefDatabase().getRefs(id.toRefPrefix()).values();
    List<CodeReviewCommit> commits = new ArrayList<>(refs.size());
    for (Ref ref : refs) {
        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
        if (psId == null) {
            continue;
        }
        try {
            CodeReviewCommit c = rw.parseCommit(ref.getObjectId());
            c.setPatchsetId(psId);
            commits.add(c);
        } catch (MissingObjectException | IncorrectObjectTypeException e) {
            // Bogus ref, can't be merged into tip so we don't care.
            continue;
        }
    }
    Collections.sort(commits, ReviewDbUtil.intKeyOrdering().reverse().onResultOf(c -> c.getPatchsetId()));
    CodeReviewCommit result = MergeUtil.findAnyMergedInto(rw, commits, tip);
    if (result == null) {
        return null;
    }
    // Some patch set of this change is actually merged into the target
    // branch, most likely because a previous run of MergeOp failed after
    // updateRepo, during updateChange.
    // 
    // Do the best we can to clean this up: mark the change as merged and set
    // the current patch set. Don't touch the dest branch at all. This can
    // lead to some odd situations like another change in the set merging in
    // a different patch set of this change, but that's unavoidable at this
    // point.  At least the change will end up in the right state.
    // 
    // TODO(dborowitz): Consider deleting later junk patch set refs. They
    // presumably don't have PatchSets pointing to them.
    rw.parseBody(result);
    result.add(args.canMergeFlag);
    PatchSet.Id psId = result.getPatchsetId();
    result.copyFrom(toMerge);
    // Got overwriten by copyFrom.
    result.setPatchsetId(psId);
    result.setStatusCode(CommitMergeStatus.ALREADY_MERGED);
    args.commits.put(result);
    return result;
}
#method_after
private CodeReviewCommit getAlreadyMergedCommit(RepoContext ctx) throws IOException {
    CodeReviewCommit tip = args.mergeTip.getInitialTip();
    if (tip == null) {
        return null;
    }
    CodeReviewRevWalk rw = (CodeReviewRevWalk) ctx.getRevWalk();
    Change.Id id = getId();
    Collection<Ref> refs = ctx.getRepository().getRefDatabase().getRefs(id.toRefPrefix()).values();
    List<CodeReviewCommit> commits = new ArrayList<>(refs.size());
    for (Ref ref : refs) {
        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
        if (psId == null) {
            continue;
        }
        try {
            CodeReviewCommit c = rw.parseCommit(ref.getObjectId());
            c.setPatchsetId(psId);
            commits.add(c);
        } catch (MissingObjectException | IncorrectObjectTypeException e) {
            // Bogus ref, can't be merged into tip so we don't care.
            continue;
        }
    }
    Collections.sort(commits, ReviewDbUtil.intKeyOrdering().reverse().onResultOf(c -> c.getPatchsetId()));
    CodeReviewCommit result = MergeUtil.findAnyMergedInto(rw, commits, tip);
    if (result == null) {
        return null;
    }
    // Some patch set of this change is actually merged into the target
    // branch, most likely because a previous run of MergeOp failed after
    // updateRepo, during updateChange.
    // 
    // Do the best we can to clean this up: mark the change as merged and set
    // the current patch set. Don't touch the dest branch at all. This can
    // lead to some odd situations like another change in the set merging in
    // a different patch set of this change, but that's unavoidable at this
    // point.  At least the change will end up in the right state.
    // 
    // TODO(dborowitz): Consider deleting later junk patch set refs. They
    // presumably don't have PatchSets pointing to them.
    rw.parseBody(result);
    result.add(args.canMergeFlag);
    PatchSet.Id psId = result.getPatchsetId();
    result.copyFrom(toMerge);
    // Got overwriten by copyFrom.
    result.setPatchsetId(psId);
    result.setStatusCode(CommitMergeStatus.ALREADY_MERGED);
    args.commitStatus.put(result);
    return result;
}
#end_block

#method_before
@Override
public final boolean updateChange(ChangeContext ctx) throws Exception {
    logDebug("{}#updateChange for change {}", getClass().getSimpleName(), toMerge.change().getId());
    // Update change and notes from ctx.
    toMerge.setControl(ctx.getControl());
    PatchSet.Id oldPsId = checkNotNull(toMerge.getPatchsetId());
    PatchSet.Id newPsId;
    if (alreadyMerged != null) {
        alreadyMerged.setControl(ctx.getControl());
        mergedPatchSet = getOrCreateAlreadyMergedPatchSet(ctx);
        newPsId = mergedPatchSet.getId();
    } else {
        PatchSet newPatchSet = updateChangeImpl(ctx);
        newPsId = checkNotNull(ctx.getChange().currentPatchSetId());
        if (newPatchSet == null) {
            checkState(oldPsId.equals(newPsId), "patch set advanced from %s to %s but updateChangeImpl did not" + " return new patch set instance", oldPsId, newPsId);
            // Ok to use stale notes to get the old patch set, which didn't change
            // during the submit strategy.
            mergedPatchSet = checkNotNull(args.psUtil.get(ctx.getDb(), ctx.getNotes(), oldPsId), "missing old patch set %s", oldPsId);
        } else {
            PatchSet.Id n = newPatchSet.getId();
            checkState(!n.equals(oldPsId) && n.equals(newPsId), "current patch was %s and is now %s, but updateChangeImpl returned" + " new patch set instance at %s", oldPsId, newPsId, n);
            mergedPatchSet = newPatchSet;
        }
    }
    Change c = ctx.getChange();
    Change.Id id = c.getId();
    CodeReviewCommit commit = args.commits.get(id);
    checkNotNull(commit, "missing commit for change " + id);
    CommitMergeStatus s = commit.getStatusCode();
    checkNotNull(s, "status not set for change " + id + " expected to previously fail fast");
    logDebug("Status of change {} ({}) on {}: {}", id, commit.name(), c.getDest(), s);
    setApproval(ctx, args.caller);
    mergeResultRev = alreadyMerged == null ? args.mergeTip.getMergeResults().get(commit) : // ChangeMergedEvent in the fixup case, but we'll just live with that.
    alreadyMerged;
    try {
        setMerged(ctx, message(ctx, commit, s));
    } catch (OrmException err) {
        String msg = "Error updating change status for " + id;
        log.error(msg, err);
        args.commits.logProblem(id, msg);
    // It's possible this happened before updating anything in the db, but
    // it's hard to know for sure, so just return true below to be safe.
    }
    updatedChange = c;
    return true;
}
#method_after
@Override
public final boolean updateChange(ChangeContext ctx) throws Exception {
    logDebug("{}#updateChange for change {}", getClass().getSimpleName(), toMerge.change().getId());
    // Update change and notes from ctx.
    toMerge.setControl(ctx.getControl());
    PatchSet.Id oldPsId = checkNotNull(toMerge.getPatchsetId());
    PatchSet.Id newPsId;
    if (alreadyMerged != null) {
        alreadyMerged.setControl(ctx.getControl());
        mergedPatchSet = getOrCreateAlreadyMergedPatchSet(ctx);
        newPsId = mergedPatchSet.getId();
    } else {
        PatchSet newPatchSet = updateChangeImpl(ctx);
        newPsId = checkNotNull(ctx.getChange().currentPatchSetId());
        if (newPatchSet == null) {
            checkState(oldPsId.equals(newPsId), "patch set advanced from %s to %s but updateChangeImpl did not" + " return new patch set instance", oldPsId, newPsId);
            // Ok to use stale notes to get the old patch set, which didn't change
            // during the submit strategy.
            mergedPatchSet = checkNotNull(args.psUtil.get(ctx.getDb(), ctx.getNotes(), oldPsId), "missing old patch set %s", oldPsId);
        } else {
            PatchSet.Id n = newPatchSet.getId();
            checkState(!n.equals(oldPsId) && n.equals(newPsId), "current patch was %s and is now %s, but updateChangeImpl returned" + " new patch set instance at %s", oldPsId, newPsId, n);
            mergedPatchSet = newPatchSet;
        }
    }
    Change c = ctx.getChange();
    Change.Id id = c.getId();
    CodeReviewCommit commit = args.commitStatus.get(id);
    checkNotNull(commit, "missing commit for change " + id);
    CommitMergeStatus s = commit.getStatusCode();
    checkNotNull(s, "status not set for change " + id + " expected to previously fail fast");
    logDebug("Status of change {} ({}) on {}: {}", id, commit.name(), c.getDest(), s);
    setApproval(ctx, args.caller);
    mergeResultRev = alreadyMerged == null ? args.mergeTip.getMergeResults().get(commit) : // ChangeMergedEvent in the fixup case, but we'll just live with that.
    alreadyMerged;
    try {
        setMerged(ctx, message(ctx, commit, s));
    } catch (OrmException err) {
        String msg = "Error updating change status for " + id;
        log.error(msg, err);
        args.commitStatus.logProblem(id, msg);
    // It's possible this happened before updating anything in the db, but
    // it's hard to know for sure, so just return true below to be safe.
    }
    updatedChange = c;
    return true;
}
#end_block

#method_before
private void setApproval(ChangeContext ctx, IdentifiedUser user) throws OrmException {
    Change.Id id = ctx.getChange().getId();
    List<SubmitRecord> records = args.commits.getSubmitRecords(id);
    PatchSet.Id oldPsId = toMerge.getPatchsetId();
    PatchSet.Id newPsId = ctx.getChange().currentPatchSetId();
    logDebug("Add approval for " + id);
    ChangeUpdate origPsUpdate = ctx.getUpdate(oldPsId);
    origPsUpdate.putReviewer(user.getAccountId(), REVIEWER);
    LabelNormalizer.Result normalized = approve(ctx, origPsUpdate);
    ChangeUpdate newPsUpdate = ctx.getUpdate(newPsId);
    newPsUpdate.merge(args.submissionId, records);
    // approvals as well.
    if (!newPsId.equals(oldPsId)) {
        saveApprovals(normalized, ctx, newPsUpdate, true);
        submitter = convertPatchSet(newPsId).apply(submitter);
    }
}
#method_after
private void setApproval(ChangeContext ctx, IdentifiedUser user) throws OrmException {
    Change.Id id = ctx.getChange().getId();
    List<SubmitRecord> records = args.commitStatus.getSubmitRecords(id);
    PatchSet.Id oldPsId = toMerge.getPatchsetId();
    PatchSet.Id newPsId = ctx.getChange().currentPatchSetId();
    logDebug("Add approval for " + id);
    ChangeUpdate origPsUpdate = ctx.getUpdate(oldPsId);
    origPsUpdate.putReviewer(user.getAccountId(), REVIEWER);
    LabelNormalizer.Result normalized = approve(ctx, origPsUpdate);
    ChangeUpdate newPsUpdate = ctx.getUpdate(newPsId);
    newPsUpdate.merge(args.submissionId, records);
    // approvals as well.
    if (!newPsId.equals(oldPsId)) {
        saveApprovals(normalized, ctx, newPsUpdate, true);
        submitter = convertPatchSet(newPsId).apply(submitter);
    }
}
#end_block

#method_before
private ChangeMessage message(ChangeContext ctx, PatchSet.Id psId, String body) throws OrmException {
    return ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), body, ChangeMessagesUtil.TAG_MERGED);
}
#method_after
private ChangeMessage message(ChangeContext ctx, PatchSet.Id psId, String body) {
    return ChangeMessagesUtil.newMessage(psId, ctx.getUser(), ctx.getWhen(), body, ChangeMessagesUtil.TAG_MERGED);
}
#end_block

#method_before
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null && !args.dryrun) {
        args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen());
    }
}
#method_after
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            try (Repository git = args.repoManager.openRepository(getProject())) {
                git.setGitwebDescription(p.getProject().getDescription());
            } catch (IOException e) {
                log.error("cannot update description of " + p.getProject().getName(), e);
            }
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling, args.accountsToNotify).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null && !args.dryrun) {
        args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen());
    }
}
#end_block

#method_before
private Comment parseComment(byte[] note, MutableInteger curr, String currentFileName, PatchSet.Id psId, RevId revId, boolean isForBase, Integer parentNumber) throws ConfigInvalidException {
    Change.Id changeId = psId.getParentKey();
    // Check if there is a new file.
    boolean newFile = (RawParseUtils.match(note, curr.value, FILE.getBytes(UTF_8))) != -1;
    if (newFile) {
        // If so, parse the new file name.
        currentFileName = parseFilename(note, curr, changeId);
    } else if (currentFileName == null) {
        throw parseException(changeId, "could not parse %s", FILE);
    }
    CommentRange range = parseCommentRange(note, curr);
    if (range == null) {
        throw parseException(changeId, "could not parse %s", COMMENT_RANGE);
    }
    Timestamp commentTime = parseTimestamp(note, curr, changeId);
    Account.Id aId = parseAuthor(note, curr, changeId, AUTHOR);
    boolean hasRealAuthor = (RawParseUtils.match(note, curr.value, REAL_AUTHOR.getBytes(UTF_8))) != -1;
    Account.Id raId = null;
    if (hasRealAuthor) {
        raId = parseAuthor(note, curr, changeId, REAL_AUTHOR);
    }
    boolean hasParent = (RawParseUtils.match(note, curr.value, PARENT.getBytes(UTF_8))) != -1;
    String parentUUID = null;
    if (hasParent) {
        parentUUID = parseStringField(note, curr, changeId, PARENT);
    }
    String uuid = parseStringField(note, curr, changeId, UUID);
    boolean hasTag = (RawParseUtils.match(note, curr.value, TAG.getBytes(UTF_8))) != -1;
    String tag = null;
    if (hasTag) {
        tag = parseStringField(note, curr, changeId, TAG);
    }
    int commentLength = parseCommentLength(note, curr, changeId);
    String message = RawParseUtils.decode(UTF_8, note, curr.value, curr.value + commentLength);
    checkResult(message, "message contents", changeId);
    Comment c = new Comment(new Comment.Key(uuid, currentFileName, psId.get()), aId, commentTime, isForBase ? (short) (parentNumber == null ? 0 : -parentNumber) : (short) 1, message, serverId);
    c.lineNbr = range.getEndLine();
    c.parentUuid = parentUUID;
    c.tag = tag;
    c.setRevId(revId);
    if (raId != null) {
        c.setRealAuthor(raId);
    }
    if (range.getStartCharacter() != -1) {
        c.setRange(range);
    }
    curr.value = RawParseUtils.nextLF(note, curr.value + commentLength);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return c;
}
#method_after
private Comment parseComment(byte[] note, MutableInteger curr, String currentFileName, PatchSet.Id psId, RevId revId, boolean isForBase, Integer parentNumber) throws ConfigInvalidException {
    Change.Id changeId = psId.getParentKey();
    // Check if there is a new file.
    boolean newFile = (RawParseUtils.match(note, curr.value, FILE.getBytes(UTF_8))) != -1;
    if (newFile) {
        // If so, parse the new file name.
        currentFileName = parseFilename(note, curr, changeId);
    } else if (currentFileName == null) {
        throw parseException(changeId, "could not parse %s", FILE);
    }
    CommentRange range = parseCommentRange(note, curr);
    if (range == null) {
        throw parseException(changeId, "could not parse %s", COMMENT_RANGE);
    }
    Timestamp commentTime = parseTimestamp(note, curr, changeId);
    Account.Id aId = parseAuthor(note, curr, changeId, AUTHOR);
    boolean hasRealAuthor = (RawParseUtils.match(note, curr.value, REAL_AUTHOR.getBytes(UTF_8))) != -1;
    Account.Id raId = null;
    if (hasRealAuthor) {
        raId = parseAuthor(note, curr, changeId, REAL_AUTHOR);
    }
    boolean hasParent = (RawParseUtils.match(note, curr.value, PARENT.getBytes(UTF_8))) != -1;
    String parentUUID = null;
    boolean unresolved = false;
    if (hasParent) {
        parentUUID = parseStringField(note, curr, changeId, PARENT);
    }
    boolean hasUnresolved = (RawParseUtils.match(note, curr.value, UNRESOLVED.getBytes(UTF_8))) != -1;
    if (hasUnresolved) {
        unresolved = parseBooleanField(note, curr, changeId, UNRESOLVED);
    }
    String uuid = parseStringField(note, curr, changeId, UUID);
    boolean hasTag = (RawParseUtils.match(note, curr.value, TAG.getBytes(UTF_8))) != -1;
    String tag = null;
    if (hasTag) {
        tag = parseStringField(note, curr, changeId, TAG);
    }
    int commentLength = parseCommentLength(note, curr, changeId);
    String message = RawParseUtils.decode(UTF_8, note, curr.value, curr.value + commentLength);
    checkResult(message, "message contents", changeId);
    Comment c = new Comment(new Comment.Key(uuid, currentFileName, psId.get()), aId, commentTime, isForBase ? (short) (parentNumber == null ? 0 : -parentNumber) : (short) 1, message, serverId, unresolved);
    c.lineNbr = range.getEndLine();
    c.parentUuid = parentUUID;
    c.tag = tag;
    c.setRevId(revId);
    if (raId != null) {
        c.setRealAuthor(raId);
    }
    if (range.getStartCharacter() != -1) {
        c.setRange(range);
    }
    curr.value = RawParseUtils.nextLF(note, curr.value + commentLength);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return c;
}
#end_block

#method_before
void buildNote(Multimap<Integer, Comment> comments, OutputStream out) {
    if (comments.isEmpty()) {
        return;
    }
    List<Integer> psIds = new ArrayList<>(comments.keySet());
    Collections.sort(psIds);
    OutputStreamWriter streamWriter = new OutputStreamWriter(out, UTF_8);
    try (PrintWriter writer = new PrintWriter(streamWriter)) {
        String revId = comments.values().iterator().next().revId;
        appendHeaderField(writer, REVISION, revId);
        for (int psId : psIds) {
            List<Comment> psComments = COMMENT_ORDER.sortedCopy(comments.get(psId));
            Comment first = psComments.get(0);
            short side = first.side;
            appendHeaderField(writer, side <= 0 ? BASE_PATCH_SET : PATCH_SET, Integer.toString(psId));
            if (side < 0) {
                appendHeaderField(writer, PARENT_NUMBER, Integer.toString(-side));
            }
            String currentFilename = null;
            for (Comment c : psComments) {
                checkArgument(revId.equals(c.revId), "All comments being added must have all the same RevId. The " + "comment below does not have the same RevId as the others " + "(%s).\n%s", revId, c);
                checkArgument(side == c.side, "All comments being added must all have the same side. The " + "comment below does not have the same side as the others " + "(%s).\n%s", side, c);
                String commentFilename = QuotedString.GIT_PATH.quote(c.key.filename);
                if (!commentFilename.equals(currentFilename)) {
                    currentFilename = commentFilename;
                    writer.print("File: ");
                    writer.print(commentFilename);
                    writer.print("\n\n");
                }
                appendOneComment(writer, c);
            }
        }
    }
}
#method_after
void buildNote(ListMultimap<Integer, Comment> comments, OutputStream out) {
    if (comments.isEmpty()) {
        return;
    }
    List<Integer> psIds = new ArrayList<>(comments.keySet());
    Collections.sort(psIds);
    OutputStreamWriter streamWriter = new OutputStreamWriter(out, UTF_8);
    try (PrintWriter writer = new PrintWriter(streamWriter)) {
        String revId = comments.values().iterator().next().revId;
        appendHeaderField(writer, REVISION, revId);
        for (int psId : psIds) {
            List<Comment> psComments = COMMENT_ORDER.sortedCopy(comments.get(psId));
            Comment first = psComments.get(0);
            short side = first.side;
            appendHeaderField(writer, side <= 0 ? BASE_PATCH_SET : PATCH_SET, Integer.toString(psId));
            if (side < 0) {
                appendHeaderField(writer, PARENT_NUMBER, Integer.toString(-side));
            }
            String currentFilename = null;
            for (Comment c : psComments) {
                checkArgument(revId.equals(c.revId), "All comments being added must have all the same RevId. The " + "comment below does not have the same RevId as the others " + "(%s).\n%s", revId, c);
                checkArgument(side == c.side, "All comments being added must all have the same side. The " + "comment below does not have the same side as the others " + "(%s).\n%s", side, c);
                String commentFilename = QuotedString.GIT_PATH.quote(c.key.filename);
                if (!commentFilename.equals(currentFilename)) {
                    currentFilename = commentFilename;
                    writer.print("File: ");
                    writer.print(commentFilename);
                    writer.print("\n\n");
                }
                appendOneComment(writer, c);
            }
        }
    }
}
#end_block

#method_before
private void appendOneComment(PrintWriter writer, Comment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    Comment.Range range = c.range;
    if (range != null) {
        writer.print(range.startLine);
        writer.print(':');
        writer.print(range.startChar);
        writer.print('-');
        writer.print(range.endLine);
        writer.print(':');
        writer.print(range.endChar);
    } else {
        writer.print(c.lineNbr);
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.writtenOn));
    writer.print("\n");
    appendIdent(writer, AUTHOR, c.author.getId(), c.writtenOn);
    if (!c.getRealAuthor().equals(c.author)) {
        appendIdent(writer, REAL_AUTHOR, c.getRealAuthor().getId(), c.writtenOn);
    }
    String parent = c.parentUuid;
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.key.uuid);
    if (c.tag != null) {
        appendHeaderField(writer, TAG, c.tag);
    }
    byte[] messageBytes = c.message.getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.message);
    writer.print("\n\n");
}
#method_after
private void appendOneComment(PrintWriter writer, Comment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    Comment.Range range = c.range;
    if (range != null) {
        writer.print(range.startLine);
        writer.print(':');
        writer.print(range.startChar);
        writer.print('-');
        writer.print(range.endLine);
        writer.print(':');
        writer.print(range.endChar);
    } else {
        writer.print(c.lineNbr);
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.writtenOn));
    writer.print("\n");
    appendIdent(writer, AUTHOR, c.author.getId(), c.writtenOn);
    if (!c.getRealAuthor().equals(c.author)) {
        appendIdent(writer, REAL_AUTHOR, c.getRealAuthor().getId(), c.writtenOn);
    }
    String parent = c.parentUuid;
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UNRESOLVED, Boolean.toString(c.unresolved));
    appendHeaderField(writer, UUID, c.key.uuid);
    if (c.tag != null) {
        appendHeaderField(writer, TAG, c.tag);
    }
    byte[] messageBytes = c.message.getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.message);
    writer.print("\n\n");
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(PARENT_GROUPS_NAME, AccountGroup.UUID.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
            }).loader(ParentGroupsLoader.class);
            cache(SUBGROUPS_NAME, AccountGroup.UUID.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
            }).loader(SubgroupsLoader.class);
            cache(EXTERNAL_NAME, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
            }).loader(AllExternalLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(PARENT_GROUPS_NAME, AccountGroup.UUID.class, new TypeLiteral<ImmutableList<AccountGroup.UUID>>() {
            }).loader(ParentGroupsLoader.class);
            cache(SUBGROUPS_NAME, AccountGroup.UUID.class, new TypeLiteral<ImmutableList<AccountGroup.UUID>>() {
            }).loader(SubgroupsLoader.class);
            cache(EXTERNAL_NAME, String.class, new TypeLiteral<ImmutableList<AccountGroup.UUID>>() {
            }).loader(AllExternalLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public Set<AccountGroup.UUID> subgroupsOf(AccountGroup.UUID groupId) {
    try {
        return subgroups.get(groupId);
    } catch (ExecutionException e) {
        log.warn("Cannot load members of group", e);
        return Collections.emptySet();
    }
}
#method_after
@Override
public Collection<AccountGroup.UUID> subgroupsOf(AccountGroup.UUID groupId) {
    try {
        return subgroups.get(groupId);
    } catch (ExecutionException e) {
        log.warn("Cannot load members of group", e);
        return Collections.emptySet();
    }
}
#end_block

#method_before
@Override
public Set<AccountGroup.UUID> parentGroupsOf(AccountGroup.UUID groupId) {
    try {
        return parentGroups.get(groupId);
    } catch (ExecutionException e) {
        log.warn("Cannot load included groups", e);
        return Collections.emptySet();
    }
}
#method_after
@Override
public Collection<AccountGroup.UUID> parentGroupsOf(AccountGroup.UUID groupId) {
    try {
        return parentGroups.get(groupId);
    } catch (ExecutionException e) {
        log.warn("Cannot load included groups", e);
        return Collections.emptySet();
    }
}
#end_block

#method_before
@Override
public Set<AccountGroup.UUID> allExternalMembers() {
    try {
        return external.get(EXTERNAL_NAME);
    } catch (ExecutionException e) {
        log.warn("Cannot load set of non-internal groups", e);
        return Collections.emptySet();
    }
}
#method_after
@Override
public Collection<AccountGroup.UUID> allExternalMembers() {
    try {
        return external.get(EXTERNAL_NAME);
    } catch (ExecutionException e) {
        log.warn("Cannot load set of non-internal groups", e);
        return ImmutableList.of();
    }
}
#end_block

#method_before
@Override
public Set<AccountGroup.UUID> load(AccountGroup.UUID key) throws Exception {
    try (ReviewDb db = schema.open()) {
        List<AccountGroup> group = db.accountGroups().byUUID(key).toList();
        if (group.size() != 1) {
            return Collections.emptySet();
        }
        Set<AccountGroup.UUID> ids = new HashSet<>();
        for (AccountGroupById agi : db.accountGroupById().byGroup(group.get(0).getId())) {
            ids.add(agi.getIncludeUUID());
        }
        return ImmutableSet.copyOf(ids);
    }
}
#method_after
@Override
public ImmutableList<AccountGroup.UUID> load(AccountGroup.UUID key) throws OrmException {
    try (ReviewDb db = schema.open()) {
        List<AccountGroup> group = db.accountGroups().byUUID(key).toList();
        if (group.size() != 1) {
            return ImmutableList.of();
        }
        Set<AccountGroup.UUID> ids = new HashSet<>();
        for (AccountGroupById agi : db.accountGroupById().byGroup(group.get(0).getId())) {
            ids.add(agi.getIncludeUUID());
        }
        return ImmutableList.copyOf(ids);
    }
}
#end_block

#method_before
@Override
public Set<AccountGroup.UUID> load(AccountGroup.UUID key) throws Exception {
    try (ReviewDb db = schema.open()) {
        Set<AccountGroup.Id> ids = new HashSet<>();
        for (AccountGroupById agi : db.accountGroupById().byIncludeUUID(key)) {
            ids.add(agi.getGroupId());
        }
        Set<AccountGroup.UUID> groupArray = new HashSet<>();
        for (AccountGroup g : db.accountGroups().get(ids)) {
            groupArray.add(g.getGroupUUID());
        }
        return ImmutableSet.copyOf(groupArray);
    }
}
#method_after
@Override
public ImmutableList<AccountGroup.UUID> load(AccountGroup.UUID key) throws OrmException {
    try (ReviewDb db = schema.open()) {
        Set<AccountGroup.Id> ids = new HashSet<>();
        for (AccountGroupById agi : db.accountGroupById().byIncludeUUID(key)) {
            ids.add(agi.getGroupId());
        }
        Set<AccountGroup.UUID> groupArray = new HashSet<>();
        for (AccountGroup g : db.accountGroups().get(ids)) {
            groupArray.add(g.getGroupUUID());
        }
        return ImmutableList.copyOf(groupArray);
    }
}
#end_block

#method_before
@Override
public Set<AccountGroup.UUID> load(String key) throws Exception {
    try (ReviewDb db = schema.open()) {
        Set<AccountGroup.UUID> ids = new HashSet<>();
        for (AccountGroupById agi : db.accountGroupById().all()) {
            if (!AccountGroup.isInternalGroup(agi.getIncludeUUID())) {
                ids.add(agi.getIncludeUUID());
            }
        }
        return ImmutableSet.copyOf(ids);
    }
}
#method_after
@Override
public ImmutableList<AccountGroup.UUID> load(String key) throws Exception {
    try (ReviewDb db = schema.open()) {
        Set<AccountGroup.UUID> ids = new HashSet<>();
        for (AccountGroupById agi : db.accountGroupById().all()) {
            if (!AccountGroup.isInternalGroup(agi.getIncludeUUID())) {
                ids.add(agi.getIncludeUUID());
            }
        }
        return ImmutableList.copyOf(ids);
    }
}
#end_block

#method_before
private void deleteDraftPatchSet(PatchSet patchSet, ChangeContext ctx) throws OrmException {
    // For NoteDb itself, no need to delete these entities, as they are
    // automatically filtered out when patch sets are deleted.
    psUtil.delete(ctx.getDb(), ctx.getUpdate(patchSet.getId()), patchSet);
    accountPatchReviewStore.get().clearReviewed(psId);
    if (PrimaryStorage.of(ctx.getChange()) == REVIEW_DB) {
        // Avoid OrmConcurrencyException trying to delete non-existent entities.
        // Use the unwrap from DeleteChangeOp to handle BatchUpdateReviewDb.
        ReviewDb db = DeleteChangeOp.unwrap(ctx.getDb());
        db.changeMessages().delete(db.changeMessages().byPatchSet(psId));
        db.patchComments().delete(db.patchComments().byPatchSet(psId));
        db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(psId));
    }
}
#method_after
private void deleteDraftPatchSet(PatchSet patchSet, ChangeContext ctx) throws OrmException {
    // For NoteDb itself, no need to delete these entities, as they are
    // automatically filtered out when patch sets are deleted.
    psUtil.delete(ctx.getDb(), ctx.getUpdate(patchSet.getId()), patchSet);
    accountPatchReviewStore.get().clearReviewed(psId);
    // Use the unwrap from DeleteChangeOp to handle BatchUpdateReviewDb.
    ReviewDb db = DeleteChangeOp.unwrap(ctx.getDb());
    db.changeMessages().delete(db.changeMessages().byPatchSet(psId));
    db.patchComments().delete(db.patchComments().byPatchSet(psId));
    db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(psId));
}
#end_block

#method_before
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc, GeneralPreferencesInfo i) throws AuthException, BadRequestException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("requires Modify Account capability");
    }
    checkDownloadScheme(i.downloadScheme);
    Account.Id id = rsrc.getUser().getAccountId();
    GeneralPreferencesInfo n = loader.merge(id, i);
    n.my = i.my;
    n.urlAliases = i.urlAliases;
    writeToGit(id, n);
    return cache.get(id).getAccount().getGeneralPreferencesInfo();
}
#method_after
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc, GeneralPreferencesInfo i) throws AuthException, BadRequestException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("requires Modify Account capability");
    }
    checkDownloadScheme(i.downloadScheme);
    Account.Id id = rsrc.getUser().getAccountId();
    GeneralPreferencesInfo n = loader.merge(id, i);
    n.changeTable = i.changeTable;
    n.my = i.my;
    n.urlAliases = i.urlAliases;
    writeToGit(id, n);
    return cache.get(id).getAccount().getGeneralPreferencesInfo();
}
#end_block

#method_before
private void writeToGit(Account.Id id, GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    VersionedAccountPreferences prefs;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, GeneralPreferencesInfo.defaults());
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
        cache.evict(id);
    }
}
#method_after
private void writeToGit(Account.Id id, GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    VersionedAccountPreferences prefs;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, GeneralPreferencesInfo.defaults());
        storeMyChangeTableColumns(prefs, i.changeTable);
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
        cache.evict(id);
    }
}
#end_block

#method_before
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        refDeletionValidator.validateRefOperation(rsrc.getName(), identifiedUser.get(), u);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws RestApiException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    deleteRefFactory.create(rsrc).ref(rsrc.getRef()).delete();
    return Response.none();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    repoManager = new InMemoryRepositoryManager();
    projectCache = new ProjectCache() {

        @Override
        public ProjectState getAllProjects() {
            return get(allProjectsName);
        }

        @Override
        public ProjectState getAllUsers() {
            return null;
        }

        @Override
        public ProjectState get(Project.NameKey projectName) {
            return all.get(projectName);
        }

        @Override
        public void evict(Project p) {
        }

        @Override
        public void remove(Project p) {
        }

        @Override
        public Iterable<Project.NameKey> all() {
            return Collections.emptySet();
        }

        @Override
        public Iterable<Project.NameKey> byName(String prefix) {
            return Collections.emptySet();
        }

        @Override
        public void onCreateProject(Project.NameKey newProjectName) {
        }

        @Override
        public Set<AccountGroup.UUID> guessRelevantGroupUUIDs() {
            return Collections.emptySet();
        }

        @Override
        public ProjectState checkedGet(Project.NameKey projectName) throws IOException {
            return all.get(projectName);
        }

        @Override
        public void evict(Project.NameKey p) {
        }
    };
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    try {
        Repository repo = repoManager.createRepository(allProjectsName);
        ProjectConfig allProjects = new ProjectConfig(new Project.NameKey(allProjectsName.get()));
        allProjects.load(repo);
        LabelType cr = Util.codeReview();
        allProjects.getLabelSections().put(cr.getName(), cr);
        add(allProjects);
    } catch (IOException | ConfigInvalidException e) {
        throw new RuntimeException(e);
    }
    db = schemaFactory.open();
    schemaCreator.create(db);
    Cache<SectionSortCache.EntryKey, SectionSortCache.EntryVal> c = CacheBuilder.newBuilder().build();
    sectionSorter = new PermissionCollection.Factory(new SectionSortCache(c));
    parent = new ProjectConfig(parentKey);
    parent.load(newRepository(parentKey));
    add(parent);
    local = new ProjectConfig(localKey);
    local.load(newRepository(localKey));
    add(local);
    local.getProject().setParentName(parentKey);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return null;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
    changeControlFactory = injector.getInstance(ChangeControl.Factory.class);
}
#method_after
@Before
public void setUp() throws Exception {
    repoManager = new InMemoryRepositoryManager();
    projectCache = new ProjectCache() {

        @Override
        public ProjectState getAllProjects() {
            return get(allProjectsName);
        }

        @Override
        public ProjectState getAllUsers() {
            return null;
        }

        @Override
        public ProjectState get(Project.NameKey projectName) {
            return all.get(projectName);
        }

        @Override
        public void evict(Project p) {
        }

        @Override
        public void remove(Project p) {
        }

        @Override
        public Iterable<Project.NameKey> all() {
            return Collections.emptySet();
        }

        @Override
        public Iterable<Project.NameKey> byName(String prefix) {
            return Collections.emptySet();
        }

        @Override
        public void onCreateProject(Project.NameKey newProjectName) {
        }

        @Override
        public Set<AccountGroup.UUID> guessRelevantGroupUUIDs() {
            return Collections.emptySet();
        }

        @Override
        public ProjectState checkedGet(Project.NameKey projectName) throws IOException {
            return all.get(projectName);
        }

        @Override
        public void evict(Project.NameKey p) {
        }
    };
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    try {
        Repository repo = repoManager.createRepository(allProjectsName);
        ProjectConfig allProjects = new ProjectConfig(new Project.NameKey(allProjectsName.get()));
        allProjects.load(repo);
        LabelType cr = Util.codeReview();
        allProjects.getLabelSections().put(cr.getName(), cr);
        add(allProjects);
    } catch (IOException | ConfigInvalidException e) {
        throw new RuntimeException(e);
    }
    db = schemaFactory.open();
    singleVersionListener.start();
    try {
        schemaCreator.create(db);
    } finally {
        singleVersionListener.stop();
    }
    Cache<SectionSortCache.EntryKey, SectionSortCache.EntryVal> c = CacheBuilder.newBuilder().build();
    sectionSorter = new PermissionCollection.Factory(new SectionSortCache(c));
    parent = new ProjectConfig(parentKey);
    parent.load(newRepository(parentKey));
    add(parent);
    local = new ProjectConfig(localKey);
    local.load(newRepository(localKey));
    add(local);
    local.getProject().setParentName(parentKey);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return null;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
    changeControlFactory = injector.getInstance(ChangeControl.Factory.class);
}
#end_block

#method_before
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    String canonicalWebUrl = "http://localhost";
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), projectCache, sectionSorter, null, changeControlFactory, null, null, canonicalWebUrl, new MockUser(name, memberOf), newProjectState(local));
}
#method_after
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    String canonicalWebUrl = "http://localhost";
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), projectCache, sectionSorter, null, changeControlFactory, null, queryProvider, null, canonicalWebUrl, new MockUser(name, memberOf), newProjectState(local));
}
#end_block

#method_before
@Override
public ProjectApi name(String name) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ProjectApi name(String name) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ProjectApi create(ProjectInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ProjectApi create(ProjectInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ProjectApi create(String name) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ProjectApi create(String name) {
    throw new NotImplementedException();
}
#end_block

#method_before
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws Exception {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(httpPass);
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                checkArgument(g != null, "group not found: %s", n);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = genSshKey();
        authorizedKeys.addKey(id, publicKey(sshKey, email));
        sshKeyCache.evict(username);
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        indexer.index(id);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#method_after
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws Exception {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(httpPass);
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                checkArgument(g != null, "group not found: %s", n);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = null;
        if (SshMode.useSsh()) {
            sshKey = genSshKey();
            authorizedKeys.addKey(id, publicKey(sshKey, email));
            sshKeyCache.evict(username);
        }
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        indexer.index(id);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#end_block

#method_before
private BranchInfo createBranchInfo(Ref ref, RefControl refControl, Set<String> targets) {
    BranchInfo info = new BranchInfo();
    info.ref = ref.getName();
    info.revision = ref.getObjectId() != null ? ref.getObjectId().name() : null;
    info.canDelete = !targets.contains(ref.getName()) && refControl.canDelete() ? true : null;
    for (UiAction.Description d : UiActions.from(branchViews, new BranchResource(refControl.getProjectControl(), info), Providers.of(refControl.getUser()))) {
        if (info.actions == null) {
            info.actions = new TreeMap<>();
        }
        info.actions.put(d.getId(), new ActionInfo(d));
    }
    FluentIterable<WebLinkInfo> links = webLinks.getBranchLinks(refControl.getProjectControl().getProject().getName(), ref.getName());
    info.webLinks = links.isEmpty() ? null : links.toList();
    return info;
}
#method_after
private BranchInfo createBranchInfo(Ref ref, RefControl refControl, Set<String> targets) {
    BranchInfo info = new BranchInfo();
    info.ref = ref.getName();
    info.revision = ref.getObjectId() != null ? ref.getObjectId().name() : null;
    info.canDelete = !targets.contains(ref.getName()) && refControl.canDelete() ? true : null;
    for (UiAction.Description d : UiActions.from(branchViews, new BranchResource(refControl.getProjectControl(), info), Providers.of(refControl.getUser()))) {
        if (info.actions == null) {
            info.actions = new TreeMap<>();
        }
        info.actions.put(d.getId(), new ActionInfo(d));
    }
    List<WebLinkInfo> links = webLinks.getBranchLinks(refControl.getProjectControl().getProject().getName(), ref.getName());
    info.webLinks = links.isEmpty() ? null : links;
    return info;
}
#end_block

#method_before
public Change reloadChange() throws OrmException {
    notes = notesFactory.create(db, project, legacyId);
    change = notes.getChange();
    if (change == null) {
        throw new OrmException("Unable to load change " + legacyId);
    }
    setPatchSets(null);
    return change;
}
#method_after
public Change reloadChange() throws OrmException {
    try {
        notes = notesFactory.createChecked(db, project, legacyId);
    } catch (NoSuchChangeException e) {
        throw new OrmException("Unable to load change " + legacyId, e);
    }
    change = notes.getChange();
    setPatchSets(null);
    return change;
}
#end_block

#method_before
public Set<Account.Id> editsByUser() throws OrmException {
    if (editsByUser == null) {
        if (!lazyLoad) {
            return Collections.emptySet();
        }
        Change c = change();
        if (c == null) {
            return Collections.emptySet();
        }
        editsByUser = new HashSet<>();
        Change.Id id = checkNotNull(change.getId());
        try (Repository repo = repoManager.openRepository(project())) {
            for (String ref : repo.getRefDatabase().getRefs(RefNames.REFS_USERS).keySet()) {
                if (id.equals(Change.Id.fromEditRefPart(ref))) {
                    editsByUser.add(Account.Id.fromRefPart(ref));
                }
            }
        } catch (IOException e) {
            throw new OrmException(e);
        }
    }
    return editsByUser;
}
#method_after
public Set<Account.Id> editsByUser() throws OrmException {
    return editRefs().keySet();
}
#end_block

#method_before
public Set<Account.Id> draftsByUser() throws OrmException {
    if (draftsByUser == null) {
        if (!lazyLoad) {
            return Collections.emptySet();
        }
        Change c = change();
        if (c == null) {
            return Collections.emptySet();
        }
        draftsByUser = new HashSet<>();
        for (Comment sc : commentsUtil.draftByChange(db, notes)) {
            draftsByUser.add(sc.author.getId());
        }
    }
    return draftsByUser;
}
#method_after
public Set<Account.Id> draftsByUser() throws OrmException {
    return draftRefs().keySet();
}
#end_block

#method_before
public ImmutableMultimap<Account.Id, String> stars() throws OrmException {
    if (stars == null) {
        if (!lazyLoad) {
            return ImmutableMultimap.of();
        }
        stars = checkNotNull(starredChangesUtil).byChange(legacyId);
    }
    return stars;
}
#method_after
public ImmutableListMultimap<Account.Id, String> stars() throws OrmException {
    if (stars == null) {
        if (!lazyLoad) {
            return ImmutableListMultimap.of();
        }
        ImmutableListMultimap.Builder<Account.Id, String> b = ImmutableListMultimap.builder();
        for (Map.Entry<Account.Id, StarRef> e : starRefs().entrySet()) {
            b.putAll(e.getKey(), e.getValue().labels());
        }
        return b.build();
    }
    return stars;
}
#end_block

#method_before
public void setStars(Multimap<Account.Id, String> stars) {
    this.stars = ImmutableMultimap.copyOf(stars);
}
#method_after
public void setStars(ListMultimap<Account.Id, String> stars) {
    this.stars = ImmutableListMultimap.copyOf(stars);
}
#end_block

#method_before
@Test
@GerritConfig(name = "plugins.allowRemoteAdmin", value = "true")
public void serverConfigWithPlugin() throws Exception {
    Path plugins = tempSiteDir.newFolder("plugins").toPath();
    Path jsplugin = plugins.resolve("js-plugin-1.js");
    Files.write(jsplugin, "Gerrit.install(function(self){});\n".getBytes(UTF_8));
    adminSshSession.exec("gerrit plugin reload");
    ServerInfo i = gApi.config().server().getInfo();
    // plugin
    assertThat(i.plugin.jsResourcePaths).hasSize(1);
}
#method_after
@Test
@UseSsh
@GerritConfig(name = "plugins.allowRemoteAdmin", value = "true")
public void serverConfigWithPlugin() throws Exception {
    Path plugins = tempSiteDir.newFolder("plugins").toPath();
    Path jsplugin = plugins.resolve("js-plugin-1.js");
    Files.write(jsplugin, "Gerrit.install(function(self){});\n".getBytes(UTF_8));
    adminSshSession.exec("gerrit plugin reload");
    ServerInfo i = gApi.config().server().getInfo();
    // plugin
    assertThat(i.plugin.jsResourcePaths).hasSize(1);
}
#end_block

#method_before
<T> boolean parse(T param, Multimap<String, String> in, HttpServletRequest req, HttpServletResponse res) throws IOException {
    CmdLineParser clp = parserFactory.create(param);
    try {
        clp.parseOptionMap(in);
    } catch (CmdLineException | NumberFormatException e) {
        if (!clp.wasHelpRequestedByOption()) {
            replyError(req, res, SC_BAD_REQUEST, e.getMessage(), e);
            return false;
        }
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter msg = new StringWriter();
        clp.printQueryStringUsage(req.getRequestURI(), msg);
        msg.write('\n');
        msg.write('\n');
        clp.printUsage(msg, null);
        msg.write('\n');
        CacheHeaders.setNotCacheable(res);
        replyBinaryResult(req, res, BinaryResult.create(msg.toString()).setContentType("text/plain"));
        return false;
    }
    return true;
}
#method_after
<T> boolean parse(T param, ListMultimap<String, String> in, HttpServletRequest req, HttpServletResponse res) throws IOException {
    CmdLineParser clp = parserFactory.create(param);
    try {
        clp.parseOptionMap(in);
    } catch (CmdLineException | NumberFormatException e) {
        if (!clp.wasHelpRequestedByOption()) {
            replyError(req, res, SC_BAD_REQUEST, e.getMessage(), e);
            return false;
        }
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter msg = new StringWriter();
        clp.printQueryStringUsage(req.getRequestURI(), msg);
        msg.write('\n');
        msg.write('\n');
        clp.printUsage(msg, null);
        msg.write('\n');
        CacheHeaders.setNotCacheable(res);
        replyBinaryResult(req, res, BinaryResult.create(msg.toString()).setContentType("text/plain"));
        return false;
    }
    return true;
}
#end_block

#method_before
static void splitQueryString(String queryString, Multimap<String, String> config, Multimap<String, String> params) {
    if (!Strings.isNullOrEmpty(queryString)) {
        for (String kvPair : Splitter.on('&').split(queryString)) {
            Iterator<String> i = Splitter.on('=').limit(2).split(kvPair).iterator();
            String key = Url.decode(i.next());
            String val = i.hasNext() ? Url.decode(i.next()) : "";
            if (RESERVED_KEYS.contains(key)) {
                config.put(key, val);
            } else {
                params.put(key, val);
            }
        }
    }
}
#method_after
static void splitQueryString(String queryString, ListMultimap<String, String> config, ListMultimap<String, String> params) {
    if (!Strings.isNullOrEmpty(queryString)) {
        for (String kvPair : Splitter.on('&').split(queryString)) {
            Iterator<String> i = Splitter.on('=').limit(2).split(kvPair).iterator();
            String key = Url.decode(i.next());
            String val = i.hasNext() ? Url.decode(i.next()) : "";
            if (RESERVED_KEYS.contains(key)) {
                config.put(key, val);
            } else {
                params.put(key, val);
            }
        }
    }
}
#end_block

#method_before
public static void myOwned(String groupName, AsyncCallback<GroupMap> cb) {
    myOwnedGroups().addParameter("q", groupName).get(NativeMap.copyKeysIntoChildren(cb));
}
#method_after
public static void myOwned(String groupName, AsyncCallback<GroupMap> cb) {
    myOwnedGroups().addParameter("g", groupName).get(NativeMap.copyKeysIntoChildren(cb));
}
#end_block

#method_before
public InMemoryDatabase create() throws OrmException {
    if (!created) {
        created = true;
        try (ReviewDb c = open()) {
            schemaCreator.create(c);
        } catch (IOException | ConfigInvalidException e) {
            throw new OrmException("Cannot create in-memory database", e);
        }
    }
    return this;
}
#method_after
public InMemoryDatabase create() throws OrmException {
    if (!created) {
        created = true;
        try (ReviewDb c = open()) {
            singleVersionListener.start();
            schemaCreator.create(c);
        } catch (IOException | ConfigInvalidException e) {
            throw new OrmException("Cannot create in-memory database", e);
        } finally {
            singleVersionListener.stop();
        }
    }
    return this;
}
#end_block

#method_before
public void create(final ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(jdbc)) {
        jdbc.updateSchema(e);
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = SchemaVersion.getBinaryVersion();
    db.schemaVersion().insert(Collections.singleton(sVer));
    initSystemConfig(db);
    allProjectsCreator.setAdministrators(GroupReference.forGroup(admin)).setBatchUsers(GroupReference.forGroup(batch)).create();
    allUsersCreator.setAdministrators(GroupReference.forGroup(admin)).create();
    dataSourceType.getIndexScript().run(db);
}
#method_after
public void create(final ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(jdbc)) {
        jdbc.updateSchema(e);
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = SchemaVersion.getBinaryVersion();
    db.schemaVersion().insert(Collections.singleton(sVer));
    createDefaultGroups(db);
    initSystemConfig(db);
    allProjectsCreator.setAdministrators(GroupReference.forGroup(admin)).setBatchUsers(GroupReference.forGroup(batch)).create();
    allUsersCreator.setAdministrators(GroupReference.forGroup(admin)).create();
    dataSourceType.getIndexScript().run(db);
}
#end_block

#method_before
private SystemConfig initSystemConfig(final ReviewDb c) throws OrmException {
    admin = newGroup(c, "Administrators", null);
    admin.setDescription("Gerrit Site Administrators");
    c.accountGroups().insert(Collections.singleton(admin));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(admin)));
    batch = newGroup(c, "Non-Interactive Users", null);
    batch.setDescription("Users who perform batch actions on Gerrit");
    batch.setOwnerGroupUUID(admin.getGroupUUID());
    c.accountGroups().insert(Collections.singleton(batch));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(batch)));
    final SystemConfig s = SystemConfig.create();
    try {
        s.sitePath = site_path.toRealPath().normalize().toString();
    } catch (IOException e) {
        s.sitePath = site_path.toAbsolutePath().normalize().toString();
    }
    c.systemConfig().insert(Collections.singleton(s));
    return s;
}
#method_after
private SystemConfig initSystemConfig(ReviewDb db) throws OrmException {
    SystemConfig s = SystemConfig.create();
    try {
        s.sitePath = site_path.toRealPath().normalize().toString();
    } catch (IOException e) {
        s.sitePath = site_path.toAbsolutePath().normalize().toString();
    }
    db.systemConfig().insert(Collections.singleton(s));
    return s;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        if (ctx.getControl().canRemoveReviewer(a)) {
            del.add(a);
            if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
                oldApprovals.put(a.getLabel(), a.getValue());
                removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                votesRemoved = true;
            }
        } else {
            throw new AuthException("delete reviewer not permitted");
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    if (PrimaryStorage.of(ctx.getChange()) == REVIEW_DB) {
        // Avoid OrmConcurrencyException trying to update non-existent entities.
        ctx.getDb().patchSetApprovals().delete(del);
    }
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_REVIEWER);
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    List<PatchSetApproval> del = new ArrayList<>();
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        if (ctx.getControl().canRemoveReviewer(a)) {
            del.add(a);
            if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
                oldApprovals.put(a.getLabel(), a.getValue());
                removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                votesRemoved = true;
            }
        } else {
            throw new AuthException("delete reviewer not permitted");
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_REVIEWER);
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        emailReviewers(ctx.getProject(), currChange, del, changeMessage);
    }
    reviewerDeleted.fire(currChange, currPs, reviewer, ctx.getAccount(), changeMessage.getMessage(), newApprovals, oldApprovals, input.notify, ctx.getWhen());
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (NotifyUtil.shouldNotify(input.notify, input.notifyDetails)) {
        emailReviewers(ctx.getProject(), currChange, changeMessage);
    }
    reviewerDeleted.fire(currChange, currPs, reviewer, ctx.getAccount(), changeMessage.getMessage(), newApprovals, oldApprovals, input.notify, ctx.getWhen());
}
#end_block

#method_before
private void emailReviewers(Project.NameKey projectName, Change change, List<PatchSetApproval> dels, ChangeMessage changeMessage) {
    // The user knows they removed themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(dels.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : dels) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            DeleteReviewerSender cm = deleteReviewerSenderFactory.create(projectName, change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.setChangeMessage(changeMessage.getMessage(), changeMessage.getWrittenOn());
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot email update for change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Project.NameKey projectName, Change change, ChangeMessage changeMessage) {
    Account.Id userId = user.get().getAccountId();
    if (userId.equals(reviewer.getId())) {
        // The user knows they removed themselves, don't bother emailing them.
        return;
    }
    try {
        DeleteReviewerSender cm = deleteReviewerSenderFactory.create(projectName, change.getId());
        cm.setFrom(userId);
        cm.addReviewers(Collections.singleton(reviewer.getId()));
        cm.setChangeMessage(changeMessage.getMessage(), changeMessage.getWrittenOn());
        cm.setNotify(input.notify);
        cm.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        cm.send();
    } catch (Exception err) {
        log.error("Cannot email update for change " + change.getId(), err);
    }
}
#end_block

#method_before
public static String extractUsername(String auth) {
    auth = emptyToNull(auth);
    if (auth == null) {
        return null;
    } else if (auth.startsWith("Basic ")) {
        auth = auth.substring("Basic ".length());
        auth = new String(Base64.decode(auth));
        final int c = auth.indexOf(':');
        return c > 0 ? auth.substring(0, c) : null;
    } else if (auth.startsWith("Digest ")) {
        final int u = auth.indexOf("username=\"");
        if (u <= 0) {
            return null;
        }
        auth = auth.substring(u + 10);
        final int e = auth.indexOf('"');
        return e > 0 ? auth.substring(0, e) : null;
    } else {
        return null;
    }
}
#method_after
public static String extractUsername(String auth) {
    auth = emptyToNull(auth);
    if (auth == null) {
        return null;
    } else if (auth.startsWith("Basic ")) {
        auth = auth.substring("Basic ".length());
        auth = new String(Base64.decode(auth), UTF_8);
        final int c = auth.indexOf(':');
        return c > 0 ? auth.substring(0, c) : null;
    } else if (auth.startsWith("Digest ")) {
        final int u = auth.indexOf("username=\"");
        if (u <= 0) {
            return null;
        }
        auth = auth.substring(u + 10);
        final int e = auth.indexOf('"');
        return e > 0 ? auth.substring(0, e) : null;
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public void close() {
    List<ListenableFuture<?>> closeFutures = Lists.newArrayListWithCapacity(2);
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            openIndex.close();
        }
    }));
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            closedIndex.close();
        }
    }));
    Futures.getUnchecked(Futures.allAsList(closeFutures));
}
#method_after
@Override
public void close() {
    try {
        openIndex.close();
    } finally {
        closedIndex.close();
    }
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    final Set<String> fields = IndexUtils.fields(opts);
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws IOException {
            return doRead(fields);
        }

        @Override
        public String toString() {
            return predicate.toString();
        }
    }), fields);
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    final Set<String> fields = IndexUtils.changeFields(opts);
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws IOException {
            return doRead(fields);
        }

        @Override
        public String toString() {
            return predicate.toString();
        }
    }), fields);
}
#end_block

#method_before
private static Multimap<String, IndexableField> fields(Document doc, Set<String> fields) {
    Multimap<String, IndexableField> stored = ArrayListMultimap.create(fields.size(), 4);
    for (IndexableField f : doc) {
        String name = f.name();
        if (fields.contains(name)) {
            stored.put(name, f);
        }
    }
    return stored;
}
#method_after
private static ListMultimap<String, IndexableField> fields(Document doc, Set<String> fields) {
    ListMultimap<String, IndexableField> stored = MultimapBuilder.hashKeys(fields.size()).arrayListValues(4).build();
    for (IndexableField f : doc) {
        String name = f.name();
        if (fields.contains(name)) {
            stored.put(name, f);
        }
    }
    return stored;
}
#end_block

#method_before
private ChangeData toChangeData(Multimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    decodeSubmitRecords(doc, SUBMIT_RECORD_STRICT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_STRICT, cd);
    decodeSubmitRecords(doc, SUBMIT_RECORD_LENIENT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_LENIENT, cd);
    return cd;
}
#method_after
private ChangeData toChangeData(ListMultimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    decodeSubmitRecords(doc, SUBMIT_RECORD_STRICT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_STRICT, cd);
    decodeSubmitRecords(doc, SUBMIT_RECORD_LENIENT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_LENIENT, cd);
    if (fields.contains(REF_STATE_FIELD)) {
        decodeRefStates(doc, cd);
    }
    if (fields.contains(REF_STATE_PATTERN_FIELD)) {
        decodeRefStatePatterns(doc, cd);
    }
    return cd;
}
#end_block

#method_before
private void decodePatchSets(Multimap<String, IndexableField> doc, ChangeData cd) {
    List<PatchSet> patchSets = decodeProtos(doc, PATCH_SET_FIELD, PatchSetProtoField.CODEC);
    if (!patchSets.isEmpty()) {
        // Will be an empty list for schemas prior to when this field was stored;
        // this cannot be valid since a change needs at least one patch set.
        cd.setPatchSets(patchSets);
    }
}
#method_after
private void decodePatchSets(ListMultimap<String, IndexableField> doc, ChangeData cd) {
    List<PatchSet> patchSets = decodeProtos(doc, PATCH_SET_FIELD, PatchSetProtoField.CODEC);
    if (!patchSets.isEmpty()) {
        // Will be an empty list for schemas prior to when this field was stored;
        // this cannot be valid since a change needs at least one patch set.
        cd.setPatchSets(patchSets);
    }
}
#end_block

#method_before
private void decodeApprovals(Multimap<String, IndexableField> doc, ChangeData cd) {
    cd.setCurrentApprovals(decodeProtos(doc, APPROVAL_FIELD, PatchSetApprovalProtoField.CODEC));
}
#method_after
private void decodeApprovals(ListMultimap<String, IndexableField> doc, ChangeData cd) {
    cd.setCurrentApprovals(decodeProtos(doc, APPROVAL_FIELD, PatchSetApprovalProtoField.CODEC));
}
#end_block

#method_before
private void decodeChangedLines(Multimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField added = Iterables.getFirst(doc.get(ADDED_FIELD), null);
    IndexableField deleted = Iterables.getFirst(doc.get(DELETED_FIELD), null);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    } else {
        // No ChangedLines stored, likely due to failure during reindexing, for
        // example due to LargeObjectException. But we know the field was
        // requested, so update ChangeData to prevent callers from trying to
        // lazily load it, as that would probably also fail.
        cd.setNoChangedLines();
    }
}
#method_after
private void decodeChangedLines(ListMultimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField added = Iterables.getFirst(doc.get(ADDED_FIELD), null);
    IndexableField deleted = Iterables.getFirst(doc.get(DELETED_FIELD), null);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    } else {
        // No ChangedLines stored, likely due to failure during reindexing, for
        // example due to LargeObjectException. But we know the field was
        // requested, so update ChangeData to prevent callers from trying to
        // lazily load it, as that would probably also fail.
        cd.setNoChangedLines();
    }
}
#end_block

#method_before
private void decodeMergeable(Multimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField f = Iterables.getFirst(doc.get(MERGEABLE_FIELD), null);
    if (f != null) {
        String mergeable = f.stringValue();
        if ("1".equals(mergeable)) {
            cd.setMergeable(true);
        } else if ("0".equals(mergeable)) {
            cd.setMergeable(false);
        }
    }
}
#method_after
private void decodeMergeable(ListMultimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField f = Iterables.getFirst(doc.get(MERGEABLE_FIELD), null);
    if (f != null) {
        String mergeable = f.stringValue();
        if ("1".equals(mergeable)) {
            cd.setMergeable(true);
        } else if ("0".equals(mergeable)) {
            cd.setMergeable(false);
        }
    }
}
#end_block

#method_before
private void decodeReviewedBy(Multimap<String, IndexableField> doc, ChangeData cd) {
    Collection<IndexableField> reviewedBy = doc.get(REVIEWEDBY_FIELD);
    if (reviewedBy.size() > 0) {
        Set<Account.Id> accounts = Sets.newHashSetWithExpectedSize(reviewedBy.size());
        for (IndexableField r : reviewedBy) {
            int id = r.numericValue().intValue();
            if (reviewedBy.size() == 1 && id == ChangeField.NOT_REVIEWED) {
                break;
            }
            accounts.add(new Account.Id(id));
        }
        cd.setReviewedBy(accounts);
    }
}
#method_after
private void decodeReviewedBy(ListMultimap<String, IndexableField> doc, ChangeData cd) {
    Collection<IndexableField> reviewedBy = doc.get(REVIEWEDBY_FIELD);
    if (reviewedBy.size() > 0) {
        Set<Account.Id> accounts = Sets.newHashSetWithExpectedSize(reviewedBy.size());
        for (IndexableField r : reviewedBy) {
            int id = r.numericValue().intValue();
            if (reviewedBy.size() == 1 && id == ChangeField.NOT_REVIEWED) {
                break;
            }
            accounts.add(new Account.Id(id));
        }
        cd.setReviewedBy(accounts);
    }
}
#end_block

#method_before
private void decodeHashtags(Multimap<String, IndexableField> doc, ChangeData cd) {
    Collection<IndexableField> hashtag = doc.get(HASHTAG_FIELD);
    Set<String> hashtags = Sets.newHashSetWithExpectedSize(hashtag.size());
    for (IndexableField r : hashtag) {
        hashtags.add(r.binaryValue().utf8ToString());
    }
    cd.setHashtags(hashtags);
}
#method_after
private void decodeHashtags(ListMultimap<String, IndexableField> doc, ChangeData cd) {
    Collection<IndexableField> hashtag = doc.get(HASHTAG_FIELD);
    Set<String> hashtags = Sets.newHashSetWithExpectedSize(hashtag.size());
    for (IndexableField r : hashtag) {
        hashtags.add(r.binaryValue().utf8ToString());
    }
    cd.setHashtags(hashtags);
}
#end_block

#method_before
private void decodeStar(Multimap<String, IndexableField> doc, ChangeData cd) {
    Collection<IndexableField> star = doc.get(STAR_FIELD);
    Multimap<Account.Id, String> stars = ArrayListMultimap.create();
    for (IndexableField r : star) {
        StarredChangesUtil.StarField starField = StarredChangesUtil.StarField.parse(r.stringValue());
        if (starField != null) {
            stars.put(starField.accountId(), starField.label());
        }
    }
    cd.setStars(stars);
}
#method_after
private void decodeStar(ListMultimap<String, IndexableField> doc, ChangeData cd) {
    Collection<IndexableField> star = doc.get(STAR_FIELD);
    ListMultimap<Account.Id, String> stars = MultimapBuilder.hashKeys().arrayListValues().build();
    for (IndexableField r : star) {
        StarredChangesUtil.StarField starField = StarredChangesUtil.StarField.parse(r.stringValue());
        if (starField != null) {
            stars.put(starField.accountId(), starField.label());
        }
    }
    cd.setStars(stars);
}
#end_block

#method_before
private void decodeReviewers(Multimap<String, IndexableField> doc, ChangeData cd) {
    cd.setReviewers(ChangeField.parseReviewerFieldValues(FluentIterable.from(doc.get(REVIEWER_FIELD)).transform(IndexableField::stringValue)));
}
#method_after
private void decodeReviewers(ListMultimap<String, IndexableField> doc, ChangeData cd) {
    cd.setReviewers(ChangeField.parseReviewerFieldValues(FluentIterable.from(doc.get(REVIEWER_FIELD)).transform(IndexableField::stringValue)));
}
#end_block

#method_before
private void decodeSubmitRecords(Multimap<String, IndexableField> doc, String field, SubmitRuleOptions opts, ChangeData cd) {
    ChangeField.parseSubmitRecords(Collections2.transform(doc.get(field), f -> f.binaryValue().utf8ToString()), opts, cd);
}
#method_after
private void decodeSubmitRecords(ListMultimap<String, IndexableField> doc, String field, SubmitRuleOptions opts, ChangeData cd) {
    ChangeField.parseSubmitRecords(Collections2.transform(doc.get(field), f -> f.binaryValue().utf8ToString()), opts, cd);
}
#end_block

#method_before
private static <T> List<T> decodeProtos(Multimap<String, IndexableField> doc, String fieldName, ProtobufCodec<T> codec) {
    Collection<IndexableField> fields = doc.get(fieldName);
    if (fields.isEmpty()) {
        return Collections.emptyList();
    }
    List<T> result = new ArrayList<>(fields.size());
    for (IndexableField f : fields) {
        BytesRef r = f.binaryValue();
        result.add(codec.decode(r.bytes, r.offset, r.length));
    }
    return result;
}
#method_after
private static <T> List<T> decodeProtos(ListMultimap<String, IndexableField> doc, String fieldName, ProtobufCodec<T> codec) {
    Collection<IndexableField> fields = doc.get(fieldName);
    if (fields.isEmpty()) {
        return Collections.emptyList();
    }
    List<T> result = new ArrayList<>(fields.size());
    for (IndexableField f : fields) {
        BytesRef r = f.binaryValue();
        result.add(codec.decode(r.bytes, r.offset, r.length));
    }
    return result;
}
#end_block

#method_before
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments);
}
#method_after
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments);
}
#end_block

#method_before
private Multimap<PatchSet.Id, PatchSetApproval> buildApprovals() {
    Multimap<PatchSet.Id, PatchSetApproval> result = ArrayListMultimap.create();
    for (PatchSetApproval a : approvals.values()) {
        if (!patchSets.containsKey(a.getPatchSetId())) {
            // Patch set deleted or missing.
            continue;
        } else if (allPastReviewers.contains(a.getAccountId()) && !reviewers.containsRow(a.getAccountId())) {
            // Reviewer was explicitly removed.
            continue;
        }
        result.put(a.getPatchSetId(), a);
    }
    for (Collection<PatchSetApproval> v : result.asMap().values()) {
        Collections.sort((List<PatchSetApproval>) v, ChangeNotes.PSA_BY_TIME);
    }
    return result;
}
#method_after
private ListMultimap<PatchSet.Id, PatchSetApproval> buildApprovals() {
    ListMultimap<PatchSet.Id, PatchSetApproval> result = MultimapBuilder.hashKeys().arrayListValues().build();
    for (PatchSetApproval a : approvals.values()) {
        if (!patchSets.containsKey(a.getPatchSetId())) {
            // Patch set deleted or missing.
            continue;
        } else if (allPastReviewers.contains(a.getAccountId()) && !reviewers.containsRow(a.getAccountId())) {
            // Reviewer was explicitly removed.
            continue;
        }
        result.put(a.getPatchSetId(), a);
    }
    for (Collection<PatchSetApproval> v : result.asMap().values()) {
        Collections.sort((List<PatchSetApproval>) v, ChangeNotes.PSA_BY_TIME);
    }
    return result;
}
#end_block

#method_before
private Multimap<PatchSet.Id, ChangeMessage> buildMessagesByPatchSet() {
    for (Collection<ChangeMessage> v : changeMessagesByPatchSet.asMap().values()) {
        Collections.reverse((List<ChangeMessage>) v);
    }
    return changeMessagesByPatchSet;
}
#method_after
private ListMultimap<PatchSet.Id, ChangeMessage> buildMessagesByPatchSet() {
    for (Collection<ChangeMessage> v : changeMessagesByPatchSet.asMap().values()) {
        Collections.reverse((List<ChangeMessage>) v);
    }
    return changeMessagesByPatchSet;
}
#end_block

#method_before
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    Account.Id realAccountId = parseRealAccountId(commit, accountId);
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, realAccountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    // "Status: merged" as non-post-submit.
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, realAccountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
    parseDescription(psId, commit);
}
#method_after
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    Account.Id realAccountId = parseRealAccountId(commit, accountId);
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, realAccountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    parseCurrentPatchSet(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    // "Status: merged" as non-post-submit.
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, realAccountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
    parseDescription(psId, commit);
}
#end_block

#method_before
private void updatePatchSetStates() {
    Set<PatchSet.Id> missing = new TreeSet<>(ReviewDbUtil.intKeyOrdering());
    for (Iterator<PatchSet> it = patchSets.values().iterator(); it.hasNext(); ) {
        PatchSet ps = it.next();
        if (ps.getRevision().equals(PARTIAL_PATCH_SET)) {
            missing.add(ps.getId());
            it.remove();
        }
    }
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                patchSets.remove(e.getKey());
                break;
            case DRAFT:
                PatchSet ps = patchSets.get(e.getKey());
                if (ps != null) {
                    ps.setDraft(true);
                }
                break;
        }
    }
    // Post-process other collections to remove items corresponding to deleted
    // (or otherwise missing) patch sets. This is safer than trying to prevent
    // insertion, as it will also filter out items racily added after the patch
    // set was deleted.
    NavigableSet<PatchSet.Id> all = patchSets.navigableKeySet();
    if (!all.isEmpty()) {
        currentPatchSetId = all.last();
    } else {
        currentPatchSetId = null;
    }
    changeMessagesByPatchSet.keys().retainAll(all);
    int pruned = pruneEntitiesForMissingPatchSets(allChangeMessages, ChangeMessage::getPatchSetId, missing);
    pruned += pruneEntitiesForMissingPatchSets(comments.values(), c -> new PatchSet.Id(id, c.key.patchSetId), missing);
    pruned += pruneEntitiesForMissingPatchSets(approvals.values(), PatchSetApproval::getPatchSetId, missing);
    if (!missing.isEmpty()) {
        log.warn("ignoring {} additional entities due to missing patch sets: {}", pruned, missing);
    }
}
#method_after
private void updatePatchSetStates() {
    Set<PatchSet.Id> missing = new TreeSet<>(ReviewDbUtil.intKeyOrdering());
    for (Iterator<PatchSet> it = patchSets.values().iterator(); it.hasNext(); ) {
        PatchSet ps = it.next();
        if (ps.getRevision().equals(PARTIAL_PATCH_SET)) {
            missing.add(ps.getId());
            it.remove();
        }
    }
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                patchSets.remove(e.getKey());
                break;
            case DRAFT:
                PatchSet ps = patchSets.get(e.getKey());
                if (ps != null) {
                    ps.setDraft(true);
                }
                break;
        }
    }
    // Post-process other collections to remove items corresponding to deleted
    // (or otherwise missing) patch sets. This is safer than trying to prevent
    // insertion, as it will also filter out items racily added after the patch
    // set was deleted.
    changeMessagesByPatchSet.keys().retainAll(patchSets.keySet());
    int pruned = pruneEntitiesForMissingPatchSets(allChangeMessages, ChangeMessage::getPatchSetId, missing);
    pruned += pruneEntitiesForMissingPatchSets(comments.values(), c -> new PatchSet.Id(id, c.key.patchSetId), missing);
    pruned += pruneEntitiesForMissingPatchSets(approvals.values(), PatchSetApproval::getPatchSetId, missing);
    if (!missing.isEmpty()) {
        log.warn("ignoring {} additional entities due to missing patch sets: {}", pruned, missing);
    }
}
#end_block

#method_before
@Override
public PatchScript call() throws OrmException, NoSuchChangeException, LargeObjectException, AuthException, InvalidChangeOperationException, IOException {
    if (parentNum < 0) {
        validatePatchSetId(psa);
    }
    validatePatchSetId(psb);
    change = control.getChange();
    project = change.getProject();
    PatchSet psEntityA = psa != null ? psUtil.get(db, control.getNotes(), psa) : null;
    PatchSet psEntityB = psb.get() == 0 ? new PatchSet(psb) : psUtil.get(db, control.getNotes(), psb);
    if ((psEntityA != null && !control.isPatchVisible(psEntityA, db)) || (psEntityB != null && !control.isPatchVisible(psEntityB, db))) {
        throw new NoSuchChangeException(changeId);
    }
    try (Repository git = repoManager.openRepository(project)) {
        bId = toObjectId(psEntityB);
        if (parentNum < 0) {
            aId = psEntityA != null ? toObjectId(psEntityA) : null;
        }
        try {
            final PatchList list = listFor(keyFor(diffPrefs.ignoreWhitespace));
            final PatchScriptBuilder b = newBuilder(list, git);
            final PatchListEntry content = list.get(fileName);
            loadCommentsAndHistory(control.getNotes(), content.getChangeType(), content.getOldName(), content.getNewName());
            return b.toPatchScript(content, comments, history);
        } catch (PatchListNotAvailableException e) {
            throw new NoSuchChangeException(changeId, e);
        } catch (IOException e) {
            log.error("File content unavailable", e);
            throw new NoSuchChangeException(changeId, e);
        } catch (org.eclipse.jgit.errors.LargeObjectException err) {
            throw new LargeObjectException("File content is too large", err);
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Repository " + project + " not found", e);
        throw new NoSuchChangeException(changeId, e);
    } catch (IOException e) {
        log.error("Cannot open repository " + project, e);
        throw new NoSuchChangeException(changeId, e);
    }
}
#method_after
@Override
public PatchScript call() throws OrmException, LargeObjectException, AuthException, InvalidChangeOperationException, IOException {
    if (parentNum < 0) {
        validatePatchSetId(psa);
    }
    validatePatchSetId(psb);
    change = control.getChange();
    project = change.getProject();
    PatchSet psEntityA = psa != null ? psUtil.get(db, control.getNotes(), psa) : null;
    PatchSet psEntityB = psb.get() == 0 ? new PatchSet(psb) : psUtil.get(db, control.getNotes(), psb);
    if ((psEntityA != null && !control.isPatchVisible(psEntityA, db)) || (psEntityB != null && !control.isPatchVisible(psEntityB, db))) {
        throw new NoSuchChangeException(changeId);
    }
    try (Repository git = repoManager.openRepository(project)) {
        bId = toObjectId(psEntityB);
        if (parentNum < 0) {
            aId = psEntityA != null ? toObjectId(psEntityA) : null;
        }
        try {
            final PatchList list = listFor(keyFor(diffPrefs.ignoreWhitespace));
            final PatchScriptBuilder b = newBuilder(list, git);
            final PatchListEntry content = list.get(fileName);
            loadCommentsAndHistory(control.getNotes(), content.getChangeType(), content.getOldName(), content.getNewName());
            return b.toPatchScript(content, comments, history);
        } catch (PatchListNotAvailableException e) {
            throw new NoSuchChangeException(changeId, e);
        } catch (IOException e) {
            log.error("File content unavailable", e);
            throw new NoSuchChangeException(changeId, e);
        } catch (org.eclipse.jgit.errors.LargeObjectException err) {
            throw new LargeObjectException("File content is too large", err);
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Repository " + project + " not found", e);
        throw new NoSuchChangeException(changeId, e);
    } catch (IOException e) {
        log.error("Cannot open repository " + project, e);
        throw new NoSuchChangeException(changeId, e);
    }
}
#end_block

#method_before
private void loadCommentsAndHistory(ChangeNotes notes, ChangeType changeType, String oldName, String newName) throws OrmException {
    Map<Patch.Key, Patch> byKey = new HashMap<>();
    if (loadHistory) {
        // This seems like a cheap trick. It doesn't properly account for a
        // file that gets renamed between patch set 1 and patch set 2. We
        // will wind up packing the wrong Patch object because we didn't do
        // proper rename detection between the patch sets.
        // 
        history = new ArrayList<>();
        for (PatchSet ps : psUtil.byChange(db, notes)) {
            if (!control.isPatchVisible(ps, db)) {
                continue;
            }
            String name = fileName;
            if (psa != null) {
                switch(changeType) {
                    case COPIED:
                    case RENAMED:
                        if (ps.getId().equals(psa)) {
                            name = oldName;
                        }
                        break;
                    case MODIFIED:
                    case DELETED:
                    case ADDED:
                    case REWRITE:
                        break;
                }
            }
            Patch p = new Patch(new Patch.Key(ps.getId(), name));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
        if (edit != null && edit.isPresent()) {
            Patch p = new Patch(new Patch.Key(new PatchSet.Id(psb.getParentKey(), 0), fileName));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
    }
    if (loadComments && edit == null) {
        AccountInfoCacheFactory aic = aicFactory.create();
        comments = new CommentDetail(psa, psb);
        switch(changeType) {
            case ADDED:
            case MODIFIED:
                loadPublished(byKey, aic, newName);
                break;
            case DELETED:
                loadPublished(byKey, aic, newName);
                break;
            case COPIED:
            case RENAMED:
                if (psa != null) {
                    loadPublished(byKey, aic, oldName);
                }
                loadPublished(byKey, aic, newName);
                break;
            case REWRITE:
                break;
        }
        CurrentUser user = control.getUser();
        if (user.isIdentifiedUser()) {
            Account.Id me = user.getAccountId();
            switch(changeType) {
                case ADDED:
                case MODIFIED:
                    loadDrafts(byKey, aic, me, newName);
                    break;
                case DELETED:
                    loadDrafts(byKey, aic, me, newName);
                    break;
                case COPIED:
                case RENAMED:
                    if (psa != null) {
                        loadDrafts(byKey, aic, me, oldName);
                    }
                    loadDrafts(byKey, aic, me, newName);
                    break;
                case REWRITE:
                    break;
            }
        }
        comments.setAccountInfoCache(aic.create());
    }
}
#method_after
private void loadCommentsAndHistory(ChangeNotes notes, ChangeType changeType, String oldName, String newName) throws OrmException {
    Map<Patch.Key, Patch> byKey = new HashMap<>();
    if (loadHistory) {
        // This seems like a cheap trick. It doesn't properly account for a
        // file that gets renamed between patch set 1 and patch set 2. We
        // will wind up packing the wrong Patch object because we didn't do
        // proper rename detection between the patch sets.
        // 
        history = new ArrayList<>();
        for (PatchSet ps : psUtil.byChange(db, notes)) {
            if (!control.isPatchVisible(ps, db)) {
                continue;
            }
            String name = fileName;
            if (psa != null) {
                switch(changeType) {
                    case COPIED:
                    case RENAMED:
                        if (ps.getId().equals(psa)) {
                            name = oldName;
                        }
                        break;
                    case MODIFIED:
                    case DELETED:
                    case ADDED:
                    case REWRITE:
                        break;
                }
            }
            Patch p = new Patch(new Patch.Key(ps.getId(), name));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
        if (edit != null && edit.isPresent()) {
            Patch p = new Patch(new Patch.Key(new PatchSet.Id(psb.getParentKey(), 0), fileName));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
    }
    if (loadComments && edit == null) {
        comments = new CommentDetail(psa, psb);
        switch(changeType) {
            case ADDED:
            case MODIFIED:
                loadPublished(byKey, newName);
                break;
            case DELETED:
                loadPublished(byKey, newName);
                break;
            case COPIED:
            case RENAMED:
                if (psa != null) {
                    loadPublished(byKey, oldName);
                }
                loadPublished(byKey, newName);
                break;
            case REWRITE:
                break;
        }
        CurrentUser user = control.getUser();
        if (user.isIdentifiedUser()) {
            Account.Id me = user.getAccountId();
            switch(changeType) {
                case ADDED:
                case MODIFIED:
                    loadDrafts(byKey, me, newName);
                    break;
                case DELETED:
                    loadDrafts(byKey, me, newName);
                    break;
                case COPIED:
                case RENAMED:
                    if (psa != null) {
                        loadDrafts(byKey, me, oldName);
                    }
                    loadDrafts(byKey, me, newName);
                    break;
                case REWRITE:
                    break;
            }
        }
    }
}
#end_block

#method_before
private void loadPublished(final Map<Patch.Key, Patch> byKey, final AccountInfoCacheFactory aic, final String file) throws OrmException {
    ChangeNotes notes = control.getNotes();
    for (Comment c : commentsUtil.publishedByChangeFile(db, notes, changeId, file)) {
        if (comments.include(change.getId(), c)) {
            aic.want(c.author.getId());
        }
        PatchSet.Id psId = new PatchSet.Id(change.getId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
}
#method_after
private void loadPublished(Map<Patch.Key, Patch> byKey, String file) throws OrmException {
    ChangeNotes notes = control.getNotes();
    for (Comment c : commentsUtil.publishedByChangeFile(db, notes, changeId, file)) {
        comments.include(change.getId(), c);
        PatchSet.Id psId = new PatchSet.Id(change.getId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
}
#end_block

#method_before
private void loadDrafts(final Map<Patch.Key, Patch> byKey, final AccountInfoCacheFactory aic, final Account.Id me, final String file) throws OrmException {
    for (Comment c : commentsUtil.draftByChangeFileAuthor(db, control.getNotes(), file, me)) {
        if (comments.include(change.getId(), c)) {
            aic.want(me);
        }
        PatchSet.Id psId = new PatchSet.Id(change.getId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setDraftCount(p.getDraftCount() + 1);
        }
    }
}
#method_after
private void loadDrafts(Map<Patch.Key, Patch> byKey, Account.Id me, String file) throws OrmException {
    for (Comment c : commentsUtil.draftByChangeFileAuthor(db, control.getNotes(), file, me)) {
        comments.include(change.getId(), c);
        PatchSet.Id psId = new PatchSet.Id(change.getId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setDraftCount(p.getDraftCount() + 1);
        }
    }
}
#end_block

#method_before
@Override
public String toString() {
    return new StringBuilder().append("Comment{").append("key=").append(key).append(',').append("lineNbr=").append(lineNbr).append(',').append("author=").append(author.getId().get()).append(',').append("realAuthor=").append(realAuthor != null ? realAuthor.getId().get() : "").append(',').append("writtenOn=").append(writtenOn.toString()).append(',').append("side=").append(side).append(',').append("message=").append(Objects.toString(message, "")).append(',').append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',').append("range=").append(Objects.toString(range, "")).append(',').append("revId=").append(revId != null ? revId : "").append("tag=").append(Objects.toString(tag, "")).append('}').toString();
}
#method_after
@Override
public String toString() {
    return new StringBuilder().append("Comment{").append("key=").append(key).append(',').append("lineNbr=").append(lineNbr).append(',').append("author=").append(author.getId().get()).append(',').append("realAuthor=").append(realAuthor != null ? realAuthor.getId().get() : "").append(',').append("writtenOn=").append(writtenOn.toString()).append(',').append("side=").append(side).append(',').append("message=").append(Objects.toString(message, "")).append(',').append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',').append("range=").append(Objects.toString(range, "")).append(',').append("revId=").append(revId != null ? revId : "").append(',').append("tag=").append(Objects.toString(tag, "")).append(',').append("unresolved=").append(unresolved).append('}').toString();
}
#end_block

#method_before
private Multimap<Integer, Comment> buildCommentMap() {
    Multimap<Integer, Comment> all = ArrayListMultimap.create();
    for (Comment c : baseComments) {
        if (!delete.contains(c.key) && !put.containsKey(c.key)) {
            all.put(c.key.patchSetId, c);
        }
    }
    for (Comment c : put.values()) {
        if (!delete.contains(c.key)) {
            all.put(c.key.patchSetId, c);
        }
    }
    return all;
}
#method_after
private ListMultimap<Integer, Comment> buildCommentMap() {
    ListMultimap<Integer, Comment> all = MultimapBuilder.hashKeys().arrayListValues().build();
    for (Comment c : baseComments) {
        if (!delete.contains(c.key) && !put.containsKey(c.key)) {
            all.put(c.key.patchSetId, c);
        }
    }
    for (Comment c : put.values()) {
        if (!delete.contains(c.key)) {
            all.put(c.key.patchSetId, c);
        }
    }
    return all;
}
#end_block

#method_before
private void buildNoteJson(ChangeNoteUtil noteUtil, OutputStream out) throws IOException {
    Multimap<Integer, Comment> comments = buildCommentMap();
    if (comments.isEmpty() && pushCert == null) {
        return;
    }
    RevisionNoteData data = new RevisionNoteData();
    data.comments = COMMENT_ORDER.sortedCopy(comments.values());
    data.pushCert = pushCert;
    try (OutputStreamWriter osw = new OutputStreamWriter(out, UTF_8)) {
        noteUtil.getGson().toJson(data, osw);
    }
}
#method_after
private void buildNoteJson(ChangeNoteUtil noteUtil, OutputStream out) throws IOException {
    ListMultimap<Integer, Comment> comments = buildCommentMap();
    if (comments.isEmpty() && pushCert == null) {
        return;
    }
    RevisionNoteData data = new RevisionNoteData();
    data.comments = COMMENT_ORDER.sortedCopy(comments.values());
    data.pushCert = pushCert;
    try (OutputStreamWriter osw = new OutputStreamWriter(out, UTF_8)) {
        noteUtil.getGson().toJson(data, osw);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    // TODO(dborowitz): Use jimfs.
    Path p = Paths.get(cfg.getString("gerrit", null, "tempSiteDir"));
    bind(Path.class).annotatedWith(SitePath.class).toInstance(p);
    makeSiteDirs(p);
    bind(GitRepositoryManager.class).toInstance(new InMemoryRepositoryManager());
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(NotesMigration.class).to(TestNotesMigration.class);
    TypeLiteral<SchemaFactory<ReviewDb>> schemaFactory = new TypeLiteral<SchemaFactory<ReviewDb>>() {
    };
    bind(schemaFactory).to(NotesMigrationSchemaFactory.class);
    bind(Key.get(schemaFactory, ReviewDbFactory.class)).to(InMemoryDatabase.class);
    bind(InMemoryDatabase.class).in(SINGLETON);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    listener().to(CreateDatabase.class);
    bind(SitePaths.class);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    install(new SchemaModule());
    bind(SchemaVersion.class).to(SchemaVersion.C);
}
#method_after
@Override
protected void configure() {
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    // TODO(dborowitz): Use jimfs.
    Path p = Paths.get(cfg.getString("gerrit", null, "tempSiteDir"));
    bind(Path.class).annotatedWith(SitePath.class).toInstance(p);
    makeSiteDirs(p);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(NotesMigration.class).to(TestNotesMigration.class);
    TypeLiteral<SchemaFactory<ReviewDb>> schemaFactory = new TypeLiteral<SchemaFactory<ReviewDb>>() {
    };
    bind(schemaFactory).to(NotesMigrationSchemaFactory.class);
    bind(Key.get(schemaFactory, ReviewDbFactory.class)).to(InMemoryDatabase.class);
    bind(InMemoryDatabase.class).in(SINGLETON);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    listener().to(CreateDatabase.class);
    bind(SitePaths.class);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    install(new SchemaModule());
    bind(SchemaVersion.class).to(SchemaVersion.C);
}
#end_block

#method_before
@Override
protected void configure() {
    CommandName git = Commands.named("git");
    CommandName gerrit = Commands.named("gerrit");
    CommandName logging = Commands.named(gerrit, "logging");
    CommandName plugin = Commands.named(gerrit, "plugin");
    CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, CloseConnection.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    if (sshEnabled()) {
        command("git-upload-pack").to(Commands.key(git, "upload-pack"));
        command(git, "upload-pack").to(Upload.class);
        command("git-upload-archive").to(Commands.key(git, "upload-archive"));
        command(git, "upload-archive").to(UploadArchive.class);
    }
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, SetHeadCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (slaveMode) {
        command("git-receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command("gerrit-receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command(git, "receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command(gerrit, "test-submit").to(NotSupportedInSlaveModeFailureCommand.class);
    } else {
        if (sshEnabled()) {
            command("git-receive-pack").to(Commands.key(git, "receive-pack"));
            command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
            command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        }
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(logging).toProvider(new DispatchCommandProvider(logging));
    command(logging, SetLoggingLevelCommand.class);
    command(logging, ListLoggingLevelCommand.class);
    alias(logging, "ls", ListLoggingLevelCommand.class);
    alias(logging, "set", SetLoggingLevelCommand.class);
}
#method_after
@Override
protected void configure() {
    CommandName git = Commands.named("git");
    CommandName gerrit = Commands.named("gerrit");
    CommandName logging = Commands.named(gerrit, "logging");
    CommandName plugin = Commands.named(gerrit, "plugin");
    CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, CloseConnection.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    if (sshEnabled()) {
        command("git-upload-pack").to(Commands.key(git, "upload-pack"));
        command(git, "upload-pack").to(Upload.class);
        command("git-upload-archive").to(Commands.key(git, "upload-archive"));
        command(git, "upload-archive").to(UploadArchive.class);
    }
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, SetHeadCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (slaveMode) {
        command("git-receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command("gerrit-receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command(git, "receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command(gerrit, "test-submit").to(NotSupportedInSlaveModeFailureCommand.class);
    } else {
        if (sshEnabled()) {
            command("git-receive-pack").to(Commands.key(git, "receive-pack"));
            command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
            command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        }
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(logging).toProvider(new DispatchCommandProvider(logging));
    command(logging, SetLoggingLevelCommand.class);
    command(logging, ListLoggingLevelCommand.class);
    alias(logging, "ls", ListLoggingLevelCommand.class);
    alias(logging, "set", SetLoggingLevelCommand.class);
    install(lfsPluginAuthModule);
}
#end_block

#method_before
public boolean canReadCommit(ReviewDb db, Repository repo, RevCommit commit) {
    try (RevWalk rw = new RevWalk(repo)) {
        return isMergedIntoVisibleRef(repo, db, rw, commit, repo.getAllRefs().values());
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), getProject().getNameKey());
        log.error(msg, e);
        return false;
    }
}
#method_after
public boolean canReadCommit(ReviewDb db, Repository repo, RevCommit commit) {
    // Look for changes associated with the commit.
    try {
        List<ChangeData> changes = queryProvider.get().byProjectCommit(getProject().getNameKey(), commit);
        for (ChangeData change : changes) {
            if (controlFor(db, change.change()).isVisible(db)) {
                return true;
            }
        }
    } catch (OrmException e) {
        log.error("Cannot look up change for commit " + commit.name() + " in " + getProject().getName(), e);
    }
    // Scan all visible refs.
    return canReadCommitFromVisibleRef(db, repo, commit);
}
#end_block

#method_before
private static long initialDelay(String startTime, String interval) {
    return new ScheduleConfig(config(startTime, interval), "section", "subsection", NOW).getInitialDelay();
}
#method_after
@Test
public void initialDelay() throws Exception {
    assertEquals(ms(1, HOURS), initialDelay("11:00", "1h"));
    assertEquals(ms(30, MINUTES), initialDelay("05:30", "1h"));
    assertEquals(ms(30, MINUTES), initialDelay("09:30", "1h"));
    assertEquals(ms(30, MINUTES), initialDelay("13:30", "1h"));
    assertEquals(ms(59, MINUTES), initialDelay("13:59", "1h"));
    assertEquals(ms(1, HOURS), initialDelay("11:00", "1d"));
    assertEquals(ms(19, HOURS) + ms(30, MINUTES), initialDelay("05:30", "1d"));
    assertEquals(ms(1, HOURS), initialDelay("11:00", "1w"));
    assertEquals(ms(7, DAYS) - ms(4, HOURS) - ms(30, MINUTES), initialDelay("05:30", "1w"));
    assertEquals(ms(3, DAYS) + ms(1, HOURS), initialDelay("Mon 11:00", "1w"));
    assertEquals(ms(1, HOURS), initialDelay("Fri 11:00", "1w"));
    assertEquals(ms(1, HOURS), initialDelay("Mon 11:00", "1d"));
    assertEquals(ms(23, HOURS), initialDelay("Mon 09:00", "1d"));
    assertEquals(ms(1, DAYS), initialDelay("Mon 10:00", "1d"));
    assertEquals(ms(1, DAYS), initialDelay("Mon 10:00", "1d"));
}
#end_block

#method_before
@Before
public void setup() {
    user = createNiceMock(IdentifiedUser.class);
    replay(user);
    backends = new DynamicSet<>();
    backends.add(new SystemGroupBackend());
    backend = new UniversalGroupBackend(backends);
}
#method_after
@Before
public void setup() {
    user = createNiceMock(IdentifiedUser.class);
    replay(user);
    backends = new DynamicSet<>();
    backends.add(new SystemGroupBackend(new Config()));
    backend = new UniversalGroupBackend(backends);
}
#end_block

#method_before
@Override
public void start() {
    if (timer == null) {
        timer = new Timer();
    } else {
        timer.cancel();
    }
    timer.scheduleAtFixedRate(new TimerTask() {

        @Override
        public void run() {
            MailReceiver.this.handleEmails();
        }
    }, 0L, mailSettings.fetchInterval);
}
#method_after
@Override
public void start() {
    if (timer == null) {
        timer = new Timer();
    } else {
        timer.cancel();
    }
    timer.scheduleAtFixedRate(new TimerTask() {

        @Override
        public void run() {
            MailReceiver.this.handleEmails(true);
        }
    }, 0L, mailSettings.fetchInterval);
}
#end_block

#method_before
@Override
public TagInfo apply(ProjectResource resource, TagInput input) throws RestApiException, IOException {
    if (input == null) {
        input = new TagInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (ref.startsWith(R_REFS) && !ref.startsWith(R_TAGS)) {
        throw new BadRequestException("invalid tag name \"" + ref + "\"");
    }
    if (!ref.startsWith(R_TAGS)) {
        ref = R_TAGS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid tag name \"" + ref + "\"");
    }
    RefControl refControl = resource.getControl().controlForRef(ref);
    try (Repository repo = repoManager.openRepository(resource.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, resource.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        rw.reset();
        boolean isAnnotated = Strings.emptyToNull(input.message) != null;
        boolean isSigned = isAnnotated && input.message.contains("-----BEGIN PGP SIGNATURE-----\n");
        if (isSigned) {
            throw new MethodNotAllowedException("Cannot create signed tag \"" + ref + "\"");
        } else if (isAnnotated && !refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException("Cannot create annotated tag \"" + ref + "\"");
        } else if (!refControl.canPerform(Permission.CREATE)) {
            throw new AuthException("Cannot create tag \"" + ref + "\"");
        }
        if (repo.getRefDatabase().exactRef(ref) != null) {
            throw new ResourceConflictException("tag \"" + ref + "\" already exists");
        }
        try (Git git = new Git(repo)) {
            TagCommand tag = git.tag().setObjectId(object).setName(ref.substring(R_TAGS.length())).setAnnotated(isAnnotated).setSigned(isSigned);
            if (isAnnotated) {
                tag.setMessage(input.message).setTagger(identifiedUser.get().newCommitterIdent(TimeUtil.nowTs(), TimeZone.getDefault()));
            }
            Ref result = tag.call();
            tagCache.updateFastForward(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId());
            referenceUpdated.fire(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId(), identifiedUser.get().getAccount());
            try (RevWalk w = new RevWalk(repo)) {
                return ListTags.createTagInfo(result, w);
            }
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("Invalid base revision");
    } catch (GitAPIException e) {
        log.error("Cannot create tag \"" + ref + "\"", e);
        throw new IOException(e);
    }
}
#method_after
@Override
public TagInfo apply(ProjectResource resource, TagInput input) throws RestApiException, IOException {
    if (input == null) {
        input = new TagInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    ref = RefUtil.normalizeTagRef(ref);
    RefControl refControl = resource.getControl().controlForRef(ref);
    try (Repository repo = repoManager.openRepository(resource.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, resource.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        rw.reset();
        boolean isAnnotated = Strings.emptyToNull(input.message) != null;
        boolean isSigned = isAnnotated && input.message.contains("-----BEGIN PGP SIGNATURE-----\n");
        if (isSigned) {
            throw new MethodNotAllowedException("Cannot create signed tag \"" + ref + "\"");
        } else if (isAnnotated && !refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException("Cannot create annotated tag \"" + ref + "\"");
        } else if (!refControl.canPerform(Permission.CREATE)) {
            throw new AuthException("Cannot create tag \"" + ref + "\"");
        }
        if (repo.getRefDatabase().exactRef(ref) != null) {
            throw new ResourceConflictException("tag \"" + ref + "\" already exists");
        }
        try (Git git = new Git(repo)) {
            TagCommand tag = git.tag().setObjectId(object).setName(ref.substring(R_TAGS.length())).setAnnotated(isAnnotated).setSigned(isSigned);
            if (isAnnotated) {
                tag.setMessage(input.message).setTagger(identifiedUser.get().newCommitterIdent(TimeUtil.nowTs(), TimeZone.getDefault()));
            }
            Ref result = tag.call();
            tagCache.updateFastForward(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId());
            referenceUpdated.fire(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId(), identifiedUser.get().getAccount());
            try (RevWalk w = new RevWalk(repo)) {
                return ListTags.createTagInfo(result, w);
            }
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("Invalid base revision");
    } catch (GitAPIException e) {
        log.error("Cannot create tag \"" + ref + "\"", e);
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    GitwebType type = typeFromConfig(cfg);
    if (type != null) {
        bind(GitwebType.class).toInstance(type);
        if (!isNullOrEmpty(type.getBranch())) {
            DynamicSet.bind(binder(), BranchWebLink.class).to(GitwebLinks.class);
        }
        if (!isNullOrEmpty(type.getFile()) || !isNullOrEmpty(type.getRootTree())) {
            DynamicSet.bind(binder(), FileWebLink.class).to(GitwebLinks.class);
        }
        if (!isNullOrEmpty(type.getFileHistory())) {
            DynamicSet.bind(binder(), FileHistoryWebLink.class).to(GitwebLinks.class);
        }
        if (!isNullOrEmpty(type.getRevision())) {
            DynamicSet.bind(binder(), PatchSetWebLink.class).to(GitwebLinks.class);
        }
        if (!isNullOrEmpty(type.getProject())) {
            DynamicSet.bind(binder(), ProjectWebLink.class).to(GitwebLinks.class);
        }
    }
}
#method_after
@Override
protected void configure() {
    GitwebType type = typeFromConfig(cfg);
    if (type != null) {
        bind(GitwebType.class).toInstance(type);
        if (!isNullOrEmpty(type.getBranch())) {
            DynamicSet.bind(binder(), BranchWebLink.class).to(GitwebLinks.class);
        }
        if (!isNullOrEmpty(type.getFile()) || !isNullOrEmpty(type.getRootTree())) {
            DynamicSet.bind(binder(), FileWebLink.class).to(GitwebLinks.class);
        }
        if (!isNullOrEmpty(type.getFileHistory())) {
            DynamicSet.bind(binder(), FileHistoryWebLink.class).to(GitwebLinks.class);
        }
        if (!isNullOrEmpty(type.getRevision())) {
            DynamicSet.bind(binder(), PatchSetWebLink.class).to(GitwebLinks.class);
            DynamicSet.bind(binder(), ParentWebLink.class).to(GitwebLinks.class);
        }
        if (!isNullOrEmpty(type.getProject())) {
            DynamicSet.bind(binder(), ProjectWebLink.class).to(GitwebLinks.class);
        }
    }
}
#end_block

#method_before
@Override
public WebLinkInfo getFileHistoryWebLink(String projectName, String revision, String fileName) {
    if (fileHistory != null) {
        return link(revision.replace("project", encode(projectName)).replace("branch", encode(revision)).replace("file", encode(fileName)).toString());
    }
    return null;
}
#method_after
@Override
public WebLinkInfo getFileHistoryWebLink(String projectName, String revision, String fileName) {
    if (fileHistory != null) {
        return link(fileHistory.replace("project", encode(projectName)).replace("branch", encode(revision)).replace("file", encode(fileName)).toString());
    }
    return null;
}
#end_block

#method_before
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.toAbsolutePath())) {
            throw die("aborted by user");
        }
        FileUtil.mkdirsOrDie(site.site_path, "Cannot make directory");
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.tmp_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    mkdir(site.plugins_dir);
    mkdir(site.data_dir);
    for (InitStep step : steps) {
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        step.run();
    }
    saveSecureStore();
    savePublic(flags.cfg);
    extract(site.gerrit_sh, getClass(), "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    chmod(0700, site.tmp_dir);
    extractMailExample("Abandoned.soy");
    extractMailExample("AbandonedHtml.soy");
    extractMailExample("AddKey.soy");
    extractMailExample("ChangeFooter.soy");
    extractMailExample("ChangeFooterHtml.soy");
    extractMailExample("ChangeSubject.soy");
    extractMailExample("Comment.soy");
    extractMailExample("CommentHtml.soy");
    extractMailExample("CommentFooter.soy");
    extractMailExample("CommentFooterHtml.soy");
    extractMailExample("DeleteReviewer.soy");
    extractMailExample("DeleteReviewerHtml.soy");
    extractMailExample("DeleteVote.soy");
    extractMailExample("DeleteVoteHtml.soy");
    extractMailExample("Footer.soy");
    extractMailExample("FooterHtml.soy");
    extractMailExample("HeaderHtml.soy");
    extractMailExample("Merged.soy");
    extractMailExample("MergedHtml.soy");
    extractMailExample("NewChange.soy");
    extractMailExample("NewChangeHtml.soy");
    extractMailExample("RegisterNewEmail.soy");
    extractMailExample("ReplacePatchSet.soy");
    extractMailExample("ReplacePatchSetHtml.soy");
    extractMailExample("Restored.soy");
    extractMailExample("RestoredHtml.soy");
    extractMailExample("Reverted.soy");
    extractMailExample("RevertedHtml.soy");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#method_after
public void run() throws Exception {
    ui.header("Gerrit Code Review %s", version());
    if (site.isNew) {
        if (!ui.yesno(true, "Create '%s'", site.site_path.toAbsolutePath())) {
            throw die("aborted by user");
        }
        FileUtil.mkdirsOrDie(site.site_path, "Cannot make directory");
        flags.deleteOnFailure = true;
    }
    mkdir(site.bin_dir);
    mkdir(site.etc_dir);
    mkdir(site.lib_dir);
    mkdir(site.tmp_dir);
    mkdir(site.logs_dir);
    mkdir(site.mail_dir);
    mkdir(site.static_dir);
    mkdir(site.plugins_dir);
    mkdir(site.data_dir);
    for (InitStep step : steps) {
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        step.run();
    }
    saveSecureStore();
    savePublic(flags.cfg);
    extract(site.gerrit_sh, getClass(), "gerrit.sh");
    chmod(0755, site.gerrit_sh);
    chmod(0700, site.tmp_dir);
    extractMailExample("Abandoned.soy");
    extractMailExample("AbandonedHtml.soy");
    extractMailExample("AddKey.soy");
    extractMailExample("ChangeFooter.soy");
    extractMailExample("ChangeFooterHtml.soy");
    extractMailExample("ChangeSubject.soy");
    extractMailExample("Comment.soy");
    extractMailExample("CommentHtml.soy");
    extractMailExample("CommentFooter.soy");
    extractMailExample("CommentFooterHtml.soy");
    extractMailExample("DeleteReviewer.soy");
    extractMailExample("DeleteReviewerHtml.soy");
    extractMailExample("DeleteVote.soy");
    extractMailExample("DeleteVoteHtml.soy");
    extractMailExample("Footer.soy");
    extractMailExample("FooterHtml.soy");
    extractMailExample("HeaderHtml.soy");
    extractMailExample("Merged.soy");
    extractMailExample("MergedHtml.soy");
    extractMailExample("NewChange.soy");
    extractMailExample("NewChangeHtml.soy");
    extractMailExample("RegisterNewEmail.soy");
    extractMailExample("ReplacePatchSet.soy");
    extractMailExample("ReplacePatchSetHtml.soy");
    extractMailExample("Restored.soy");
    extractMailExample("RestoredHtml.soy");
    extractMailExample("Reverted.soy");
    extractMailExample("RevertedHtml.soy");
    extractMailExample("SetAssignee.soy");
    extractMailExample("SetAssigneeHtml.soy");
    if (!ui.isBatch()) {
        System.err.println();
    }
}
#end_block

#method_before
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithRebase() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertRebase(testRepo, false);
    RevCommit headAfterSecondSubmit = getRemoteHead();
    assertThat(headAfterSecondSubmit.getParent(0)).isEqualTo(headAfterFirstSubmit);
    assertApproved(change2.getChangeId());
    assertCurrentRevision(change2.getChangeId(), 2, headAfterSecondSubmit);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getCommitterIdent());
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit, headAfterFirstSubmit, headAfterSecondSubmit);
    assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name(), change2.getChangeId(), headAfterSecondSubmit.name());
}
#method_after
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithRebase() throws Exception {
    submitWithRebase(admin);
}
#end_block

#method_before
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithRebase() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertRebase(testRepo, false);
    RevCommit headAfterSecondSubmit = getRemoteHead();
    assertThat(headAfterSecondSubmit.getParent(0)).isEqualTo(headAfterFirstSubmit);
    assertApproved(change2.getChangeId());
    assertCurrentRevision(change2.getChangeId(), 2, headAfterSecondSubmit);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getCommitterIdent());
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit, headAfterFirstSubmit, headAfterSecondSubmit);
    assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name(), change2.getChangeId(), headAfterSecondSubmit.name());
}
#method_after
private void submitWithRebase(TestAccount submitter) throws Exception {
    setApiUser(submitter);
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertRebase(testRepo, false);
    RevCommit headAfterSecondSubmit = getRemoteHead();
    assertThat(headAfterSecondSubmit.getParent(0)).isEqualTo(headAfterFirstSubmit);
    assertApproved(change2.getChangeId(), submitter);
    assertCurrentRevision(change2.getChangeId(), 2, headAfterSecondSubmit);
    assertSubmitter(change2.getChangeId(), 1, submitter);
    assertSubmitter(change2.getChangeId(), 2, submitter);
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(submitter.getIdent(), headAfterSecondSubmit.getCommitterIdent());
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit, headAfterFirstSubmit, headAfterSecondSubmit);
    assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name(), change2.getChangeId(), headAfterSecondSubmit.name());
}
#end_block

#method_before
public final SiteIndexer<K, V, I> getSiteIndexer() {
    return siteIndexer;
}
#method_after
public final SiteIndexer<K, V, I> getSiteIndexer() {
    return siteIndexer.get();
}
#end_block

#method_before
static void configureHttpProxy() throws MalformedURLException {
    final String s = System.getenv("http_proxy");
    if (s == null || s.equals("")) {
        return;
    }
    final URL u = new URL((!s.contains("://")) ? "http://" + s : s);
    if (!"http".equals(u.getProtocol())) {
        throw new MalformedURLException("Invalid http_proxy: " + s + ": Only http supported.");
    }
    final String proxyHost = u.getHost();
    final int proxyPort = u.getPort();
    System.setProperty("http.proxyHost", proxyHost);
    if (proxyPort > 0) {
        System.setProperty("http.proxyPort", String.valueOf(proxyPort));
    }
    final String userpass = u.getUserInfo();
    if (userpass != null && userpass.contains(":")) {
        final int c = userpass.indexOf(':');
        final String user = userpass.substring(0, c);
        final String pass = userpass.substring(c + 1);
        CachedAuthenticator.add(new CachedAuthenticator.CachedAuthentication(proxyHost, proxyPort, user, pass));
    }
}
#method_after
static void configureHttpProxy() throws MalformedURLException {
    final String s = System.getenv("http_proxy");
    if (Strings.isNullOrEmpty(s)) {
        return;
    }
    final URL u = new URL((!s.contains("://")) ? "http://" + s : s);
    if (!"http".equals(u.getProtocol())) {
        throw new MalformedURLException("Invalid http_proxy: " + s + ": Only http supported.");
    }
    final String proxyHost = u.getHost();
    final int proxyPort = u.getPort();
    System.setProperty("http.proxyHost", proxyHost);
    if (proxyPort > 0) {
        System.setProperty("http.proxyPort", String.valueOf(proxyPort));
    }
    final String userpass = u.getUserInfo();
    if (userpass != null && userpass.contains(":")) {
        final int c = userpass.indexOf(':');
        final String user = userpass.substring(0, c);
        final String pass = userpass.substring(c + 1);
        CachedAuthenticator.add(new CachedAuthenticator.CachedAuthentication(proxyHost, proxyPort, user, pass));
    }
}
#end_block

#method_before
String getRemoteDisplayname(HttpServletRequest req) {
    if (displaynameHeader != null) {
        return emptyToNull(req.getHeader(displaynameHeader));
    }
    return null;
}
#method_after
String getRemoteDisplayname(HttpServletRequest req) {
    if (displaynameHeader != null) {
        String raw = req.getHeader(displaynameHeader);
        return emptyToNull(new String(raw.getBytes(ISO_8859_1), UTF_8));
    }
    return null;
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    return reviewersUtil.suggestReviewers(rsrc.getNotes(), this, rsrc.getControl().getProjectControl(), getVisibility(rsrc), excludeGroups);
}
#method_after
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws AuthException, BadRequestException, OrmException, IOException {
    if (!self.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    return reviewersUtil.suggestReviewers(rsrc.getNotes(), this, rsrc.getControl().getProjectControl(), getVisibility(rsrc), excludeGroups);
}
#end_block

#method_before
@Override
public String toString() {
    return name;
}
#method_after
@Override
public String toString() {
    if (fullName != null) {
        return fullName;
    }
    CurrentUser who = user.get();
    if (who.isIdentifiedUser()) {
        String username = who.asIdentifiedUser().getUserName();
        if (username != null && !username.isEmpty()) {
            fullName = name + " (" + username + ")";
            return fullName;
        }
    }
    return name;
}
#end_block

#method_before
private String generateName(HttpServletRequest req) {
    String userName = "";
    CurrentUser who = user.get();
    if (who.isIdentifiedUser()) {
        String name = who.asIdentifiedUser().getUserName();
        if (name != null && !name.isEmpty()) {
            userName = " (" + name + ")";
        }
    }
    String uri = req.getServletPath();
    Matcher m = URI_PATTERN.matcher(uri);
    if (m.matches()) {
        String path = m.group(1);
        String cmd = m.group(2);
        return cmd + " " + path + userName;
    }
    return req.getMethod() + " " + uri + userName;
}
#method_after
private String generateName(HttpServletRequest req) {
    String uri = req.getServletPath();
    Matcher m = URI_PATTERN.matcher(uri);
    if (m.matches()) {
        String path = m.group(1);
        String cmd = m.group(2);
        return cmd + " " + path;
    }
    return req.getMethod() + " " + uri;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private static Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    Class<?> clazz = Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return (Class<? extends Module>) clazz;
}
#method_after
@SuppressWarnings("unchecked")
protected static Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    Class<?> clazz = Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return (Class<? extends Module>) clazz;
}
#end_block

#method_before
private void startPlugin(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    serverManager = new LifecycleManager();
    serverManager.add(root);
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(getName(), env, scanner, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        serverManager.add(sysInjector);
    } else if (auto != null && auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        serverManager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (env.hasSshModule()) {
        List<Module> modules = new LinkedList<>();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getSshModule());
        }
        if (sshModule != null) {
            modules.add(sysInjector.getInstance(sshModule));
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        } else if (auto != null && auto.sshModule != null) {
            modules.add(auto.sshModule);
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        }
    }
    if (env.hasHttpModule()) {
        List<Module> modules = new LinkedList<>();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getHttpModule());
        }
        if (httpModule != null) {
            modules.add(sysInjector.getInstance(httpModule));
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        } else if (auto != null && auto.httpModule != null) {
            modules.add(auto.httpModule);
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        }
    }
    serverManager.start();
}
#method_after
private void startPlugin(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    serverManager = new LifecycleManager();
    serverManager.add(root);
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(getName(), env, scanner, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        serverManager.add(sysInjector);
    } else if (auto != null && auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        serverManager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (env.hasSshModule()) {
        List<Module> modules = new ArrayList<>();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getSshModule());
        }
        if (sshModule != null) {
            modules.add(sysInjector.getInstance(sshModule));
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        } else if (auto != null && auto.sshModule != null) {
            modules.add(auto.sshModule);
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        }
    }
    if (env.hasHttpModule()) {
        List<Module> modules = new ArrayList<>();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getHttpModule());
        }
        if (httpModule != null) {
            modules.add(sysInjector.getInstance(httpModule));
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        } else if (auto != null && auto.httpModule != null) {
            modules.add(auto.httpModule);
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        }
    }
    serverManager.start();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(GitRepositoryManager.class).to(MultiBaseLocalDiskRepositoryManager.class);
    bind(LocalDiskRepositoryManager.class).to(MultiBaseLocalDiskRepositoryManager.class);
    listener().to(MultiBaseLocalDiskRepositoryManager.class);
    listener().to(MultiBaseLocalDiskRepositoryManager.Lifecycle.class);
}
#method_after
@Override
protected void configure() {
    bind(GitRepositoryManager.class).to(MultiBaseLocalDiskRepositoryManager.class);
    listener().to(MultiBaseLocalDiskRepositoryManager.Lifecycle.class);
}
#end_block

#method_before
private String getMessage(ChangeNotes notes) throws NoSuchChangeException, OrmException, IOException {
    Change.Id changeId = notes.getChangeId();
    PatchSet ps = psUtil.current(db.get(), notes);
    if (ps == null) {
        throw new NoSuchChangeException(changeId);
    }
    try (Repository git = gitManager.openRepository(notes.getProjectName());
        RevWalk revWalk = new RevWalk(git)) {
        RevCommit commit = revWalk.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        return commit.getFullMessage();
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
}
#method_after
private String getMessage(ChangeNotes notes) throws OrmException, IOException {
    Change.Id changeId = notes.getChangeId();
    PatchSet ps = psUtil.current(db.get(), notes);
    if (ps == null) {
        throw new NoSuchChangeException(changeId);
    }
    try (Repository git = gitManager.openRepository(notes.getProjectName());
        RevWalk revWalk = new RevWalk(git)) {
        RevCommit commit = revWalk.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        return commit.getFullMessage();
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
}
#end_block

#method_before
private byte[] getMergeList(ChangeNotes notes) throws NoSuchChangeException, OrmException, IOException {
    Change.Id changeId = notes.getChangeId();
    PatchSet ps = psUtil.current(db.get(), notes);
    if (ps == null) {
        throw new NoSuchChangeException(changeId);
    }
    try (Repository git = gitManager.openRepository(notes.getProjectName());
        RevWalk revWalk = new RevWalk(git)) {
        return Text.forMergeList(ComparisonType.againstAutoMerge(), revWalk.getObjectReader(), ObjectId.fromString(ps.getRevision().get())).getContent();
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
}
#method_after
private byte[] getMergeList(ChangeNotes notes) throws OrmException, IOException {
    Change.Id changeId = notes.getChangeId();
    PatchSet ps = psUtil.current(db.get(), notes);
    if (ps == null) {
        throw new NoSuchChangeException(changeId);
    }
    try (Repository git = gitManager.openRepository(notes.getProjectName());
        RevWalk revWalk = new RevWalk(git)) {
        return Text.forMergeList(ComparisonType.againstAutoMerge(), revWalk.getObjectReader(), ObjectId.fromString(ps.getRevision().get())).getContent();
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
}
#end_block

#method_before
@Test
public void postSubmitApproval() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    String label = "Code-Review";
    ApprovalInfo approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Submit by direct push.
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Repeating the current label is allowed. Does not flip the postSubmit bit
    // due to deduplication codepath.
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Reducing vote is not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Increasing vote is allowed.
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
    // Decreasing to previous post-submit vote is still not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
}
#method_after
@Test
public void postSubmitApproval() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    String label = "Code-Review";
    ApprovalInfo approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Submit by direct push.
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    assertPermitted(gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS)), "Code-Review", 1, 2);
    // Repeating the current label is allowed. Does not flip the postSubmit bit
    // due to deduplication codepath.
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Reducing vote is not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Increasing vote is allowed.
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
    assertPermitted(gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS)), "Code-Review", 2);
    // Decreasing to previous post-submit vote is still not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
}
#end_block

#method_before
@Test
public void actions() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(current(r).actions().keySet()).containsExactly("cherrypick", "rebase");
    current(r).review(ReviewInput.approve());
    assertThat(current(r).actions().keySet()).containsExactly("submit", "cherrypick", "rebase");
    current(r).submit();
    assertThat(current(r).actions().keySet()).containsExactly("cherrypick");
}
#method_after
@Test
public void actions() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(current(r).actions().keySet()).containsExactly("cherrypick", "description", "rebase");
    current(r).review(ReviewInput.approve());
    assertThat(current(r).actions().keySet()).containsExactly("submit", "cherrypick", "description", "rebase");
    current(r).submit();
    assertThat(current(r).actions().keySet()).containsExactly("cherrypick");
}
#end_block

#method_before
private ApprovalInfo getApproval(String changeId, String label) throws Exception {
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo li = info.labels.get(label);
    assertThat(li).isNotNull();
    int accountId = atrScope.get().getUser().getAccountId().get();
    return li.all.stream().filter(a -> a._accountId == accountId).findFirst().get();
}
#method_after
private ApprovalInfo getApproval(String changeId, String label) throws Exception {
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS));
    LabelInfo li = info.labels.get(label);
    assertThat(li).isNotNull();
    int accountId = atrScope.get().getUser().getAccountId().get();
    return li.all.stream().filter(a -> a._accountId == accountId).findFirst().get();
}
#end_block

#method_before
@Test
public void revisionActionsOneChangePerTopicUnapproved() throws Exception {
    String changeId = createChangeWithTopic().getChangeId();
    Map<String, ActionInfo> actions = getActions(changeId);
    assertThat(actions).containsKey("cherrypick");
    assertThat(actions).containsKey("rebase");
    assertThat(actions).hasSize(2);
}
#method_after
@Test
public void revisionActionsOneChangePerTopicUnapproved() throws Exception {
    String changeId = createChangeWithTopic().getChangeId();
    Map<String, ActionInfo> actions = getActions(changeId);
    assertThat(actions).hasSize(3);
    assertThat(actions).containsKey("cherrypick");
    assertThat(actions).containsKey("rebase");
    assertThat(actions).containsKey("description");
}
#end_block

#method_before
@Test
public void revisionActionsETag() throws Exception {
    String parent = createChange().getChangeId();
    String change = createChangeWithTopic().getChangeId();
    approve(change);
    String etag1 = getRevisionActions.getETag(parseCurrentRevisionResource(change));
    approve(parent);
    String etag2 = getRevisionActions.getETag(parseCurrentRevisionResource(change));
    String changeWithSameTopic = createChangeWithTopic().getChangeId();
    String etag3 = getRevisionActions.getETag(parseCurrentRevisionResource(change));
    approve(changeWithSameTopic);
    String etag4 = getRevisionActions.getETag(parseCurrentRevisionResource(change));
    if (isSubmitWholeTopicEnabled()) {
        assertThat(ImmutableList.of(etag1, etag2, etag3, etag4)).containsNoDuplicates();
    } else {
        assertThat(etag2).isNotEqualTo(etag1);
        assertThat(etag3).isEqualTo(etag2);
        assertThat(etag4).isEqualTo(etag2);
    }
}
#method_after
@Test
public void revisionActionsETag() throws Exception {
    String parent = createChange().getChangeId();
    String change = createChangeWithTopic().getChangeId();
    approve(change);
    String etag1 = getETag(change);
    approve(parent);
    String etag2 = getETag(change);
    String changeWithSameTopic = createChangeWithTopic().getChangeId();
    String etag3 = getETag(change);
    approve(changeWithSameTopic);
    String etag4 = getETag(change);
    if (isSubmitWholeTopicEnabled()) {
        assertThat(ImmutableList.of(etag1, etag2, etag3, etag4)).containsNoDuplicates();
    } else {
        assertThat(etag2).isNotEqualTo(etag1);
        assertThat(etag3).isEqualTo(etag2);
        assertThat(etag4).isEqualTo(etag2);
    }
}
#end_block

#method_before
@Test
public void revisionActionsETagWithHiddenDraftInTopic() throws Exception {
    String change = createChangeWithTopic().getChangeId();
    approve(change);
    setApiUser(user);
    String etag1 = getRevisionActions.getETag(parseCurrentRevisionResource(change));
    setApiUser(admin);
    String draft = createDraftWithTopic().getChangeId();
    approve(draft);
    setApiUser(user);
    String etag2 = getRevisionActions.getETag(parseCurrentRevisionResource(change));
    if (isSubmitWholeTopicEnabled()) {
        assertThat(etag2).isNotEqualTo(etag1);
    } else {
        assertThat(etag2).isEqualTo(etag1);
    }
}
#method_after
@Test
public void revisionActionsETagWithHiddenDraftInTopic() throws Exception {
    String change = createChangeWithTopic().getChangeId();
    approve(change);
    setApiUser(user);
    String etag1 = getETag(change);
    setApiUser(admin);
    String draft = createDraftWithTopic().getChangeId();
    approve(draft);
    setApiUser(user);
    String etag2 = getETag(change);
    if (isSubmitWholeTopicEnabled()) {
        assertThat(etag2).isNotEqualTo(etag1);
    } else {
        assertThat(etag2).isEqualTo(etag1);
    }
}
#end_block

#method_before
@Test
public void revisionActionsAnonymousETag() throws Exception {
    String parent = createChange().getChangeId();
    String change = createChangeWithTopic().getChangeId();
    approve(change);
    setApiUserAnonymous();
    String etag1 = getRevisionActions.getETag(parseCurrentRevisionResource(change));
    setApiUser(admin);
    approve(parent);
    setApiUserAnonymous();
    String etag2 = getRevisionActions.getETag(parseCurrentRevisionResource(change));
    setApiUser(admin);
    String changeWithSameTopic = createChangeWithTopic().getChangeId();
    setApiUserAnonymous();
    String etag3 = getRevisionActions.getETag(parseCurrentRevisionResource(change));
    setApiUser(admin);
    approve(changeWithSameTopic);
    setApiUserAnonymous();
    String etag4 = getRevisionActions.getETag(parseCurrentRevisionResource(change));
    if (isSubmitWholeTopicEnabled()) {
        assertThat(ImmutableList.of(etag1, etag2, etag3, etag4)).containsNoDuplicates();
    } else {
        assertThat(etag2).isNotEqualTo(etag1);
        assertThat(etag3).isEqualTo(etag2);
        assertThat(etag4).isEqualTo(etag2);
    }
}
#method_after
@Test
public void revisionActionsAnonymousETag() throws Exception {
    String parent = createChange().getChangeId();
    String change = createChangeWithTopic().getChangeId();
    approve(change);
    setApiUserAnonymous();
    String etag1 = getETag(change);
    setApiUser(admin);
    approve(parent);
    setApiUserAnonymous();
    String etag2 = getETag(change);
    setApiUser(admin);
    String changeWithSameTopic = createChangeWithTopic().getChangeId();
    setApiUserAnonymous();
    String etag3 = getETag(change);
    setApiUser(admin);
    approve(changeWithSameTopic);
    setApiUserAnonymous();
    String etag4 = getETag(change);
    if (isSubmitWholeTopicEnabled()) {
        assertThat(ImmutableList.of(etag1, etag2, etag3, etag4)).containsNoDuplicates();
    } else {
        assertThat(etag2).isNotEqualTo(etag1);
        assertThat(etag3).isEqualTo(etag2);
        assertThat(etag4).isEqualTo(etag2);
    }
}
#end_block

#method_before
@Test
@TestProjectInput(submitType = SubmitType.CHERRY_PICK)
public void revisionActionsAnonymousETagCherryPickStrategy() throws Exception {
    String parent = createChange().getChangeId();
    String change = createChange().getChangeId();
    approve(change);
    setApiUserAnonymous();
    String etag1 = getRevisionActions.getETag(parseCurrentRevisionResource(change));
    setApiUser(admin);
    approve(parent);
    setApiUserAnonymous();
    String etag2 = getRevisionActions.getETag(parseCurrentRevisionResource(change));
    assertThat(etag2).isEqualTo(etag1);
}
#method_after
@Test
@TestProjectInput(submitType = SubmitType.CHERRY_PICK)
public void revisionActionsAnonymousETagCherryPickStrategy() throws Exception {
    String parent = createChange().getChangeId();
    String change = createChange().getChangeId();
    approve(change);
    setApiUserAnonymous();
    String etag1 = getETag(change);
    setApiUser(admin);
    approve(parent);
    setApiUserAnonymous();
    String etag2 = getETag(change);
    assertThat(etag2).isEqualTo(etag1);
}
#end_block

#method_before
private void commonActionsAssertions(Map<String, ActionInfo> actions) {
    assertThat(actions).hasSize(3);
    assertThat(actions).containsKey("cherrypick");
    assertThat(actions).containsKey("submit");
    assertThat(actions).containsKey("rebase");
}
#method_after
private void commonActionsAssertions(Map<String, ActionInfo> actions) {
    assertThat(actions).hasSize(4);
    assertThat(actions).containsKey("cherrypick");
    assertThat(actions).containsKey("submit");
    assertThat(actions).containsKey("description");
    assertThat(actions).containsKey("rebase");
}
#end_block

#method_before
private List<AccessSection> getAccessSections(Map<String, AccessSectionInfo> sectionInfos) throws UnprocessableEntityException {
    List<AccessSection> sections = new LinkedList<>();
    if (sectionInfos == null) {
        return sections;
    }
    for (Map.Entry<String, AccessSectionInfo> entry : sectionInfos.entrySet()) {
        AccessSection accessSection = new AccessSection(entry.getKey());
        if (entry.getValue().permissions == null) {
            continue;
        }
        for (Map.Entry<String, PermissionInfo> permissionEntry : entry.getValue().permissions.entrySet()) {
            Permission p = new Permission(permissionEntry.getKey());
            if (permissionEntry.getValue().exclusive != null) {
                p.setExclusiveGroup(permissionEntry.getValue().exclusive);
            }
            if (permissionEntry.getValue().rules == null) {
                continue;
            }
            for (Map.Entry<String, PermissionRuleInfo> permissionRuleInfoEntry : permissionEntry.getValue().rules.entrySet()) {
                PermissionRuleInfo pri = permissionRuleInfoEntry.getValue();
                GroupDescription.Basic group = groupsCollection.parseId(permissionRuleInfoEntry.getKey());
                if (group == null) {
                    throw new UnprocessableEntityException(permissionRuleInfoEntry.getKey() + " is not a valid group ID");
                }
                PermissionRule r = new PermissionRule(GroupReference.forGroup(group));
                if (pri != null) {
                    if (pri.max != null) {
                        r.setMax(pri.max);
                    }
                    if (pri.min != null) {
                        r.setMin(pri.min);
                    }
                    r.setAction(GetAccess.ACTION_TYPE.inverse().get(pri.action));
                    if (pri.force != null) {
                        r.setForce(pri.force);
                    }
                }
                p.add(r);
            }
            accessSection.getPermissions().add(p);
        }
        sections.add(accessSection);
    }
    return sections;
}
#method_after
private List<AccessSection> getAccessSections(Map<String, AccessSectionInfo> sectionInfos) throws UnprocessableEntityException {
    if (sectionInfos == null) {
        return Collections.emptyList();
    }
    List<AccessSection> sections = new ArrayList<>(sectionInfos.size());
    for (Map.Entry<String, AccessSectionInfo> entry : sectionInfos.entrySet()) {
        AccessSection accessSection = new AccessSection(entry.getKey());
        if (entry.getValue().permissions == null) {
            continue;
        }
        for (Map.Entry<String, PermissionInfo> permissionEntry : entry.getValue().permissions.entrySet()) {
            Permission p = new Permission(permissionEntry.getKey());
            if (permissionEntry.getValue().exclusive != null) {
                p.setExclusiveGroup(permissionEntry.getValue().exclusive);
            }
            if (permissionEntry.getValue().rules == null) {
                continue;
            }
            for (Map.Entry<String, PermissionRuleInfo> permissionRuleInfoEntry : permissionEntry.getValue().rules.entrySet()) {
                PermissionRuleInfo pri = permissionRuleInfoEntry.getValue();
                GroupDescription.Basic group = groupsCollection.parseId(permissionRuleInfoEntry.getKey());
                if (group == null) {
                    throw new UnprocessableEntityException(permissionRuleInfoEntry.getKey() + " is not a valid group ID");
                }
                PermissionRule r = new PermissionRule(GroupReference.forGroup(group));
                if (pri != null) {
                    if (pri.max != null) {
                        r.setMax(pri.max);
                    }
                    if (pri.min != null) {
                        r.setMin(pri.min);
                    }
                    r.setAction(GetAccess.ACTION_TYPE.inverse().get(pri.action));
                    if (pri.force != null) {
                        r.setForce(pri.force);
                    }
                }
                p.add(r);
            }
            accessSection.getPermissions().add(p);
        }
        sections.add(accessSection);
    }
    return sections;
}
#end_block

#method_before
@Test
public void commitWhoseParentIsUninterestingGetsNewGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    Multimap<ObjectId, String> groups = collectGroups(newWalk(a, branchTip), patchSets(), groups());
    assertThat(groups).containsEntry(a, a.name());
}
#method_after
@Test
public void commitWhoseParentIsUninterestingGetsNewGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    SortedSetMultimap<ObjectId, String> groups = collectGroups(newWalk(a, branchTip), patchSets(), groups());
    assertThat(groups).containsEntry(a, a.name());
}
#end_block

#method_before
@Test
public void commitWhoseParentIsNewPatchSetGetsParentsGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(a).create();
    Multimap<ObjectId, String> groups = collectGroups(newWalk(b, branchTip), patchSets(), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(b, a.name());
}
#method_after
@Test
public void commitWhoseParentIsNewPatchSetGetsParentsGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(a).create();
    SortedSetMultimap<ObjectId, String> groups = collectGroups(newWalk(b, branchTip), patchSets(), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(b, a.name());
}
#end_block

#method_before
@Test
public void commitWhoseParentIsExistingPatchSetGetsParentsGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(a).create();
    String group = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    Multimap<ObjectId, String> groups = collectGroups(newWalk(b, branchTip), patchSets().put(a, psId(1, 1)), groups().put(psId(1, 1), group));
    assertThat(groups).containsEntry(a, group);
    assertThat(groups).containsEntry(b, group);
}
#method_after
@Test
public void commitWhoseParentIsExistingPatchSetGetsParentsGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(a).create();
    String group = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    SortedSetMultimap<ObjectId, String> groups = collectGroups(newWalk(b, branchTip), patchSets().put(a, psId(1, 1)), groups().put(psId(1, 1), group));
    assertThat(groups).containsEntry(a, group);
    assertThat(groups).containsEntry(b, group);
}
#end_block

#method_before
@Test
public void commitWhoseParentIsExistingPatchSetWithNoGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(a).create();
    Multimap<ObjectId, String> groups = collectGroups(newWalk(b, branchTip), patchSets().put(a, psId(1, 1)), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(b, a.name());
}
#method_after
@Test
public void commitWhoseParentIsExistingPatchSetWithNoGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(a).create();
    SortedSetMultimap<ObjectId, String> groups = collectGroups(newWalk(b, branchTip), patchSets().put(a, psId(1, 1)), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(b, a.name());
}
#end_block

#method_before
@Test
public void mergeCommitAndNewParentsAllGetSameGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(a).parent(b).create();
    Multimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets(), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(b, a.name());
    assertThat(groups).containsEntry(m, a.name());
}
#method_after
@Test
public void mergeCommitAndNewParentsAllGetSameGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(a).parent(b).create();
    SortedSetMultimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets(), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(b, a.name());
    assertThat(groups).containsEntry(m, a.name());
}
#end_block

#method_before
@Test
public void mergeCommitWhereOneParentHasExistingGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(a).parent(b).create();
    String group = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    Multimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets().put(b, psId(1, 1)), groups().put(psId(1, 1), group));
    // Merge commit and other parent get the existing group.
    assertThat(groups).containsEntry(a, group);
    assertThat(groups).containsEntry(b, group);
    assertThat(groups).containsEntry(m, group);
}
#method_after
@Test
public void mergeCommitWhereOneParentHasExistingGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(a).parent(b).create();
    String group = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    SortedSetMultimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets().put(b, psId(1, 1)), groups().put(psId(1, 1), group));
    // Merge commit and other parent get the existing group.
    assertThat(groups).containsEntry(a, group);
    assertThat(groups).containsEntry(b, group);
    assertThat(groups).containsEntry(m, group);
}
#end_block

#method_before
@Test
public void mergeCommitWhereBothParentsHaveDifferentGroups() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(a).parent(b).create();
    String group1 = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    String group2 = "1234567812345678123456781234567812345678";
    Multimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets().put(a, psId(1, 1)).put(b, psId(2, 1)), groups().put(psId(1, 1), group1).put(psId(2, 1), group2));
    assertThat(groups).containsEntry(a, group1);
    assertThat(groups).containsEntry(b, group2);
    // Merge commit gets joined group of parents.
    assertThat(groups.asMap()).containsEntry(m, ImmutableSet.of(group1, group2));
}
#method_after
@Test
public void mergeCommitWhereBothParentsHaveDifferentGroups() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(a).parent(b).create();
    String group1 = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    String group2 = "1234567812345678123456781234567812345678";
    SortedSetMultimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets().put(a, psId(1, 1)).put(b, psId(2, 1)), groups().put(psId(1, 1), group1).put(psId(2, 1), group2));
    assertThat(groups).containsEntry(a, group1);
    assertThat(groups).containsEntry(b, group2);
    // Merge commit gets joined group of parents.
    assertThat(groups.asMap()).containsEntry(m, ImmutableSet.of(group1, group2));
}
#end_block

#method_before
@Test
public void mergeCommitMergesGroupsFromParent() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(a).parent(b).create();
    String group1 = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    String group2a = "1234567812345678123456781234567812345678";
    String group2b = "ef123456ef123456ef123456ef123456ef123456";
    Multimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets().put(a, psId(1, 1)).put(b, psId(2, 1)), groups().put(psId(1, 1), group1).put(psId(2, 1), group2a).put(psId(2, 1), group2b));
    assertThat(groups).containsEntry(a, group1);
    assertThat(groups.asMap()).containsEntry(b, ImmutableSet.of(group2a, group2b));
    // Joined parent groups are split and resorted.
    assertThat(groups.asMap()).containsEntry(m, ImmutableSet.of(group1, group2a, group2b));
}
#method_after
@Test
public void mergeCommitMergesGroupsFromParent() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(a).parent(b).create();
    String group1 = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    String group2a = "1234567812345678123456781234567812345678";
    String group2b = "ef123456ef123456ef123456ef123456ef123456";
    SortedSetMultimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets().put(a, psId(1, 1)).put(b, psId(2, 1)), groups().put(psId(1, 1), group1).put(psId(2, 1), group2a).put(psId(2, 1), group2b));
    assertThat(groups).containsEntry(a, group1);
    assertThat(groups.asMap()).containsEntry(b, ImmutableSet.of(group2a, group2b));
    // Joined parent groups are split and resorted.
    assertThat(groups.asMap()).containsEntry(m, ImmutableSet.of(group1, group2a, group2b));
}
#end_block

#method_before
@Test
public void mergeCommitWithOneUninterestingParentAndOtherParentIsExisting() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(branchTip).parent(a).create();
    String group = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    Multimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets().put(a, psId(1, 1)), groups().put(psId(1, 1), group));
    assertThat(groups).containsEntry(a, group);
    assertThat(groups).containsEntry(m, group);
}
#method_after
@Test
public void mergeCommitWithOneUninterestingParentAndOtherParentIsExisting() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(branchTip).parent(a).create();
    String group = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    SortedSetMultimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets().put(a, psId(1, 1)), groups().put(psId(1, 1), group));
    assertThat(groups).containsEntry(a, group);
    assertThat(groups).containsEntry(m, group);
}
#end_block

#method_before
@Test
public void mergeCommitWithOneUninterestingParentAndOtherParentIsNew() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(branchTip).parent(a).create();
    Multimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets(), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(m, a.name());
}
#method_after
@Test
public void mergeCommitWithOneUninterestingParentAndOtherParentIsNew() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(branchTip).parent(a).create();
    SortedSetMultimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets(), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(m, a.name());
}
#end_block

#method_before
@Test
public void multipleMergeCommitsInHistoryAllResolveToSameGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(branchTip).create();
    RevCommit c = tr.commit().parent(branchTip).create();
    RevCommit m1 = tr.commit().parent(b).parent(c).create();
    RevCommit m2 = tr.commit().parent(a).parent(m1).create();
    Multimap<ObjectId, String> groups = collectGroups(newWalk(m2, branchTip), patchSets(), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(b, a.name());
    assertThat(groups).containsEntry(c, a.name());
    assertThat(groups).containsEntry(m1, a.name());
    assertThat(groups).containsEntry(m2, a.name());
}
#method_after
@Test
public void multipleMergeCommitsInHistoryAllResolveToSameGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(branchTip).create();
    RevCommit c = tr.commit().parent(branchTip).create();
    RevCommit m1 = tr.commit().parent(b).parent(c).create();
    RevCommit m2 = tr.commit().parent(a).parent(m1).create();
    SortedSetMultimap<ObjectId, String> groups = collectGroups(newWalk(m2, branchTip), patchSets(), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(b, a.name());
    assertThat(groups).containsEntry(c, a.name());
    assertThat(groups).containsEntry(m1, a.name());
    assertThat(groups).containsEntry(m2, a.name());
}
#end_block

#method_before
@Test
public void mergeCommitWithDuplicatedParentGetsParentsGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(a).parent(a).create();
    tr.getRevWalk().parseBody(m);
    assertThat(m.getParentCount()).isEqualTo(2);
    assertThat(m.getParent(0)).isEqualTo(m.getParent(1));
    Multimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets(), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(m, a.name());
}
#method_after
@Test
public void mergeCommitWithDuplicatedParentGetsParentsGroup() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit m = tr.commit().parent(a).parent(a).create();
    tr.getRevWalk().parseBody(m);
    assertThat(m.getParentCount()).isEqualTo(2);
    assertThat(m.getParent(0)).isEqualTo(m.getParent(1));
    SortedSetMultimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets(), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(m, a.name());
}
#end_block

#method_before
@Test
public void mergeCommitWithOneNewParentAndTwoExistingPatchSets() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(branchTip).create();
    RevCommit c = tr.commit().parent(b).create();
    RevCommit m = tr.commit().parent(a).parent(c).create();
    String group1 = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    String group2 = "1234567812345678123456781234567812345678";
    Multimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets().put(a, psId(1, 1)).put(b, psId(2, 1)), groups().put(psId(1, 1), group1).put(psId(2, 1), group2));
    assertThat(groups).containsEntry(a, group1);
    assertThat(groups).containsEntry(b, group2);
    assertThat(groups).containsEntry(c, group2);
    assertThat(groups.asMap()).containsEntry(m, ImmutableSet.of(group1, group2));
}
#method_after
@Test
public void mergeCommitWithOneNewParentAndTwoExistingPatchSets() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(branchTip).create();
    RevCommit c = tr.commit().parent(b).create();
    RevCommit m = tr.commit().parent(a).parent(c).create();
    String group1 = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    String group2 = "1234567812345678123456781234567812345678";
    SortedSetMultimap<ObjectId, String> groups = collectGroups(newWalk(m, branchTip), patchSets().put(a, psId(1, 1)).put(b, psId(2, 1)), groups().put(psId(1, 1), group1).put(psId(2, 1), group2));
    assertThat(groups).containsEntry(a, group1);
    assertThat(groups).containsEntry(b, group2);
    assertThat(groups).containsEntry(c, group2);
    assertThat(groups.asMap()).containsEntry(m, ImmutableSet.of(group1, group2));
}
#end_block

#method_before
@Test
public void collectGroupsForMultipleTipsInParallel() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(a).create();
    RevCommit c = tr.commit().parent(branchTip).create();
    RevCommit d = tr.commit().parent(c).create();
    RevWalk rw = newWalk(b, branchTip);
    rw.markStart(rw.parseCommit(d));
    // Schema upgrade case: all commits are existing patch sets, but none have
    // groups assigned yet.
    Multimap<ObjectId, String> groups = collectGroups(rw, patchSets().put(branchTip, psId(1, 1)).put(a, psId(2, 1)).put(b, psId(3, 1)).put(c, psId(4, 1)).put(d, psId(5, 1)), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(b, a.name());
    assertThat(groups).containsEntry(c, c.name());
    assertThat(groups).containsEntry(d, c.name());
}
#method_after
@Test
public void collectGroupsForMultipleTipsInParallel() throws Exception {
    RevCommit branchTip = tr.commit().create();
    RevCommit a = tr.commit().parent(branchTip).create();
    RevCommit b = tr.commit().parent(a).create();
    RevCommit c = tr.commit().parent(branchTip).create();
    RevCommit d = tr.commit().parent(c).create();
    RevWalk rw = newWalk(b, branchTip);
    rw.markStart(rw.parseCommit(d));
    // Schema upgrade case: all commits are existing patch sets, but none have
    // groups assigned yet.
    SortedSetMultimap<ObjectId, String> groups = collectGroups(rw, patchSets().put(branchTip, psId(1, 1)).put(a, psId(2, 1)).put(b, psId(3, 1)).put(c, psId(4, 1)).put(d, psId(5, 1)), groups());
    assertThat(groups).containsEntry(a, a.name());
    assertThat(groups).containsEntry(b, a.name());
    assertThat(groups).containsEntry(c, c.name());
    assertThat(groups).containsEntry(d, c.name());
}
#end_block

#method_before
private static Multimap<ObjectId, String> collectGroups(RevWalk rw, ImmutableMultimap.Builder<ObjectId, PatchSet.Id> patchSetsBySha, ImmutableListMultimap.Builder<PatchSet.Id, String> groupLookup) throws Exception {
    GroupCollector gc = new GroupCollector(patchSetsBySha.build(), groupLookup.build());
    RevCommit c;
    while ((c = rw.next()) != null) {
        gc.visit(c);
    }
    return gc.getGroups();
}
#method_after
private static SortedSetMultimap<ObjectId, String> collectGroups(RevWalk rw, ImmutableListMultimap.Builder<ObjectId, PatchSet.Id> patchSetsBySha, ImmutableListMultimap.Builder<PatchSet.Id, String> groupLookup) throws Exception {
    GroupCollector gc = new GroupCollector(patchSetsBySha.build(), groupLookup.build());
    RevCommit c;
    while ((c = rw.next()) != null) {
        gc.visit(c);
    }
    return gc.getGroups();
}
#end_block

#method_before
// Helper methods for constructing various map arguments, to avoid lots of
private static ImmutableMultimap.Builder<ObjectId, PatchSet.Id> patchSets() {
    return ImmutableMultimap.builder();
}
#method_after
// Helper methods for constructing various map arguments, to avoid lots of
private static ImmutableListMultimap.Builder<ObjectId, PatchSet.Id> patchSets() {
    return ImmutableListMultimap.builder();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(admin.getIdent(), changeId);
    change = getChange(changeId);
    assertThat(ps).isNotNull();
    changeId2 = newChange2(admin.getIdent());
    change2 = getChange(changeId2);
    assertThat(change2).isNotNull();
    ps2 = getCurrentPatchSet(changeId2);
    assertThat(ps2).isNotNull();
}
#method_after
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    assertThat(ps).isNotNull();
    amendChange(admin.getIdent(), changeId);
    changeId2 = newChange2(admin.getIdent());
}
#end_block

#method_before
@Test
public void parseEditRevision() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    // check that '0' is parsed as edit revision
    gApi.changes().id(change.getChangeId()).revision(0).comments();
    // check that 'edit' is parsed as edit revision
    gApi.changes().id(change.getChangeId()).revision("edit").comments();
}
#method_after
@Test
public void parseEditRevision() throws Exception {
    createArbitraryEditFor(changeId);
    // check that '0' is parsed as edit revision
    gApi.changes().id(changeId).revision(0).comments();
    // check that 'edit' is parsed as edit revision
    gApi.changes().id(changeId).revision("edit").comments();
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.publish(editUtil.byChange(change).get(), NotifyHandling.NONE);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
}
#method_after
@Test
public void publishEdit() throws Exception {
    createArbitraryEditFor(changeId);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    assertThat(getEdit(changeId)).isAbsent();
    assertChangeMessages(changeId, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
}
#end_block

#method_before
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(modifier.createEdit(change, oldCurrentPatchSet)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    adminRestSession.post(urlPublish()).assertNoContent();
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(newCurrentPatchSet.getId()).isNotEqualTo(oldCurrentPatchSet.getId());
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
}
#method_after
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    createArbitraryEditFor(changeId);
    adminRestSession.post(urlPublish(changeId)).assertNoContent();
    assertThat(getEdit(changeId)).isAbsent();
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(newCurrentPatchSet.getId()).isNotEqualTo(oldCurrentPatchSet.getId());
    assertChangeMessages(changeId, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
}
#end_block

#method_before
@Test
public void publishEditNotifyRest() throws Exception {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(change.getChangeId()).addReviewer(in);
    modifier.createEdit(change, getCurrentPatchSet(changeId));
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    sender.clear();
    PublishChangeEditInput input = new PublishChangeEditInput();
    input.notify = NotifyHandling.NONE;
    adminRestSession.post(urlPublish(), input).assertNoContent();
    assertThat(sender.getMessages()).hasSize(0);
}
#method_after
@Test
public void publishEditNotifyRest() throws Exception {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(changeId).addReviewer(in);
    createArbitraryEditFor(changeId);
    sender.clear();
    PublishChangeEditInput input = new PublishChangeEditInput();
    input.notify = NotifyHandling.NONE;
    adminRestSession.post(urlPublish(changeId), input).assertNoContent();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void deleteEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    adminRestSession.delete(urlEdit()).assertNoContent();
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
}
#method_after
@Test
public void deleteEditRest() throws Exception {
    createArbitraryEditFor(changeId);
    adminRestSession.delete(urlEdit(changeId)).assertNoContent();
    assertThat(getEdit(changeId)).isAbsent();
}
#end_block

#method_before
@Test
public void publishEditRestWithoutCLA() throws Exception {
    setUseContributorAgreements(InheritableBoolean.TRUE);
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(modifier.createEdit(change, oldCurrentPatchSet)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    adminRestSession.post(urlPublish()).assertForbidden();
    setUseContributorAgreements(InheritableBoolean.FALSE);
    adminRestSession.post(urlPublish()).assertNoContent();
}
#method_after
@Test
public void publishEditRestWithoutCLA() throws Exception {
    createArbitraryEditFor(changeId);
    setUseContributorAgreements(InheritableBoolean.TRUE);
    adminRestSession.post(urlPublish(changeId)).assertForbidden();
    setUseContributorAgreements(InheritableBoolean.FALSE);
    adminRestSession.post(urlPublish(changeId)).assertNoContent();
}
#end_block

#method_before
@Test
public void rebaseEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    modifier.rebaseEdit(edit, current);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(beforeRebase.equals(afterRebase)).isFalse();
}
#method_after
@Test
public void rebaseEdit() throws Exception {
    PatchSet previousPatchSet = getCurrentPatchSet(changeId2);
    createEmptyEditFor(changeId2);
    gApi.changes().id(changeId2).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW));
    amendChange(admin.getIdent(), changeId2);
    PatchSet currentPatchSet = getCurrentPatchSet(changeId2);
    Optional<EditInfo> originalEdit = getEdit(changeId2);
    assertThat(originalEdit).value().baseRevision().isEqualTo(previousPatchSet.getRevision().get());
    Timestamp beforeRebase = originalEdit.get().commit.committer.date;
    gApi.changes().id(changeId2).edit().rebase();
    ensureSameBytes(getFileContentOfEdit(changeId2, FILE_NAME), CONTENT_NEW);
    ensureSameBytes(getFileContentOfEdit(changeId2, FILE_NAME2), CONTENT_NEW2);
    Optional<EditInfo> rebasedEdit = getEdit(changeId2);
    assertThat(rebasedEdit).value().baseRevision().isEqualTo(currentPatchSet.getRevision().get());
    assertThat(rebasedEdit).value().commit().committer().creationDate().isNotEqualTo(beforeRebase);
}
#end_block

#method_before
@Test
public void rebaseEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    adminRestSession.post(urlRebase()).assertNoContent();
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(afterRebase).isNotEqualTo(beforeRebase);
}
#method_after
@Test
public void rebaseEditRest() throws Exception {
    PatchSet previousPatchSet = getCurrentPatchSet(changeId2);
    createEmptyEditFor(changeId2);
    gApi.changes().id(changeId2).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW));
    amendChange(admin.getIdent(), changeId2);
    PatchSet currentPatchSet = getCurrentPatchSet(changeId2);
    Optional<EditInfo> originalEdit = getEdit(changeId2);
    assertThat(originalEdit).value().baseRevision().isEqualTo(previousPatchSet.getRevision().get());
    Timestamp beforeRebase = originalEdit.get().commit.committer.date;
    adminRestSession.post(urlRebase(changeId2)).assertNoContent();
    ensureSameBytes(getFileContentOfEdit(changeId2, FILE_NAME), CONTENT_NEW);
    ensureSameBytes(getFileContentOfEdit(changeId2, FILE_NAME2), CONTENT_NEW2);
    Optional<EditInfo> rebasedEdit = getEdit(changeId2);
    assertThat(rebasedEdit).value().baseRevision().isEqualTo(currentPatchSet.getRevision().get());
    assertThat(rebasedEdit).value().commit().committer().creationDate().isNotEqualTo(beforeRebase);
}
#end_block

#method_before
@Test
public void rebaseEditWithConflictsRest_Conflict() throws Exception {
    PatchSet current = getCurrentPatchSet(changeId2);
    assertThat(modifier.createEdit(change2, current)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change2).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change2).get();
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, FILE_NAME, new String(CONTENT_NEW2), changeId2);
    push.to("refs/for/master").assertOkStatus();
    adminRestSession.post(urlRebase()).assertConflict();
}
#method_after
@Test
public void rebaseEditWithConflictsRest_Conflict() throws Exception {
    PatchSet currentPatchSet = getCurrentPatchSet(changeId2);
    createEmptyEditFor(changeId2);
    gApi.changes().id(changeId2).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW));
    Optional<EditInfo> edit = getEdit(changeId2);
    assertThat(edit).value().baseRevision().isEqualTo(currentPatchSet.getRevision().get());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, FILE_NAME, new String(CONTENT_NEW2, UTF_8), changeId2);
    push.to("refs/for/master").assertOkStatus();
    adminRestSession.post(urlRebase(changeId2)).assertConflict();
}
#end_block

#method_before
@Test
public void updateExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW);
    editUtil.delete(edit.get());
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
}
#method_after
@Test
public void updateExistingFile() throws Exception {
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW));
    assertThat(getEdit(changeId)).isPresent();
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME), CONTENT_NEW);
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME), CONTENT_NEW);
}
#end_block

#method_before
@Test
@TestProjectInput(createEmptyCommit = false)
public void updateRootCommitMessage() throws Exception {
    // Re-clone empty repo; TestRepository doesn't let us reset to unborn head.
    testRepo = cloneProject(project);
    changeId = newChange(admin.getIdent());
    change = getChange(changeId);
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getParentCount()).isEqualTo(0);
    String msg = String.format("New commit message\n\nChange-Id: %s\n", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
}
#method_after
@Test
@TestProjectInput(createEmptyCommit = false)
public void updateRootCommitMessage() throws Exception {
    // Re-clone empty repo; TestRepository doesn't let us reset to unborn head.
    testRepo = cloneProject(project);
    changeId = newChange(admin.getIdent());
    createEmptyEditFor(changeId);
    Optional<EditInfo> edit = getEdit(changeId);
    assertThat(edit).value().commit().parents().isEmpty();
    String msg = String.format("New commit message\n\nChange-Id: %s\n", changeId);
    gApi.changes().id(changeId).edit().modifyCommitMessage(msg);
    String commitMessage = gApi.changes().id(changeId).edit().getCommitMessage();
    assertThat(commitMessage).isEqualTo(msg);
}
#end_block

#method_before
@Test
public void updateMessageNoChange() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    exception.expect(UnchangedCommitMessageException.class);
    exception.expectMessage("New commit message cannot be same as existing commit message");
    modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
}
#method_after
@Test
public void updateMessageNoChange() throws Exception {
    createEmptyEditFor(changeId);
    String commitMessage = gApi.changes().id(changeId).edit().getCommitMessage();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("New commit message cannot be same as existing commit message");
    gApi.changes().id(changeId).edit().modifyCommitMessage(commitMessage);
}
#end_block

#method_before
@Test
public void updateMessageOnlyAddTrailingNewLines() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    exception.expect(UnchangedCommitMessageException.class);
    exception.expectMessage("New commit message cannot be same as existing commit message");
    modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage() + "\n\n");
}
#method_after
@Test
public void updateMessageOnlyAddTrailingNewLines() throws Exception {
    createEmptyEditFor(changeId);
    String commitMessage = gApi.changes().id(changeId).edit().getCommitMessage();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("New commit message cannot be same as existing commit message");
    gApi.changes().id(changeId).edit().modifyCommitMessage(commitMessage + "\n\n");
}
#end_block

#method_before
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String msg = String.format("New commit message\n\nChange-Id: %s\n", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get(), NotifyHandling.NONE);
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Commit message was updated."));
}
#method_after
@Test
public void updateMessage() throws Exception {
    createEmptyEditFor(changeId);
    String msg = String.format("New commit message\n\nChange-Id: %s\n", changeId);
    gApi.changes().id(changeId).edit().modifyCommitMessage(msg);
    String commitMessage = gApi.changes().id(changeId).edit().getCommitMessage();
    assertThat(commitMessage).isEqualTo(msg);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    assertThat(getEdit(changeId)).isAbsent();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
    assertThat(info.revisions.get(info.currentRevision).description).isEqualTo("Edit commit message");
    assertChangeMessages(changeId, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Commit message was updated."));
}
#end_block

#method_before
@Test
public void updateMessageRest() throws Exception {
    adminRestSession.get(urlEditMessage(false)).assertNotFound();
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2_STR + "\n\nChange-Id: %s\n", change.getKey());
    adminRestSession.put(urlEditMessage(false), in).assertNoContent();
    RestResponse r = adminRestSession.getJsonAccept(urlEditMessage(false));
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s\n", change.getKey());
    adminRestSession.put(urlEditMessage(false), in).assertNoContent();
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    r = adminRestSession.getJsonAccept(urlEditMessage(true));
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        assertThat(readContentFromJson(r)).isEqualTo(commit.getFullMessage());
    }
    editUtil.publish(edit.get(), NotifyHandling.NONE);
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Commit message was updated."));
}
#method_after
@Test
public void updateMessageRest() throws Exception {
    adminRestSession.get(urlEditMessage(changeId, false)).assertNotFound();
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2_STR + "\n\nChange-Id: %s\n", changeId);
    adminRestSession.put(urlEditMessage(changeId, false), in).assertNoContent();
    RestResponse r = adminRestSession.getJsonAccept(urlEditMessage(changeId, false));
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    String commitMessage = gApi.changes().id(changeId).edit().getCommitMessage();
    assertThat(commitMessage).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s\n", changeId);
    adminRestSession.put(urlEditMessage(changeId, false), in).assertNoContent();
    String updatedCommitMessage = gApi.changes().id(changeId).edit().getCommitMessage();
    assertThat(updatedCommitMessage).isEqualTo(in.message);
    r = adminRestSession.getJsonAccept(urlEditMessage(changeId, true));
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        assertThat(readContentFromJson(r)).isEqualTo(commit.getFullMessage());
    }
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    assertChangeMessages(changeId, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Commit message was updated."));
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    adminRestSession.get(urlEdit()).assertNoContent();
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo(false);
    assertThat(info.commit.commit).isEqualTo(edit.get().getRevision().get());
    assertThat(info.commit.parents).hasSize(1);
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    adminRestSession.get(urlEdit()).assertNoContent();
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
    createArbitraryEditFor(changeId);
    EditInfo editInfo = getEditInfo(changeId, false);
    ChangeInfo changeInfo = get(changeId);
    assertThat(editInfo.commit.commit).isNotEqualTo(changeInfo.currentRevision);
    assertThat(editInfo).commit().parents().hasSize(1);
    assertThat(editInfo).baseRevision().isEqualTo(changeInfo.currentRevision);
    gApi.changes().id(changeId).edit().delete();
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
}
#end_block

#method_before
@Test
public void retrieveFilesInEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    EditInfo info = toEditInfo(true);
    assertThat(info.files).hasSize(2);
    List<String> l = Lists.newArrayList(info.files.keySet());
    assertThat(l.get(0)).isEqualTo("/COMMIT_MSG");
    assertThat(l.get(1)).isEqualTo("foo");
}
#method_after
@Test
public void retrieveFilesInEdit() throws Exception {
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW));
    EditInfo info = getEditInfo(changeId, true);
    assertThat(info.files).isNotNull();
    assertThat(info.files.keySet()).containsExactly(Patch.COMMIT_MSG, FILE_NAME, FILE_NAME2);
}
#end_block

#method_before
@Test
public void deleteExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.deleteFile(edit.get(), FILE_NAME)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    exception.expect(ResourceNotFoundException.class);
    fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME);
}
#method_after
@Test
public void deleteExistingFile() throws Exception {
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().deleteFile(FILE_NAME);
    assertThat(getFileContentOfEdit(changeId, FILE_NAME)).isAbsent();
}
#end_block

#method_before
@Test
public void renameExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.renameFile(edit.get(), FILE_NAME, FILE_NAME3)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME3), CONTENT_OLD);
    exception.expect(ResourceNotFoundException.class);
    fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME);
}
#method_after
@Test
public void renameExistingFile() throws Exception {
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().renameFile(FILE_NAME, FILE_NAME3);
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME3), CONTENT_OLD);
    assertThat(getFileContentOfEdit(changeId, FILE_NAME)).isAbsent();
}
#end_block

#method_before
@Test
public void createEditByDeletingExistingFileRest() throws Exception {
    adminRestSession.delete(urlEditFile()).assertNoContent();
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    exception.expect(ResourceNotFoundException.class);
    fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME);
}
#method_after
@Test
public void createEditByDeletingExistingFileRest() throws Exception {
    adminRestSession.delete(urlEditFile(changeId, FILE_NAME)).assertNoContent();
    assertThat(getFileContentOfEdit(changeId, FILE_NAME)).isAbsent();
}
#end_block

#method_before
@Test
public void deletingNonExistingEditRest() throws Exception {
    adminRestSession.delete(urlEdit()).assertNotFound();
}
#method_after
@Test
public void deletingNonExistingEditRest() throws Exception {
    adminRestSession.delete(urlEdit(changeId)).assertNotFound();
}
#end_block

#method_before
@Test
public void deleteExistingFileRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    adminRestSession.delete(urlEditFile()).assertNoContent();
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    exception.expect(ResourceNotFoundException.class);
    fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME);
}
#method_after
@Test
public void deleteExistingFileRest() throws Exception {
    createEmptyEditFor(changeId);
    adminRestSession.delete(urlEditFile(changeId, FILE_NAME)).assertNoContent();
    assertThat(getFileContentOfEdit(changeId, FILE_NAME)).isAbsent();
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSet() throws Exception {
    assertThat(modifier.createEdit(change2, ps2)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertThat(modifier.restoreFile(edit.get(), FILE_NAME)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change2);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_OLD);
}
#method_after
@Test
public void restoreDeletedFileInPatchSet() throws Exception {
    createEmptyEditFor(changeId2);
    gApi.changes().id(changeId2).edit().restoreFile(FILE_NAME);
    ensureSameBytes(getFileContentOfEdit(changeId2, FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void revertChanges() throws Exception {
    assertThat(modifier.createEdit(change2, ps2)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertThat(modifier.restoreFile(edit.get(), FILE_NAME)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change2);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_OLD);
    assertThat(modifier.modifyFile(editUtil.byChange(change2).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change2);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertThat(modifier.restoreFile(edit.get(), FILE_NAME)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change2);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_OLD);
    editUtil.delete(edit.get());
}
#method_after
@Test
public void revertChanges() throws Exception {
    createEmptyEditFor(changeId2);
    gApi.changes().id(changeId2).edit().restoreFile(FILE_NAME);
    ensureSameBytes(getFileContentOfEdit(changeId2, FILE_NAME), CONTENT_OLD);
    gApi.changes().id(changeId2).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW));
    ensureSameBytes(getFileContentOfEdit(changeId2, FILE_NAME), CONTENT_NEW);
    gApi.changes().id(changeId2).edit().restoreFile(FILE_NAME);
    ensureSameBytes(getFileContentOfEdit(changeId2, FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void renameFileRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Post.Input in = new Post.Input();
    in.oldPath = FILE_NAME;
    in.newPath = FILE_NAME3;
    adminRestSession.post(urlEdit(), in).assertNoContent();
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME3), CONTENT_OLD);
    exception.expect(ResourceNotFoundException.class);
    fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME);
}
#method_after
@Test
public void renameFileRest() throws Exception {
    createEmptyEditFor(changeId);
    Post.Input in = new Post.Input();
    in.oldPath = FILE_NAME;
    in.newPath = FILE_NAME3;
    adminRestSession.post(urlEdit(changeId), in).assertNoContent();
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME3), CONTENT_OLD);
    assertThat(getFileContentOfEdit(changeId, FILE_NAME)).isAbsent();
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    adminRestSession.post(urlEdit2(), in).assertNoContent();
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_OLD);
}
#method_after
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    adminRestSession.post(urlEdit(changeId2), in).assertNoContent();
    ensureSameBytes(getFileContentOfEdit(changeId2, FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void amendExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW2);
}
#method_after
@Test
public void amendExistingFile() throws Exception {
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW));
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME), CONTENT_NEW);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW2));
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RawInputUtil.create(CONTENT_NEW);
    adminRestSession.putRaw(urlEditFile(), in.content).assertNoContent();
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW);
    in.content = RawInputUtil.create(CONTENT_NEW2);
    adminRestSession.putRaw(urlEditFile(), in.content).assertNoContent();
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW2);
}
#method_after
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RawInputUtil.create(CONTENT_NEW);
    adminRestSession.putRaw(urlEditFile(changeId, FILE_NAME), in.content).assertNoContent();
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME), CONTENT_NEW);
    in.content = RawInputUtil.create(CONTENT_NEW2);
    adminRestSession.putRaw(urlEditFile(changeId, FILE_NAME), in.content).assertNoContent();
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void changeEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Put.Input in = new Put.Input();
    in.content = RawInputUtil.create(CONTENT_NEW);
    adminRestSession.putRaw(urlEditFile(), in.content).assertNoContent();
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW);
}
#method_after
@Test
public void changeEditRest() throws Exception {
    createEmptyEditFor(changeId);
    Put.Input in = new Put.Input();
    in.content = RawInputUtil.create(CONTENT_NEW);
    adminRestSession.putRaw(urlEditFile(changeId, FILE_NAME), in.content).assertNoContent();
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME), CONTENT_NEW);
}
#end_block

#method_before
@Test
public void emptyPutRequest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    adminRestSession.put(urlEditFile()).assertNoContent();
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), "".getBytes());
}
#method_after
@Test
public void emptyPutRequest() throws Exception {
    createEmptyEditFor(changeId);
    adminRestSession.put(urlEditFile(changeId, FILE_NAME)).assertNoContent();
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME), "".getBytes(UTF_8));
}
#end_block

#method_before
@Test
public void createEmptyEditRest() throws Exception {
    adminRestSession.post(urlEdit()).assertNoContent();
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_OLD);
}
#method_after
@Test
public void createEmptyEditRest() throws Exception {
    adminRestSession.post(urlEdit(changeId)).assertNoContent();
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME), CONTENT_OLD);
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RawInputUtil.create(CONTENT_NEW);
    adminRestSession.putRaw(urlEditFile(), in.content).assertNoContent();
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    RestResponse r = adminRestSession.getJsonAccept(urlEditFile());
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(StringUtils.newStringUtf8(CONTENT_NEW2));
    r = adminRestSession.getJsonAccept(urlEditFile(true));
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(StringUtils.newStringUtf8(CONTENT_OLD));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RawInputUtil.create(CONTENT_NEW);
    adminRestSession.putRaw(urlEditFile(changeId, FILE_NAME), in.content).assertNoContent();
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW2));
    RestResponse r = adminRestSession.getJsonAccept(urlEditFile(changeId, FILE_NAME));
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(new String(CONTENT_NEW2, UTF_8));
    r = adminRestSession.getJsonAccept(urlEditFile(changeId, FILE_NAME, true));
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(new String(CONTENT_OLD, UTF_8));
}
#end_block

#method_before
@Test
public void getFileNotFoundRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    adminRestSession.delete(urlEditFile()).assertNoContent();
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    adminRestSession.get(urlEditFile()).assertNoContent();
    exception.expect(ResourceNotFoundException.class);
    fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME);
}
#method_after
@Test
public void getFileNotFoundRest() throws Exception {
    createEmptyEditFor(changeId);
    adminRestSession.delete(urlEditFile(changeId, FILE_NAME)).assertNoContent();
    adminRestSession.get(urlEditFile(changeId, FILE_NAME)).assertNoContent();
    assertThat(getFileContentOfEdit(changeId, FILE_NAME)).isAbsent();
}
#end_block

#method_before
@Test
public void addNewFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME2), CONTENT_NEW);
}
#method_after
@Test
public void addNewFile() throws Exception {
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME3, RawInputUtil.create(CONTENT_NEW));
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME3), CONTENT_NEW);
}
#end_block

#method_before
@Test
public void addNewFileAndAmend() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME2), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RawInputUtil.create(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME2), CONTENT_NEW2);
}
#method_after
@Test
public void addNewFileAndAmend() throws Exception {
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME3, RawInputUtil.create(CONTENT_NEW));
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME3), CONTENT_NEW);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME3, RawInputUtil.create(CONTENT_NEW2));
    ensureSameBytes(getFileContentOfEdit(changeId, FILE_NAME3), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void writeNoChanges() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    exception.expect(InvalidChangeOperationException.class);
    exception.expectMessage("no changes were made");
    modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_OLD));
}
#method_after
@Test
public void writeNoChanges() throws Exception {
    createEmptyEditFor(changeId);
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("no changes were made");
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_OLD));
}
#end_block

#method_before
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    String changeId = change.getKey().get();
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.<String, Short>of(cr, (short) 1);
    gApi.changes().id(changeId).revision(change.currentPatchSetId().get()).review(r);
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    assertThat(modifier.modifyMessage(edit.get(), newMsg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    editUtil.publish(edit.get(), NotifyHandling.NONE);
    ChangeInfo info = get(changeId);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#method_after
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.of(cr, (short) 1);
    gApi.changes().id(changeId).current().review(r);
    createEmptyEditFor(changeId);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    gApi.changes().id(changeId).edit().modifyCommitMessage(newMsg);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    ChangeInfo info = get(changeId);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#end_block

#method_before
@Test
public void files() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    ChangeEdit edit = editUtil.byChange(change).get();
    assertThat(modifier.modifyFile(edit, FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change).get();
    RestResponse r = adminRestSession.getJsonAccept(urlRevisionFiles(edit));
    Map<String, FileInfo> files = readContentFromJson(r, new TypeToken<Map<String, FileInfo>>() {
    });
    assertThat(files).containsKey(FILE_NAME);
    r = adminRestSession.getJsonAccept(urlRevisionFiles());
    files = readContentFromJson(r, new TypeToken<Map<String, FileInfo>>() {
    });
    assertThat(files).containsKey(FILE_NAME);
}
#method_after
@Test
public void files() throws Exception {
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW));
    Optional<EditInfo> edit = getEdit(changeId);
    assertThat(edit).isPresent();
    String editCommitId = edit.get().commit.commit;
    RestResponse r = adminRestSession.getJsonAccept(urlRevisionFiles(changeId, editCommitId));
    Map<String, FileInfo> files = readContentFromJson(r, new TypeToken<Map<String, FileInfo>>() {
    });
    assertThat(files).containsKey(FILE_NAME);
    r = adminRestSession.getJsonAccept(urlRevisionFiles(changeId));
    files = readContentFromJson(r, new TypeToken<Map<String, FileInfo>>() {
    });
    assertThat(files).containsKey(FILE_NAME);
}
#end_block

#method_before
@Test
public void diff() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    ChangeEdit edit = editUtil.byChange(change).get();
    assertThat(modifier.modifyFile(edit, FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change).get();
    RestResponse r = adminRestSession.getJsonAccept(urlDiff(edit));
    DiffInfo diff = readContentFromJson(r, DiffInfo.class);
    assertThat(diff.diffHeader.get(0)).contains(FILE_NAME);
    r = adminRestSession.getJsonAccept(urlDiff());
    diff = readContentFromJson(r, DiffInfo.class);
    assertThat(diff.diffHeader.get(0)).contains(FILE_NAME);
}
#method_after
@Test
public void diff() throws Exception {
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW));
    Optional<EditInfo> edit = getEdit(changeId);
    assertThat(edit).isPresent();
    String editCommitId = edit.get().commit.commit;
    RestResponse r = adminRestSession.getJsonAccept(urlDiff(changeId, editCommitId, FILE_NAME));
    DiffInfo diff = readContentFromJson(r, DiffInfo.class);
    assertThat(diff.diffHeader.get(0)).contains(FILE_NAME);
    r = adminRestSession.getJsonAccept(urlDiff(changeId, FILE_NAME));
    diff = readContentFromJson(r, DiffInfo.class);
    assertThat(diff.diffHeader.get(0)).contains(FILE_NAME);
}
#end_block

#method_before
@Test
public void createEditWithoutPushPatchSetPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSetEdit");
    // Clone repository as user
    TestRepository<InMemoryRepository> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(Permission.ADD_PATCH_SET, REGISTERED_USERS, "refs/for/*", p);
    // Create change as user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), userTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Try to create edit as admin
    assertThat(modifier.createEdit(r1.getChange().change(), r1.getPatchSet())).isEqualTo(RefUpdate.Result.REJECTED);
}
#method_after
@Test
public void createEditWithoutPushPatchSetPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSetEdit");
    // Clone repository as user
    TestRepository<InMemoryRepository> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(Permission.ADD_PATCH_SET, REGISTERED_USERS, "refs/for/*", p);
    // Create change as user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), userTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Try to create edit as admin
    exception.expect(AuthException.class);
    createEmptyEditFor(r1.getChangeId());
}
#end_block

#method_before
private String urlEdit() {
    return "/changes/" + change.getChangeId() + "/edit";
}
#method_after
private String urlEdit(String changeId) {
    return "/changes/" + changeId + "/edit";
}
#end_block

#method_before
private String urlEditMessage(boolean base) {
    return "/changes/" + change.getChangeId() + "/edit:message" + (base ? "?base" : "");
}
#method_after
private String urlEditMessage(String changeId, boolean base) {
    return "/changes/" + changeId + "/edit:message" + (base ? "?base" : "");
}
#end_block

#method_before
private String urlEditFile(boolean base) {
    return urlEdit() + "/" + FILE_NAME + (base ? "?base" : "");
}
#method_after
private String urlEditFile(String changeId, String fileName) {
    return urlEditFile(changeId, fileName, false);
}
#end_block

#method_before
private String urlGetFiles() {
    return urlEdit() + "?list";
}
#method_after
private String urlGetFiles(String changeId) {
    return urlEdit(changeId) + "?list";
}
#end_block

#method_before
private String urlRevisionFiles() {
    return "/changes/" + change.getChangeId() + "/revisions/0/files";
}
#method_after
private String urlRevisionFiles(String changeId, String revisionId) {
    return "/changes/" + changeId + "/revisions/" + revisionId + "/files";
}
#end_block

#method_before
private String urlPublish() {
    return "/changes/" + change.getChangeId() + "/edit:publish";
}
#method_after
private String urlPublish(String changeId) {
    return "/changes/" + changeId + "/edit:publish";
}
#end_block

#method_before
private String urlRebase() {
    return "/changes/" + change.getChangeId() + "/edit:rebase";
}
#method_after
private String urlRebase(String changeId) {
    return "/changes/" + changeId + "/edit:rebase";
}
#end_block

#method_before
private String urlDiff(ChangeEdit edit) {
    return "/changes/" + change.getChangeId() + "/revisions/" + edit.getRevision().get() + "/files/" + FILE_NAME + "/diff?context=ALL&intraline";
}
#method_after
private String urlDiff(String changeId, String fileName) {
    return "/changes/" + changeId + "/revisions/0/files/" + fileName + "/diff?context=ALL&intraline";
}
#end_block

#method_before
private void assertChangeMessages(Change c, List<String> expectedMessages) throws Exception {
    ChangeInfo ci = get(c.getId().toString());
    assertThat(ci.messages).isNotNull();
    assertThat(ci.messages).hasSize(expectedMessages.size());
    List<String> actualMessages = new ArrayList<>();
    Iterator<ChangeMessageInfo> it = ci.messages.iterator();
    while (it.hasNext()) {
        actualMessages.add(it.next().message);
    }
    assertThat(actualMessages).containsExactlyElementsIn(expectedMessages).inOrder();
}
#method_after
private void assertChangeMessages(String changeId, List<String> expectedMessages) throws Exception {
    ChangeInfo ci = get(changeId);
    assertThat(ci.messages).isNotNull();
    assertThat(ci.messages).hasSize(expectedMessages.size());
    List<String> actualMessages = ci.messages.stream().map(message -> message.message).collect(Collectors.toList());
    assertThat(actualMessages).containsExactlyElementsIn(expectedMessages).inOrder();
}
#end_block

#method_before
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to list project watches " + "of other users");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = readFromGit ? watchConfig.getProjectWatches(accountId) : readProjectWatchesFromDb(dbProvider.get(), accountId);
    List<ProjectWatchInfo> projectWatchInfos = new LinkedList<>();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches.entrySet()) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = e.getKey().filter();
        pwi.project = e.getKey().project().get();
        pwi.notifyAbandonedChanges = toBoolean(e.getValue().contains(NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(e.getValue().contains(NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(e.getValue().contains(NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(e.getValue().contains(NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(e.getValue().contains(NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    Collections.sort(projectWatchInfos, new Comparator<ProjectWatchInfo>() {

        @Override
        public int compare(ProjectWatchInfo pwi1, ProjectWatchInfo pwi2) {
            return ComparisonChain.start().compare(pwi1.project, pwi2.project).compare(Strings.nullToEmpty(pwi1.filter), Strings.nullToEmpty(pwi2.filter)).result();
        }
    });
    return projectWatchInfos;
}
#method_after
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to list project watches " + "of other users");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    List<ProjectWatchInfo> projectWatchInfos = new ArrayList<>();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : watchConfig.getProjectWatches(accountId).entrySet()) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = e.getKey().filter();
        pwi.project = e.getKey().project().get();
        pwi.notifyAbandonedChanges = toBoolean(e.getValue().contains(NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(e.getValue().contains(NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(e.getValue().contains(NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(e.getValue().contains(NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(e.getValue().contains(NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    Collections.sort(projectWatchInfos, new Comparator<ProjectWatchInfo>() {

        @Override
        public int compare(ProjectWatchInfo pwi1, ProjectWatchInfo pwi2) {
            return ComparisonChain.start().compare(pwi1.project, pwi2.project).compare(Strings.nullToEmpty(pwi1.filter), Strings.nullToEmpty(pwi2.filter)).result();
        }
    });
    return projectWatchInfos;
}
#end_block

#method_before
private GeneralPreferencesInfo read(Account.Id id, GeneralPreferencesInfo in) throws IOException, ConfigInvalidException, RepositoryNotFoundException {
    try (Repository allUsers = gitMgr.openRepository(allUsersName)) {
        // Load all users default prefs
        VersionedAccountPreferences dp = VersionedAccountPreferences.forDefault();
        dp.load(allUsers);
        GeneralPreferencesInfo allUserPrefs = new GeneralPreferencesInfo();
        loadSection(dp.getConfig(), UserConfigSections.GENERAL, null, allUserPrefs, GeneralPreferencesInfo.defaults(), in);
        // Load user prefs
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(id);
        p.load(allUsers);
        GeneralPreferencesInfo r = loadSection(p.getConfig(), UserConfigSections.GENERAL, null, new GeneralPreferencesInfo(), updateDefaults(allUserPrefs), in);
        return loadMyMenusAndUrlAliases(r, p, dp);
    }
}
#method_after
private GeneralPreferencesInfo read(Account.Id id, GeneralPreferencesInfo in) throws IOException, ConfigInvalidException, RepositoryNotFoundException {
    try (Repository allUsers = gitMgr.openRepository(allUsersName)) {
        // Load all users default prefs
        VersionedAccountPreferences dp = VersionedAccountPreferences.forDefault();
        dp.load(allUsers);
        GeneralPreferencesInfo allUserPrefs = new GeneralPreferencesInfo();
        loadSection(dp.getConfig(), UserConfigSections.GENERAL, null, allUserPrefs, GeneralPreferencesInfo.defaults(), in);
        // Load user prefs
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(id);
        p.load(allUsers);
        GeneralPreferencesInfo r = loadSection(p.getConfig(), UserConfigSections.GENERAL, null, new GeneralPreferencesInfo(), updateDefaults(allUserPrefs), in);
        loadChangeTableColumns(r, p, dp);
        return loadMyMenusAndUrlAliases(r, p, dp);
    }
}
#end_block

#method_before
@Override
public CurrentUser getUser() {
    return user;
}
#method_after
@Override
public CurrentUser getUser() {
    return userProvider.get();
}
#end_block

#method_before
public Executor createQueue(int poolsize, String prefix) {
    final Executor r = new Executor(poolsize, prefix);
    r.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
    r.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
    queues.add(r);
    return r;
}
#method_after
public Executor createQueue(int poolsize, String prefix) {
    final Executor r = new Executor(poolsize, prefix);
    r.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
    r.setExecuteExistingDelayedTasksAfterShutdownPolicy(true);
    queues.add(r);
    return r;
}
#end_block

#method_before
private void recursivelyExpandGroups(final Set<String> groupDNs, final LdapSchema schema, final DirContext ctx, final String groupDN) {
    if (groupDNs.add(groupDN) && schema.accountMemberField != null) {
        ImmutableSet<String> cachedParentsDNs = parentGroups.getIfPresent(groupDN);
        if (cachedParentsDNs == null) {
            // Recursively identify the groups it is a member of.
            ImmutableSet.Builder<String> dns = ImmutableSet.builder();
            try {
                final Name compositeGroupName = new CompositeName().add(groupDN);
                final Attribute in = ctx.getAttributes(compositeGroupName, schema.accountMemberFieldArray).get(schema.accountMemberField);
                if (in != null) {
                    final NamingEnumeration<?> groups = in.getAll();
                    try {
                        while (groups.hasMore()) {
                            dns.add((String) groups.next());
                        }
                    } catch (PartialResultException e) {
                    // Ignored
                    }
                }
            } catch (NamingException e) {
                LdapRealm.log.warn("Could not find group " + groupDN, e);
            }
            cachedParentsDNs = dns.build();
            parentGroups.put(groupDN, cachedParentsDNs);
        }
        for (String dn : cachedParentsDNs) {
            recursivelyExpandGroups(groupDNs, schema, ctx, dn);
        }
    }
}
#method_after
private void recursivelyExpandGroups(final Set<String> groupDNs, final LdapSchema schema, final DirContext ctx, final String groupDN) {
    if (groupDNs.add(groupDN) && schema.accountMemberField != null && schema.accountMemberExpandGroups) {
        ImmutableSet<String> cachedParentsDNs = parentGroups.getIfPresent(groupDN);
        if (cachedParentsDNs == null) {
            // Recursively identify the groups it is a member of.
            ImmutableSet.Builder<String> dns = ImmutableSet.builder();
            try {
                final Name compositeGroupName = new CompositeName().add(groupDN);
                final Attribute in = ctx.getAttributes(compositeGroupName, schema.accountMemberFieldArray).get(schema.accountMemberField);
                if (in != null) {
                    final NamingEnumeration<?> groups = in.getAll();
                    try {
                        while (groups.hasMore()) {
                            dns.add((String) groups.next());
                        }
                    } catch (PartialResultException e) {
                    // Ignored
                    }
                }
            } catch (NamingException e) {
                LdapRealm.log.warn("Could not find group " + groupDN, e);
            }
            cachedParentsDNs = dns.build();
            parentGroups.put(groupDN, cachedParentsDNs);
        }
        for (String dn : cachedParentsDNs) {
            recursivelyExpandGroups(groupDNs, schema, ctx, dn);
        }
    }
}
#end_block

#method_before
public void publish(final ChangeEdit edit, NotifyHandling notify) throws NoSuchChangeException, IOException, OrmException, RestApiException, UpdateException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        RevWalk rw = new RevWalk(repo);
        ObjectInserter oi = repo.newObjectInserter()) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        RevCommit squashed = squashEdit(rw, oi, edit.getEditCommit(), basePatchSet);
        ChangeControl ctl = changeControlFactory.controlFor(db.get(), change, edit.getUser());
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, squashed).setNotify(notify);
        StringBuilder message = new StringBuilder("Patch Set ").append(inserter.getPatchSetId().get()).append(": ");
        // Previously checked that the base patch set is the current patch set.
        ObjectId prior = ObjectId.fromString(basePatchSet.getRevision().get());
        ChangeKind kind = changeKindCache.getChangeKind(change.getProject(), repo, prior, squashed);
        if (kind == ChangeKind.NO_CODE_CHANGE) {
            message.append("Commit message was updated.");
        } else {
            message.append("Published edit on patch set ").append(basePatchSet.getPatchSetId()).append(".");
        }
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setDraft(change.getStatus() == Status.DRAFT || basePatchSet.isDraft()).setMessage(message.toString()));
            bu.addOp(change.getId(), new BatchUpdate.Op() {

                @Override
                public void updateRepo(RepoContext ctx) throws Exception {
                    deleteRef(ctx.getRepository(), edit);
                }
            });
            bu.execute();
        } catch (UpdateException e) {
            if (e.getCause() instanceof IOException && e.getMessage().equals(String.format("%s: Failed to delete ref %s: %s", IOException.class.getName(), edit.getRefName(), RefUpdate.Result.LOCK_FAILURE.name()))) {
                throw new ResourceConflictException("edit ref was updated");
            }
        }
        indexer.index(db.get(), inserter.getChange());
    }
}
#method_after
public void publish(final ChangeEdit edit, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws IOException, OrmException, RestApiException, UpdateException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        RevWalk rw = new RevWalk(repo);
        ObjectInserter oi = repo.newObjectInserter()) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        RevCommit squashed = squashEdit(rw, oi, edit.getEditCommit(), basePatchSet);
        ChangeControl ctl = changeControlFactory.controlFor(db.get(), change, edit.getUser());
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, squashed).setNotify(notify).setAccountsToNotify(accountsToNotify);
        StringBuilder message = new StringBuilder("Patch Set ").append(inserter.getPatchSetId().get()).append(": ");
        // Previously checked that the base patch set is the current patch set.
        ObjectId prior = ObjectId.fromString(basePatchSet.getRevision().get());
        ChangeKind kind = changeKindCache.getChangeKind(change.getProject(), repo, prior, squashed);
        if (kind == ChangeKind.NO_CODE_CHANGE) {
            message.append("Commit message was updated.");
            inserter.setDescription("Edit commit message");
        } else {
            message.append("Published edit on patch set ").append(basePatchSet.getPatchSetId()).append(".");
        }
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setDraft(change.getStatus() == Status.DRAFT || basePatchSet.isDraft()).setMessage(message.toString()));
            bu.addOp(change.getId(), new BatchUpdate.Op() {

                @Override
                public void updateRepo(RepoContext ctx) throws Exception {
                    deleteRef(ctx.getRepository(), edit);
                }
            });
            bu.execute();
        } catch (UpdateException e) {
            if (e.getCause() instanceof IOException && e.getMessage().equals(String.format("%s: Failed to delete ref %s: %s", IOException.class.getName(), edit.getRefName(), RefUpdate.Result.LOCK_FAILURE.name()))) {
                throw new ResourceConflictException("edit ref was updated");
            }
        }
        indexer.index(db.get(), inserter.getChange());
    }
}
#end_block

#method_before
@Override
public Response<?> apply(VoteResource rsrc, DeleteVoteInput input) throws RestApiException, UpdateException {
    if (input == null) {
        input = new DeleteVoteInput();
    }
    if (input.label != null && !rsrc.getLabel().equals(input.label)) {
        throw new BadRequestException("label must match URL");
    }
    if (input.notify == null) {
        input.notify = NotifyHandling.ALL;
    }
    ReviewerResource r = rsrc.getReviewer();
    Change change = r.getChange();
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), r.getControl().getUser(), TimeUtil.nowTs())) {
        bu.addOp(change.getId(), new Op(r.getReviewerUser().getAccountId(), rsrc.getLabel(), input));
        bu.execute();
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(VoteResource rsrc, DeleteVoteInput input) throws RestApiException, UpdateException {
    if (input == null) {
        input = new DeleteVoteInput();
    }
    if (input.label != null && !rsrc.getLabel().equals(input.label)) {
        throw new BadRequestException("label must match URL");
    }
    if (input.notify == null) {
        input.notify = NotifyHandling.ALL;
    }
    ReviewerResource r = rsrc.getReviewer();
    Change change = r.getChange();
    if (r.getRevisionResource() != null && !r.getRevisionResource().isCurrent()) {
        throw new MethodNotAllowedException("Cannot delete vote on non-current patch set");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), r.getControl().getUser(), TimeUtil.nowTs())) {
        bu.addOp(change.getId(), new Op(r.getReviewerUser().getAccountId(), rsrc.getLabel(), input));
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    boolean found = false;
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (labelTypes.byLabel(a.getLabelId()) == null) {
            // Ignore undefined labels.
            continue;
        } else if (!a.getLabel().equals(label)) {
            // Populate map for non-matching labels, needed by VoteDeleted.
            newApprovals.put(a.getLabel(), a.getValue());
            continue;
        } else if (!ctl.canRemoveReviewer(a)) {
            throw new AuthException("delete vote not permitted");
        }
        // Set the approval to 0 if vote is being removed.
        newApprovals.put(a.getLabel(), (short) 0);
        found = true;
        // Set old value, as required by VoteDeleted.
        oldApprovals.put(a.getLabel(), a.getValue());
        break;
    }
    if (!found) {
        throw new ResourceNotFoundException();
    }
    ctx.getUpdate(psId).removeApprovalFor(accountId, label);
    if (PrimaryStorage.of(ctx.getChange()) == REVIEW_DB) {
        // Avoid OrmConcurrencyException trying to update non-existent entities.
        ctx.getDb().patchSetApprovals().upsert(Collections.singleton(deletedApproval(ctx)));
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed ");
    LabelVote.appendTo(msg, label, checkNotNull(oldApprovals.get(label)));
    msg.append(" by ").append(userFactory.create(accountId).getNameEmail()).append("\n");
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_VOTE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    boolean found = false;
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (labelTypes.byLabel(a.getLabelId()) == null) {
            // Ignore undefined labels.
            continue;
        } else if (!a.getLabel().equals(label)) {
            // Populate map for non-matching labels, needed by VoteDeleted.
            newApprovals.put(a.getLabel(), a.getValue());
            continue;
        } else if (!ctl.canRemoveReviewer(a)) {
            throw new AuthException("delete vote not permitted");
        }
        // Set the approval to 0 if vote is being removed.
        newApprovals.put(a.getLabel(), (short) 0);
        found = true;
        // Set old value, as required by VoteDeleted.
        oldApprovals.put(a.getLabel(), a.getValue());
        break;
    }
    if (!found) {
        throw new ResourceNotFoundException();
    }
    ctx.getUpdate(psId).removeApprovalFor(accountId, label);
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(deletedApproval(ctx)));
    StringBuilder msg = new StringBuilder();
    msg.append("Removed ");
    LabelVote.appendTo(msg, label, checkNotNull(oldApprovals.get(label)));
    msg.append(" by ").append(userFactory.create(accountId).getNameEmail()).append("\n");
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_VOTE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getIdentifiedUser();
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    voteDeleted.fire(change, ps, newApprovals, oldApprovals, input.notify, changeMessage.getMessage(), user.getAccount(), ctx.getWhen());
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getIdentifiedUser();
    if (NotifyUtil.shouldNotify(input.notify, input.notifyDetails)) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.setNotify(input.notify);
            cm.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    voteDeleted.fire(change, ps, newApprovals, oldApprovals, input.notify, changeMessage.getMessage(), user.getAccount(), ctx.getWhen());
}
#end_block

#method_before
@Override
public void run() {
    RequestContext old = requestContext.setContext(this);
    try {
        MergedSender cm = mergedSenderFactory.create(project, changeId);
        if (submitter != null) {
            cm.setFrom(submitter);
        }
        cm.setNotify(notifyHandling);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + changeId, e);
    } finally {
        requestContext.setContext(old);
        if (db != null) {
            db.close();
            db = null;
        }
    }
}
#method_after
@Override
public void run() {
    RequestContext old = requestContext.setContext(this);
    try {
        MergedSender cm = mergedSenderFactory.create(project, changeId);
        if (submitter != null) {
            cm.setFrom(submitter);
        }
        cm.setNotify(notifyHandling);
        cm.setAccountsToNotify(accountsToNotify);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + changeId, e);
    } finally {
        requestContext.setContext(old);
        if (db != null) {
            db.close();
            db = null;
        }
    }
}
#end_block

#method_before
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, Multimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, Multimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, Multimap<RevId, Comment> publishedComments) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments));
}
#method_after
static ChangeNotesState create(@Nullable ObjectId metaId, Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Account.Id assignee, @Nullable Change.Status status, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, ListMultimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, ListMultimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, ListMultimap<RevId, Comment> publishedComments) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(metaId, changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee, status), ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableList.copyOf(patchSets.entrySet()), ImmutableList.copyOf(approvals.entries()), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments));
}
#end_block

#method_before
@Override
public GroupInfo get() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public GroupInfo get() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public GroupInfo detail() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public GroupInfo detail() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public String name() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public String name() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void name(String name) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void name(String name) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public GroupInfo owner() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public GroupInfo owner() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void owner(String owner) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void owner(String owner) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public String description() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public String description() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void description(String description) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void description(String description) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public GroupOptionsInfo options() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public GroupOptionsInfo options() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void options(GroupOptionsInfo options) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void options(GroupOptionsInfo options) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<AccountInfo> members() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<AccountInfo> members() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void addMembers(String... members) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void addMembers(String... members) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void removeMembers(String... members) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void removeMembers(String... members) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<GroupInfo> includedGroups() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<GroupInfo> includedGroups() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void addGroups(String... groups) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void addGroups(String... groups) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void removeGroups(String... groups) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void removeGroups(String... groups) {
    throw new NotImplementedException();
}
#end_block

#method_before
protected Injector createDbInjector(final boolean enableMetrics, final DataSourceProvider.Context context) {
    final Path sitePath = getSitePath();
    final List<Module> modules = new ArrayList<>();
    Module sitePathModule = new AbstractModule() {

        @Override
        protected void configure() {
            bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            bind(String.class).annotatedWith(SecureStoreClassName.class).toProvider(Providers.of(getConfiguredSecureStoreClass()));
        }
    };
    modules.add(sitePathModule);
    if (enableMetrics) {
        modules.add(new DropWizardMetricMaker.ApiModule());
    } else {
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(MetricMaker.class).to(DisabledMetricMaker.class);
            }
        });
    }
    modules.add(new LifecycleModule() {

        @Override
        protected void configure() {
            bind(DataSourceProvider.Context.class).toInstance(context);
            if (dsProvider != null) {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(dsProvider).in(SINGLETON);
                if (LifecycleListener.class.isAssignableFrom(dsProvider.getClass())) {
                    listener().toInstance((LifecycleListener) dsProvider);
                }
            } else {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(SiteLibraryBasedDataSourceProvider.class).in(SINGLETON);
                listener().to(SiteLibraryBasedDataSourceProvider.class);
            }
        }
    });
    Module configModule = new GerritServerConfigModule();
    modules.add(configModule);
    Injector cfgInjector = Guice.createInjector(sitePathModule, configModule);
    Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    String dbType;
    if (dsProvider != null) {
        dbType = getDbType(dsProvider);
    } else {
        dbType = cfg.getString("database", null, "type");
    }
    if (dbType == null) {
        throw new ProvisionException("database.type must be defined");
    }
    final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(DataSourceType.class).toInstance(dst);
        }
    });
    modules.add(new DatabaseModule());
    modules.add(new SchemaModule());
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new ConfigNotesMigration.Module());
    try {
        return Guice.createInjector(PRODUCTION, modules);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof SQLException) {
            throw die("Cannot connect to SQL database", why);
        }
        if (why instanceof OrmException && why.getCause() != null && "Unable to determine driver URL".equals(why.getMessage())) {
            why = why.getCause();
            if (isCannotCreatePoolException(why)) {
                throw die("Cannot connect to SQL database", why.getCause());
            }
            throw die("Cannot connect to SQL database", why);
        }
        final StringBuilder buf = new StringBuilder();
        if (why != null) {
            buf.append(why.getMessage());
            why = why.getCause();
        } else {
            buf.append(first.getMessage());
        }
        while (why != null) {
            buf.append("\n  caused by ");
            buf.append(why.toString());
            why = why.getCause();
        }
        throw die(buf.toString(), new RuntimeException("DbInjector failed", ce));
    }
}
#method_after
protected Injector createDbInjector(final boolean enableMetrics, final DataSourceProvider.Context context) {
    final Path sitePath = getSitePath();
    final List<Module> modules = new ArrayList<>();
    Module sitePathModule = new AbstractModule() {

        @Override
        protected void configure() {
            bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            bind(String.class).annotatedWith(SecureStoreClassName.class).toProvider(Providers.of(getConfiguredSecureStoreClass()));
        }
    };
    modules.add(sitePathModule);
    if (enableMetrics) {
        modules.add(new DropWizardMetricMaker.ApiModule());
    } else {
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(MetricMaker.class).to(DisabledMetricMaker.class);
            }
        });
    }
    modules.add(new LifecycleModule() {

        @Override
        protected void configure() {
            bind(DataSourceProvider.Context.class).toInstance(context);
            if (dsProvider != null) {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(dsProvider).in(SINGLETON);
                if (LifecycleListener.class.isAssignableFrom(dsProvider.getClass())) {
                    listener().toInstance((LifecycleListener) dsProvider);
                }
            } else {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(SiteLibraryBasedDataSourceProvider.class).in(SINGLETON);
                listener().to(SiteLibraryBasedDataSourceProvider.class);
            }
        }
    });
    Module configModule = new GerritServerConfigModule();
    modules.add(configModule);
    Injector cfgInjector = Guice.createInjector(sitePathModule, configModule);
    Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    String dbType;
    if (dsProvider != null) {
        dbType = getDbType(dsProvider);
    } else {
        dbType = cfg.getString("database", null, "type");
    }
    if (dbType == null) {
        throw new ProvisionException("database.type must be defined");
    }
    final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(DataSourceType.class).toInstance(dst);
        }
    });
    modules.add(new DatabaseModule());
    modules.add(new SchemaModule());
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new ConfigNotesMigration.Module());
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    try {
        return Guice.createInjector(PRODUCTION, modules);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof SQLException) {
            throw die("Cannot connect to SQL database", why);
        }
        if (why instanceof OrmException && why.getCause() != null && "Unable to determine driver URL".equals(why.getMessage())) {
            why = why.getCause();
            if (isCannotCreatePoolException(why)) {
                throw die("Cannot connect to SQL database", why.getCause());
            }
            throw die("Cannot connect to SQL database", why);
        }
        final StringBuilder buf = new StringBuilder();
        if (why != null) {
            buf.append(why.getMessage());
            why = why.getCause();
        } else {
            buf.append(first.getMessage());
        }
        while (why != null) {
            buf.append("\n  caused by ");
            buf.append(why.toString());
            why = why.getCause();
        }
        throw die(buf.toString(), new RuntimeException("DbInjector failed", ce));
    }
}
#end_block

#method_before
@Test
public void editMergeList() throws Exception {
    ChangeData cd = getOnlyElement(queryProvider.get().byKeyPrefix(changeId));
    modifier.createEdit(cd.change(), cd.currentPatchSet());
    exception.expect(InvalidPathException.class);
    exception.expectMessage("Invalid path: " + MERGE_LIST);
    modifier.modifyFile(editUtil.byChange(cd.change()).get(), MERGE_LIST, RawInputUtil.create("new content"));
}
#method_after
@Test
public void editMergeList() throws Exception {
    gApi.changes().id(changeId).edit().create();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Invalid path: " + MERGE_LIST);
    gApi.changes().id(changeId).edit().modifyFile(MERGE_LIST, RawInputUtil.create("new content"));
}
#end_block

#method_before
@Test
public void deleteMergeList() throws Exception {
    ChangeData cd = getOnlyElement(queryProvider.get().byKeyPrefix(changeId));
    modifier.createEdit(cd.change(), cd.currentPatchSet());
    exception.expect(InvalidChangeOperationException.class);
    exception.expectMessage("no changes were made");
    modifier.deleteFile(editUtil.byChange(cd.change()).get(), MERGE_LIST);
}
#method_after
@Test
public void deleteMergeList() throws Exception {
    gApi.changes().id(changeId).edit().create();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("no changes were made");
    gApi.changes().id(changeId).edit().deleteFile(MERGE_LIST);
}
#end_block

#method_before
static Predicate<AccountState> id(Account.Id accountId) {
    return new AccountPredicate(AccountField.ID, AccountQueryBuilder.FIELD_ACCOUNT, accountId.toString());
}
#method_after
public static Predicate<AccountState> id(Account.Id accountId) {
    return new AccountPredicate(AccountField.ID, AccountQueryBuilder.FIELD_ACCOUNT, accountId.toString());
}
#end_block

#method_before
private void audit() {
    try {
        GerritCall call = currentCall.get();
        MethodHandle method = call.getMethod();
        if (method == null) {
            return;
        }
        Audit note = method.getAnnotation(Audit.class);
        if (note != null) {
            final String sid = call.getWebSession().getSessionId();
            final CurrentUser username = call.getWebSession().getUser();
            final Multimap<String, ?> args = extractParams(note, call);
            final String what = extractWhat(note, call);
            final Object result = call.getResult();
            audit.dispatch(new RpcAuditEvent(sid, username, what, call.getWhen(), args, call.getHttpServletRequest().getMethod(), call.getHttpServletRequest().getMethod(), ((AuditedHttpServletResponse) (call.getHttpServletResponse())).getStatus(), result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#method_after
private void audit() {
    try {
        GerritCall call = currentCall.get();
        MethodHandle method = call.getMethod();
        if (method == null) {
            return;
        }
        Audit note = method.getAnnotation(Audit.class);
        if (note != null) {
            String sid = call.getWebSession().getSessionId();
            CurrentUser username = call.getWebSession().getUser();
            ListMultimap<String, ?> args = extractParams(note, call);
            String what = extractWhat(note, call);
            Object result = call.getResult();
            audit.dispatch(new RpcAuditEvent(sid, username, what, call.getWhen(), args, call.getHttpServletRequest().getMethod(), call.getHttpServletRequest().getMethod(), ((AuditedHttpServletResponse) (call.getHttpServletResponse())).getStatus(), result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#end_block

#method_before
private Multimap<String, ?> extractParams(final Audit note, final GerritCall call) {
    Multimap<String, Object> args = ArrayListMultimap.create();
    Object[] params = call.getParams();
    for (int i = 0; i < params.length; i++) {
        args.put("$" + i, params[i]);
    }
    for (int idx : note.obfuscate()) {
        args.removeAll("$" + idx);
        args.put("$" + idx, "*****");
    }
    return args;
}
#method_after
private ListMultimap<String, ?> extractParams(Audit note, GerritCall call) {
    ListMultimap<String, Object> args = MultimapBuilder.hashKeys().arrayListValues().build();
    Object[] params = call.getParams();
    for (int i = 0; i < params.length; i++) {
        args.put("$" + i, params[i]);
    }
    for (int idx : note.obfuscate()) {
        args.removeAll("$" + idx);
        args.put("$" + idx, "*****");
    }
    return args;
}
#end_block

#method_before
@Override
public ChangeKind call() throws IOException {
    if (Objects.equals(key.prior, key.next)) {
        return ChangeKind.NO_CODE_CHANGE;
    }
    Repository repo = alreadyOpenRepo;
    boolean close = false;
    if (repo == null) {
        repo = repoManager.openRepository(projectName);
        close = true;
    }
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit prior = walk.parseCommit(key.prior);
        walk.parseBody(prior);
        RevCommit next = walk.parseCommit(key.next);
        walk.parseBody(next);
        if (!next.getFullMessage().equals(prior.getFullMessage())) {
            if (isSameDeltaAndTree(prior, next)) {
                return ChangeKind.NO_CODE_CHANGE;
            }
            return ChangeKind.REWORK;
        }
        if (isSameDeltaAndTree(prior, next)) {
            return ChangeKind.NO_CHANGE;
        }
        if ((prior.getParentCount() != 1 || next.getParentCount() != 1) && !onlyFirstParentChanged(prior, next)) {
            // Trivial rebases done by machine only work well on 1 parent.
            return ChangeKind.REWORK;
        }
        // cherry-picked onto the next commit's new first parent.
        try (ObjectInserter ins = new InMemoryInserter(repo)) {
            ThreeWayMerger merger = MergeUtil.newThreeWayMerger(repo, ins, key.strategyName);
            merger.setBase(prior.getParent(0));
            if (merger.merge(next.getParent(0), prior) && merger.getResultTreeId().equals(next.getTree())) {
                if (prior.getParentCount() == 1) {
                    return ChangeKind.TRIVIAL_REBASE;
                }
                return ChangeKind.MERGE_FIRST_PARENT_UPDATE;
            }
        } catch (LargeObjectException e) {
        // Some object is too large for the merge attempt to succeed. Assume
        // it was a rework.
        }
        return ChangeKind.REWORK;
    } finally {
        if (close) {
            repo.close();
        }
    }
}
#method_after
@Override
public ChangeKind call() throws IOException {
    if (Objects.equals(key.prior, key.next)) {
        return ChangeKind.NO_CODE_CHANGE;
    }
    Repository repo = alreadyOpenRepo;
    boolean close = false;
    if (repo == null) {
        repo = repoManager.openRepository(projectName);
        close = true;
    }
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit prior = walk.parseCommit(key.prior);
        walk.parseBody(prior);
        RevCommit next = walk.parseCommit(key.next);
        walk.parseBody(next);
        if (!next.getFullMessage().equals(prior.getFullMessage())) {
            if (isSameDeltaAndTree(prior, next)) {
                return ChangeKind.NO_CODE_CHANGE;
            }
            return ChangeKind.REWORK;
        }
        if (isSameDeltaAndTree(prior, next)) {
            return ChangeKind.NO_CHANGE;
        }
        if ((prior.getParentCount() != 1 || next.getParentCount() != 1) && (!onlyFirstParentChanged(prior, next) || prior.getParentCount() == 0)) {
            // Trivial rebases done by machine only work well on 1 parent.
            return ChangeKind.REWORK;
        }
        // cherry-picked onto the next commit's new first parent.
        try (ObjectInserter ins = new InMemoryInserter(repo)) {
            ThreeWayMerger merger = MergeUtil.newThreeWayMerger(repo, ins, key.strategyName);
            merger.setBase(prior.getParent(0));
            if (merger.merge(next.getParent(0), prior) && merger.getResultTreeId().equals(next.getTree())) {
                if (prior.getParentCount() == 1) {
                    return ChangeKind.TRIVIAL_REBASE;
                }
                return ChangeKind.MERGE_FIRST_PARENT_UPDATE;
            }
        } catch (LargeObjectException e) {
        // Some object is too large for the merge attempt to succeed. Assume
        // it was a rework.
        }
        return ChangeKind.REWORK;
    } finally {
        if (close) {
            repo.close();
        }
    }
}
#end_block

#method_before
@Override
protected Void impl(RequestContext ctx) throws OrmException, IOException, NoSuchChangeException {
    // Reload change, as some time may have passed since GetChanges.
    ReviewDb db = ctx.getReviewDbProvider().get();
    try {
        Change c = notesFactory.createChecked(db, new Project.NameKey(event.getProjectName()), id).getChange();
        indexerFactory.create(executor, indexes).index(db, c);
    } catch (NoSuchChangeException e) {
        indexerFactory.create(executor, indexes).delete(id);
    }
    return null;
}
#method_after
@Override
protected Void impl(RequestContext ctx) throws OrmException, IOException {
    // Reload change, as some time may have passed since GetChanges.
    ReviewDb db = ctx.getReviewDbProvider().get();
    try {
        Change c = notesFactory.createChecked(db, new Project.NameKey(event.getProjectName()), id).getChange();
        indexerFactory.create(executor, indexes).index(db, c);
    } catch (NoSuchChangeException e) {
        indexerFactory.create(executor, indexes).delete(id);
    }
    return null;
}
#end_block

#method_before
@Override
public void run() {
    RequestContext old = requestContext.setContext(this);
    try {
        CommentSender cm = commentSenderFactory.create(notes.getProjectName(), notes.getChangeId());
        cm.setFrom(user.getAccountId());
        cm.setPatchSet(patchSet, patchSetInfoFactory.get(notes.getProjectName(), patchSet));
        cm.setChangeMessage(message.getMessage(), message.getWrittenOn());
        cm.setComments(comments);
        cm.setNotify(notify);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email comments for " + patchSet.getId(), e);
    } finally {
        requestContext.setContext(old);
        if (db != null) {
            db.close();
            db = null;
        }
    }
}
#method_after
@Override
public void run() {
    RequestContext old = requestContext.setContext(this);
    try {
        CommentSender cm = commentSenderFactory.create(notes.getProjectName(), notes.getChangeId());
        cm.setFrom(user.getAccountId());
        cm.setPatchSet(patchSet, patchSetInfoFactory.get(notes.getProjectName(), patchSet));
        cm.setChangeMessage(message.getMessage(), message.getWrittenOn());
        cm.setComments(comments);
        cm.setPatchSetComment(patchSetComment);
        cm.setLabels(labels);
        cm.setNotify(notify);
        cm.setAccountsToNotify(accountsToNotify);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email comments for " + patchSet.getId(), e);
    } finally {
        requestContext.setContext(old);
        if (db != null) {
            db.close();
            db = null;
        }
    }
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws MergeConflictException, InvalidChangeOperationException, RestApiException, IOException, OrmException, NoSuchChangeException {
    // Ok that originalPatchSet was not read in a transaction, since we just
    // need its revision.
    RevId oldRev = originalPatchSet.getRevision();
    RevWalk rw = ctx.getRevWalk();
    RevCommit original = rw.parseCommit(ObjectId.fromString(oldRev.get()));
    rw.parseBody(original);
    RevCommit baseCommit;
    if (baseCommitish != null) {
        baseCommit = rw.parseCommit(ctx.getRepository().resolve(baseCommitish));
    } else {
        baseCommit = rw.parseCommit(rebaseUtil.findBaseRevision(originalPatchSet, ctl.getChange().getDest(), ctx.getRepository(), ctx.getRevWalk()));
    }
    rebasedCommit = rebaseCommit(ctx, original, baseCommit);
    RevId baseRevId = new RevId((baseCommitish != null) ? baseCommitish : ObjectId.toString(baseCommit.getId()));
    Base base = rebaseUtil.parseBase(new RevisionResource(changeResourceFactory.create(ctl), originalPatchSet), baseRevId.get());
    rebasedPatchSetId = ChangeUtil.nextPatchSetId(ctx.getRepository(), ctl.getChange().currentPatchSetId());
    patchSetInserter = patchSetInserterFactory.create(ctl, rebasedPatchSetId, rebasedCommit).setDraft(originalPatchSet.isDraft()).setNotify(NotifyHandling.NONE).setFireRevisionCreated(fireRevisionCreated).setCopyApprovals(copyApprovals);
    if (postMessage) {
        patchSetInserter.setMessage("Patch Set " + rebasedPatchSetId.get() + ": Patch Set " + originalPatchSet.getId().get() + " was rebased");
    }
    if (base != null) {
        patchSetInserter.setGroups(base.patchSet().getGroups());
    }
    if (validate != null) {
        patchSetInserter.setValidatePolicy(validate);
    }
    patchSetInserter.updateRepo(ctx);
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws MergeConflictException, InvalidChangeOperationException, RestApiException, IOException, OrmException, NoSuchChangeException {
    // Ok that originalPatchSet was not read in a transaction, since we just
    // need its revision.
    RevId oldRev = originalPatchSet.getRevision();
    RevWalk rw = ctx.getRevWalk();
    RevCommit original = rw.parseCommit(ObjectId.fromString(oldRev.get()));
    rw.parseBody(original);
    RevCommit baseCommit;
    if (baseCommitish != null) {
        baseCommit = rw.parseCommit(ctx.getRepository().resolve(baseCommitish));
    } else {
        baseCommit = rw.parseCommit(rebaseUtil.findBaseRevision(originalPatchSet, ctl.getChange().getDest(), ctx.getRepository(), ctx.getRevWalk()));
    }
    String newCommitMessage;
    if (detailedCommitMessage) {
        rw.parseBody(baseCommit);
        newCommitMessage = newMergeUtil().createCommitMessageOnSubmit(original, baseCommit, ctl, originalPatchSet.getId());
    } else {
        newCommitMessage = original.getFullMessage();
    }
    rebasedCommit = rebaseCommit(ctx, original, baseCommit, newCommitMessage);
    RevId baseRevId = new RevId((baseCommitish != null) ? baseCommitish : ObjectId.toString(baseCommit.getId()));
    Base base = rebaseUtil.parseBase(new RevisionResource(changeResourceFactory.create(ctl), originalPatchSet), baseRevId.get());
    rebasedPatchSetId = ChangeUtil.nextPatchSetId(ctx.getRepository(), ctl.getChange().currentPatchSetId());
    patchSetInserter = patchSetInserterFactory.create(ctl, rebasedPatchSetId, rebasedCommit).setDescription("Rebase").setDraft(originalPatchSet.isDraft()).setNotify(NotifyHandling.NONE).setFireRevisionCreated(fireRevisionCreated).setCopyApprovals(copyApprovals).setCheckAddPatchSetPermission(checkAddPatchSetPermission);
    if (postMessage) {
        patchSetInserter.setMessage("Patch Set " + rebasedPatchSetId.get() + ": Patch Set " + originalPatchSet.getId().get() + " was rebased");
    }
    if (base != null) {
        patchSetInserter.setGroups(base.patchSet().getGroups());
    }
    if (validate != null) {
        patchSetInserter.setValidatePolicy(validate);
    }
    patchSetInserter.updateRepo(ctx);
}
#end_block

#method_before
private RevCommit rebaseCommit(RepoContext ctx, RevCommit original, ObjectId base) throws ResourceConflictException, MergeConflictException, IOException {
    RevCommit parentCommit = original.getParent(0);
    if (base.equals(parentCommit)) {
        throw new ResourceConflictException("Change is already up to date.");
    }
    ThreeWayMerger merger = newMergeUtil().newThreeWayMerger(ctx.getRepository(), ctx.getInserter());
    merger.setBase(parentCommit);
    merger.merge(original, base);
    if (merger.getResultTreeId() == null) {
        throw new MergeConflictException("The change could not be rebased due to a conflict during merge.");
    }
    CommitBuilder cb = new CommitBuilder();
    cb.setTreeId(merger.getResultTreeId());
    cb.setParentId(base);
    cb.setAuthor(original.getAuthorIdent());
    cb.setMessage(original.getFullMessage());
    if (committerIdent != null) {
        cb.setCommitter(committerIdent);
    } else {
        cb.setCommitter(ctx.getIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone()));
    }
    ObjectId objectId = ctx.getInserter().insert(cb);
    ctx.getInserter().flush();
    return ctx.getRevWalk().parseCommit(objectId);
}
#method_after
private RevCommit rebaseCommit(RepoContext ctx, RevCommit original, ObjectId base, String commitMessage) throws ResourceConflictException, IOException {
    RevCommit parentCommit = original.getParent(0);
    if (base.equals(parentCommit)) {
        throw new ResourceConflictException("Change is already up to date.");
    }
    ThreeWayMerger merger = newMergeUtil().newThreeWayMerger(ctx.getRepository(), ctx.getInserter());
    merger.setBase(parentCommit);
    merger.merge(original, base);
    if (merger.getResultTreeId() == null) {
        throw new MergeConflictException("The change could not be rebased due to a conflict during merge.");
    }
    CommitBuilder cb = new CommitBuilder();
    cb.setTreeId(merger.getResultTreeId());
    cb.setParentId(base);
    cb.setAuthor(original.getAuthorIdent());
    cb.setMessage(commitMessage);
    if (committerIdent != null) {
        cb.setCommitter(committerIdent);
    } else {
        cb.setCommitter(ctx.getIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone()));
    }
    ObjectId objectId = ctx.getInserter().insert(cb);
    ctx.getInserter().flush();
    return ctx.getRevWalk().parseCommit(objectId);
}
#end_block

#method_before
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    return ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_RESTORE);
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    return ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_RESTORE);
}
#end_block

#method_before
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), has(Sandboxed.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null);
}
#method_after
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), has(Sandboxed.class, testDesc.getTestClass()), has(UseSsh.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null);
}
#end_block

#method_before
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Sandboxed.class) != null || has(Sandboxed.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class));
}
#method_after
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(testDesc, configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Sandboxed.class) != null || has(Sandboxed.class, testDesc.getTestClass()), testDesc.getAnnotation(UseSsh.class) != null || has(UseSsh.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class));
}
#end_block

#method_before
static GerritServer start(Description desc, Config baseConfig) throws Exception {
    Config cfg = desc.buildConfig(baseConfig);
    Logger.getLogger("com.google.gerrit").setLevel(Level.DEBUG);
    final CyclicBarrier serverStarted = new CyclicBarrier(2);
    final Daemon daemon = new Daemon(new Runnable() {

        @Override
        public void run() {
            try {
                serverStarted.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        }
    }, Paths.get(baseConfig.getString("gerrit", null, "tempSiteDir")));
    daemon.setEmailModuleForTesting(new FakeEmailSender.Module());
    final File site;
    ExecutorService daemonService = null;
    if (desc.memory()) {
        site = null;
        mergeTestConfig(cfg);
        // Set the log4j configuration to an invalid one to prevent system logs
        // from getting configured and creating log files.
        System.setProperty(SystemLog.LOG4J_CONFIGURATION, "invalidConfiguration");
        cfg.setBoolean("httpd", null, "requestLog", false);
        cfg.setBoolean("sshd", null, "requestLog", false);
        cfg.setBoolean("index", "lucene", "testInmemory", true);
        cfg.setString("gitweb", null, "cgi", "");
        daemon.setEnableHttpd(desc.httpd());
        daemon.setLuceneModule(LuceneIndexModule.singleVersionAllLatest(0));
        daemon.setDatabaseForTesting(ImmutableList.<Module>of(new InMemoryTestingDatabaseModule(cfg)));
        daemon.start();
    } else {
        site = initSite(cfg);
        daemonService = Executors.newSingleThreadExecutor();
        daemonService.submit(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                int rc = daemon.main(new String[] { "-d", site.getPath(), "--headless", "--console-log", "--show-stack-trace" });
                if (rc != 0) {
                    System.err.println("Failed to start Gerrit daemon");
                    serverStarted.reset();
                }
                return null;
            }
        });
        serverStarted.await();
        System.out.println("Gerrit Server Started");
    }
    Injector i = createTestInjector(daemon);
    return new GerritServer(desc, i, daemon, daemonService);
}
#method_after
static GerritServer start(Description desc, Config baseConfig) throws Exception {
    Config cfg = desc.buildConfig(baseConfig);
    Logger.getLogger("com.google.gerrit").setLevel(Level.DEBUG);
    final CyclicBarrier serverStarted = new CyclicBarrier(2);
    final Daemon daemon = new Daemon(new Runnable() {

        @Override
        public void run() {
            try {
                serverStarted.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        }
    }, Paths.get(baseConfig.getString("gerrit", null, "tempSiteDir")));
    daemon.setEmailModuleForTesting(new FakeEmailSender.Module());
    daemon.setEnableSshd(SshMode.useSsh());
    final File site;
    ExecutorService daemonService = null;
    if (desc.memory()) {
        site = null;
        mergeTestConfig(cfg);
        // Set the log4j configuration to an invalid one to prevent system logs
        // from getting configured and creating log files.
        System.setProperty(SystemLog.LOG4J_CONFIGURATION, "invalidConfiguration");
        cfg.setBoolean("httpd", null, "requestLog", false);
        cfg.setBoolean("sshd", null, "requestLog", false);
        cfg.setBoolean("index", "lucene", "testInmemory", true);
        cfg.setString("gitweb", null, "cgi", "");
        daemon.setEnableHttpd(desc.httpd());
        daemon.setLuceneModule(LuceneIndexModule.singleVersionAllLatest(0));
        daemon.setDatabaseForTesting(ImmutableList.<Module>of(new InMemoryTestingDatabaseModule(cfg)));
        daemon.start();
    } else {
        site = initSite(cfg);
        daemonService = Executors.newSingleThreadExecutor();
        daemonService.submit(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                int rc = daemon.main(new String[] { "-d", site.getPath(), "--headless", "--console-log", "--show-stack-trace" });
                if (rc != 0) {
                    System.err.println("Failed to start Gerrit daemon");
                    serverStarted.reset();
                }
                return null;
            }
        });
        serverStarted.await();
        System.out.println("Gerrit Server Started");
    }
    Injector i = createTestInjector(daemon);
    return new GerritServer(desc, i, daemon, daemonService);
}
#end_block

#method_before
void stop() throws Exception {
    try {
        if (NoteDbMode.get().equals(NoteDbMode.CHECK)) {
            testInjector.getInstance(NoteDbChecker.class).rebuildAndCheckAllChanges();
        }
    } finally {
        daemon.getLifecycleManager().stop();
        if (daemonService != null) {
            System.out.println("Gerrit Server Shutdown");
            daemonService.shutdownNow();
            daemonService.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
        }
        RepositoryCache.clear();
    }
}
#method_after
void stop() throws Exception {
    try {
        checkNoteDbState();
    } finally {
        daemon.getLifecycleManager().stop();
        if (daemonService != null) {
            System.out.println("Gerrit Server Shutdown");
            daemonService.shutdownNow();
            daemonService.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
        }
        RepositoryCache.clear();
    }
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Updated watch configuration\n");
    }
    Config cfg = readConfig(WATCH_CONFIG);
    for (String projectName : cfg.getSubsections(PROJECT)) {
        cfg.unset(PROJECT, projectName, KEY_NOTIFY);
    }
    Multimap<String, String> notifyValuesByProject = ArrayListMultimap.create();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches.entrySet()) {
        NotifyValue notifyValue = NotifyValue.create(e.getKey().filter(), e.getValue());
        notifyValuesByProject.put(e.getKey().project().get(), notifyValue.toString());
    }
    for (Map.Entry<String, Collection<String>> e : notifyValuesByProject.asMap().entrySet()) {
        cfg.setStringList(PROJECT, e.getKey(), KEY_NOTIFY, new ArrayList<>(e.getValue()));
    }
    saveConfig(WATCH_CONFIG, cfg);
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Updated watch configuration\n");
    }
    Config cfg = readConfig(WATCH_CONFIG);
    for (String projectName : cfg.getSubsections(PROJECT)) {
        cfg.unsetSection(PROJECT, projectName);
    }
    ListMultimap<String, String> notifyValuesByProject = MultimapBuilder.hashKeys().arrayListValues().build();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches.entrySet()) {
        NotifyValue notifyValue = NotifyValue.create(e.getKey().filter(), e.getValue());
        notifyValuesByProject.put(e.getKey().project().get(), notifyValue.toString());
    }
    for (Map.Entry<String, Collection<String>> e : notifyValuesByProject.asMap().entrySet()) {
        cfg.setStringList(PROJECT, e.getKey(), KEY_NOTIFY, new ArrayList<>(e.getValue()));
    }
    saveConfig(WATCH_CONFIG, cfg);
    return true;
}
#end_block

#method_before
public static NotifyValue parse(Account.Id accountId, String project, String notifyValue, ValidationError.Sink validationErrorSink) {
    notifyValue = notifyValue.trim();
    int i = notifyValue.lastIndexOf('[');
    if (i < 0 || notifyValue.charAt(notifyValue.length() - 1) != ']') {
        validationErrorSink.error(new ValidationError(WATCH_CONFIG, String.format("Invalid project watch of account %d for project %s: %s", accountId.get(), project, notifyValue)));
        return null;
    }
    String filter = notifyValue.substring(0, i).trim();
    if (filter.isEmpty() || AccountProjectWatch.FILTER_ALL.equals(filter)) {
        filter = null;
    }
    Set<NotifyType> notifyTypes = EnumSet.noneOf(NotifyType.class);
    if (i + 1 < notifyValue.length() - 2) {
        for (String nt : Splitter.on(',').trimResults().splitToList(notifyValue.substring(i + 1, notifyValue.length() - 1))) {
            NotifyType notifyType = Enums.getIfPresent(NotifyType.class, nt).orNull();
            if (notifyType == null) {
                validationErrorSink.error(new ValidationError(WATCH_CONFIG, String.format("Invalid notify type %s in project watch " + "of account %d for project %s: %s", nt, accountId.get(), project, notifyValue)));
                continue;
            }
            notifyTypes.add(notifyType);
        }
    }
    return create(filter, notifyTypes);
}
#method_after
public static NotifyValue parse(Account.Id accountId, String project, String notifyValue, ValidationError.Sink validationErrorSink) {
    notifyValue = notifyValue.trim();
    int i = notifyValue.lastIndexOf('[');
    if (i < 0 || notifyValue.charAt(notifyValue.length() - 1) != ']') {
        validationErrorSink.error(new ValidationError(WATCH_CONFIG, String.format("Invalid project watch of account %d for project %s: %s", accountId.get(), project, notifyValue)));
        return null;
    }
    String filter = notifyValue.substring(0, i).trim();
    if (filter.isEmpty() || FILTER_ALL.equals(filter)) {
        filter = null;
    }
    Set<NotifyType> notifyTypes = EnumSet.noneOf(NotifyType.class);
    if (i + 1 < notifyValue.length() - 2) {
        for (String nt : Splitter.on(',').trimResults().splitToList(notifyValue.substring(i + 1, notifyValue.length() - 1))) {
            NotifyType notifyType = Enums.getIfPresent(NotifyType.class, nt).orNull();
            if (notifyType == null) {
                validationErrorSink.error(new ValidationError(WATCH_CONFIG, String.format("Invalid notify type %s in project watch " + "of account %d for project %s: %s", nt, accountId.get(), project, notifyValue)));
                continue;
            }
            notifyTypes.add(notifyType);
        }
    }
    return create(filter, notifyTypes);
}
#end_block

#method_before
@Override
public String toString() {
    List<NotifyType> notifyTypes = new ArrayList<>(notifyTypes());
    StringBuilder notifyValue = new StringBuilder();
    notifyValue.append(firstNonNull(filter(), AccountProjectWatch.FILTER_ALL)).append(" [");
    Joiner.on(", ").appendTo(notifyValue, notifyTypes);
    notifyValue.append("]");
    return notifyValue.toString();
}
#method_after
@Override
public String toString() {
    List<NotifyType> notifyTypes = new ArrayList<>(notifyTypes());
    StringBuilder notifyValue = new StringBuilder();
    notifyValue.append(firstNonNull(filter(), FILTER_ALL)).append(" [");
    Joiner.on(", ").appendTo(notifyValue, notifyTypes);
    notifyValue.append("]");
    return notifyValue.toString();
}
#end_block

#method_before
@Test
public void submitWholeTopic() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", "test-topic");
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", "test-topic");
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", "test-topic");
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    change1.assertChange(Change.Status.MERGED, name("test-topic"), admin);
    change2.assertChange(Change.Status.MERGED, name("test-topic"), admin);
    change3.assertChange(Change.Status.MERGED, name("test-topic"), admin);
    // Check for the exact change to have the correct submitter.
    assertSubmitter(change3);
    // Also check submitters for changes submitted via the topic relationship.
    assertSubmitter(change1);
    assertSubmitter(change2);
}
#method_after
@Test
public void submitWholeTopic() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    String topic = "test-topic";
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", topic);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", topic);
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", topic);
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    String expectedTopic = name(topic);
    change1.assertChange(Change.Status.MERGED, expectedTopic, admin);
    change2.assertChange(Change.Status.MERGED, expectedTopic, admin);
    change3.assertChange(Change.Status.MERGED, expectedTopic, admin);
    // Check for the exact change to have the correct submitter.
    assertSubmitter(change3);
    // Also check submitters for changes submitted via the topic relationship.
    assertSubmitter(change1);
    assertSubmitter(change2);
    // Check that the repo has the expected commits
    List<RevCommit> log = getRemoteLog();
    List<String> commitsInRepo = log.stream().map(c -> c.getShortMessage()).collect(Collectors.toList());
    int expectedCommitCount = getSubmitType() == SubmitType.MERGE_ALWAYS ? // initial commit + 3 commits + merge commit
    5 : // initial commit + 3 commits
    4;
    assertThat(log).hasSize(expectedCommitCount);
    assertThat(commitsInRepo).containsAllOf("Initial empty repository", "Change 1", "Change 2", "Change 3");
    if (getSubmitType() == SubmitType.MERGE_ALWAYS) {
        assertThat(commitsInRepo).contains("Merge changes from topic '" + expectedTopic + "'");
    }
}
#end_block

#method_before
protected BinaryResult submitPreview(String changeId) throws Exception {
    return gApi.changes().id(changeId).current().submitPreview();
}
#method_after
protected BinaryResult submitPreview(String changeId, String format) throws Exception {
    return gApi.changes().id(changeId).current().submitPreview(format);
}
#end_block

#method_before
protected void assertApproved(String changeId) throws Exception {
    ChangeInfo c = get(changeId, DETAILED_LABELS);
    LabelInfo cr = c.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).value).isEqualTo(2);
    assertThat(new Account.Id(cr.all.get(0)._accountId)).isEqualTo(admin.getId());
}
#method_after
protected void assertApproved(String changeId) throws Exception {
    assertApproved(changeId, admin);
}
#end_block

#method_before
protected void assertApproved(String changeId) throws Exception {
    ChangeInfo c = get(changeId, DETAILED_LABELS);
    LabelInfo cr = c.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).value).isEqualTo(2);
    assertThat(new Account.Id(cr.all.get(0)._accountId)).isEqualTo(admin.getId());
}
#method_after
protected void assertApproved(String changeId, TestAccount user) throws Exception {
    ChangeInfo c = get(changeId, DETAILED_LABELS);
    LabelInfo cr = c.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).value).isEqualTo(2);
    assertThat(new Account.Id(cr.all.get(0)._accountId)).isEqualTo(user.getId());
}
#end_block

#method_before
protected void assertSubmitter(String changeId, int psId) throws Exception {
    Change c = getOnlyElement(queryProvider.get().byKeyPrefix(changeId)).change();
    ChangeNotes cn = notesFactory.createChecked(db, c);
    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new PatchSet.Id(cn.getChangeId(), psId));
    assertThat(submitter).isNotNull();
    assertThat(submitter.isLegacySubmit()).isTrue();
    assertThat(submitter.getAccountId()).isEqualTo(admin.getId());
}
#method_after
protected void assertSubmitter(String changeId, int psId) throws Exception {
    assertSubmitter(changeId, psId, admin);
}
#end_block

#method_before
protected void assertSubmitter(String changeId, int psId) throws Exception {
    Change c = getOnlyElement(queryProvider.get().byKeyPrefix(changeId)).change();
    ChangeNotes cn = notesFactory.createChecked(db, c);
    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new PatchSet.Id(cn.getChangeId(), psId));
    assertThat(submitter).isNotNull();
    assertThat(submitter.isLegacySubmit()).isTrue();
    assertThat(submitter.getAccountId()).isEqualTo(admin.getId());
}
#method_after
protected void assertSubmitter(String changeId, int psId, TestAccount user) throws Exception {
    Change c = getOnlyElement(queryProvider.get().byKeyPrefix(changeId)).change();
    ChangeNotes cn = notesFactory.createChecked(db, c);
    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new PatchSet.Id(cn.getChangeId(), psId));
    assertThat(submitter).isNotNull();
    assertThat(submitter.isLegacySubmit()).isTrue();
    assertThat(submitter.getAccountId()).isEqualTo(user.getId());
}
#end_block

#method_before
public ChangeControl findOne(Change.Id id, CurrentUser user) throws OrmException, NoSuchChangeException {
    List<ChangeControl> ctls = find(id, user);
    if (ctls.size() != 1) {
        throw new NoSuchChangeException(id);
    }
    return ctls.get(0);
}
#method_after
public ChangeControl findOne(Change.Id id, CurrentUser user) throws OrmException {
    List<ChangeControl> ctls = find(id, user);
    if (ctls.size() != 1) {
        throw new NoSuchChangeException(id);
    }
    return ctls.get(0);
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    try {
        GroupResource rsrc = groups.parse(TopLevelResource.INSTANCE, IdString.fromDecoded(groupName));
        PutName.Input input = new PutName.Input();
        input.name = newGroupName;
        putName.apply(rsrc, input);
    } catch (RestApiException | OrmException | NoSuchGroupException e) {
        throw die(e);
    }
}
#method_after
@Override
protected void run() throws Failure {
    try {
        GroupResource rsrc = groups.parse(TopLevelResource.INSTANCE, IdString.fromDecoded(groupName));
        PutName.Input input = new PutName.Input();
        input.name = newGroupName;
        putName.apply(rsrc, input);
    } catch (RestApiException | OrmException | IOException | NoSuchGroupException e) {
        throw die(e);
    }
}
#end_block

#method_before
@Override
public ChangeApi id(int id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi id(int id) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi id(String triplet) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi id(String triplet) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi id(String project, String branch, String id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi id(String project, String branch, String id) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi create(ChangeInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi create(ChangeInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
public Account.Id lookup(String externalId) throws AccountException {
    try {
        if (accountIndexes.getSearchIndex() != null) {
            AccountState accountState = accountQueryProvider.get().oneByExternalId(externalId);
            return accountState != null ? accountState.getAccount().getId() : null;
        }
        try (ReviewDb db = schema.open()) {
            AccountExternalId ext = db.accountExternalIds().get(new AccountExternalId.Key(externalId));
            return ext != null ? ext.getAccountId() : null;
        }
    } catch (OrmException e) {
        throw new AccountException("Cannot lookup account " + externalId, e);
    }
}
#method_after
public Optional<Account.Id> lookup(String externalId) throws AccountException {
    try {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(externalId);
        return accountState != null ? Optional.of(accountState.getAccount().getId()) : Optional.empty();
    } catch (OrmException e) {
        throw new AccountException("Cannot lookup account " + externalId, e);
    }
}
#end_block

#method_before
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            AccountExternalId.Key key = id(who);
            AccountExternalId id = getAccountExternalId(db, key);
            if (id == null) {
                // 
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.getAccountId()).getAccount();
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(db, who, id);
            return new AuthResult(id.getAccountId(), key, false);
        }
    } catch (OrmException e) {
        throw new AccountException("Authentication error", e);
    }
}
#method_after
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            AccountExternalId.Key key = id(who);
            AccountExternalId id = getAccountExternalId(key);
            if (id == null) {
                // 
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.getAccountId()).getAccount();
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(db, who, id);
            return new AuthResult(id.getAccountId(), key, false);
        }
    } catch (OrmException e) {
        throw new AccountException("Authentication error", e);
    }
}
#end_block

#method_before
private AccountExternalId getAccountExternalId(ReviewDb db, AccountExternalId.Key key) throws OrmException {
    if (accountIndexes.getSearchIndex() != null) {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(key.get());
        if (accountState != null) {
            for (AccountExternalId extId : accountState.getExternalIds()) {
                if (extId.getKey().equals(key)) {
                    return extId;
                }
            }
        }
        return null;
    }
    // without having to query the DB every time
    if (key.getScheme().equals(AccountExternalId.SCHEME_GERRIT) || key.getScheme().equals(AccountExternalId.SCHEME_USERNAME)) {
        AccountState state = byIdCache.getByUsername(key.get().substring(key.getScheme().length()));
        if (state != null) {
            for (AccountExternalId accountExternalId : state.getExternalIds()) {
                if (accountExternalId.getKey().equals(key)) {
                    return accountExternalId;
                }
            }
        }
    }
    return db.accountExternalIds().get(key);
}
#method_after
private AccountExternalId getAccountExternalId(AccountExternalId.Key key) throws OrmException {
    AccountState accountState = accountQueryProvider.get().oneByExternalId(key.get());
    if (accountState != null) {
        for (AccountExternalId extId : accountState.getExternalIds()) {
            if (extId.getKey().equals(key)) {
                return extId;
            }
        }
    }
    return null;
}
#end_block

#method_before
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    Account account = new Account(newId, TimeUtil.nowTs());
    AccountExternalId extId = createId(newId, who);
    extId.setEmailAddress(who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.getEmailAddress());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        db.accountExternalIds().upsert(Collections.singleton(extId));
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    byIdCache.evict(account.getId());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.getKey(), true);
}
#method_after
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    Account account = new Account(newId, TimeUtil.nowTs());
    AccountExternalId extId = createId(newId, who);
    extId.setEmailAddress(who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.getEmailAddress());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        AccountExternalId existingExtId = db.accountExternalIds().get(extId.getKey());
        if (existingExtId != null && !existingExtId.getAccountId().equals(extId.getAccountId())) {
            // external ID is assigned to another account, do not overwrite
            db.accounts().delete(Collections.singleton(account));
            throw new AccountException("Cannot assign external ID \"" + extId.getExternalId() + "\" to account " + newId + "; external ID already in use.");
        }
        db.accountExternalIds().upsert(Collections.singleton(extId));
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    byIdCache.evict(account.getId());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.getKey(), true);
}
#end_block

#method_before
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(db, key);
        if (extId != null) {
            if (!extId.getAccountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            update(db, who, extId);
        } else {
            extId = createId(to, who);
            extId.setEmailAddress(who.getEmailAddress());
            db.accountExternalIds().insert(Collections.singleton(extId));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                }
            }
            if (who.getEmailAddress() != null) {
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(to);
            }
        }
        return new AuthResult(to, key, false);
    }
}
#method_after
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(key);
        if (extId != null) {
            if (!extId.getAccountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            update(db, who, extId);
        } else {
            extId = createId(to, who);
            extId.setEmailAddress(who.getEmailAddress());
            db.accountExternalIds().insert(Collections.singleton(extId));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                }
            }
            if (who.getEmailAddress() != null) {
                byEmailCache.evict(who.getEmailAddress());
            }
            byIdCache.evict(to);
        }
        return new AuthResult(to, key, false);
    }
}
#end_block

#method_before
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(db, key);
        if (extId != null) {
            if (!extId.getAccountId().equals(from)) {
                throw new AccountException("Identity '" + key.get() + "' in use by another account");
            }
            db.accountExternalIds().delete(Collections.singleton(extId));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                }
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(from);
            }
        } else {
            throw new AccountException("Identity '" + key.get() + "' not found");
        }
        return new AuthResult(from, key, false);
    }
}
#method_after
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(key);
        if (extId != null) {
            if (!extId.getAccountId().equals(from)) {
                throw new AccountException("Identity '" + key.get() + "' in use by another account");
            }
            db.accountExternalIds().delete(Collections.singleton(extId));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                }
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(from);
            }
        } else {
            throw new AccountException("Identity '" + key.get() + "' not found");
        }
        return new AuthResult(from, key, false);
    }
}
#end_block

#method_before
public static boolean isRefsEdit(String ref) {
    return ref.startsWith(REFS_USERS) && ref.contains(EDIT_PREFIX);
}
#method_after
public static boolean isRefsEdit(String ref) {
    return ref != null && ref.startsWith(REFS_USERS) && ref.contains(EDIT_PREFIX);
}
#end_block

#method_before
public void setNotify(NotifyHandling notify) {
    this.notify = notify;
}
#method_after
public void setNotify(NotifyHandling notify) {
    this.notify = checkNotNull(notify);
}
#end_block

#method_before
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify)) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("HeaderHtml"));
    }
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        String textPart = textBody.toString();
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = textPart;
        if (useHtml()) {
            va.htmlBody = htmlBody.toString();
        } else {
            va.htmlBody = null;
        }
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body, va.htmlBody);
    }
}
#method_after
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify) && accountsToNotify.isEmpty()) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("HeaderHtml"));
    }
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (!accountsToNotify.containsValue(fromId) && rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        String textPart = textBody.toString();
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = textPart;
        if (useHtml()) {
            va.htmlBody = htmlBody.toString();
        } else {
            va.htmlBody = null;
        }
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body, va.htmlBody);
    }
}
#end_block

#method_before
protected void init() throws EmailException {
    setupVelocityContext();
    setupSoyContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.getEmail().equals(a.getEmail())) {
            setHeader("Reply-To", a.getEmail());
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    textBody = new StringBuilder();
    htmlBody = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#method_after
protected void init() throws EmailException {
    setupVelocityContext();
    setupSoyContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    for (RecipientType recipientType : accountsToNotify.keySet()) {
        add(recipientType, accountsToNotify.get(recipientType));
    }
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.getEmail().equals(a.getEmail())) {
            setHeader("Reply-To", a.getEmail());
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    textBody = new StringBuilder();
    htmlBody = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#end_block

#method_before
protected boolean shouldSendMessage() {
    if (textBody.length() == 0) {
        // If we have no message body, don't send.
        return false;
    }
    if (smtpRcptTo.isEmpty()) {
        // unable to match a destination. Don't bother sending it.
        return false;
    }
    if (smtpRcptTo.size() == 1 && rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#method_after
protected boolean shouldSendMessage() {
    if (textBody.length() == 0) {
        // If we have no message body, don't send.
        return false;
    }
    if (smtpRcptTo.isEmpty()) {
        // unable to match a destination. Don't bother sending it.
        return false;
    }
    if ((accountsToNotify == null || accountsToNotify.isEmpty()) && smtpRcptTo.size() == 1 && rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#end_block

#method_before
protected void setupSoyContext() {
    soyContext = new HashMap<>();
    soyContext.put("messageClass", messageClass);
    soyContextEmailData = new HashMap<>();
    soyContextEmailData.put("settingsUrl", getSettingsUrl());
    soyContextEmailData.put("gerritHost", getGerritHost());
    soyContextEmailData.put("gerritUrl", getGerritUrl());
    soyContext.put("email", soyContextEmailData);
}
#method_after
protected void setupSoyContext() {
    soyContext = new HashMap<>();
    footers = new ArrayList<>();
    soyContext.put("messageClass", messageClass);
    soyContext.put("footers", footers);
    soyContextEmailData = new HashMap<>();
    soyContextEmailData.put("settingsUrl", getSettingsUrl());
    soyContextEmailData.put("gerritHost", getGerritHost());
    soyContextEmailData.put("gerritUrl", getGerritUrl());
    soyContext.put("email", soyContextEmailData);
}
#end_block

#method_before
public Comment newComment(ChangeContext ctx, String path, PatchSet.Id psId, short side, String message) throws OrmException {
    Comment c = new Comment(new Comment.Key(ChangeUtil.messageUUID(ctx.getDb()), path, psId.get()), ctx.getUser().getAccountId(), ctx.getWhen(), side, message, serverId);
    ctx.getUser().updateRealAccountId(c::setRealAuthor);
    return c;
}
#method_after
public Comment newComment(ChangeContext ctx, String path, PatchSet.Id psId, short side, String message, @Nullable Boolean unresolved, @Nullable String parentUuid) throws OrmException, UnprocessableEntityException {
    if (unresolved == null) {
        if (parentUuid == null) {
            // Default to false if comment is not descended from another.
            unresolved = false;
        } else {
            // Inherit unresolved value from inReplyTo comment if not specified.
            Comment.Key key = new Comment.Key(parentUuid, path, psId.patchSetId);
            Optional<Comment> parent = get(ctx.getDb(), ctx.getNotes(), key);
            if (!parent.isPresent()) {
                throw new UnprocessableEntityException("Invalid parentUuid supplied for comment");
            }
            unresolved = parent.get().unresolved;
        }
    }
    Comment c = new Comment(new Comment.Key(ChangeUtil.messageUuid(), path, psId.get()), ctx.getUser().getAccountId(), ctx.getWhen(), side, message, serverId, unresolved);
    c.parentUuid = parentUuid;
    ctx.getUser().updateRealAccountId(c::setRealAuthor);
    return c;
}
#end_block

#method_before
public RobotComment newRobotComment(ChangeContext ctx, String path, PatchSet.Id psId, short side, String message, String robotId, String robotRunId) throws OrmException {
    RobotComment c = new RobotComment(new Comment.Key(ChangeUtil.messageUUID(ctx.getDb()), path, psId.get()), ctx.getUser().getAccountId(), ctx.getWhen(), side, message, serverId, robotId, robotRunId);
    ctx.getUser().updateRealAccountId(c::setRealAuthor);
    return c;
}
#method_after
public RobotComment newRobotComment(ChangeContext ctx, String path, PatchSet.Id psId, short side, String message, String robotId, String robotRunId) {
    RobotComment c = new RobotComment(new Comment.Key(ChangeUtil.messageUuid(), path, psId.get()), ctx.getUser().getAccountId(), ctx.getWhen(), side, message, serverId, robotId, robotRunId);
    ctx.getUser().updateRealAccountId(c::setRealAuthor);
    return c;
}
#end_block

#method_before
public void deleteComments(ReviewDb db, ChangeUpdate update, Iterable<Comment> comments) throws OrmException {
    for (Comment c : comments) {
        update.deleteComment(c);
    }
    if (PrimaryStorage.of(update.getChange()) == REVIEW_DB) {
        // Avoid OrmConcurrencyException trying to delete non-existent entities.
        db.patchComments().delete(toPatchLineComments(update.getId(), PatchLineComment.Status.DRAFT, comments));
    }
}
#method_after
public void deleteComments(ReviewDb db, ChangeUpdate update, Iterable<Comment> comments) throws OrmException {
    for (Comment c : comments) {
        update.deleteComment(c);
    }
    db.patchComments().delete(toPatchLineComments(update.getId(), PatchLineComment.Status.DRAFT, comments));
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (Repository git = repoManager.openRepository(allUsersName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git)) {
        ProjectConfig config = ProjectConfig.read(md);
        config.getAccessSection(RefNames.REFS_USERS + "*", true).remove(new Permission(Permission.READ));
        GroupReference registered = SystemGroupBackend.getGroup(REGISTERED_USERS);
        AccessSection users = config.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true);
        grant(config, users, Permission.READ, true, registered);
        grant(config, users, Permission.PUSH, true, registered);
        grant(config, users, Permission.SUBMIT, true, registered);
        for (LabelType lt : getLabelTypes(config)) {
            if ("Code-Review".equals(lt.getName()) || "Verified".equals(lt.getName())) {
                grant(config, users, lt, lt.getMin().getValue(), lt.getMax().getValue(), registered);
            }
        }
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(COMMIT_MSG);
        config.commit(md);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (Repository git = repoManager.openRepository(allUsersName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git)) {
        ProjectConfig config = ProjectConfig.read(md);
        config.getAccessSection(RefNames.REFS_USERS + "*", true).remove(new Permission(Permission.READ));
        GroupReference registered = systemGroupBackend.getGroup(REGISTERED_USERS);
        AccessSection users = config.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true);
        grant(config, users, Permission.READ, true, registered);
        grant(config, users, Permission.PUSH, true, registered);
        grant(config, users, Permission.SUBMIT, true, registered);
        for (LabelType lt : getLabelTypes(config)) {
            if ("Code-Review".equals(lt.getName()) || "Verified".equals(lt.getName())) {
                grant(config, users, lt, lt.getMin().getValue(), lt.getMax().getValue(), registered);
            }
        }
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(COMMIT_MSG);
        config.commit(md);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#end_block

#method_before
private boolean search(Set<AccountGroup.UUID> ids) {
    return user.getEffectiveGroups().containsAnyOf(ids);
}
#method_after
private boolean search(Iterable<AccountGroup.UUID> ids) {
    return user.getEffectiveGroups().containsAnyOf(ids);
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void delete() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void review(ReviewInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void review(ReviewInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void submit() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void submit() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void submit(SubmitInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void submit(SubmitInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void publish() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void publish() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi cherryPick(CherryPickInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi rebase() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi rebase() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi rebase(RebaseInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi rebase(RebaseInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void setReviewed(String path, boolean reviewed) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Set<String> reviewed() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Set<String> reviewed() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public MergeableInfo mergeable() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public MergeableInfo mergeable() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public MergeableInfo mergeableOtherBranches() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public MergeableInfo mergeableOtherBranches() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, FileInfo> files(String base) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, FileInfo> files(int parentNum) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, FileInfo> files(int parentNum) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, FileInfo> files() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, FileInfo> files() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<CommentInfo> commentsAsList() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<CommentInfo> commentsAsList() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<CommentInfo> draftsAsList() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<CommentInfo> draftsAsList() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<RobotCommentInfo> robotCommentsAsList() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<RobotCommentInfo> robotCommentsAsList() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DraftApi createDraft(DraftInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public DraftApi createDraft(DraftInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DraftApi draft(String id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public DraftApi draft(String id) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public CommentApi comment(String id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public CommentApi comment(String id) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public RobotCommentApi robotComment(String id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public RobotCommentApi robotComment(String id) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult patch() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult patch() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult patch(String path) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult patch(String path) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, ActionInfo> actions() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, ActionInfo> actions() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SubmitType submitType() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SubmitType submitType() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult submitPreview() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult submitPreview() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult submitPreview() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult submitPreview(String format) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SubmitType testSubmitType(TestSubmitRuleInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SubmitType testSubmitType(TestSubmitRuleInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public MergeListRequest getMergeList() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public MergeListRequest getMergeList() {
    throw new NotImplementedException();
}
#end_block

#method_before
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._accountId();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.hasValue()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#method_after
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        Short labelMaxValue = label.valueSet().isEmpty() ? null : LabelInfo.parseValue(label.maxValue());
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._accountId();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (labelMaxValue != null && ai.permittedVotingRange() != null && ai.permittedVotingRange().max() == labelMaxValue) {
                    ad.votable(name + " (" + label.maxValue() + ") ");
                } else if (ai.hasValue()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException | NoSuchChangeException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    try {
        return updateByMerge.apply(change, in).value();
    } catch (IOException | UpdateException | InvalidChangeOperationException | NoSuchChangeException | OrmException e) {
        throw new RestApiException("Cannot update change by merge", e);
    }
}
#method_after
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    try {
        return updateByMerge.apply(change, in).value();
    } catch (IOException | UpdateException | InvalidChangeOperationException | OrmException e) {
        throw new RestApiException("Cannot update change by merge", e);
    }
}
#end_block

#method_before
@Override
public EditInfo getEdit() throws RestApiException {
    try {
        Response<EditInfo> edit = editDetail.apply(change);
        return edit.isNone() ? null : edit.value();
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot retrieve change edit", e);
    }
}
#method_after
@Override
public EditInfo getEdit() throws RestApiException {
    return edit().get().orElse(null);
}
#end_block

#method_before
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (UpdateException e) {
        throw new RestApiException("Cannot delete assignee", e);
    }
}
#method_after
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (UpdateException | OrmException e) {
        throw new RestApiException("Cannot delete assignee", e);
    }
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    final long startNanos = System.nanoTime();
    long auditStartTs = TimeUtil.nowMs();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    long responseBytes = -1;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    RestResource rsrc = TopLevelResource.INSTANCE;
    ViewData viewData = null;
    try {
        if (isCorsPreflight(req)) {
            doCorsPreflight(req, res);
            return;
        }
        checkCors(req, res);
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        CapabilityUtils.checkRequiresCapability(globals.currentUser, null, rc.getClass());
        viewData = new ViewData(null, null);
        if (path.isEmpty()) {
            if (isRead(req)) {
                viewData = new ViewData(null, rc.list());
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                viewData = new ViewData(null, ac.post(rsrc));
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    viewData = new ViewData(null, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, rc, req.getMethod(), path);
            }
        }
        checkRequiresCapability(viewData);
        while (viewData.view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) viewData.view;
            if (path.isEmpty()) {
                if (isRead(req)) {
                    viewData = new ViewData(null, c.list());
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    viewData = new ViewData(null, ac.post(rsrc));
                } else if (c instanceof AcceptsDelete && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(null, ac.delete(rsrc, null));
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            }
            IdString id = path.remove(0);
            try {
                rsrc = c.parse(rsrc, id);
                checkPreconditions(req);
                viewData = new ViewData(null, null);
            } catch (ResourceNotFoundException e) {
                if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else if (c instanceof AcceptsDelete && path.isEmpty() && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.delete(rsrc, id));
                    status = SC_NO_CONTENT;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, c, req.getMethod(), path);
            }
            checkRequiresCapability(viewData);
        }
        if (notModified(req, rsrc, viewData.view)) {
            res.sendError(SC_NOT_MODIFIED);
            return;
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(viewData.view, params, req, res)) {
            return;
        }
        if (viewData.view instanceof RestReadView<?> && isRead(req)) {
            result = ((RestReadView<RestResource>) viewData.view).apply(rsrc);
        } else if (viewData.view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) viewData.view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response<?> r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, rsrc, viewData.view, r.caching());
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else if (result instanceof Response.Accepted) {
            CacheHeaders.setNotCacheable(res);
            res.setStatus(SC_ACCEPTED);
            res.setHeader(HttpHeaders.LOCATION, ((Response.Accepted) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                responseBytes = replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                responseBytes = replyJson(req, res, config, result);
            }
        }
    } catch (MalformedJsonException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (JsonParseException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (BadRequestException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, messageOr(e, "Bad Request"), e.caching(), e);
    } catch (AuthException e) {
        responseBytes = replyError(req, res, status = SC_FORBIDDEN, messageOr(e, "Forbidden"), e.caching(), e);
    } catch (AmbiguousViewException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Ambiguous"), e);
    } catch (ResourceNotFoundException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Not Found"), e.caching(), e);
    } catch (MethodNotAllowedException e) {
        responseBytes = replyError(req, res, status = SC_METHOD_NOT_ALLOWED, messageOr(e, "Method Not Allowed"), e.caching(), e);
    } catch (ResourceConflictException e) {
        responseBytes = replyError(req, res, status = SC_CONFLICT, messageOr(e, "Conflict"), e.caching(), e);
    } catch (PreconditionFailedException e) {
        responseBytes = replyError(req, res, status = SC_PRECONDITION_FAILED, messageOr(e, "Precondition Failed"), e.caching(), e);
    } catch (UnprocessableEntityException e) {
        responseBytes = replyError(req, res, status = SC_UNPROCESSABLE_ENTITY, messageOr(e, "Unprocessable Entity"), e.caching(), e);
    } catch (NotImplementedException e) {
        responseBytes = replyError(req, res, status = SC_NOT_IMPLEMENTED, messageOr(e, "Not Implemented"), e);
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        responseBytes = handleException(e, req, res);
    } finally {
        String metric = viewData != null && viewData.view != null ? globals.metrics.view(viewData) : "_unknown";
        globals.metrics.count.increment(metric);
        if (status >= SC_BAD_REQUEST) {
            globals.metrics.errorCount.increment(metric, status);
        }
        if (responseBytes != -1) {
            globals.metrics.responseBytes.record(metric, responseBytes);
        }
        globals.metrics.serverLatency.record(metric, System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
        globals.auditService.dispatch(new ExtendedHttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req, auditStartTs, params, inputRequestBody, status, result, rsrc, viewData == null ? null : viewData.view));
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    final long startNanos = System.nanoTime();
    long auditStartTs = TimeUtil.nowMs();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    long responseBytes = -1;
    Object result = null;
    ListMultimap<String, String> params = MultimapBuilder.hashKeys().arrayListValues().build();
    ListMultimap<String, String> config = MultimapBuilder.hashKeys().arrayListValues().build();
    Object inputRequestBody = null;
    RestResource rsrc = TopLevelResource.INSTANCE;
    ViewData viewData = null;
    try {
        if (isCorsPreflight(req)) {
            doCorsPreflight(req, res);
            return;
        }
        checkCors(req, res);
        checkUserSession(req);
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        CapabilityUtils.checkRequiresCapability(globals.currentUser, null, rc.getClass());
        viewData = new ViewData(null, null);
        if (path.isEmpty()) {
            if (rc instanceof NeedsParams) {
                ((NeedsParams) rc).setParams(params);
            }
            if (isRead(req)) {
                viewData = new ViewData(null, rc.list());
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                viewData = new ViewData(null, ac.post(rsrc));
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    viewData = new ViewData(null, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, rc, req.getMethod(), path);
            }
        }
        checkRequiresCapability(viewData);
        while (viewData.view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) viewData.view;
            if (path.isEmpty()) {
                if (isRead(req)) {
                    viewData = new ViewData(null, c.list());
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    viewData = new ViewData(null, ac.post(rsrc));
                } else if (c instanceof AcceptsDelete && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(null, ac.delete(rsrc, null));
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            }
            IdString id = path.remove(0);
            try {
                rsrc = c.parse(rsrc, id);
                checkPreconditions(req);
                viewData = new ViewData(null, null);
            } catch (ResourceNotFoundException e) {
                if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else if (c instanceof AcceptsDelete && path.isEmpty() && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(viewData.pluginName, ac.delete(rsrc, id));
                    status = SC_NO_CONTENT;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, c, req.getMethod(), path);
            }
            checkRequiresCapability(viewData);
        }
        if (notModified(req, rsrc, viewData.view)) {
            res.sendError(SC_NOT_MODIFIED);
            return;
        }
        if (!globals.paramParser.get().parse(viewData.view, params, req, res)) {
            return;
        }
        if (viewData.view instanceof RestReadView<?> && isRead(req)) {
            result = ((RestReadView<RestResource>) viewData.view).apply(rsrc);
        } else if (viewData.view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) viewData.view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response<?> r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, rsrc, viewData.view, r.caching());
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else if (result instanceof Response.Accepted) {
            CacheHeaders.setNotCacheable(res);
            res.setStatus(SC_ACCEPTED);
            res.setHeader(HttpHeaders.LOCATION, ((Response.Accepted) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                responseBytes = replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                responseBytes = replyJson(req, res, config, result);
            }
        }
    } catch (MalformedJsonException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (JsonParseException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (BadRequestException e) {
        responseBytes = replyError(req, res, status = SC_BAD_REQUEST, messageOr(e, "Bad Request"), e.caching(), e);
    } catch (AuthException e) {
        responseBytes = replyError(req, res, status = SC_FORBIDDEN, messageOr(e, "Forbidden"), e.caching(), e);
    } catch (AmbiguousViewException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Ambiguous"), e);
    } catch (ResourceNotFoundException e) {
        responseBytes = replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Not Found"), e.caching(), e);
    } catch (MethodNotAllowedException e) {
        responseBytes = replyError(req, res, status = SC_METHOD_NOT_ALLOWED, messageOr(e, "Method Not Allowed"), e.caching(), e);
    } catch (ResourceConflictException e) {
        responseBytes = replyError(req, res, status = SC_CONFLICT, messageOr(e, "Conflict"), e.caching(), e);
    } catch (PreconditionFailedException e) {
        responseBytes = replyError(req, res, status = SC_PRECONDITION_FAILED, messageOr(e, "Precondition Failed"), e.caching(), e);
    } catch (UnprocessableEntityException e) {
        responseBytes = replyError(req, res, status = SC_UNPROCESSABLE_ENTITY, messageOr(e, "Unprocessable Entity"), e.caching(), e);
    } catch (NotImplementedException e) {
        responseBytes = replyError(req, res, status = SC_NOT_IMPLEMENTED, messageOr(e, "Not Implemented"), e);
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        responseBytes = handleException(e, req, res);
    } finally {
        String metric = viewData != null && viewData.view != null ? globals.metrics.view(viewData) : "_unknown";
        globals.metrics.count.increment(metric);
        if (status >= SC_BAD_REQUEST) {
            globals.metrics.errorCount.increment(metric, status);
        }
        if (responseBytes != -1) {
            globals.metrics.responseBytes.record(metric, responseBytes);
        }
        globals.metrics.serverLatency.record(metric, System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
        globals.auditService.dispatch(new ExtendedHttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req, auditStartTs, params, inputRequestBody, status, result, rsrc, viewData == null ? null : viewData.view));
    }
}
#end_block

#method_before
public static long replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    TemporaryBuffer.Heap buf = heap(HEAP_EST_SIZE, Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    return replyBinaryResult(req, res, asBinaryResult(buf).setContentType(JSON_TYPE).setCharacterEncoding(UTF_8));
}
#method_after
public static long replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, ListMultimap<String, String> config, Object result) throws IOException {
    TemporaryBuffer.Heap buf = heap(HEAP_EST_SIZE, Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    return replyBinaryResult(req, res, asBinaryResult(buf).setContentType(JSON_TYPE).setCharacterEncoding(UTF_8));
}
#end_block

#method_before
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder();
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#method_after
private static Gson newGson(ListMultimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder();
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#end_block

#method_before
private static void enablePrettyPrint(GsonBuilder gb, Multimap<String, String> config, @Nullable HttpServletRequest req) {
    String pp = Iterables.getFirst(config.get("pp"), null);
    if (pp == null) {
        pp = Iterables.getFirst(config.get("prettyPrint"), null);
        if (pp == null && req != null) {
            pp = acceptsJson(req) ? "0" : "1";
        }
    }
    if ("1".equals(pp) || "true".equals(pp)) {
        gb.setPrettyPrinting();
    }
}
#method_after
private static void enablePrettyPrint(GsonBuilder gb, ListMultimap<String, String> config, @Nullable HttpServletRequest req) {
    String pp = Iterables.getFirst(config.get("pp"), null);
    if (pp == null) {
        pp = Iterables.getFirst(config.get("prettyPrint"), null);
        if (pp == null && req != null) {
            pp = acceptsJson(req) ? "0" : "1";
        }
    }
    if ("1".equals(pp) || "true".equals(pp)) {
        gb.setPrettyPrinting();
    }
}
#end_block

#method_before
private static void enablePartialGetFields(GsonBuilder gb, Multimap<String, String> config) {
    final Set<String> want = new HashSet<>();
    for (String p : config.get("fields")) {
        Iterables.addAll(want, OptionUtil.splitOptionValue(p));
    }
    if (!want.isEmpty()) {
        gb.addSerializationExclusionStrategy(new ExclusionStrategy() {

            private final Map<String, String> names = new HashMap<>();

            @Override
            public boolean shouldSkipField(FieldAttributes field) {
                String name = names.get(field.getName());
                if (name == null) {
                    // Translate and cache the JSON lower_case_style used.
                    try {
                        name = // 
                        FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES.translateName(field.getDeclaringClass().getDeclaredField(field.getName()));
                        names.put(field.getName(), name);
                    } catch (SecurityException e) {
                        return true;
                    } catch (NoSuchFieldException e) {
                        return true;
                    }
                }
                return !want.contains(name);
            }

            @Override
            public boolean shouldSkipClass(Class<?> clazz) {
                return false;
            }
        });
    }
}
#method_after
private static void enablePartialGetFields(GsonBuilder gb, ListMultimap<String, String> config) {
    final Set<String> want = new HashSet<>();
    for (String p : config.get("fields")) {
        Iterables.addAll(want, OptionUtil.splitOptionValue(p));
    }
    if (!want.isEmpty()) {
        gb.addSerializationExclusionStrategy(new ExclusionStrategy() {

            private final Map<String, String> names = new HashMap<>();

            @Override
            public boolean shouldSkipField(FieldAttributes field) {
                String name = names.get(field.getName());
                if (name == null) {
                    // Translate and cache the JSON lower_case_style used.
                    try {
                        name = // 
                        FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES.translateName(field.getDeclaringClass().getDeclaredField(field.getName()));
                        names.put(field.getName(), name);
                    } catch (SecurityException e) {
                        return true;
                    } catch (NoSuchFieldException e) {
                        return true;
                    }
                }
                return !want.contains(name);
            }

            @Override
            public boolean shouldSkipClass(Class<?> clazz) {
                return false;
            }
        });
    }
}
#end_block

#method_before
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isRead(req)) {
        user.setAccessPath(AccessPath.REST_API);
    } else if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
        throw new AuthException("Invalid authentication method. In order to authenticate, " + "prefix the REST endpoint URL with /a/ (e.g. http://example.com/a/projects/).");
    }
}
#method_after
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isRead(req)) {
        user.setAccessPath(AccessPath.REST_API);
        user.setLastLoginExternalIdKey(globals.webSession.get().getLastLoginExternalId());
    } else if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
        throw new AuthException("Invalid authentication method. In order to authenticate, " + "prefix the REST endpoint URL with /a/ (e.g. http://example.com/a/projects/).");
    }
}
#end_block

#method_before
static long replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || isRead(req)) && isMaybeHTML(text)) {
        return replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    }
    if (!text.endsWith("\n")) {
        text += "\n";
    }
    return replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
}
#method_after
static long replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || isRead(req)) && isMaybeHTML(text)) {
        return replyJson(req, res, ImmutableListMultimap.of("pp", "0"), new JsonPrimitive(text));
    }
    if (!text.endsWith("\n")) {
        text += "\n";
    }
    return replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
}
#end_block

#method_before
public SubmitStrategy create(SubmitType submitType, ReviewDb db, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, RevFlag canMergeFlag, Set<RevCommit> alreadyAccepted, Branch.NameKey destBranch, IdentifiedUser caller, MergeTip mergeTip, CommitStatus commits, RequestId submissionId, NotifyHandling notifyHandling, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    SubmitStrategy.Arguments args = argsFactory.create(submitType, destBranch, commits, rw, caller, mergeTip, inserter, repo, canMergeFlag, db, alreadyAccepted, submissionId, notifyHandling, submoduleOp, dryrun);
    switch(submitType) {
        case CHERRY_PICK:
            return new CherryPick(args);
        case FAST_FORWARD_ONLY:
            return new FastForwardOnly(args);
        case MERGE_ALWAYS:
            return new MergeAlways(args);
        case MERGE_IF_NECESSARY:
            return new MergeIfNecessary(args);
        case REBASE_IF_NECESSARY:
            return new RebaseIfNecessary(args);
        case REBASE_ALWAYS:
            return new RebaseAlways(args);
        default:
            String errorMsg = "No submit strategy for: " + submitType;
            log.error(errorMsg);
            throw new IntegrationException(errorMsg);
    }
}
#method_after
public SubmitStrategy create(SubmitType submitType, ReviewDb db, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, RevFlag canMergeFlag, Set<RevCommit> alreadyAccepted, Set<CodeReviewCommit> incoming, Branch.NameKey destBranch, IdentifiedUser caller, MergeTip mergeTip, CommitStatus commitStatus, RequestId submissionId, NotifyHandling notifyHandling, ListMultimap<RecipientType, Account.Id> accountsToNotify, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    SubmitStrategy.Arguments args = argsFactory.create(submitType, destBranch, commitStatus, rw, caller, mergeTip, inserter, repo, canMergeFlag, db, alreadyAccepted, incoming, submissionId, notifyHandling, accountsToNotify, submoduleOp, dryrun);
    switch(submitType) {
        case CHERRY_PICK:
            return new CherryPick(args);
        case FAST_FORWARD_ONLY:
            return new FastForwardOnly(args);
        case MERGE_ALWAYS:
            return new MergeAlways(args);
        case MERGE_IF_NECESSARY:
            return new MergeIfNecessary(args);
        case REBASE_IF_NECESSARY:
            return new RebaseIfNecessary(args);
        case REBASE_ALWAYS:
            return new RebaseAlways(args);
        default:
            String errorMsg = "No submit strategy for: " + submitType;
            log.error(errorMsg);
            throw new IntegrationException(errorMsg);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    String psDescription = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        psDescription = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null, psDescription);
    update.setPsDescription(psDescription);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = ChangeMessagesUtil.newMessage(ctx.getDb(), patchSetId, ctx.getUser(), ctx.getWhen(), message.toString(), ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    String psDescription = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        psDescription = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null, psDescription);
    update.setPsDescription(psDescription);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = ChangeMessagesUtil.newMessage(patchSetId, ctx.getUser(), ctx.getWhen(), message.toString(), ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(final Context ctx) throws Exception {
    // Normally the ref updated hook is fired by BatchUpdate, but ReplaceOp is
    // special because its ref is actually updated by ReceiveCommits, so from
    // BatchUpdate's perspective there is no ref update. Thus we have to fire it
    // manually.
    final Account account = ctx.getAccount();
    if (!updateRef) {
        gitRefUpdated.fire(ctx.getProject(), newPatchSet.getRefName(), ObjectId.zeroId(), commit, account);
    }
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), change.getId());
                    cm.setFrom(account.getId());
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
                    if (magicBranch != null && magicBranch.notify != null) {
                        cm.setNotify(magicBranch.notify);
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    NotifyHandling notify = magicBranch != null && magicBranch.notify != null ? magicBranch.notify : NotifyHandling.ALL;
    revisionCreated.fire(change, newPatchSet, ctx.getAccount(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#method_after
@Override
public void postUpdate(final Context ctx) throws Exception {
    // Normally the ref updated hook is fired by BatchUpdate, but ReplaceOp is
    // special because its ref is actually updated by ReceiveCommits, so from
    // BatchUpdate's perspective there is no ref update. Thus we have to fire it
    // manually.
    final Account account = ctx.getAccount();
    if (!updateRef) {
        gitRefUpdated.fire(ctx.getProject(), newPatchSet.getRefName(), ObjectId.zeroId(), commit, account);
    }
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), change.getId());
                    cm.setFrom(account.getId());
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
                    if (magicBranch != null) {
                        cm.setNotify(magicBranch.notify);
                        cm.setAccountsToNotify(magicBranch.getAccountsToNotify());
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    NotifyHandling notify = magicBranch != null && magicBranch.notify != null ? magicBranch.notify : NotifyHandling.ALL;
    revisionCreated.fire(change, newPatchSet, ctx.getAccount(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#end_block

#method_before
private void fireCommentAddedEvent(final Context ctx) throws NoSuchChangeException, OrmException {
    if (approvals.isEmpty()) {
        return;
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
    List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
    Map<String, Short> allApprovals = new HashMap<>();
    Map<String, Short> oldApprovals = new HashMap<>();
    for (LabelType lt : labels) {
        allApprovals.put(lt.getName(), (short) 0);
        oldApprovals.put(lt.getName(), null);
    }
    for (Map.Entry<String, Short> entry : approvals.entrySet()) {
        if (entry.getValue() != 0) {
            allApprovals.put(entry.getKey(), entry.getValue());
            oldApprovals.put(entry.getKey(), (short) 0);
        }
    }
    commentAdded.fire(change, newPatchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
}
#method_after
private void fireCommentAddedEvent(Context ctx) throws OrmException {
    if (approvals.isEmpty()) {
        return;
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
    List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
    Map<String, Short> allApprovals = new HashMap<>();
    Map<String, Short> oldApprovals = new HashMap<>();
    for (LabelType lt : labels) {
        allApprovals.put(lt.getName(), (short) 0);
        oldApprovals.put(lt.getName(), null);
    }
    for (Map.Entry<String, Short> entry : approvals.entrySet()) {
        if (entry.getValue() != 0) {
            allApprovals.put(entry.getKey(), entry.getValue());
            oldApprovals.put(entry.getKey(), (short) 0);
        }
    }
    commentAdded.fire(change, newPatchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
}
#end_block

#method_before
@Override
public AddReviewerResult apply(ChangeResource rsrc, AddReviewerInput input) throws IOException, OrmException, RestApiException, UpdateException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    Addition addition = prepareApplication(rsrc, input);
    if (addition.op == null) {
        return addition.result;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, addition.op);
        bu.execute();
        addition.gatherResults();
    }
    return addition.result;
}
#method_after
@Override
public AddReviewerResult apply(ChangeResource rsrc, AddReviewerInput input) throws IOException, OrmException, RestApiException, UpdateException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    Addition addition = prepareApplication(rsrc, input, true);
    if (addition.op == null) {
        return addition.result;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, addition.op);
        bu.execute();
        addition.gatherResults();
    }
    return addition.result;
}
#end_block

#method_before
public Addition prepareApplication(ChangeResource rsrc, AddReviewerInput input) throws OrmException, RestApiException, IOException {
    Account.Id accountId;
    try {
        accountId = accounts.parse(input.reviewer).getAccountId();
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
    return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.state(), input.notify);
}
#method_after
public Addition prepareApplication(ChangeResource rsrc, AddReviewerInput input, boolean allowGroup) throws OrmException, RestApiException, IOException {
    Account.Id accountId;
    try {
        accountId = accounts.parse(input.reviewer).getAccountId();
    } catch (UnprocessableEntityException e) {
        if (allowGroup) {
            try {
                return putGroup(rsrc, input);
            } catch (UnprocessableEntityException e2) {
                throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFoundUserOrGroup, input.reviewer));
            }
        }
        throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFoundUser, input.reviewer));
    }
    return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.state(), input.notify, notifyUtil.resolveAccounts(input.notifyDetails));
}
#end_block

#method_before
Addition ccCurrentUser(CurrentUser user, RevisionResource revision) {
    return new Addition(user.getUserName(), revision.getChangeResource(), ImmutableMap.of(user.getAccountId(), revision.getControl()), CC, NotifyHandling.NONE);
}
#method_after
Addition ccCurrentUser(CurrentUser user, RevisionResource revision) {
    return new Addition(user.getUserName(), revision.getChangeResource(), ImmutableMap.of(user.getAccountId(), revision.getControl()), CC, NotifyHandling.NONE, ImmutableListMultimap.of());
}
#end_block

#method_before
private Addition putAccount(String reviewer, ReviewerResource rsrc, ReviewerState state, NotifyHandling notify) throws UnprocessableEntityException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    if (isValidReviewer(member, control)) {
        return new Addition(reviewer, rsrc.getChangeResource(), ImmutableMap.of(member.getId(), control), state, notify);
    }
    if (member.isActive()) {
        throw new UnprocessableEntityException(String.format("Change not visible to %s", reviewer));
    }
    throw new UnprocessableEntityException(String.format("Account of %s is inactive.", reviewer));
}
#method_after
private Addition putAccount(String reviewer, ReviewerResource rsrc, ReviewerState state, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws UnprocessableEntityException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    if (isValidReviewer(member, control)) {
        return new Addition(reviewer, rsrc.getChangeResource(), ImmutableMap.of(member.getId(), control), state, notify, accountsToNotify);
    }
    if (member.isActive()) {
        throw new UnprocessableEntityException(String.format("Change not visible to %s", reviewer));
    }
    throw new UnprocessableEntityException(String.format("Account of %s is inactive.", reviewer));
}
#end_block

#method_before
private Addition putGroup(ChangeResource rsrc, AddReviewerInput input) throws RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName()));
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName()));
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        return fail(input.reviewer, true, MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size()));
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    return new Addition(input.reviewer, rsrc, reviewers, input.state(), input.notify);
}
#method_after
private Addition putGroup(ChangeResource rsrc, AddReviewerInput input) throws RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName()));
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        return fail(input.reviewer, MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName()));
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        return fail(input.reviewer, true, MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size()));
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    return new Addition(input.reviewer, rsrc, reviewers, input.state(), input.notify, notifyUtil.resolveAccounts(input.notifyDetails));
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    if (addedReviewers != null || addedCCs != null) {
        if (addedReviewers == null) {
            addedReviewers = new ArrayList<>();
        }
        if (addedCCs == null) {
            addedCCs = new ArrayList<>();
        }
        emailReviewers(rsrc.getChange(), Lists.transform(addedReviewers, r -> r.getAccountId()), addedCCs, notify);
        if (!addedReviewers.isEmpty()) {
            List<Account> reviewers = Lists.transform(addedReviewers, psa -> accountCache.get(psa.getAccountId()).getAccount());
            reviewerAdded.fire(rsrc.getChange(), patchSet, reviewers, ctx.getAccount(), ctx.getWhen());
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws Exception {
    if (addedReviewers != null || addedCCs != null) {
        if (addedReviewers == null) {
            addedReviewers = new ArrayList<>();
        }
        if (addedCCs == null) {
            addedCCs = new ArrayList<>();
        }
        emailReviewers(rsrc.getChange(), Lists.transform(addedReviewers, r -> r.getAccountId()), addedCCs, notify, accountsToNotify);
        if (!addedReviewers.isEmpty()) {
            List<Account> reviewers = Lists.transform(addedReviewers, psa -> accountCache.get(psa.getAccountId()).getAccount());
            reviewerAdded.fire(rsrc.getChange(), patchSet, reviewers, ctx.getAccount(), ctx.getWhen());
        }
    }
}
#end_block

#method_before
public void emailReviewers(Change change, Collection<Account.Id> added, Collection<Account.Id> copied, NotifyHandling notify) {
    if (added.isEmpty() && copied.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (Account.Id id : added) {
        if (!id.equals(userId)) {
            toMail.add(id);
        }
    }
    List<Account.Id> toCopy = Lists.newArrayListWithCapacity(copied.size());
    for (Account.Id id : copied) {
        if (!id.equals(userId)) {
            toCopy.add(id);
        }
    }
    if (toMail.isEmpty() && toCopy.isEmpty()) {
        return;
    }
    try {
        AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId(), notify);
        cm.setFrom(userId);
        cm.addReviewers(toMail);
        cm.addExtraCC(toCopy);
        cm.send();
    } catch (Exception err) {
        log.error("Cannot send email to new reviewers of change " + change.getId(), err);
    }
}
#method_after
public void emailReviewers(Change change, Collection<Account.Id> added, Collection<Account.Id> copied, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) {
    if (added.isEmpty() && copied.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (Account.Id id : added) {
        if (!id.equals(userId)) {
            toMail.add(id);
        }
    }
    List<Account.Id> toCopy = Lists.newArrayListWithCapacity(copied.size());
    for (Account.Id id : copied) {
        if (!id.equals(userId)) {
            toCopy.add(id);
        }
    }
    if (toMail.isEmpty() && toCopy.isEmpty()) {
        return;
    }
    try {
        AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
        if (notify != null) {
            cm.setNotify(notify);
        }
        cm.setAccountsToNotify(accountsToNotify);
        cm.setFrom(userId);
        cm.addReviewers(toMail);
        cm.addExtraCC(toCopy);
        cm.send();
    } catch (Exception err) {
        log.error("Cannot send email to new reviewers of change " + change.getId(), err);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Project.NameKey project = getProjectKey();
    CallbackGroup cbg = new CallbackGroup();
    AccessMap.get(project, cbg.add(new GerritCallback<ProjectAccessInfo>() {

        @Override
        public void onSuccess(ProjectAccessInfo result) {
            isOwner = result.isOwner();
            enableForm();
            saveProject.setVisible(isOwner);
        }
    }));
    ProjectApi.getConfig(project, cbg.addFinal(new ScreenLoadCallback<ConfigInfo>(this) {

        @Override
        public void preDisplay(ConfigInfo result) {
            display(result);
        }
    }));
    savedPanel = INFO;
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Project.NameKey project = getProjectKey();
    CallbackGroup cbg = new CallbackGroup();
    AccessMap.get(project, cbg.add(new GerritCallback<ProjectAccessInfo>() {

        @Override
        public void onSuccess(ProjectAccessInfo result) {
            isOwner = result.isOwner();
            configVisible = result.configVisible();
            enableForm();
            saveProject.setVisible(isOwner);
        }
    }));
    ProjectApi.getConfig(project, cbg.addFinal(new ScreenLoadCallback<ConfigInfo>(this) {

        @Override
        public void preDisplay(ConfigInfo result) {
            display(result);
        }
    }));
    savedPanel = INFO;
}
#end_block

#method_before
private void initProjectActions(ConfigInfo info) {
    actionsGrid.clear(true);
    actionsGrid.removeAllRows();
    boolean showCreateChange = Gerrit.isSignedIn();
    NativeMap<ActionInfo> actions = info.actions();
    if (actions == null) {
        actions = NativeMap.create().cast();
    }
    if (actions.isEmpty() && !showCreateChange) {
        return;
    }
    actions.copyKeysIntoChildren("id");
    actionsGrid.addHeader(new SmallHeading(Util.C.headingProjectCommands()));
    FlowPanel actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().projectActions());
    actionsPanel.setVisible(true);
    actionsGrid.add(Util.C.headingCommands(), actionsPanel);
    for (String id : actions.keySet()) {
        actionsPanel.add(new ActionButton(getProjectKey(), actions.get(id)));
    }
    // HEAD. This would have to happen on the server side.
    if (showCreateChange) {
        actionsPanel.add(createChangeAction());
    }
    if (isOwner) {
        actionsPanel.add(createEditConfigAction());
    }
}
#method_after
private void initProjectActions(ConfigInfo info) {
    actionsGrid.clear(true);
    actionsGrid.removeAllRows();
    boolean showCreateChange = Gerrit.isSignedIn();
    NativeMap<ActionInfo> actions = info.actions();
    if (actions == null) {
        actions = NativeMap.create().cast();
    }
    if (actions.isEmpty() && !showCreateChange) {
        return;
    }
    actions.copyKeysIntoChildren("id");
    actionsGrid.addHeader(new SmallHeading(Util.C.headingProjectCommands()));
    FlowPanel actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().projectActions());
    actionsPanel.setVisible(true);
    actionsGrid.add(Util.C.headingCommands(), actionsPanel);
    for (String id : actions.keySet()) {
        actionsPanel.add(new ActionButton(getProjectKey(), actions.get(id)));
    }
    // HEAD. This would have to happen on the server side.
    if (showCreateChange) {
        actionsPanel.add(createChangeAction());
    }
    if (isOwner && configVisible) {
        actionsPanel.add(createEditConfigAction());
    }
}
#end_block

#method_before
@Override
public ProjectResource parse(TopLevelResource parent, IdString id) throws ResourceNotFoundException, IOException {
    ProjectResource rsrc = _parse(id.get());
    if (rsrc == null) {
        throw new ResourceNotFoundException(id);
    }
    return rsrc;
}
#method_after
@Override
public ProjectResource parse(TopLevelResource parent, IdString id) throws ResourceNotFoundException, IOException {
    ProjectResource rsrc = _parse(id.get(), true);
    if (rsrc == null) {
        throw new ResourceNotFoundException(id);
    }
    return rsrc;
}
#end_block

#method_before
public ProjectResource parse(String id) throws UnprocessableEntityException, IOException {
    ProjectResource rsrc = _parse(id);
    if (rsrc == null) {
        throw new UnprocessableEntityException(String.format("Project Not Found: %s", id));
    }
    return rsrc;
}
#method_after
public ProjectResource parse(String id) throws UnprocessableEntityException, IOException {
    return parse(id, true);
}
#end_block

#method_before
public ProjectResource parse(String id) throws UnprocessableEntityException, IOException {
    ProjectResource rsrc = _parse(id);
    if (rsrc == null) {
        throw new UnprocessableEntityException(String.format("Project Not Found: %s", id));
    }
    return rsrc;
}
#method_after
public ProjectResource parse(String id, boolean checkVisibility) throws UnprocessableEntityException, IOException {
    ProjectResource rsrc = _parse(id, checkVisibility);
    if (rsrc == null) {
        throw new UnprocessableEntityException(String.format("Project Not Found: %s", id));
    }
    return rsrc;
}
#end_block

#method_before
private ProjectResource _parse(String id) throws IOException {
    if (id.endsWith(Constants.DOT_GIT_EXT)) {
        id = id.substring(0, id.length() - Constants.DOT_GIT_EXT.length());
    }
    ProjectControl ctl;
    try {
        ctl = controlFactory.controlFor(new Project.NameKey(id), user.get());
    } catch (NoSuchProjectException e) {
        return null;
    }
    if (!ctl.isVisible() && !ctl.isOwner()) {
        return null;
    }
    return new ProjectResource(ctl);
}
#method_after
private ProjectResource _parse(String id, boolean checkVisibility) throws IOException {
    if (id.endsWith(Constants.DOT_GIT_EXT)) {
        id = id.substring(0, id.length() - Constants.DOT_GIT_EXT.length());
    }
    ProjectControl ctl;
    try {
        ctl = controlFactory.controlFor(new Project.NameKey(id), user.get());
    } catch (NoSuchProjectException e) {
        return null;
    }
    if (checkVisibility && !ctl.isVisible() && !ctl.isOwner()) {
        return null;
    }
    return new ProjectResource(ctl);
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(ChangeResource rsrc, AssigneeInput input) throws RestApiException, UpdateException, OrmException, IOException {
    if (!rsrc.getControl().canEditAssignee()) {
        throw new AuthException("Changing Assignee not permitted");
    }
    if (Strings.isNullOrEmpty(input.assignee)) {
        throw new BadRequestException("missing assignee field");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), TimeUtil.nowTs())) {
        SetAssigneeOp op = assigneeFactory.create(input.assignee);
        bu.addOp(rsrc.getId(), op);
        PostReviewers.Addition reviewersAddition = addAssigneeAsCC(rsrc, input.assignee);
        bu.addOp(rsrc.getId(), reviewersAddition.op);
        bu.execute();
        return Response.ok(AccountJson.toAccountInfo(op.getNewAssignee()));
    }
}
#method_after
@Override
public Response<AccountInfo> apply(ChangeResource rsrc, AssigneeInput input) throws RestApiException, UpdateException, OrmException, IOException {
    if (!rsrc.getControl().canEditAssignee()) {
        throw new AuthException("Changing Assignee not permitted");
    }
    if (input.assignee == null || input.assignee.trim().isEmpty()) {
        throw new BadRequestException("missing assignee field");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), TimeUtil.nowTs())) {
        SetAssigneeOp op = assigneeFactory.create(input.assignee);
        bu.addOp(rsrc.getId(), op);
        PostReviewers.Addition reviewersAddition = addAssigneeAsCC(rsrc, input.assignee);
        bu.addOp(rsrc.getId(), reviewersAddition.op);
        bu.execute();
        return Response.ok(accountLoaderFactory.create(true).fillOne(op.getNewAssignee()));
    }
}
#end_block

#method_before
private Addition addAssigneeAsCC(ChangeResource rsrc, String assignee) throws OrmException, RestApiException, IOException {
    AddReviewerInput reviewerInput = new AddReviewerInput();
    reviewerInput.reviewer = assignee;
    reviewerInput.state = ReviewerState.CC;
    reviewerInput.confirmed = true;
    reviewerInput.notify = NotifyHandling.NONE;
    return postReviewers.prepareApplication(rsrc, reviewerInput);
}
#method_after
private Addition addAssigneeAsCC(ChangeResource rsrc, String assignee) throws OrmException, RestApiException, IOException {
    AddReviewerInput reviewerInput = new AddReviewerInput();
    reviewerInput.reviewer = assignee;
    reviewerInput.state = ReviewerState.CC;
    reviewerInput.confirmed = true;
    reviewerInput.notify = NotifyHandling.NONE;
    return postReviewers.prepareApplication(rsrc, reviewerInput, false);
}
#end_block

#method_before
@Override
public ChangeEditResource parse(ChangeResource rsrc, IdString id) throws ResourceNotFoundException, AuthException, IOException, InvalidChangeOperationException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        throw new ResourceNotFoundException(id);
    }
    return new ChangeEditResource(rsrc, edit.get(), id.get());
}
#method_after
@Override
public ChangeEditResource parse(ChangeResource rsrc, IdString id) throws ResourceNotFoundException, AuthException, IOException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        throw new ResourceNotFoundException(id);
    }
    return new ChangeEditResource(rsrc, edit.get(), id.get());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Create create(ChangeResource parent, IdString id) throws RestApiException {
    return createFactory.create(parent.getChange(), id.get());
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Create create(ChangeResource parent, IdString id) throws RestApiException {
    return createFactory.create(id.get());
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource resource, Put.Input input) throws AuthException, IOException, ResourceConflictException, OrmException, InvalidChangeOperationException {
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    if (edit.isPresent()) {
        throw new ResourceConflictException(String.format("edit already exists for the change %s", resource.getId()));
    }
    edit = createEdit(resource);
    if (!Strings.isNullOrEmpty(path)) {
        putEdit.apply(new ChangeEditResource(resource, edit.get(), path), input);
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource resource, Put.Input input) throws AuthException, ResourceConflictException, IOException, OrmException {
    putEdit.apply(resource.getControl(), path, input.content);
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, DeleteFile.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException, BadRequestException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent()) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        editModifier.createEdit(rsrc.getChange(), psUtil.current(db.get(), rsrc.getNotes()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, DeleteFile.Input in) throws IOException, AuthException, ResourceConflictException, OrmException {
    return deleteContent.apply(rsrc.getControl(), path);
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource resource, Post.Input input) throws AuthException, InvalidChangeOperationException, IOException, ResourceConflictException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(resource.getChange());
    if (!edit.isPresent()) {
        edit = createEdit(resource);
    }
    if (input != null) {
        if (!Strings.isNullOrEmpty(input.restorePath)) {
            editModifier.restoreFile(edit.get(), input.restorePath);
        } else if (!Strings.isNullOrEmpty(input.oldPath) && !Strings.isNullOrEmpty(input.newPath)) {
            editModifier.renameFile(edit.get(), input.oldPath, input.newPath);
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource resource, Post.Input input) throws AuthException, IOException, ResourceConflictException, OrmException {
    Project.NameKey project = resource.getProject();
    try (Repository repository = repositoryManager.openRepository(project)) {
        ChangeControl changeControl = resource.getControl();
        if (isRestoreFile(input)) {
            editModifier.restoreFile(repository, changeControl, input.restorePath);
        } else if (isRenameFile(input)) {
            editModifier.renameFile(repository, changeControl, input.oldPath, input.newPath);
        } else {
            editModifier.createEdit(repository, changeControl);
        }
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException {
    String path = rsrc.getPath();
    if (Strings.isNullOrEmpty(path) || path.charAt(0) == '/') {
        throw new ResourceConflictException("Invalid path: " + path);
    }
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), input.content);
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException, OrmException {
    return apply(rsrc.getControl(), rsrc.getPath(), input.content);
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException {
    String path = rsrc.getPath();
    if (Strings.isNullOrEmpty(path) || path.charAt(0) == '/') {
        throw new ResourceConflictException("Invalid path: " + path);
    }
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), input.content);
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
public Response<?> apply(ChangeControl changeControl, String path, RawInput newContent) throws ResourceConflictException, AuthException, IOException, OrmException {
    if (Strings.isNullOrEmpty(path) || path.charAt(0) == '/') {
        throw new ResourceConflictException("Invalid path: " + path);
    }
    Project.NameKey project = changeControl.getChange().getProject();
    try (Repository repository = repositoryManager.openRepository(project)) {
        editModifier.modifyFile(repository, changeControl, path, newContent);
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceConflictException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    return apply(rsrc.getControl(), rsrc.getPath());
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceConflictException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
public Response<?> apply(ChangeControl changeControl, String filePath) throws AuthException, IOException, OrmException, ResourceConflictException {
    Project.NameKey project = changeControl.getChange().getProject();
    try (Repository repository = repositoryManager.openRepository(project)) {
        editModifier.deleteFile(repository, changeControl, filePath);
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc) throws IOException {
    try {
        ChangeEdit edit = rsrc.getChangeEdit();
        return Response.ok(fileContentUtil.getContent(rsrc.getControl().getProjectControl().getProjectState(), base ? ObjectId.fromString(edit.getBasePatchSet().getRevision().get()) : ObjectId.fromString(edit.getRevision().get()), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#method_after
@Override
public Response<BinaryResult> apply(ChangeEditResource rsrc) throws IOException {
    try {
        ChangeEdit edit = rsrc.getChangeEdit();
        return Response.ok(fileContentUtil.getContent(rsrc.getControl().getProjectControl().getProjectState(), base ? ObjectId.fromString(edit.getBasePatchSet().getRevision().get()) : ObjectId.fromString(edit.getRevision().get()), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#end_block

#method_before
@Override
public FileInfo apply(ChangeEditResource rsrc) {
    FileInfo r = new FileInfo();
    ChangeEdit edit = rsrc.getChangeEdit();
    Change change = edit.getChange();
    FluentIterable<DiffWebLinkInfo> links = webLinks.getDiffLinks(change.getProject().get(), change.getChangeId(), edit.getBasePatchSet().getPatchSetId(), edit.getBasePatchSet().getRefName(), rsrc.getPath(), 0, edit.getRefName(), rsrc.getPath());
    r.webLinks = links.isEmpty() ? null : links.toList();
    return r;
}
#method_after
@Override
public FileInfo apply(ChangeEditResource rsrc) {
    FileInfo r = new FileInfo();
    ChangeEdit edit = rsrc.getChangeEdit();
    Change change = edit.getChange();
    List<DiffWebLinkInfo> links = webLinks.getDiffLinks(change.getProject().get(), change.getChangeId(), edit.getBasePatchSet().getPatchSetId(), edit.getBasePatchSet().getRefName(), rsrc.getPath(), 0, edit.getRefName(), rsrc.getPath());
    r.webLinks = links.isEmpty() ? null : links;
    return r;
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc, Input input) throws AuthException, IOException, InvalidChangeOperationException, BadRequestException, ResourceConflictException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        editModifier.createEdit(rsrc.getChange(), psUtil.current(db.get(), rsrc.getNotes()));
        edit = editUtil.byChange(rsrc.getChange());
    }
    if (input == null || Strings.isNullOrEmpty(input.message)) {
        throw new BadRequestException("commit message must be provided");
    }
    try {
        editModifier.modifyMessage(edit.get(), input.message);
    } catch (UnchangedCommitMessageException ucm) {
        throw new ResourceConflictException(ucm.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Object apply(ChangeResource rsrc, Input input) throws AuthException, IOException, BadRequestException, ResourceConflictException, OrmException {
    if (input == null || Strings.isNullOrEmpty(input.message)) {
        throw new BadRequestException("commit message must be provided");
    }
    Project.NameKey project = rsrc.getProject();
    try (Repository repository = repositoryManager.openRepository(project)) {
        ChangeControl changeControl = rsrc.getControl();
        editModifier.modifyMessage(repository, changeControl, input.message);
    } catch (UnchangedCommitMessageException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public SoyTofu get() throws ProvisionException {
    SoyFileSet.Builder builder = SoyFileSet.builder();
    for (String name : TEMPLATES) {
        addTemplate(builder, name);
    }
    return builder.build().compileToTofu();
}
#method_after
@Override
public SoyTofu get() throws ProvisionException {
    SoyFileSet.Builder builder = SoyFileSet.builder();
    builder.setSoyAstCache(cache);
    for (String name : TEMPLATES) {
        addTemplate(builder, name);
    }
    return builder.build().compileToTofu();
}
#end_block

#method_before
private void addTemplate(SoyFileSet.Builder builder, String name) throws ProvisionException {
    // Load as a file in the mail templates directory if present.
    Path tmpl = site.mail_dir.resolve(name);
    if (Files.isRegularFile(tmpl)) {
        String content;
        try (Reader r = Files.newBufferedReader(tmpl, StandardCharsets.UTF_8)) {
            content = CharStreams.toString(r);
        } catch (IOException err) {
            throw new ProvisionException("Failed to read template file " + tmpl.toAbsolutePath().toString(), err);
        }
        builder.add(content, tmpl.toAbsolutePath().toString());
        return;
    }
    // Otherwise load the template as a resource.
    String resourcePath = "com/google/gerrit/server/mail/" + name;
    builder.add(Resources.getResource(resourcePath));
}
#method_after
private void addTemplate(SoyFileSet.Builder builder, String name) throws ProvisionException {
    // Load as a file in the mail templates directory if present.
    Path tmpl = site.mail_dir.resolve(name);
    if (Files.isRegularFile(tmpl)) {
        String content;
        // mtime.
        try (Reader r = Files.newBufferedReader(tmpl, StandardCharsets.UTF_8)) {
            content = CharStreams.toString(r);
        } catch (IOException err) {
            throw new ProvisionException("Failed to read template file " + tmpl.toAbsolutePath().toString(), err);
        }
        builder.add(content, tmpl.toAbsolutePath().toString());
        return;
    }
    // Otherwise load the template as a resource.
    String resourcePath = "com/google/gerrit/server/mail/" + name;
    builder.add(Resources.getResource(resourcePath));
}
#end_block

#method_before
public static Id parse(final String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#method_after
public static Id parse(String str) {
    Id r = new Id();
    r.fromString(str);
    return r;
}
#end_block

#method_before
public void setFullName(final String name) {
    if (name != null && !name.trim().isEmpty()) {
        fullName = name.trim();
    } else {
        fullName = null;
    }
}
#method_after
public void setFullName(String name) {
    if (name != null && !name.trim().isEmpty()) {
        fullName = name.trim();
    } else {
        fullName = null;
    }
}
#end_block

#method_before
public void setPreferredEmail(final String addr) {
    preferredEmail = addr;
}
#method_after
public void setPreferredEmail(String addr) {
    preferredEmail = addr;
}
#end_block

#method_before
public void setUserName(final String userName) {
    this.userName = userName;
}
#method_after
public void setUserName(String userName) {
    this.userName = userName;
}
#end_block

#method_before
private void rebuild(ChangeResource rsrc) throws ResourceNotFoundException, ConfigInvalidException, OrmException, IOException {
    try {
        rebuilder.rebuild(db.get(), rsrc.getId());
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(IdString.fromDecoded(rsrc.getId().toString()));
    }
}
#method_after
private void rebuild(ChangeResource rsrc) throws ResourceNotFoundException, OrmException, IOException {
    try {
        rebuilder.rebuild(db.get(), rsrc.getId());
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(IdString.fromDecoded(rsrc.getId().toString()));
    }
}
#end_block

#method_before
private void executeUpdateRepo() throws UpdateException, RestApiException {
    try {
        logDebug("Executing updateRepo on {} ops", ops.size());
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
        logDebug("Executing updateRepo on {} RepoOnlyOps", repoOnlyOps.size());
        for (RepoOnlyOp op : repoOnlyOps) {
            op.updateRepo(ctx);
        }
        if (inserter != null) {
            logDebug("Flushing inserter");
            inserter.flush();
        } else {
            logDebug("No objects to flush");
        }
    } catch (Exception e) {
        Throwables.throwIfInstanceOf(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeUpdateRepo() throws UpdateException, RestApiException {
    try {
        logDebug("Executing updateRepo on {} ops", ops.size());
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
        logDebug("Executing updateRepo on {} RepoOnlyOps", repoOnlyOps.size());
        for (RepoOnlyOp op : repoOnlyOps) {
            op.updateRepo(ctx);
        }
        if (onSubmitValidators != null && commands != null && !commands.isEmpty()) {
            // Validation of refs has to take place here and not at the beginning
            // executeRefUpdates. Otherwise failing validation in a second
            // BatchUpdate object will happen *after* first object's
            // executeRefUpdates has finished, hence after first repo's refs have
            // been updated, which is too late.
            onSubmitValidators.validate(project, new ReadOnlyRepository(getRepository()), ctx.getInserter().newReader(), commands.getCommands());
        }
        if (inserter != null) {
            logDebug("Flushing inserter");
            inserter.flush();
        } else {
            logDebug("No objects to flush");
        }
    } catch (Exception e) {
        Throwables.throwIfInstanceOf(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
private void executeNoteDbUpdates(List<ChangeTask> tasks) {
    // Aggregate together all NoteDb ref updates from the ops we executed,
    // possibly in parallel. Each task had its own NoteDbUpdateManager instance
    // with its own thread-local copy of the repo(s), but each of those was just
    // used for staging updates and was never executed.
    // 
    // Use a new BatchRefUpdate as the original batchRefUpdate field is intended
    // for use only by the updateRepo phase.
    // 
    // See the comments in NoteDbUpdateManager#execute() for why we execute the
    // updates on the change repo first.
    logDebug("Executing NoteDb updates for {} changes", tasks.size());
    try {
        BatchRefUpdate changeRefUpdate = getRepository().getRefDatabase().newBatchUpdate();
        boolean hasAllUsersCommands = false;
        try (ObjectInserter ins = getRepository().newObjectInserter()) {
            int objs = 0;
            for (ChangeTask task : tasks) {
                if (task.noteDbResult == null) {
                    logDebug("No-op update to {}", task.id);
                    continue;
                }
                for (ReceiveCommand cmd : task.noteDbResult.changeCommands()) {
                    changeRefUpdate.addCommand(cmd);
                }
                for (InsertedObject obj : task.noteDbResult.changeObjects()) {
                    objs++;
                    ins.insert(obj.type(), obj.data().toByteArray());
                }
                hasAllUsersCommands |= !task.noteDbResult.allUsersCommands().isEmpty();
            }
            logDebug("Collected {} objects and {} ref updates to change repo", objs, changeRefUpdate.getCommands().size());
            executeNoteDbUpdate(getRevWalk(), ins, changeRefUpdate);
        }
        if (hasAllUsersCommands) {
            try (Repository allUsersRepo = repoManager.openRepository(allUsers);
                RevWalk allUsersRw = new RevWalk(allUsersRepo);
                ObjectInserter allUsersIns = allUsersRepo.newObjectInserter()) {
                int objs = 0;
                BatchRefUpdate allUsersRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
                for (ChangeTask task : tasks) {
                    for (ReceiveCommand cmd : task.noteDbResult.allUsersCommands()) {
                        allUsersRefUpdate.addCommand(cmd);
                    }
                    for (InsertedObject obj : task.noteDbResult.allUsersObjects()) {
                        allUsersIns.insert(obj.type(), obj.data().toByteArray());
                    }
                }
                logDebug("Collected {} objects and {} ref updates to All-Users", objs, allUsersRefUpdate.getCommands().size());
                executeNoteDbUpdate(allUsersRw, allUsersIns, allUsersRefUpdate);
            }
        } else {
            logDebug("No All-Users updates");
        }
    } catch (IOException e) {
        // Ignore all errors trying to update NoteDb at this point. We've
        // already written the NoteDbChangeState to ReviewDb, which means
        // if the state is out of date it will be rebuilt the next time it
        // is needed.
        // Always log even without RequestId.
        log.debug("Ignoring NoteDb update error after ReviewDb write", e);
    }
}
#method_after
private void executeNoteDbUpdates(List<ChangeTask> tasks) throws IOException {
    // Aggregate together all NoteDb ref updates from the ops we executed,
    // possibly in parallel. Each task had its own NoteDbUpdateManager instance
    // with its own thread-local copy of the repo(s), but each of those was just
    // used for staging updates and was never executed.
    // 
    // Use a new BatchRefUpdate as the original batchRefUpdate field is intended
    // for use only by the updateRepo phase.
    // 
    // See the comments in NoteDbUpdateManager#execute() for why we execute the
    // updates on the change repo first.
    logDebug("Executing NoteDb updates for {} changes", tasks.size());
    try {
        BatchRefUpdate changeRefUpdate = getRepository().getRefDatabase().newBatchUpdate();
        boolean hasAllUsersCommands = false;
        try (ObjectInserter ins = getRepository().newObjectInserter()) {
            int objs = 0;
            for (ChangeTask task : tasks) {
                if (task.noteDbResult == null) {
                    logDebug("No-op update to {}", task.id);
                    continue;
                }
                for (ReceiveCommand cmd : task.noteDbResult.changeCommands()) {
                    changeRefUpdate.addCommand(cmd);
                }
                for (InsertedObject obj : task.noteDbResult.changeObjects()) {
                    objs++;
                    ins.insert(obj.type(), obj.data().toByteArray());
                }
                hasAllUsersCommands |= !task.noteDbResult.allUsersCommands().isEmpty();
            }
            logDebug("Collected {} objects and {} ref updates to change repo", objs, changeRefUpdate.getCommands().size());
            executeNoteDbUpdate(getRevWalk(), ins, changeRefUpdate);
        }
        if (hasAllUsersCommands) {
            try (Repository allUsersRepo = repoManager.openRepository(allUsers);
                RevWalk allUsersRw = new RevWalk(allUsersRepo);
                ObjectInserter allUsersIns = allUsersRepo.newObjectInserter()) {
                int objs = 0;
                BatchRefUpdate allUsersRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
                for (ChangeTask task : tasks) {
                    for (ReceiveCommand cmd : task.noteDbResult.allUsersCommands()) {
                        allUsersRefUpdate.addCommand(cmd);
                    }
                    for (InsertedObject obj : task.noteDbResult.allUsersObjects()) {
                        allUsersIns.insert(obj.type(), obj.data().toByteArray());
                    }
                }
                logDebug("Collected {} objects and {} ref updates to All-Users", objs, allUsersRefUpdate.getCommands().size());
                executeNoteDbUpdate(allUsersRw, allUsersIns, allUsersRefUpdate);
            }
        } else {
            logDebug("No All-Users updates");
        }
    } catch (IOException e) {
        if (tasks.stream().allMatch(t -> t.storage == PrimaryStorage.REVIEW_DB)) {
            // Ignore all errors trying to update NoteDb at this point. We've
            // already written the NoteDbChangeStates to ReviewDb, which means
            // if any state is out of date it will be rebuilt the next time it
            // is needed.
            // Always log even without RequestId.
            log.debug("Ignoring NoteDb update error after ReviewDb write", e);
        } else {
            // primary storage.
            throw e;
        }
    }
}
#end_block

#method_before
private void executeNoteDbUpdate(RevWalk rw, ObjectInserter ins, BatchRefUpdate bru) throws IOException {
    if (bru.getCommands().isEmpty()) {
        logDebug("No commands, skipping flush and ref update");
        return;
    }
    ins.flush();
    bru.setAllowNonFastForwards(true);
    bru.execute(rw, NullProgressMonitor.INSTANCE);
    for (ReceiveCommand cmd : bru.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            throw new IOException("Update failed: " + bru);
        }
    }
}
#method_after
private void executeNoteDbUpdate(RevWalk rw, ObjectInserter ins, BatchRefUpdate bru) throws IOException {
    if (bru.getCommands().isEmpty()) {
        logDebug("No commands, skipping flush and ref update");
        return;
    }
    ins.flush();
    bru.setAllowNonFastForwards(true);
    bru.execute(rw, NullProgressMonitor.INSTANCE);
    for (ReceiveCommand cmd : bru.getCommands()) {
        // TODO(dborowitz): LOCK_FAILURE for NoteDb primary should be retried.
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            throw new IOException("Update failed: " + bru);
        }
    }
}
#end_block

#method_before
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    // Not always opened.
    @SuppressWarnings("resource")
    NoteDbUpdateManager updateManager = null;
    try {
        PrimaryStorage storage;
        db.changes().beginTransaction(id);
        try {
            ChangeContext ctx = newChangeContext(db, repo, rw, id);
            storage = PrimaryStorage.of(ctx.getChange());
            if (storage == PrimaryStorage.NOTE_DB && !notesMigration.readChanges()) {
                throw new OrmException("must have NoteDb enabled to update change " + id);
            }
            // Call updateChange on each op.
            logDebug("Calling updateChange on {} ops", changeOps.size());
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                logDebug("No ops reported dirty, short-circuiting");
                return;
            }
            deleted = ctx.deleted;
            if (deleted) {
                logDebug("Change was deleted");
            }
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.commitChangeWrites()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            if (storage == PrimaryStorage.REVIEW_DB) {
                // If primary storage of this change is in ReviewDb, bump
                // lastUpdatedOn or rowVersion and commit. Otherwise, don't waste
                // time updating ReviewDb at all.
                Iterable<Change> cs = changesToUpdate(ctx);
                if (isNewChange(id)) {
                    // Insert rather than upsert in case of a race on change IDs.
                    logDebug("Inserting change");
                    db.changes().insert(cs);
                } else if (deleted) {
                    logDebug("Deleting change");
                    db.changes().delete(cs);
                } else {
                    logDebug("Updating change");
                    db.changes().update(cs);
                }
                if (!dryrun) {
                    db.commit();
                }
            } else {
                logDebug("Skipping ReviewDb write since primary storage is {}", storage);
            }
        } finally {
            db.rollback();
        }
        // flushed inserters as well.
        if (storage == PrimaryStorage.NOTE_DB) {
            // Should have failed above if NoteDb is disabled.
            checkState(notesMigration.commitChangeWrites());
            noteDbResult = updateManager.stage().get(id);
        } else if (notesMigration.commitChangeWrites()) {
            try {
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        logDebug("Error updating change (should be rethrown)", e);
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    } finally {
        if (updateManager != null) {
            updateManager.close();
        }
    }
}
#method_after
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    // Not always opened.
    @SuppressWarnings("resource")
    NoteDbUpdateManager updateManager = null;
    try {
        db.changes().beginTransaction(id);
        try {
            ChangeContext ctx = newChangeContext(db, repo, rw, id);
            NoteDbChangeState oldState = NoteDbChangeState.parse(ctx.getChange());
            NoteDbChangeState.checkNotReadOnly(oldState, skewMs);
            storage = PrimaryStorage.of(oldState);
            if (storage == PrimaryStorage.NOTE_DB && !notesMigration.readChanges()) {
                throw new OrmException("must have NoteDb enabled to update change " + id);
            }
            // Call updateChange on each op.
            logDebug("Calling updateChange on {} ops", changeOps.size());
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                logDebug("No ops reported dirty, short-circuiting");
                return;
            }
            deleted = ctx.deleted;
            if (deleted) {
                logDebug("Change was deleted");
            }
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.commitChangeWrites()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            if (storage == PrimaryStorage.REVIEW_DB) {
                // If primary storage of this change is in ReviewDb, bump
                // lastUpdatedOn or rowVersion and commit. Otherwise, don't waste
                // time updating ReviewDb at all.
                Iterable<Change> cs = changesToUpdate(ctx);
                if (isNewChange(id)) {
                    // Insert rather than upsert in case of a race on change IDs.
                    logDebug("Inserting change");
                    db.changes().insert(cs);
                } else if (deleted) {
                    logDebug("Deleting change");
                    db.changes().delete(cs);
                } else {
                    logDebug("Updating change");
                    db.changes().update(cs);
                }
                if (!dryrun) {
                    db.commit();
                }
            } else {
                logDebug("Skipping ReviewDb write since primary storage is {}", storage);
            }
        } finally {
            db.rollback();
        }
        // flushed inserters as well.
        if (storage == PrimaryStorage.NOTE_DB) {
            // Should have failed above if NoteDb is disabled.
            checkState(notesMigration.commitChangeWrites());
            noteDbResult = updateManager.stage().get(id);
        } else if (notesMigration.commitChangeWrites()) {
            try {
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        logDebug("Error updating change (should be rethrown)", e);
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    } finally {
        if (updateManager != null) {
            updateManager.close();
        }
    }
}
#end_block

#method_before
private ChangeContext newChangeContext(ReviewDb db, Repository repo, RevWalk rw, Change.Id id) throws Exception {
    Change c = newChanges.get(id);
    if (c == null) {
        c = ChangeNotes.readOneReviewDbChange(db, id);
    }
    // Pass in preloaded change to controlFor, to avoid:
    // - reading from a db that does not belong to this update
    // - attempting to read a change that doesn't exist yet
    ChangeNotes notes = changeNotesFactory.createForBatchUpdate(c);
    ChangeControl ctl = changeControlFactory.controlFor(notes, user);
    return new ChangeContext(ctl, new BatchUpdateReviewDb(db), repo, rw);
}
#method_after
private ChangeContext newChangeContext(ReviewDb db, Repository repo, RevWalk rw, Change.Id id) throws OrmException {
    Change c = newChanges.get(id);
    boolean isNew = c != null;
    if (isNew) {
        // New change: populate noteDbState.
        checkState(c.getNoteDbState() == null, "noteDbState should not be filled in by callers");
        if (notesMigration.changePrimaryStorage() == PrimaryStorage.NOTE_DB) {
            c.setNoteDbState(NoteDbChangeState.NOTE_DB_PRIMARY_STATE);
        }
    } else {
        // Existing change.
        c = ChangeNotes.readOneReviewDbChange(db, id);
        if (c == null) {
            // Not in ReviewDb, but new changes are created with default primary
            // storage as NOTE_DB, so we can assume that a missing change is
            // NoteDb primary. Pass a synthetic change into ChangeNotes.Factory,
            // which lets ChangeNotes take care of the existence check.
            // 
            // TODO(dborowitz): This assumption is potentially risky, because
            // it means once we turn this option on and start creating changes
            // without writing anything to ReviewDb, we can't turn this option
            // back off without making those changes inaccessible. The problem
            // is we have no way of distinguishing a change that only exists in
            // NoteDb because it only ever existed in NoteDb, from a change that
            // only exists in NoteDb because it used to exist in ReviewDb and
            // deleting from ReviewDb succeeded but deleting from NoteDb failed.
            // 
            // TODO(dborowitz): We actually still have that problem anyway. Maybe
            // we need a cutoff timestamp? Or maybe we need to start leaving
            // tombstones in ReviewDb?
            c = ChangeNotes.Factory.newNoteDbOnlyChange(project, id);
        }
        NoteDbChangeState.checkNotReadOnly(c, skewMs);
    }
    ChangeNotes notes = changeNotesFactory.createForBatchUpdate(c, !isNew);
    ChangeControl ctl = changeControlFactory.controlFor(notes, user);
    return new ChangeContext(ctl, new BatchUpdateReviewDb(db), repo, rw);
}
#end_block

#method_before
private NoteDbUpdateManager stageNoteDbUpdate(ChangeContext ctx, boolean deleted) throws OrmException, IOException {
    logDebug("Staging NoteDb update");
    NoteDbUpdateManager updateManager = updateManagerFactory.create(ctx.getProject()).setChangeRepo(ctx.getRepository(), ctx.getRevWalk(), null, new ChainedReceiveCommands(repo));
    for (ChangeUpdate u : ctx.updates.values()) {
        updateManager.add(u);
    }
    Change c = ctx.getChange();
    if (deleted) {
        updateManager.deleteChange(c.getId());
    }
    try {
        updateManager.stageAndApplyDelta(c);
    } catch (MismatchedStateException ex) {
        // Refused to apply update because NoteDb was out of sync, which can
        // only happen if ReviewDb is the primary storage for this change.
        // 
        // Go ahead with this ReviewDb update; it's still out of sync, but this
        // is no worse than before, and it will eventually get rebuilt.
        logDebug("Ignoring MismatchedStateException while staging");
    }
    return updateManager;
}
#method_after
private NoteDbUpdateManager stageNoteDbUpdate(ChangeContext ctx, boolean deleted) throws OrmException, IOException {
    logDebug("Staging NoteDb update");
    NoteDbUpdateManager updateManager = updateManagerFactory.create(ctx.getProject()).setChangeRepo(ctx.getRepository(), ctx.getRevWalk(), null, new ChainedReceiveCommands(repo));
    if (ctx.getUser().isIdentifiedUser()) {
        updateManager.setRefLogIdent(ctx.getUser().asIdentifiedUser().newRefLogIdent(ctx.getWhen(), tz));
    }
    for (ChangeUpdate u : ctx.updates.values()) {
        updateManager.add(u);
    }
    Change c = ctx.getChange();
    if (deleted) {
        updateManager.deleteChange(c.getId());
    }
    try {
        updateManager.stageAndApplyDelta(c);
    } catch (MismatchedStateException ex) {
        // Refused to apply update because NoteDb was out of sync, which can
        // only happen if ReviewDb is the primary storage for this change.
        // 
        // Go ahead with this ReviewDb update; it's still out of sync, but this
        // is no worse than before, and it will eventually get rebuilt.
        logDebug("Ignoring MismatchedStateException while staging");
    }
    return updateManager;
}
#end_block

#method_before
public static void display(final String token) {
    if (body.getView() == null || !body.getView().displayToken(token)) {
        dispatcher.display(token);
    }
}
#method_after
public static void display(final String token) {
    if (body.getView() == null || !body.getView().displayToken(token)) {
        dispatcher.display(token);
        updateUiLink(token);
    }
}
#end_block

#method_before
public static void display(final String token, final Screen view) {
    if (view.isRequiresSignIn() && !isSignedIn()) {
        doSignIn(token);
    } else {
        view.setToken(token);
        if (isSignedIn()) {
            LocalComments.saveInlineComments();
        }
        body.setView(view);
    }
}
#method_after
public static void display(final String token, final Screen view) {
    if (view.isRequiresSignIn() && !isSignedIn()) {
        doSignIn(token);
    } else {
        view.setToken(token);
        if (isSignedIn()) {
            LocalComments.saveInlineComments();
        }
        body.setView(view);
        updateUiLink(token);
    }
}
#end_block

#method_before
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    if (info().gerrit().webUis().contains(UiType.POLYGERRIT)) {
        btmmenu.add(new InlineLabel(" | "));
        Anchor a = new Anchor(C.polyGerrit(), GWT.getHostPageBaseURL() + "?polygerrit=1");
        a.setStyleName("");
        btmmenu.add(a);
    }
    String reportBugUrl = info().gerrit().reportBugUrl();
    if (reportBugUrl != null) {
        String reportBugText = info().gerrit().reportBugText();
        Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#method_after
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    if (info().gerrit().webUis().contains(UiType.POLYGERRIT)) {
        btmmenu.add(new InlineLabel(" | "));
        uiSwitcherLink = new Anchor(C.newUi(), getUiSwitcherUrl(History.getToken()));
        uiSwitcherLink.setStyleName("");
        btmmenu.add(uiSwitcherLink);
    }
    String reportBugUrl = info().gerrit().reportBugUrl();
    if (reportBugUrl != null) {
        String reportBugText = info().gerrit().reportBugText();
        Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    setTimeForTesting();
    KeyUtil.setEncoderImpl(new StandardKeyEncoder());
    serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    repo = repoManager.createRepository(project);
    tr = new TestRepository<>(repo);
    rw = tr.getRevWalk();
    accountCache = new FakeAccountCache();
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    injector = Guice.createInjector(new FactoryModule() {

        @Override
        public void configure() {
            install(new GitModule());
            install(NoteDbModule.forTest(testConfig));
            bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
            bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
            bind(NotesMigration.class).toInstance(MIGRATION);
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            bind(CapabilityControl.Factory.class).toProvider(Providers.<CapabilityControl.Factory>of(null));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(testConfig);
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toInstance(Boolean.FALSE);
            bind(Realm.class).to(FakeRealm.class);
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(MetricMaker.class).to(DisabledMetricMaker.class);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(null));
        }
    });
    injector.injectMembers(this);
    repoManager.createRepository(allUsers);
    changeOwner = userFactory.create(co.getId());
    otherUser = userFactory.create(ou.getId());
    otherUserId = otherUser.getAccountId();
    internalUser = new InternalUser(null);
}
#method_after
@Before
public void setUp() throws Exception {
    setTimeForTesting();
    serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    repo = repoManager.createRepository(project);
    tr = new TestRepository<>(repo);
    rw = tr.getRevWalk();
    accountCache = new FakeAccountCache();
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    injector = Guice.createInjector(new FactoryModule() {

        @Override
        public void configure() {
            install(new GitModule());
            install(NoteDbModule.forTest(testConfig));
            bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
            bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
            bind(NotesMigration.class).toInstance(MIGRATION);
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            bind(CapabilityControl.Factory.class).toProvider(Providers.<CapabilityControl.Factory>of(null));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(testConfig);
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toInstance(Boolean.FALSE);
            bind(Realm.class).to(FakeRealm.class);
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(MetricMaker.class).to(DisabledMetricMaker.class);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(null));
        }
    });
    injector.injectMembers(this);
    repoManager.createRepository(allUsers);
    changeOwner = userFactory.create(co.getId());
    otherUser = userFactory.create(ou.getId());
    otherUserId = otherUser.getAccountId();
    internalUser = new InternalUser(null);
}
#end_block

#method_before
protected Comment newComment(PatchSet.Id psId, String filename, String UUID, CommentRange range, int line, IdentifiedUser commenter, String parentUUID, Timestamp t, String message, short side, String commitSHA1) {
    Comment c = new Comment(new Comment.Key(UUID, filename, psId.get()), commenter.getAccountId(), t, side, message, serverId);
    c.lineNbr = line;
    c.parentUuid = parentUUID;
    c.revId = commitSHA1;
    c.setRange(range);
    return c;
}
#method_after
protected Comment newComment(PatchSet.Id psId, String filename, String UUID, CommentRange range, int line, IdentifiedUser commenter, String parentUUID, Timestamp t, String message, short side, String commitSHA1, boolean unresolved) {
    Comment c = new Comment(new Comment.Key(UUID, filename, psId.get()), commenter.getAccountId(), t, side, message, serverId, unresolved);
    c.lineNbr = line;
    c.parentUuid = parentUUID;
    c.revId = commitSHA1;
    c.setRange(range);
    return c;
}
#end_block

#method_before
@After
public void restoreExternalIds() throws Exception {
    db.accountExternalIds().delete(getExternalIds(admin));
    db.accountExternalIds().delete(getExternalIds(user));
    db.accountExternalIds().insert(savedExternalIds);
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
}
#method_after
@After
public void restoreExternalIds() throws Exception {
    if (savedExternalIds != null) {
        // savedExternalIds is null when we don't run SSH tests and the assume in
        // @Before in AbstractDaemonTest prevents this class' @Before method from
        // being executed.
        db.accountExternalIds().delete(getExternalIds(admin));
        db.accountExternalIds().delete(getExternalIds(user));
        db.accountExternalIds().insert(savedExternalIds);
    }
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
}
#end_block

#method_before
@Test
public void addEmail() throws Exception {
    List<String> emails = ImmutableList.of("new.email@example.com", "new.email@example.systems");
    for (String email : emails) {
        EmailInput input = new EmailInput();
        input.email = email;
        input.noConfirmation = true;
        gApi.accounts().self().addEmail(input);
    }
}
#method_after
@Test
public void addEmail() throws Exception {
    List<String> emails = ImmutableList.of("new.email@example.com", "new.email@example.systems", // Not in the list of TLDs but added to override in OutgoingEmailValidator
    "new.email@example.local");
    for (String email : emails) {
        EmailInput input = new EmailInput();
        input.email = email;
        input.noConfirmation = true;
        gApi.accounts().self().addEmail(input);
    }
}
#end_block

#method_before
@Test
public void addInvalidEmail() throws Exception {
    EmailInput input = new EmailInput();
    input.email = "invalid@";
    input.noConfirmation = true;
    exception.expect(BadRequestException.class);
    exception.expectMessage("invalid email address");
    gApi.accounts().self().addEmail(input);
}
#method_after
@Test
public void addInvalidEmail() throws Exception {
    List<String> emails = ImmutableList.of(// Missing domain part
    "new.email", // Missing domain part
    "new.email@", // Missing user part
    "@example.com", // Non-supported TLD  (see tlds-alpha-by-domain.txt)
    "new.email@example.blog");
    for (String email : emails) {
        EmailInput input = new EmailInput();
        input.email = email;
        input.noConfirmation = true;
        try {
            gApi.accounts().self().addEmail(input);
            fail("Expected BadRequestException for invalid email address: " + email);
        } catch (BadRequestException e) {
            assertThat(e).hasMessage("invalid email address");
        }
    }
}
#end_block

#method_before
@Test
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    assertSequenceNumbers(info);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add another new key
    String newKey2 = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
    assertSequenceNumbers(info);
    // Delete second key
    gApi.accounts().self().deleteSshKey(2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(1).seq).isEqualTo(3);
}
#method_after
@Test
@UseSsh
public void sshKeys() throws Exception {
    // 
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    assertSequenceNumbers(info);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add another new key
    String newKey2 = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
    assertSequenceNumbers(info);
    // Delete second key
    gApi.accounts().self().deleteSshKey(2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(1).seq).isEqualTo(3);
}
#end_block

#method_before
private void assertUser(AccountInfo info, TestAccount account) throws Exception {
    assertThat(info.name).isEqualTo(account.fullName);
    assertThat(info.email).isEqualTo(account.email);
    assertThat(info.username).isEqualTo(account.username);
}
#method_after
private void assertUser(AccountInfo info, TestAccount account) throws Exception {
    assertThat(info.name).isEqualTo(account.fullName);
    assertThat(info.email).isEqualTo(account.email);
    assertThat(info.username).isEqualTo(account.username);
    assertThat(info.status).isEqualTo(account.status);
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = open();
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    }
    final RefControl metaConfigControl = pc.controlForRef(RefNames.REFS_CONFIG);
    List<AccessSection> local = new ArrayList<>();
    Set<String> ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                local.add(section);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                local.add(section);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setCanUpload(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    detail.setConfigVisible(pc.isOwner() || metaConfigControl.isVisible());
    detail.setGroupInfo(buildGroupInfo(local));
    detail.setLabelTypes(pc.getLabelTypes());
    detail.setFileHistoryLinks(getConfigFileLogLinks(projectName.get()));
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = open();
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    }
    final RefControl metaConfigControl = pc.controlForRef(RefNames.REFS_CONFIG);
    List<AccessSection> local = new ArrayList<>();
    Set<String> ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                local.add(section);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                local.add(section);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setCanUpload(metaConfigControl.isVisible() && (pc.isOwner() || metaConfigControl.canUpload()));
    detail.setConfigVisible(pc.isOwner() || metaConfigControl.isVisible());
    detail.setGroupInfo(buildGroupInfo(local));
    detail.setLabelTypes(pc.getLabelTypes());
    detail.setFileHistoryLinks(getConfigFileLogLinks(projectName.get()));
    return detail;
}
#end_block

#method_before
private List<WebLinkInfoCommon> getConfigFileLogLinks(String projectName) {
    FluentIterable<WebLinkInfoCommon> links = webLinks.getFileHistoryLinksCommon(projectName, RefNames.REFS_CONFIG, ProjectConfig.PROJECT_CONFIG);
    return links.isEmpty() ? null : links.toList();
}
#method_after
private List<WebLinkInfoCommon> getConfigFileLogLinks(String projectName) {
    List<WebLinkInfoCommon> links = webLinks.getFileHistoryLinks(projectName, RefNames.REFS_CONFIG, ProjectConfig.PROJECT_CONFIG);
    return links.isEmpty() ? null : links;
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    if (notify.compareTo(NotifyHandling.OWNER_REVIEWERS) >= 0) {
        ccAllApprovals();
    }
    if (notify.compareTo(NotifyHandling.ALL) >= 0) {
        bccStarredBy();
        includeWatchers(NotifyType.ALL_COMMENTS);
    }
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    if (notify.compareTo(NotifyHandling.OWNER_REVIEWERS) >= 0) {
        ccAllApprovals();
    }
    if (notify.compareTo(NotifyHandling.ALL) >= 0) {
        bccStarredBy();
        includeWatchers(NotifyType.ALL_COMMENTS);
    }
    // Add header that enables identifying comments on parsed email.
    // Grouping is currently done by timestamp.
    setHeader("X-Gerrit-Comment-Date", timestamp);
}
#end_block

#method_before
@Deprecated
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    for (FileCommentGroup group : getGroupedInlineComments()) {
        String link = group.getLink();
        if (link != null) {
            cmts.append(link).append('\n');
        }
        cmts.append(group.getTitle()).append(":\n\n");
        for (Comment c : group.comments) {
            appendComment(cmts, lines, group.fileData, c);
        }
        cmts.append("\n\n");
    }
    return cmts.toString();
}
#method_after
@Deprecated
public String getInlineComments(int lines) {
    try (Repository repo = getRepository()) {
        StringBuilder cmts = new StringBuilder();
        for (FileCommentGroup group : getGroupedInlineComments(repo)) {
            String link = group.getLink();
            if (link != null) {
                cmts.append(link).append('\n');
            }
            cmts.append(group.getTitle()).append(":\n\n");
            for (Comment c : group.comments) {
                appendComment(cmts, lines, group.fileData, c);
            }
            cmts.append("\n\n");
        }
        return cmts.toString();
    }
}
#end_block

#method_before
private List<CommentSender.FileCommentGroup> getGroupedInlineComments() {
    List<CommentSender.FileCommentGroup> groups = new ArrayList<>();
    try (Repository repo = getRepository()) {
        // Get the patch list:
        PatchList patchList = null;
        if (repo != null) {
            try {
                patchList = getPatchList();
            } catch (PatchListNotAvailableException e) {
                log.error("Failed to get patch list", e);
            }
        }
        // Loop over the comments and collect them into groups based on the file
        // location of the comment.
        FileCommentGroup currentGroup = null;
        for (Comment c : inlineComments) {
            // If it's a new group:
            if (currentGroup == null || !c.key.filename.equals(currentGroup.filename) || c.key.patchSetId != currentGroup.patchSetId) {
                currentGroup = new FileCommentGroup();
                currentGroup.filename = c.key.filename;
                currentGroup.patchSetId = c.key.patchSetId;
                groups.add(currentGroup);
                if (patchList != null) {
                    try {
                        currentGroup.fileData = new PatchFile(repo, patchList, c.key.filename);
                    } catch (IOException e) {
                        log.warn(String.format("Cannot load %s from %s in %s", c.key.filename, patchList.getNewId().name(), projectState.getProject().getName()), e);
                        currentGroup.fileData = null;
                    }
                }
            }
            if (currentGroup.fileData != null) {
                currentGroup.comments.add(c);
            }
        }
    }
    Collections.sort(groups, Comparator.comparing(g -> g.filename, FilenameComparator.INSTANCE));
    return groups;
}
#method_after
private List<CommentSender.FileCommentGroup> getGroupedInlineComments(Repository repo) {
    List<CommentSender.FileCommentGroup> groups = new ArrayList<>();
    // Get the patch list:
    PatchList patchList = null;
    if (repo != null) {
        try {
            patchList = getPatchList();
        } catch (PatchListNotAvailableException e) {
            log.error("Failed to get patch list", e);
        }
    }
    // Loop over the comments and collect them into groups based on the file
    // location of the comment.
    FileCommentGroup currentGroup = null;
    for (Comment c : inlineComments) {
        // If it's a new group:
        if (currentGroup == null || !c.key.filename.equals(currentGroup.filename) || c.key.patchSetId != currentGroup.patchSetId) {
            currentGroup = new FileCommentGroup();
            currentGroup.filename = c.key.filename;
            currentGroup.patchSetId = c.key.patchSetId;
            groups.add(currentGroup);
            if (patchList != null) {
                try {
                    currentGroup.fileData = new PatchFile(repo, patchList, c.key.filename);
                } catch (IOException e) {
                    log.warn(String.format("Cannot load %s from %s in %s", c.key.filename, patchList.getNewId().name(), projectState.getProject().getName()), e);
                    currentGroup.fileData = null;
                }
            }
        }
        if (currentGroup.fileData != null) {
            currentGroup.comments.add(c);
        }
    }
    Collections.sort(groups, Comparator.comparing(g -> g.filename, FilenameComparator.INSTANCE));
    return groups;
}
#end_block

#method_before
private List<String> getLinesOfComment(Comment comment, PatchFile fileData) {
    List<String> lines = new ArrayList<>();
    if (comment.range == null) {
        lines.add(getLine(fileData, comment.side, comment.lineNbr));
    } else {
        lines.addAll(getLinesByRange(comment.range, fileData, comment.side));
    }
    return lines;
}
#method_after
private List<String> getLinesOfComment(Comment comment, PatchFile fileData) {
    List<String> lines = new ArrayList<>();
    if (comment.lineNbr == 0) {
        // file level comment has no line
        return lines;
    }
    if (comment.range == null) {
        lines.add(getLine(fileData, comment.side, comment.lineNbr));
    } else {
        lines.addAll(getLinesByRange(comment.range, fileData, comment.side));
    }
    return lines;
}
#end_block

#method_before
private List<Map<String, Object>> getCommentGroupsTemplateData() {
    List<Map<String, Object>> commentGroups = new ArrayList<>();
    for (CommentSender.FileCommentGroup group : getGroupedInlineComments()) {
        Map<String, Object> groupData = new HashMap<>();
        groupData.put("link", group.getLink());
        groupData.put("title", group.getTitle());
        groupData.put("patchSetId", group.patchSetId);
        List<Map<String, Object>> commentsList = new ArrayList<>();
        for (Comment comment : group.comments) {
            Map<String, Object> commentData = new HashMap<>();
            commentData.put("lines", getLinesOfComment(comment, group.fileData));
            commentData.put("message", comment.message.trim());
            // Set the prefix.
            String prefix = getCommentLinePrefix(comment);
            commentData.put("linePrefix", prefix);
            commentData.put("linePrefixEmpty", Strings.padStart(": ", prefix.length(), ' '));
            // Set line numbers.
            int startLine;
            if (comment.range == null) {
                startLine = comment.lineNbr;
            } else {
                startLine = comment.range.startLine;
                commentData.put("endLine", comment.range.endLine);
            }
            commentData.put("startLine", startLine);
            // Set the comment link.
            if (comment.lineNbr == 0) {
                commentData.put("link", group.getLink());
            } else if (comment.side == 0) {
                commentData.put("link", group.getLink() + "@a" + startLine);
            } else {
                commentData.put("link", group.getLink() + '@' + startLine);
            }
            // Set robot comment data.
            if (comment instanceof RobotComment) {
                RobotComment robotComment = (RobotComment) comment;
                commentData.put("isRobotComment", true);
                commentData.put("robotId", robotComment.robotId);
                commentData.put("robotRunId", robotComment.robotRunId);
                commentData.put("robotUrl", robotComment.url);
            } else {
                commentData.put("isRobotComment", false);
            }
            // Set parent comment info.
            Optional<Comment> parent = getParent(comment);
            if (parent.isPresent()) {
                commentData.put("parentMessage", getShortenedCommentMessage(parent.get()));
            }
            commentsList.add(commentData);
        }
        groupData.put("comments", commentsList);
        commentGroups.add(groupData);
    }
    return commentGroups;
}
#method_after
private List<Map<String, Object>> getCommentGroupsTemplateData(Repository repo) {
    List<Map<String, Object>> commentGroups = new ArrayList<>();
    for (CommentSender.FileCommentGroup group : getGroupedInlineComments(repo)) {
        Map<String, Object> groupData = new HashMap<>();
        groupData.put("link", group.getLink());
        groupData.put("title", group.getTitle());
        groupData.put("patchSetId", group.patchSetId);
        List<Map<String, Object>> commentsList = new ArrayList<>();
        for (Comment comment : group.comments) {
            Map<String, Object> commentData = new HashMap<>();
            commentData.put("lines", getLinesOfComment(comment, group.fileData));
            commentData.put("message", comment.message.trim());
            List<CommentFormatter.Block> blocks = CommentFormatter.parse(comment.message);
            commentData.put("messageBlocks", commentBlocksToSoyData(blocks));
            // Set the prefix.
            String prefix = getCommentLinePrefix(comment);
            commentData.put("linePrefix", prefix);
            commentData.put("linePrefixEmpty", Strings.padStart(": ", prefix.length(), ' '));
            // Set line numbers.
            int startLine;
            if (comment.range == null) {
                startLine = comment.lineNbr;
            } else {
                startLine = comment.range.startLine;
                commentData.put("endLine", comment.range.endLine);
            }
            commentData.put("startLine", startLine);
            // Set the comment link.
            if (comment.lineNbr == 0) {
                commentData.put("link", group.getLink());
            } else if (comment.side == 0) {
                commentData.put("link", group.getLink() + "@a" + startLine);
            } else {
                commentData.put("link", group.getLink() + '@' + startLine);
            }
            // Set robot comment data.
            if (comment instanceof RobotComment) {
                RobotComment robotComment = (RobotComment) comment;
                commentData.put("isRobotComment", true);
                commentData.put("robotId", robotComment.robotId);
                commentData.put("robotRunId", robotComment.robotRunId);
                commentData.put("robotUrl", robotComment.url);
            } else {
                commentData.put("isRobotComment", false);
            }
            // If the comment has a quote, don't bother loading the parent message.
            if (!hasQuote(blocks)) {
                // Set parent comment info.
                Optional<Comment> parent = getParent(comment);
                if (parent.isPresent()) {
                    commentData.put("parentMessage", getShortenedCommentMessage(parent.get()));
                }
            }
            commentsList.add(commentData);
        }
        groupData.put("comments", commentsList);
        commentGroups.add(groupData);
    }
    return commentGroups;
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("commentFiles", getCommentGroupsTemplateData());
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    boolean hasComments = false;
    try (Repository repo = getRepository()) {
        List<Map<String, Object>> files = getCommentGroupsTemplateData(repo);
        soyContext.put("commentFiles", files);
        hasComments = !files.isEmpty();
    }
    soyContext.put("patchSetCommentBlocks", commentBlocksToSoyData(CommentFormatter.parse(patchSetComment)));
    soyContext.put("labels", getLabelVoteSoyData(labels));
    soyContext.put("commentCount", inlineComments.size());
    soyContext.put("commentTimestamp", getCommentTimestamp());
    soyContext.put("coverLetterBlocks", commentBlocksToSoyData(CommentFormatter.parse(getCoverLetter())));
    footers.add("Gerrit-Comment-Date: " + getCommentTimestamp());
    footers.add("Gerrit-HasComments: " + (hasComments ? "Yes" : "No"));
}
#end_block

#method_before
private String getLine(PatchFile fileInfo, short side, int lineNbr) {
    try {
        return fileInfo.getLine(side, lineNbr);
    } catch (IOException err) {
        // Default to the empty string if the file cannot be safely read.
        log.warn(String.format("Failed to read file on side %d", side), err);
        return "";
    } catch (IndexOutOfBoundsException err) {
        // Default to the empty string if the given line number does not appear
        // in the file.
        log.warn(String.format("Failed to get line number of file on side %d", side), err);
        return "";
    } catch (NoSuchEntityException err) {
        // Default to the empty string if the side cannot be found.
        log.warn(String.format("Side %d of file didn't exist", side), err);
        return "";
    }
}
#method_after
private String getLine(PatchFile fileInfo, short side, int lineNbr) {
    try {
        return fileInfo.getLine(side, lineNbr);
    } catch (IOException err) {
        // Default to the empty string if the file cannot be safely read.
        log.warn(String.format("Failed to read file on side %d", side), err);
        return "";
    } catch (IndexOutOfBoundsException err) {
        // Default to the empty string if the given line number does not appear
        // in the file.
        log.debug(String.format("Failed to get line number of file on side %d", side), err);
        return "";
    } catch (NoSuchEntityException err) {
        // Default to the empty string if the side cannot be found.
        log.warn(String.format("Side %d of file didn't exist", side), err);
        return "";
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    Map<String, GroupReference> groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setRejectImplicitMerges(getEnum(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, DEFAULT_SUBMIT_ACTION));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, DEFAULT_STATE_VALUE));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    Map<String, GroupReference> groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        // The config must not contain more than one parent to inherit from
        // as there is no guarantee which of the parents would be used then.
        error(new ValidationError(PROJECT_CONFIG, "Cannot inherit from multiple projects"));
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setRejectImplicitMerges(getEnum(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, DEFAULT_SUBMIT_ACTION));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, DEFAULT_STATE_VALUE));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
private void loadLabelSections(Config rc) {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = new LinkedHashMap<>();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = new ArrayList<>();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String functionName = MoreObjects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        if (!values.isEmpty()) {
            short dv = (short) rc.getInt(LABEL, name, KEY_DEFAULT_VALUE, 0);
            if (isInRange(dv, values)) {
                label.setDefaultValue(dv);
            } else {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\"", KEY_DEFAULT_VALUE, dv, name)));
            }
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, LabelType.DEF_COPY_MIN_SCORE));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, LabelType.DEF_COPY_MAX_SCORE));
        label.setCopyAllScoresOnMergeFirstParentUpdate(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE));
        label.setCopyAllScoresIfNoCodeChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE));
        label.setCopyAllScoresIfNoChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, LabelType.DEF_CAN_OVERRIDE));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_BRANCH));
        labelSections.put(name, label);
    }
}
#method_after
private void loadLabelSections(Config rc) {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = new LinkedHashMap<>();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = new ArrayList<>();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String functionName = MoreObjects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        if (!values.isEmpty()) {
            short dv = (short) rc.getInt(LABEL, name, KEY_DEFAULT_VALUE, 0);
            if (isInRange(dv, values)) {
                label.setDefaultValue(dv);
            } else {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\"", KEY_DEFAULT_VALUE, dv, name)));
            }
        }
        label.setAllowPostSubmit(rc.getBoolean(LABEL, name, KEY_ALLOW_POST_SUBMIT, LabelType.DEF_ALLOW_POST_SUBMIT));
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, LabelType.DEF_COPY_MIN_SCORE));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, LabelType.DEF_COPY_MAX_SCORE));
        label.setCopyAllScoresOnMergeFirstParentUpdate(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE));
        label.setCopyAllScoresIfNoCodeChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE));
        label.setCopyAllScoresIfNoChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, LabelType.DEF_CAN_OVERRIDE));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_BRANCH));
        labelSections.put(name, label);
    }
}
#end_block

#method_before
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunctionName());
        rc.setInt(LABEL, name, KEY_DEFAULT_VALUE, label.getDefaultValue());
        setBooleanConfigKey(rc, name, KEY_COPY_MIN_SCORE, label.isCopyMinScore(), LabelType.DEF_COPY_MIN_SCORE);
        setBooleanConfigKey(rc, name, KEY_COPY_MAX_SCORE, label.isCopyMaxScore(), LabelType.DEF_COPY_MAX_SCORE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, label.isCopyAllScoresOnTrivialRebase(), LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, label.isCopyAllScoresIfNoCodeChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, label.isCopyAllScoresIfNoChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, label.isCopyAllScoresOnMergeFirstParentUpdate(), LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE);
        setBooleanConfigKey(rc, name, KEY_CAN_OVERRIDE, label.canOverride(), LabelType.DEF_CAN_OVERRIDE);
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#method_after
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunctionName());
        rc.setInt(LABEL, name, KEY_DEFAULT_VALUE, label.getDefaultValue());
        setBooleanConfigKey(rc, name, KEY_ALLOW_POST_SUBMIT, label.allowPostSubmit(), LabelType.DEF_ALLOW_POST_SUBMIT);
        setBooleanConfigKey(rc, name, KEY_COPY_MIN_SCORE, label.isCopyMinScore(), LabelType.DEF_COPY_MIN_SCORE);
        setBooleanConfigKey(rc, name, KEY_COPY_MAX_SCORE, label.isCopyMaxScore(), LabelType.DEF_COPY_MAX_SCORE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, label.isCopyAllScoresOnTrivialRebase(), LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, label.isCopyAllScoresIfNoCodeChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, label.isCopyAllScoresIfNoChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, label.isCopyAllScoresOnMergeFirstParentUpdate(), LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE);
        setBooleanConfigKey(rc, name, KEY_CAN_OVERRIDE, label.canOverride(), LabelType.DEF_CAN_OVERRIDE);
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#end_block

#method_before
private void fill(AccountInfo info, Account account, @Nullable Collection<AccountExternalId> externalIds, Set<FillOptions> options) {
    if (options.contains(FillOptions.ID)) {
        info._accountId = account.getId().get();
    } else {
        // Was previously set to look up account for filling.
        info._accountId = null;
    }
    if (options.contains(FillOptions.NAME)) {
        info.name = Strings.emptyToNull(account.getFullName());
        if (info.name == null) {
            info.name = account.getUserName();
        }
    }
    if (options.contains(FillOptions.EMAIL)) {
        info.email = account.getPreferredEmail();
    }
    if (options.contains(FillOptions.SECONDARY_EMAILS)) {
        info.secondaryEmails = externalIds != null ? getSecondaryEmails(account, externalIds) : null;
    }
    if (options.contains(FillOptions.USERNAME)) {
        info.username = externalIds != null ? AccountState.getUserName(externalIds) : null;
    }
    if (options.contains(FillOptions.AVATARS)) {
        AvatarProvider ap = avatar.get();
        if (ap != null) {
            info.avatars = new ArrayList<>(3);
            IdentifiedUser user = userFactory.create(account.getId());
            // GWT UI uses DEFAULT_SIZE (26px).
            addAvatar(ap, info, user, AvatarInfo.DEFAULT_SIZE);
            // PolyGerrit UI prefers 32px and 100px.
            if (!info.avatars.isEmpty()) {
                if (32 != AvatarInfo.DEFAULT_SIZE) {
                    addAvatar(ap, info, user, 32);
                }
                if (100 != AvatarInfo.DEFAULT_SIZE) {
                    addAvatar(ap, info, user, 100);
                }
            }
        }
    }
}
#method_after
private void fill(AccountInfo info, Account account, @Nullable Collection<AccountExternalId> externalIds, Set<FillOptions> options) {
    if (options.contains(FillOptions.ID)) {
        info._accountId = account.getId().get();
    } else {
        // Was previously set to look up account for filling.
        info._accountId = null;
    }
    if (options.contains(FillOptions.NAME)) {
        info.name = Strings.emptyToNull(account.getFullName());
        if (info.name == null) {
            info.name = account.getUserName();
        }
    }
    if (options.contains(FillOptions.EMAIL)) {
        info.email = account.getPreferredEmail();
    }
    if (options.contains(FillOptions.SECONDARY_EMAILS)) {
        info.secondaryEmails = externalIds != null ? getSecondaryEmails(account, externalIds) : null;
    }
    if (options.contains(FillOptions.USERNAME)) {
        info.username = externalIds != null ? AccountState.getUserName(externalIds) : null;
    }
    if (options.contains(FillOptions.STATUS)) {
        info.status = account.getStatus();
    }
    if (options.contains(FillOptions.AVATARS)) {
        AvatarProvider ap = avatar.get();
        if (ap != null) {
            info.avatars = new ArrayList<>(3);
            IdentifiedUser user = userFactory.create(account.getId());
            // GWT UI uses DEFAULT_SIZE (26px).
            addAvatar(ap, info, user, AvatarInfo.DEFAULT_SIZE);
            // PolyGerrit UI prefers 32px and 100px.
            if (!info.avatars.isEmpty()) {
                if (32 != AvatarInfo.DEFAULT_SIZE) {
                    addAvatar(ap, info, user, 32);
                }
                if (100 != AvatarInfo.DEFAULT_SIZE) {
                    addAvatar(ap, info, user, 100);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public RestView<TopLevelResource> list() throws ResourceNotFoundException, AuthException {
    final CurrentUser user = self.get();
    if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!(user.isIdentifiedUser())) {
        throw new ResourceNotFoundException();
    }
    return list.get();
}
#method_after
@Override
public RestView<TopLevelResource> list() throws ResourceNotFoundException, AuthException {
    final CurrentUser user = self.get();
    if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!(user.isIdentifiedUser())) {
        throw new ResourceNotFoundException();
    }
    if (hasQuery2) {
        return queryGroups.get();
    }
    return list.get();
}
#end_block

#method_before
@Override
public void stop() {
    I read = searchIndex.get();
    if (read != null) {
        read.close();
    }
    for (I write : writeIndexes) {
        if (write != read) {
            write.close();
        }
    }
}
#method_after
@Override
public void stop() {
    I read = searchIndex.get();
    if (read != null) {
        read.close();
    }
    for (I write : writeIndexes) {
        if (write != read) {
            write.stop();
            write.close();
        }
    }
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContextEmailData.put("reviewerNames", getReviewerNames());
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("ownerName", getNameFor(change.getOwner()));
    soyContextEmailData.put("reviewerNames", getReviewerNames());
}
#end_block

#method_before
public static <R extends RestResource> Iterable<UiAction.Description> from(RestCollection<?, R> collection, R resource, Provider<CurrentUser> userProvider) {
    return from(collection.views(), resource, userProvider);
}
#method_after
public static <R extends RestResource> FluentIterable<UiAction.Description> from(RestCollection<?, R> collection, R resource, Provider<CurrentUser> userProvider) {
    return from(collection.views(), resource, userProvider);
}
#end_block

#method_before
public static <R extends RestResource> Iterable<UiAction.Description> from(DynamicMap<RestView<R>> views, final R resource, final Provider<CurrentUser> userProvider) {
    return FluentIterable.from(views).transform((DynamicMap.Entry<RestView<R>> e) -> {
        int d = e.getExportName().indexOf('.');
        if (d < 0) {
            return null;
        }
        RestView<R> view;
        try {
            view = e.getProvider().get();
        } catch (RuntimeException err) {
            log.error(String.format("error creating view %s.%s", e.getPluginName(), e.getExportName()), err);
            return null;
        }
        if (!(view instanceof UiAction)) {
            return null;
        }
        try {
            CapabilityUtils.checkRequiresCapability(userProvider, e.getPluginName(), view.getClass());
        } catch (AuthException exc) {
            return null;
        }
        UiAction.Description dsc = ((UiAction<R>) view).getDescription(resource);
        if (dsc == null || !dsc.isVisible()) {
            return null;
        }
        String name = e.getExportName().substring(d + 1);
        PrivateInternals_UiActionDescription.setMethod(dsc, e.getExportName().substring(0, d));
        PrivateInternals_UiActionDescription.setId(dsc, "gerrit".equals(e.getPluginName()) ? name : e.getPluginName() + '~' + name);
        return dsc;
    }).filter(Objects::nonNull);
}
#method_after
public static <R extends RestResource> FluentIterable<UiAction.Description> from(DynamicMap<RestView<R>> views, R resource, Provider<CurrentUser> userProvider) {
    return FluentIterable.from(views).transform((DynamicMap.Entry<RestView<R>> e) -> {
        int d = e.getExportName().indexOf('.');
        if (d < 0) {
            return null;
        }
        RestView<R> view;
        try {
            view = e.getProvider().get();
        } catch (RuntimeException err) {
            log.error(String.format("error creating view %s.%s", e.getPluginName(), e.getExportName()), err);
            return null;
        }
        if (!(view instanceof UiAction)) {
            return null;
        }
        try {
            CapabilityUtils.checkRequiresCapability(userProvider, e.getPluginName(), view.getClass());
        } catch (AuthException exc) {
            return null;
        }
        UiAction.Description dsc = ((UiAction<R>) view).getDescription(resource);
        if (dsc == null || !dsc.isVisible()) {
            return null;
        }
        String name = e.getExportName().substring(d + 1);
        PrivateInternals_UiActionDescription.setMethod(dsc, e.getExportName().substring(0, d));
        PrivateInternals_UiActionDescription.setId(dsc, "gerrit".equals(e.getPluginName()) ? name : e.getPluginName() + '~' + name);
        return dsc;
    }).filter(Objects::nonNull);
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        RevWalk rw = new RevWalk(oi.newReader())) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setGroups(groups);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        RevWalk rw = new RevWalk(oi.newReader())) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getControl(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
public List<CodeReviewCommit> sort(Collection<CodeReviewCommit> incoming) throws IOException {
    final List<CodeReviewCommit> sorted = new ArrayList<>();
    final Set<CodeReviewCommit> sort = new HashSet<>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        for (RevCommit c : accepted) {
            // n also tip of directly pushed branch => n remains 'interesting' here
            if (!c.equals(n)) {
                rw.markUninteresting(c);
            }
        }
        CodeReviewCommit c;
        final List<CodeReviewCommit> contents = new ArrayList<>();
        while ((c = rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                // 
                if (n.missing == null) {
                    n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY);
                    n.missing = new ArrayList<>();
                }
                n.missing.add(c);
            } else {
                contents.add(c);
            }
        }
        if (n.getStatusCode() == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        sort.removeAll(contents);
        Collections.reverse(contents);
        sorted.removeAll(contents);
        sorted.addAll(contents);
    }
    return sorted;
}
#method_after
public List<CodeReviewCommit> sort(Collection<CodeReviewCommit> incoming) throws IOException {
    final List<CodeReviewCommit> sorted = new ArrayList<>();
    final Set<CodeReviewCommit> sort = new HashSet<>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        if (initialTip != null) {
            rw.markUninteresting(initialTip);
        }
        CodeReviewCommit c;
        final List<CodeReviewCommit> contents = new ArrayList<>();
        while ((c = rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                if (isAlreadyMerged(c, n.change().getDest())) {
                    rw.markUninteresting(c);
                } else {
                    // We cannot merge n as it would bring something we
                    // aren't permitted to merge at this time. Drop n.
                    // 
                    n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY);
                }
                // dependency. Not need to walk further.
                break;
            }
            contents.add(c);
        }
        if (n.getStatusCode() == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        sort.removeAll(contents);
        Collections.reverse(contents);
        sorted.removeAll(contents);
        sorted.addAll(contents);
    }
    return sorted;
}
#end_block

#method_before
public boolean include(Change.Id changeId, Comment p) {
    PatchSet.Id psId = new PatchSet.Id(changeId, p.key.patchSetId);
    switch(p.side) {
        case 0:
            if (idA == null && idB.equals(psId)) {
                a.add(p);
                return true;
            }
            break;
        case 1:
            if (idA != null && idA.equals(psId)) {
                a.add(p);
                return true;
            }
            if (idB.equals(psId)) {
                b.add(p);
                return true;
            }
            break;
    }
    return false;
}
#method_after
public void include(Change.Id changeId, Comment p) {
    PatchSet.Id psId = new PatchSet.Id(changeId, p.key.patchSetId);
    if (p.side == 0) {
        if (idA == null && idB.equals(psId)) {
            a.add(p);
        }
    } else if (p.side == 1) {
        if (idA != null && idA.equals(psId)) {
            a.add(p);
        } else if (idB.equals(psId)) {
            b.add(p);
        }
    }
}
#end_block

#method_before
private Predicate<PatchSet.Id> validPatchSetPredicate() {
    Predicate<PatchSet.Id> upToCurrent = upToCurrentPredicate();
    return p -> upToCurrent.apply(p) && patchSets.containsKey(p);
}
#method_after
private Predicate<PatchSet.Id> validPatchSetPredicate() {
    return patchSets::containsKey;
}
#end_block

#method_before
private static void diffChangeMessages(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    if (bundleA.source == REVIEW_DB && bundleB.source == REVIEW_DB) {
        // Both came from ReviewDb: check all fields exactly.
        Map<ChangeMessage.Key, ChangeMessage> as = changeMessageMap(bundleA.filterChangeMessages());
        Map<ChangeMessage.Key, ChangeMessage> bs = changeMessageMap(bundleB.filterChangeMessages());
        for (ChangeMessage.Key k : diffKeySets(diffs, as, bs)) {
            ChangeMessage a = as.get(k);
            ChangeMessage b = bs.get(k);
            String desc = describe(k);
            diffColumns(diffs, ChangeMessage.class, desc, bundleA, a, bundleB, b);
        }
        return;
    }
    Change.Id id = bundleA.getChange().getId();
    checkArgument(id.equals(bundleB.getChange().getId()));
    // Try to pair up matching ChangeMessages from each side, and succeed only
    // if both collections are empty at the end. Quadratic in the worst case,
    // but easy to reason about.
    List<ChangeMessage> as = new LinkedList<>(bundleA.filterChangeMessages());
    Multimap<ChangeMessageCandidate, ChangeMessage> bs = LinkedListMultimap.create();
    for (ChangeMessage b : bundleB.filterChangeMessages()) {
        bs.put(ChangeMessageCandidate.create(b), b);
    }
    Iterator<ChangeMessage> ait = as.iterator();
    A: while (ait.hasNext()) {
        ChangeMessage a = ait.next();
        Iterator<ChangeMessage> bit = bs.get(ChangeMessageCandidate.create(a)).iterator();
        while (bit.hasNext()) {
            ChangeMessage b = bit.next();
            if (changeMessagesMatch(bundleA, a, bundleB, b)) {
                ait.remove();
                bit.remove();
                continue A;
            }
        }
    }
    if (as.isEmpty() && bs.isEmpty()) {
        return;
    }
    StringBuilder sb = new StringBuilder("ChangeMessages differ for Change.Id ").append(id).append('\n');
    if (!as.isEmpty()) {
        sb.append("Only in A:");
        for (ChangeMessage cm : as) {
            sb.append("\n  ").append(cm);
        }
        if (!bs.isEmpty()) {
            sb.append('\n');
        }
    }
    if (!bs.isEmpty()) {
        sb.append("Only in B:");
        for (ChangeMessage cm : CHANGE_MESSAGE_ORDER.sortedCopy(bs.values())) {
            sb.append("\n  ").append(cm);
        }
    }
    diffs.add(sb.toString());
}
#method_after
private static void diffChangeMessages(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    if (bundleA.source == REVIEW_DB && bundleB.source == REVIEW_DB) {
        // Both came from ReviewDb: check all fields exactly.
        Map<ChangeMessage.Key, ChangeMessage> as = changeMessageMap(bundleA.filterChangeMessages());
        Map<ChangeMessage.Key, ChangeMessage> bs = changeMessageMap(bundleB.filterChangeMessages());
        for (ChangeMessage.Key k : diffKeySets(diffs, as, bs)) {
            ChangeMessage a = as.get(k);
            ChangeMessage b = bs.get(k);
            String desc = describe(k);
            diffColumns(diffs, ChangeMessage.class, desc, bundleA, a, bundleB, b);
        }
        return;
    }
    Change.Id id = bundleA.getChange().getId();
    checkArgument(id.equals(bundleB.getChange().getId()));
    // Try to pair up matching ChangeMessages from each side, and succeed only
    // if both collections are empty at the end. Quadratic in the worst case,
    // but easy to reason about.
    List<ChangeMessage> as = new LinkedList<>(bundleA.filterChangeMessages());
    ListMultimap<ChangeMessageCandidate, ChangeMessage> bs = LinkedListMultimap.create();
    for (ChangeMessage b : bundleB.filterChangeMessages()) {
        bs.put(ChangeMessageCandidate.create(b), b);
    }
    Iterator<ChangeMessage> ait = as.iterator();
    A: while (ait.hasNext()) {
        ChangeMessage a = ait.next();
        Iterator<ChangeMessage> bit = bs.get(ChangeMessageCandidate.create(a)).iterator();
        while (bit.hasNext()) {
            ChangeMessage b = bit.next();
            if (changeMessagesMatch(bundleA, a, bundleB, b)) {
                ait.remove();
                bit.remove();
                continue A;
            }
        }
    }
    if (as.isEmpty() && bs.isEmpty()) {
        return;
    }
    StringBuilder sb = new StringBuilder("ChangeMessages differ for Change.Id ").append(id).append('\n');
    if (!as.isEmpty()) {
        sb.append("Only in A:");
        for (ChangeMessage cm : as) {
            sb.append("\n  ").append(cm);
        }
        if (!bs.isEmpty()) {
            sb.append('\n');
        }
    }
    if (!bs.isEmpty()) {
        sb.append("Only in B:");
        for (ChangeMessage cm : CHANGE_MESSAGE_ORDER.sortedCopy(bs.values())) {
            sb.append("\n  ").append(cm);
        }
    }
    diffs.add(sb.toString());
}
#end_block

#method_before
private static void diffPatchSets(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    Map<PatchSet.Id, PatchSet> as = bundleA.filterPatchSets();
    Map<PatchSet.Id, PatchSet> bs = bundleB.filterPatchSets();
    for (PatchSet.Id id : diffKeySets(diffs, as, bs)) {
        PatchSet a = as.get(id);
        PatchSet b = bs.get(id);
        String desc = describe(id);
        String pushCertField = "pushCertificate";
        diffColumnsExcluding(diffs, PatchSet.class, desc, bundleA, a, bundleB, b, pushCertField);
        diffValues(diffs, desc, trimPushCert(a), trimPushCert(b), pushCertField);
    }
}
#method_after
private static void diffPatchSets(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    Map<PatchSet.Id, PatchSet> as = bundleA.patchSets;
    Map<PatchSet.Id, PatchSet> bs = bundleB.patchSets;
    for (PatchSet.Id id : diffKeySets(diffs, as, bs)) {
        PatchSet a = as.get(id);
        PatchSet b = bs.get(id);
        String desc = describe(id);
        String pushCertField = "pushCertificate";
        diffColumnsExcluding(diffs, PatchSet.class, desc, bundleA, a, bundleB, b, pushCertField);
        diffValues(diffs, desc, trimPushCert(a), trimPushCert(b), pushCertField);
    }
}
#end_block

#method_before
@SuppressWarnings("resource")
public String exec(String command, InputStream opt) throws JSchException, IOException {
    ChannelExec channel = (ChannelExec) getSession().openChannel("exec");
    try {
        channel.setCommand(command);
        channel.setInputStream(opt);
        InputStream in = channel.getInputStream();
        channel.connect();
        Scanner s = new Scanner(channel.getErrStream()).useDelimiter("\\A");
        error = s.hasNext() ? s.next() : null;
        s = new Scanner(in).useDelimiter("\\A");
        return s.hasNext() ? s.next() : "";
    } finally {
        channel.disconnect();
    }
}
#method_after
@SuppressWarnings("resource")
public String exec(String command, InputStream opt) throws JSchException, IOException {
    ChannelExec channel = (ChannelExec) getSession().openChannel("exec");
    try {
        channel.setCommand(command);
        channel.setInputStream(opt);
        InputStream in = channel.getInputStream();
        InputStream err = channel.getErrStream();
        channel.connect();
        Scanner s = new Scanner(err).useDelimiter("\\A");
        error = s.hasNext() ? s.next() : null;
        s = new Scanner(in).useDelimiter("\\A");
        return s.hasNext() ? s.next() : "";
    } finally {
        channel.disconnect();
    }
}
#end_block

#method_before
@Override
public ProjectInfo get() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ProjectInfo get() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ProjectInfo get(boolean recursive) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ProjectInfo get(boolean recursive) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op();
        bu.addOp(rsrc.getChange().getId(), op);
        bu.execute();
        if (op.getDeletedAssignee() == null) {
            return Response.none();
        }
        return Response.ok(AccountJson.toAccountInfo(op.getDeletedAssignee()));
    }
}
#method_after
@Override
public Response<AccountInfo> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException, OrmException {
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op();
        bu.addOp(rsrc.getChange().getId(), op);
        bu.execute();
        Account.Id deletedAssignee = op.getDeletedAssignee();
        return deletedAssignee == null ? Response.none() : Response.ok(accountLoaderFactory.create(true).fillOne(deletedAssignee));
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException {
    if (!ctx.getControl().canEditAssignee()) {
        throw new AuthException("Delete Assignee not permitted");
    }
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    Account.Id currentAssigneeId = change.getAssignee();
    if (currentAssigneeId == null) {
        return false;
    }
    deletedAssignee = accountInfos.create().get(currentAssigneeId);
    // noteDb
    update.removeAssignee();
    // reviewDb
    change.setAssignee(null);
    addMessage(ctx, update, deletedAssignee);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException {
    if (!ctx.getControl().canEditAssignee()) {
        throw new AuthException("Delete Assignee not permitted");
    }
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    Account.Id currentAssigneeId = change.getAssignee();
    if (currentAssigneeId == null) {
        return false;
    }
    IdentifiedUser deletedAssigneeUser = userFactory.create(currentAssigneeId);
    deletedAssignee = deletedAssigneeUser.getAccount();
    // noteDb
    update.removeAssignee();
    // reviewDb
    change.setAssignee(null);
    addMessage(ctx, update, deletedAssigneeUser);
    return true;
}
#end_block

#method_before
public Account getDeletedAssignee() {
    return deletedAssignee;
}
#method_after
public Account.Id getDeletedAssignee() {
    return deletedAssignee != null ? deletedAssignee.getId() : null;
}
#end_block

#method_before
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account deleted) throws OrmException {
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, "Assignee deleted: " + deleted.getName(anonymousCowardName), ChangeMessagesUtil.TAG_DELETE_ASSIGNEE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, IdentifiedUser deletedAssignee) throws OrmException {
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, "Assignee deleted: " + deletedAssignee.getNameEmail(), ChangeMessagesUtil.TAG_DELETE_ASSIGNEE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    draftPublished.fire(change, patchSet, ctx.getAccount(), ctx.getWhen());
    if (patchSet.isDraft() && change.getStatus() == Change.Status.DRAFT) {
        // Skip emails if the patch set is still a draft.
        return;
    }
    try {
        if (wasDraftChange) {
            sendCreateChange(ctx);
        } else {
            sendReplacePatchSet(ctx);
        }
    } catch (EmailException | OrmException e) {
        log.error("Cannot send email for publishing draft " + psId, e);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    draftPublished.fire(change, patchSet, ctx.getAccount(), ctx.getWhen());
    if (patchSet.isDraft() && change.getStatus() == Change.Status.DRAFT) {
        // Skip emails if the patch set is still a draft.
        return;
    }
    try {
        if (wasDraftChange) {
            sendCreateChange(ctx);
        } else {
            sendReplacePatchSet(ctx);
        }
    } catch (EmailException e) {
        log.error("Cannot send email for publishing draft " + psId, e);
    }
}
#end_block

#method_before
private void sendReplacePatchSet(Context ctx) throws EmailException, OrmException {
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), "Uploaded patch set " + psId.get() + ".", ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(ctx.getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#method_after
private void sendReplacePatchSet(Context ctx) throws EmailException {
    ChangeMessage msg = ChangeMessagesUtil.newMessage(psId, ctx.getUser(), ctx.getWhen(), "Uploaded patch set " + psId.get() + ".", ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(ctx.getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#end_block

#method_before
@Override
public Response<String> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, ResourceNotFoundException, OrmException {
    if (input == null) {
        // Delete would set description to null.
        input = new Input();
    }
    if (resource.toAccountGroup() == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    AccountGroup group = db.get().accountGroups().get(resource.toAccountGroup().getId());
    if (group == null) {
        throw new ResourceNotFoundException();
    }
    group.setDescription(Strings.emptyToNull(input.description));
    db.get().accountGroups().update(Collections.singleton(group));
    groupCache.evict(group);
    return Strings.isNullOrEmpty(input.description) ? Response.<String>none() : Response.ok(input.description);
}
#method_after
@Override
public Response<String> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new Input();
    }
    if (resource.toAccountGroup() == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    AccountGroup group = db.get().accountGroups().get(resource.toAccountGroup().getId());
    if (group == null) {
        throw new ResourceNotFoundException();
    }
    group.setDescription(Strings.emptyToNull(input.description));
    db.get().accountGroups().update(Collections.singleton(group));
    groupCache.evict(group);
    return Strings.isNullOrEmpty(input.description) ? Response.<String>none() : Response.ok(input.description);
}
#end_block

#method_before
private static InlineComment getInlineComment(String key) {
    String path;
    Side side = Side.PARENT;
    int line = 0;
    CommentRange range;
    StorageBackend storage = new StorageBackend();
    String[] elements = key.split("-");
    int offset = 1;
    if (key.startsWith("patchReply-") || key.startsWith("patchCommentEdit-")) {
        offset = 2;
    }
    Change.Id changeId = new Change.Id(Integer.parseInt(elements[offset + 0]));
    PatchSet.Id psId = new PatchSet.Id(changeId, Integer.parseInt(elements[offset + 1]));
    path = atob(elements[offset + 2]);
    side = (Side.PARENT.toString().equals(elements[offset + 3])) ? Side.PARENT : Side.REVISION;
    range = null;
    if (elements[offset + 4].startsWith("R")) {
        String rangeStart = elements[offset + 4].substring(1);
        String rangeEnd = elements[offset + 5];
        String[] split = rangeStart.split(",");
        int sl = Integer.parseInt(split[0]);
        int sc = Integer.parseInt(split[1]);
        split = rangeEnd.split(",");
        int el = Integer.parseInt(split[0]);
        int ec = Integer.parseInt(split[1]);
        range = CommentRange.create(sl, sc, el, ec);
        line = sl;
    } else {
        line = Integer.parseInt(elements[offset + 4]);
    }
    CommentInfo info = CommentInfo.create(path, side, line, range);
    info.message(storage.getItem(key));
    if (key.startsWith("patchReply-")) {
        info.inReplyTo(elements[1]);
    } else if (key.startsWith("patchCommentEdit-")) {
        info.id(elements[1]);
    }
    InlineComment inlineComment = new InlineComment(psId, info);
    return inlineComment;
}
#method_after
private static InlineComment getInlineComment(String key) {
    String path;
    Side side = Side.PARENT;
    int line = 0;
    CommentRange range;
    StorageBackend storage = new StorageBackend();
    String[] elements = key.split("-");
    int offset = 1;
    if (key.startsWith("patchReply-") || key.startsWith("patchCommentEdit-")) {
        offset = 2;
    }
    Change.Id changeId = new Change.Id(Integer.parseInt(elements[offset + 0]));
    PatchSet.Id psId = new PatchSet.Id(changeId, Integer.parseInt(elements[offset + 1]));
    path = atob(elements[offset + 2]);
    side = (Side.PARENT.toString().equals(elements[offset + 3])) ? Side.PARENT : Side.REVISION;
    range = null;
    if (elements[offset + 4].startsWith("R")) {
        String rangeStart = elements[offset + 4].substring(1);
        String rangeEnd = elements[offset + 5];
        String[] split = rangeStart.split(",");
        int sl = Integer.parseInt(split[0]);
        int sc = Integer.parseInt(split[1]);
        split = rangeEnd.split(",");
        int el = Integer.parseInt(split[0]);
        int ec = Integer.parseInt(split[1]);
        range = CommentRange.create(sl, sc, el, ec);
        line = sl;
    } else {
        line = Integer.parseInt(elements[offset + 4]);
    }
    CommentInfo info = CommentInfo.create(path, side, line, range, false);
    info.message(storage.getItem(key));
    if (key.startsWith("patchReply-")) {
        info.inReplyTo(elements[1]);
    } else if (key.startsWith("patchCommentEdit-")) {
        info.id(elements[1]);
    }
    InlineComment inlineComment = new InlineComment(psId, info);
    return inlineComment;
}
#end_block

#method_before
private ChangeData toChangeData(JsonElement json) {
    JsonElement sourceElement = json.getAsJsonObject().get("_source");
    if (sourceElement == null) {
        sourceElement = json.getAsJsonObject().get("fields");
    }
    JsonObject source = sourceElement.getAsJsonObject();
    JsonElement c = source.get(ChangeField.CHANGE.getName());
    if (c == null) {
        int id = source.get(ChangeField.LEGACY_ID.getName()).getAsInt();
        String projectName = source.get(ChangeField.PROJECT.getName()).getAsString();
        if (projectName == null) {
            return changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), new Change.Id(id));
        }
        return changeDataFactory.create(db.get(), new Project.NameKey(projectName), new Change.Id(id));
    }
    ChangeData cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(Base64.decodeBase64(c.getAsString())));
    // Patch sets.
    cd.setPatchSets(decodeProtos(source, ChangeField.PATCH_SET.getName(), PatchSetProtoField.CODEC));
    // Approvals.
    if (source.get(ChangeField.APPROVAL.getName()) != null) {
        cd.setCurrentApprovals(decodeProtos(source, ChangeField.APPROVAL.getName(), PatchSetApprovalProtoField.CODEC));
    } else if (fields.contains(ChangeField.APPROVAL.getName())) {
        cd.setCurrentApprovals(Collections.emptyList());
    }
    JsonElement addedElement = source.get(ChangeField.ADDED.getName());
    JsonElement deletedElement = source.get(ChangeField.DELETED.getName());
    if (addedElement != null && deletedElement != null) {
        // Changed lines.
        int added = addedElement.getAsInt();
        int deleted = deletedElement.getAsInt();
        if (added != 0 && deleted != 0) {
            cd.setChangedLines(added, deleted);
        }
    }
    // Mergeable.
    JsonElement mergeableElement = source.get(ChangeField.MERGEABLE.getName());
    if (mergeableElement != null) {
        String mergeable = mergeableElement.getAsString();
        if ("1".equals(mergeable)) {
            cd.setMergeable(true);
        } else if ("0".equals(mergeable)) {
            cd.setMergeable(false);
        }
    }
    // Reviewed-by.
    if (source.get(ChangeField.REVIEWEDBY.getName()) != null) {
        JsonArray reviewedBy = source.get(ChangeField.REVIEWEDBY.getName()).getAsJsonArray();
        if (reviewedBy.size() > 0) {
            Set<Account.Id> accounts = Sets.newHashSetWithExpectedSize(reviewedBy.size());
            for (int i = 0; i < reviewedBy.size(); i++) {
                int aId = reviewedBy.get(i).getAsInt();
                if (reviewedBy.size() == 1 && aId == ChangeField.NOT_REVIEWED) {
                    break;
                }
                accounts.add(new Account.Id(aId));
            }
            cd.setReviewedBy(accounts);
        }
    } else if (fields.contains(ChangeField.REVIEWEDBY.getName())) {
        cd.setReviewedBy(Collections.emptySet());
    }
    if (source.get(ChangeField.REVIEWER.getName()) != null) {
        cd.setReviewers(ChangeField.parseReviewerFieldValues(FluentIterable.from(source.get(ChangeField.REVIEWER.getName()).getAsJsonArray()).transform(JsonElement::getAsString)));
    } else if (fields.contains(ChangeField.REVIEWER.getName())) {
        cd.setReviewers(ReviewerSet.empty());
    }
    decodeSubmitRecords(source, ChangeField.STORED_SUBMIT_RECORD_STRICT.getName(), ChangeField.SUBMIT_RULE_OPTIONS_STRICT, cd);
    decodeSubmitRecords(source, ChangeField.STORED_SUBMIT_RECORD_LENIENT.getName(), ChangeField.SUBMIT_RULE_OPTIONS_LENIENT, cd);
    return cd;
}
#method_after
private ChangeData toChangeData(JsonElement json) {
    JsonElement sourceElement = json.getAsJsonObject().get("_source");
    if (sourceElement == null) {
        sourceElement = json.getAsJsonObject().get("fields");
    }
    JsonObject source = sourceElement.getAsJsonObject();
    JsonElement c = source.get(ChangeField.CHANGE.getName());
    if (c == null) {
        int id = source.get(ChangeField.LEGACY_ID.getName()).getAsInt();
        String projectName = source.get(ChangeField.PROJECT.getName()).getAsString();
        if (projectName == null) {
            return changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), new Change.Id(id));
        }
        return changeDataFactory.create(db.get(), new Project.NameKey(projectName), new Change.Id(id));
    }
    ChangeData cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(Base64.decodeBase64(c.getAsString())));
    // Patch sets.
    cd.setPatchSets(decodeProtos(source, ChangeField.PATCH_SET.getName(), PatchSetProtoField.CODEC));
    // Approvals.
    if (source.get(ChangeField.APPROVAL.getName()) != null) {
        cd.setCurrentApprovals(decodeProtos(source, ChangeField.APPROVAL.getName(), PatchSetApprovalProtoField.CODEC));
    } else if (fields.contains(ChangeField.APPROVAL.getName())) {
        cd.setCurrentApprovals(Collections.emptyList());
    }
    JsonElement addedElement = source.get(ChangeField.ADDED.getName());
    JsonElement deletedElement = source.get(ChangeField.DELETED.getName());
    if (addedElement != null && deletedElement != null) {
        // Changed lines.
        int added = addedElement.getAsInt();
        int deleted = deletedElement.getAsInt();
        if (added != 0 && deleted != 0) {
            cd.setChangedLines(added, deleted);
        }
    }
    // Mergeable.
    JsonElement mergeableElement = source.get(ChangeField.MERGEABLE.getName());
    if (mergeableElement != null) {
        String mergeable = mergeableElement.getAsString();
        if ("1".equals(mergeable)) {
            cd.setMergeable(true);
        } else if ("0".equals(mergeable)) {
            cd.setMergeable(false);
        }
    }
    // Reviewed-by.
    if (source.get(ChangeField.REVIEWEDBY.getName()) != null) {
        JsonArray reviewedBy = source.get(ChangeField.REVIEWEDBY.getName()).getAsJsonArray();
        if (reviewedBy.size() > 0) {
            Set<Account.Id> accounts = Sets.newHashSetWithExpectedSize(reviewedBy.size());
            for (int i = 0; i < reviewedBy.size(); i++) {
                int aId = reviewedBy.get(i).getAsInt();
                if (reviewedBy.size() == 1 && aId == ChangeField.NOT_REVIEWED) {
                    break;
                }
                accounts.add(new Account.Id(aId));
            }
            cd.setReviewedBy(accounts);
        }
    } else if (fields.contains(ChangeField.REVIEWEDBY.getName())) {
        cd.setReviewedBy(Collections.emptySet());
    }
    if (source.get(ChangeField.REVIEWER.getName()) != null) {
        cd.setReviewers(ChangeField.parseReviewerFieldValues(FluentIterable.from(source.get(ChangeField.REVIEWER.getName()).getAsJsonArray()).transform(JsonElement::getAsString)));
    } else if (fields.contains(ChangeField.REVIEWER.getName())) {
        cd.setReviewers(ReviewerSet.empty());
    }
    decodeSubmitRecords(source, ChangeField.STORED_SUBMIT_RECORD_STRICT.getName(), ChangeField.SUBMIT_RULE_OPTIONS_STRICT, cd);
    decodeSubmitRecords(source, ChangeField.STORED_SUBMIT_RECORD_LENIENT.getName(), ChangeField.SUBMIT_RULE_OPTIONS_LENIENT, cd);
    if (source.get(ChangeField.REF_STATE.getName()) != null) {
        JsonArray refStates = source.get(ChangeField.REF_STATE.getName()).getAsJsonArray();
        cd.setRefStates(Iterables.transform(refStates, e -> Base64.decodeBase64(e.getAsString())));
    }
    if (source.get(ChangeField.REF_STATE_PATTERN.getName()) != null) {
        JsonArray refStatePatterns = source.get(ChangeField.REF_STATE_PATTERN.getName()).getAsJsonArray();
        cd.setRefStatePatterns(Iterables.transform(refStatePatterns, e -> Base64.decodeBase64(e.getAsString())));
    }
    return cd;
}
#end_block

#method_before
public void copyFrom(final CodeReviewCommit src) {
    control = src.control;
    patchsetId = src.patchsetId;
    statusCode = src.statusCode;
    missing = src.missing;
}
#method_after
public void copyFrom(final CodeReviewCommit src) {
    control = src.control;
    patchsetId = src.patchsetId;
    statusCode = src.statusCode;
}
#end_block

#method_before
void doAuth(final HttpServletRequest req, final HttpServletResponse rsp) throws Exception {
    if (OMODE_CANCEL.equals(req.getParameter(OPENID_MODE))) {
        cancel(req, rsp);
        return;
    }
    // Process the authentication response.
    // 
    final SignInMode mode = signInMode(req);
    final String openidIdentifier = req.getParameter("openid.identity");
    final String claimedIdentifier = req.getParameter(P_CLAIMED);
    final String returnToken = req.getParameter(P_TOKEN);
    final boolean remember = "1".equals(req.getParameter(P_REMEMBER));
    final String rediscoverIdentifier = claimedIdentifier != null ? claimedIdentifier : openidIdentifier;
    final State state;
    if (!isAllowedOpenID(rediscoverIdentifier) || !isAllowedOpenID(openidIdentifier) || (claimedIdentifier != null && !isAllowedOpenID(claimedIdentifier))) {
        cancelWithError(req, rsp, "Provider not allowed");
        return;
    }
    state = init(req, rediscoverIdentifier, mode, remember, returnToken);
    if (state == null) {
        // Re-discovery must have failed, we can't run a login.
        // 
        cancel(req, rsp);
        return;
    }
    final String returnTo = req.getParameter("openid.return_to");
    if (returnTo != null && returnTo.contains("openid.rpnonce=")) {
        // Some providers (claimid.com) seem to embed these request
        // parameters into our return_to URL, and then give us them
        // in the return_to request parameter. But not all.
        // 
        state.retTo.put("openid.rpnonce", req.getParameter("openid.rpnonce"));
        state.retTo.put("openid.rpsig", req.getParameter("openid.rpsig"));
    }
    final VerificationResult result = manager.verify(state.retTo.toString(), new ParameterList(req.getParameterMap()), state.discovered);
    if (result.getVerifiedId() == null) /* authentication failure */
    {
        if ("Nonce verification failed.".equals(result.getStatusMsg())) {
            // We might be suffering from clock skew on this system.
            // 
            log.error("OpenID failure: " + result.getStatusMsg() + "  Likely caused by clock skew on this server," + " install/configure NTP.");
            cancelWithError(req, rsp, result.getStatusMsg());
        } else if (result.getStatusMsg() != null) {
            // Authentication failed.
            // 
            log.error("OpenID failure: " + result.getStatusMsg());
            cancelWithError(req, rsp, result.getStatusMsg());
        } else {
            // Assume authentication was canceled.
            // 
            cancel(req, rsp);
        }
        return;
    }
    final Message authRsp = result.getAuthResponse();
    SRegResponse sregRsp = null;
    FetchResponse fetchRsp = null;
    if (0 <= papeMaxAuthAge) {
        PapeResponse ext;
        boolean unsupported = false;
        try {
            ext = (PapeResponse) authRsp.getExtension(PapeMessage.OPENID_NS_PAPE);
        } catch (MessageException err) {
            // Far too many providers are unable to provide PAPE extensions
            // right now. Instead of blocking all of them log the error and
            // let the authentication complete anyway.
            // 
            log.error("Invalid PAPE response " + openidIdentifier + ": " + err);
            unsupported = true;
            ext = null;
        }
        if (!unsupported && ext == null) {
            log.error("No PAPE extension response from " + openidIdentifier);
            cancelWithError(req, rsp, "OpenID provider does not support PAPE.");
            return;
        }
    }
    if (authRsp.hasExtension(SRegMessage.OPENID_NS_SREG)) {
        final MessageExtension ext = authRsp.getExtension(SRegMessage.OPENID_NS_SREG);
        if (ext instanceof SRegResponse) {
            sregRsp = (SRegResponse) ext;
        }
    }
    if (authRsp.hasExtension(AxMessage.OPENID_NS_AX)) {
        final MessageExtension ext = authRsp.getExtension(AxMessage.OPENID_NS_AX);
        if (ext instanceof FetchResponse) {
            fetchRsp = (FetchResponse) ext;
        }
    }
    final com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(openidIdentifier);
    if (sregRsp != null) {
        areq.setDisplayName(sregRsp.getAttributeValue("fullname"));
        areq.setEmailAddress(sregRsp.getAttributeValue("email"));
    } else if (fetchRsp != null) {
        final String firstName = fetchRsp.getAttributeValue("FirstName");
        final String lastName = fetchRsp.getAttributeValue("LastName");
        final StringBuilder n = new StringBuilder();
        if (firstName != null && firstName.length() > 0) {
            n.append(firstName);
        }
        if (lastName != null && lastName.length() > 0) {
            if (n.length() > 0) {
                n.append(' ');
            }
            n.append(lastName);
        }
        areq.setDisplayName(n.length() > 0 ? n.toString() : null);
        areq.setEmailAddress(fetchRsp.getAttributeValue("Email"));
    }
    if (openIdDomains != null && openIdDomains.size() > 0) {
        // Administrator limited email domains, which can be used for OpenID.
        // Login process will only work if the passed email matches one
        // of these domains.
        // 
        final String email = areq.getEmailAddress();
        int emailAtIndex = email.lastIndexOf("@");
        if (emailAtIndex >= 0 && emailAtIndex < email.length() - 1) {
            final String emailDomain = email.substring(emailAtIndex);
            boolean match = false;
            for (String domain : openIdDomains) {
                if (emailDomain.equalsIgnoreCase(domain)) {
                    match = true;
                    break;
                }
            }
            if (!match) {
                log.error("Domain disallowed: " + emailDomain);
                cancelWithError(req, rsp, "Domain disallowed");
                return;
            }
        }
    }
    if (claimedIdentifier != null) {
        // The user used a claimed identity which has delegated to the verified
        // identity we have in our AuthRequest above. We still should have a
        // link between the two, so set one up if not present.
        // 
        Account.Id claimedId = accountManager.lookup(claimedIdentifier);
        Account.Id actualId = accountManager.lookup(areq.getExternalId());
        if (claimedId != null && actualId != null) {
            if (claimedId.equals(actualId)) {
            // Both link to the same account, that's what we expected.
            } else {
                // This is (for now) a fatal error. There are two records
                // for what might be the same user.
                // 
                log.error("OpenID accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + areq.getExternalId());
                cancelWithError(req, rsp, "Contact site administrator");
                return;
            }
        } else if (claimedId == null && actualId != null) {
            // Older account, the actual was already created but the claimed
            // was missing due to a bug in Gerrit. Link the claimed.
            // 
            final com.google.gerrit.server.account.AuthRequest linkReq = new com.google.gerrit.server.account.AuthRequest(claimedIdentifier);
            linkReq.setDisplayName(areq.getDisplayName());
            linkReq.setEmailAddress(areq.getEmailAddress());
            accountManager.link(actualId, linkReq);
        } else if (claimedId != null && actualId == null) {
            // Claimed account already exists, but it smells like the user has
            // changed their delegate to point to a different provider. Link
            // the new provider.
            // 
            accountManager.link(claimedId, areq);
        } else {
        // Both are null, we are going to create a new account below.
        }
    }
    try {
        final com.google.gerrit.server.account.AuthResult arsp;
        switch(mode) {
            case REGISTER:
            case SIGN_IN:
                arsp = accountManager.authenticate(areq);
                final Cookie lastId = new Cookie(OpenIdUrls.LASTID_COOKIE, "");
                lastId.setPath(req.getContextPath() + "/login/");
                if (remember) {
                    lastId.setValue(rediscoverIdentifier);
                    lastId.setMaxAge(LASTID_AGE);
                } else {
                    lastId.setMaxAge(0);
                }
                rsp.addCookie(lastId);
                webSession.get().login(arsp, remember);
                if (arsp.isNew() && claimedIdentifier != null) {
                    final com.google.gerrit.server.account.AuthRequest linkReq = new com.google.gerrit.server.account.AuthRequest(claimedIdentifier);
                    linkReq.setDisplayName(areq.getDisplayName());
                    linkReq.setEmailAddress(areq.getEmailAddress());
                    accountManager.link(arsp.getAccountId(), linkReq);
                }
                callback(arsp.isNew(), req, rsp);
                break;
            case LINK_IDENTIY:
                {
                    arsp = accountManager.link(identifiedUser.get().getAccountId(), areq);
                    webSession.get().login(arsp, remember);
                    callback(false, req, rsp);
                    break;
                }
        }
    } catch (AccountException e) {
        log.error("OpenID authentication failure", e);
        cancelWithError(req, rsp, "Contact site administrator");
    }
}
#method_after
void doAuth(final HttpServletRequest req, final HttpServletResponse rsp) throws Exception {
    if (OMODE_CANCEL.equals(req.getParameter(OPENID_MODE))) {
        cancel(req, rsp);
        return;
    }
    // Process the authentication response.
    // 
    final SignInMode mode = signInMode(req);
    final String openidIdentifier = req.getParameter("openid.identity");
    final String claimedIdentifier = req.getParameter(P_CLAIMED);
    final String returnToken = req.getParameter(P_TOKEN);
    final boolean remember = "1".equals(req.getParameter(P_REMEMBER));
    final String rediscoverIdentifier = claimedIdentifier != null ? claimedIdentifier : openidIdentifier;
    final State state;
    if (!isAllowedOpenID(rediscoverIdentifier) || !isAllowedOpenID(openidIdentifier) || (claimedIdentifier != null && !isAllowedOpenID(claimedIdentifier))) {
        cancelWithError(req, rsp, "Provider not allowed");
        return;
    }
    state = init(req, rediscoverIdentifier, mode, remember, returnToken);
    if (state == null) {
        // Re-discovery must have failed, we can't run a login.
        // 
        cancel(req, rsp);
        return;
    }
    final String returnTo = req.getParameter("openid.return_to");
    if (returnTo != null && returnTo.contains("openid.rpnonce=")) {
        // Some providers (claimid.com) seem to embed these request
        // parameters into our return_to URL, and then give us them
        // in the return_to request parameter. But not all.
        // 
        state.retTo.put("openid.rpnonce", req.getParameter("openid.rpnonce"));
        state.retTo.put("openid.rpsig", req.getParameter("openid.rpsig"));
    }
    final VerificationResult result = manager.verify(state.retTo.toString(), new ParameterList(req.getParameterMap()), state.discovered);
    if (result.getVerifiedId() == null) /* authentication failure */
    {
        if ("Nonce verification failed.".equals(result.getStatusMsg())) {
            // We might be suffering from clock skew on this system.
            // 
            log.error("OpenID failure: " + result.getStatusMsg() + "  Likely caused by clock skew on this server," + " install/configure NTP.");
            cancelWithError(req, rsp, result.getStatusMsg());
        } else if (result.getStatusMsg() != null) {
            // Authentication failed.
            // 
            log.error("OpenID failure: " + result.getStatusMsg());
            cancelWithError(req, rsp, result.getStatusMsg());
        } else {
            // Assume authentication was canceled.
            // 
            cancel(req, rsp);
        }
        return;
    }
    final Message authRsp = result.getAuthResponse();
    SRegResponse sregRsp = null;
    FetchResponse fetchRsp = null;
    if (0 <= papeMaxAuthAge) {
        PapeResponse ext;
        boolean unsupported = false;
        try {
            ext = (PapeResponse) authRsp.getExtension(PapeMessage.OPENID_NS_PAPE);
        } catch (MessageException err) {
            // Far too many providers are unable to provide PAPE extensions
            // right now. Instead of blocking all of them log the error and
            // let the authentication complete anyway.
            // 
            log.error("Invalid PAPE response " + openidIdentifier + ": " + err);
            unsupported = true;
            ext = null;
        }
        if (!unsupported && ext == null) {
            log.error("No PAPE extension response from " + openidIdentifier);
            cancelWithError(req, rsp, "OpenID provider does not support PAPE.");
            return;
        }
    }
    if (authRsp.hasExtension(SRegMessage.OPENID_NS_SREG)) {
        final MessageExtension ext = authRsp.getExtension(SRegMessage.OPENID_NS_SREG);
        if (ext instanceof SRegResponse) {
            sregRsp = (SRegResponse) ext;
        }
    }
    if (authRsp.hasExtension(AxMessage.OPENID_NS_AX)) {
        final MessageExtension ext = authRsp.getExtension(AxMessage.OPENID_NS_AX);
        if (ext instanceof FetchResponse) {
            fetchRsp = (FetchResponse) ext;
        }
    }
    final com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(openidIdentifier);
    if (sregRsp != null) {
        areq.setDisplayName(sregRsp.getAttributeValue("fullname"));
        areq.setEmailAddress(sregRsp.getAttributeValue("email"));
    } else if (fetchRsp != null) {
        final String firstName = fetchRsp.getAttributeValue("FirstName");
        final String lastName = fetchRsp.getAttributeValue("LastName");
        final StringBuilder n = new StringBuilder();
        if (firstName != null && firstName.length() > 0) {
            n.append(firstName);
        }
        if (lastName != null && lastName.length() > 0) {
            if (n.length() > 0) {
                n.append(' ');
            }
            n.append(lastName);
        }
        areq.setDisplayName(n.length() > 0 ? n.toString() : null);
        areq.setEmailAddress(fetchRsp.getAttributeValue("Email"));
    }
    if (openIdDomains != null && openIdDomains.size() > 0) {
        // Administrator limited email domains, which can be used for OpenID.
        // Login process will only work if the passed email matches one
        // of these domains.
        // 
        final String email = areq.getEmailAddress();
        int emailAtIndex = email.lastIndexOf("@");
        if (emailAtIndex >= 0 && emailAtIndex < email.length() - 1) {
            final String emailDomain = email.substring(emailAtIndex);
            boolean match = false;
            for (String domain : openIdDomains) {
                if (emailDomain.equalsIgnoreCase(domain)) {
                    match = true;
                    break;
                }
            }
            if (!match) {
                log.error("Domain disallowed: " + emailDomain);
                cancelWithError(req, rsp, "Domain disallowed");
                return;
            }
        }
    }
    if (claimedIdentifier != null) {
        // The user used a claimed identity which has delegated to the verified
        // identity we have in our AuthRequest above. We still should have a
        // link between the two, so set one up if not present.
        // 
        Optional<Account.Id> claimedId = accountManager.lookup(claimedIdentifier);
        Optional<Account.Id> actualId = accountManager.lookup(areq.getExternalId());
        if (claimedId.isPresent() && actualId.isPresent()) {
            if (claimedId.get().equals(actualId.get())) {
            // Both link to the same account, that's what we expected.
            } else {
                // This is (for now) a fatal error. There are two records
                // for what might be the same user.
                // 
                log.error("OpenID accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId.get() + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId.get() + " is " + areq.getExternalId());
                cancelWithError(req, rsp, "Contact site administrator");
                return;
            }
        } else if (!claimedId.isPresent() && actualId.isPresent()) {
            // Older account, the actual was already created but the claimed
            // was missing due to a bug in Gerrit. Link the claimed.
            // 
            final com.google.gerrit.server.account.AuthRequest linkReq = new com.google.gerrit.server.account.AuthRequest(claimedIdentifier);
            linkReq.setDisplayName(areq.getDisplayName());
            linkReq.setEmailAddress(areq.getEmailAddress());
            accountManager.link(actualId.get(), linkReq);
        } else if (claimedId.isPresent() && !actualId.isPresent()) {
            // Claimed account already exists, but it smells like the user has
            // changed their delegate to point to a different provider. Link
            // the new provider.
            // 
            accountManager.link(claimedId.get(), areq);
        } else {
        // Both are null, we are going to create a new account below.
        }
    }
    try {
        final com.google.gerrit.server.account.AuthResult arsp;
        switch(mode) {
            case REGISTER:
            case SIGN_IN:
                arsp = accountManager.authenticate(areq);
                final Cookie lastId = new Cookie(OpenIdUrls.LASTID_COOKIE, "");
                lastId.setPath(req.getContextPath() + "/login/");
                if (remember) {
                    lastId.setValue(rediscoverIdentifier);
                    lastId.setMaxAge(LASTID_AGE);
                } else {
                    lastId.setMaxAge(0);
                }
                rsp.addCookie(lastId);
                webSession.get().login(arsp, remember);
                if (arsp.isNew() && claimedIdentifier != null) {
                    final com.google.gerrit.server.account.AuthRequest linkReq = new com.google.gerrit.server.account.AuthRequest(claimedIdentifier);
                    linkReq.setDisplayName(areq.getDisplayName());
                    linkReq.setEmailAddress(areq.getEmailAddress());
                    accountManager.link(arsp.getAccountId(), linkReq);
                }
                callback(arsp.isNew(), req, rsp);
                break;
            case LINK_IDENTIY:
                {
                    arsp = accountManager.link(identifiedUser.get().getAccountId(), areq);
                    webSession.get().login(arsp, remember);
                    callback(false, req, rsp);
                    break;
                }
        }
    } catch (AccountException e) {
        log.error("OpenID authentication failure", e);
        cancelWithError(req, rsp, "Contact site administrator");
    }
}
#end_block

#method_before
public static PatchLineComment from(Change.Id changeId, PatchLineComment.Status status, Comment c) {
    PatchLineComment.Key key = new PatchLineComment.Key(new Patch.Key(new PatchSet.Id(changeId, c.key.patchSetId), c.key.filename), c.key.uuid);
    PatchLineComment plc = new PatchLineComment(key, c.lineNbr, c.author.getId(), c.parentUuid, c.writtenOn);
    plc.setSide(c.side);
    plc.setMessage(c.message);
    if (c.range != null) {
        Comment.Range r = c.range;
        plc.setRange(new CommentRange(r.startLine, r.startChar, r.endLine, r.endChar));
    }
    plc.setTag(c.tag);
    plc.setRevId(new RevId(c.revId));
    plc.setStatus(status);
    plc.setRealAuthor(c.getRealAuthor().getId());
    return plc;
}
#method_after
public static PatchLineComment from(Change.Id changeId, PatchLineComment.Status status, Comment c) {
    PatchLineComment.Key key = new PatchLineComment.Key(new Patch.Key(new PatchSet.Id(changeId, c.key.patchSetId), c.key.filename), c.key.uuid);
    PatchLineComment plc = new PatchLineComment(key, c.lineNbr, c.author.getId(), c.parentUuid, c.writtenOn);
    plc.setSide(c.side);
    plc.setMessage(c.message);
    if (c.range != null) {
        Comment.Range r = c.range;
        plc.setRange(new CommentRange(r.startLine, r.startChar, r.endLine, r.endChar));
    }
    plc.setTag(c.tag);
    plc.setRevId(new RevId(c.revId));
    plc.setStatus(status);
    plc.setRealAuthor(c.getRealAuthor().getId());
    plc.setUnresolved(c.unresolved);
    return plc;
}
#end_block

#method_before
public Comment asComment(String serverId) {
    Comment c = new Comment(key.asCommentKey(), author, writtenOn, side, message, serverId);
    c.setRevId(revId);
    c.setRange(range);
    c.lineNbr = lineNbr;
    c.parentUuid = parentUuid;
    c.tag = tag;
    c.setRealAuthor(getRealAuthor());
    return c;
}
#method_after
public Comment asComment(String serverId) {
    Comment c = new Comment(key.asCommentKey(), author, writtenOn, side, message, serverId, unresolved);
    c.setRevId(revId);
    c.setRange(range);
    c.lineNbr = lineNbr;
    c.parentUuid = parentUuid;
    c.tag = tag;
    c.setRealAuthor(getRealAuthor());
    return c;
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (o instanceof PatchLineComment) {
        PatchLineComment c = (PatchLineComment) o;
        return Objects.equals(key, c.getKey()) && Objects.equals(lineNbr, c.getLine()) && Objects.equals(author, c.getAuthor()) && Objects.equals(writtenOn, c.getWrittenOn()) && Objects.equals(status, c.getStatus().getCode()) && Objects.equals(side, c.getSide()) && Objects.equals(message, c.getMessage()) && Objects.equals(parentUuid, c.getParentUuid()) && Objects.equals(range, c.getRange()) && Objects.equals(revId, c.getRevId()) && Objects.equals(tag, c.getTag());
    }
    return false;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o instanceof PatchLineComment) {
        PatchLineComment c = (PatchLineComment) o;
        return Objects.equals(key, c.getKey()) && Objects.equals(lineNbr, c.getLine()) && Objects.equals(author, c.getAuthor()) && Objects.equals(writtenOn, c.getWrittenOn()) && Objects.equals(status, c.getStatus().getCode()) && Objects.equals(side, c.getSide()) && Objects.equals(message, c.getMessage()) && Objects.equals(parentUuid, c.getParentUuid()) && Objects.equals(range, c.getRange()) && Objects.equals(revId, c.getRevId()) && Objects.equals(tag, c.getTag()) && Objects.equals(unresolved, c.getUnresolved());
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("PatchLineComment{");
    builder.append("key=").append(key).append(',');
    builder.append("lineNbr=").append(lineNbr).append(',');
    builder.append("author=").append(author.get()).append(',');
    builder.append("realAuthor=").append(realAuthor != null ? realAuthor.get() : "").append(',');
    builder.append("writtenOn=").append(writtenOn.toString()).append(',');
    builder.append("status=").append(status).append(',');
    builder.append("side=").append(side).append(',');
    builder.append("message=").append(Objects.toString(message, "")).append(',');
    builder.append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',');
    builder.append("range=").append(Objects.toString(range, "")).append(',');
    builder.append("revId=").append(revId != null ? revId.get() : "");
    builder.append("tag=").append(Objects.toString(tag, ""));
    builder.append('}');
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("PatchLineComment{");
    builder.append("key=").append(key).append(',');
    builder.append("lineNbr=").append(lineNbr).append(',');
    builder.append("author=").append(author.get()).append(',');
    builder.append("realAuthor=").append(realAuthor != null ? realAuthor.get() : "").append(',');
    builder.append("writtenOn=").append(writtenOn.toString()).append(',');
    builder.append("status=").append(status).append(',');
    builder.append("side=").append(side).append(',');
    builder.append("message=").append(Objects.toString(message, "")).append(',');
    builder.append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',');
    builder.append("range=").append(Objects.toString(range, "")).append(',');
    builder.append("revId=").append(revId != null ? revId.get() : "").append(',');
    builder.append("tag=").append(Objects.toString(tag, "")).append(',');
    builder.append("unresolved=").append(unresolved);
    builder.append('}');
    return builder.toString();
}
#end_block

#method_before
public Iterable<PatchSetData> sort(Iterable<ChangeData> in) throws OrmException, IOException {
    Multimap<Project.NameKey, ChangeData> byProject = ArrayListMultimap.create();
    for (ChangeData cd : in) {
        byProject.put(cd.change().getProject(), cd);
    }
    List<List<PatchSetData>> sortedByProject = new ArrayList<>(byProject.keySet().size());
    for (Map.Entry<Project.NameKey, Collection<ChangeData>> e : byProject.asMap().entrySet()) {
        sortedByProject.add(sortProject(e.getKey(), e.getValue()));
    }
    Collections.sort(sortedByProject, PROJECT_LIST_SORTER);
    return Iterables.concat(sortedByProject);
}
#method_after
public Iterable<PatchSetData> sort(Iterable<ChangeData> in) throws OrmException, IOException {
    ListMultimap<Project.NameKey, ChangeData> byProject = MultimapBuilder.hashKeys().arrayListValues().build();
    for (ChangeData cd : in) {
        byProject.put(cd.change().getProject(), cd);
    }
    List<List<PatchSetData>> sortedByProject = new ArrayList<>(byProject.keySet().size());
    for (Map.Entry<Project.NameKey, Collection<ChangeData>> e : byProject.asMap().entrySet()) {
        sortedByProject.add(sortProject(e.getKey(), e.getValue()));
    }
    Collections.sort(sortedByProject, PROJECT_LIST_SORTER);
    return Iterables.concat(sortedByProject);
}
#end_block

#method_before
private List<PatchSetData> sortProject(Project.NameKey project, Collection<ChangeData> in) throws OrmException, IOException {
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        rw.setRetainBody(retainBody);
        Multimap<RevCommit, PatchSetData> byCommit = byCommit(rw, in);
        if (byCommit.isEmpty()) {
            return ImmutableList.of();
        } else if (byCommit.size() == 1) {
            return ImmutableList.of(byCommit.values().iterator().next());
        }
        // Walk from all patch set SHA-1s, and terminate as soon as we've found
        // everything we're looking for. This is equivalent to just sorting the
        // list of commits by the RevWalk's configured order.
        // 
        // Partially topo sort the list, ensuring no parent is emitted before a
        // direct child that is also in the input set. This preserves the stable,
        // expected sort in the case where many commits share the same timestamp,
        // e.g. a quick rebase. It also avoids JGit's topo sort, which slurps all
        // interesting commits at the beginning, which is a problem since we don't
        // know which commits to mark as uninteresting. Finding a reasonable set
        // of commits to mark uninteresting (the "rootmost" set) is at least as
        // difficult as just implementing this partial topo sort ourselves.
        // 
        // (This is slightly less efficient than JGit's topo sort, which uses a
        // private in-degree field in RevCommit rather than multimaps. We assume
        // the input size is small enough that this is not an issue.)
        Set<RevCommit> commits = byCommit.keySet();
        Multimap<RevCommit, RevCommit> children = collectChildren(commits);
        Multimap<RevCommit, RevCommit> pending = ArrayListMultimap.create();
        Deque<RevCommit> todo = new ArrayDeque<>();
        RevFlag done = rw.newFlag("done");
        markStart(rw, commits);
        int expected = commits.size();
        int found = 0;
        RevCommit c;
        List<PatchSetData> result = new ArrayList<>(expected);
        while (found < expected && (c = rw.next()) != null) {
            if (!commits.contains(c)) {
                continue;
            }
            todo.clear();
            todo.add(c);
            int i = 0;
            while (!todo.isEmpty()) {
                // Sanity check: we can't pop more than N pending commits, otherwise
                // we have an infinite loop due to programmer error or something.
                checkState(++i <= commits.size(), "Too many pending steps while sorting %s", commits);
                RevCommit t = todo.removeFirst();
                if (t.has(done)) {
                    continue;
                }
                boolean ready = true;
                for (RevCommit child : children.get(t)) {
                    if (!child.has(done)) {
                        pending.put(child, t);
                        ready = false;
                    }
                }
                if (ready) {
                    found += emit(t, byCommit, result, done);
                    todo.addAll(pending.get(t));
                }
            }
        }
        return result;
    }
}
#method_after
private List<PatchSetData> sortProject(Project.NameKey project, Collection<ChangeData> in) throws OrmException, IOException {
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        rw.setRetainBody(retainBody);
        ListMultimap<RevCommit, PatchSetData> byCommit = byCommit(rw, in);
        if (byCommit.isEmpty()) {
            return ImmutableList.of();
        } else if (byCommit.size() == 1) {
            return ImmutableList.of(byCommit.values().iterator().next());
        }
        // Walk from all patch set SHA-1s, and terminate as soon as we've found
        // everything we're looking for. This is equivalent to just sorting the
        // list of commits by the RevWalk's configured order.
        // 
        // Partially topo sort the list, ensuring no parent is emitted before a
        // direct child that is also in the input set. This preserves the stable,
        // expected sort in the case where many commits share the same timestamp,
        // e.g. a quick rebase. It also avoids JGit's topo sort, which slurps all
        // interesting commits at the beginning, which is a problem since we don't
        // know which commits to mark as uninteresting. Finding a reasonable set
        // of commits to mark uninteresting (the "rootmost" set) is at least as
        // difficult as just implementing this partial topo sort ourselves.
        // 
        // (This is slightly less efficient than JGit's topo sort, which uses a
        // private in-degree field in RevCommit rather than multimaps. We assume
        // the input size is small enough that this is not an issue.)
        Set<RevCommit> commits = byCommit.keySet();
        ListMultimap<RevCommit, RevCommit> children = collectChildren(commits);
        ListMultimap<RevCommit, RevCommit> pending = MultimapBuilder.hashKeys().arrayListValues().build();
        Deque<RevCommit> todo = new ArrayDeque<>();
        RevFlag done = rw.newFlag("done");
        markStart(rw, commits);
        int expected = commits.size();
        int found = 0;
        RevCommit c;
        List<PatchSetData> result = new ArrayList<>(expected);
        while (found < expected && (c = rw.next()) != null) {
            if (!commits.contains(c)) {
                continue;
            }
            todo.clear();
            todo.add(c);
            int i = 0;
            while (!todo.isEmpty()) {
                // Sanity check: we can't pop more than N pending commits, otherwise
                // we have an infinite loop due to programmer error or something.
                checkState(++i <= commits.size(), "Too many pending steps while sorting %s", commits);
                RevCommit t = todo.removeFirst();
                if (t.has(done)) {
                    continue;
                }
                boolean ready = true;
                for (RevCommit child : children.get(t)) {
                    if (!child.has(done)) {
                        pending.put(child, t);
                        ready = false;
                    }
                }
                if (ready) {
                    found += emit(t, byCommit, result, done);
                    todo.addAll(pending.get(t));
                }
            }
        }
        return result;
    }
}
#end_block

#method_before
private static Multimap<RevCommit, RevCommit> collectChildren(Set<RevCommit> commits) {
    Multimap<RevCommit, RevCommit> children = ArrayListMultimap.create();
    for (RevCommit c : commits) {
        for (RevCommit p : c.getParents()) {
            if (commits.contains(p)) {
                children.put(p, c);
            }
        }
    }
    return children;
}
#method_after
private static ListMultimap<RevCommit, RevCommit> collectChildren(Set<RevCommit> commits) {
    ListMultimap<RevCommit, RevCommit> children = MultimapBuilder.hashKeys().arrayListValues().build();
    for (RevCommit c : commits) {
        for (RevCommit p : c.getParents()) {
            if (commits.contains(p)) {
                children.put(p, c);
            }
        }
    }
    return children;
}
#end_block

#method_before
private static int emit(RevCommit c, Multimap<RevCommit, PatchSetData> byCommit, List<PatchSetData> result, RevFlag done) {
    if (c.has(done)) {
        return 0;
    }
    c.add(done);
    Collection<PatchSetData> psds = byCommit.get(c);
    if (!psds.isEmpty()) {
        result.addAll(psds);
        return 1;
    }
    return 0;
}
#method_after
private static int emit(RevCommit c, ListMultimap<RevCommit, PatchSetData> byCommit, List<PatchSetData> result, RevFlag done) {
    if (c.has(done)) {
        return 0;
    }
    c.add(done);
    Collection<PatchSetData> psds = byCommit.get(c);
    if (!psds.isEmpty()) {
        result.addAll(psds);
        return 1;
    }
    return 0;
}
#end_block

#method_before
private Multimap<RevCommit, PatchSetData> byCommit(RevWalk rw, Collection<ChangeData> in) throws OrmException, IOException {
    Multimap<RevCommit, PatchSetData> byCommit = ArrayListMultimap.create(in.size(), 1);
    for (ChangeData cd : in) {
        PatchSet maxPs = null;
        for (PatchSet ps : cd.patchSets()) {
            if (shouldInclude(ps) && (maxPs == null || ps.getId().get() > maxPs.getId().get())) {
                maxPs = ps;
            }
        }
        if (maxPs == null) {
            // No patch sets matched.
            continue;
        }
        ObjectId id = ObjectId.fromString(maxPs.getRevision().get());
        try {
            RevCommit c = rw.parseCommit(id);
            byCommit.put(c, PatchSetData.create(cd, maxPs, c));
        } catch (MissingObjectException | IncorrectObjectTypeException e) {
            log.warn("missing commit " + id.name() + " for patch set " + maxPs.getId(), e);
        }
    }
    return byCommit;
}
#method_after
private ListMultimap<RevCommit, PatchSetData> byCommit(RevWalk rw, Collection<ChangeData> in) throws OrmException, IOException {
    ListMultimap<RevCommit, PatchSetData> byCommit = MultimapBuilder.hashKeys(in.size()).arrayListValues(1).build();
    for (ChangeData cd : in) {
        PatchSet maxPs = null;
        for (PatchSet ps : cd.patchSets()) {
            if (shouldInclude(ps) && (maxPs == null || ps.getId().get() > maxPs.getId().get())) {
                maxPs = ps;
            }
        }
        if (maxPs == null) {
            // No patch sets matched.
            continue;
        }
        ObjectId id = ObjectId.fromString(maxPs.getRevision().get());
        try {
            RevCommit c = rw.parseCommit(id);
            byCommit.put(c, PatchSetData.create(cd, maxPs, c));
        } catch (MissingObjectException | IncorrectObjectTypeException e) {
            log.warn("missing commit " + id.name() + " for patch set " + maxPs.getId(), e);
        }
    }
    return byCommit;
}
#end_block

#method_before
@Override
public void configure() {
    factory(ChangeUpdate.Factory.class);
    factory(ChangeDraftUpdate.Factory.class);
    factory(DraftCommentNotes.Factory.class);
    factory(RobotCommentUpdate.Factory.class);
    factory(RobotCommentNotes.Factory.class);
    factory(NoteDbUpdateManager.Factory.class);
    if (!useTestBindings) {
        install(ChangeNotesCache.module());
        if (cfg.getBoolean("noteDb", null, "testRebuilderWrapper", false)) {
            // Yes, another variety of test bindings with a different way of
            // configuring it.
            bind(ChangeRebuilder.class).to(TestChangeRebuilderWrapper.class);
        } else {
            bind(ChangeRebuilder.class).to(ChangeRebuilderImpl.class);
        }
    } else {
        bind(ChangeRebuilder.class).toInstance(new ChangeRebuilder(null) {

            @Override
            public Result rebuild(ReviewDb db, Change.Id changeId) {
                return null;
            }

            @Override
            public Result rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) {
                return null;
            }

            @Override
            public NoteDbUpdateManager stage(ReviewDb db, Change.Id changeId) {
                return null;
            }

            @Override
            public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) {
                return null;
            }

            @Override
            public void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) {
            // Do nothing.
            }
        });
        bind(new TypeLiteral<Cache<ChangeNotesCache.Key, ChangeNotesState>>() {
        }).annotatedWith(Names.named(ChangeNotesCache.CACHE_NAME)).toInstance(CacheBuilder.newBuilder().<ChangeNotesCache.Key, ChangeNotesState>build());
    }
}
#method_after
@Override
public void configure() {
    factory(ChangeUpdate.Factory.class);
    factory(ChangeDraftUpdate.Factory.class);
    factory(DraftCommentNotes.Factory.class);
    factory(RobotCommentUpdate.Factory.class);
    factory(RobotCommentNotes.Factory.class);
    factory(NoteDbUpdateManager.Factory.class);
    if (!useTestBindings) {
        install(ChangeNotesCache.module());
        if (cfg.getBoolean("noteDb", null, "testRebuilderWrapper", false)) {
            // Yes, another variety of test bindings with a different way of
            // configuring it.
            bind(ChangeRebuilder.class).to(TestChangeRebuilderWrapper.class);
        } else {
            bind(ChangeRebuilder.class).to(ChangeRebuilderImpl.class);
        }
    } else {
        bind(ChangeRebuilder.class).toInstance(new ChangeRebuilder(null) {

            @Override
            public Result rebuild(ReviewDb db, Change.Id changeId) {
                return null;
            }

            @Override
            public Result rebuildEvenIfReadOnly(ReviewDb db, Id changeId) {
                return null;
            }

            @Override
            public Result rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) {
                return null;
            }

            @Override
            public NoteDbUpdateManager stage(ReviewDb db, Change.Id changeId) {
                return null;
            }

            @Override
            public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) {
                return null;
            }

            @Override
            public void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) {
            // Do nothing.
            }
        });
        bind(new TypeLiteral<Cache<ChangeNotesCache.Key, ChangeNotesState>>() {
        }).annotatedWith(Names.named(ChangeNotesCache.CACHE_NAME)).toInstance(CacheBuilder.newBuilder().<ChangeNotesCache.Key, ChangeNotesState>build());
    }
}
#end_block

#method_before
@Override
public ResultSet<AccountState> read() throws OrmException {
    IndexSearcher searcher = null;
    try {
        searcher = acquire();
        int realLimit = opts.start() + opts.limit();
        TopFieldDocs docs = searcher.search(query, realLimit, sort);
        List<AccountState> result = new ArrayList<>(docs.scoreDocs.length);
        for (int i = opts.start(); i < docs.scoreDocs.length; i++) {
            ScoreDoc sd = docs.scoreDocs[i];
            Document doc = searcher.doc(sd.doc, fields(opts));
            result.add(toAccountState(doc));
        }
        final List<AccountState> r = Collections.unmodifiableList(result);
        return new ResultSet<AccountState>() {

            @Override
            public Iterator<AccountState> iterator() {
                return r.iterator();
            }

            @Override
            public List<AccountState> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        if (searcher != null) {
            try {
                release(searcher);
            } catch (IOException e) {
                log.warn("cannot release Lucene searcher", e);
            }
        }
    }
}
#method_after
@Override
public ResultSet<AccountState> read() throws OrmException {
    IndexSearcher searcher = null;
    try {
        searcher = acquire();
        int realLimit = opts.start() + opts.limit();
        TopFieldDocs docs = searcher.search(query, realLimit, sort);
        List<AccountState> result = new ArrayList<>(docs.scoreDocs.length);
        for (int i = opts.start(); i < docs.scoreDocs.length; i++) {
            ScoreDoc sd = docs.scoreDocs[i];
            Document doc = searcher.doc(sd.doc, IndexUtils.accountFields(opts));
            result.add(toAccountState(doc));
        }
        final List<AccountState> r = Collections.unmodifiableList(result);
        return new ResultSet<AccountState>() {

            @Override
            public Iterator<AccountState> iterator() {
                return r.iterator();
            }

            @Override
            public List<AccountState> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        if (searcher != null) {
            try {
                release(searcher);
            } catch (IOException e) {
                log.warn("cannot release Lucene searcher", e);
            }
        }
    }
}
#end_block

#method_before
private AccountState toAccountState(Document doc) {
    Account.Id id = new Account.Id(doc.getField(ID.getName()).numericValue().intValue());
    // to reindex when those change.
    return accountCache.get(id);
}
#method_after
private AccountState toAccountState(Document doc) {
    Account.Id id = new Account.Id(doc.getField(ID.getName()).numericValue().intValue());
    // to reindex when those change.
    return accountCache.get().get(id);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), change.getStatus().name().toLowerCase()));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(db, ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(db, ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null, null);
    if (notify != NotifyHandling.NONE) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(db, patchSet.getId(), ctx.getUser(), ctx.getWhen(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), change.getStatus().name().toLowerCase()));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(db, ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(db, ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null, description);
    if (notify != NotifyHandling.NONE) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), ctx.getWhen(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (notify != NotifyHandling.NONE) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(ctx.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.addReviewers(oldReviewers.byState(REVIEWER));
            cm.addExtraCC(oldReviewers.byState(CC));
            cm.setNotify(notify);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty()) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(ctx.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.addReviewers(oldReviewers.byState(REVIEWER));
            cm.addExtraCC(oldReviewers.byState(CC));
            cm.setNotify(notify);
            cm.setAccountsToNotify(accountsToNotify);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
    }
}
#end_block

#method_before
private void validate(RepoContext ctx) throws AuthException, ResourceConflictException, IOException, OrmException {
    if (!origCtl.canAddPatchSet(ctx.getDb())) {
        throw new AuthException("cannot add patch set");
    }
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    String refName = getPatchSetId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), origCtl.getProjectControl().getProject(), origCtl.getRefControl().getRefName(), commit, ctx.getIdentifiedUser());
    try {
        commitValidatorsFactory.create(validatePolicy, origCtl.getRefControl(), new NoSshInfo(), ctx.getRepository()).validate(event);
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws AuthException, ResourceConflictException, IOException, OrmException {
    if (checkAddPatchSetPermission && !origCtl.canAddPatchSet(ctx.getDb())) {
        throw new AuthException("cannot add patch set");
    }
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    String refName = getPatchSetId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), origCtl.getProjectControl().getProject(), origCtl.getRefControl().getRefName(), commit, ctx.getIdentifiedUser());
    try {
        commitValidatorsFactory.create(validatePolicy, origCtl.getRefControl(), new NoSshInfo(), ctx.getRepository()).validate(event);
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#end_block

#method_before
@Test
public void hiddenDraftInTopic() throws Exception {
    RevCommit initialHead = getRemoteHead();
    RevCommit a = commitBuilder().add("a", "1").message("change 1").create();
    pushHead(testRepo, "refs/for/master/" + name("topic"), false);
    String id1 = getChangeId(a);
    testRepo.reset(initialHead);
    commitBuilder().add("b", "2").message("invisible change").create();
    pushHead(testRepo, "refs/drafts/master/" + name("topic"), false);
    setApiUser(user);
    SubmittedTogetherInfo result = gApi.changes().id(id1).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    if (isSubmitWholeTopicEnabled()) {
        assertThat(result.changes).hasSize(1);
        assertThat(result.changes.get(0).changeId).isEqualTo(id1);
        assertThat(result.nonVisibleChanges).isEqualTo(1);
    } else {
        assertThat(result.changes).hasSize(0);
        assertThat(result.nonVisibleChanges).isEqualTo(0);
    }
}
#method_after
@Test
public void hiddenDraftInTopic() throws Exception {
    RevCommit initialHead = getRemoteHead();
    RevCommit a = commitBuilder().add("a", "1").message("change 1").create();
    pushHead(testRepo, "refs/for/master/" + name("topic"), false);
    String id1 = getChangeId(a);
    testRepo.reset(initialHead);
    commitBuilder().add("b", "2").message("invisible change").create();
    pushHead(testRepo, "refs/drafts/master/" + name("topic"), false);
    setApiUser(user);
    SubmittedTogetherInfo result = gApi.changes().id(id1).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    if (isSubmitWholeTopicEnabled()) {
        assertThat(result.changes).hasSize(1);
        assertThat(result.changes.get(0).changeId).isEqualTo(id1);
        assertThat(result.nonVisibleChanges).isEqualTo(1);
    } else {
        assertThat(result.changes).isEmpty();
        assertThat(result.nonVisibleChanges).isEqualTo(0);
    }
}
#end_block

#method_before
@Test
public void hiddenDraftInTopicOldApi() throws Exception {
    RevCommit initialHead = getRemoteHead();
    RevCommit a = commitBuilder().add("a", "1").message("change 1").create();
    pushHead(testRepo, "refs/for/master/" + name("topic"), false);
    String id1 = getChangeId(a);
    testRepo.reset(initialHead);
    commitBuilder().add("b", "2").message("invisible change").create();
    pushHead(testRepo, "refs/drafts/master/" + name("topic"), false);
    setApiUser(user);
    if (isSubmitWholeTopicEnabled()) {
        exception.expect(AuthException.class);
        exception.expectMessage("change would be submitted with a change that you cannot see");
        gApi.changes().id(id1).submittedTogether();
    } else {
        List<ChangeInfo> result = gApi.changes().id(id1).submittedTogether();
        assertThat(result).hasSize(0);
    }
}
#method_after
@Test
public void hiddenDraftInTopicOldApi() throws Exception {
    RevCommit initialHead = getRemoteHead();
    RevCommit a = commitBuilder().add("a", "1").message("change 1").create();
    pushHead(testRepo, "refs/for/master/" + name("topic"), false);
    String id1 = getChangeId(a);
    testRepo.reset(initialHead);
    commitBuilder().add("b", "2").message("invisible change").create();
    pushHead(testRepo, "refs/drafts/master/" + name("topic"), false);
    setApiUser(user);
    if (isSubmitWholeTopicEnabled()) {
        exception.expect(AuthException.class);
        exception.expectMessage("change would be submitted with a change that you cannot see");
        gApi.changes().id(id1).submittedTogether();
    } else {
        List<ChangeInfo> result = gApi.changes().id(id1).submittedTogether();
        assertThat(result).isEmpty();
    }
}
#end_block

#method_before
@Override
public BinaryResult content() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult content() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DiffInfo diff() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public DiffInfo diff() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DiffInfo diff(String base) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public DiffInfo diff(String base) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DiffInfo diff(int parent) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public DiffInfo diff(int parent) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DiffRequest diffRequest() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public DiffRequest diffRequest() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Multimap<Account.Id, Change.Id> imports = ArrayListMultimap.create();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT " + "account_id, " + "change_id " + "FROM starred_changes")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            Change.Id changeId = new Change.Id(rs.getInt(2));
            imports.put(accountId, changeId);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        ObjectId id = StarredChangesUtil.writeLabels(git, StarredChangesUtil.DEFAULT_LABELS);
        for (Map.Entry<Account.Id, Change.Id> e : imports.entries()) {
            bru.addCommand(new ReceiveCommand(ObjectId.zeroId(), id, RefNames.refsStarredChanges(e.getValue(), e.getKey())));
        }
        bru.execute(rw, new TextProgressMonitor());
    } catch (IOException ex) {
        throw new OrmException(ex);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    ListMultimap<Account.Id, Change.Id> imports = MultimapBuilder.hashKeys().arrayListValues().build();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT " + "account_id, " + "change_id " + "FROM starred_changes")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            Change.Id changeId = new Change.Id(rs.getInt(2));
            imports.put(accountId, changeId);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        ObjectId id = StarredChangesUtil.writeLabels(git, StarredChangesUtil.DEFAULT_LABELS);
        for (Map.Entry<Account.Id, Change.Id> e : imports.entries()) {
            bru.addCommand(new ReceiveCommand(ObjectId.zeroId(), id, RefNames.refsStarredChanges(e.getValue(), e.getKey())));
        }
        bru.execute(rw, new TextProgressMonitor());
    } catch (IOException ex) {
        throw new OrmException(ex);
    }
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    if ("GET".equals(req.getMethod()) && !Strings.isNullOrEmpty(req.getParameter("q"))) {
        HttpServletResponse rsp = (HttpServletResponse) response;
        try {
            List<DocResult> result = searcher.doQuery(request.getParameter("q"));
            Multimap<String, String> config = LinkedHashMultimap.create();
            RestApiServlet.replyJson(req, rsp, config, result);
        } catch (DocQueryException e) {
            log.error("Doc search failed:", e);
            rsp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    } else {
        chain.doFilter(request, response);
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    if ("GET".equals(req.getMethod()) && !Strings.isNullOrEmpty(req.getParameter("q"))) {
        HttpServletResponse rsp = (HttpServletResponse) response;
        try {
            List<DocResult> result = searcher.doQuery(request.getParameter("q"));
            RestApiServlet.replyJson(req, rsp, ImmutableListMultimap.of(), result);
        } catch (DocQueryException e) {
            log.error("Doc search failed:", e);
            rsp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    } else {
        chain.doFilter(request, response);
    }
}
#end_block

#method_before
@Override
protected ProjectAccess updateProjectConfig(CurrentUser user, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    gitRefUpdated.fire(config.getProject().getNameKey(), RefNames.REFS_CONFIG, base, commit.getId(), user.asIdentifiedUser().getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#method_after
@Override
protected ProjectAccess updateProjectConfig(ProjectControl projectControl, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    gitRefUpdated.fire(config.getProject().getNameKey(), RefNames.REFS_CONFIG, base, commit.getId(), projectControl.getUser().asIdentifiedUser().getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#end_block

#method_before
@Override
public synchronized void handleEmails() {
    IMAPClient imap;
    if (mailSettings.encryption != Encryption.NONE) {
        imap = new IMAPSClient(mailSettings.encryption.name(), false);
    } else {
        imap = new IMAPClient();
    }
    if (mailSettings.port > 0) {
        imap.setDefaultPort(mailSettings.port);
    }
    // Set a 30s timeout for each operation
    imap.setDefaultTimeout(30 * 1000);
    try {
        imap.connect(mailSettings.host);
        try {
            if (!imap.login(mailSettings.username, mailSettings.password)) {
                log.error("Could not login to IMAP server");
                return;
            }
            try {
                if (!imap.select(INBOX_FOLDER)) {
                    log.error("Could not select IMAP folder " + INBOX_FOLDER);
                    return;
                }
                // should fetch.
                if (!imap.fetch("1:*", "(INTERNALDATE)")) {
                    log.error("IMAP fetch failed. Will retry in next fetch cycle.");
                    return;
                }
                // Format of reply is one line per email and one line to indicate
                // that the fetch was successful.
                // Example:
                // * 1 FETCH (INTERNALDATE "Mon, 24 Oct 2016 16:53:22 +0200 (CEST)")
                // * 2 FETCH (INTERNALDATE "Mon, 24 Oct 2016 16:53:22 +0200 (CEST)")
                // AAAC OK FETCH completed.
                int numMessages = imap.getReplyStrings().length - 1;
                log.info("Fetched " + numMessages + " messages via IMAP");
                if (numMessages == 0) {
                    return;
                }
                // Fetch the full version of all emails
                List<MailMessage> mailMessages = new ArrayList<>(numMessages);
                for (int i = 1; i <= numMessages; i++) {
                    if (imap.fetch(i + ":" + i, "(BODY.PEEK[])")) {
                        // Obtain full reply
                        String[] rawMessage = imap.getReplyStrings();
                        if (rawMessage.length < 2) {
                            continue;
                        }
                        // First and last line are IMAP status codes. We have already
                        // checked, that the fetch returned true (OK), so we safely ignore
                        // those two lines.
                        StringBuilder b = new StringBuilder(2 * (rawMessage.length - 2));
                        for (int j = 1; j < rawMessage.length - 1; j++) {
                            if (j > 1) {
                                b.append("\n");
                            }
                            b.append(rawMessage[j]);
                        }
                        try {
                            MailMessage mailMessage = RawMailParser.parse(b.toString());
                            if (pendingDeletion.contains(mailMessage.id())) {
                                // Mark message as deleted
                                if (imap.store(i + ":" + i, "+FLAGS", "(\\Deleted)")) {
                                    pendingDeletion.remove(mailMessage.id());
                                } else {
                                    log.error("Could not mark mail message as deleted: " + mailMessage.id());
                                }
                            } else {
                                mailMessages.add(mailMessage);
                            }
                        } catch (MailParsingException e) {
                            log.error("Exception while parsing email after IMAP fetch", e);
                        }
                    } else {
                        log.error("IMAP fetch failed. Will retry in next fetch cycle.");
                    }
                }
                // Permanently delete emails marked for deletion
                if (!imap.expunge()) {
                    log.error("Could not expunge IMAP emails");
                }
            // TODO(hiesel) Call email handling logic with mailMessages
            } finally {
                imap.logout();
            }
        } finally {
            imap.disconnect();
        }
    } catch (IOException e) {
        log.error("Error while talking to IMAP server", e);
        return;
    }
}
#method_after
@Override
public synchronized void handleEmails(boolean async) {
    IMAPClient imap;
    if (mailSettings.encryption != Encryption.NONE) {
        imap = new IMAPSClient(mailSettings.encryption.name(), false);
    } else {
        imap = new IMAPClient();
    }
    if (mailSettings.port > 0) {
        imap.setDefaultPort(mailSettings.port);
    }
    // Set a 30s timeout for each operation
    imap.setDefaultTimeout(30 * 1000);
    try {
        imap.connect(mailSettings.host);
        try {
            if (!imap.login(mailSettings.username, mailSettings.password)) {
                log.error("Could not login to IMAP server");
                return;
            }
            try {
                if (!imap.select(INBOX_FOLDER)) {
                    log.error("Could not select IMAP folder " + INBOX_FOLDER);
                    return;
                }
                // should fetch.
                if (!imap.fetch("1:*", "(INTERNALDATE)")) {
                    log.error("IMAP fetch failed. Will retry in next fetch cycle.");
                    return;
                }
                // Format of reply is one line per email and one line to indicate
                // that the fetch was successful.
                // Example:
                // * 1 FETCH (INTERNALDATE "Mon, 24 Oct 2016 16:53:22 +0200 (CEST)")
                // * 2 FETCH (INTERNALDATE "Mon, 24 Oct 2016 16:53:22 +0200 (CEST)")
                // AAAC OK FETCH completed.
                int numMessages = imap.getReplyStrings().length - 1;
                log.info("Fetched " + numMessages + " messages via IMAP");
                if (numMessages == 0) {
                    return;
                }
                // Fetch the full version of all emails
                List<MailMessage> mailMessages = new ArrayList<>(numMessages);
                for (int i = 1; i <= numMessages; i++) {
                    if (imap.fetch(i + ":" + i, "(BODY.PEEK[])")) {
                        // Obtain full reply
                        String[] rawMessage = imap.getReplyStrings();
                        if (rawMessage.length < 2) {
                            continue;
                        }
                        // First and last line are IMAP status codes. We have already
                        // checked, that the fetch returned true (OK), so we safely ignore
                        // those two lines.
                        StringBuilder b = new StringBuilder(2 * (rawMessage.length - 2));
                        for (int j = 1; j < rawMessage.length - 1; j++) {
                            if (j > 1) {
                                b.append("\n");
                            }
                            b.append(rawMessage[j]);
                        }
                        try {
                            MailMessage mailMessage = RawMailParser.parse(b.toString());
                            if (pendingDeletion.contains(mailMessage.id())) {
                                // Mark message as deleted
                                if (imap.store(i + ":" + i, "+FLAGS", "(\\Deleted)")) {
                                    pendingDeletion.remove(mailMessage.id());
                                } else {
                                    log.error("Could not mark mail message as deleted: " + mailMessage.id());
                                }
                            } else {
                                mailMessages.add(mailMessage);
                            }
                        } catch (MailParsingException e) {
                            log.error("Exception while parsing email after IMAP fetch", e);
                        }
                    } else {
                        log.error("IMAP fetch failed. Will retry in next fetch cycle.");
                    }
                }
                // Permanently delete emails marked for deletion
                if (!imap.expunge()) {
                    log.error("Could not expunge IMAP emails");
                }
                dispatchMailProcessor(mailMessages, async);
            } finally {
                imap.logout();
            }
        } finally {
            imap.disconnect();
        }
    } catch (IOException e) {
        log.error("Error while talking to IMAP server", e);
        return;
    }
}
#end_block

#method_before
private void gotoSibling(int offset) {
    if (offset > 0 && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(int offset) {
    if (offset > 0 && changeInfo.currentRevision() != null && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
public static CommentInfo create(String path, Side side, int parent, int line, CommentRange range) {
    CommentInfo n = createObject().cast();
    n.path(path);
    n.side(side);
    n.parent(parent);
    if (range != null) {
        n.line(range.endLine());
        n.range(range);
    } else if (line > 0) {
        n.line(line);
    }
    return n;
}
#method_after
public static CommentInfo create(String path, Side side, int line, CommentRange range, Boolean unresolved) {
    return create(path, side, 0, line, range, unresolved);
}
#end_block

#method_before
public static CommentInfo createReply(CommentInfo r) {
    CommentInfo n = createObject().cast();
    n.path(r.path());
    n.side(r.side());
    n.parent(r.parent());
    n.inReplyTo(r.id());
    if (r.hasRange()) {
        n.line(r.range().endLine());
        n.range(r.range());
    } else if (r.hasLine()) {
        n.line(r.line());
    }
    return n;
}
#method_after
public static CommentInfo createReply(CommentInfo r) {
    CommentInfo n = createObject().cast();
    n.path(r.path());
    n.side(r.side());
    n.parent(r.parent());
    n.inReplyTo(r.id());
    if (r.hasRange()) {
        n.line(r.range().endLine());
        n.range(r.range());
    } else if (r.hasLine()) {
        n.line(r.line());
    }
    n.unresolved(r.unresolved());
    return n;
}
#end_block

#method_before
public static CommentInfo copy(CommentInfo s) {
    CommentInfo n = createObject().cast();
    n.path(s.path());
    n.side(s.side());
    n.parent(s.parent());
    n.id(s.id());
    n.inReplyTo(s.inReplyTo());
    n.message(s.message());
    if (s.hasRange()) {
        n.line(s.range().endLine());
        n.range(s.range());
    } else if (s.hasLine()) {
        n.line(s.line());
    }
    return n;
}
#method_after
public static CommentInfo copy(CommentInfo s) {
    CommentInfo n = createObject().cast();
    n.path(s.path());
    n.side(s.side());
    n.parent(s.parent());
    n.id(s.id());
    n.inReplyTo(s.inReplyTo());
    n.message(s.message());
    if (s.hasRange()) {
        n.line(s.range().endLine());
        n.range(s.range());
    } else if (s.hasLine()) {
        n.line(s.line());
    }
    n.unresolved(s.unresolved());
    return n;
}
#end_block

#method_before
@BeforeClass
public static void startIndexService() throws InterruptedException, ExecutionException {
    if (node != null) {
        // do not start Elasticsearch twice
        return;
    }
    elasticDir = Files.createTempDir();
    Path elasticDirPath = elasticDir.toPath();
    Settings settings = Settings.settingsBuilder().put("cluster.name", "gerrit").put("node.name", "Gerrit Elasticsearch Test Node").put("node.local", true).put("discovery.zen.ping.multicast.enabled", false).put("index.store.fs.memory.enabled", true).put("index.gateway.type", "none").put("index.max_result_window", Integer.MAX_VALUE).put("gateway.type", "default").put("http.port", 0).put("discovery.zen.ping.unicast.hosts", "[\"localhost\"]").put("path.home", elasticDirPath.toAbsolutePath()).put("path.data", elasticDirPath.resolve("data").toAbsolutePath()).put("path.work", elasticDirPath.resolve("work").toAbsolutePath()).put("path.logs", elasticDirPath.resolve("logs").toAbsolutePath()).put("transport.tcp.connect_timeout", "60s").build();
    // Start the node
    node = NodeBuilder.nodeBuilder().settings(settings).node();
    // Wait for it to be ready
    node.client().admin().cluster().prepareHealth().setWaitForYellowStatus().execute().actionGet();
    createIndexes();
    assertThat(node.isClosed()).isFalse();
    port = getHttpPort();
}
#method_after
@BeforeClass
public static void startIndexService() throws InterruptedException, ExecutionException {
    if (nodeInfo != null) {
        // do not start Elasticsearch twice
        return;
    }
    nodeInfo = ElasticTestUtils.startElasticsearchNode();
    ElasticTestUtils.createAllIndexes(nodeInfo);
}
#end_block

#method_before
@After
public void cleanupIndex() {
    node.client().admin().indices().prepareDelete("gerrit").execute();
    createIndexes();
}
#method_after
@After
public void cleanupIndex() {
    if (nodeInfo != null) {
        ElasticTestUtils.deleteAllIndexes(nodeInfo);
        ElasticTestUtils.createAllIndexes(nodeInfo);
    }
}
#end_block

#method_before
@AfterClass
public static void stopElasticsearchServer() {
    if (node != null) {
        node.close();
        node = null;
    }
    if (elasticDir != null && elasticDir.delete()) {
        elasticDir = null;
    }
}
#method_after
@AfterClass
public static void stopElasticsearchServer() {
    if (nodeInfo != null) {
        nodeInfo.node.close();
        nodeInfo.elasticDir.delete();
        nodeInfo = null;
    }
}
#end_block

#method_before
@Override
protected Injector createInjector() {
    Config elasticsearchConfig = new Config(config);
    InMemoryModule.setDefaults(elasticsearchConfig);
    elasticsearchConfig.setEnum("index", null, "type", IndexType.ELASTICSEARCH);
    elasticsearchConfig.setString("index", null, "protocol", "http");
    elasticsearchConfig.setString("index", null, "hostname", "localhost");
    elasticsearchConfig.setString("index", null, "port", port);
    elasticsearchConfig.setString("index", null, "name", "gerrit");
    elasticsearchConfig.setBoolean("index", "elasticsearch", "test", true);
    return Guice.createInjector(new InMemoryModule(elasticsearchConfig, notesMigration));
}
#method_after
@Override
protected Injector createInjector() {
    Config elasticsearchConfig = new Config(config);
    InMemoryModule.setDefaults(elasticsearchConfig);
    ElasticTestUtils.configure(elasticsearchConfig, nodeInfo.port);
    return Guice.createInjector(new InMemoryModule(elasticsearchConfig, notesMigration));
}
#end_block

#method_before
public static MailMessage parse(String raw) throws MailParsingException {
    MailMessage.Builder messageBuilder = MailMessage.builder();
    Message mimeMessage;
    try {
        MessageBuilder builder = new DefaultMessageBuilder();
        mimeMessage = builder.parseMessage(new ByteArrayInputStream(raw.getBytes(UTF_8)));
    } catch (IOException | MimeException e) {
        throw new MailParsingException("Can't parse email", e);
    }
    // Add general headers
    messageBuilder.id(mimeMessage.getMessageId());
    messageBuilder.subject(mimeMessage.getSubject());
    messageBuilder.dateReceived(new DateTime(mimeMessage.getDate()));
    // Add From, To and Cc
    if (mimeMessage.getFrom() != null && mimeMessage.getFrom().size() > 0) {
        Mailbox from = mimeMessage.getFrom().get(0);
        messageBuilder.from(new Address(from.getName(), from.getAddress()));
    }
    if (mimeMessage.getTo() != null) {
        for (Mailbox m : mimeMessage.getTo().flatten()) {
            messageBuilder.addTo(new Address(m.getName(), m.getAddress()));
        }
    }
    if (mimeMessage.getCc() != null) {
        for (Mailbox m : mimeMessage.getCc().flatten()) {
            messageBuilder.addCc(new Address(m.getName(), m.getAddress()));
        }
    }
    // Add additional headers
    mimeMessage.getHeader().getFields().stream().filter(f -> !MAIN_HEADERS.contains(f.getName().toLowerCase())).forEach(f -> messageBuilder.addAdditionalHeader(f.getName() + ": " + f.getBody()));
    // Add text and html body parts
    StringBuilder textBuilder = new StringBuilder();
    StringBuilder htmlBuilder = new StringBuilder();
    try {
        handleMimePart(mimeMessage, textBuilder, htmlBuilder);
    } catch (IOException e) {
        throw new MailParsingException("Can't parse email", e);
    }
    messageBuilder.textContent(Strings.emptyToNull(textBuilder.toString()));
    messageBuilder.htmlContent(Strings.emptyToNull(htmlBuilder.toString()));
    try {
        // required attributes are missing, so that the caller doesn't fall over.
        return messageBuilder.build();
    } catch (IllegalStateException e) {
        throw new MailParsingException("Missing required attributes after email was parsed", e);
    }
}
#method_after
public static MailMessage parse(String raw) throws MailParsingException {
    MailMessage.Builder messageBuilder = MailMessage.builder();
    messageBuilder.rawContentUTF(raw);
    Message mimeMessage;
    try {
        MessageBuilder builder = new DefaultMessageBuilder();
        mimeMessage = builder.parseMessage(new ByteArrayInputStream(raw.getBytes(UTF_8)));
    } catch (IOException | MimeException e) {
        throw new MailParsingException("Can't parse email", e);
    }
    // Add general headers
    messageBuilder.id(mimeMessage.getMessageId());
    messageBuilder.subject(mimeMessage.getSubject());
    messageBuilder.dateReceived(new DateTime(mimeMessage.getDate()));
    // Add From, To and Cc
    if (mimeMessage.getFrom() != null && mimeMessage.getFrom().size() > 0) {
        Mailbox from = mimeMessage.getFrom().get(0);
        messageBuilder.from(new Address(from.getName(), from.getAddress()));
    }
    if (mimeMessage.getTo() != null) {
        for (Mailbox m : mimeMessage.getTo().flatten()) {
            messageBuilder.addTo(new Address(m.getName(), m.getAddress()));
        }
    }
    if (mimeMessage.getCc() != null) {
        for (Mailbox m : mimeMessage.getCc().flatten()) {
            messageBuilder.addCc(new Address(m.getName(), m.getAddress()));
        }
    }
    // Add additional headers
    mimeMessage.getHeader().getFields().stream().filter(f -> !MAIN_HEADERS.contains(f.getName().toLowerCase())).forEach(f -> messageBuilder.addAdditionalHeader(f.getName() + ": " + f.getBody()));
    // Add text and html body parts
    StringBuilder textBuilder = new StringBuilder();
    StringBuilder htmlBuilder = new StringBuilder();
    try {
        handleMimePart(mimeMessage, textBuilder, htmlBuilder);
    } catch (IOException e) {
        throw new MailParsingException("Can't parse email", e);
    }
    messageBuilder.textContent(Strings.emptyToNull(textBuilder.toString()));
    messageBuilder.htmlContent(Strings.emptyToNull(htmlBuilder.toString()));
    try {
        // required attributes are missing, so that the caller doesn't fall over.
        return messageBuilder.build();
    } catch (IllegalStateException e) {
        throw new MailParsingException("Missing required attributes after email was parsed", e);
    }
}
#end_block

#method_before
public static MailMessage parse(int[] chars) throws MailParsingException {
    StringBuilder b = new StringBuilder(chars.length);
    for (int c : chars) {
        b.append((char) c);
    }
    return parse(b.toString());
}
#method_after
public static MailMessage parse(int[] chars) throws MailParsingException {
    StringBuilder b = new StringBuilder(chars.length);
    for (int c : chars) {
        b.append((char) c);
    }
    MailMessage.Builder messageBuilder = parse(b.toString()).toBuilder();
    messageBuilder.rawContent(ImmutableList.copyOf(Ints.asList(chars)));
    return messageBuilder.build();
}
#end_block

#method_before
private boolean canSee(ReviewDb db, ChangeNotes notes, Account.Id accountId) {
    try {
        IdentifiedUser user = userFactory.create(accountId);
        return changeControlFactory.controlFor(notes, user).isVisible(db);
    } catch (OrmException | NoSuchChangeException e) {
        log.warn(String.format("Failed to check if account %d can see change %d", accountId.get(), notes.getChangeId().get()), e);
        return false;
    }
}
#method_after
private boolean canSee(ReviewDb db, ChangeNotes notes, Account.Id accountId) {
    try {
        IdentifiedUser user = userFactory.create(accountId);
        return changeControlFactory.controlFor(notes, user).isVisible(db);
    } catch (OrmException e) {
        log.warn(String.format("Failed to check if account %d can see change %d", accountId.get(), notes.getChangeId().get()), e);
        return false;
    }
}
#end_block

#method_before
@Override
public Map<String, GpgKeyInfo> apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException, PGPException, OrmException, IOException {
    GpgKeys.checkVisible(self, rsrc);
    List<AccountExternalId> existingExtIds = GpgKeys.getGpgExtIds(db.get(), rsrc.getUser().getAccountId()).toList();
    try (PublicKeyStore store = storeProvider.get()) {
        Set<Fingerprint> toRemove = readKeysToRemove(input, existingExtIds);
        List<PGPPublicKeyRing> newKeys = readKeysToAdd(input, toRemove);
        List<AccountExternalId> newExtIds = new ArrayList<>(existingExtIds.size());
        for (PGPPublicKeyRing keyRing : newKeys) {
            PGPPublicKey key = keyRing.getPublicKey();
            AccountExternalId.Key extIdKey = toExtIdKey(key.getFingerprint());
            if (accountIndexes.getSearchIndex() != null) {
                Account account = getAccountByExternalId(extIdKey.get());
                if (account != null) {
                    if (!account.getId().equals(rsrc.getUser().getAccountId())) {
                        throw new ResourceConflictException("GPG key already associated with another account");
                    }
                } else {
                    newExtIds.add(new AccountExternalId(rsrc.getUser().getAccountId(), extIdKey));
                }
            } else {
                AccountExternalId existing = db.get().accountExternalIds().get(extIdKey);
                if (existing != null) {
                    if (!existing.getAccountId().equals(rsrc.getUser().getAccountId())) {
                        throw new ResourceConflictException("GPG key already associated with another account");
                    }
                } else {
                    newExtIds.add(new AccountExternalId(rsrc.getUser().getAccountId(), extIdKey));
                }
            }
        }
        storeKeys(rsrc, newKeys, toRemove);
        if (!newExtIds.isEmpty()) {
            db.get().accountExternalIds().insert(newExtIds);
        }
        db.get().accountExternalIds().deleteKeys(Iterables.transform(toRemove, fp -> toExtIdKey(fp.get())));
        accountCache.evict(rsrc.getUser().getAccountId());
        return toJson(newKeys, toRemove, store, rsrc.getUser());
    }
}
#method_after
@Override
public Map<String, GpgKeyInfo> apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException, PGPException, OrmException, IOException {
    GpgKeys.checkVisible(self, rsrc);
    List<AccountExternalId> existingExtIds = GpgKeys.getGpgExtIds(db.get(), rsrc.getUser().getAccountId()).toList();
    try (PublicKeyStore store = storeProvider.get()) {
        Set<Fingerprint> toRemove = readKeysToRemove(input, existingExtIds);
        List<PGPPublicKeyRing> newKeys = readKeysToAdd(input, toRemove);
        List<AccountExternalId> newExtIds = new ArrayList<>(existingExtIds.size());
        for (PGPPublicKeyRing keyRing : newKeys) {
            PGPPublicKey key = keyRing.getPublicKey();
            AccountExternalId.Key extIdKey = toExtIdKey(key.getFingerprint());
            Account account = getAccountByExternalId(extIdKey.get());
            if (account != null) {
                if (!account.getId().equals(rsrc.getUser().getAccountId())) {
                    throw new ResourceConflictException("GPG key already associated with another account");
                }
            } else {
                newExtIds.add(new AccountExternalId(rsrc.getUser().getAccountId(), extIdKey));
            }
        }
        storeKeys(rsrc, newKeys, toRemove);
        if (!newExtIds.isEmpty()) {
            db.get().accountExternalIds().insert(newExtIds);
        }
        db.get().accountExternalIds().deleteKeys(Iterables.transform(toRemove, fp -> toExtIdKey(fp.get())));
        accountCache.evict(rsrc.getUser().getAccountId());
        return toJson(newKeys, toRemove, store, rsrc.getUser());
    }
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(ChangeResource req, MergePatchSetInput in) throws NoSuchChangeException, OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (in.merge == null) {
        throw new BadRequestException("merge field is required");
    }
    MergeInput merge = in.merge;
    if (Strings.isNullOrEmpty(merge.source)) {
        throw new BadRequestException("merge.source must be non-empty");
    }
    ChangeControl ctl = req.getControl();
    if (!ctl.isVisible(db.get())) {
        throw new InvalidChangeOperationException("Base change not found: " + req.getId());
    }
    PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
    if (!ctl.canAddPatchSet(db.get())) {
        throw new AuthException("cannot add patch set");
    }
    ProjectControl projectControl = ctl.getProjectControl();
    Change change = ctl.getChange();
    Project.NameKey project = change.getProject();
    Branch.NameKey dest = change.getDest();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        RevWalk rw = new RevWalk(oi.newReader())) {
        RevCommit sourceCommit = MergeUtil.resolveCommit(git, rw, merge.source);
        if (!projectControl.canReadCommit(db.get(), git, sourceCommit)) {
            throw new ResourceNotFoundException("cannot find source commit: " + merge.source + " to merge.");
        }
        RevCommit currentPsCommit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        RevCommit newCommit = createMergeCommit(in, projectControl, dest, git, oi, rw, currentPsCommit, sourceCommit, author, ObjectId.fromString(change.getKey().get().substring(1)));
        PatchSet.Id nextPsId = ChangeUtil.nextPatchSetId(ps.getId());
        PatchSetInserter psInserter = patchSetInserterFactory.create(ctl, nextPsId, newCommit);
        try (BatchUpdate bu = batchUpdateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.addOp(ctl.getId(), psInserter.setMessage("Uploaded patch set " + nextPsId.get() + ".").setDraft(ps.isDraft()).setNotify(NotifyHandling.NONE));
            bu.execute();
        }
        ChangeJson json = jsonFactory.create(EnumSet.of(ListChangesOption.CURRENT_REVISION));
        return Response.ok(json.format(psInserter.getChange()));
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(ChangeResource req, MergePatchSetInput in) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (in.merge == null) {
        throw new BadRequestException("merge field is required");
    }
    MergeInput merge = in.merge;
    if (Strings.isNullOrEmpty(merge.source)) {
        throw new BadRequestException("merge.source must be non-empty");
    }
    ChangeControl ctl = req.getControl();
    if (!ctl.isVisible(db.get())) {
        throw new InvalidChangeOperationException("Base change not found: " + req.getId());
    }
    PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
    if (!ctl.canAddPatchSet(db.get())) {
        throw new AuthException("cannot add patch set");
    }
    ProjectControl projectControl = ctl.getProjectControl();
    Change change = ctl.getChange();
    Project.NameKey project = change.getProject();
    Branch.NameKey dest = change.getDest();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        RevWalk rw = new RevWalk(oi.newReader())) {
        RevCommit sourceCommit = MergeUtil.resolveCommit(git, rw, merge.source);
        if (!projectControl.canReadCommit(db.get(), git, sourceCommit)) {
            throw new ResourceNotFoundException("cannot find source commit: " + merge.source + " to merge.");
        }
        RevCommit currentPsCommit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        RevCommit newCommit = createMergeCommit(in, projectControl, dest, git, oi, rw, currentPsCommit, sourceCommit, author, ObjectId.fromString(change.getKey().get().substring(1)));
        PatchSet.Id nextPsId = ChangeUtil.nextPatchSetId(ps.getId());
        PatchSetInserter psInserter = patchSetInserterFactory.create(ctl, nextPsId, newCommit);
        try (BatchUpdate bu = batchUpdateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.addOp(ctl.getId(), psInserter.setMessage("Uploaded patch set " + nextPsId.get() + ".").setDraft(ps.isDraft()).setNotify(NotifyHandling.NONE));
            bu.execute();
        }
        ChangeJson json = jsonFactory.create(EnumSet.of(ListChangesOption.CURRENT_REVISION));
        return Response.ok(json.format(psInserter.getChange()));
    }
}
#end_block

#method_before
@Test
public void flushAll() throws Exception {
    RestResponse r = adminRestSession.get("/config/server/caches/project_list");
    CacheInfo cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isGreaterThan((long) 0);
    r = adminRestSession.post("/config/server/caches/", new PostCaches.Input(FLUSH_ALL));
    r.assertOK();
    r.consume();
    r = adminRestSession.get("/config/server/caches/project_list");
    cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isNull();
}
#method_after
@Test
public void flushAll() throws Exception {
    RestResponse r = adminRestSession.getOK("/config/server/caches/project_list");
    CacheInfo cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isGreaterThan((long) 0);
    r = adminRestSession.postOK("/config/server/caches/", new PostCaches.Input(FLUSH_ALL));
    r.consume();
    r = adminRestSession.getOK("/config/server/caches/project_list");
    cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isNull();
}
#end_block

#method_before
@Test
public void flush() throws Exception {
    RestResponse r = adminRestSession.get("/config/server/caches/project_list");
    CacheInfo cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isGreaterThan((long) 0);
    r = adminRestSession.get("/config/server/caches/projects");
    cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isGreaterThan((long) 1);
    r = adminRestSession.post("/config/server/caches/", new PostCaches.Input(FLUSH, Arrays.asList("accounts", "project_list")));
    r.assertOK();
    r.consume();
    r = adminRestSession.get("/config/server/caches/project_list");
    cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isNull();
    r = adminRestSession.get("/config/server/caches/projects");
    cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isGreaterThan((long) 1);
}
#method_after
@Test
public void flush() throws Exception {
    RestResponse r = adminRestSession.getOK("/config/server/caches/project_list");
    CacheInfo cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isGreaterThan((long) 0);
    r = adminRestSession.getOK("/config/server/caches/projects");
    cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isGreaterThan((long) 1);
    r = adminRestSession.postOK("/config/server/caches/", new PostCaches.Input(FLUSH, Arrays.asList("accounts", "project_list")));
    r.consume();
    r = adminRestSession.getOK("/config/server/caches/project_list");
    cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isNull();
    r = adminRestSession.getOK("/config/server/caches/projects");
    cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isGreaterThan((long) 1);
}
#end_block

#method_before
@Test
public void flush_UnprocessableEntity() throws Exception {
    RestResponse r = adminRestSession.get("/config/server/caches/projects");
    CacheInfo cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isGreaterThan((long) 0);
    r = adminRestSession.post("/config/server/caches/", new PostCaches.Input(FLUSH, Arrays.asList("projects", "unprocessable")));
    r.assertUnprocessableEntity();
    r.consume();
    r = adminRestSession.get("/config/server/caches/projects");
    cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isGreaterThan((long) 0);
}
#method_after
@Test
public void flush_UnprocessableEntity() throws Exception {
    RestResponse r = adminRestSession.getOK("/config/server/caches/projects");
    CacheInfo cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isGreaterThan((long) 0);
    r = adminRestSession.post("/config/server/caches/", new PostCaches.Input(FLUSH, Arrays.asList("projects", "unprocessable")));
    r.assertUnprocessableEntity();
    r.consume();
    r = adminRestSession.getOK("/config/server/caches/projects");
    cacheInfo = newGson().fromJson(r.getReader(), CacheInfo.class);
    assertThat(cacheInfo.entries.mem).isGreaterThan((long) 0);
}
#end_block

#method_before
@Test
public void flushWebSessions_Forbidden() throws Exception {
    allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.FLUSH_CACHES, GlobalCapability.VIEW_CACHES);
    try {
        RestResponse r = userRestSession.post("/config/server/caches/", new PostCaches.Input(FLUSH, Arrays.asList("projects")));
        r.assertOK();
        r.consume();
        userRestSession.post("/config/server/caches/", new PostCaches.Input(FLUSH, Arrays.asList("web_sessions"))).assertForbidden();
    } finally {
        removeGlobalCapabilities(REGISTERED_USERS, GlobalCapability.FLUSH_CACHES, GlobalCapability.VIEW_CACHES);
    }
}
#method_after
@Test
public void flushWebSessions_Forbidden() throws Exception {
    allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.FLUSH_CACHES, GlobalCapability.VIEW_CACHES);
    try {
        RestResponse r = userRestSession.postOK("/config/server/caches/", new PostCaches.Input(FLUSH, Arrays.asList("projects")));
        r.consume();
        userRestSession.post("/config/server/caches/", new PostCaches.Input(FLUSH, Arrays.asList("web_sessions"))).assertForbidden();
    } finally {
        removeGlobalCapabilities(REGISTERED_USERS, GlobalCapability.FLUSH_CACHES, GlobalCapability.VIEW_CACHES);
    }
}
#end_block

#method_before
public CheckedFuture<?, IOException> indexAsync(Project.NameKey project, Change.Id id) {
    return executor != null ? submit(new IndexTask(project, id)) : Futures.<Object, IOException>immediateCheckedFuture(null);
}
#method_after
public CheckedFuture<?, IOException> indexAsync(Project.NameKey project, Change.Id id) {
    return submit(new IndexTask(project, id));
}
#end_block

#method_before
public void index(ChangeData cd) throws IOException {
    for (Index<?, ChangeData> i : getWriteIndexes()) {
        i.replace(cd);
    }
    fireChangeIndexedEvent(cd.getId().get());
}
#method_after
public void index(ChangeData cd) throws IOException {
    for (Index<?, ChangeData> i : getWriteIndexes()) {
        i.replace(cd);
    }
    fireChangeIndexedEvent(cd.getId().get());
    // Always double-check whether the change might be stale immediately after
    // interactively indexing it. This fixes up the case where two writers write
    // to the primary storage in one order, and the corresponding index writes
    // happen in the opposite order:
    // 1. Writer A writes to primary storage.
    // 2. Writer B writes to primary storage.
    // 3. Writer B updates index.
    // 4. Writer A updates index.
    // 
    // Without the extra reindexIfStale step, A has no way of knowing that it's
    // about to overwrite the index document with stale data. It doesn't work to
    // have A check for staleness before attempting its index update, because
    // B's index update might not have happened when it does the check.
    // 
    // With the extra reindexIfStale step after (3)/(4), we are able to detect
    // and fix the staleness. It doesn't matter which order the two
    // reindexIfStale calls actually execute in; we are guaranteed that at least
    // one of them will execute after the second index write, (4).
    reindexAfterIndexUpdate(cd);
}
#end_block

#method_before
public void index(ReviewDb db, Change change) throws IOException, OrmException {
    index(newChangeData(db, change));
}
#method_after
public void index(ReviewDb db, Change change) throws IOException, OrmException {
    index(newChangeData(db, change));
    // See comment in #index(ChangeData).
    reindexAfterIndexUpdate(change.getProject(), change.getId());
}
#end_block

#method_before
public void index(ReviewDb db, Project.NameKey project, Change.Id changeId) throws IOException, OrmException {
    index(newChangeData(db, project, changeId));
}
#method_after
public void index(ReviewDb db, Project.NameKey project, Change.Id changeId) throws IOException, OrmException {
    ChangeData cd = newChangeData(db, project, changeId);
    index(cd);
    // See comment in #index(ChangeData).
    reindexAfterIndexUpdate(cd);
}
#end_block

#method_before
public CheckedFuture<?, IOException> deleteAsync(Change.Id id) {
    return executor != null ? submit(new DeleteTask(id)) : Futures.<Object, IOException>immediateCheckedFuture(null);
}
#method_after
public CheckedFuture<?, IOException> deleteAsync(Change.Id id) {
    return submit(new DeleteTask(id));
}
#end_block

#method_before
private CheckedFuture<?, IOException> submit(Callable<?> task) {
    return Futures.makeChecked(Futures.nonCancellationPropagating(executor.submit(task)), MAPPER);
}
#method_after
private <T> CheckedFuture<T, IOException> submit(Callable<T> task) {
    return submit(task, executor);
}
#end_block

#method_before
@Override
public String toString() {
    return "index-change-" + id.get();
}
#method_after
@Override
public String toString() {
    return "index-change-" + id;
}
#end_block

#method_before
@Override
public int run() throws Exception {
    final SiteInit init = createSiteInit();
    if (beforeInit(init)) {
        return 0;
    }
    init.flags.autoStart = getAutoStart() && init.site.isNew;
    init.flags.dev = isDev() && init.site.isNew;
    init.flags.skipPlugins = skipPlugins();
    init.flags.deleteCaches = getDeleteCaches();
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        run = createSiteRun(init);
        run.upgradeSchema();
        init.initializer.postRun(createSysInjector(init));
    } catch (Exception | Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().toRealPath().normalize());
    afterInit(run);
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    final SiteInit init = createSiteInit();
    if (beforeInit(init)) {
        return 0;
    }
    init.flags.autoStart = getAutoStart() && init.site.isNew;
    init.flags.dev = isDev() && init.site.isNew;
    init.flags.skipPlugins = skipPlugins();
    init.flags.deleteCaches = getDeleteCaches();
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        Injector sysInjector = createSysInjector(init);
        IndexManagerOnInit indexManager = sysInjector.getInstance(IndexManagerOnInit.class);
        try {
            indexManager.start();
            run = createSiteRun(init);
            run.upgradeSchema();
            init.initializer.postRun(sysInjector);
        } finally {
            indexManager.stop();
        }
    } catch (Exception | Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().toRealPath().normalize());
    afterInit(run);
    return 0;
}
#end_block

#method_before
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final Path sitePath = getSitePath();
    final List<Module> m = new ArrayList<>();
    final SecureStoreInitData secureStoreInitData = discoverSecureStoreClass();
    final String currentSecureStoreClassName = getConfiguredSecureStoreClass();
    if (secureStoreInitData != null && currentSecureStoreClassName != null && !currentSecureStoreClassName.equals(secureStoreInitData.className)) {
        String err = String.format("Different secure store was previously configured: %s. " + "Use SwitchSecureStore program to switch between implementations.", currentSecureStoreClassName);
        throw die(err);
    }
    m.add(new GerritServerConfigModule());
    m.add(new InitModule(standalone, initDb));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = MoreObjects.firstNonNull(getInstallPlugins(), new ArrayList<String>());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(new TypeLiteral<Boolean>() {
            }).annotatedWith(InstallAllPlugins.class).toInstance(installAllPlugins());
            bind(PluginsDistribution.class).toInstance(pluginsDistribution);
            String secureStoreClassName;
            if (secureStoreInitData != null) {
                secureStoreClassName = secureStoreInitData.className;
            } else {
                secureStoreClassName = currentSecureStoreClassName;
            }
            if (secureStoreClassName != null) {
                ui.message("Using secure store: %s\n", secureStoreClassName);
            }
            bind(SecureStoreInitData.class).toProvider(Providers.of(secureStoreInitData));
            bind(String.class).annotatedWith(SecureStoreClassName.class).toProvider(Providers.of(secureStoreClassName));
            bind(SecureStore.class).toProvider(SecureStoreProvider.class).in(SINGLETON);
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(LibraryDownload.class).toInstance(getSkippedDownloads());
            bind(Boolean.class).annotatedWith(LibraryDownload.class).toInstance(skipAllDownloads());
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#method_after
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final Path sitePath = getSitePath();
    final List<Module> m = new ArrayList<>();
    final SecureStoreInitData secureStoreInitData = discoverSecureStoreClass();
    final String currentSecureStoreClassName = getConfiguredSecureStoreClass();
    if (secureStoreInitData != null && currentSecureStoreClassName != null && !currentSecureStoreClassName.equals(secureStoreInitData.className)) {
        String err = String.format("Different secure store was previously configured: %s. " + "Use SwitchSecureStore program to switch between implementations.", currentSecureStoreClassName);
        throw die(err);
    }
    m.add(new GerritServerConfigModule());
    m.add(new InitModule(standalone, initDb));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = MoreObjects.firstNonNull(getInstallPlugins(), new ArrayList<String>());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(new TypeLiteral<Boolean>() {
            }).annotatedWith(InstallAllPlugins.class).toInstance(installAllPlugins());
            bind(PluginsDistribution.class).toInstance(pluginsDistribution);
            String secureStoreClassName;
            if (secureStoreInitData != null) {
                secureStoreClassName = secureStoreInitData.className;
            } else {
                secureStoreClassName = currentSecureStoreClassName;
            }
            if (secureStoreClassName != null) {
                ui.message("Using secure store: %s\n", secureStoreClassName);
            }
            bind(SecureStoreInitData.class).toProvider(Providers.of(secureStoreInitData));
            bind(String.class).annotatedWith(SecureStoreClassName.class).toProvider(Providers.of(secureStoreClassName));
            bind(SecureStore.class).toProvider(SecureStoreProvider.class).in(SINGLETON);
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(LibraryDownload.class).toInstance(getSkippedDownloads());
            bind(Boolean.class).annotatedWith(LibraryDownload.class).toInstance(skipAllDownloads());
            bind(MetricMaker.class).to(DisabledMetricMaker.class);
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#end_block

#method_before
private SecureStoreInitData discoverSecureStoreClass() {
    String secureStore = getSecureStoreLib();
    if (Strings.isNullOrEmpty(secureStore)) {
        return null;
    }
    try {
        Path secureStoreLib = Paths.get(secureStore);
        if (!Files.exists(secureStoreLib)) {
            throw new InvalidSecureStoreException(String.format("File %s doesn't exist", secureStore));
        }
        JarScanner scanner = new JarScanner(secureStoreLib);
        List<String> secureStores = scanner.findSubClassesOf(SecureStore.class);
        if (secureStores.isEmpty()) {
            throw new InvalidSecureStoreException(String.format("Cannot find class implementing %s interface in %s", SecureStore.class.getName(), secureStore));
        }
        if (secureStores.size() > 1) {
            throw new InvalidSecureStoreException(String.format("%s has more that one implementation of %s interface", secureStore, SecureStore.class.getName()));
        }
        IoUtil.loadJARs(secureStoreLib);
        return new SecureStoreInitData(secureStoreLib, secureStores.get(0));
    } catch (IOException e) {
        throw new InvalidSecureStoreException(String.format("%s is not a valid jar", secureStore));
    }
}
#method_after
private SecureStoreInitData discoverSecureStoreClass() {
    String secureStore = getSecureStoreLib();
    if (Strings.isNullOrEmpty(secureStore)) {
        return null;
    }
    Path secureStoreLib = Paths.get(secureStore);
    if (!Files.exists(secureStoreLib)) {
        throw new InvalidSecureStoreException(String.format("File %s doesn't exist", secureStore));
    }
    try (JarScanner scanner = new JarScanner(secureStoreLib)) {
        List<String> secureStores = scanner.findSubClassesOf(SecureStore.class);
        if (secureStores.isEmpty()) {
            throw new InvalidSecureStoreException(String.format("Cannot find class implementing %s interface in %s", SecureStore.class.getName(), secureStore));
        }
        if (secureStores.size() > 1) {
            throw new InvalidSecureStoreException(String.format("%s has more that one implementation of %s interface", secureStore, SecureStore.class.getName()));
        }
        IoUtil.loadJARs(secureStoreLib);
        return new SecureStoreInitData(secureStoreLib, secureStores.get(0));
    } catch (IOException e) {
        throw new InvalidSecureStoreException(String.format("%s is not a valid jar", secureStore));
    }
}
#end_block

#method_before
private Injector createSysInjector(final SiteInit init) {
    if (sysInjector == null) {
        final List<Module> modules = new ArrayList<>();
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(ConsoleUI.class).toInstance(init.ui);
                bind(InitFlags.class).toInstance(init.flags);
            }
        });
        sysInjector = createDbInjector(SINGLE_USER).createChildInjector(modules);
    }
    return sysInjector;
}
#method_after
private Injector createSysInjector(final SiteInit init) {
    if (sysInjector == null) {
        final List<Module> modules = new ArrayList<>();
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(ConsoleUI.class).toInstance(init.ui);
                bind(InitFlags.class).toInstance(init.flags);
            }
        });
        Injector dbInjector = createDbInjector(SINGLE_USER);
        switch(IndexModule.getIndexType(dbInjector)) {
            case LUCENE:
                modules.add(new LuceneIndexModuleOnInit());
                break;
            case ELASTICSEARCH:
                modules.add(new ElasticIndexModuleOnInit());
                break;
            default:
                throw new IllegalStateException("unsupported index.type");
        }
        sysInjector = dbInjector.createChildInjector(modules);
    }
    return sysInjector;
}
#end_block

#method_before
public List<String> getFooterLineValues(FooterKey key) {
    if (footerLines == null) {
        List<FooterLine> src = getFooterLines();
        footerLines = ArrayListMultimap.create(src.size(), 1);
        for (FooterLine fl : src) {
            footerLines.put(fl.getKey().toLowerCase(), fl.getValue());
        }
    }
    return footerLines.get(key.getName().toLowerCase());
}
#method_after
public List<String> getFooterLineValues(FooterKey key) {
    if (footerLines == null) {
        List<FooterLine> src = getFooterLines();
        footerLines = MultimapBuilder.hashKeys(src.size()).arrayListValues(1).build();
        for (FooterLine fl : src) {
            footerLines.put(fl.getKey().toLowerCase(), fl.getValue());
        }
    }
    return footerLines.get(key.getName().toLowerCase());
}
#end_block

#method_before
private void updateProjectGroups(ReviewDb db, Repository repo, RevWalk rw, Set<Change.Id> changes, UpdateUI ui) throws OrmException, IOException, NoSuchChangeException {
    // Match sorting in ReceiveCommits.
    rw.reset();
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.REVERSE, true);
    RefDatabase refdb = repo.getRefDatabase();
    for (Ref ref : refdb.getRefs(Constants.R_HEADS).values()) {
        RevCommit c = maybeParseCommit(rw, ref.getObjectId(), ui);
        if (c != null) {
            rw.markUninteresting(c);
        }
    }
    Multimap<ObjectId, Ref> changeRefsBySha = ArrayListMultimap.create();
    Multimap<ObjectId, PatchSet.Id> patchSetsBySha = ArrayListMultimap.create();
    for (Ref ref : refdb.getRefs(RefNames.REFS_CHANGES).values()) {
        ObjectId id = ref.getObjectId();
        if (ref.getObjectId() == null) {
            continue;
        }
        id = id.copy();
        changeRefsBySha.put(id, ref);
        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
        if (psId != null && changes.contains(psId.getParentKey())) {
            patchSetsBySha.put(id, psId);
            RevCommit c = maybeParseCommit(rw, id, ui);
            if (c != null) {
                rw.markStart(c);
            }
        }
    }
    GroupCollector collector = GroupCollector.createForSchemaUpgradeOnly(changeRefsBySha, db);
    RevCommit c;
    while ((c = rw.next()) != null) {
        collector.visit(c);
    }
    updateGroups(db, collector, patchSetsBySha);
}
#method_after
private void updateProjectGroups(ReviewDb db, Repository repo, RevWalk rw, Set<Change.Id> changes, UpdateUI ui) throws OrmException, IOException {
    // Match sorting in ReceiveCommits.
    rw.reset();
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.REVERSE, true);
    RefDatabase refdb = repo.getRefDatabase();
    for (Ref ref : refdb.getRefs(Constants.R_HEADS).values()) {
        RevCommit c = maybeParseCommit(rw, ref.getObjectId(), ui);
        if (c != null) {
            rw.markUninteresting(c);
        }
    }
    ListMultimap<ObjectId, Ref> changeRefsBySha = MultimapBuilder.hashKeys().arrayListValues().build();
    ListMultimap<ObjectId, PatchSet.Id> patchSetsBySha = MultimapBuilder.hashKeys().arrayListValues().build();
    for (Ref ref : refdb.getRefs(RefNames.REFS_CHANGES).values()) {
        ObjectId id = ref.getObjectId();
        if (ref.getObjectId() == null) {
            continue;
        }
        id = id.copy();
        changeRefsBySha.put(id, ref);
        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
        if (psId != null && changes.contains(psId.getParentKey())) {
            patchSetsBySha.put(id, psId);
            RevCommit c = maybeParseCommit(rw, id, ui);
            if (c != null) {
                rw.markStart(c);
            }
        }
    }
    GroupCollector collector = GroupCollector.createForSchemaUpgradeOnly(changeRefsBySha, db);
    RevCommit c;
    while ((c = rw.next()) != null) {
        collector.visit(c);
    }
    updateGroups(db, collector, patchSetsBySha);
}
#end_block

#method_before
private static void updateGroups(ReviewDb db, GroupCollector collector, Multimap<ObjectId, PatchSet.Id> patchSetsBySha) throws OrmException, NoSuchChangeException {
    Map<PatchSet.Id, PatchSet> patchSets = db.patchSets().toMap(db.patchSets().get(patchSetsBySha.values()));
    for (Map.Entry<ObjectId, Collection<String>> e : collector.getGroups().asMap().entrySet()) {
        for (PatchSet.Id psId : patchSetsBySha.get(e.getKey())) {
            PatchSet ps = patchSets.get(psId);
            if (ps != null) {
                ps.setGroups(ImmutableList.copyOf(e.getValue()));
            }
        }
    }
    db.patchSets().update(patchSets.values());
}
#method_after
private static void updateGroups(ReviewDb db, GroupCollector collector, ListMultimap<ObjectId, PatchSet.Id> patchSetsBySha) throws OrmException {
    Map<PatchSet.Id, PatchSet> patchSets = db.patchSets().toMap(db.patchSets().get(patchSetsBySha.values()));
    for (Map.Entry<ObjectId, Collection<String>> e : collector.getGroups().asMap().entrySet()) {
        for (PatchSet.Id psId : patchSetsBySha.get(e.getKey())) {
            PatchSet ps = patchSets.get(psId);
            if (ps != null) {
                ps.setGroups(ImmutableList.copyOf(e.getValue()));
            }
        }
    }
    db.patchSets().update(patchSets.values());
}
#end_block

#method_before
private SetMultimap<Project.NameKey, Change.Id> getOpenChangesByProject(ReviewDb db, UpdateUI ui) throws OrmException {
    SortedSet<NameKey> projects = repoManager.list();
    SortedSet<NameKey> nonExistentProjects = Sets.newTreeSet();
    SetMultimap<Project.NameKey, Change.Id> openByProject = HashMultimap.create();
    for (Change c : db.changes().all()) {
        Status status = c.getStatus();
        if (status != null && status.isClosed()) {
            continue;
        }
        NameKey projectKey = c.getProject();
        if (!projects.contains(projectKey)) {
            nonExistentProjects.add(projectKey);
        } else {
            // The old "submitted" state is not supported anymore
            // (thus status is null) but it was an opened state and needs
            // to be migrated as such
            openByProject.put(projectKey, c.getId());
        }
    }
    if (!nonExistentProjects.isEmpty()) {
        ui.message("Detected open changes referring to the following non-existent projects:");
        ui.message(Joiner.on(", ").join(nonExistentProjects));
        ui.message("It is highly recommended to remove\n" + "the obsolete open changes, comments and patch-sets from your DB.\n");
    }
    return openByProject;
}
#method_after
private SetMultimap<Project.NameKey, Change.Id> getOpenChangesByProject(ReviewDb db, UpdateUI ui) throws OrmException {
    SortedSet<NameKey> projects = repoManager.list();
    SortedSet<NameKey> nonExistentProjects = Sets.newTreeSet();
    SetMultimap<Project.NameKey, Change.Id> openByProject = MultimapBuilder.hashKeys().hashSetValues().build();
    for (Change c : db.changes().all()) {
        Status status = c.getStatus();
        if (status != null && status.isClosed()) {
            continue;
        }
        NameKey projectKey = c.getProject();
        if (!projects.contains(projectKey)) {
            nonExistentProjects.add(projectKey);
        } else {
            // The old "submitted" state is not supported anymore
            // (thus status is null) but it was an opened state and needs
            // to be migrated as such
            openByProject.put(projectKey, c.getId());
        }
    }
    if (!nonExistentProjects.isEmpty()) {
        ui.message("Detected open changes referring to the following non-existent projects:");
        ui.message(Joiner.on(", ").join(nonExistentProjects));
        ui.message("It is highly recommended to remove\n" + "the obsolete open changes, comments and patch-sets from your DB.\n");
    }
    return openByProject;
}
#end_block

#method_before
private List<AccountInfo> toAccountInfoList(Set<Account.Id> accountIds) throws OrmException {
    List<AccountInfo> result = new LinkedList<>();
    AccountLoader loader = infoFactory.create(true);
    for (Account.Id accId : accountIds) {
        result.add(loader.get(accId));
    }
    loader.fill();
    return result;
}
#method_after
private List<AccountInfo> toAccountInfoList(Set<Account.Id> accountIds) throws OrmException {
    List<AccountInfo> result = new ArrayList<>();
    AccountLoader loader = infoFactory.create(true);
    for (Account.Id accId : accountIds) {
        result.add(loader.get(accId));
    }
    loader.fill();
    return result;
}
#end_block

#method_before
@Override
public void start() {
    int cpus = Runtime.getRuntime().availableProcessors();
    if (config.getBoolean("cache", "projects", "loadOnStartup", false)) {
        final ThreadPoolExecutor pool = new ScheduledThreadPoolExecutor(config.getInt("cache", "projects", "loadThreads", cpus), new ThreadFactoryBuilder().setNameFormat("ProjectCacheLoader-%d").build());
        log.info("Loading project cache");
        pool.execute(new Runnable() {

            @Override
            public void run() {
                for (final Project.NameKey name : cache.all()) {
                    pool.execute(new Runnable() {

                        @Override
                        public void run() {
                            cache.get(name);
                        }
                    });
                }
                pool.shutdown();
            }
        });
    }
}
#method_after
@Override
public void start() {
    int cpus = Runtime.getRuntime().availableProcessors();
    if (config.getBoolean("cache", "projects", "loadOnStartup", false)) {
        final ThreadPoolExecutor pool = new ScheduledThreadPoolExecutor(config.getInt("cache", "projects", "loadThreads", cpus), new ThreadFactoryBuilder().setNameFormat("ProjectCacheLoader-%d").build());
        ExecutorService scheduler = Executors.newFixedThreadPool(1);
        log.info("Loading project cache");
        scheduler.execute(new Runnable() {

            @Override
            public void run() {
                for (final Project.NameKey name : cache.all()) {
                    pool.execute(new Runnable() {

                        @Override
                        public void run() {
                            cache.get(name);
                        }
                    });
                }
                pool.shutdown();
                try {
                    pool.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
                    log.info("Finished loading project cache");
                } catch (InterruptedException e) {
                    log.warn("Interrupted while waiting for project cache to load");
                }
            }
        });
    }
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    String projectName = branch.getParentKey().get();
    soyContext.put("projectName", projectName);
    // shortProjectName is the project name with the path abbreviated.
    soyContext.put("shortProjectName", projectName.replaceAll("/.*/", "..."));
    soyContextEmailData.put("sshHost", getSshHost());
    Map<String, String> branchData = new HashMap<>();
    branchData.put("shortName", branch.getShortName());
    soyContext.put("branch", branchData);
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    String projectName = branch.getParentKey().get();
    soyContext.put("projectName", projectName);
    // shortProjectName is the project name with the path abbreviated.
    soyContext.put("shortProjectName", projectName.replaceAll("/.*/", "..."));
    soyContextEmailData.put("sshHost", getSshHost());
    Map<String, String> branchData = new HashMap<>();
    branchData.put("shortName", branch.getShortName());
    soyContext.put("branch", branchData);
    footers.add("Gerrit-Project: " + branch.getParentKey().get());
    footers.add("Gerrit-Branch: " + branch.getShortName());
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    comment = commentsUtil.newComment(ctx, in.path, ps.getId(), in.side(), in.message.trim());
    comment.parentUuid = Url.decode(in.inReplyTo);
    comment.setLineNbrAndRange(in.line, in.range);
    comment.tag = in.tag;
    setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(psId), Status.DRAFT, Collections.singleton(comment));
    ctx.bumpLastUpdatedOn(false);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException, UnprocessableEntityException {
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    String parentUuid = Url.decode(in.inReplyTo);
    comment = commentsUtil.newComment(ctx, in.path, ps.getId(), in.side(), in.message.trim(), in.unresolved, parentUuid);
    comment.setLineNbrAndRange(in.line, in.range);
    comment.tag = in.tag;
    setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(psId), Status.DRAFT, Collections.singleton(comment));
    ctx.bumpLastUpdatedOn(false);
    return true;
}
#end_block

#method_before
public ChangeNotes createChecked(ReviewDb db, Change c) throws OrmException, NoSuchChangeException {
    return createChecked(db, c.getProject(), c.getId());
}
#method_after
public ChangeNotes createChecked(ReviewDb db, Change c) throws OrmException {
    return createChecked(db, c.getProject(), c.getId());
}
#end_block

#method_before
public ChangeNotes createChecked(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    Change change = readOneReviewDbChange(db, changeId);
    if (change == null || !change.getProject().equals(project)) {
        throw new NoSuchChangeException(changeId);
    }
    return new ChangeNotes(args, change).load();
}
#method_after
public ChangeNotes createChecked(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException {
    Change change = readOneReviewDbChange(db, changeId);
    if (change == null) {
        if (!args.migration.readChanges()) {
            throw new NoSuchChangeException(changeId);
        }
        // Change isn't in ReviewDb, but its primary storage might be in NoteDb.
        // Prepopulate the change exists with proper noteDbState field.
        change = newNoteDbOnlyChange(project, changeId);
    } else if (!change.getProject().equals(project)) {
        throw new NoSuchChangeException(changeId);
    }
    return new ChangeNotes(args, change).load();
}
#end_block

#method_before
public ChangeNotes createChecked(Change.Id changeId) throws OrmException, NoSuchChangeException {
    InternalChangeQuery query = queryProvider.get().noFields();
    List<ChangeData> changes = query.byLegacyChangeId(changeId);
    if (changes.isEmpty()) {
        throw new NoSuchChangeException(changeId);
    }
    if (changes.size() != 1) {
        log.error(String.format("Multiple changes found for %d", changeId.get()));
        throw new NoSuchChangeException(changeId);
    }
    return changes.get(0).notes();
}
#method_after
public ChangeNotes createChecked(Change.Id changeId) throws OrmException {
    InternalChangeQuery query = queryProvider.get().noFields();
    List<ChangeData> changes = query.byLegacyChangeId(changeId);
    if (changes.isEmpty()) {
        throw new NoSuchChangeException(changeId);
    }
    if (changes.size() != 1) {
        log.error(String.format("Multiple changes found for %d", changeId.get()));
        throw new NoSuchChangeException(changeId);
    }
    return changes.get(0).notes();
}
#end_block

#method_before
private Change loadChangeFromDb(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException {
    Change change = readOneReviewDbChange(db, changeId);
    checkArgument(project != null, "project is required");
    checkNotNull(change, "change %s not found in ReviewDb", changeId);
    checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s, but actual" + " project is %s", project, changeId, change.getProject());
    // database
    return change;
}
#method_after
private Change loadChangeFromDb(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException {
    checkArgument(project != null, "project is required");
    Change change = readOneReviewDbChange(db, changeId);
    if (change == null && args.migration.readChanges()) {
        // Change isn't in ReviewDb, but its primary storage might be in NoteDb.
        // Prepopulate the change exists with proper noteDbState field.
        change = newNoteDbOnlyChange(project, changeId);
    } else {
        checkNotNull(change, "change %s not found in ReviewDb", changeId);
        checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s, but actual" + " project is %s", project, changeId, change.getProject());
    }
    // database
    return change;
}
#end_block

#method_before
public ChangeNotes createWithAutoRebuildingDisabled(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException {
    return new ChangeNotes(args, loadChangeFromDb(db, project, changeId), false, null).load();
}
#method_after
public ChangeNotes createWithAutoRebuildingDisabled(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException {
    return new ChangeNotes(args, loadChangeFromDb(db, project, changeId), true, false, null).load();
}
#end_block

#method_before
public ChangeNotes createForBatchUpdate(Change change) throws OrmException {
    return new ChangeNotes(args, change, false, null).load();
}
#method_after
public ChangeNotes createForBatchUpdate(Change change, boolean shouldExist) throws OrmException {
    return new ChangeNotes(args, change, shouldExist, false, null).load();
}
#end_block

#method_before
public ChangeNotes createWithAutoRebuildingDisabled(Change change, RefCache refs) throws OrmException {
    return new ChangeNotes(args, change, false, refs).load();
}
#method_after
public ChangeNotes createWithAutoRebuildingDisabled(Change change, RefCache refs) throws OrmException {
    return new ChangeNotes(args, change, true, false, refs).load();
}
#end_block

#method_before
public ListMultimap<Project.NameKey, ChangeNotes> create(ReviewDb db, Predicate<ChangeNotes> predicate) throws IOException, OrmException {
    ListMultimap<Project.NameKey, ChangeNotes> m = ArrayListMultimap.create();
    if (args.migration.readChanges()) {
        for (Project.NameKey project : projectCache.all()) {
            try (Repository repo = args.repoManager.openRepository(project)) {
                List<ChangeNotes> changes = scanNoteDb(repo, db, project);
                for (ChangeNotes cn : changes) {
                    if (predicate.test(cn)) {
                        m.put(project, cn);
                    }
                }
            }
        }
    } else {
        for (Change change : ReviewDbUtil.unwrapDb(db).changes().all()) {
            ChangeNotes notes = createFromChangeOnlyWhenNoteDbDisabled(change);
            if (predicate.test(notes)) {
                m.put(change.getProject(), notes);
            }
        }
    }
    return ImmutableListMultimap.copyOf(m);
}
#method_after
public ListMultimap<Project.NameKey, ChangeNotes> create(ReviewDb db, Predicate<ChangeNotes> predicate) throws IOException, OrmException {
    ListMultimap<Project.NameKey, ChangeNotes> m = MultimapBuilder.hashKeys().arrayListValues().build();
    if (args.migration.readChanges()) {
        for (Project.NameKey project : projectCache.all()) {
            try (Repository repo = args.repoManager.openRepository(project)) {
                List<ChangeNotes> changes = scanNoteDb(repo, db, project);
                for (ChangeNotes cn : changes) {
                    if (predicate.test(cn)) {
                        m.put(project, cn);
                    }
                }
            }
        }
    } else {
        for (Change change : ReviewDbUtil.unwrapDb(db).changes().all()) {
            ChangeNotes notes = createFromChangeOnlyWhenNoteDbDisabled(change);
            if (predicate.test(notes)) {
                m.put(change.getProject(), notes);
            }
        }
    }
    return ImmutableListMultimap.copyOf(m);
}
#end_block

#method_before
private List<ChangeNotes> scanNoteDb(Repository repo, ReviewDb db, Project.NameKey project) throws OrmException, IOException {
    Set<Change.Id> ids = scan(repo);
    List<ChangeNotes> changeNotes = new ArrayList<>(ids.size());
    for (Change.Id id : ids) {
        Change change = readOneReviewDbChange(db, id);
        if (change == null) {
            log.warn("skipping change {} found in project {} " + "but not in ReviewDb", id, project);
            continue;
        } else if (!change.getProject().equals(project)) {
            log.error("skipping change {} found in project {} " + "because ReviewDb change has project {}", id, project, change.getProject());
            continue;
        }
        log.debug("adding change {} found in project {}", id, project);
        changeNotes.add(new ChangeNotes(args, change).load());
    }
    return changeNotes;
}
#method_after
private List<ChangeNotes> scanNoteDb(Repository repo, ReviewDb db, Project.NameKey project) throws OrmException, IOException {
    Set<Change.Id> ids = scan(repo);
    List<ChangeNotes> changeNotes = new ArrayList<>(ids.size());
    PrimaryStorage defaultStorage = args.migration.changePrimaryStorage();
    for (Change.Id id : ids) {
        Change change = readOneReviewDbChange(db, id);
        if (change == null) {
            if (defaultStorage == PrimaryStorage.REVIEW_DB) {
                log.warn("skipping change {} found in project {} " + "but not in ReviewDb", id, project);
                continue;
            }
            // TODO(dborowitz): See discussion in BatchUpdate#newChangeContext.
            change = newNoteDbOnlyChange(project, id);
        } else if (!change.getProject().equals(project)) {
            log.error("skipping change {} found in project {} " + "because ReviewDb change has project {}", id, project, change.getProject());
            continue;
        }
        log.debug("adding change {} found in project {}", id, project);
        changeNotes.add(new ChangeNotes(args, change).load());
    }
    return changeNotes;
}
#end_block

#method_before
public ImmutableListMultimap<RevId, Comment> getDraftComments(Account.Id author) throws OrmException {
    loadDraftComments(author);
    final Multimap<RevId, Comment> published = state.publishedComments();
    // Filter out any draft comments that also exist in the published map, in
    // case the update to All-Users to delete them during the publish operation
    // failed.
    Multimap<RevId, Comment> filtered = Multimaps.filterEntries(draftCommentNotes.getComments(), (Map.Entry<RevId, Comment> e) -> {
        for (Comment c : published.get(e.getKey())) {
            if (c.key.equals(e.getValue().key)) {
                return false;
            }
        }
        return true;
    });
    return ImmutableListMultimap.copyOf(filtered);
}
#method_after
public ImmutableListMultimap<RevId, Comment> getDraftComments(Account.Id author) throws OrmException {
    return getDraftComments(author, null);
}
#end_block

#method_before
public ImmutableListMultimap<RevId, Comment> getDraftComments(Account.Id author) throws OrmException {
    loadDraftComments(author);
    final Multimap<RevId, Comment> published = state.publishedComments();
    // Filter out any draft comments that also exist in the published map, in
    // case the update to All-Users to delete them during the publish operation
    // failed.
    Multimap<RevId, Comment> filtered = Multimaps.filterEntries(draftCommentNotes.getComments(), (Map.Entry<RevId, Comment> e) -> {
        for (Comment c : published.get(e.getKey())) {
            if (c.key.equals(e.getValue().key)) {
                return false;
            }
        }
        return true;
    });
    return ImmutableListMultimap.copyOf(filtered);
}
#method_after
public ImmutableListMultimap<RevId, Comment> getDraftComments(Account.Id author, @Nullable Ref ref) throws OrmException {
    loadDraftComments(author, ref);
    // during the publish operation failed.
    return ImmutableListMultimap.copyOf(Multimaps.filterEntries(draftCommentNotes.getComments(), e -> !getCommentKeys().contains(e.getValue().key)));
}
#end_block

#method_before
private void loadDraftComments(Account.Id author) throws OrmException {
    if (draftCommentNotes == null || !author.equals(draftCommentNotes.getAuthor())) {
        draftCommentNotes = new DraftCommentNotes(args, change, author, autoRebuild, rebuildResult);
        draftCommentNotes.load();
    }
}
#method_after
private void loadDraftComments(Account.Id author, @Nullable Ref ref) throws OrmException {
    if (draftCommentNotes == null || !author.equals(draftCommentNotes.getAuthor()) || ref != null) {
        draftCommentNotes = new DraftCommentNotes(args, change, author, autoRebuild, rebuildResult, ref);
        draftCommentNotes.load();
    }
}
#end_block

#method_before
RobotCommentNotes getRobotCommentNotes() {
    return robotCommentNotes;
}
#method_after
public RobotCommentNotes getRobotCommentNotes() {
    return robotCommentNotes;
}
#end_block

#method_before
public boolean containsComment(Comment c) throws OrmException {
    if (containsCommentPublished(c)) {
        return true;
    }
    loadDraftComments(c.author.getId());
    return draftCommentNotes.containsComment(c);
}
#method_after
public boolean containsComment(Comment c) throws OrmException {
    if (containsCommentPublished(c)) {
        return true;
    }
    loadDraftComments(c.author.getId(), null);
    return draftCommentNotes.containsComment(c);
}
#end_block

#method_before
@Override
protected String getRefName() {
    return changeMetaRef(getChangeId());
}
#method_after
@Override
public String getRefName() {
    return changeMetaRef(getChangeId());
}
#end_block

#method_before
@Override
protected void onLoad(LoadHandle handle) throws IOException, ConfigInvalidException {
    ObjectId rev = handle.id();
    if (rev == null) {
        loadDefaults();
        return;
    }
    ChangeNotesCache.Value v = args.cache.get().get(getProjectName(), getChangeId(), rev, handle.walk());
    state = v.state();
    state.copyColumnsTo(change);
    revisionNoteMap = v.revisionNoteMap();
}
#method_after
@Override
protected void onLoad(LoadHandle handle) throws NoSuchChangeException, IOException, ConfigInvalidException {
    ObjectId rev = handle.id();
    if (rev == null) {
        if (args.migration.readChanges() && PrimaryStorage.of(change) == PrimaryStorage.NOTE_DB && shouldExist) {
            throw new NoSuchChangeException(getChangeId());
        }
        loadDefaults();
        return;
    }
    ChangeNotesCache.Value v = args.cache.get().get(getProjectName(), getChangeId(), rev, handle.walk());
    state = v.state();
    state.copyColumnsTo(change);
    revisionNoteMap = v.revisionNoteMap();
}
#end_block

#method_before
@Override
protected LoadHandle openHandle(Repository repo) throws IOException {
    if (autoRebuild) {
        NoteDbChangeState state = NoteDbChangeState.parse(change);
        ObjectId id = readRef(repo);
        if (state == null && id == null) {
            return super.openHandle(repo, id);
        }
        RefCache refs = this.refs != null ? this.refs : new RepoRefCache(repo);
        if (!NoteDbChangeState.isChangeUpToDate(state, refs, getChangeId())) {
            return rebuildAndOpen(repo, id);
        }
    }
    return super.openHandle(repo);
}
#method_after
@Override
protected LoadHandle openHandle(Repository repo) throws NoSuchChangeException, IOException {
    if (autoRebuild) {
        NoteDbChangeState state = NoteDbChangeState.parse(change);
        ObjectId id = readRef(repo);
        if (id == null) {
            if (state == null) {
                return super.openHandle(repo, id);
            } else if (shouldExist) {
                throw new NoSuchChangeException(getChangeId());
            }
        }
        RefCache refs = this.refs != null ? this.refs : new RepoRefCache(repo);
        if (!NoteDbChangeState.isChangeUpToDate(state, refs, getChangeId())) {
            return rebuildAndOpen(repo, id);
        }
    }
    return super.openHandle(repo);
}
#end_block

#method_before
private LoadHandle rebuildAndOpen(Repository repo, ObjectId oldId) throws IOException {
    Timer1.Context timer = args.metrics.autoRebuildLatency.start(CHANGES);
    try {
        Change.Id cid = getChangeId();
        ReviewDb db = args.db.get();
        ChangeRebuilder rebuilder = args.rebuilder.get();
        NoteDbUpdateManager.Result r;
        try (NoteDbUpdateManager manager = rebuilder.stage(db, cid)) {
            if (manager == null) {
                // May be null in tests.
                return super.openHandle(repo, oldId);
            }
            r = manager.stageAndApplyDelta(change);
            try {
                rebuilder.execute(db, cid, manager);
                repo.scanForRepoChanges();
            } catch (OrmException | IOException e) {
                // Rebuilding failed. Most likely cause is contention on one or more
                // change refs; there are other types of errors that can happen during
                // rebuilding, but generally speaking they should happen during stage(),
                // not execute(). Assume that some other worker is going to successfully
                // store the rebuilt state, which is deterministic given an input
                // ChangeBundle.
                // 
                // Parse notes from the staged result so we can return something useful
                // to the caller instead of throwing.
                log.debug("Rebuilding change {} failed: {}", getChangeId(), e.getMessage());
                args.metrics.autoRebuildFailureCount.increment(CHANGES);
                rebuildResult = checkNotNull(r);
                checkNotNull(r.newState());
                checkNotNull(r.staged());
                return LoadHandle.create(ChangeNotesCommit.newStagedRevWalk(repo, r.staged().changeObjects()), r.newState().getChangeMetaId());
            }
        }
        return LoadHandle.create(ChangeNotesCommit.newRevWalk(repo), r.newState().getChangeMetaId());
    } catch (NoSuchChangeException e) {
        return super.openHandle(repo, oldId);
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        log.debug("Rebuilt change {} in project {} in {} ms", getChangeId(), getProjectName(), TimeUnit.MILLISECONDS.convert(timer.stop(), TimeUnit.NANOSECONDS));
    }
}
#method_after
private LoadHandle rebuildAndOpen(Repository repo, ObjectId oldId) throws IOException {
    Timer1.Context timer = args.metrics.autoRebuildLatency.start(CHANGES);
    try {
        Change.Id cid = getChangeId();
        ReviewDb db = args.db.get();
        ChangeRebuilder rebuilder = args.rebuilder.get();
        NoteDbUpdateManager.Result r;
        try (NoteDbUpdateManager manager = rebuilder.stage(db, cid)) {
            if (manager == null) {
                // May be null in tests.
                return super.openHandle(repo, oldId);
            }
            manager.setRefLogMessage("Auto-rebuilding change");
            r = manager.stageAndApplyDelta(change);
            try {
                rebuilder.execute(db, cid, manager);
                repo.scanForRepoChanges();
            } catch (OrmException | IOException e) {
                // Rebuilding failed. Most likely cause is contention on one or more
                // change refs; there are other types of errors that can happen during
                // rebuilding, but generally speaking they should happen during stage(),
                // not execute(). Assume that some other worker is going to successfully
                // store the rebuilt state, which is deterministic given an input
                // ChangeBundle.
                // 
                // Parse notes from the staged result so we can return something useful
                // to the caller instead of throwing.
                log.debug("Rebuilding change {} failed: {}", getChangeId(), e.getMessage());
                args.metrics.autoRebuildFailureCount.increment(CHANGES);
                rebuildResult = checkNotNull(r);
                checkNotNull(r.newState());
                checkNotNull(r.staged());
                return LoadHandle.create(ChangeNotesCommit.newStagedRevWalk(repo, r.staged().changeObjects()), r.newState().getChangeMetaId());
            }
        }
        return LoadHandle.create(ChangeNotesCommit.newRevWalk(repo), r.newState().getChangeMetaId());
    } catch (NoSuchChangeException e) {
        return super.openHandle(repo, oldId);
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        log.debug("Rebuilt change {} in project {} in {} ms", getChangeId(), getProjectName(), TimeUnit.MILLISECONDS.convert(timer.stop(), TimeUnit.NANOSECONDS));
    }
}
#end_block

#method_before
@Override
public String getVersion() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public String getVersion() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ServerInfo getInfo() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ServerInfo getInfo() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public GeneralPreferencesInfo getDefaultPreferences() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public GeneralPreferencesInfo getDefaultPreferences() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public GeneralPreferencesInfo setDefaultPreferences(GeneralPreferencesInfo in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public GeneralPreferencesInfo setDefaultPreferences(GeneralPreferencesInfo in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DiffPreferencesInfo getDefaultDiffPreferences() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public DiffPreferencesInfo getDefaultDiffPreferences() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DiffPreferencesInfo setDefaultDiffPreferences(DiffPreferencesInfo in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public DiffPreferencesInfo setDefaultDiffPreferences(DiffPreferencesInfo in) {
    throw new NotImplementedException();
}
#end_block

#method_before
private static Injector buildInjector(final Injector parent) {
    // are behind this installation's current version.
    return Guice.createInjector(Stage.DEVELOPMENT, new AbstractModule() {

        @Override
        protected void configure() {
            bind(SchemaVersion.class).to(SchemaVersion.C);
            for (Key<?> k : new Key<?>[] { Key.get(PersonIdent.class, GerritPersonIdent.class), Key.get(String.class, AnonymousCowardName.class) }) {
                rebind(parent, k);
            }
            for (Class<?> c : new Class<?>[] { AllProjectsName.class, AllUsersCreator.class, AllUsersName.class, GitRepositoryManager.class, SitePaths.class }) {
                rebind(parent, Key.get(c));
            }
        }

        private <T> void rebind(Injector parent, Key<T> c) {
            bind(c).toProvider(parent.getProvider(c));
        }
    });
}
#method_after
private static Injector buildInjector(final Injector parent) {
    // are behind this installation's current version.
    return Guice.createInjector(Stage.DEVELOPMENT, new AbstractModule() {

        @Override
        protected void configure() {
            bind(SchemaVersion.class).to(SchemaVersion.C);
            for (Key<?> k : new Key<?>[] { Key.get(PersonIdent.class, GerritPersonIdent.class), Key.get(String.class, AnonymousCowardName.class) }) {
                rebind(parent, k);
            }
            for (Class<?> c : new Class<?>[] { AllProjectsName.class, AllUsersCreator.class, AllUsersName.class, GitRepositoryManager.class, SitePaths.class, SystemGroupBackend.class }) {
                rebind(parent, Key.get(c));
            }
        }

        private <T> void rebind(Injector parent, Key<T> c) {
            bind(c).toProvider(parent.getProvider(c));
        }
    });
}
#end_block

#method_before
@Argument(index = 0, required = true, multiValued = true, metaVar = "CHANGE", usage = "changes to index")
void addChange(String token) {
    try {
        changeArgumentParser.addChange(token, changes, null, false);
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database is down", e);
    }
}
#method_after
@Argument(index = 0, required = true, multiValued = true, metaVar = "CHANGE", usage = "changes to index")
void addChange(String token) {
    try {
        changeArgumentParser.addChange(token, changes, null, false);
    } catch (UnloggedFailure | OrmException e) {
        writeError("warning", e.getMessage());
    }
}
#end_block

#method_before
@Override
public GroupInfo apply(GroupResource resource, Input input) throws ResourceNotFoundException, MethodNotAllowedException, AuthException, BadRequestException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.owner)) {
        throw new BadRequestException("owner is required");
    }
    group = db.get().accountGroups().get(group.getId());
    if (group == null) {
        throw new ResourceNotFoundException();
    }
    GroupDescription.Basic owner = groupsCollection.parse(input.owner);
    if (!group.getOwnerGroupUUID().equals(owner.getGroupUUID())) {
        group.setOwnerGroupUUID(owner.getGroupUUID());
        db.get().accountGroups().update(Collections.singleton(group));
        groupCache.evict(group);
    }
    return json.format(owner);
}
#method_after
@Override
public GroupInfo apply(GroupResource resource, Input input) throws ResourceNotFoundException, MethodNotAllowedException, AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.owner)) {
        throw new BadRequestException("owner is required");
    }
    group = db.get().accountGroups().get(group.getId());
    if (group == null) {
        throw new ResourceNotFoundException();
    }
    GroupDescription.Basic owner = groupsCollection.parse(input.owner);
    if (!group.getOwnerGroupUUID().equals(owner.getGroupUUID())) {
        group.setOwnerGroupUUID(owner.getGroupUUID());
        db.get().accountGroups().update(Collections.singleton(group));
        groupCache.evict(group);
    }
    return json.format(owner);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(db, patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private Set<Account.Id> filterOnChangeVisibility(final ReviewDb db, final ChangeNotes notes, Set<Account.Id> accounts) {
    return accounts.stream().filter(accountId -> {
        try {
            IdentifiedUser user = userFactory.create(accountId);
            return changeControlFactory.controlFor(notes, user).isVisible(db);
        } catch (OrmException | NoSuchChangeException e) {
            log.warn(String.format("Failed to check if account %d can see change %d", accountId.get(), notes.getChangeId().get()), e);
            return false;
        }
    }).collect(toSet());
}
#method_after
private Set<Account.Id> filterOnChangeVisibility(final ReviewDb db, final ChangeNotes notes, Set<Account.Id> accounts) {
    return accounts.stream().filter(accountId -> {
        try {
            IdentifiedUser user = userFactory.create(accountId);
            return changeControlFactory.controlFor(notes, user).isVisible(db);
        } catch (OrmException e) {
            log.warn(String.format("Failed to check if account %d can see change %d", accountId.get(), notes.getChangeId().get()), e);
            return false;
        }
    }).collect(toSet());
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException, NoSuchChangeException {
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
            List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail && (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty())) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.setAccountsToNotify(accountsToNotify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
            List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#end_block

#method_before
public ImmutableMultimap<Change.Id, String> getProblems() {
    return ImmutableMultimap.copyOf(problems);
}
#method_after
public ImmutableListMultimap<Change.Id, String> getProblems() {
    return ImmutableListMultimap.copyOf(problems);
}
#end_block

#method_before
private void checkSubmitRulesAndState(ChangeSet cs) throws ResourceConflictException {
    checkArgument(!cs.furtherHiddenChanges(), "checkSubmitRulesAndState called for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        try {
            if (cd.change().getStatus() != Change.Status.NEW) {
                commits.problem(cd.getId(), "Change " + cd.getId() + " is " + cd.change().getStatus().toString().toLowerCase());
            } else {
                checkSubmitRule(cd);
            }
        } catch (ResourceConflictException e) {
            commits.problem(cd.getId(), e.getMessage());
        } catch (OrmException e) {
            String msg = "Error checking submit rules for change";
            log.warn(msg + " " + cd.getId(), e);
            commits.problem(cd.getId(), msg);
        }
    }
    commits.maybeFailVerbose();
}
#method_after
private void checkSubmitRulesAndState(ChangeSet cs) throws ResourceConflictException {
    checkArgument(!cs.furtherHiddenChanges(), "checkSubmitRulesAndState called for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        try {
            if (cd.change().getStatus() != Change.Status.NEW) {
                commitStatus.problem(cd.getId(), "Change " + cd.getId() + " is " + cd.change().getStatus().toString().toLowerCase());
            } else {
                checkSubmitRule(cd);
            }
        } catch (ResourceConflictException e) {
            commitStatus.problem(cd.getId(), e.getMessage());
        } catch (OrmException e) {
            String msg = "Error checking submit rules for change";
            log.warn(msg + " " + cd.getId(), e);
            commitStatus.problem(cd.getId(), msg);
        }
    }
    commitStatus.maybeFailVerbose();
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput, boolean dryrun) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.dryrun = dryrun;
    this.caller = caller;
    this.ts = TimeUtil.nowTs();
    submissionId = RequestId.forChange(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.setMergeOpRepoManager(orm).completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput, boolean dryrun) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.accountsToNotify = notifyUtil.resolveAccounts(submitInput.notifyDetails);
    this.dryrun = dryrun;
    this.caller = caller;
    this.ts = TimeUtil.nowTs();
    submissionId = RequestId.forChange(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.setMergeOpRepoManager(orm).completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commitStatus = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Branch.NameKey> branches = cbb.keySet();
    for (Branch.NameKey branch : branches) {
        OpenRepo or = openRepo(branch.getParentKey());
        if (or != null) {
            toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
        }
    }
    // Done checks that don't involve running submit strategies.
    commits.maybeFailVerbose();
    SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
    try {
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp, dryrun);
        this.allProjects = submoduleOp.getProjectsInOrder();
        BatchUpdate.execute(orm.batchUpdates(allProjects), new SubmitStrategyListener(submitInput, strategies, commits), submissionId, dryrun);
    } catch (SubmoduleException e) {
        throw new IntegrationException(e);
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot integrate hidden changes into history");
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    ListMultimap<Branch.NameKey, ChangeData> cbb;
    try {
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Branch.NameKey> branches = cbb.keySet();
    for (Branch.NameKey branch : branches) {
        OpenRepo or = openRepo(branch.getParentKey());
        if (or != null) {
            toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
        }
    }
    // Done checks that don't involve running submit strategies.
    commitStatus.maybeFailVerbose();
    SubmoduleOp submoduleOp = subOpFactory.create(branches, orm);
    try {
        List<SubmitStrategy> strategies = getSubmitStrategies(toSubmit, submoduleOp, dryrun);
        this.allProjects = submoduleOp.getProjectsInOrder();
        BatchUpdate.execute(orm.batchUpdates(allProjects), new SubmitStrategyListener(submitInput, strategies, commitStatus), submissionId, dryrun);
    } catch (SubmoduleException e) {
        throw new IntegrationException(e);
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
}
#end_block

#method_before
private List<SubmitStrategy> getSubmitStrategies(Map<Branch.NameKey, BranchBatch> toSubmit, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    List<SubmitStrategy> strategies = new ArrayList<>();
    Set<Branch.NameKey> allBranches = submoduleOp.getBranchesInOrder();
    for (Branch.NameKey branch : allBranches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        if (toSubmit.containsKey(branch)) {
            BranchBatch submitting = toSubmit.get(branch);
            OpenBranch ob = or.getBranch(branch);
            checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
            Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
            ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
            SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip, submoduleOp, dryrun);
            strategies.add(strategy);
            strategy.addOps(or.getUpdate(), commitsToSubmit);
            if (submitting.submitType().equals(SubmitType.FAST_FORWARD_ONLY) && submoduleOp.hasSubscription(branch)) {
                submoduleOp.addOp(or.getUpdate(), branch);
            }
        } else {
            // no open change for this branch
            // add submodule triggered op into BatchUpdate
            submoduleOp.addOp(or.getUpdate(), branch);
        }
    }
    return strategies;
}
#method_after
private List<SubmitStrategy> getSubmitStrategies(Map<Branch.NameKey, BranchBatch> toSubmit, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    List<SubmitStrategy> strategies = new ArrayList<>();
    Set<Branch.NameKey> allBranches = submoduleOp.getBranchesInOrder();
    Set<CodeReviewCommit> allCommits = toSubmit.values().stream().map(BranchBatch::commits).flatMap(Set::stream).collect(Collectors.toSet());
    for (Branch.NameKey branch : allBranches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        if (toSubmit.containsKey(branch)) {
            BranchBatch submitting = toSubmit.get(branch);
            OpenBranch ob = or.getBranch(branch);
            checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
            Set<CodeReviewCommit> commitsToSubmit = submitting.commits();
            ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
            SubmitStrategy strategy = submitStrategyFactory.create(submitting.submitType(), db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, ob.oldTip), allCommits, branch, caller, ob.mergeTip, commitStatus, submissionId, submitInput.notify, accountsToNotify, submoduleOp, dryrun);
            strategies.add(strategy);
            strategy.addOps(or.getUpdate(), commitsToSubmit);
            if (submitting.submitType().equals(SubmitType.FAST_FORWARD_ONLY) && submoduleOp.hasSubscription(branch)) {
                submoduleOp.addOp(or.getUpdate(), branch);
            }
        } else {
            // no open change for this branch
            // add submodule triggered op into BatchUpdate
            submoduleOp.addOp(or.getUpdate(), branch);
        }
    }
    return strategies;
}
#end_block

#method_before
private Set<RevCommit> getAlreadyAccepted(OpenRepo or, CodeReviewCommit branchTip) throws IntegrationException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : or.repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                CodeReviewCommit aac = or.rw.parseCommit(r.getObjectId());
                if (!commits.commits.values().contains(aac)) {
                    alreadyAccepted.add(aac);
                }
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#method_after
private Set<RevCommit> getAlreadyAccepted(OpenRepo or, CodeReviewCommit branchTip) throws IntegrationException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : or.repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                CodeReviewCommit aac = or.rw.parseCommit(r.getObjectId());
                if (!commitStatus.commits.values().contains(aac)) {
                    alreadyAccepted.add(aac);
                }
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#end_block

#method_before
private BranchBatch validateChangeList(OpenRepo or, Collection<ChangeData> submitted) throws IntegrationException {
    logDebug("Validating {} changes", submitted.size());
    List<ChangeData> toSubmit = new ArrayList<>(submitted.size());
    Multimap<ObjectId, PatchSet.Id> revisions = getRevisions(or, submitted);
    SubmitType submitType = null;
    ChangeData choseSubmitTypeFrom = null;
    for (ChangeData cd : submitted) {
        Change.Id changeId = cd.getId();
        ChangeControl ctl;
        Change chg;
        try {
            ctl = cd.changeControl();
            chg = cd.change();
        } catch (OrmException e) {
            commits.logProblem(changeId, e);
            continue;
        }
        SubmitType st = getSubmitType(cd);
        if (st == null) {
            commits.logProblem(changeId, "No submit type for change");
            continue;
        }
        if (submitType == null) {
            submitType = st;
            choseSubmitTypeFrom = cd;
        } else if (st != submitType) {
            commits.problem(changeId, String.format("Change has submit type %s, but previously chose submit type %s " + "from change %s in the same batch", st, submitType, choseSubmitTypeFrom.getId()));
            continue;
        }
        if (chg.currentPatchSetId() == null) {
            String msg = "Missing current patch set on change";
            logError(msg + " " + changeId);
            commits.problem(changeId, msg);
            continue;
        }
        PatchSet ps;
        Branch.NameKey destBranch = chg.getDest();
        try {
            ps = cd.currentPatchSet();
        } catch (OrmException e) {
            commits.logProblem(changeId, e);
            continue;
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.logProblem(changeId, "Missing patch set or revision on change");
            continue;
        }
        String idstr = ps.getRevision().get();
        ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException e) {
            commits.logProblem(changeId, e);
            continue;
        }
        if (!revisions.containsEntry(id, ps.getId())) {
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.logProblem(changeId, "Revision " + idstr + " of patch set " + ps.getPatchSetId() + " does not match " + ps.getId().toRefName() + " for change");
            continue;
        }
        CodeReviewCommit commit;
        try {
            commit = or.rw.parseCommit(id);
        } catch (IOException e) {
            commits.logProblem(changeId, e);
            continue;
        }
        // TODO(dborowitz): Consider putting ChangeData in CodeReviewCommit.
        commit.setControl(ctl);
        commit.setPatchsetId(ps.getId());
        commits.put(commit);
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(or.repo, commit, or.project, destBranch, ps.getId(), caller);
        } catch (MergeValidationException mve) {
            commits.problem(changeId, mve.getMessage());
            continue;
        }
        commit.add(or.canMergeFlag);
        toSubmit.add(cd);
    }
    logDebug("Submitting on this run: {}", toSubmit);
    return new AutoValue_MergeOp_BranchBatch(submitType, toSubmit);
}
#method_after
private BranchBatch validateChangeList(OpenRepo or, Collection<ChangeData> submitted) throws IntegrationException {
    logDebug("Validating {} changes", submitted.size());
    Set<CodeReviewCommit> toSubmit = new LinkedHashSet<>(submitted.size());
    SetMultimap<ObjectId, PatchSet.Id> revisions = getRevisions(or, submitted);
    SubmitType submitType = null;
    ChangeData choseSubmitTypeFrom = null;
    for (ChangeData cd : submitted) {
        Change.Id changeId = cd.getId();
        ChangeControl ctl;
        Change chg;
        try {
            ctl = cd.changeControl();
            chg = cd.change();
        } catch (OrmException e) {
            commitStatus.logProblem(changeId, e);
            continue;
        }
        SubmitType st = getSubmitType(cd);
        if (st == null) {
            commitStatus.logProblem(changeId, "No submit type for change");
            continue;
        }
        if (submitType == null) {
            submitType = st;
            choseSubmitTypeFrom = cd;
        } else if (st != submitType) {
            commitStatus.problem(changeId, String.format("Change has submit type %s, but previously chose submit type %s " + "from change %s in the same batch", st, submitType, choseSubmitTypeFrom.getId()));
            continue;
        }
        if (chg.currentPatchSetId() == null) {
            String msg = "Missing current patch set on change";
            logError(msg + " " + changeId);
            commitStatus.problem(changeId, msg);
            continue;
        }
        PatchSet ps;
        Branch.NameKey destBranch = chg.getDest();
        try {
            ps = cd.currentPatchSet();
        } catch (OrmException e) {
            commitStatus.logProblem(changeId, e);
            continue;
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commitStatus.logProblem(changeId, "Missing patch set or revision on change");
            continue;
        }
        String idstr = ps.getRevision().get();
        ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException e) {
            commitStatus.logProblem(changeId, e);
            continue;
        }
        if (!revisions.containsEntry(id, ps.getId())) {
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commitStatus.logProblem(changeId, "Revision " + idstr + " of patch set " + ps.getPatchSetId() + " does not match " + ps.getId().toRefName() + " for change");
            continue;
        }
        CodeReviewCommit commit;
        try {
            commit = or.rw.parseCommit(id);
        } catch (IOException e) {
            commitStatus.logProblem(changeId, e);
            continue;
        }
        // TODO(dborowitz): Consider putting ChangeData in CodeReviewCommit.
        commit.setControl(ctl);
        commit.setPatchsetId(ps.getId());
        commitStatus.put(commit);
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(or.repo, commit, or.project, destBranch, ps.getId(), caller);
        } catch (MergeValidationException mve) {
            commitStatus.problem(changeId, mve.getMessage());
            continue;
        }
        commit.add(or.canMergeFlag);
        toSubmit.add(commit);
    }
    logDebug("Submitting on this run: {}", toSubmit);
    return new AutoValue_MergeOp_BranchBatch(submitType, toSubmit);
}
#end_block

#method_before
private Multimap<ObjectId, PatchSet.Id> getRevisions(OpenRepo or, Collection<ChangeData> cds) throws IntegrationException {
    try {
        List<String> refNames = new ArrayList<>(cds.size());
        for (ChangeData cd : cds) {
            Change c = cd.change();
            if (c != null) {
                refNames.add(c.currentPatchSetId().toRefName());
            }
        }
        Multimap<ObjectId, PatchSet.Id> revisions = HashMultimap.create(cds.size(), 1);
        for (Map.Entry<String, Ref> e : or.repo.getRefDatabase().exactRef(refNames.toArray(new String[refNames.size()])).entrySet()) {
            revisions.put(e.getValue().getObjectId(), PatchSet.Id.fromRef(e.getKey()));
        }
        return revisions;
    } catch (IOException | OrmException e) {
        throw new IntegrationException("Failed to validate changes", e);
    }
}
#method_after
private SetMultimap<ObjectId, PatchSet.Id> getRevisions(OpenRepo or, Collection<ChangeData> cds) throws IntegrationException {
    try {
        List<String> refNames = new ArrayList<>(cds.size());
        for (ChangeData cd : cds) {
            Change c = cd.change();
            if (c != null) {
                refNames.add(c.currentPatchSetId().toRefName());
            }
        }
        SetMultimap<ObjectId, PatchSet.Id> revisions = MultimapBuilder.hashKeys(cds.size()).hashSetValues(1).build();
        for (Map.Entry<String, Ref> e : or.repo.getRefDatabase().exactRef(refNames.toArray(new String[refNames.size()])).entrySet()) {
            revisions.put(e.getValue().getObjectId(), PatchSet.Id.fromRef(e.getKey()));
        }
        return revisions;
    } catch (IOException | OrmException e) {
        throw new IntegrationException("Failed to validate changes", e);
    }
}
#end_block

#method_before
private void abandonAllOpenChangeForDeletedProject(Project.NameKey destProject) {
    try {
        for (ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) {
            try (BatchUpdate bu = batchUpdateFactory.create(db, destProject, internalUserFactory.create(), ts)) {
                bu.setRequestId(submissionId);
                bu.addOp(cd.getId(), new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) throws OrmException {
                        Change change = ctx.getChange();
                        if (!change.getStatus().isOpen()) {
                            return false;
                        }
                        change.setStatus(Change.Status.ABANDONED);
                        ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), change.currentPatchSetId(), internalUserFactory.create(), change.getLastUpdatedOn(), ChangeMessagesUtil.TAG_MERGED, "Project was deleted.");
                        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(change.currentPatchSetId()), msg);
                        return true;
                    }
                });
                try {
                    bu.execute();
                } catch (UpdateException | RestApiException e) {
                    logWarn("Cannot abandon changes for deleted project " + destProject, e);
                }
            }
        }
    } catch (OrmException e) {
        logWarn("Cannot abandon changes for deleted project " + destProject, e);
    }
}
#method_after
private void abandonAllOpenChangeForDeletedProject(Project.NameKey destProject) {
    try {
        for (ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) {
            try (BatchUpdate bu = batchUpdateFactory.create(db, destProject, internalUserFactory.create(), ts)) {
                bu.setRequestId(submissionId);
                bu.addOp(cd.getId(), new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) throws OrmException {
                        Change change = ctx.getChange();
                        if (!change.getStatus().isOpen()) {
                            return false;
                        }
                        change.setStatus(Change.Status.ABANDONED);
                        ChangeMessage msg = ChangeMessagesUtil.newMessage(change.currentPatchSetId(), internalUserFactory.create(), change.getLastUpdatedOn(), ChangeMessagesUtil.TAG_MERGED, "Project was deleted.");
                        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(change.currentPatchSetId()), msg);
                        return true;
                    }
                });
                try {
                    bu.execute();
                } catch (UpdateException | RestApiException e) {
                    logWarn("Cannot abandon changes for deleted project " + destProject, e);
                }
            }
        }
    } catch (OrmException e) {
        logWarn("Cannot abandon changes for deleted project " + destProject, e);
    }
}
#end_block

#method_before
@ConfigSuite.Default
public static Config defaultConfig() {
    Config cfg = new Config();
    cfg.setBoolean("noteDb", null, "testRebuilderWrapper", true);
    return cfg;
}
#method_after
@ConfigSuite.Default
public static Config defaultConfig() {
    Config cfg = new Config();
    cfg.setBoolean("noteDb", null, "testRebuilderWrapper", true);
    // Disable async reindex-if-stale check after index update. This avoids
    // unintentional auto-rebuilding of the change in NoteDb during the read
    // path of the reindex-if-stale check. For the purposes of this test, we
    // want precise control over when auto-rebuilding happens.
    cfg.setBoolean("index", null, "testReindexAfterUpdate", false);
    return cfg;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.readWrite()).isFalse();
    TestTimeUtil.resetWithClockStep(1, TimeUnit.SECONDS);
    setNotesMigration(false, false);
}
#method_after
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.readWrite()).isFalse();
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    setNotesMigration(false, false);
}
#end_block

#method_before
@Test
public void publishedComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putComment(user, id, 1, "comment");
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void publishedComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putComment(user, id, 1, "comment", null);
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void draftComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment");
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void draftComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment", null);
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void draftAndPublishedComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "draft comment");
    putComment(user, id, 1, "published comment");
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void draftAndPublishedComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "draft comment", null);
    putComment(user, id, 1, "published comment", null);
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void publishDraftComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "draft comment");
    publishDrafts(user, id);
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void publishDraftComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "draft comment", null);
    publishDrafts(user, id);
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void noteDbChangeState() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    ObjectId changeMetaId = getMetaRef(project, changeMetaRef(id));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name());
    putDraft(user, id, 1, "comment by user");
    ObjectId userDraftsId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + user.getId() + "=" + userDraftsId.name());
    putDraft(admin, id, 2, "comment by admin");
    ObjectId adminDraftsId = getMetaRef(allUsers, refsDraftComments(id, admin.getId()));
    assertThat(admin.getId().get()).isLessThan(user.getId().get());
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
    putDraft(admin, id, 2, "revised comment by admin");
    adminDraftsId = getMetaRef(allUsers, refsDraftComments(id, admin.getId()));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
}
#method_after
@Test
public void noteDbChangeState() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    ObjectId changeMetaId = getMetaRef(project, changeMetaRef(id));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name());
    putDraft(user, id, 1, "comment by user", null);
    ObjectId userDraftsId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + user.getId() + "=" + userDraftsId.name());
    putDraft(admin, id, 2, "comment by admin", null);
    ObjectId adminDraftsId = getMetaRef(allUsers, refsDraftComments(id, admin.getId()));
    assertThat(admin.getId().get()).isLessThan(user.getId().get());
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
    putDraft(admin, id, 2, "revised comment by admin", null);
    adminDraftsId = getMetaRef(allUsers, refsDraftComments(id, admin.getId()));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
}
#end_block

#method_before
@Test
public void rebuildAutomaticallyWithinBatchUpdate() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    final Change.Id id = r.getPatchSetId().getParentKey();
    assertChangeUpToDate(true, id);
    // Update ReviewDb and NoteDb, then revert the corresponding NoteDb change
    // to simulate it failing.
    NoteDbChangeState oldState = NoteDbChangeState.parse(getUnwrappedDb().changes().get(id));
    String topic = name("a-topic");
    gApi.changes().id(id.get()).topic(topic);
    try (Repository repo = repoManager.openRepository(project)) {
        new TestRepository<>(repo).update(RefNames.changeMetaRef(id), oldState.getChangeMetaId());
    }
    assertChangeUpToDate(false, id);
    // Next NoteDb read comes inside the transaction started by BatchUpdate. In
    // reality this could be caused by a failed update happening between when
    // the change is parsed by ChangesCollection and when the BatchUpdate
    // executes. We simulate it here by using BatchUpdate directly and not going
    // through an API handler.
    final String msg = "message from BatchUpdate";
    try (BatchUpdate bu = batchUpdateFactory.create(db, project, identifiedUserFactory.create(user.getId()), TimeUtil.nowTs())) {
        bu.addOp(id, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                PatchSet.Id psId = ctx.getChange().currentPatchSetId();
                ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), psId);
                cm.setMessage(msg);
                ctx.getDb().changeMessages().insert(Collections.singleton(cm));
                ctx.getUpdate(psId).setChangeMessage(msg);
                return true;
            }
        });
        try {
            bu.execute();
            fail("expected update to fail");
        } catch (UpdateException e) {
            assertThat(e.getMessage()).contains("cannot copy ChangeNotesState");
        }
    }
// TODO(dborowitz): Re-enable these assertions once we fix auto-rebuilding
// in the BatchUpdate path.
// // As an implementation detail, change wasn't actually rebuilt inside the
// // BatchUpdate transaction, but it was rebuilt during read for the
// // subsequent reindex. Thus it's impossible to actually observe an
// // out-of-date state in the caller.
// assertChangeUpToDate(true, id);
// // Check that the bundles are equal.
// ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
// ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
// ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
// assertThat(actual.differencesFrom(expected)).isEmpty();
// assertThat(
// Iterables.transform(
// notes.getChangeMessages(),
// ChangeMessage::getMessage))
// .contains(msg);
// assertThat(actual.getChange().getTopic()).isEqualTo(topic);
}
#method_after
@Test
public void rebuildAutomaticallyWithinBatchUpdate() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    final Change.Id id = r.getPatchSetId().getParentKey();
    assertChangeUpToDate(true, id);
    // Update ReviewDb and NoteDb, then revert the corresponding NoteDb change
    // to simulate it failing.
    NoteDbChangeState oldState = NoteDbChangeState.parse(getUnwrappedDb().changes().get(id));
    String topic = name("a-topic");
    gApi.changes().id(id.get()).topic(topic);
    try (Repository repo = repoManager.openRepository(project)) {
        new TestRepository<>(repo).update(RefNames.changeMetaRef(id), oldState.getChangeMetaId());
    }
    assertChangeUpToDate(false, id);
    // Next NoteDb read comes inside the transaction started by BatchUpdate. In
    // reality this could be caused by a failed update happening between when
    // the change is parsed by ChangesCollection and when the BatchUpdate
    // executes. We simulate it here by using BatchUpdate directly and not going
    // through an API handler.
    final String msg = "message from BatchUpdate";
    try (BatchUpdate bu = batchUpdateFactory.create(db, project, identifiedUserFactory.create(user.getId()), TimeUtil.nowTs())) {
        bu.addOp(id, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                PatchSet.Id psId = ctx.getChange().currentPatchSetId();
                ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUuid()), ctx.getAccountId(), ctx.getWhen(), psId);
                cm.setMessage(msg);
                ctx.getDb().changeMessages().insert(Collections.singleton(cm));
                ctx.getUpdate(psId).setChangeMessage(msg);
                return true;
            }
        });
        try {
            bu.execute();
            fail("expected update to fail");
        } catch (UpdateException e) {
            assertThat(e.getMessage()).contains("cannot copy ChangeNotesState");
        }
    }
// TODO(dborowitz): Re-enable these assertions once we fix auto-rebuilding
// in the BatchUpdate path.
// // As an implementation detail, change wasn't actually rebuilt inside the
// // BatchUpdate transaction, but it was rebuilt during read for the
// // subsequent reindex. Thus it's impossible to actually observe an
// // out-of-date state in the caller.
// assertChangeUpToDate(true, id);
// // Check that the bundles are equal.
// ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
// ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
// ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
// assertThat(actual.differencesFrom(expected)).isEmpty();
// assertThat(
// Iterables.transform(
// notes.getChangeMessages(),
// ChangeMessage::getMessage))
// .contains(msg);
// assertThat(actual.getChange().getTopic()).isEqualTo(topic);
}
#end_block

#method_before
@Test
public void rebuildReturnsDraftResultWhenRebuildingInChangeNotesFails() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment by user");
    assertChangeUpToDate(true, id);
    ObjectId oldMetaId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    // Add a draft behind NoteDb's back.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "second comment by user");
    setInvalidNoteDbState(id);
    assertDraftsUpToDate(false, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Force the next rebuild attempt to fail (in ChangeNotes).
    rebuilderWrapper.failNextUpdate();
    setNotesMigration(true, true);
    ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
    notes.getDraftComments(user.getId());
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Not up to date, but the actual returned state matches anyway.
    assertDraftsUpToDate(false, id, user);
    ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
    ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
    assertThat(actual.differencesFrom(expected)).isEmpty();
    // Another rebuild attempt succeeds
    notesFactory.create(dbProvider.get(), project, id);
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(true, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isNotEqualTo(oldMetaId);
}
#method_after
@Test
public void rebuildReturnsDraftResultWhenRebuildingInChangeNotesFails() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment by user", null);
    assertChangeUpToDate(true, id);
    ObjectId oldMetaId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    // Add a draft behind NoteDb's back.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "second comment by user", null);
    setInvalidNoteDbState(id);
    assertDraftsUpToDate(false, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Force the next rebuild attempt to fail (in ChangeNotes).
    rebuilderWrapper.failNextUpdate();
    setNotesMigration(true, true);
    ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
    notes.getDraftComments(user.getId());
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Not up to date, but the actual returned state matches anyway.
    assertDraftsUpToDate(false, id, user);
    ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
    ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
    assertThat(actual.differencesFrom(expected)).isEmpty();
    // Another rebuild attempt succeeds
    notesFactory.create(dbProvider.get(), project, id);
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(true, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isNotEqualTo(oldMetaId);
}
#end_block

#method_before
@Test
public void rebuildReturnsDraftResultWhenRebuildingInDraftCommentNotesFails() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment by user");
    assertChangeUpToDate(true, id);
    ObjectId oldMetaId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    // Add a draft behind NoteDb's back.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "second comment by user");
    ReviewDb db = getUnwrappedDb();
    Change c = db.changes().get(id);
    // Leave change meta ID alone so DraftCommentNotes does the rebuild.
    ObjectId badSha = ObjectId.fromString("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef");
    NoteDbChangeState bogusState = new NoteDbChangeState(id, PrimaryStorage.REVIEW_DB, Optional.of(NoteDbChangeState.RefState.create(NoteDbChangeState.parse(c).getChangeMetaId(), ImmutableMap.of(user.getId(), badSha))));
    c.setNoteDbState(bogusState.toString());
    db.changes().update(Collections.singleton(c));
    assertDraftsUpToDate(false, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Force the next rebuild attempt to fail (in DraftCommentNotes).
    rebuilderWrapper.failNextUpdate();
    setNotesMigration(true, true);
    ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
    notes.getDraftComments(user.getId());
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Not up to date, but the actual returned state matches anyway.
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(false, id, user);
    ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
    ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
    assertThat(actual.differencesFrom(expected)).isEmpty();
    // Another rebuild attempt succeeds
    notesFactory.create(dbProvider.get(), project, id).getDraftComments(user.getId());
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(true, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isNotEqualTo(oldMetaId);
}
#method_after
@Test
public void rebuildReturnsDraftResultWhenRebuildingInDraftCommentNotesFails() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment by user", null);
    assertChangeUpToDate(true, id);
    ObjectId oldMetaId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    // Add a draft behind NoteDb's back.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "second comment by user", null);
    ReviewDb db = getUnwrappedDb();
    Change c = db.changes().get(id);
    // Leave change meta ID alone so DraftCommentNotes does the rebuild.
    ObjectId badSha = ObjectId.fromString("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef");
    NoteDbChangeState bogusState = new NoteDbChangeState(id, PrimaryStorage.REVIEW_DB, Optional.of(NoteDbChangeState.RefState.create(NoteDbChangeState.parse(c).getChangeMetaId(), ImmutableMap.of(user.getId(), badSha))), Optional.empty());
    c.setNoteDbState(bogusState.toString());
    db.changes().update(Collections.singleton(c));
    assertDraftsUpToDate(false, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Force the next rebuild attempt to fail (in DraftCommentNotes).
    rebuilderWrapper.failNextUpdate();
    setNotesMigration(true, true);
    ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
    notes.getDraftComments(user.getId());
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Not up to date, but the actual returned state matches anyway.
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(false, id, user);
    ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
    ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
    assertThat(actual.differencesFrom(expected)).isEmpty();
    // Another rebuild attempt succeeds
    notesFactory.create(dbProvider.get(), project, id).getDraftComments(user.getId());
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(true, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isNotEqualTo(oldMetaId);
}
#end_block

#method_before
@Test
public void rebuildAutomaticallyWhenDraftsOutOfDate() throws Exception {
    setNotesMigration(true, true);
    setApiUser(user);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment");
    assertDraftsUpToDate(true, id, user);
    // Make a ReviewDb change behind NoteDb's back and ensure it's detected.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "comment");
    setInvalidNoteDbState(id);
    assertDraftsUpToDate(false, id, user);
    // On next NoteDb read, the drafts are transparently rebuilt.
    setNotesMigration(true, true);
    assertThat(gApi.changes().id(id.get()).current().drafts()).containsKey(PushOneCommit.FILE_NAME);
    assertDraftsUpToDate(true, id, user);
}
#method_after
@Test
public void rebuildAutomaticallyWhenDraftsOutOfDate() throws Exception {
    setNotesMigration(true, true);
    setApiUser(user);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment", null);
    assertDraftsUpToDate(true, id, user);
    // Make a ReviewDb change behind NoteDb's back and ensure it's detected.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "comment", null);
    setInvalidNoteDbState(id);
    assertDraftsUpToDate(false, id, user);
    // On next NoteDb read, the drafts are transparently rebuilt.
    setNotesMigration(true, true);
    assertThat(gApi.changes().id(id.get()).current().drafts()).containsKey(PushOneCommit.FILE_NAME);
    assertDraftsUpToDate(true, id, user);
}
#end_block

#method_before
@Test
public void rebuildDeletesOldDraftRefs() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment");
    Account.Id otherAccountId = new Account.Id(user.getId().get() + 1234);
    String otherDraftRef = refsDraftComments(id, otherAccountId);
    try (Repository repo = repoManager.openRepository(allUsers);
        ObjectInserter ins = repo.newObjectInserter()) {
        ObjectId sha = ins.insert(OBJ_BLOB, "garbage data".getBytes(UTF_8));
        ins.flush();
        RefUpdate ru = repo.updateRef(otherDraftRef);
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(sha);
        assertThat(ru.update()).isEqualTo(RefUpdate.Result.NEW);
    }
    checker.rebuildAndCheckChanges(id);
    try (Repository repo = repoManager.openRepository(allUsers)) {
        assertThat(repo.exactRef(otherDraftRef)).isNull();
    }
}
#method_after
@Test
public void rebuildDeletesOldDraftRefs() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment", null);
    Account.Id otherAccountId = new Account.Id(user.getId().get() + 1234);
    String otherDraftRef = refsDraftComments(id, otherAccountId);
    try (Repository repo = repoManager.openRepository(allUsers);
        ObjectInserter ins = repo.newObjectInserter()) {
        ObjectId sha = ins.insert(OBJ_BLOB, "garbage data".getBytes(UTF_8));
        ins.flush();
        RefUpdate ru = repo.updateRef(otherDraftRef);
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(sha);
        assertThat(ru.update()).isEqualTo(RefUpdate.Result.NEW);
    }
    checker.rebuildAndCheckChanges(id);
    try (Repository repo = repoManager.openRepository(allUsers)) {
        assertThat(repo.exactRef(otherDraftRef)).isNull();
    }
}
#end_block

#method_before
private void putDraft(TestAccount account, Change.Id id, int line, String msg) throws Exception {
    DraftInput in = new DraftInput();
    in.line = line;
    in.message = msg;
    in.path = PushOneCommit.FILE_NAME;
    AcceptanceTestRequestScope.Context old = setApiUser(account);
    try {
        gApi.changes().id(id.get()).current().createDraft(in);
    } finally {
        atrScope.set(old);
    }
}
#method_after
private void putDraft(TestAccount account, Change.Id id, int line, String msg, Boolean unresolved) throws Exception {
    DraftInput in = new DraftInput();
    in.line = line;
    in.message = msg;
    in.path = PushOneCommit.FILE_NAME;
    in.unresolved = unresolved;
    AcceptanceTestRequestScope.Context old = setApiUser(account);
    try {
        gApi.changes().id(id.get()).current().createDraft(in);
    } finally {
        atrScope.set(old);
    }
}
#end_block

#method_before
private void putComment(TestAccount account, Change.Id id, int line, String msg) throws Exception {
    CommentInput in = new CommentInput();
    in.line = line;
    in.message = msg;
    ReviewInput rin = new ReviewInput();
    rin.comments = new HashMap<>();
    rin.comments.put(PushOneCommit.FILE_NAME, ImmutableList.of(in));
    rin.drafts = ReviewInput.DraftHandling.KEEP;
    AcceptanceTestRequestScope.Context old = setApiUser(account);
    try {
        gApi.changes().id(id.get()).current().review(rin);
    } finally {
        atrScope.set(old);
    }
}
#method_after
private void putComment(TestAccount account, Change.Id id, int line, String msg, String inReplyTo) throws Exception {
    CommentInput in = new CommentInput();
    in.line = line;
    in.message = msg;
    in.inReplyTo = inReplyTo;
    ReviewInput rin = new ReviewInput();
    rin.comments = new HashMap<>();
    rin.comments.put(PushOneCommit.FILE_NAME, ImmutableList.of(in));
    rin.drafts = ReviewInput.DraftHandling.KEEP;
    AcceptanceTestRequestScope.Context old = setApiUser(account);
    try {
        gApi.changes().id(id.get()).current().review(rin);
    } finally {
        atrScope.set(old);
    }
}
#end_block

#method_before
private ChangeMessage insertMessage(Change.Id id, PatchSet.Id psId, Account.Id author, Timestamp ts, String message) throws Exception {
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), author, ts, psId);
    msg.setMessage(message);
    db.changeMessages().insert(Collections.singleton(msg));
    Change c = db.changes().get(id);
    if (ts.compareTo(c.getLastUpdatedOn()) > 0) {
        c.setLastUpdatedOn(ts);
        db.changes().update(Collections.singleton(c));
    }
    return msg;
}
#method_after
private ChangeMessage insertMessage(Change.Id id, PatchSet.Id psId, Account.Id author, Timestamp ts, String message) throws Exception {
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUuid()), author, ts, psId);
    msg.setMessage(message);
    db.changeMessages().insert(Collections.singleton(msg));
    Change c = db.changes().get(id);
    if (ts.compareTo(c.getLastUpdatedOn()) > 0) {
        c.setLastUpdatedOn(ts);
        db.changes().update(Collections.singleton(c));
    }
    return msg;
}
#end_block

#method_before
private void allowRunAs() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    Util.allow(cfg, GlobalCapability.RUN_AS, SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID());
    saveProjectConfig(allProjects, cfg);
}
#method_after
private void allowRunAs() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    Util.allow(cfg, GlobalCapability.RUN_AS, systemGroupBackend.getGroup(REGISTERED_USERS).getUUID());
    saveProjectConfig(allProjects, cfg);
}
#end_block

#method_before
private void removeRunAs() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    Util.remove(cfg, GlobalCapability.RUN_AS, SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID());
    saveProjectConfig(allProjects, cfg);
}
#method_after
private void removeRunAs() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    Util.remove(cfg, GlobalCapability.RUN_AS, systemGroupBackend.getGroup(REGISTERED_USERS).getUUID());
    saveProjectConfig(allProjects, cfg);
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, Rebase.Input in) throws AuthException, ResourceConflictException, IOException, InvalidChangeOperationException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        throw new ResourceConflictException(String.format("no edit exists for change %s", rsrc.getChange().getChangeId()));
    }
    PatchSet current = psUtil.current(db.get(), rsrc.getNotes());
    if (current.getId().equals(edit.get().getBasePatchSet().getId())) {
        throw new ResourceConflictException(String.format("edit for change %s is already on latest patch set: %s", rsrc.getChange().getChangeId(), current.getId()));
    }
    editModifier.rebaseEdit(edit.get(), current);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, Rebase.Input in) throws AuthException, ResourceConflictException, IOException, OrmException {
    Project.NameKey project = rsrc.getProject();
    try (Repository repository = repositoryManager.openRepository(project)) {
        editModifier.rebaseEdit(repository, rsrc.getControl());
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Test
public void addMultipleIncludes() throws Exception {
    String p = createGroup("parent");
    String g1 = createGroup("newGroup1");
    String g2 = createGroup("newGroup2");
    List<String> groups = new LinkedList<>();
    groups.add(g1);
    groups.add(g2);
    gApi.groups().id(p).addGroups(g1, g2);
    assertIncludes(p, g1, g2);
}
#method_after
@Test
public void addMultipleIncludes() throws Exception {
    String p = createGroup("parent");
    String g1 = createGroup("newGroup1");
    String g2 = createGroup("newGroup2");
    List<String> groups = new ArrayList<>();
    groups.add(g1);
    groups.add(g2);
    gApi.groups().id(p).addGroups(g1, g2);
    assertIncludes(p, g1, g2);
}
#end_block

#method_before
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = new HashMap<>();
    List<GroupInfo> result = new LinkedList<>();
    Account.Id me = control.getUser().getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup()) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#method_after
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = new HashMap<>();
    List<GroupInfo> result = new ArrayList<>();
    Account.Id me = control.getUser().getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup()) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#end_block

#method_before
@Override
public List<AccountInfo> apply(TopLevelResource rsrc) throws OrmException, BadRequestException, MethodNotAllowedException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (suggest && (!suggestConfig || query.length() < suggestFrom)) {
        return Collections.emptyList();
    }
    Set<FillOptions> fillOptions = EnumSet.of(FillOptions.ID);
    if (options.contains(ListAccountsOption.DETAILS)) {
        fillOptions.addAll(AccountLoader.DETAILED_OPTIONS);
    }
    if (options.contains(ListAccountsOption.ALL_EMAILS)) {
        fillOptions.add(FillOptions.EMAIL);
        fillOptions.add(FillOptions.SECONDARY_EMAILS);
    }
    if (suggest) {
        fillOptions.addAll(AccountLoader.DETAILED_OPTIONS);
        fillOptions.add(FillOptions.EMAIL);
        fillOptions.add(FillOptions.SECONDARY_EMAILS);
    }
    accountLoader = accountLoaderFactory.create(fillOptions);
    AccountIndex searchIndex = indexes.getSearchIndex();
    if (searchIndex != null) {
        return queryFromIndex();
    }
    if (!suggest) {
        throw new MethodNotAllowedException();
    }
    if (start != null) {
        throw new MethodNotAllowedException("option start not allowed");
    }
    return queryFromDb();
}
#method_after
@Override
public List<AccountInfo> apply(TopLevelResource rsrc) throws OrmException, BadRequestException, MethodNotAllowedException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (suggest && (!suggestConfig || query.length() < suggestFrom)) {
        return Collections.emptyList();
    }
    Set<FillOptions> fillOptions = EnumSet.of(FillOptions.ID);
    if (options.contains(ListAccountsOption.DETAILS)) {
        fillOptions.addAll(AccountLoader.DETAILED_OPTIONS);
    }
    if (options.contains(ListAccountsOption.ALL_EMAILS)) {
        fillOptions.add(FillOptions.EMAIL);
        fillOptions.add(FillOptions.SECONDARY_EMAILS);
    }
    if (suggest) {
        fillOptions.addAll(AccountLoader.DETAILED_OPTIONS);
        fillOptions.add(FillOptions.EMAIL);
        fillOptions.add(FillOptions.SECONDARY_EMAILS);
    }
    accountLoader = accountLoaderFactory.create(fillOptions);
    if (queryProcessor.isDisabled()) {
        throw new MethodNotAllowedException("query disabled");
    }
    if (start != null) {
        queryProcessor.setStart(start);
    }
    Map<Account.Id, AccountInfo> matches = new LinkedHashMap<>();
    try {
        Predicate<AccountState> queryPred;
        if (suggest) {
            queryPred = queryBuilder.defaultQuery(query);
            queryProcessor.setLimit(suggestLimit);
        } else {
            queryPred = queryBuilder.parse(query);
        }
        QueryResult<AccountState> result = queryProcessor.query(queryPred);
        for (AccountState accountState : result.entities()) {
            Account.Id id = accountState.getAccount().getId();
            matches.put(id, accountLoader.get(id));
        }
        accountLoader.fill();
        List<AccountInfo> sorted = AccountInfoComparator.ORDER_NULLS_LAST.sortedCopy(matches.values());
        if (!sorted.isEmpty() && result.more()) {
            sorted.get(sorted.size() - 1)._moreAccounts = true;
        }
        return sorted;
    } catch (QueryParseException e) {
        if (suggest) {
            return ImmutableList.of();
        }
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
private void authenticateAndRedirect(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(user.getExternalId());
    AuthResult arsp = null;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        Account.Id actualId = accountManager.lookup(user.getExternalId());
        Account.Id claimedId = null;
        // That why we query it here, not to lose linking mode.
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            claimedId = accountManager.lookup(claimedIdentifier);
            if (claimedId == null) {
                log.debug("Claimed identity is unknown");
            }
        }
        // and user account exists for this identity
        if (claimedId != null) {
            log.debug("Claimed identity is set and is known");
            if (actualId != null) {
                if (claimedId.equals(actualId)) {
                    // Both link to the same account, that's what we expected.
                    log.debug("Both link to the same account. All is fine.");
                } else {
                    // This is (for now) a fatal error. There are two records
                    // for what might be the same user. The admin would have to
                    // link the accounts manually.
                    log.error("OAuth accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + user.getExternalId());
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            } else {
                // Claimed account already exists: link to it.
                log.debug("Claimed account already exists: link to it.");
                try {
                    accountManager.link(claimedId, areq);
                } catch (OrmException e) {
                    log.error("Cannot link: " + user.getExternalId() + " to user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier);
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            }
        } else if (linkMode) {
            // Use case 2: link mode activated from the UI
            Account.Id accountId = identifiedUser.get().getAccountId();
            try {
                log.debug("Linking \"{}\" to \"{}\"", user.getExternalId(), accountId);
                accountManager.link(accountId, areq);
            } catch (OrmException e) {
                log.error("Cannot link: " + user.getExternalId() + " to user identity: " + accountId);
                rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                return;
            } finally {
                linkMode = false;
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    StringBuilder rdr = new StringBuilder(urlProvider.get(req));
    rdr.append(Url.decode(redirectToken));
    rsp.sendRedirect(rdr.toString());
}
#method_after
private void authenticateAndRedirect(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(user.getExternalId());
    AuthResult arsp = null;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        Optional<Account.Id> actualId = accountManager.lookup(user.getExternalId());
        Optional<Account.Id> claimedId = Optional.empty();
        // That why we query it here, not to lose linking mode.
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            claimedId = accountManager.lookup(claimedIdentifier);
            if (!claimedId.isPresent()) {
                log.debug("Claimed identity is unknown");
            }
        }
        // and user account exists for this identity
        if (claimedId.isPresent()) {
            log.debug("Claimed identity is set and is known");
            if (actualId.isPresent()) {
                if (claimedId.get().equals(actualId.get())) {
                    // Both link to the same account, that's what we expected.
                    log.debug("Both link to the same account. All is fine.");
                } else {
                    // This is (for now) a fatal error. There are two records
                    // for what might be the same user. The admin would have to
                    // link the accounts manually.
                    log.error("OAuth accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId.get() + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId.get() + " is " + user.getExternalId());
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            } else {
                // Claimed account already exists: link to it.
                log.debug("Claimed account already exists: link to it.");
                try {
                    accountManager.link(claimedId.get(), areq);
                } catch (OrmException e) {
                    log.error("Cannot link: " + user.getExternalId() + " to user identity:\n" + "  Claimed ID: " + claimedId.get() + " is " + claimedIdentifier);
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            }
        } else if (linkMode) {
            // Use case 2: link mode activated from the UI
            Account.Id accountId = identifiedUser.get().getAccountId();
            try {
                log.debug("Linking \"{}\" to \"{}\"", user.getExternalId(), accountId);
                accountManager.link(accountId, areq);
            } catch (OrmException e) {
                log.error("Cannot link: " + user.getExternalId() + " to user identity: " + accountId);
                rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                return;
            } finally {
                linkMode = false;
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    StringBuilder rdr = new StringBuilder(urlProvider.get(req));
    rdr.append(Url.decode(redirectToken));
    rsp.sendRedirect(rdr.toString());
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(test ? new H2AccountPatchReviewStore.InMemoryModule() : new H2AccountPatchReviewStore.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(test ? new H2AccountPatchReviewStore.InMemoryModule() : new H2AccountPatchReviewStore.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave, sysInjector.getInstance(DownloadConfig.class)));
    if (!slave && indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave, sysInjector.getInstance(DownloadConfig.class), sysInjector.getInstance(LfsPluginAuthCommand.Module.class)));
    if (!slave && indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public Map<Class<? extends Annotation>, Iterable<ExtensionMetaData>> scan(String pluginName, Iterable<Class<? extends Annotation>> annotations) throws InvalidPluginException {
    Set<String> descriptors = new HashSet<>();
    Multimap<String, JarScanner.ClassData> rawMap = ArrayListMultimap.create();
    Map<Class<? extends Annotation>, String> classObjToClassDescr = new HashMap<>();
    for (Class<? extends Annotation> annotation : annotations) {
        String descriptor = Type.getType(annotation).getDescriptor();
        descriptors.add(descriptor);
        classObjToClassDescr.put(annotation, descriptor);
    }
    Enumeration<JarEntry> e = jarFile.entries();
    while (e.hasMoreElements()) {
        JarEntry entry = e.nextElement();
        if (skip(entry)) {
            continue;
        }
        ClassData def = new ClassData(descriptors);
        try {
            new ClassReader(read(jarFile, entry)).accept(def, SKIP_ALL);
        } catch (IOException err) {
            throw new InvalidPluginException("Cannot auto-register", err);
        } catch (RuntimeException err) {
            PluginLoader.log.warn(String.format("Plugin %s has invalid class file %s inside of %s", pluginName, entry.getName(), jarFile.getName()), err);
            continue;
        }
        if (!Strings.isNullOrEmpty(def.annotationName)) {
            if (def.isConcrete()) {
                rawMap.put(def.annotationName, def);
            } else {
                PluginLoader.log.warn(String.format("Plugin %s tries to @%s(\"%s\") abstract class %s", pluginName, def.annotationName, def.annotationValue, def.className));
            }
        }
    }
    ImmutableMap.Builder<Class<? extends Annotation>, Iterable<ExtensionMetaData>> result = ImmutableMap.builder();
    for (Class<? extends Annotation> annotoation : annotations) {
        String descr = classObjToClassDescr.get(annotoation);
        Collection<ClassData> discoverdData = rawMap.get(descr);
        Collection<ClassData> values = firstNonNull(discoverdData, Collections.<ClassData>emptySet());
        result.put(annotoation, transform(values, cd -> new ExtensionMetaData(cd.className, cd.annotationValue)));
    }
    return result.build();
}
#method_after
@Override
public Map<Class<? extends Annotation>, Iterable<ExtensionMetaData>> scan(String pluginName, Iterable<Class<? extends Annotation>> annotations) throws InvalidPluginException {
    Set<String> descriptors = new HashSet<>();
    ListMultimap<String, JarScanner.ClassData> rawMap = MultimapBuilder.hashKeys().arrayListValues().build();
    Map<Class<? extends Annotation>, String> classObjToClassDescr = new HashMap<>();
    for (Class<? extends Annotation> annotation : annotations) {
        String descriptor = Type.getType(annotation).getDescriptor();
        descriptors.add(descriptor);
        classObjToClassDescr.put(annotation, descriptor);
    }
    Enumeration<JarEntry> e = jarFile.entries();
    while (e.hasMoreElements()) {
        JarEntry entry = e.nextElement();
        if (skip(entry)) {
            continue;
        }
        ClassData def = new ClassData(descriptors);
        try {
            new ClassReader(read(jarFile, entry)).accept(def, SKIP_ALL);
        } catch (IOException err) {
            throw new InvalidPluginException("Cannot auto-register", err);
        } catch (RuntimeException err) {
            PluginLoader.log.warn(String.format("Plugin %s has invalid class file %s inside of %s", pluginName, entry.getName(), jarFile.getName()), err);
            continue;
        }
        if (!Strings.isNullOrEmpty(def.annotationName)) {
            if (def.isConcrete()) {
                rawMap.put(def.annotationName, def);
            } else {
                PluginLoader.log.warn(String.format("Plugin %s tries to @%s(\"%s\") abstract class %s", pluginName, def.annotationName, def.annotationValue, def.className));
            }
        }
    }
    ImmutableMap.Builder<Class<? extends Annotation>, Iterable<ExtensionMetaData>> result = ImmutableMap.builder();
    for (Class<? extends Annotation> annotoation : annotations) {
        String descr = classObjToClassDescr.get(annotoation);
        Collection<ClassData> discoverdData = rawMap.get(descr);
        Collection<ClassData> values = firstNonNull(discoverdData, Collections.<ClassData>emptySet());
        result.put(annotoation, transform(values, cd -> new ExtensionMetaData(cd.className, cd.annotationValue)));
    }
    return result.build();
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    logDebug("Executing batch with {} commands", batch.getCommands().size());
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                logDebug("Allowing non-fast-forward for edit ref");
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            logError(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                logDebug("Updating tag cache on fast-forward of {}", c.getRefName());
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                logDebug("Reloading project in cache");
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                logDebug("Firing ref update for {}", c.getRefName());
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            } else {
                logDebug("Assuming ref update event for {} has fired", c.getRefName());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        logError("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    logDebug("Executing batch with {} commands", batch.getCommands().size());
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                logDebug("Allowing non-fast-forward for edit ref");
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            logError(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        logDebug("Handling error conditions: {}", errors.keySet());
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                logDebug("Updating tag cache on fast-forward of {}", c.getRefName());
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                logDebug("Reloading project in cache");
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                try {
                    repo.setGitwebDescription(ps.getProject().getDescription());
                } catch (IOException e) {
                    log.warn("cannot update description of " + project.getName(), e);
                }
            }
            if (!MagicBranch.isMagicBranch(refName)) {
                logDebug("Firing ref update for {}", c.getRefName());
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            } else {
                logDebug("Assuming ref update event for {} has fired", c.getRefName());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, receiveId);
        SubmoduleOp op = subOpFactory.create(branches, orm);
        op.updateSuperProjects();
    } catch (SubmoduleException e) {
        logError("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            String refName = replace.inputCommand.getRefName();
            checkState(NEW_PATCHSET.matcher(refName).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), refName);
            try {
                logDebug("One-off insertion of patch set for {}", refName);
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                logError(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            logError(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    // No need to continue.
    if (magicBranch == null) {
        logDebug("No magic branch, nothing more to do");
        return;
    } else if (magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranch.cmd.getResult(), Strings.nullToEmpty(magicBranch.cmd.getMessage())));
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            logError(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    logDebug("Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size());
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + lastCreateChangeErrors.stream().collect(joining(" ")));
        logError(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            String refName = replace.inputCommand.getRefName();
            checkState(NEW_PATCHSET.matcher(refName).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), refName);
            try {
                logDebug("One-off insertion of patch set for {}", refName);
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                logError(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            logError(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    // No need to continue.
    if (magicBranch == null) {
        logDebug("No magic branch, nothing more to do");
        return;
    } else if (magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        logWarn(String.format("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranch.cmd.getResult(), Strings.nullToEmpty(magicBranch.cmd.getMessage())));
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            logError(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    logDebug("Counted {} ok to insert, out of {} to replace and {} new", okToInsert, replaceCount, newChanges.size());
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + lastCreateChangeErrors.stream().collect(joining(" ")));
        logError(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        logDebug("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                logDebug("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        logError("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            logError("Error submitting changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    logDebug("Parsing replace command");
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
        logDebug("Replacing with {}", newCommit);
    } catch (IOException e) {
        logError("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        logError("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        logError("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    logDebug("Replacing change {}", changeEnt.getId());
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    logDebug("Parsing replace command");
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
        logDebug("Replacing with {}", newCommit);
    } catch (IOException e) {
        logError("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (NoSuchChangeException e) {
        logError("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    } catch (OrmException e) {
        logError("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    logDebug("Replacing change {}", changeEnt.getId());
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in branch {} with Change-Id {}: {}", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
private void initChangeRefMaps() {
    if (refsByChange == null) {
        int estRefsPerChange = 4;
        refsById = HashMultimap.create();
        refsByChange = ArrayListMultimap.create(allRefs.size() / estRefsPerChange, estRefsPerChange);
        for (Ref ref : allRefs.values()) {
            ObjectId obj = ref.getObjectId();
            if (obj != null) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                if (psId != null) {
                    refsById.put(obj, ref);
                    refsByChange.put(psId.getParentKey(), ref);
                }
            }
        }
    }
}
#method_after
private void initChangeRefMaps() {
    if (refsByChange == null) {
        int estRefsPerChange = 4;
        refsById = MultimapBuilder.hashKeys().arrayListValues().build();
        refsByChange = MultimapBuilder.hashKeys(allRefs.size() / estRefsPerChange).arrayListValues(estRefsPerChange).build();
        for (Ref ref : allRefs.values()) {
            ObjectId obj = ref.getObjectId();
            if (obj != null) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                if (psId != null) {
                    refsById.put(obj, ref);
                    refsByChange.put(psId.getParentKey(), ref);
                }
            }
        }
    }
}
#end_block

#method_before
private SetMultimap<ObjectId, Ref> changeRefsById() {
    initChangeRefMaps();
    return refsById;
}
#method_after
private ListMultimap<ObjectId, Ref> changeRefsById() {
    initChangeRefMaps();
    return refsById;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        logDebug("Short-circuiting new commit validation");
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        logDebug("Short-circuiting new commit validation");
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        ListMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        int i = 0;
        for (RevCommit c; (c = walk.next()) != null; ) {
            i++;
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    logWarn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
        logDebug("Validated {} new commits", i);
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with" + " new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        logError("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with" + " new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private void locatePaths() {
    URL pluginClassesUrl = getClass().getProtectionDomain().getCodeSource().getLocation();
    Path basePath = Paths.get(pluginClassesUrl.getPath()).getParent();
    int idx = 0;
    int buckOutIdx = 0;
    int pluginsIdx = 0;
    for (Path subPath : basePath) {
        if (subPath.endsWith("plugins")) {
            pluginsIdx = idx;
        }
        if (subPath.endsWith(BUCKOUT) || subPath.endsWith(ECLIPSE)) {
            buckOutIdx = idx;
        }
        idx++;
    }
    standalone = checkStandalone(basePath);
    pluginRoot = basePath.getRoot().resolve(basePath.subpath(0, buckOutIdx));
    gen = pluginRoot.resolve(BUCKOUT).resolve("gen");
    if (standalone) {
        pluginSource = pluginRoot;
    } else {
        pluginSubPath = basePath.subpath(pluginsIdx, pluginsIdx + 2);
        pluginSource = pluginRoot.resolve(pluginSubPath);
    }
}
#method_after
private void locatePaths() throws IOException {
    URL pluginClassesUrl = getClass().getProtectionDomain().getCodeSource().getLocation();
    basePath = Paths.get(pluginClassesUrl.getPath()).getParent();
    int idx = 0;
    int buckOutIdx = 0;
    int pluginsIdx = 0;
    for (Path subPath : basePath) {
        if (subPath.endsWith("plugins")) {
            pluginsIdx = idx;
        }
        if (subPath.endsWith(BAZELOUT) || subPath.endsWith(ECLIPSE)) {
            bazel = true;
            buckOutIdx = idx;
        }
        if (subPath.endsWith(BUCKOUT)) {
            buckOutIdx = idx;
        }
        idx++;
    }
    standalone = checkStandalone(basePath);
    if (bazel) {
        pluginRoot = GerritLauncher.resolveInSourceRoot(".");
        gen = pluginRoot.resolve("bazel-out/local-fastbuild/genfiles");
    } else {
        pluginRoot = basePath.getRoot().resolve(basePath.subpath(0, buckOutIdx));
        gen = pluginRoot.resolve(BUCKOUT).resolve("gen");
    }
    if (standalone) {
        pluginSource = pluginRoot;
    } else {
        pluginSubPath = basePath.subpath(pluginsIdx, pluginsIdx + 2);
        pluginSource = pluginRoot.resolve(pluginSubPath);
    }
}
#end_block

#method_before
private boolean checkStandalone(Path basePath) {
    String pathCharStringOrNone = "[a-zA-Z0-9._-]*?";
    Pattern pattern = Pattern.compile(pathCharStringOrNone + "gerrit" + pathCharStringOrNone);
    Path partialPath = basePath;
    for (int i = basePath.getNameCount(); i > 0; i--) {
        int count = partialPath.getNameCount();
        if (count > 1) {
            String gerritDirCandidate = partialPath.subpath(count - 2, count - 1).toString();
            if (pattern.matcher(gerritDirCandidate).matches()) {
                if (partialPath.endsWith(gerritDirCandidate + "/" + BUCKOUT) || partialPath.endsWith(gerritDirCandidate + "/" + ECLIPSE)) {
                    return false;
                }
            }
        }
        partialPath = partialPath.getParent();
    }
    return true;
}
#method_after
private boolean checkStandalone(Path basePath) {
    // TODO(davido): Fix Bazel standalone mode
    if (bazel) {
        return false;
    }
    String pathCharStringOrNone = "[a-zA-Z0-9._-]*?";
    Pattern pattern = Pattern.compile(pathCharStringOrNone + "gerrit" + pathCharStringOrNone);
    Path partialPath = basePath;
    for (int i = basePath.getNameCount(); i > 0; i--) {
        int count = partialPath.getNameCount();
        if (count > 1) {
            String gerritDirCandidate = partialPath.subpath(count - 2, count - 1).toString();
            if (pattern.matcher(gerritDirCandidate).matches()) {
                if (partialPath.endsWith(gerritDirCandidate + "/" + BUCKOUT) || partialPath.endsWith(gerritDirCandidate + "/" + ECLIPSE)) {
                    return false;
                }
            }
        }
        partialPath = partialPath.getParent();
    }
    return true;
}
#end_block

#method_before
private void retrievePluginName() throws IOException {
    Path buckFile = pluginSource.resolve("BUCK");
    byte[] bytes = Files.readAllBytes(buckFile);
    String buckContent = new String(bytes, UTF_8).replaceAll("\\s+", "");
    Matcher matcher = Pattern.compile("gerrit_plugin\\(name='(.*?)'").matcher(buckContent);
    if (matcher.find()) {
        pluginName = matcher.group(1);
    }
    if (Strings.isNullOrEmpty(pluginName)) {
        if (standalone) {
            pluginName = pluginRoot.getFileName().toString();
        } else {
            pluginName = pluginSubPath.getFileName().toString();
        }
    }
}
#method_after
private void retrievePluginName() throws IOException {
    if (bazel) {
        pluginName = basePath.getFileName().toString();
        return;
    }
    Path buildfile = pluginSource.resolve("BUCK");
    if (!Files.exists(buildfile)) {
        buildfile = pluginSource.resolve("BUILD");
    }
    if (!Files.exists(buildfile)) {
        throw new IllegalStateException("Cannot find build file in: " + pluginSource);
    }
    byte[] bytes = Files.readAllBytes(buildfile);
    String buckContent = new String(bytes, UTF_8).replaceAll("\\s+", "");
    Matcher matcher = Pattern.compile("gerrit_plugin\\(name='(.*?)'").matcher(buckContent);
    if (matcher.find()) {
        pluginName = matcher.group(1);
    }
    if (Strings.isNullOrEmpty(pluginName)) {
        if (standalone) {
            pluginName = pluginRoot.getFileName().toString();
        } else {
            pluginName = pluginSubPath.getFileName().toString();
        }
    }
}
#end_block

#method_before
private void buildPluginJar() throws IOException, InterruptedException {
    Properties properties = loadBuckProperties();
    String buck = MoreObjects.firstNonNull(properties.getProperty(BUCKLC), BUCKLC);
    String target;
    if (standalone) {
        target = "//:" + pluginName;
    } else {
        target = pluginSubPath.toString();
    }
    ProcessBuilder processBuilder = new ProcessBuilder(buck, "build", target).directory(pluginRoot.toFile()).redirectErrorStream(true);
    // otherwise plugin jar creation fails:
    processBuilder.environment().put("NO_BUCKD", "1");
    Path forceJar = pluginSource.resolve("src/main/java/ForceJarIfMissing.java");
    // if exists after cancelled test:
    Files.deleteIfExists(forceJar);
    Files.createFile(forceJar);
    testSite = tempSiteDir.getRoot().toPath();
    // otherwise process often hangs:
    Path log = testSite.resolve("log");
    processBuilder.redirectErrorStream(true);
    processBuilder.redirectOutput(Redirect.appendTo(log.toFile()));
    try {
        processBuilder.start().waitFor();
    } finally {
        Files.delete(forceJar);
        // otherwise jar not made next time if missing again:
        processBuilder.start().waitFor();
    }
}
#method_after
private void buildPluginJar() throws IOException, InterruptedException {
    Path dir = pluginRoot;
    String build;
    if (bazel) {
        dir = GerritLauncher.resolveInSourceRoot(".");
        Properties properties = loadBuildProperties(dir.resolve(".primary_build_tool"));
        build = MoreObjects.firstNonNull(properties.getProperty(BAZELLC), BAZELLC);
    } else {
        Properties properties = loadBuildProperties(gen.resolve(Paths.get("tools/buck/buck.properties")));
        build = MoreObjects.firstNonNull(properties.getProperty(BUCKLC), BUCKLC);
    }
    String target;
    if (standalone) {
        target = "//:" + pluginName;
    } else {
        target = pluginSubPath.toString();
    }
    ProcessBuilder processBuilder = new ProcessBuilder(build, "build", target).directory(dir.toFile()).redirectErrorStream(true);
    Path forceJar = pluginSource.resolve("src/main/java/ForceJarIfMissing.java");
    if (!bazel) {
        // otherwise plugin jar creation fails:
        processBuilder.environment().put("NO_BUCKD", "1");
        // if exists after cancelled test:
        Files.deleteIfExists(forceJar);
        Files.createFile(forceJar);
    }
    testSite = tempSiteDir.getRoot().toPath();
    // otherwise process often hangs:
    Path log = testSite.resolve("log");
    processBuilder.redirectErrorStream(true);
    processBuilder.redirectOutput(Redirect.appendTo(log.toFile()));
    try {
        processBuilder.start().waitFor();
    } finally {
        Files.deleteIfExists(forceJar);
        // otherwise jar not made next time if missing again:
        processBuilder.start().waitFor();
    }
}
#end_block

#method_before
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching;
    if (args.accountIndexes.getSearchIndex() != null) {
        matching = getWatchersFromIndex(type);
    } else {
        matching = getWatchersFromDb(type);
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc);
                } catch (QueryParseException e) {
                    log.warn("Project {} has invalid notify {} filter \"{}\": {}", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage());
                }
            }
        }
    }
    return matching;
}
#method_after
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<>();
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(project)) {
        Account.Id accountId = a.getAccount().getId();
        for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : a.getProjectWatches().entrySet()) {
            if (project.equals(e.getKey().project()) && add(matching, accountId, e.getKey(), e.getValue(), type)) {
                // We only want to prevent matching All-Projects if this filter hits
                projectWatchers.add(accountId);
            }
        }
    }
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(args.allProjectsName)) {
        for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : a.getProjectWatches().entrySet()) {
            if (args.allProjectsName.equals(e.getKey().project())) {
                Account.Id accountId = a.getAccount().getId();
                if (!projectWatchers.contains(accountId)) {
                    add(matching, accountId, e.getKey(), e.getValue(), type);
                }
            }
        }
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc);
                } catch (QueryParseException e) {
                    log.warn("Project {} has invalid notify {} filter \"{}\": {}", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage());
                }
            }
        }
    }
    return matching;
}
#end_block

#method_before
private List<WebLinkInfo> filterWebLinks(DiffView diffView) {
    List<WebLinkInfo> filteredDiffWebLinks = new LinkedList<>();
    List<DiffWebLinkInfo> allDiffWebLinks = Natives.asList(webLinks());
    if (allDiffWebLinks != null) {
        for (DiffWebLinkInfo webLink : allDiffWebLinks) {
            if (diffView == DiffView.SIDE_BY_SIDE && webLink.showOnSideBySideDiffView()) {
                filteredDiffWebLinks.add(webLink);
            }
            if (diffView == DiffView.UNIFIED_DIFF && webLink.showOnUnifiedDiffView()) {
                filteredDiffWebLinks.add(webLink);
            }
        }
    }
    return filteredDiffWebLinks;
}
#method_after
private List<WebLinkInfo> filterWebLinks(DiffView diffView) {
    List<WebLinkInfo> filteredDiffWebLinks = new ArrayList<>();
    List<DiffWebLinkInfo> allDiffWebLinks = Natives.asList(webLinks());
    if (allDiffWebLinks != null) {
        for (DiffWebLinkInfo webLink : allDiffWebLinks) {
            if (diffView == DiffView.SIDE_BY_SIDE && webLink.showOnSideBySideDiffView()) {
                filteredDiffWebLinks.add(webLink);
            }
            if (diffView == DiffView.UNIFIED_DIFF && webLink.showOnUnifiedDiffView()) {
                filteredDiffWebLinks.add(webLink);
            }
        }
    }
    return filteredDiffWebLinks;
}
#end_block

#method_before
private static void execute(OpenRepo or) throws IOException {
    if (or == null || or.cmds.isEmpty()) {
        return;
    }
    or.flush();
    BatchRefUpdate bru = or.repo.getRefDatabase().newBatchUpdate();
    or.cmds.addTo(bru);
    bru.setAllowNonFastForwards(true);
    bru.execute(or.rw, NullProgressMonitor.INSTANCE);
    for (ReceiveCommand cmd : bru.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            throw new IOException("Update failed: " + bru);
        }
    }
}
#method_after
private void execute(OpenRepo or) throws IOException {
    if (or == null || or.cmds.isEmpty()) {
        return;
    }
    or.flush();
    BatchRefUpdate bru = or.repo.getRefDatabase().newBatchUpdate();
    bru.setRefLogMessage(firstNonNull(refLogMessage, "Update NoteDb refs"), false);
    bru.setRefLogIdent(refLogIdent != null ? refLogIdent : serverIdent.get());
    or.cmds.addTo(bru);
    bru.setAllowNonFastForwards(true);
    bru.execute(or.rw, NullProgressMonitor.INSTANCE);
    for (ReceiveCommand cmd : bru.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            throw new IOException("Update failed: " + bru);
        }
    }
}
#end_block

#method_before
private void checkExpectedState() throws OrmException, IOException {
    if (!checkExpectedState) {
        return;
    }
    // that got passed into the ChangeUpdate.
    for (Collection<ChangeUpdate> us : changeUpdates.asMap().values()) {
        ChangeUpdate u = us.iterator().next();
        NoteDbChangeState expectedState = NoteDbChangeState.parse(u.getChange());
        if (expectedState == null) {
            // MismatchedStateException.
            continue;
        }
        if (expectedState.getPrimaryStorage() == PrimaryStorage.NOTE_DB) {
            // NoteDb is primary, no need to compare state to ReviewDb.
            continue;
        }
        if (!expectedState.isChangeUpToDate(changeRepo.cmds.getRepoRefCache())) {
            throw new MismatchedStateException(u.getId(), expectedState);
        }
    }
    for (Collection<ChangeDraftUpdate> us : draftUpdates.asMap().values()) {
        ChangeDraftUpdate u = us.iterator().next();
        NoteDbChangeState expectedState = NoteDbChangeState.parse(u.getChange());
        if (expectedState == null || expectedState.getPrimaryStorage() == PrimaryStorage.NOTE_DB) {
            // See above.
            continue;
        }
        Account.Id accountId = u.getAccountId();
        if (!expectedState.areDraftsUpToDate(allUsersRepo.cmds.getRepoRefCache(), accountId)) {
            throw new OrmConcurrencyException(String.format("cannot apply NoteDb updates for change %s;" + " draft ref for account %s does not match %s", u.getId(), accountId, expectedState.getChangeMetaId().name()));
        }
    }
}
#method_after
private void checkExpectedState() throws OrmException, IOException {
    if (!checkExpectedState) {
        return;
    }
    // that got passed into the ChangeUpdate.
    for (Collection<ChangeUpdate> us : changeUpdates.asMap().values()) {
        ChangeUpdate u = us.iterator().next();
        NoteDbChangeState expectedState = NoteDbChangeState.parse(u.getChange());
        if (expectedState == null) {
            // MismatchedStateException.
            continue;
        }
        if (expectedState.getPrimaryStorage() == PrimaryStorage.NOTE_DB) {
            // NoteDb is primary, no need to compare state to ReviewDb.
            continue;
        }
        if (!expectedState.isChangeUpToDate(changeRepo.cmds.getRepoRefCache())) {
            throw new MismatchedStateException(u.getId(), expectedState);
        }
    }
    for (Collection<ChangeDraftUpdate> us : draftUpdates.asMap().values()) {
        ChangeDraftUpdate u = us.iterator().next();
        NoteDbChangeState expectedState = NoteDbChangeState.parse(u.getChange());
        if (expectedState == null || expectedState.getPrimaryStorage() == PrimaryStorage.NOTE_DB) {
            // See above.
            continue;
        }
        Account.Id accountId = u.getAccountId();
        if (!expectedState.areDraftsUpToDate(allUsersRepo.cmds.getRepoRefCache(), accountId)) {
            ObjectId expectedDraftId = firstNonNull(expectedState.getDraftIds().get(accountId), ObjectId.zeroId());
            throw new OrmConcurrencyException(String.format("cannot apply NoteDb updates for change %s;" + " draft ref for account %s does not match %s", u.getId(), accountId, expectedDraftId.name()));
        }
    }
}
#end_block

#method_before
public BatchUpdate getUpdate() {
    checkState(db != null, "call setContext before getUpdate");
    if (update == null) {
        update = batchUpdateFactory.create(db, getProjectName(), caller, ts).setRepository(repo, rw, ins).setRequestId(submissionId);
    }
    return update;
}
#method_after
public BatchUpdate getUpdate() {
    checkState(db != null, "call setContext before getUpdate");
    if (update == null) {
        update = batchUpdateFactory.create(db, getProjectName(), caller, ts).setRepository(repo, rw, ins).setRequestId(submissionId).setOnSubmitValidators(onSubmitValidatorsFactory.create());
    }
    return update;
}
#end_block

#method_before
private synchronized Repo get(Project.NameKey name) throws RepositoryNotFoundException {
    Repo repo = repos.get(normalize(name));
    if (repo != null) {
        return repo;
    }
    throw new RepositoryNotFoundException(name.get());
}
#method_after
private synchronized Repo get(Project.NameKey name) throws RepositoryNotFoundException {
    Repo repo = repos.get(normalize(name));
    if (repo != null) {
        repo.incrementOpen();
        return repo;
    }
    throw new RepositoryNotFoundException(name.get());
}
#end_block

#method_before
public synchronized void rescan() {
    Multimap<String, Path> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, Path> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, Path> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        Path path = entry.getValue();
        String fileName = path.getFileName().toString();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(path)) {
            log.warn("No Plugin provider was found that handles this file format: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(path.toFile())) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(path)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", active.getName()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, path, active);
            if (!loadedPlugin.isDisabled()) {
                log.info(String.format("%s plugin %s, version %s", active == null ? "Loaded" : "Reloaded", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    SetMultimap<String, Path> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, Path> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, Path> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        Path path = entry.getValue();
        String fileName = path.getFileName().toString();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(path)) {
            log.warn("No Plugin provider was found that handles this file format: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(path.toFile())) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(path)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", active.getName()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, path, active);
            if (!loadedPlugin.isDisabled()) {
                log.info(String.format("%s plugin %s, version %s", active == null ? "Loaded" : "Reloaded", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private void syncDisabledPlugins(Multimap<String, Path> jars) {
    stopRemovedPlugins(jars);
    dropRemovedDisabledPlugins(jars);
}
#method_after
private void syncDisabledPlugins(SetMultimap<String, Path> jars) {
    stopRemovedPlugins(jars);
    dropRemovedDisabledPlugins(jars);
}
#end_block

#method_before
private void stopRemovedPlugins(Multimap<String, Path> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (Map.Entry<String, Collection<Path>> entry : jars.asMap().entrySet()) {
        for (Path path : entry.getValue()) {
            if (!path.getFileName().toString().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#method_after
private void stopRemovedPlugins(SetMultimap<String, Path> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (Map.Entry<String, Collection<Path>> entry : jars.asMap().entrySet()) {
        for (Path path : entry.getValue()) {
            if (!path.getFileName().toString().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#end_block

#method_before
private void dropRemovedDisabledPlugins(Multimap<String, Path> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (Map.Entry<String, Collection<Path>> entry : jars.asMap().entrySet()) {
        for (Path path : entry.getValue()) {
            if (path.getFileName().toString().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#method_after
private void dropRemovedDisabledPlugins(SetMultimap<String, Path> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (Map.Entry<String, Collection<Path>> entry : jars.asMap().entrySet()) {
        for (Path path : entry.getValue()) {
            if (path.getFileName().toString().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#end_block

#method_before
// Only one active plugin per plugin name can exist for each plugin name.
private static Map<String, Path> filterDisabled(Multimap<String, Path> pluginPaths) {
    Map<String, Path> activePlugins = Maps.newHashMapWithExpectedSize(pluginPaths.keys().size());
    for (String name : pluginPaths.keys()) {
        for (Path pluginPath : pluginPaths.asMap().get(name)) {
            if (!pluginPath.getFileName().toString().endsWith(".disabled")) {
                assert !activePlugins.containsKey(name);
                activePlugins.put(name, pluginPath);
            }
        }
    }
    return activePlugins;
}
#method_after
// Only one active plugin per plugin name can exist for each plugin name.
private static Map<String, Path> filterDisabled(SetMultimap<String, Path> pluginPaths) {
    Map<String, Path> activePlugins = Maps.newHashMapWithExpectedSize(pluginPaths.keys().size());
    for (String name : pluginPaths.keys()) {
        for (Path pluginPath : pluginPaths.asMap().get(name)) {
            if (!pluginPath.getFileName().toString().endsWith(".disabled")) {
                assert !activePlugins.containsKey(name);
                activePlugins.put(name, pluginPath);
            }
        }
    }
    return activePlugins;
}
#end_block

#method_before
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name initially assigned from its filename.
// Values are the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
// name are disabled.
// 
// NOTE: Bear in mind that the plugin name can be reassigned after load by the
public Multimap<String, Path> prunePlugins(Path pluginsDir) {
    List<Path> pluginPaths = scanPathsInPluginsDirectory(pluginsDir);
    Multimap<String, Path> map;
    map = asMultimap(pluginPaths);
    for (String plugin : map.keySet()) {
        Collection<Path> files = map.asMap().get(plugin);
        if (files.size() == 1) {
            continue;
        }
        // retrieve enabled plugins
        Iterable<Path> enabled = filterDisabledPlugins(files);
        // If we have only one (the winner) plugin, nothing to do
        if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
            continue;
        }
        Path winner = Iterables.getFirst(enabled, null);
        assert winner != null;
        // Disable all loser plugins by renaming their file names to
        // "file.disabled" and replace the disabled files in the multimap.
        Collection<Path> elementsToRemove = new ArrayList<>();
        Collection<Path> elementsToAdd = new ArrayList<>();
        for (Path loser : Iterables.skip(enabled, 1)) {
            log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
            Path disabledPlugin = Paths.get(loser + ".disabled");
            elementsToAdd.add(disabledPlugin);
            elementsToRemove.add(loser);
            try {
                Files.move(loser, disabledPlugin);
            } catch (IOException e) {
                log.warn("Failed to fully disable plugin " + loser, e);
            }
        }
        Iterables.removeAll(files, elementsToRemove);
        Iterables.addAll(files, elementsToAdd);
    }
    return map;
}
#method_after
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name initially assigned from its filename.
// Values are the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
// name are disabled.
// 
// NOTE: Bear in mind that the plugin name can be reassigned after load by the
public SetMultimap<String, Path> prunePlugins(Path pluginsDir) {
    List<Path> pluginPaths = scanPathsInPluginsDirectory(pluginsDir);
    SetMultimap<String, Path> map;
    map = asMultimap(pluginPaths);
    for (String plugin : map.keySet()) {
        Collection<Path> files = map.asMap().get(plugin);
        if (files.size() == 1) {
            continue;
        }
        // retrieve enabled plugins
        Iterable<Path> enabled = filterDisabledPlugins(files);
        // If we have only one (the winner) plugin, nothing to do
        if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
            continue;
        }
        Path winner = Iterables.getFirst(enabled, null);
        assert winner != null;
        // Disable all loser plugins by renaming their file names to
        // "file.disabled" and replace the disabled files in the multimap.
        Collection<Path> elementsToRemove = new ArrayList<>();
        Collection<Path> elementsToAdd = new ArrayList<>();
        for (Path loser : Iterables.skip(enabled, 1)) {
            log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
            Path disabledPlugin = Paths.get(loser + ".disabled");
            elementsToAdd.add(disabledPlugin);
            elementsToRemove.add(loser);
            try {
                Files.move(loser, disabledPlugin);
            } catch (IOException e) {
                log.warn("Failed to fully disable plugin " + loser, e);
            }
        }
        Iterables.removeAll(files, elementsToRemove);
        Iterables.addAll(files, elementsToAdd);
    }
    return map;
}
#end_block

#method_before
private Multimap<String, Path> asMultimap(List<Path> plugins) {
    Multimap<String, Path> map = LinkedHashMultimap.create();
    for (Path srcPath : plugins) {
        map.put(getPluginName(srcPath), srcPath);
    }
    return map;
}
#method_after
private SetMultimap<String, Path> asMultimap(List<Path> plugins) {
    SetMultimap<String, Path> map = LinkedHashMultimap.create();
    for (Path srcPath : plugins) {
        map.put(getPluginName(srcPath), srcPath);
    }
    return map;
}
#end_block

#method_before
private <T> QueryBuilder notTimestamp(TimestampRangePredicate<T> r) throws QueryParseException {
    if (r.getMinTimestamp().getTime() == 0) {
        return QueryBuilders.rangeQuery(r.getField().getName()).gt(new DateTime(r.getMaxTimestamp().getTime()));
    }
    throw new QueryParseException("cannot negate: " + r);
}
#method_after
private <T> QueryBuilder notTimestamp(TimestampRangePredicate<T> r) throws QueryParseException {
    if (r.getMinTimestamp().getTime() == 0) {
        return QueryBuilders.rangeQuery(r.getField().getName()).gt(Instant.ofEpochMilli(r.getMaxTimestamp().getTime()));
    }
    throw new QueryParseException("cannot negate: " + r);
}
#end_block

#method_before
private <T> QueryBuilder timestampQuery(IndexPredicate<T> p) throws QueryParseException {
    if (p instanceof TimestampRangePredicate) {
        TimestampRangePredicate<T> r = (TimestampRangePredicate<T>) p;
        if (p instanceof AfterPredicate) {
            return QueryBuilders.rangeQuery(r.getField().getName()).gte(new DateTime(r.getMinTimestamp().getTime()));
        }
        return QueryBuilders.rangeQuery(r.getField().getName()).gte(new DateTime(r.getMinTimestamp().getTime())).lte(new DateTime(r.getMaxTimestamp().getTime()));
    }
    throw new QueryParseException("not a timestamp: " + p);
}
#method_after
private <T> QueryBuilder timestampQuery(IndexPredicate<T> p) throws QueryParseException {
    if (p instanceof TimestampRangePredicate) {
        TimestampRangePredicate<T> r = (TimestampRangePredicate<T>) p;
        if (p instanceof AfterPredicate) {
            return QueryBuilders.rangeQuery(r.getField().getName()).gte(Instant.ofEpochMilli(r.getMinTimestamp().getTime()));
        }
        return QueryBuilders.rangeQuery(r.getField().getName()).gte(Instant.ofEpochMilli(r.getMinTimestamp().getTime())).lte(Instant.ofEpochMilli(r.getMaxTimestamp().getTime()));
    }
    throw new QueryParseException("not a timestamp: " + p);
}
#end_block

#method_before
private List<ChangeControl> changeFromNotesFactory(String id, CurrentUser currentUser) throws OrmException {
    return changeNotesFactory.create(db, Arrays.asList(Change.Id.parse(id))).stream().map(changeNote -> controlForChange(changeNote, currentUser)).filter(changeControl -> changeControl.isPresent()).map(changeControl -> changeControl.get()).collect(toList());
}
#method_after
private List<ChangeControl> changeFromNotesFactory(String id, CurrentUser currentUser) throws OrmException, UnloggedFailure {
    return changeNotesFactory.create(db, parseId(id)).stream().map(changeNote -> controlForChange(changeNote, currentUser)).filter(changeControl -> changeControl.isPresent()).map(changeControl -> changeControl.get()).collect(toList());
}
#end_block

#method_before
@Override
public ProjectApi create() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ProjectApi create() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ProjectApi create(ProjectInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ProjectApi create(ProjectInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ProjectInfo get() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ProjectInfo get() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public String description() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public String description() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ProjectAccessInfo access() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ProjectAccessInfo access() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ConfigInfo config() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ConfigInfo config() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ConfigInfo config(ConfigInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ConfigInfo config(ConfigInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ProjectAccessInfo access(ProjectAccessInput p) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ProjectAccessInfo access(ProjectAccessInput p) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void description(DescriptionInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void description(DescriptionInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<ProjectInfo> children(boolean recursive) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<ProjectInfo> children(boolean recursive) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChildProjectApi child(String name) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ChildProjectApi child(String name) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BranchApi branch(String ref) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public BranchApi branch(String ref) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public TagApi tag(String ref) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public TagApi tag(String ref) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void deleteBranches(DeleteBranchesInput in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void deleteBranches(DeleteBranchesInput in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Test
public void suggestReviewersChange() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, name("u"), 6);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, name("u"), 5);
    assertThat(reviewers).hasSize(5);
    reviewers = suggestReviewers(changeId, group3.getName(), 10);
    assertThat(reviewers).hasSize(1);
}
#method_after
@Test
public void suggestReviewersChange() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, name("u"), 6);
    assertReviewers(reviewers, ImmutableList.of(user1, user2, user3), ImmutableList.of(group1, group2, group3));
    reviewers = suggestReviewers(changeId, name("u"), 5);
    assertReviewers(reviewers, ImmutableList.of(user1, user2, user3), ImmutableList.of(group1, group2));
    reviewers = suggestReviewers(changeId, group3.getName(), 10);
    assertReviewers(reviewers, ImmutableList.of(), ImmutableList.of(group3));
    // Suggested accounts are ordered by activity. All users have no activity,
    // hence we don't know which of the matching accounts we get when the query
    // is limited to 1.
    reviewers = suggestReviewers(changeId, name("u"), 1);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.get(0).account).isNotNull();
    assertThat(ImmutableList.of(reviewers.get(0).account._accountId)).containsAnyIn(ImmutableList.of(user1, user2, user3).stream().map(u -> u.id.get()).collect(toList()));
}
#end_block

#method_before
@Test
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "first", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "last", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi la", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "la fi", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1 la", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "first1 last2", 1);
    assertThat(reviewers).hasSize(0);
    reviewers = suggestReviewers(changeId, name("user"), 7);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, user1.username, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "example.com", 7);
    assertThat(reviewers).hasSize(5);
    reviewers = suggestReviewers(changeId, user1.email, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user1.username + " example", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user4.email.toLowerCase(), 2);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.get(0).account.email).isEqualTo(user4.email);
}
#method_after
@Test
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "first");
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1");
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "last");
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "last1");
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi la");
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "la fi");
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1 la");
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi last1");
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "first1 last2");
    assertThat(reviewers).isEmpty();
    reviewers = suggestReviewers(changeId, name("user"));
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, user1.username);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "example.com");
    assertThat(reviewers).hasSize(5);
    reviewers = suggestReviewers(changeId, user1.email);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user1.username + " example");
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user4.email.toLowerCase());
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.get(0).account.email).isEqualTo(user4.email);
}
#end_block

#method_before
private List<SuggestedReviewerInfo> suggestReviewers(String changeId, String query, int n) throws Exception {
    return gApi.changes().id(changeId).suggestReviewers(query).withLimit(n).get();
}
#method_after
private List<SuggestedReviewerInfo> suggestReviewers(String changeId, String query) throws Exception {
    return gApi.changes().id(changeId).suggestReviewers(query).get();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(PluginUser.class).toInstance(plugin.getPluginUser());
    bind(String.class).annotatedWith(PluginName.class).toInstance(plugin.getName());
    bind(String.class).annotatedWith(PluginCanonicalWebUrl.class).toInstance(plugin.getPluginCanonicalWebUrl());
    install(new LifecycleModule() {

        @Override
        public void configure() {
            PluginMetricMaker metrics = new PluginMetricMaker(serverMetrics, plugin.getName());
            bind(MetricMaker.class).toInstance(metrics);
            listener().toInstance(metrics);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(PluginUser.class).toInstance(plugin.getPluginUser());
    bind(String.class).annotatedWith(PluginName.class).toInstance(plugin.getName());
    bind(String.class).annotatedWith(PluginCanonicalWebUrl.class).toInstance(plugin.getPluginCanonicalWebUrl());
    install(new LifecycleModule() {

        @Override
        public void configure() {
            PluginMetricMaker metrics = new PluginMetricMaker(serverMetrics, MoreObjects.firstNonNull(plugin.getMetricsPrefix(), String.format("plugins/%s/", plugin.getName())));
            bind(MetricMaker.class).toInstance(metrics);
            listener().toInstance(metrics);
        }
    });
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw die("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw die("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("abandon and delete actions are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("abandon and rebase actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw die("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("publish and delete actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw die("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("json and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("json and delete actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw die("json and publish actions are mutually exclusive");
        }
        if (abandonChange) {
            throw die("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw die("json and message are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("json and rebase actions are mutually exclusive");
        }
        if (changeTag != null) {
            throw die("json and tag actions are mutually exclusive");
        }
    }
    if (rebaseChange) {
        if (deleteDraftPatchSet) {
            throw die("rebase and delete actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("rebase and submit actions are mutually exclusive");
        }
    }
    if (deleteDraftPatchSet && submitChange) {
        throw die("delete and submit actions are mutually exclusive");
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error", e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("error", "no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal", "internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw die("one or more reviews failed; review output above");
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw die("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw die("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("abandon and delete actions are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("abandon and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("abandon and move actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw die("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("publish and delete actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw die("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("json and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("json and delete actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw die("json and publish actions are mutually exclusive");
        }
        if (abandonChange) {
            throw die("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw die("json and message are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("json and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("json and move actions are mutually exclusive");
        }
        if (changeTag != null) {
            throw die("json and tag actions are mutually exclusive");
        }
    }
    if (rebaseChange) {
        if (deleteDraftPatchSet) {
            throw die("rebase and delete actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("rebase and submit actions are mutually exclusive");
        }
    }
    if (deleteDraftPatchSet && submitChange) {
        throw die("delete and submit actions are mutually exclusive");
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error", e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("error", "no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal", "internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw die("one or more reviews failed; review output above");
    }
}
#end_block

#method_before
private void reviewPatchSet(final PatchSet patchSet) throws Exception {
    if (notify == null) {
        notify = NotifyHandling.ALL;
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.tag = Strings.emptyToNull(changeTag);
    review.notify = notify;
    review.labels = new TreeMap<>();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = strictLabels;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // We don't need to add the review comment when abandoning/restoring.
    if (abandonChange || restoreChange) {
        review.message = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = Strings.emptyToNull(changeComment);
            applyReview(patchSet, review);
            changeApi(patchSet).abandon(input);
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).restore(input);
            applyReview(patchSet, review);
        } else {
            applyReview(patchSet, review);
        }
        if (rebaseChange) {
            revisionApi(patchSet).rebase();
        }
        if (submitChange) {
            revisionApi(patchSet).submit();
        }
        if (publishPatchSet) {
            revisionApi(patchSet).publish();
        } else if (deleteDraftPatchSet) {
            revisionApi(patchSet).delete();
        }
    } catch (IllegalStateException | RestApiException e) {
        throw die(e);
    }
}
#method_after
private void reviewPatchSet(final PatchSet patchSet) throws Exception {
    if (notify == null) {
        notify = NotifyHandling.ALL;
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.tag = Strings.emptyToNull(changeTag);
    review.notify = notify;
    review.labels = new TreeMap<>();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = strictLabels;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // We don't need to add the review comment when abandoning/restoring.
    if (abandonChange || restoreChange || moveToBranch != null) {
        review.message = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = Strings.emptyToNull(changeComment);
            applyReview(patchSet, review);
            changeApi(patchSet).abandon(input);
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).restore(input);
            applyReview(patchSet, review);
        } else {
            applyReview(patchSet, review);
        }
        if (moveToBranch != null) {
            MoveInput moveInput = new MoveInput();
            moveInput.destinationBranch = moveToBranch;
            moveInput.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).move(moveInput);
        }
        if (rebaseChange) {
            revisionApi(patchSet).rebase();
        }
        if (submitChange) {
            revisionApi(patchSet).submit();
        }
        if (publishPatchSet) {
            revisionApi(patchSet).publish();
        } else if (deleteDraftPatchSet) {
            revisionApi(patchSet).delete();
        }
    } catch (IllegalStateException | RestApiException e) {
        throw die(e);
    }
}
#end_block

#method_before
@Test
public void rebase() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    String changeId = r2.getChangeId();
    // Rebase the second change
    gApi.changes().id(changeId).current().rebase();
    // Second change should have 2 patch sets
    ChangeInfo c2 = gApi.changes().id(changeId).get();
    assertThat(c2.revisions.get(c2.currentRevision)._number).isEqualTo(2);
    // ...and the committer should be correct
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT));
    GitPerson committer = info.revisions.get(info.currentRevision).commit.committer;
    assertThat(committer.name).isEqualTo(admin.fullName);
    assertThat(committer.email).isEqualTo(admin.email);
    // Rebasing the second change again should fail
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already up to date");
    gApi.changes().id(changeId).current().rebase();
}
#method_after
@Test
public void rebase() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    String changeId = r2.getChangeId();
    // Rebase the second change
    gApi.changes().id(changeId).current().rebase();
    // Second change should have 2 patch sets
    ChangeInfo c2 = gApi.changes().id(changeId).get();
    assertThat(c2.revisions.get(c2.currentRevision)._number).isEqualTo(2);
    // ...and the committer and description should be correct
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT));
    GitPerson committer = info.revisions.get(info.currentRevision).commit.committer;
    assertThat(committer.name).isEqualTo(admin.fullName);
    assertThat(committer.email).isEqualTo(admin.email);
    String description = info.revisions.get(info.currentRevision).description;
    assertThat(description).isEqualTo("Rebase");
    // Rebasing the second change again should fail
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already up to date");
    gApi.changes().id(changeId).current().rebase();
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded a new change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#method_after
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#end_block

#method_before
@Test
public void addReviewerWithNoteDbWhenDummyApprovalInReviewDbExists() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    PushOneCommit.Result r = createChange();
    // insert dummy approval in ReviewDb
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(r.getPatchSetId(), user.id, new LabelId("Code-Review")), (short) 0, TimeUtil.nowTs());
    db.patchSetApprovals().insert(Collections.singleton(psa));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
}
#method_after
@Test
public void addReviewerWithNoteDbWhenDummyApprovalInReviewDbExists() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    assume().that(notesMigration.changePrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
    PushOneCommit.Result r = createChange();
    // insert dummy approval in ReviewDb
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(r.getPatchSetId(), user.id, new LabelId("Code-Review")), (short) 0, TimeUtil.nowTs());
    db.patchSetApprovals().insert(Collections.singleton(psa));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
}
#end_block

#method_before
@Test
public void removeReviewerNoVotes() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(Util.verified().getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).addReviewer(user.getId().toString());
    // ReviewerState will vary between ReviewDb and NoteDb; we just care that it
    // shows up somewhere.
    Iterable<AccountInfo> reviewers = Iterables.concat(gApi.changes().id(changeId).get().reviewers.values());
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    sender.clear();
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove();
    assertThat(gApi.changes().id(changeId).get().reviewers).isEmpty();
    assertThat(sender.getMessages()).hasSize(1);
    Message message = sender.getMessages().get(0);
    assertThat(message.body()).contains("Removed reviewer " + user.fullName + ".");
    assertThat(message.body()).doesNotContain("with the following votes");
    // Make sure the reviewer can still be added again.
    gApi.changes().id(changeId).addReviewer(user.getId().toString());
    reviewers = Iterables.concat(gApi.changes().id(changeId).get().reviewers.values());
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Remove again, and then try to remove once more to verify 404 is
    // returned.
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove();
    exception.expect(ResourceNotFoundException.class);
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove();
}
#method_after
@Test
public void removeReviewerNoVotes() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(Util.verified().getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).addReviewer(user.getId().toString());
    // ReviewerState will vary between ReviewDb and NoteDb; we just care that it
    // shows up somewhere.
    Iterable<AccountInfo> reviewers = Iterables.concat(gApi.changes().id(changeId).get().reviewers.values());
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    sender.clear();
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove();
    assertThat(gApi.changes().id(changeId).get().reviewers).isEmpty();
    assertThat(sender.getMessages()).hasSize(1);
    Message message = sender.getMessages().get(0);
    assertThat(message.body()).contains("Removed reviewer " + user.fullName + ".");
    assertThat(message.body()).doesNotContain("with the following votes");
    // Make sure the reviewer can still be added again.
    gApi.changes().id(changeId).addReviewer(user.getId().toString());
    reviewers = Iterables.concat(gApi.changes().id(changeId).get().reviewers.values());
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Remove again, and then try to remove once more to verify 404 is
    // returned.
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove();
    exception.expect(ResourceNotFoundException.class);
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove();
}
#end_block

#method_before
private void testRemoveReviewer(boolean notify) throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.recommend());
    Collection<AccountInfo> reviewers = gApi.changes().id(changeId).get().reviewers.get(REVIEWER);
    assertThat(reviewers).hasSize(2);
    Iterator<AccountInfo> reviewerIt = reviewers.iterator();
    assertThat(reviewerIt.next()._accountId).isEqualTo(admin.getId().get());
    assertThat(reviewerIt.next()._accountId).isEqualTo(user.getId().get());
    sender.clear();
    setApiUser(admin);
    DeleteReviewerInput input = new DeleteReviewerInput();
    if (!notify) {
        input.notify = NotifyHandling.NONE;
    }
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove(input);
    if (notify) {
        assertThat(sender.getMessages()).hasSize(1);
        Message message = sender.getMessages().get(0);
        assertThat(message.body()).contains("Removed reviewer " + user.fullName + " with the following votes");
        assertThat(message.body()).contains("* Code-Review+1 by " + user.fullName);
    } else {
        assertThat(sender.getMessages()).hasSize(0);
    }
    reviewers = gApi.changes().id(changeId).get().reviewers.get(REVIEWER);
    assertThat(reviewers).hasSize(1);
    reviewerIt = reviewers.iterator();
    assertThat(reviewerIt.next()._accountId).isEqualTo(admin.getId().get());
    eventRecorder.assertReviewerDeletedEvents(changeId, user.email);
}
#method_after
private void testRemoveReviewer(boolean notify) throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.recommend());
    Collection<AccountInfo> reviewers = gApi.changes().id(changeId).get().reviewers.get(REVIEWER);
    assertThat(reviewers).hasSize(2);
    Iterator<AccountInfo> reviewerIt = reviewers.iterator();
    assertThat(reviewerIt.next()._accountId).isEqualTo(admin.getId().get());
    assertThat(reviewerIt.next()._accountId).isEqualTo(user.getId().get());
    sender.clear();
    setApiUser(admin);
    DeleteReviewerInput input = new DeleteReviewerInput();
    if (!notify) {
        input.notify = NotifyHandling.NONE;
    }
    gApi.changes().id(changeId).reviewer(user.getId().toString()).remove(input);
    if (notify) {
        assertThat(sender.getMessages()).hasSize(1);
        Message message = sender.getMessages().get(0);
        assertThat(message.body()).contains("Removed reviewer " + user.fullName + " with the following votes");
        assertThat(message.body()).contains("* Code-Review+1 by " + user.fullName);
    } else {
        assertThat(sender.getMessages()).isEmpty();
    }
    reviewers = gApi.changes().id(changeId).get().reviewers.get(REVIEWER);
    assertThat(reviewers).hasSize(1);
    reviewerIt = reviewers.iterator();
    assertThat(reviewerIt.next()._accountId).isEqualTo(admin.getId().get());
    eventRecorder.assertReviewerDeletedEvents(changeId, user.email);
}
#end_block

#method_before
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    setApiUser(admin);
    sender.clear();
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">" + "\n");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    // Dummy 0 approval on the change to block vote copying to this patch set.
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#method_after
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">" + "\n");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    // Dummy 0 approval on the change to block vote copying to this patch set.
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#end_block

#method_before
@Test
public void deleteVoteNotifyNone() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    setApiUser(admin);
    sender.clear();
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertThat(sender.getMessages()).hasSize(0);
}
#method_after
@Test
public void deleteVoteNotifyNone() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void nonVotingReviewerStaysAfterSubmit() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    String heads = "refs/heads/*";
    AccountGroup.UUID owners = SystemGroupBackend.getGroup(CHANGE_OWNER).getUUID();
    AccountGroup.UUID registered = SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, owners, heads);
    Util.allow(cfg, Permission.forLabel("Code-Review"), -2, +2, registered, heads);
    saveProjectConfig(project, cfg);
    // Set Code-Review+2 and Verified+1 as admin (change owner)
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String commit = r.getCommit().name();
    ReviewInput input = ReviewInput.approve();
    input.label(verified.getName(), 1);
    gApi.changes().id(changeId).revision(commit).review(input);
    // Reviewers should only be "admin"
    ChangeInfo c = gApi.changes().id(changeId).get();
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    assertThat(c.reviewers.get(CC)).isNull();
    // Add the user as reviewer
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(changeId).addReviewer(in);
    c = gApi.changes().id(changeId).get();
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    // Approve the change as user, then remove the approval
    // (only to confirm that the user does have Code-Review+2 permission)
    setApiUser(user);
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.approve());
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.noScore());
    // Submit the change
    setApiUser(admin);
    gApi.changes().id(changeId).revision(commit).submit();
    // User should still be on the change
    c = gApi.changes().id(changeId).get();
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#method_after
@Test
public void nonVotingReviewerStaysAfterSubmit() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    String heads = "refs/heads/*";
    AccountGroup.UUID owners = systemGroupBackend.getGroup(CHANGE_OWNER).getUUID();
    AccountGroup.UUID registered = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, owners, heads);
    Util.allow(cfg, Permission.forLabel("Code-Review"), -2, +2, registered, heads);
    saveProjectConfig(project, cfg);
    // Set Code-Review+2 and Verified+1 as admin (change owner)
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String commit = r.getCommit().name();
    ReviewInput input = ReviewInput.approve();
    input.label(verified.getName(), 1);
    gApi.changes().id(changeId).revision(commit).review(input);
    // Reviewers should only be "admin"
    ChangeInfo c = gApi.changes().id(changeId).get();
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    assertThat(c.reviewers.get(CC)).isNull();
    // Add the user as reviewer
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(changeId).addReviewer(in);
    c = gApi.changes().id(changeId).get();
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    // Approve the change as user, then remove the approval
    // (only to confirm that the user does have Code-Review+2 permission)
    setApiUser(user);
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.approve());
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.noScore());
    // Submit the change
    setApiUser(admin);
    gApi.changes().id(changeId).revision(commit).submit();
    // User should still be on the change
    c = gApi.changes().id(changeId).get();
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#end_block

#method_before
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), custom1);
    cfg.getLabelSections().put(custom2.getName(), custom2);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(options);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), custom1);
    cfg.getLabelSections().put(custom2.getName(), custom2);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(options);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
@Test
public void checkLabelsForOpenChange() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.NEW);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    // add an approval on the new label
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
}
#method_after
@Test
public void checkLabelsForOpenChange() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.NEW);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", -2, -1, 0, 1, 2);
    assertPermitted(change, "Verified", -1, 0, 1);
    // add an approval on the new label
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
}
#end_block

#method_before
@Test
public void checkLabelsForMergedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    // ignore the new label by Prolog submit rule and assert that the label is
    // no longer returned
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Ignore Verified", "rules.pl", "submit_rule(submit(CR)) :-\n" + "  gerrit:max_with_block(-2, 2, 'Code-Review', CR).");
    push2.to(RefNames.REFS_CONFIG);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    // add an approval on the new label and assert that the label is now
    // returned although it is ignored by the Prolog submit rule and hence not
    // included in the submit records
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
}
#method_after
@Test
public void checkLabelsForMergedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified", 0, 1);
    // ignore the new label by Prolog submit rule and assert that the label is
    // no longer returned
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Ignore Verified", "rules.pl", "submit_rule(submit(CR)) :-\n" + "  gerrit:max_with_block(-2, 2, 'Code-Review', CR).");
    push2.to(RefNames.REFS_CONFIG);
    change = gApi.changes().id(r.getChangeId()).get();
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // add an approval on the new label and assert that the label is now
    // returned although it is ignored by the Prolog submit rule and hence not
    // included in the submit records
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
}
#end_block

#method_before
@Test
public void checkLabelsForAutoClosedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/heads/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
}
#method_after
@Test
public void checkLabelsForAutoClosedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/heads/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 0, 1, 2);
}
#end_block

#method_before
private ServerPlugin loadJarPlugin(String name, Path srcJar, FileSnapshot snapshot, Path tmp, PluginDescription description) throws IOException, InvalidPluginException, MalformedURLException {
    JarFile jarFile = new JarFile(tmp.toFile());
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            Path classes = Paths.get(overlay).resolve(name).resolve("main");
            if (Files.isDirectory(classes)) {
                log.info(String.format("plugin %s: including %s", name, classes));
                urls.add(classes.toUri().toURL());
            }
        }
        urls.add(tmp.toUri().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), PluginLoader.parentFor(type));
        JarScanner jarScanner = createJarScanner(tmp);
        ServerPlugin plugin = new ServerPlugin(name, description.canonicalUrl, description.user, srcJar, snapshot, jarScanner, description.dataDir, pluginLoader);
        plugin.setCleanupHandle(new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private ServerPlugin loadJarPlugin(String name, Path srcJar, FileSnapshot snapshot, Path tmp, PluginDescription description) throws IOException, InvalidPluginException, MalformedURLException {
    JarFile jarFile = new JarFile(tmp.toFile());
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            Path classes = Paths.get(overlay).resolve(name).resolve("main");
            if (Files.isDirectory(classes)) {
                log.info(String.format("plugin %s: including %s", name, classes));
                urls.add(classes.toUri().toURL());
            }
        }
        urls.add(tmp.toUri().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), PluginLoader.parentFor(type));
        JarScanner jarScanner = createJarScanner(tmp);
        PluginConfig pluginConfig = configFactory.getFromGerritConfig(name);
        ServerPlugin plugin = new ServerPlugin(name, description.canonicalUrl, description.user, srcJar, snapshot, jarScanner, description.dataDir, pluginLoader, pluginConfig.getString("metricsPrefix", null));
        plugin.setCleanupHandle(new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
public List<ChangeData> byProjectCommit(Project.NameKey project, String hash) throws OrmException {
    return query(and(project(project), commit(hash)));
}
#method_after
public List<ChangeData> byProjectCommit(Project.NameKey project, ObjectId id) throws OrmException {
    return byProjectCommit(project, id.name());
}
#end_block

#method_before
public Set<Account.Id> findAllByNameOrEmail(ReviewDb db, String nameOrEmail) throws OrmException {
    int lt = nameOrEmail.indexOf('<');
    int gt = nameOrEmail.indexOf('>');
    if (lt >= 0 && gt > lt && nameOrEmail.contains("@")) {
        Set<Account.Id> ids = byEmail.get(nameOrEmail.substring(lt + 1, gt));
        if (ids.isEmpty() || ids.size() == 1) {
            return ids;
        }
        // more than one match, try to return the best one
        String name = nameOrEmail.substring(0, lt - 1);
        Set<Account.Id> nameMatches = new HashSet<>();
        for (Account.Id id : ids) {
            Account a = byId.get(id).getAccount();
            if (name.equals(a.getFullName())) {
                nameMatches.add(id);
            }
        }
        return nameMatches.isEmpty() ? ids : nameMatches;
    }
    if (nameOrEmail.contains("@")) {
        return byEmail.get(nameOrEmail);
    }
    Account.Id id = realm.lookup(nameOrEmail);
    if (id != null) {
        return Collections.singleton(id);
    }
    if (accountIndexes.getSearchIndex() != null) {
        List<AccountState> m = accountQueryProvider.get().byFullName(nameOrEmail);
        if (m.size() == 1) {
            return Collections.singleton(m.get(0).getAccount().getId());
        }
        // and pray we come up with a reasonable result list.
        return accountQueryProvider.get().byDefault(nameOrEmail).stream().map(a -> a.getAccount().getId()).collect(toSet());
    }
    List<Account> m = db.accounts().byFullName(nameOrEmail).toList();
    if (m.size() == 1) {
        return Collections.singleton(m.get(0).getId());
    }
    // At this point we have no clue. Just perform a whole bunch of suggestions
    // and pray we come up with a reasonable result list.
    Set<Account.Id> result = new HashSet<>();
    String a = nameOrEmail;
    String b = nameOrEmail + "\u9fa5";
    for (Account act : db.accounts().suggestByFullName(a, b, 10)) {
        result.add(act.getId());
    }
    for (AccountExternalId extId : db.accountExternalIds().suggestByKey(new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, a), new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, b), 10)) {
        result.add(extId.getAccountId());
    }
    for (AccountExternalId extId : db.accountExternalIds().suggestByEmailAddress(a, b, 10)) {
        result.add(extId.getAccountId());
    }
    return result;
}
#method_after
public Set<Account.Id> findAllByNameOrEmail(ReviewDb db, String nameOrEmail) throws OrmException {
    int lt = nameOrEmail.indexOf('<');
    int gt = nameOrEmail.indexOf('>');
    if (lt >= 0 && gt > lt && nameOrEmail.contains("@")) {
        Set<Account.Id> ids = byEmail.get(nameOrEmail.substring(lt + 1, gt));
        if (ids.isEmpty() || ids.size() == 1) {
            return ids;
        }
        // more than one match, try to return the best one
        String name = nameOrEmail.substring(0, lt - 1);
        Set<Account.Id> nameMatches = new HashSet<>();
        for (Account.Id id : ids) {
            Account a = byId.get(id).getAccount();
            if (name.equals(a.getFullName())) {
                nameMatches.add(id);
            }
        }
        return nameMatches.isEmpty() ? ids : nameMatches;
    }
    if (nameOrEmail.contains("@")) {
        return byEmail.get(nameOrEmail);
    }
    Account.Id id = realm.lookup(nameOrEmail);
    if (id != null) {
        return Collections.singleton(id);
    }
    List<AccountState> m = accountQueryProvider.get().byFullName(nameOrEmail);
    if (m.size() == 1) {
        return Collections.singleton(m.get(0).getAccount().getId());
    }
    // and pray we come up with a reasonable result list.
    return accountQueryProvider.get().byDefault(nameOrEmail).stream().map(a -> a.getAccount().getId()).collect(toSet());
}
#end_block

#method_before
@Override
public BinaryResult content() throws RestApiException {
    try {
        return getContent.apply(file);
    } catch (NoSuchChangeException | IOException | OrmException e) {
        throw new RestApiException("Cannot retrieve file content", e);
    }
}
#method_after
@Override
public BinaryResult content() throws RestApiException {
    try {
        return getContent.apply(file);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot retrieve file content", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo get() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountInfo get() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public boolean getActive() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public boolean getActive() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void setActive(boolean active) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void setActive(boolean active) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public String getAvatarUrl(int size) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public String getAvatarUrl(int size) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public GeneralPreferencesInfo getPreferences() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public GeneralPreferencesInfo getPreferences() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public GeneralPreferencesInfo setPreferences(GeneralPreferencesInfo in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public GeneralPreferencesInfo setPreferences(GeneralPreferencesInfo in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DiffPreferencesInfo getDiffPreferences() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public DiffPreferencesInfo getDiffPreferences() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DiffPreferencesInfo setDiffPreferences(DiffPreferencesInfo in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public DiffPreferencesInfo setDiffPreferences(DiffPreferencesInfo in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public EditPreferencesInfo getEditPreferences() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public EditPreferencesInfo getEditPreferences() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public EditPreferencesInfo setEditPreferences(EditPreferencesInfo in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public EditPreferencesInfo setEditPreferences(EditPreferencesInfo in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<ProjectWatchInfo> getWatchedProjects() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<ProjectWatchInfo> getWatchedProjects() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<ProjectWatchInfo> setWatchedProjects(List<ProjectWatchInfo> in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<ProjectWatchInfo> setWatchedProjects(List<ProjectWatchInfo> in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void deleteWatchedProjects(List<ProjectWatchInfo> in) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void deleteWatchedProjects(List<ProjectWatchInfo> in) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void starChange(String changeId) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void starChange(String changeId) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void unstarChange(String changeId) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void unstarChange(String changeId) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void setStars(String changeId, StarsInput input) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void setStars(String changeId, StarsInput input) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SortedSet<String> getStars(String changeId) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SortedSet<String> getStars(String changeId) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<ChangeInfo> getStarredChanges() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<ChangeInfo> getStarredChanges() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void addEmail(EmailInput input) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void addEmail(EmailInput input) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<SshKeyInfo> listSshKeys() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<SshKeyInfo> listSshKeys() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SshKeyInfo addSshKey(String key) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SshKeyInfo addSshKey(String key) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void deleteSshKey(int seq) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void deleteSshKey(int seq) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, GpgKeyInfo> putGpgKeys(List<String> add, List<String> remove) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, GpgKeyInfo> putGpgKeys(List<String> add, List<String> remove) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public GpgKeyApi gpgKey(String id) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public GpgKeyApi gpgKey(String id) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, GpgKeyInfo> listGpgKeys() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, GpgKeyInfo> listGpgKeys() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<AgreementInfo> listAgreements() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<AgreementInfo> listAgreements() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void signAgreement(String agreementName) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void signAgreement(String agreementName) {
    throw new NotImplementedException();
}
#end_block

#method_before
public List<CodeReviewCommit> reduceToMinimalMerge(MergeSorter mergeSorter, Collection<CodeReviewCommit> toSort) throws IntegrationException {
    List<CodeReviewCommit> result = new ArrayList<>();
    try {
        result.addAll(mergeSorter.sort(toSort));
    } catch (IOException e) {
        throw new IntegrationException("Branch head sorting failed", e);
    }
    Collections.sort(result, CodeReviewCommit.ORDER);
    return result;
}
#method_after
public List<CodeReviewCommit> reduceToMinimalMerge(MergeSorter mergeSorter, Collection<CodeReviewCommit> toSort, Set<CodeReviewCommit> incoming) throws IntegrationException {
    List<CodeReviewCommit> result = new ArrayList<>();
    try {
        result.addAll(mergeSorter.sort(toSort, incoming));
    } catch (IOException e) {
        throw new IntegrationException("Branch head sorting failed", e);
    }
    Collections.sort(result, CodeReviewCommit.ORDER);
    return result;
}
#end_block

#method_before
public CodeReviewCommit createCherryPickFromCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, PersonIdent cherryPickCommitterIdent, String commitMsg, CodeReviewRevWalk rw, int parentIndex) throws MissingObjectException, IncorrectObjectTypeException, IOException, MergeIdenticalTreeException, MergeConflictException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter);
    m.setBase(originalCommit.getParent(parentIndex));
    if (m.merge(mergeTip, originalCommit)) {
        ObjectId tree = m.getResultTreeId();
        if (tree.equals(mergeTip.getTree())) {
            throw new MergeIdenticalTreeException("identical tree");
        }
        CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(tree);
        mergeCommit.setParentId(mergeTip);
        mergeCommit.setAuthor(originalCommit.getAuthorIdent());
        mergeCommit.setCommitter(cherryPickCommitterIdent);
        mergeCommit.setMessage(commitMsg);
        return rw.parseCommit(inserter.insert(mergeCommit));
    }
    throw new MergeConflictException("merge conflict");
}
#method_after
public CodeReviewCommit createCherryPickFromCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, PersonIdent cherryPickCommitterIdent, String commitMsg, CodeReviewRevWalk rw, int parentIndex, boolean ignoreIdenticalTree) throws MissingObjectException, IncorrectObjectTypeException, IOException, MergeIdenticalTreeException, MergeConflictException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter);
    m.setBase(originalCommit.getParent(parentIndex));
    if (m.merge(mergeTip, originalCommit)) {
        ObjectId tree = m.getResultTreeId();
        if (tree.equals(mergeTip.getTree()) && !ignoreIdenticalTree) {
            throw new MergeIdenticalTreeException("identical tree");
        }
        CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(tree);
        mergeCommit.setParentId(mergeTip);
        mergeCommit.setAuthor(originalCommit.getAuthorIdent());
        mergeCommit.setCommitter(cherryPickCommitterIdent);
        mergeCommit.setMessage(commitMsg);
        return rw.parseCommit(inserter.insert(mergeCommit));
    }
    throw new MergeConflictException("merge conflict");
}
#end_block

#method_before
public boolean canFastForward(MergeSorter mergeSorter, CodeReviewCommit mergeTip, CodeReviewRevWalk rw, CodeReviewCommit toMerge) throws IntegrationException {
    if (hasMissingDependencies(mergeSorter, toMerge)) {
        return false;
    }
    try {
        return mergeTip == null || rw.isMergedInto(mergeTip, toMerge);
    } catch (IOException e) {
        throw new IntegrationException("Cannot fast-forward test during merge", e);
    }
}
#method_after
public boolean canFastForward(MergeSorter mergeSorter, CodeReviewCommit mergeTip, CodeReviewRevWalk rw, CodeReviewCommit toMerge) throws IntegrationException {
    if (hasMissingDependencies(mergeSorter, toMerge)) {
        return false;
    }
    try {
        return mergeTip == null || rw.isMergedInto(mergeTip, toMerge) || rw.isMergedInto(toMerge, mergeTip);
    } catch (IOException e) {
        throw new IntegrationException("Cannot fast-forward test during merge", e);
    }
}
#end_block

#method_before
public void markCleanMerges(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final Set<RevCommit> alreadyAccepted) throws IntegrationException {
    if (mergeTip == null) {
        // 
        return;
    }
    try {
        rw.resetRetain(canMergeFlag);
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.getPatchsetId() != null && c.getStatusCode() == null) {
                c.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Cannot mark clean merges", e);
    }
}
#method_after
public void markCleanMerges(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final Set<RevCommit> alreadyAccepted) throws IntegrationException {
    if (mergeTip == null) {
        // 
        return;
    }
    try {
        rw.resetRetain(canMergeFlag);
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            // If branch was not created by this submit.
            if (!Objects.equals(c, mergeTip)) {
                rw.markUninteresting(c);
            }
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.getPatchsetId() != null && c.getStatusCode() == null) {
                c.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Cannot mark clean merges", e);
    }
}
#end_block

#method_before
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    AccountGroup group = groupCache.get(groupId);
    GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    GroupDescription.Basic ownerGroup = groupBackend.get(group.getOwnerGroupUUID());
    if (ownerGroup != null) {
        detail.setOwnerGroup(GroupReference.forGroup(ownerGroup));
    }
    detail.setMembers(loadMembers());
    detail.setIncludes(loadIncludes());
    detail.setAccounts(aic.create());
    detail.setCanModify(control.isOwner());
    return detail;
}
#method_after
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    AccountGroup group = groupCache.get(groupId);
    GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    detail.setMembers(loadMembers());
    detail.setIncludes(loadIncludes());
    return detail;
}
#end_block

#method_before
private List<AccountGroupMember> loadMembers() throws OrmException {
    List<AccountGroupMember> members = new ArrayList<>();
    for (AccountGroupMember m : db.accountGroupMembers().byGroup(groupId)) {
        if (control.canSeeMember(m.getAccountId())) {
            aic.want(m.getAccountId());
            members.add(m);
        }
    }
    Collections.sort(members, new Comparator<AccountGroupMember>() {

        @Override
        public int compare(AccountGroupMember o1, AccountGroupMember o2) {
            Account a = aic.get(o1.getAccountId());
            Account b = aic.get(o2.getAccountId());
            return n(a).compareTo(n(b));
        }

        private String n(final Account a) {
            String n = a.getFullName();
            if (n != null && n.length() > 0) {
                return n;
            }
            n = a.getPreferredEmail();
            if (n != null && n.length() > 0) {
                return n;
            }
            return a.getId().toString();
        }
    });
    return members;
}
#method_after
private List<AccountGroupMember> loadMembers() throws OrmException {
    List<AccountGroupMember> members = new ArrayList<>();
    for (AccountGroupMember m : db.accountGroupMembers().byGroup(groupId)) {
        if (control.canSeeMember(m.getAccountId())) {
            members.add(m);
        }
    }
    return members;
}
#end_block

#method_before
private List<AccountGroupById> loadIncludes() throws OrmException {
    List<AccountGroupById> groups = new ArrayList<>();
    for (AccountGroupById m : db.accountGroupById().byGroup(groupId)) {
        if (control.canSeeGroup()) {
            gic.want(m.getIncludeUUID());
            groups.add(m);
        }
    }
    Collections.sort(groups, new Comparator<AccountGroupById>() {

        @Override
        public int compare(AccountGroupById o1, AccountGroupById o2) {
            GroupDescription.Basic a = gic.get(o1.getIncludeUUID());
            GroupDescription.Basic b = gic.get(o2.getIncludeUUID());
            return n(a).compareTo(n(b));
        }

        private String n(GroupDescription.Basic a) {
            if (a == null) {
                return "";
            }
            String n = a.getName();
            if (n != null && n.length() > 0) {
                return n;
            }
            return a.getGroupUUID().get();
        }
    });
    return groups;
}
#method_after
private List<AccountGroupById> loadIncludes() throws OrmException {
    List<AccountGroupById> groups = new ArrayList<>();
    for (AccountGroupById m : db.accountGroupById().byGroup(groupId)) {
        if (control.canSeeGroup()) {
            groups.add(m);
        }
    }
    return groups;
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    for (Project.NameKey projectName : repoManager.list()) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfigSchemaUpdate cfg = ProjectConfigSchemaUpdate.read(md);
            cfg.removeForceFromPermission("pushTag");
            cfg.save(serverUser, COMMIT_MSG);
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException("Cannot migrate project " + projectName, ex);
        }
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    SortedSet<Project.NameKey> repoList = repoManager.list();
    SortedSet<Project.NameKey> repoUpgraded = new TreeSet<>();
    ui.message("\tMigrating " + repoList.size() + " repositories ...");
    for (Project.NameKey projectName : repoList) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfigSchemaUpdate cfg = ProjectConfigSchemaUpdate.read(md);
            cfg.removeForceFromPermission("pushTag");
            if (cfg.isUpdated()) {
                repoUpgraded.add(projectName);
            }
            cfg.save(serverUser, COMMIT_MSG);
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException("Cannot migrate project " + projectName, ex);
        }
    }
    ui.message("\tMigration completed:  " + repoUpgraded.size() + " repositories updated:");
    ui.message("\t" + repoUpgraded.stream().map(n -> n.get()).collect(Collectors.joining(" ")));
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(label.getName()), -1, 1, anonymousUsers, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(pLabel.getName()), 0, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(project, cfg);
    eventListenerRegistration = source.add(new CommentAddedListener() {

        @Override
        public void onCommentAdded(Event event) {
            lastCommentAddedEvent = event;
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anonymousUsers = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(label.getName()), -1, 1, anonymousUsers, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(pLabel.getName()), 0, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(project, cfg);
    eventListenerRegistration = source.add(new CommentAddedListener() {

        @Override
        public void onCommentAdded(Event event) {
            lastCommentAddedEvent = event;
        }
    });
}
#end_block

#method_before
private void deleteChangeElementsFromDb(ChangeContext ctx, Change.Id id) throws OrmException {
    if (PrimaryStorage.of(ctx.getChange()) != REVIEW_DB) {
        return;
    }
    // Avoid OrmConcurrencyException trying to delete non-existent entities.
    // Only delete from ReviewDb here; deletion from NoteDb is handled in
    // BatchUpdate.
    ReviewDb db = unwrap(ctx.getDb());
    db.patchComments().delete(db.patchComments().byChange(id));
    db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
    db.patchSets().delete(db.patchSets().byChange(id));
    db.changeMessages().delete(db.changeMessages().byChange(id));
}
#method_after
private void deleteChangeElementsFromDb(ChangeContext ctx, Change.Id id) throws OrmException {
    // Only delete from ReviewDb here; deletion from NoteDb is handled in
    // BatchUpdate.
    ReviewDb db = unwrap(ctx.getDb());
    db.patchComments().delete(db.patchComments().byChange(id));
    db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
    db.patchSets().delete(db.patchSets().byChange(id));
    db.changeMessages().delete(db.changeMessages().byChange(id));
}
#end_block

#method_before
public ChangeAttribute asChangeAttribute(ReviewDb db, Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().toString();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db, change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for" + " change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.assignee = asAccountAttribute(change.getAssignee());
    a.status = change.getStatus();
    return a;
}
#method_after
public ChangeAttribute asChangeAttribute(ReviewDb db, Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().get();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db, change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for" + " change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.assignee = asAccountAttribute(change.getAssignee());
    a.status = change.getStatus();
    return a;
}
#end_block

#method_before
private DependencyAttribute newDependencyAttribute(Change c, PatchSet ps) {
    DependencyAttribute d = new DependencyAttribute();
    d.number = c.getId().toString();
    d.id = c.getKey().toString();
    d.revision = ps.getRevision().get();
    d.ref = ps.getRefName();
    return d;
}
#method_after
private DependencyAttribute newDependencyAttribute(Change c, PatchSet ps) {
    DependencyAttribute d = new DependencyAttribute();
    d.number = c.getId().get();
    d.id = c.getKey().toString();
    d.revision = ps.getRevision().get();
    d.ref = ps.getRefName();
    return d;
}
#end_block

#method_before
public void addTrackingIds(ChangeAttribute a, Multimap<String, String> set) {
    if (!set.isEmpty()) {
        a.trackingIds = new ArrayList<>(set.size());
        for (Map.Entry<String, Collection<String>> e : set.asMap().entrySet()) {
            for (String id : e.getValue()) {
                TrackingIdAttribute t = new TrackingIdAttribute();
                t.system = e.getKey();
                t.id = id;
                a.trackingIds.add(t);
            }
        }
    }
}
#method_after
public void addTrackingIds(ChangeAttribute a, ListMultimap<String, String> set) {
    if (!set.isEmpty()) {
        a.trackingIds = new ArrayList<>(set.size());
        for (Map.Entry<String, Collection<String>> e : set.asMap().entrySet()) {
            for (String id : e.getValue()) {
                TrackingIdAttribute t = new TrackingIdAttribute();
                t.system = e.getKey();
                t.id = id;
                a.trackingIds.add(t);
            }
        }
    }
}
#end_block

#method_before
public void addPatchSetComments(PatchSetAttribute patchSetAttribute, Collection<Comment> comments) {
    for (Comment comment : comments) {
        if (comment.key.patchSetId == Integer.parseInt(patchSetAttribute.number)) {
            if (patchSetAttribute.comments == null) {
                patchSetAttribute.comments = new ArrayList<>();
            }
            patchSetAttribute.comments.add(asPatchSetLineAttribute(comment));
        }
    }
}
#method_after
public void addPatchSetComments(PatchSetAttribute patchSetAttribute, Collection<Comment> comments) {
    for (Comment comment : comments) {
        if (comment.key.patchSetId == patchSetAttribute.number) {
            if (patchSetAttribute.comments == null) {
                patchSetAttribute.comments = new ArrayList<>();
            }
            patchSetAttribute.comments.add(asPatchSetLineAttribute(comment));
        }
    }
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(ReviewDb db, RevWalk revWalk, Change change, PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    p.isDraft = patchSet.isDraft();
    PatchSet.Id pId = patchSet.getId();
    try {
        p.parents = new ArrayList<>();
        RevCommit c = revWalk.parseCommit(ObjectId.fromString(p.revision));
        for (RevCommit parent : c.getParents()) {
            p.parents.add(parent.name());
        }
        UserIdentity author = toUserIdentity(c.getAuthorIdent());
        if (author.getAccount() == null) {
            p.author = new AccountAttribute();
            p.author.email = author.getEmail();
            p.author.name = author.getName();
            p.author.username = "";
        } else {
            p.author = asAccountAttribute(author.getAccount());
        }
        List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
        for (Patch pe : list) {
            if (!Patch.isMagic(pe.getFileName())) {
                p.sizeDeletions -= pe.getDeletions();
                p.sizeInsertions += pe.getInsertions();
            }
        }
        p.kind = changeKindCache.getChangeKind(db, change, patchSet);
    } catch (IOException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(ReviewDb db, RevWalk revWalk, Change change, PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = patchSet.getPatchSetId();
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    p.isDraft = patchSet.isDraft();
    PatchSet.Id pId = patchSet.getId();
    try {
        p.parents = new ArrayList<>();
        RevCommit c = revWalk.parseCommit(ObjectId.fromString(p.revision));
        for (RevCommit parent : c.getParents()) {
            p.parents.add(parent.name());
        }
        UserIdentity author = toUserIdentity(c.getAuthorIdent());
        if (author.getAccount() == null) {
            p.author = new AccountAttribute();
            p.author.email = author.getEmail();
            p.author.name = author.getName();
            p.author.username = "";
        } else {
            p.author = asAccountAttribute(author.getAccount());
        }
        List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
        for (Patch pe : list) {
            if (!Patch.isMagic(pe.getFileName())) {
                p.sizeDeletions -= pe.getDeletions();
                p.sizeInsertions += pe.getInsertions();
            }
        }
        p.kind = changeKindCache.getChangeKind(db, change, patchSet);
    } catch (IOException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    modules.add(new EventBroker.Module());
    modules.add(new H2AccountPatchReviewStore.Module());
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, false, false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    modules.add(new EventBroker.Module());
    modules.add(new H2AccountPatchReviewStore.Module());
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, false, false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    modules.add(new SshHostKeyModule());
    modules.add(new DefaultCommandModule(false, sysInjector.getInstance(DownloadConfig.class)));
    if (indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    modules.add(new SshHostKeyModule());
    modules.add(new DefaultCommandModule(false, sysInjector.getInstance(DownloadConfig.class), sysInjector.getInstance(LfsPluginAuthCommand.Module.class)));
    if (indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
public RefUpdate.Result createEdit(Change change, PatchSet ps) throws AuthException, IOException, ResourceConflictException, OrmException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = currentUser.get().asIdentifiedUser();
    String refPrefix = RefNames.refsEditPrefix(me.getAccountId(), change.getId());
    try {
        ChangeControl c = changeControlFactory.controlFor(reviewDb.get(), change, me);
        if (!c.canAddPatchSet(reviewDb.get())) {
            return RefUpdate.Result.REJECTED;
        }
    } catch (NoSuchChangeException e) {
        return RefUpdate.Result.NO_CHANGE;
    }
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(refPrefix);
        if (!refs.isEmpty()) {
            throw new ResourceConflictException("edit already exists");
        }
        try (RevWalk rw = new RevWalk(repo)) {
            ObjectId revision = ObjectId.fromString(ps.getRevision().get());
            String editRefName = RefNames.refsEdit(me.getAccountId(), change.getId(), ps.getId());
            Result res = update(repo, me, editRefName, rw, ObjectId.zeroId(), revision, TimeUtil.nowTs());
            indexer.index(reviewDb.get(), change);
            return res;
        }
    }
}
#method_after
public void createEdit(Repository repository, ChangeControl changeControl) throws AuthException, IOException, InvalidChangeOperationException, OrmException {
    ensureAuthenticatedAndPermitted(changeControl);
    Optional<ChangeEdit> changeEdit = lookupChangeEdit(changeControl);
    if (changeEdit.isPresent()) {
        throw new InvalidChangeOperationException(String.format("A change edit " + "already exists for change %s", changeControl.getId()));
    }
    PatchSet currentPatchSet = lookupCurrentPatchSet(changeControl);
    ObjectId patchSetCommitId = getPatchSetCommitId(currentPatchSet);
    createEditReference(repository, changeControl, currentPatchSet, patchSetCommitId, TimeUtil.nowTs());
}
#end_block

#method_before
public void rebaseEdit(ChangeEdit edit, PatchSet current) throws AuthException, ResourceConflictException, InvalidChangeOperationException, IOException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = edit.getChange();
    IdentifiedUser me = currentUser.get().asIdentifiedUser();
    String refName = RefNames.refsEdit(me.getAccountId(), change.getId(), current.getId());
    try (Repository repo = gitManager.openRepository(change.getProject());
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        BatchRefUpdate ru = repo.getRefDatabase().newBatchUpdate();
        RevCommit editCommit = edit.getEditCommit();
        if (editCommit.getParentCount() == 0) {
            throw new InvalidChangeOperationException("Rebase edit against root commit not supported");
        }
        RevCommit tip = rw.parseCommit(ObjectId.fromString(current.getRevision().get()));
        ThreeWayMerger m = MergeStrategy.RESOLVE.newMerger(repo, true);
        m.setObjectInserter(inserter);
        m.setBase(ObjectId.fromString(edit.getBasePatchSet().getRevision().get()));
        if (m.merge(tip, editCommit)) {
            ObjectId tree = m.getResultTreeId();
            CommitBuilder commit = new CommitBuilder();
            commit.setTreeId(tree);
            for (int i = 0; i < tip.getParentCount(); i++) {
                commit.addParentId(tip.getParent(i));
            }
            commit.setAuthor(editCommit.getAuthorIdent());
            commit.setCommitter(new PersonIdent(editCommit.getCommitterIdent(), TimeUtil.nowTs()));
            commit.setMessage(editCommit.getFullMessage());
            ObjectId newEdit = inserter.insert(commit);
            inserter.flush();
            ru.addCommand(new ReceiveCommand(ObjectId.zeroId(), newEdit, refName));
            ru.addCommand(new ReceiveCommand(edit.getRef().getObjectId(), ObjectId.zeroId(), edit.getRefName()));
            ru.execute(rw, NullProgressMonitor.INSTANCE);
            for (ReceiveCommand cmd : ru.getCommands()) {
                if (cmd.getResult() != ReceiveCommand.Result.OK) {
                    throw new IOException("failed: " + cmd);
                }
            }
        } else {
            // TODO(davido): Allow to resolve conflicts inline
            throw new ResourceConflictException("merge conflict");
        }
    }
}
#method_after
public void rebaseEdit(Repository repository, ChangeControl changeControl) throws AuthException, InvalidChangeOperationException, IOException, OrmException, MergeConflictException {
    ensureAuthenticatedAndPermitted(changeControl);
    Optional<ChangeEdit> optionalChangeEdit = lookupChangeEdit(changeControl);
    if (!optionalChangeEdit.isPresent()) {
        throw new InvalidChangeOperationException(String.format("No change edit exists for change %s", changeControl.getId()));
    }
    ChangeEdit changeEdit = optionalChangeEdit.get();
    PatchSet currentPatchSet = lookupCurrentPatchSet(changeControl);
    if (isBasedOn(changeEdit, currentPatchSet)) {
        throw new InvalidChangeOperationException(String.format("Change edit for change %s is already based on latest patch set %s", changeControl.getId(), currentPatchSet.getId()));
    }
    rebase(repository, changeEdit, currentPatchSet);
}
#end_block

#method_before
public RefUpdate.Result modifyMessage(ChangeEdit edit, String msg) throws AuthException, InvalidChangeOperationException, IOException, UnchangedCommitMessageException {
    msg = msg.trim() + "\n";
    checkState(!Strings.isNullOrEmpty(msg), "message cannot be null");
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    RevCommit prevEdit = edit.getEditCommit();
    if (prevEdit.getFullMessage().equals(msg)) {
        throw new UnchangedCommitMessageException();
    }
    IdentifiedUser me = currentUser.get().asIdentifiedUser();
    Project.NameKey project = edit.getChange().getProject();
    try (Repository repo = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        String refName = edit.getRefName();
        Timestamp now = TimeUtil.nowTs();
        ObjectId commit = createCommit(me, inserter, prevEdit, prevEdit.getTree(), msg, now);
        inserter.flush();
        return update(repo, me, refName, rw, prevEdit, commit, now);
    }
}
#method_after
public void modifyMessage(Repository repository, ChangeControl changeControl, String newCommitMessage) throws AuthException, IOException, UnchangedCommitMessageException, OrmException {
    ensureAuthenticatedAndPermitted(changeControl);
    newCommitMessage = getWellFormedCommitMessage(newCommitMessage);
    Optional<ChangeEdit> optionalChangeEdit = lookupChangeEdit(changeControl);
    PatchSet basePatchSet = getBasePatchSet(optionalChangeEdit, changeControl);
    RevCommit basePatchSetCommit = lookupCommit(repository, basePatchSet);
    RevCommit baseCommit = optionalChangeEdit.map(ChangeEdit::getEditCommit).orElse(basePatchSetCommit);
    String currentCommitMessage = baseCommit.getFullMessage();
    if (newCommitMessage.equals(currentCommitMessage)) {
        throw new UnchangedCommitMessageException();
    }
    RevTree baseTree = baseCommit.getTree();
    Timestamp nowTimestamp = TimeUtil.nowTs();
    ObjectId newEditCommit = createCommit(repository, basePatchSetCommit, baseTree, newCommitMessage, nowTimestamp);
    if (optionalChangeEdit.isPresent()) {
        updateEditReference(repository, optionalChangeEdit.get(), newEditCommit, nowTimestamp);
    } else {
        createEditReference(repository, changeControl, basePatchSet, newEditCommit, nowTimestamp);
    }
}
#end_block

#method_before
public RefUpdate.Result modifyFile(ChangeEdit edit, String file, RawInput content) throws AuthException, InvalidChangeOperationException, IOException {
    return modify(TreeOperation.CHANGE_ENTRY, edit, file, null, content);
}
#method_after
public void modifyFile(Repository repository, ChangeControl changeControl, String filePath, RawInput newContent) throws AuthException, InvalidChangeOperationException, IOException, OrmException {
    modifyTree(repository, changeControl, new ChangeFileContentModification(filePath, newContent));
}
#end_block

#method_before
public RefUpdate.Result deleteFile(ChangeEdit edit, String file) throws AuthException, InvalidChangeOperationException, IOException {
    return modify(TreeOperation.DELETE_ENTRY, edit, file, null, null);
}
#method_after
public void deleteFile(Repository repository, ChangeControl changeControl, String file) throws AuthException, InvalidChangeOperationException, IOException, OrmException {
    modifyTree(repository, changeControl, new DeleteFileModification(file));
}
#end_block

#method_before
public RefUpdate.Result renameFile(ChangeEdit edit, String file, String newFile) throws AuthException, InvalidChangeOperationException, IOException {
    return modify(TreeOperation.RENAME_ENTRY, edit, file, newFile, null);
}
#method_after
public void renameFile(Repository repository, ChangeControl changeControl, String currentFilePath, String newFilePath) throws AuthException, InvalidChangeOperationException, IOException, OrmException {
    modifyTree(repository, changeControl, new RenameFileModification(currentFilePath, newFilePath));
}
#end_block

#method_before
public RefUpdate.Result restoreFile(ChangeEdit edit, String file) throws AuthException, InvalidChangeOperationException, IOException {
    return modify(TreeOperation.RESTORE_ENTRY, edit, file, null, null);
}
#method_after
public void restoreFile(Repository repository, ChangeControl changeControl, String file) throws AuthException, InvalidChangeOperationException, IOException, OrmException {
    modifyTree(repository, changeControl, new RestoreFileModification(file));
}
#end_block

#method_before
private ObjectId createCommit(IdentifiedUser me, ObjectInserter inserter, RevCommit revision, ObjectId tree, String msg, Timestamp when) throws IOException {
    CommitBuilder builder = new CommitBuilder();
    builder.setTreeId(tree);
    builder.setParentIds(revision.getParents());
    builder.setAuthor(revision.getAuthorIdent());
    builder.setCommitter(getCommitterIdent(me, when));
    builder.setMessage(msg);
    return inserter.insert(builder);
}
#method_after
private ObjectId createCommit(Repository repository, RevCommit basePatchSetCommit, ObjectId tree, String commitMessage, Timestamp timestamp) throws IOException {
    try (ObjectInserter objectInserter = repository.newObjectInserter()) {
        CommitBuilder builder = new CommitBuilder();
        builder.setTreeId(tree);
        builder.setParentIds(basePatchSetCommit.getParents());
        builder.setAuthor(basePatchSetCommit.getAuthorIdent());
        builder.setCommitter(getCommitterIdent(timestamp));
        builder.setMessage(commitMessage);
        ObjectId newCommitId = objectInserter.insert(builder);
        objectInserter.flush();
        return newCommitId;
    }
}
#end_block

#method_before
private PersonIdent getCommitterIdent(IdentifiedUser user, Timestamp when) {
    return user.newCommitterIdent(when, tz);
}
#method_after
private PersonIdent getCommitterIdent(Timestamp commitTimestamp) {
    IdentifiedUser user = currentUser.get().asIdentifiedUser();
    return user.newCommitterIdent(commitTimestamp, tz);
}
#end_block

#method_before
private PersonIdent getRefLogIdent(IdentifiedUser user, Timestamp when) {
    return user.newRefLogIdent(when, tz);
}
#method_after
private PersonIdent getRefLogIdent(Timestamp timestamp) {
    IdentifiedUser user = currentUser.get().asIdentifiedUser();
    return user.newRefLogIdent(timestamp, tz);
}
#end_block

#method_before
private String getNewSecureStoreClassName(Path secureStore) throws IOException {
    JarScanner scanner = new JarScanner(secureStore);
    List<String> newSecureStores = scanner.findSubClassesOf(SecureStore.class);
    if (newSecureStores.isEmpty()) {
        throw new RuntimeException(String.format("Cannot find implementation of SecureStore interface in %s", secureStore.toAbsolutePath()));
    }
    if (newSecureStores.size() > 1) {
        throw new RuntimeException(String.format("Found too many implementations of SecureStore:\n%s\nin %s", Joiner.on("\n").join(newSecureStores), secureStore.toAbsolutePath()));
    }
    return Iterables.getOnlyElement(newSecureStores);
}
#method_after
private String getNewSecureStoreClassName(Path secureStore) throws IOException {
    try (JarScanner scanner = new JarScanner(secureStore)) {
        List<String> newSecureStores = scanner.findSubClassesOf(SecureStore.class);
        if (newSecureStores.isEmpty()) {
            throw new RuntimeException(String.format("Cannot find implementation of SecureStore interface in %s", secureStore.toAbsolutePath()));
        }
        if (newSecureStores.size() > 1) {
            throw new RuntimeException(String.format("Found too many implementations of SecureStore:\n%s\nin %s", Joiner.on("\n").join(newSecureStores), secureStore.toAbsolutePath()));
        }
        return Iterables.getOnlyElement(newSecureStores);
    }
}
#end_block

#method_before
public static int mainImpl(final String[] argv) throws Exception {
    if (argv.length == 0) {
        File me;
        try {
            me = getDistributionArchive();
        } catch (FileNotFoundException e) {
            me = null;
        }
        String jar = me != null ? me.getName() : "gerrit.war";
        System.err.println("Gerrit Code Review " + getVersion(me));
        System.err.println("usage: java -jar " + jar + " command [ARG ...]");
        System.err.println();
        System.err.println("The most commonly used commands are:");
        System.err.println("  init            Initialize a Gerrit installation");
        System.err.println("  reindex         Rebuild the secondary index");
        System.err.println("  daemon          Run the Gerrit network daemons");
        System.err.println("  gsql            Run the interactive query console");
        System.err.println("  version         Display the build version number");
        System.err.println();
        System.err.println("  ls              List files available for cat");
        System.err.println("  cat FILE        Display a file from the archive");
        System.err.println();
        return 1;
    }
    // 
    if ("-v".equals(argv[0]) || "--version".equals(argv[0])) {
        argv[0] = "version";
    } else if ("-p".equals(argv[0]) || "--cat".equals(argv[0])) {
        argv[0] = "cat";
    } else if ("-l".equals(argv[0]) || "--ls".equals(argv[0])) {
        argv[0] = "ls";
    }
    // Run the application class
    // 
    final ClassLoader cl = libClassLoader(isProlog(programClassName(argv[0])));
    Thread.currentThread().setContextClassLoader(cl);
    return invokeProgram(cl, argv);
}
#method_after
public static int mainImpl(final String[] argv) throws Exception {
    if (argv.length == 0) {
        File me;
        try {
            me = getDistributionArchive();
        } catch (FileNotFoundException e) {
            me = null;
        }
        String jar = me != null ? me.getName() : "gerrit.war";
        System.err.println("Gerrit Code Review " + getVersion(me));
        System.err.println("usage: java -jar " + jar + " command [ARG ...]");
        System.err.println();
        System.err.println("The most commonly used commands are:");
        System.err.println("  init            Initialize a Gerrit installation");
        System.err.println("  reindex         Rebuild the secondary index");
        System.err.println("  daemon          Run the Gerrit network daemons");
        System.err.println("  gsql            Run the interactive query console");
        System.err.println("  version         Display the build version number");
        System.err.println("  passwd          Set or change password in secure.config");
        System.err.println();
        System.err.println("  ls              List files available for cat");
        System.err.println("  cat FILE        Display a file from the archive");
        System.err.println();
        return 1;
    }
    // 
    if ("-v".equals(argv[0]) || "--version".equals(argv[0])) {
        argv[0] = "version";
    } else if ("-p".equals(argv[0]) || "--cat".equals(argv[0])) {
        argv[0] = "cat";
    } else if ("-l".equals(argv[0]) || "--ls".equals(argv[0])) {
        argv[0] = "ls";
    }
    // Run the application class
    // 
    final ClassLoader cl = libClassLoader(isProlog(programClassName(argv[0])));
    Thread.currentThread().setContextClassLoader(cl);
    return invokeProgram(cl, argv);
}
#end_block

#method_before
private static Path resolveInSourceRoot(String name) throws FileNotFoundException {
    // Find ourselves in the classpath, as a loose class file or jar.
    Class<GerritLauncher> self = GerritLauncher.class;
    URL u = self.getResource(self.getSimpleName() + ".class");
    if (u == null) {
        throw new FileNotFoundException("Cannot find class " + self.getName());
    } else if ("jar".equals(u.getProtocol())) {
        String p = u.getPath();
        try {
            u = new URL(p.substring(0, p.indexOf('!')));
        } catch (MalformedURLException e) {
            FileNotFoundException fnfe = new FileNotFoundException("Not a valid jar file: " + u);
            fnfe.initCause(e);
            throw fnfe;
        }
    }
    if (!"file".equals(u.getProtocol())) {
        throw new FileNotFoundException("Cannot extract path from " + u);
    }
    // Pop up to the top-level source folder by looking for .buckconfig.
    Path dir = Paths.get(u.getPath());
    while (!Files.isRegularFile(dir.resolve(".buckconfig"))) {
        Path parent = dir.getParent();
        if (parent == null) {
            throw new FileNotFoundException("Cannot find source root from " + u);
        }
        dir = parent;
    }
    Path ret = dir.resolve(name);
    if (!Files.exists(ret)) {
        throw new FileNotFoundException(name + " not found in source root " + dir);
    }
    return ret;
}
#method_after
public static Path resolveInSourceRoot(String name) throws FileNotFoundException {
    // Find ourselves in the classpath, as a loose class file or jar.
    Class<GerritLauncher> self = GerritLauncher.class;
    // If the build system provides us with a source root, use that.
    try (InputStream stream = self.getResourceAsStream(SOURCE_ROOT_RESOURCE)) {
        System.err.println("URL: " + stream);
        if (stream != null) {
            try (Scanner scan = new Scanner(stream, UTF_8.name()).useDelimiter("\n")) {
                if (scan.hasNext()) {
                    Path p = Paths.get(scan.next());
                    if (!Files.exists(p)) {
                        throw new FileNotFoundException("source root not found: " + p);
                    }
                    return p;
                }
            }
        }
    } catch (IOException e) {
    // not Bazel, then.
    }
    URL u = self.getResource(self.getSimpleName() + ".class");
    if (u == null) {
        throw new FileNotFoundException("Cannot find class " + self.getName());
    } else if ("jar".equals(u.getProtocol())) {
        String p = u.getPath();
        try {
            u = new URL(p.substring(0, p.indexOf('!')));
        } catch (MalformedURLException e) {
            FileNotFoundException fnfe = new FileNotFoundException("Not a valid jar file: " + u);
            fnfe.initCause(e);
            throw fnfe;
        }
    }
    if (!"file".equals(u.getProtocol())) {
        throw new FileNotFoundException("Cannot extract path from " + u);
    }
    // Pop up to the top-level source folder by looking for .buckconfig.
    Path dir = Paths.get(u.getPath());
    while (!Files.isRegularFile(dir.resolve("WORKSPACE"))) {
        Path parent = dir.getParent();
        if (parent == null) {
            throw new FileNotFoundException("Cannot find source root from " + u);
        }
        dir = parent;
    }
    Path ret = dir.resolve(name);
    if (!Files.exists(ret)) {
        throw new FileNotFoundException(name + " not found in source root " + dir);
    }
    return ret;
}
#end_block

#method_before
private static ClassLoader useDevClasspath() throws MalformedURLException, FileNotFoundException {
    Path out = getDeveloperEclipseOut();
    List<URL> dirs = new ArrayList<>();
    dirs.add(out.resolve("classes").toUri().toURL());
    ClassLoader cl = GerritLauncher.class.getClassLoader();
    for (URL u : ((URLClassLoader) cl).getURLs()) {
        if (includeJar(u)) {
            dirs.add(u);
        }
    }
    return new URLClassLoader(dirs.toArray(new URL[dirs.size()]), ClassLoader.getSystemClassLoader().getParent());
}
#method_after
private static ClassLoader useDevClasspath() throws MalformedURLException, FileNotFoundException {
    Path out = resolveInSourceRoot("eclipse-out");
    List<URL> dirs = new ArrayList<>();
    dirs.add(out.resolve("classes").toUri().toURL());
    ClassLoader cl = GerritLauncher.class.getClassLoader();
    for (URL u : ((URLClassLoader) cl).getURLs()) {
        if (includeJar(u)) {
            dirs.add(u);
        }
    }
    return new URLClassLoader(dirs.toArray(new URL[dirs.size()]), ClassLoader.getSystemClassLoader().getParent());
}
#end_block

#method_before
public Change.Id cherryPick(Change change, PatchSet patch, final String message, final String ref, final RefControl refControl, int parent) throws NoSuchChangeException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    if (Strings.isNullOrEmpty(ref)) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = change.getProject();
    String destinationBranch = RefNames.shortName(ref);
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(oi.newReader())) {
        Ref destRef = git.getRefDatabase().exactRef(ref);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destinationBranch));
        }
        CodeReviewCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (parent <= 0 || parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = refControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk, parent - 1);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(change.getProject(), destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getDest().getParentKey(), identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = refControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(change.getTopic())) {
                        newTopic = change.getTopic() + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, refControl.getRefName(), newTopic, change.getDest());
                    bu.addOp(change.getId(), new AddMessageToSourceChangeOp(changeMessagesUtil, patch.getId(), destinationBranch, cherryPickCommit));
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#method_after
public Change.Id cherryPick(Change change, PatchSet patch, final String message, final String ref, final RefControl refControl, int parent) throws NoSuchChangeException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    if (Strings.isNullOrEmpty(ref)) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = change.getProject();
    String destinationBranch = RefNames.shortName(ref);
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(oi.newReader())) {
        Ref destRef = git.getRefDatabase().exactRef(ref);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destinationBranch));
        }
        CodeReviewCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (parent <= 0 || parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = refControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk, parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(change.getProject(), destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getDest().getParentKey(), identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = refControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(change.getTopic())) {
                        newTopic = change.getTopic() + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, refControl.getRefName(), newTopic, change.getDest());
                    bu.addOp(change.getId(), new AddMessageToSourceChangeOp(changeMessagesUtil, patch.getId(), destinationBranch, cherryPickCommit));
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    StringBuilder sb = new StringBuilder("Patch Set ").append(psId.get()).append(": Cherry Picked").append("\n\n").append("This patchset was cherry picked to branch ").append(destBranch).append(" as commit ").append(cherryPickCommit.name());
    ChangeMessage changeMessage = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), sb.toString(), ChangeMessagesUtil.TAG_CHERRY_PICK_CHANGE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    StringBuilder sb = new StringBuilder("Patch Set ").append(psId.get()).append(": Cherry Picked").append("\n\n").append("This patchset was cherry picked to branch ").append(destBranch).append(" as commit ").append(cherryPickCommit.name());
    ChangeMessage changeMessage = ChangeMessagesUtil.newMessage(psId, ctx.getUser(), ctx.getWhen(), sb.toString(), ChangeMessagesUtil.TAG_CHERRY_PICK_CHANGE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#end_block

#method_before
private boolean authenticateWithIdentityClaimedDuringHandshake(AuthRequest req, HttpServletResponse rsp, String claimedIdentifier) throws AccountException, IOException {
    Account.Id claimedId = accountManager.lookup(claimedIdentifier);
    Account.Id actualId = accountManager.lookup(user.getExternalId());
    if (claimedId != null && actualId != null) {
        if (claimedId.equals(actualId)) {
            // Both link to the same account, that's what we expected.
            log.debug("OAuth2: claimed identity equals current id");
        } else {
            // This is (for now) a fatal error. There are two records
            // for what might be the same user.
            // 
            log.error("OAuth accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + user.getExternalId());
            rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
            return false;
        }
    } else if (claimedId != null && actualId == null) {
        // Claimed account already exists: link to it.
        // 
        log.info("OAuth2: linking claimed identity to {}", claimedId.toString());
        try {
            accountManager.link(claimedId, req);
        } catch (OrmException e) {
            log.error("Cannot link: " + user.getExternalId() + " to user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier);
            rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
            return false;
        }
    }
    return true;
}
#method_after
private boolean authenticateWithIdentityClaimedDuringHandshake(AuthRequest req, HttpServletResponse rsp, String claimedIdentifier) throws AccountException, IOException {
    Optional<Account.Id> claimedId = accountManager.lookup(claimedIdentifier);
    Optional<Account.Id> actualId = accountManager.lookup(user.getExternalId());
    if (claimedId.isPresent() && actualId.isPresent()) {
        if (claimedId.get().equals(actualId.get())) {
            // Both link to the same account, that's what we expected.
            log.debug("OAuth2: claimed identity equals current id");
        } else {
            // This is (for now) a fatal error. There are two records
            // for what might be the same user.
            // 
            log.error("OAuth accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId.get() + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId.get() + " is " + user.getExternalId());
            rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
            return false;
        }
    } else if (claimedId.isPresent() && !actualId.isPresent()) {
        // Claimed account already exists: link to it.
        // 
        log.info("OAuth2: linking claimed identity to {}", claimedId.get().toString());
        try {
            accountManager.link(claimedId.get(), req);
        } catch (OrmException e) {
            log.error("Cannot link: " + user.getExternalId() + " to user identity:\n" + "  Claimed ID: " + claimedId.get() + " is " + claimedIdentifier);
            rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private static void configureDefaults(Map<String, List<PermissionRule>> out, AccessSection section) {
    configureDefault(out, section, GlobalCapability.QUERY_LIMIT, anonymous);
}
#method_after
private void configureDefaults(Map<String, List<PermissionRule>> out, AccessSection section) {
    configureDefault(out, section, GlobalCapability.QUERY_LIMIT, systemGroupBackend.getGroup(SystemGroupBackend.ANONYMOUS_USERS));
}
#end_block

#method_before
public void include(Change.Id changeId, Comment p) {
    PatchSet.Id psId = new PatchSet.Id(changeId, p.key.patchSetId);
    switch(p.side) {
        case 0:
            if (idA == null && idB.equals(psId)) {
                a.add(p);
                return;
            }
            break;
        case 1:
            if (idA != null && idA.equals(psId)) {
                a.add(p);
                return;
            }
            if (idB.equals(psId)) {
                b.add(p);
                return;
            }
            break;
    }
}
#method_after
public void include(Change.Id changeId, Comment p) {
    PatchSet.Id psId = new PatchSet.Id(changeId, p.key.patchSetId);
    switch(p.side) {
        case 0:
            if (idA == null && idB.equals(psId)) {
                a.add(p);
            }
            break;
        case 1:
            if (idA != null && idA.equals(psId)) {
                a.add(p);
            } else if (idB.equals(psId)) {
                b.add(p);
            }
            break;
    }
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
    } else {
        projectState = null;
    }
    if (patchSet == null) {
        try {
            patchSet = changeData.currentPatchSet();
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null) {
        setHeader("X-Gerrit-PatchSet", patchSet.getPatchSetId() + "");
        if (patchSetInfo == null) {
            try {
                patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId());
            } catch (PatchSetInfoNotAvailableException | OrmException err) {
                patchSetInfo = null;
            }
        }
    }
    authors = getAuthors();
    super.init();
    if (timestamp != null) {
        setHeader("Date", new Date(timestamp.getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setHeader("X-Gerrit-Numeric-Change-Id", "" + change.getChangeId());
    setChangeUrlHeader();
    setCommitIdHeader();
}
#method_after
@Override
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
    } else {
        projectState = null;
    }
    if (patchSet == null) {
        try {
            patchSet = changeData.currentPatchSet();
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null) {
        setHeader("X-Gerrit-PatchSet", patchSet.getPatchSetId() + "");
        if (patchSetInfo == null) {
            try {
                patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId());
            } catch (PatchSetInfoNotAvailableException | OrmException err) {
                patchSetInfo = null;
            }
        }
    }
    authors = getAuthors();
    super.init();
    if (timestamp != null) {
        setHeader("Date", new Date(timestamp.getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setHeader("X-Gerrit-Change-Number", "" + change.getChangeId());
    setChangeUrlHeader();
    setCommitIdHeader();
}
#end_block

#method_before
@Test
public void pushWithoutChangeId() throws Exception {
    RevCommit c = testRepo.branch("HEAD").commit().message("Message without Change-Id").add("a,txt", "content").create();
    assertThat(GitUtil.getChangeId(testRepo, c).isPresent()).isFalse();
    String ref = "refs/for/master";
    PushResult r = pushHead(testRepo, ref);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(ref);
    assertThat(refUpdate.getStatus()).isEqualTo(Status.REJECTED_OTHER_REASON);
    assertThat(refUpdate.getMessage()).endsWith(" missing Change-Id in commit message footer");
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setRequireChangeID(InheritableBoolean.FALSE);
    saveProjectConfig(project, config);
    r = pushHead(testRepo, ref);
    refUpdate = r.getRemoteUpdate(ref);
    assertThat(refUpdate.getStatus()).isEqualTo(Status.OK);
}
#method_after
@Test
public void pushWithoutChangeId() throws Exception {
    RevCommit c = createCommit(testRepo, "Message without Change-Id");
    assertThat(GitUtil.getChangeId(testRepo, c).isPresent()).isFalse();
    pushForReviewRejected(testRepo, "missing Change-Id in commit message footer");
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setRequireChangeID(InheritableBoolean.FALSE);
    saveProjectConfig(project, config);
    pushForReviewOk(testRepo);
}
#end_block

#method_before
@Test
public void pushWithMultipleChangeIds() throws Exception {
    testRepo.branch("HEAD").commit().message("Message withmultiple Change-Id\n" + "\n" + "Change-Id: I10f98c2ef76e52e23aa23be5afeb71e40b350e86\n" + "Change-Id: Ie9a132e107def33bdd513b7854b50de911edba0a\n").add("a,txt", "content").create();
    String ref = "refs/for/master";
    PushResult r = pushHead(testRepo, ref);
    RemoteRefUpdate refUpdate = r.getRemoteUpdate(ref);
    assertThat(refUpdate.getStatus()).isEqualTo(Status.REJECTED_OTHER_REASON);
    assertThat(refUpdate.getMessage()).endsWith(" multiple Change-Id lines in commit message footer");
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setRequireChangeID(InheritableBoolean.FALSE);
    saveProjectConfig(project, config);
    r = pushHead(testRepo, ref);
    refUpdate = r.getRemoteUpdate(ref);
    assertThat(refUpdate.getMessage()).endsWith(" multiple Change-Id lines in commit message footer");
}
#method_after
@Test
public void pushWithMultipleChangeIds() throws Exception {
    createCommit(testRepo, "Message with multiple Change-Id\n" + "\n" + "Change-Id: I10f98c2ef76e52e23aa23be5afeb71e40b350e86\n" + "Change-Id: Ie9a132e107def33bdd513b7854b50de911edba0a\n");
    pushForReviewRejected(testRepo, "multiple Change-Id lines in commit message footer");
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setRequireChangeID(InheritableBoolean.FALSE);
    saveProjectConfig(project, config);
    pushForReviewRejected(testRepo, "multiple Change-Id lines in commit message footer");
}
#end_block

#method_before
public void process(MailMessage message) throws OrmException {
    for (DynamicMap.Entry<MailFilter> filter : mailFilters) {
        if (filter.getProvider().get().shouldDiscardMessage(message)) {
            log.warn("Mail: Message " + message.id() + " filtered by plugin " + filter.getPluginName() + " " + filter.getExportName() + ". Will delete message.");
            return;
        }
    }
    MailMetadata metadata = MetadataParser.parse(message);
    if (!metadata.hasRequiredFields()) {
        log.error("Mail: Message " + message.id() + " is missing required metadata, have " + metadata + ". Will delete message.");
        return;
    }
    Set<Account.Id> accounts = accountByEmailCache.get(metadata.author);
    if (accounts.size() != 1) {
        log.error("Mail: Address " + metadata.author + " could not be matched to a unique account. It was matched to " + accounts + ". Will delete message.");
        return;
    }
    Account.Id account = accounts.iterator().next();
    if (!reviewDb.get().accounts().get(account).isActive()) {
        log.warn("Mail: Account " + account + " is inactive. Will delete message.");
        return;
    }
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(account)) {
        ChangeData cd = queryProvider.get().setLimit(1).byKey(Change.Key.parse(metadata.changeId)).get(0);
        if (existingMessageIds(cd).contains(message.id())) {
            log.info("Mail: Message " + message.id() + " was already processed. Will delete message.");
            return;
        }
        // Get all comments; filter and sort them to get the original list of
        // comments from the outbound email.
        // TODO(hiesel) Also filter by original comment author.
        Collection<Comment> comments = cd.publishedComments().stream().filter(c -> (c.writtenOn.getTime() / 1000) == (metadata.timestamp.getTime() / 1000)).sorted(CommentsUtil.COMMENT_ORDER).collect(Collectors.toList());
        Project.NameKey project = cd.project();
        String changeUrl = canonicalUrl.get() + "#/c/" + cd.getId().get();
        List<MailComment> parsedComments;
        if (useHtmlParser(message)) {
            parsedComments = HtmlParser.parse(message, comments, changeUrl);
        } else {
            parsedComments = TextParser.parse(message, comments, changeUrl);
        }
        if (parsedComments.isEmpty()) {
            log.warn("Mail: Could not parse any comments from " + message.id() + ". Will delete message.");
            return;
        }
        Op o = new Op(new PatchSet.Id(cd.getId(), metadata.patchSet), parsedComments, message.id());
        BatchUpdate batchUpdate = buf.create(cd.db(), project, ctx.getUser(), TimeUtil.nowTs());
        batchUpdate.addOp(cd.getId(), o);
        try {
            batchUpdate.execute();
        } catch (UpdateException | RestApiException e) {
            throw new OrmException(e);
        }
    }
}
#method_after
public void process(MailMessage message) throws OrmException {
    for (DynamicMap.Entry<MailFilter> filter : mailFilters) {
        if (!filter.getProvider().get().shouldProcessMessage(message)) {
            log.warn("Mail: Message " + message.id() + " filtered by plugin " + filter.getPluginName() + " " + filter.getExportName() + ". Will delete message.");
            return;
        }
    }
    MailMetadata metadata = MetadataParser.parse(message);
    if (!metadata.hasRequiredFields()) {
        log.error("Mail: Message " + message.id() + " is missing required metadata, have " + metadata + ". Will delete message.");
        return;
    }
    Set<Account.Id> accounts = accountByEmailCache.get(metadata.author);
    if (accounts.size() != 1) {
        log.error("Mail: Address " + metadata.author + " could not be matched to a unique account. It was matched to " + accounts + ". Will delete message.");
        return;
    }
    Account.Id account = accounts.iterator().next();
    if (!reviewDb.get().accounts().get(account).isActive()) {
        log.warn("Mail: Account " + account + " is inactive. Will delete message.");
        return;
    }
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(account)) {
        ChangeData cd = queryProvider.get().setLimit(1).byKey(Change.Key.parse(metadata.changeId)).get(0);
        if (existingMessageIds(cd).contains(message.id())) {
            log.info("Mail: Message " + message.id() + " was already processed. Will delete message.");
            return;
        }
        // Get all comments; filter and sort them to get the original list of
        // comments from the outbound email.
        // TODO(hiesel) Also filter by original comment author.
        Collection<Comment> comments = cd.publishedComments().stream().filter(c -> (c.writtenOn.getTime() / 1000) == (metadata.timestamp.getTime() / 1000)).sorted(CommentsUtil.COMMENT_ORDER).collect(Collectors.toList());
        Project.NameKey project = cd.project();
        String changeUrl = canonicalUrl.get() + "#/c/" + cd.getId().get();
        List<MailComment> parsedComments;
        if (useHtmlParser(message)) {
            parsedComments = HtmlParser.parse(message, comments, changeUrl);
        } else {
            parsedComments = TextParser.parse(message, comments, changeUrl);
        }
        if (parsedComments.isEmpty()) {
            log.warn("Mail: Could not parse any comments from " + message.id() + ". Will delete message.");
            return;
        }
        Op o = new Op(new PatchSet.Id(cd.getId(), metadata.patchSet), parsedComments, message.id());
        BatchUpdate batchUpdate = buf.create(cd.db(), project, ctx.getUser(), TimeUtil.nowTs());
        batchUpdate.addOp(cd.getId(), o);
        try {
            batchUpdate.execute();
        } catch (UpdateException | RestApiException e) {
            throw new OrmException(e);
        }
    }
}
#end_block

#method_before
@Override
public IncludedIn.IncludedInInfo apply(CommitResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    RevCommit commit = rsrc.getCommit();
    Project.NameKey project = rsrc.getProject().getProject().getNameKey();
    return includedIn.apply(project, commit.getId().getName());
}
#method_after
@Override
public IncludedInInfo apply(CommitResource rsrc) throws RestApiException, OrmException, IOException {
    RevCommit commit = rsrc.getCommit();
    Project.NameKey project = rsrc.getProject().getProject().getNameKey();
    return includedIn.apply(project, commit.getId().getName());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#end_block

#method_before
@Override
public IncludedIn.IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = ctl.getProject().getNameKey();
    return includedIn.apply(project, ps.getRevision().get());
}
#method_after
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws RestApiException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = ctl.getProject().getNameKey();
    return includedIn.apply(project, ps.getRevision().get());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    factory(DeleteRef.Factory.class);
}
#end_block

#method_before
public IncludedInInfo apply(Project.NameKey project, String objectId) throws BadRequestException, ResourceConflictException, IOException {
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(objectId));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        Multimap<String, String> external = ArrayListMultimap.create();
        for (ExternalIncludedIn ext : externalIncludedIn) {
            external.putAll(ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches()));
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external.asMap() : null));
    }
}
#method_after
public IncludedInInfo apply(Project.NameKey project, String revisionId) throws RestApiException, IOException {
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(revisionId));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        ListMultimap<String, String> external = MultimapBuilder.hashKeys().arrayListValues().build();
        for (ExternalIncludedIn ext : externalIncludedIn) {
            ListMultimap<String, String> extIncludedIns = ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches());
            if (extIncludedIns != null) {
                external.putAll(extIncludedIns);
            }
        }
        return new IncludedInInfo(d.getBranches(), d.getTags(), (!external.isEmpty() ? external.asMap() : null));
    }
}
#end_block

#method_before
private boolean isEnabledForRef(ProjectState project, String refName) {
    String[] refPatterns = pluginCfgFactory.getFromProjectConfigWithInheritance(project, pluginName).getStringList("branch");
    if (refPatterns.length == 0) {
        // Default behavior: no branch-specific config
        return true;
    }
    for (String refPattern : refPatterns) {
        if (RefConfigSection.isValid(refPattern) && match(refName, refPattern)) {
            return true;
        }
    }
    // Branch-specific behavior: ref is not matching
    return false;
}
#method_after
public boolean isEnabledForRef(Project.NameKey projectName, String refName, String validatorOp) {
    PluginConfig conf = configFactory.get(projectName);
    return conf != null && isValidConfig(conf, projectName) && (activeForRef(conf, refName)) && (!hasCriteria(conf, "skipGroup") || !canSkipValidation(conf, validatorOp) || !canSkipRef(conf, refName) || !canSkipGroup(conf));
}
#end_block

#method_before
private boolean match(String refName, String refPattern) {
    return RefPatternMatcher.getMatcher(refPattern).match(refName, null);
}
#method_after
private static boolean match(String value, String pattern) {
    return RefPatternMatcher.getMatcher(pattern).match(value, null);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    DynamicMap.mapOf(binder(), STAR_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    post(ACCOUNT_KIND, "index").to(Index.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects").to(PostWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects:delete").to(DeleteWatchedProjects.class);
    delete(ACCOUNT_KIND, "external_ids").to(DeleteAccountExternalIds.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    get(ACCOUNT_KIND, "agreements").to(GetAgreements.class);
    put(ACCOUNT_KIND, "agreements").to(PutAgreement.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    child(ACCOUNT_KIND, "stars.changes").to(Stars.class);
    get(STAR_KIND).to(Stars.Get.class);
    post(STAR_KIND).to(Stars.Post.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    DynamicMap.mapOf(binder(), STAR_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    post(ACCOUNT_KIND, "index").to(Index.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects").to(PostWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects:delete").to(DeleteWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    get(ACCOUNT_KIND, "agreements").to(GetAgreements.class);
    put(ACCOUNT_KIND, "agreements").to(PutAgreement.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    child(ACCOUNT_KIND, "stars.changes").to(Stars.class);
    get(STAR_KIND).to(Stars.Get.class);
    post(STAR_KIND).to(Stars.Post.class);
    get(ACCOUNT_KIND, "external.ids").to(GetExternalIds.class);
    post(ACCOUNT_KIND, "external.ids:delete").to(DeleteExternalIds.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
private String getLine(PatchFile fileInfo, short side, int lineNbr) {
    try {
        return fileInfo.getLine(side, lineNbr);
    } catch (IOException err) {
        // Default to the empty string if the file cannot be safely read.
        log.warn(String.format("Failed to read file on side %d", side), err);
        return "";
    } catch (IndexOutOfBoundsException err) {
        // Default to the empty string if the given line number does not appear
        // in the file.
        log.warn(String.format("Failed to get line number of file on side %d", side));
        return "";
    } catch (NoSuchEntityException err) {
        // Default to the empty string if the side cannot be found.
        log.warn(String.format("Side %d of file didn't exist", side), err);
        return "";
    }
}
#method_after
private String getLine(PatchFile fileInfo, short side, int lineNbr) {
    try {
        return fileInfo.getLine(side, lineNbr);
    } catch (IOException err) {
        // Default to the empty string if the file cannot be safely read.
        log.warn(String.format("Failed to read file on side %d", side), err);
        return "";
    } catch (IndexOutOfBoundsException err) {
        // Default to the empty string if the given line number does not appear
        // in the file.
        log.debug(String.format("Failed to get line number of file on side %d", side), err);
        return "";
    } catch (NoSuchEntityException err) {
        // Default to the empty string if the side cannot be found.
        log.warn(String.format("Side %d of file didn't exist", side), err);
        return "";
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource resource, Put.Input input) throws AuthException, ResourceConflictException, IOException, OrmException {
    if (Strings.isNullOrEmpty(path)) {
        // TODO Consider the following:
        // Generating an edit with a put (instead of a post) isn't mentioned in
        // the documentation of the REST API. We should consider whether we want
        // to keep this hidden 'feature', make it public via the documentation,
        // or remove it.
        createEdit(resource);
    } else {
        putEdit.apply(resource.getControl(), path, input.content);
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource resource, Put.Input input) throws AuthException, ResourceConflictException, IOException, OrmException {
    if (Strings.isNullOrEmpty(path)) {
        // TODO(aliceks): Consider the following:
        // Generating an edit with a put (instead of a post) isn't mentioned in
        // the documentation of the REST API. We should consider whether we want
        // to keep this hidden 'feature', make it public via the documentation,
        // or remove it.
        createEdit(resource);
    } else {
        putEdit.apply(resource.getControl(), path, input.content);
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, DeleteFile.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException, BadRequestException {
    // TODO Consider the following:
    // This check is strange. If there was already a change edit, this method
    // wouldn't be called because DeleteContent would take over. We should
    // consider to remove the positive case.
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent()) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        Project.NameKey project = rsrc.getProject();
        try (Repository repository = repoManager.openRepository(project)) {
            editModifier.deleteFile(repository, rsrc.getControl(), path);
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, DeleteFile.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException, BadRequestException {
    // TODO(aliceks): Consider the following:
    // This check is strange. If there was already a change edit, this method
    // wouldn't be called because DeleteContent would take over. We should
    // consider to remove the positive case.
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent()) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        Project.NameKey project = rsrc.getProject();
        try (Repository repository = repoManager.openRepository(project)) {
            editModifier.deleteFile(repository, rsrc.getControl(), path);
        }
    }
    return Response.none();
}
#end_block

#method_before
private boolean isRestoreFile(Input input) {
    return input != null && !Strings.isNullOrEmpty(input.restorePath);
}
#method_after
private static boolean isRestoreFile(Input input) {
    return input != null && !Strings.isNullOrEmpty(input.restorePath);
}
#end_block

#method_before
private boolean isRenameFile(Input input) {
    return input != null && !Strings.isNullOrEmpty(input.oldPath) && !Strings.isNullOrEmpty(input.newPath);
}
#method_after
private static boolean isRenameFile(Input input) {
    return input != null && !Strings.isNullOrEmpty(input.oldPath) && !Strings.isNullOrEmpty(input.newPath);
}
#end_block

#method_before
private static RevCommit lookupCommit(Repository repository, PatchSet patchSet) throws IOException {
    ObjectId patchSetCommitId = getPatchSetCommitId(patchSet);
    return lookup(repository, patchSetCommitId);
}
#method_after
private static RevCommit lookupCommit(Repository repository, PatchSet patchSet) throws IOException {
    ObjectId patchSetCommitId = getPatchSetCommitId(patchSet);
    try (RevWalk revWalk = new RevWalk(repository)) {
        return revWalk.parseCommit(patchSetCommitId);
    }
}
#end_block

#method_before
private void createEditReference(Repository repository, ChangeControl changeControl, PatchSet basePatchSet, ObjectId newEditCommit, Timestamp timestamp) throws IOException, OrmException {
    Change change = changeControl.getChange();
    String editRefName = getEditRefName(change, basePatchSet);
    updateReference(repository, editRefName, ObjectId.zeroId(), newEditCommit, timestamp);
    reindex(change);
}
#method_after
private void createEditReference(Repository repository, ChangeControl changeControl, PatchSet basePatchSet, ObjectId newEditCommit, Timestamp timestamp) throws IOException, OrmException {
    Change change = changeControl.getChange();
    String editRefName = getEditRefName(change, basePatchSet);
    updateReference(repository, editRefName, ObjectId.zeroId(), newEditCommit, timestamp);
    indexer.index(reviewDb.get(), change);
}
#end_block

#method_before
private void ensurePermitted(ChangeControl changeControl) throws OrmException, AuthException {
    if (!changeControl.canAddPatchSet(reviewDb.get())) {
        throw new AuthException("Adding patch sets and hence creation or" + " modification of change edits is not permitted.");
    }
}
#method_after
private void ensurePermitted(ChangeControl changeControl) throws OrmException, AuthException {
    if (!changeControl.canAddPatchSet(reviewDb.get())) {
        throw new AuthException("Not allowed to edit a change.");
    }
}
#end_block

#method_before
private static RevCommit lookupCommit(Repository repository, PatchSet patchSet) throws IOException {
    ObjectId patchSetCommitId = getPatchSetCommitId(patchSet);
    return lookup(repository, patchSetCommitId);
}
#method_after
private static RevCommit lookupCommit(Repository repository, PatchSet patchSet) throws IOException {
    ObjectId patchSetCommitId = getPatchSetCommitId(patchSet);
    try (RevWalk revWalk = new RevWalk(repository)) {
        return revWalk.parseCommit(patchSetCommitId);
    }
}
#end_block

#method_before
private void createEditReference(Repository repository, ChangeControl changeControl, PatchSet basePatchSet, ObjectId newEditCommit, Timestamp timestamp) throws IOException, OrmException {
    Change change = changeControl.getChange();
    String editRefName = getEditRefName(change, basePatchSet);
    updateReference(repository, editRefName, ObjectId.zeroId(), newEditCommit, timestamp);
    reindex(change);
}
#method_after
private void createEditReference(Repository repository, ChangeControl changeControl, PatchSet basePatchSet, ObjectId newEditCommit, Timestamp timestamp) throws IOException, OrmException {
    Change change = changeControl.getChange();
    String editRefName = getEditRefName(change, basePatchSet);
    updateReference(repository, editRefName, ObjectId.zeroId(), newEditCommit, timestamp);
    indexer.index(reviewDb.get(), change);
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource resource, Put.Input input) throws AuthException, ResourceConflictException, IOException, OrmException {
    Project.NameKey project = resource.getProject();
    Optional<ChangeEdit> edit;
    try (Repository repository = repositoryManager.openRepository(project)) {
        edit = createEdit(repository, resource.getControl());
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    if (!Strings.isNullOrEmpty(path)) {
        putEdit.apply(new ChangeEditResource(resource, edit.get(), path), input);
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource resource, Put.Input input) throws AuthException, ResourceConflictException, IOException, OrmException {
    Project.NameKey project = resource.getProject();
    Optional<ChangeEdit> edit;
    try (Repository repository = repositoryManager.openRepository(project)) {
        ChangeControl changeControl = resource.getControl();
        editModifier.createEdit(repository, changeControl);
        edit = editUtil.byChange(changeControl);
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    if (!Strings.isNullOrEmpty(path)) {
        putEdit.apply(new ChangeEditResource(resource, edit.get(), path), input);
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc, Input input) throws AuthException, IOException, BadRequestException, ResourceConflictException, OrmException {
    if (input == null || Strings.isNullOrEmpty(input.message)) {
        throw new BadRequestException("commit message must be provided");
    }
    Project.NameKey project = rsrc.getProject();
    try (Repository repository = repositoryManager.openRepository(project)) {
        ChangeControl changeControl = rsrc.getControl();
        ChangeEdit edit = getOrCreateChangeEdit(repository, changeControl);
        editModifier.modifyMessage(repository, input.message, edit);
    } catch (UnchangedCommitMessageException | InvalidChangeOperationException ucm) {
        throw new ResourceConflictException(ucm.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Object apply(ChangeResource rsrc, Input input) throws AuthException, IOException, BadRequestException, ResourceConflictException, OrmException {
    if (input == null || Strings.isNullOrEmpty(input.message)) {
        throw new BadRequestException("commit message must be provided");
    }
    Project.NameKey project = rsrc.getProject();
    try (Repository repository = repositoryManager.openRepository(project)) {
        ChangeControl changeControl = rsrc.getControl();
        ChangeEdit edit = getOrCreateChangeEdit(repository, changeControl);
        editModifier.modifyMessage(repository, input.message, edit);
    } catch (UnchangedCommitMessageException | InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
public ObjectId getMetaId() {
    return metaId;
}
#method_after
@Nullable
public ObjectId getMetaId() {
    return metaId;
}
#end_block

#method_before
@Test
public void refStateToByteArray() {
    assertThat(new String(RefState.toByteArray(P1, "refs/heads/foo", ObjectId.fromString(SHA1)), UTF_8)).isEqualTo(P1 + ":refs/heads/foo:" + SHA1);
    assertThat(new String(RefState.toByteArray(P1, "refs/heads/foo", null), UTF_8)).isEqualTo(P1 + ":refs/heads/foo:" + ObjectId.zeroId().name());
}
#method_after
@Test
public void refStateToByteArray() {
    assertThat(new String(RefState.create("refs/heads/foo", ObjectId.fromString(SHA1)).toByteArray(P1), UTF_8)).isEqualTo(P1 + ":refs/heads/foo:" + SHA1);
    assertThat(new String(RefState.create("refs/heads/foo", (ObjectId) null).toByteArray(P1), UTF_8)).isEqualTo(P1 + ":refs/heads/foo:" + ObjectId.zeroId().name());
}
#end_block

#method_before
@Test
public void parsePatterns() {
    assertInvalidPattern(null);
    assertInvalidPattern("");
    assertInvalidPattern("project:");
    assertInvalidPattern("project:refs/heads/foo");
    assertInvalidPattern("project:refs/he*ds/bar");
    assertInvalidPattern("project:refs/(he)*ds/bar");
    assertInvalidPattern("project:invalidrefname");
    ListMultimap<Project.NameKey, RefStatePattern> r = StalenessChecker.parsePatterns(byteArrays(P1 + ":refs/heads/*", P2 + ":refs/heads/foo/*/bar", P2 + ":refs/heads/foo/*-baz/*/quux"));
    assertThat(r.keySet()).containsExactly(P1, P2);
    RefStatePattern p = r.get(P1).get(0);
    assertThat(p.prefix()).isEqualTo("refs/heads/");
    assertThat(p.pattern().pattern()).isEqualTo("^\\Qrefs/heads/\\E.*\\Q\\E$");
    assertThat(p.match("refs/heads/foo")).isTrue();
    assertThat(p.match("xrefs/heads/foo")).isFalse();
    assertThat(p.match("refs/tags/foo")).isFalse();
    p = r.get(P2).get(0);
    assertThat(p.prefix()).isEqualTo("refs/heads/foo/");
    assertThat(p.pattern().pattern()).isEqualTo("^\\Qrefs/heads/foo/\\E.*\\Q/bar\\E$");
    assertThat(p.match("refs/heads/foo//bar")).isTrue();
    assertThat(p.match("refs/heads/foo/x/bar")).isTrue();
    assertThat(p.match("refs/heads/foo/x/y/bar")).isTrue();
    assertThat(p.match("refs/heads/foo/x/baz")).isFalse();
    p = r.get(P2).get(1);
    assertThat(p.prefix()).isEqualTo("refs/heads/foo/");
    assertThat(p.pattern().pattern()).isEqualTo("^\\Qrefs/heads/foo/\\E.*\\Q-baz/\\E.*\\Q/quux\\E$");
    assertThat(p.match("refs/heads/foo/-baz//quux")).isTrue();
    assertThat(p.match("refs/heads/foo/x-baz/x/quux")).isTrue();
    assertThat(p.match("refs/heads/foo/x/y-baz/x/y/quux")).isTrue();
    assertThat(p.match("refs/heads/foo/x-baz/x/y")).isFalse();
}
#method_after
@Test
public void parsePatterns() {
    assertInvalidPattern(null);
    assertInvalidPattern("");
    assertInvalidPattern("project:");
    assertInvalidPattern("project:refs/heads/foo");
    assertInvalidPattern("project:refs/he*ds/bar");
    assertInvalidPattern("project:refs/(he)*ds/bar");
    assertInvalidPattern("project:invalidrefname");
    ListMultimap<Project.NameKey, RefStatePattern> r = StalenessChecker.parsePatterns(byteArrays(P1 + ":refs/heads/*", P2 + ":refs/heads/foo/*/bar", P2 + ":refs/heads/foo/*-baz/*/quux"));
    assertThat(r.keySet()).containsExactly(P1, P2);
    RefStatePattern p = r.get(P1).get(0);
    assertThat(p.pattern()).isEqualTo("refs/heads/*");
    assertThat(p.prefix()).isEqualTo("refs/heads/");
    assertThat(p.regex().pattern()).isEqualTo("^\\Qrefs/heads/\\E.*\\Q\\E$");
    assertThat(p.match("refs/heads/foo")).isTrue();
    assertThat(p.match("xrefs/heads/foo")).isFalse();
    assertThat(p.match("refs/tags/foo")).isFalse();
    p = r.get(P2).get(0);
    assertThat(p.pattern()).isEqualTo("refs/heads/foo/*/bar");
    assertThat(p.prefix()).isEqualTo("refs/heads/foo/");
    assertThat(p.regex().pattern()).isEqualTo("^\\Qrefs/heads/foo/\\E.*\\Q/bar\\E$");
    assertThat(p.match("refs/heads/foo//bar")).isTrue();
    assertThat(p.match("refs/heads/foo/x/bar")).isTrue();
    assertThat(p.match("refs/heads/foo/x/y/bar")).isTrue();
    assertThat(p.match("refs/heads/foo/x/baz")).isFalse();
    p = r.get(P2).get(1);
    assertThat(p.pattern()).isEqualTo("refs/heads/foo/*-baz/*/quux");
    assertThat(p.prefix()).isEqualTo("refs/heads/foo/");
    assertThat(p.regex().pattern()).isEqualTo("^\\Qrefs/heads/foo/\\E.*\\Q-baz/\\E.*\\Q/quux\\E$");
    assertThat(p.match("refs/heads/foo/-baz//quux")).isTrue();
    assertThat(p.match("refs/heads/foo/x-baz/x/quux")).isTrue();
    assertThat(p.match("refs/heads/foo/x/y-baz/x/y/quux")).isTrue();
    assertThat(p.match("refs/heads/foo/x-baz/x/y")).isFalse();
}
#end_block

#method_before
@Test
public void refStatePatternToByteArray() {
    assertThat(new String(RefStatePattern.toByteArray(P1, "refs/*"), UTF_8)).isEqualTo(P1 + ":refs/*");
}
#method_after
@Test
public void refStatePatternToByteArray() {
    assertThat(new String(RefStatePattern.create("refs/*").toByteArray(P1), UTF_8)).isEqualTo(P1 + ":refs/*");
}
#end_block

#method_before
@VisibleForTesting
static SetMultimap<Project.NameKey, RefState> parseStates(Iterable<byte[]> states) {
    RefState.check(states != null, null);
    SetMultimap<Project.NameKey, RefState> result = HashMultimap.create();
    for (byte[] b : states) {
        RefState.check(b != null, null);
        String s = new String(b, UTF_8);
        List<String> parts = Splitter.on(':').splitToList(s);
        RefState.check(parts.size() == 3 && !parts.get(0).isEmpty() && !parts.get(1).isEmpty(), s);
        result.put(new Project.NameKey(parts.get(0)), RefState.create(parts.get(1), parts.get(2)));
    }
    return result;
}
#method_after
public static SetMultimap<Project.NameKey, RefState> parseStates(Iterable<byte[]> states) {
    RefState.check(states != null, null);
    SetMultimap<Project.NameKey, RefState> result = HashMultimap.create();
    for (byte[] b : states) {
        RefState.check(b != null, null);
        String s = new String(b, UTF_8);
        List<String> parts = Splitter.on(':').splitToList(s);
        RefState.check(parts.size() == 3 && !parts.get(0).isEmpty() && !parts.get(1).isEmpty(), s);
        result.put(new Project.NameKey(parts.get(0)), RefState.create(parts.get(1), parts.get(2)));
    }
    return result;
}
#end_block

#method_before
@VisibleForTesting
static ListMultimap<Project.NameKey, RefStatePattern> parsePatterns(Iterable<byte[]> patterns) {
    RefStatePattern.check(patterns != null, null);
    ListMultimap<Project.NameKey, RefStatePattern> result = ArrayListMultimap.create();
    for (byte[] b : patterns) {
        RefStatePattern.check(b != null, null);
        String s = new String(b, UTF_8);
        List<String> parts = Splitter.on(':').splitToList(s);
        RefStatePattern.check(parts.size() == 2, s);
        result.put(new Project.NameKey(parts.get(0)), RefStatePattern.create(parts.get(1)));
    }
    return result;
}
#method_after
public static ListMultimap<Project.NameKey, RefStatePattern> parsePatterns(Iterable<byte[]> patterns) {
    RefStatePattern.check(patterns != null, null);
    ListMultimap<Project.NameKey, RefStatePattern> result = ArrayListMultimap.create();
    for (byte[] b : patterns) {
        RefStatePattern.check(b != null, null);
        String s = new String(b, UTF_8);
        List<String> parts = Splitter.on(':').splitToList(s);
        RefStatePattern.check(parts.size() == 2, s);
        result.put(new Project.NameKey(parts.get(0)), RefStatePattern.create(parts.get(1)));
    }
    return result;
}
#end_block

#method_before
static RefState create(String ref, String sha) {
    return new AutoValue_StalenessChecker_RefState(ref, ObjectId.fromString(sha));
}
#method_after
static RefState create(String ref, @Nullable ObjectId id) {
    return new AutoValue_StalenessChecker_RefState(ref, firstNonNull(id, ObjectId.zeroId()));
}
#end_block

#method_before
static byte[] toByteArray(Project.NameKey project, String name, @Nullable ObjectId id) {
    byte[] a = (project.toString() + ':' + name + ':').getBytes(UTF_8);
    byte[] b = new byte[a.length + Constants.OBJECT_ID_STRING_LENGTH];
    System.arraycopy(a, 0, b, 0, a.length);
    firstNonNull(id, ObjectId.zeroId()).copyTo(b, a.length);
    return b;
}
#method_after
byte[] toByteArray(Project.NameKey project) {
    byte[] a = (project.toString() + ':' + ref() + ':').getBytes(UTF_8);
    byte[] b = new byte[a.length + Constants.OBJECT_ID_STRING_LENGTH];
    System.arraycopy(a, 0, b, 0, a.length);
    id().copyTo(b, a.length);
    return b;
}
#end_block

#method_before
static RefStatePattern create(String pat) {
    int star = pat.indexOf('*');
    check(star > 0 && pat.charAt(star - 1) == '/', pat);
    String prefix = pat.substring(0, star);
    check(Repository.isValidRefName(pat.replace('*', 'x')), pat);
    // Quote everything except the '*'s, which become ".*".
    String regex = StreamSupport.stream(Splitter.on('*').split(pat).spliterator(), false).map(Pattern::quote).collect(joining(".*", "^", "$"));
    return new AutoValue_StalenessChecker_RefStatePattern(prefix, Pattern.compile(regex));
}
#method_after
static RefStatePattern create(String pattern) {
    int star = pattern.indexOf('*');
    check(star > 0 && pattern.charAt(star - 1) == '/', pattern);
    String prefix = pattern.substring(0, star);
    check(Repository.isValidRefName(pattern.replace('*', 'x')), pattern);
    // Quote everything except the '*'s, which become ".*".
    String regex = StreamSupport.stream(Splitter.on('*').split(pattern).spliterator(), false).map(Pattern::quote).collect(joining(".*", "^", "$"));
    return new AutoValue_StalenessChecker_RefStatePattern(pattern, prefix, Pattern.compile(regex));
}
#end_block

#method_before
static byte[] toByteArray(Project.NameKey project, String pat) {
    return (project.toString() + ':' + pat).getBytes(UTF_8);
}
#method_after
byte[] toByteArray(Project.NameKey project) {
    return (project.toString() + ':' + pattern()).getBytes(UTF_8);
}
#end_block

#method_before
boolean match(String refName) {
    return pattern().matcher(refName).find();
}
#method_after
boolean match(String refName) {
    return regex().matcher(refName).find();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabled(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            locale = getLocale(cfg);
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains duplicate pathnames", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check for duplicate pathnames", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabledForRef(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            locale = getLocale(cfg);
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains duplicate pathnames", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check for duplicate pathnames", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabled(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains symbolic links", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on symbolic links", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabledForRef(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains symbolic links", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on symbolic links", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        String[] requiredFooters = cfg.getStringList(KEY_REQUIRED_FOOTER);
        if (requiredFooters.length > 0 && validatorConfig.isEnabled(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            List<CommitValidationMessage> messages = new LinkedList<>();
            Set<String> footers = FluentIterable.from(receiveEvent.commit.getFooterLines()).transform(new Function<FooterLine, String>() {

                @Override
                public String apply(FooterLine f) {
                    return f.getKey().toLowerCase(Locale.US);
                }
            }).toSet();
            for (int i = 0; i < requiredFooters.length; i++) {
                if (!footers.contains(requiredFooters[i].toLowerCase(Locale.US))) {
                    messages.add(new CommitValidationMessage("missing required footer: " + requiredFooters[i], true));
                }
            }
            if (!messages.isEmpty()) {
                throw new CommitValidationException("missing required footers in commit message", messages);
            }
        }
    } catch (NoSuchProjectException e) {
        throw new CommitValidationException("failed to check for required footers", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        String[] requiredFooters = cfg.getStringList(KEY_REQUIRED_FOOTER);
        if (requiredFooters.length > 0 && validatorConfig.isEnabledForRef(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            List<CommitValidationMessage> messages = new LinkedList<>();
            Set<String> footers = FluentIterable.from(receiveEvent.commit.getFooterLines()).transform(new Function<FooterLine, String>() {

                @Override
                public String apply(FooterLine f) {
                    return f.getKey().toLowerCase(Locale.US);
                }
            }).toSet();
            for (int i = 0; i < requiredFooters.length; i++) {
                if (!footers.contains(requiredFooters[i].toLowerCase(Locale.US))) {
                    messages.add(new CommitValidationMessage("missing required footer: " + requiredFooters[i], true));
                }
            }
            if (!messages.isEmpty()) {
                throw new CommitValidationException("missing required footers in commit message", messages);
            }
        }
    } catch (NoSuchProjectException e) {
        throw new CommitValidationException("failed to check for required footers", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabled(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, cfg.getStringList(KEY_INVALID_FILENAME_PATTERN));
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains files with an invalid filename", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on invalid file names", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabledForRef(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, cfg.getStringList(KEY_INVALID_FILENAME_PATTERN));
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains files with an invalid filename", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on invalid file names", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabled(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            int maxPathLength = cfg.getInt(KEY_MAX_PATH_LENGTH, 0);
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, maxPathLength);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains files with too long paths (max path length: " + maxPathLength + ")", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check for max file path length", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabledForRef(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            int maxPathLength = cfg.getInt(KEY_MAX_PATH_LENGTH, 0);
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, maxPathLength);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains files with too long paths (max path length: " + maxPathLength + ")", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check for max file path length", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabled(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, getBlockedTypes(cfg), isWhitelist(cfg));
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains blocked content type", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on content type", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabledForRef(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, getBlockedTypes(cfg), isWhitelist(cfg));
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains blocked content type", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on content type", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabled(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, cfg);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains files with a Windows line ending", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on Windows line endings", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabledForRef(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, cfg);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains files with a Windows line ending", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on Windows line endings", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabled(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, getBlockedExtensions(cfg));
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains files with blocked file extensions", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on file extensions", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabledForRef(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, getBlockedExtensions(cfg));
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains files with blocked file extensions", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on file extensions", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabled(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains submodules", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on submodules", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabledForRef(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains submodules", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on submodules", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
private boolean match(String refName, String refPattern) {
    return RefPatternMatcher.getMatcher(refPattern).match(refName, null);
}
#method_after
private static boolean match(String refName, String refPattern) {
    return RefPatternMatcher.getMatcher(refPattern).match(refName, null);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabled(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values(), cfg);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("includes files containing blocked keywords", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on blocked keywords", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName);
        if (isActive(cfg) && validatorConfig.isEnabledForRef(receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) {
            ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays.asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN)));
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values(), cfg);
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("includes files containing blocked keywords", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException | ExecutionException e) {
        throw new CommitValidationException("failed to check on blocked keywords", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
public static Id parse(final String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#method_after
public static Id parse(String str) {
    Id r = new Id();
    r.fromString(str);
    return r;
}
#end_block

#method_before
public void setFullName(final String name) {
    if (name != null && !name.trim().isEmpty()) {
        fullName = name.trim();
    } else {
        fullName = null;
    }
}
#method_after
public void setFullName(String name) {
    if (name != null && !name.trim().isEmpty()) {
        fullName = name.trim();
    } else {
        fullName = null;
    }
}
#end_block

#method_before
public void setPreferredEmail(final String addr) {
    preferredEmail = addr;
}
#method_after
public void setPreferredEmail(String addr) {
    preferredEmail = addr;
}
#end_block

#method_before
public void setStatus(final String status) {
    this.status = status;
}
#method_after
public void setStatus(String status) {
    this.status = status;
}
#end_block

#method_before
public void setUserName(final String userName) {
    this.userName = userName;
}
#method_after
public void setUserName(String userName) {
    this.userName = userName;
}
#end_block

#method_before
public ObjectId createNewTreeAndGetId(Repository repository) throws IOException {
    DirCache newTree = createNewTree(repository);
    return writeAndGetId(newTree, repository);
}
#method_after
public ObjectId createNewTreeAndGetId(Repository repository) throws IOException {
    DirCache newTree = createNewTree(repository);
    return writeAndGetId(repository, newTree);
}
#end_block

#method_before
private DirCache createNewTree(Repository repository) throws IOException {
    DirCache newTree = readBaseTree(repository);
    List<DirCacheEditor.PathEdit> pathEdits = getDesiredPathEdits(repository);
    applyPathEdits(newTree, pathEdits);
    return newTree;
}
#method_after
private DirCache createNewTree(Repository repository) throws IOException {
    DirCache newTree = readBaseTree(repository);
    List<DirCacheEditor.PathEdit> pathEdits = getPathEdits(repository);
    applyPathEdits(newTree, pathEdits);
    return newTree;
}
#end_block

#method_before
private void applyPathEdits(DirCache tree, List<DirCacheEditor.PathEdit> pathEdits) {
    DirCacheEditor dirCacheEditor = tree.editor();
    pathEdits.forEach(dirCacheEditor::add);
    dirCacheEditor.finish();
}
#method_after
private static void applyPathEdits(DirCache tree, List<DirCacheEditor.PathEdit> pathEdits) {
    DirCacheEditor dirCacheEditor = tree.editor();
    pathEdits.forEach(dirCacheEditor::add);
    dirCacheEditor.finish();
}
#end_block

#method_before
private ObjectId writeAndGetId(DirCache tree, Repository repository) throws IOException {
    try (ObjectInserter objectInserter = repository.newObjectInserter()) {
        ObjectId treeId = tree.writeTree(objectInserter);
        objectInserter.flush();
        return treeId;
    }
}
#method_after
private static ObjectId writeAndGetId(Repository repository, DirCache tree) throws IOException {
    try (ObjectInserter objectInserter = repository.newObjectInserter()) {
        ObjectId treeId = tree.writeTree(objectInserter);
        objectInserter.flush();
        return treeId;
    }
}
#end_block

#method_before
public static void display(final String token) {
    if (body.getView() == null || !body.getView().displayToken(token)) {
        dispatcher.display(token);
    }
}
#method_after
public static void display(final String token) {
    if (body.getView() == null || !body.getView().displayToken(token)) {
        dispatcher.display(token);
        updateUiLink(token);
    }
}
#end_block

#method_before
public static void display(final String token, final Screen view) {
    if (view.isRequiresSignIn() && !isSignedIn()) {
        doSignIn(token);
    } else {
        view.setToken(token);
        if (isSignedIn()) {
            LocalComments.saveInlineComments();
        }
        body.setView(view);
    }
}
#method_after
public static void display(final String token, final Screen view) {
    if (view.isRequiresSignIn() && !isSignedIn()) {
        doSignIn(token);
    } else {
        view.setToken(token);
        if (isSignedIn()) {
            LocalComments.saveInlineComments();
        }
        body.setView(view);
        updateUiLink(token);
    }
}
#end_block

#method_before
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    if (info().gerrit().webUis().contains(UiType.POLYGERRIT)) {
        btmmenu.add(new InlineLabel(" | "));
        Anchor a = new Anchor(C.polyGerrit(), History.getToken() + "?polygerrit=1");
        a.setStyleName("");
        btmmenu.add(a);
    }
    String reportBugUrl = info().gerrit().reportBugUrl();
    if (reportBugUrl != null) {
        String reportBugText = info().gerrit().reportBugText();
        Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#method_after
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    if (info().gerrit().webUis().contains(UiType.POLYGERRIT)) {
        btmmenu.add(new InlineLabel(" | "));
        uiSwitcherLink = new Anchor(C.newUi(), getUiSwitcherUrl(History.getToken()));
        uiSwitcherLink.setStyleName("");
        btmmenu.add(uiSwitcherLink);
    }
    String reportBugUrl = info().gerrit().reportBugUrl();
    if (reportBugUrl != null) {
        String reportBugText = info().gerrit().reportBugText();
        Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#end_block

#method_before
public void deleteVote(boolean onRevisionLevel) throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    PushOneCommit.Result r2 = amendChange(r.getChangeId());
    setApiUser(user);
    recommend(r.getChangeId());
    sender.clear();
    String endPoint = "/changes/" + r.getChangeId() + (onRevisionLevel ? ("/revisions/" + r2.getCommit().getName()) : "") + "/reviewers/" + user.getId().toString() + "/votes/Code-Review";
    RestResponse response = adminRestSession.delete(endPoint);
    response.assertNoContent();
    List<FakeEmailSender.Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    FakeEmailSender.Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">" + "\n");
    endPoint = "/changes/" + r.getChangeId() + (onRevisionLevel ? ("/revisions/" + r2.getCommit().getName()) : "") + "/reviewers/" + user.getId().toString() + "/votes";
    response = adminRestSession.get(endPoint);
    response.assertOK();
    Map<String, Short> m = newGson().fromJson(response.getReader(), new TypeToken<Map<String, Short>>() {
    }.getType());
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#method_after
private void deleteVote(boolean onRevisionLevel) throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    PushOneCommit.Result r2 = amendChange(r.getChangeId());
    setApiUser(user);
    recommend(r.getChangeId());
    sender.clear();
    String endPoint = "/changes/" + r.getChangeId() + (onRevisionLevel ? ("/revisions/" + r2.getCommit().getName()) : "") + "/reviewers/" + user.getId().toString() + "/votes/Code-Review";
    RestResponse response = adminRestSession.delete(endPoint);
    response.assertNoContent();
    List<FakeEmailSender.Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    FakeEmailSender.Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">" + "\n");
    endPoint = "/changes/" + r.getChangeId() + (onRevisionLevel ? ("/revisions/" + r2.getCommit().getName()) : "") + "/reviewers/" + user.getId().toString() + "/votes";
    response = adminRestSession.get(endPoint);
    response.assertOK();
    Map<String, Short> m = newGson().fromJson(response.getReader(), new TypeToken<Map<String, Short>>() {
    }.getType());
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#end_block

#method_before
private static Iterable<Account.Id> getReviewers(Collection<AccountInfo> r) {
    return Iterables.transform(r, a -> new Account.Id(a._accountId));
}
#method_after
private Iterable<Account.Id> getReviewers(Collection<AccountInfo> r) {
    return Iterables.transform(r, a -> new Account.Id(a._accountId));
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws AuthException, BadRequestException, OrmException, IOException {
    CurrentUser user = self.get();
    if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    }
    return reviewersUtil.suggestReviewers(rsrc.getNotes(), this, rsrc.getControl().getProjectControl(), getVisibility(rsrc), excludeGroups);
}
#method_after
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws AuthException, BadRequestException, OrmException, IOException {
    if (!self.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    return reviewersUtil.suggestReviewers(rsrc.getNotes(), this, rsrc.getControl().getProjectControl(), getVisibility(rsrc), excludeGroups);
}
#end_block

#method_before
@Override
public Response<?> apply(VoteResource rsrc, DeleteVoteInput input) throws RestApiException, UpdateException {
    if (input == null) {
        input = new DeleteVoteInput();
    }
    if (input.label != null && !rsrc.getLabel().equals(input.label)) {
        throw new BadRequestException("label must match URL");
    }
    if (input.notify == null) {
        input.notify = NotifyHandling.ALL;
    }
    ReviewerResource r = rsrc.getReviewer();
    Change change = r.getChange();
    if (input.patchSet != 0 && input.patchSet != change.currentPatchSetId().get()) {
        // can't delete a vote if it's not on current patch set
        throw new RestApiException("Cannot delete the vote of a stale patch set");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), r.getControl().getUser(), TimeUtil.nowTs())) {
        bu.addOp(change.getId(), new Op(r.getReviewerUser().getAccountId(), rsrc.getLabel(), input));
        bu.execute();
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(VoteResource rsrc, DeleteVoteInput input) throws RestApiException, UpdateException {
    if (input == null) {
        input = new DeleteVoteInput();
    }
    if (input.label != null && !rsrc.getLabel().equals(input.label)) {
        throw new BadRequestException("label must match URL");
    }
    if (input.notify == null) {
        input.notify = NotifyHandling.ALL;
    }
    ReviewerResource r = rsrc.getReviewer();
    Change change = r.getChange();
    if (r.getRevisionResource() != null && !r.getRevisionResource().isCurrent()) {
        throw new MethodNotAllowedException("Cannot delete vote on non-current patch set");
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), r.getControl().getUser(), TimeUtil.nowTs())) {
        bu.addOp(change.getId(), new Op(r.getReviewerUser().getAccountId(), rsrc.getLabel(), input));
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        ListMultimap<String, String> external = MultimapBuilder.hashKeys().arrayListValues().build();
        for (ExternalIncludedIn ext : includedIn) {
            Multimap<String, String> extIncludedIns = ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches());
            if (extIncludedIns != null) {
                external.putAll(extIncludedIns);
            }
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external.asMap() : null));
    }
}
#method_after
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInResolver.Result d = IncludedInResolver.resolve(r, rw, rev);
        ListMultimap<String, String> external = MultimapBuilder.hashKeys().arrayListValues().build();
        for (ExternalIncludedIn ext : includedIn) {
            ListMultimap<String, String> extIncludedIns = ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches());
            if (extIncludedIns != null) {
                external.putAll(extIncludedIns);
            }
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external.asMap() : null));
    }
}
#end_block

#method_before
private ListMultimap<String, ?> extractParams(final Audit note, final GerritCall call) {
    ListMultimap<String, Object> args = ArrayListMultimap.create();
    Object[] params = call.getParams();
    for (int i = 0; i < params.length; i++) {
        args.put("$" + i, params[i]);
    }
    for (int idx : note.obfuscate()) {
        args.removeAll("$" + idx);
        args.put("$" + idx, "*****");
    }
    return args;
}
#method_after
private ListMultimap<String, ?> extractParams(Audit note, GerritCall call) {
    ListMultimap<String, Object> args = ArrayListMultimap.create();
    Object[] params = call.getParams();
    for (int i = 0; i < params.length; i++) {
        args.put("$" + i, params[i]);
    }
    for (int idx : note.obfuscate()) {
        args.removeAll("$" + idx);
        args.put("$" + idx, "*****");
    }
    return args;
}
#end_block

#method_before
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isRead(req)) {
        user.setAccessPath(AccessPath.REST_API);
        CurrentUser.PropertyKey<AccountExternalId.Key> k = CurrentUser.PropertyKey.create();
        user.put(k, globals.webSession.get().getLastLoginExternalId());
    } else if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
        throw new AuthException("Invalid authentication method. In order to authenticate, " + "prefix the REST endpoint URL with /a/ (e.g. http://example.com/a/projects/).");
    }
}
#method_after
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isRead(req)) {
        user.setAccessPath(AccessPath.REST_API);
        user.setLastLoginExternalIdKey(globals.webSession.get().getLastLoginExternalId());
    } else if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
        throw new AuthException("Invalid authentication method. In order to authenticate, " + "prefix the REST endpoint URL with /a/ (e.g. http://example.com/a/projects/).");
    }
}
#end_block

#method_before
@Override
public void setParams(ListMultimap<String, String> params) {
    // The --query2 option is defined in QueryGroups
    this.hasQuery2 = params.containsKey("query2");
}
#method_after
@Override
public void setParams(ListMultimap<String, String> params) throws BadRequestException {
    if (params.containsKey("query") && params.containsKey("query2")) {
        throw new BadRequestException("\"query\" and \"query2\" options are mutually exclusive");
    }
    // The --query2 option is defined in QueryGroups
    this.hasQuery2 = params.containsKey("query2");
}
#end_block

#method_before
@Test
public void getExternalIDs() throws Exception {
    Collection<AccountExternalId> expectedIds = accountCache.get(user.getId()).getExternalIds();
    List<AccountExternalIdInfo> expectedIdInfos = new ArrayList<>();
    for (AccountExternalId id : expectedIds) {
        id.setCanDelete(!id.getExternalId().equals("username:user"));
        id.setTrusted(true);
        expectedIdInfos.add(toInfo(id));
    }
    RestResponse response = userRestSession.get("/accounts/self/external.ids");
    response.assertOK();
    List<AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new TypeToken<List<AccountExternalIdInfo>>() {
    }.getType());
    Collections.sort(expectedIdInfos);
    Collections.sort(results);
    assertThat(results).containsExactlyElementsIn(expectedIdInfos);
}
#method_after
@Test
public void getExternalIDs() throws Exception {
    Collection<AccountExternalId> expectedIds = accountCache.get(user.getId()).getExternalIds();
    List<AccountExternalIdInfo> expectedIdInfos = new ArrayList<>();
    for (AccountExternalId id : expectedIds) {
        id.setCanDelete(!id.getExternalId().equals("username:" + user.username));
        id.setTrusted(true);
        expectedIdInfos.add(toInfo(id));
    }
    RestResponse response = userRestSession.get("/accounts/self/external.ids");
    response.assertOK();
    List<AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new TypeToken<List<AccountExternalIdInfo>>() {
    }.getType());
    Collections.sort(expectedIdInfos);
    Collections.sort(results);
    assertThat(results).containsExactlyElementsIn(expectedIdInfos);
}
#end_block

#method_before
public String generateToken(String operation, AnyLongObjectId id) {
    if (key.isPresent()) {
        try {
            byte[] initVector = new byte[IV_LENGTH];
            rndm.nextBytes(initVector);
            Cipher cipher = cipher(initVector, Cipher.ENCRYPT_MODE);
            return Base64.encodeBytes(Bytes.concat(initVector, cipher.doFinal(String.format("%s-%s-%s", operation, id.name(), timeout()).getBytes(StandardCharsets.UTF_8))));
        } catch (GeneralSecurityException e) {
            log.error("Token generation failed with error", e);
        }
    }
    return "not:required";
}
#method_after
public String generateToken(String operation, AnyLongObjectId id) {
    try {
        byte[] initVector = new byte[IV_LENGTH];
        rndm.nextBytes(initVector);
        Cipher cipher = cipher(initVector, Cipher.ENCRYPT_MODE);
        return Base64.encodeBytes(Bytes.concat(initVector, cipher.doFinal(String.format("%s-%s-%s", operation, id.name(), timeout()).getBytes(StandardCharsets.UTF_8))));
    } catch (GeneralSecurityException e) {
        log.error("Token generation failed with error", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public boolean verifyAgainstToken(String token, String operation, AnyLongObjectId id) {
    if (!key.isPresent()) {
        return true;
    }
    if (Strings.isNullOrEmpty(token)) {
        return false;
    }
    byte[] bytes = Base64.decode(token);
    byte[] initVector = Arrays.copyOf(bytes, IV_LENGTH);
    try {
        Cipher cipher = cipher(initVector, Cipher.DECRYPT_MODE);
        String data = new String(cipher.doFinal(Arrays.copyOfRange(bytes, IV_LENGTH, bytes.length)), StandardCharsets.UTF_8);
        String oid = id.name();
        String prefix = String.format("%s-%s-", operation, oid);
        return data.startsWith(prefix) && onTime(data.substring(prefix.length()), operation, oid);
    } catch (GeneralSecurityException e) {
        log.error("Exception was thrown during token verification", e);
    }
    return false;
}
#method_after
public boolean verifyAgainstToken(String token, String operation, AnyLongObjectId id) {
    if (Strings.isNullOrEmpty(token)) {
        return false;
    }
    byte[] bytes = Base64.decode(token);
    byte[] initVector = Arrays.copyOf(bytes, IV_LENGTH);
    try {
        Cipher cipher = cipher(initVector, Cipher.DECRYPT_MODE);
        String data = new String(cipher.doFinal(Arrays.copyOfRange(bytes, IV_LENGTH, bytes.length)), StandardCharsets.UTF_8);
        String oid = id.name();
        String prefix = String.format("%s-%s-", operation, oid);
        return data.startsWith(prefix) && onTime(data.substring(prefix.length()), operation, oid);
    } catch (GeneralSecurityException e) {
        log.error("Exception was thrown during token verification", e);
    }
    return false;
}
#end_block

#method_before
private boolean onTime(String dateTime, String operation, String id) {
    DateTime deadline = ISODateTimeFormat.dateTimeParser().parseDateTime(dateTime);
    if (deadline.isBeforeNow()) {
        log.info("Operation {} on id {} timed out", operation, id);
        return false;
    }
    return true;
}
#method_after
boolean onTime(String dateTime, String operation, String id) {
    String now = DATE_TIME.print(now());
    if (now.compareTo(dateTime) > 0) {
        log.info("Operation {} on id {} timed out", operation, id);
        return false;
    }
    return true;
}
#end_block

#method_before
private String timeout() {
    DateTime now = now();
    return ISODateTimeFormat.dateTime().print(now.plusSeconds(timeout));
}
#method_after
private String timeout() {
    return DATE_TIME.print(now().plusSeconds(timeout));
}
#end_block

#method_before
private Cipher cipher(byte[] initVector, int mode) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, InvalidKeyException, InvalidAlgorithmParameterException {
    IvParameterSpec spec = new IvParameterSpec(initVector);
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
    AlgorithmParameters params = AlgorithmParameters.getInstance(ALGORITHM);
    params.init(spec);
    cipher.init(mode, key.get(), params);
    return cipher;
}
#method_after
private Cipher cipher(byte[] initVector, int mode) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, InvalidKeyException, InvalidAlgorithmParameterException {
    IvParameterSpec spec = new IvParameterSpec(initVector);
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
    AlgorithmParameters params = AlgorithmParameters.getInstance(ALGORITHM);
    params.init(spec);
    cipher.init(mode, key, params);
    return cipher;
}
#end_block

#method_before
private Optional<SecretKey> generateKey() {
    try {
        KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM);
        generator.init(128, rndm);
        return Optional.of(generator.generateKey());
    } catch (NoSuchAlgorithmException e) {
        log.error("Generating key failed with error", e);
    }
    return Optional.absent();
}
#method_after
private SecretKey generateKey() {
    try {
        KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM);
        generator.init(128, rndm);
        return generator.generateKey();
    } catch (NoSuchAlgorithmException e) {
        log.error("Generating key failed with error", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public void setLastLoginExternalIdKey(AccountExternalId.Key externalIdKey) {
    lastLoginExternalIdPropertyKey = PropertyKey.create();
    put(lastLoginExternalIdPropertyKey, externalIdKey);
}
#method_after
public void setLastLoginExternalIdKey(AccountExternalId.Key externalIdKey) {
    put(lastLoginExternalIdPropertyKey, externalIdKey);
}
#end_block

#method_before
@Operator
public Predicate<AccountGroup> description(String description) {
    return GroupPredicates.description(description);
}
#method_after
@Operator
public Predicate<AccountGroup> description(String description) throws QueryParseException {
    if (Strings.isNullOrEmpty(description)) {
        throw error("description operator requires a value");
    }
    return GroupPredicates.description(description);
}
#end_block

#method_before
public static Predicate<AccountGroup> defaultPredicate(String query) {
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<AccountGroup>> preds = Lists.newArrayListWithCapacity(5);
    preds.add(uuid(new AccountGroup.UUID(query)));
    preds.add(name(query));
    preds.add(inname(query));
    preds.add(description(query));
    preds.add(owner(query));
    // predicates.
    return Predicate.or(preds);
}
#method_after
public static Predicate<AccountGroup> defaultPredicate(String query) {
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<AccountGroup>> preds = Lists.newArrayListWithCapacity(5);
    preds.add(uuid(new AccountGroup.UUID(query)));
    preds.add(name(query));
    preds.add(inname(query));
    if (!Strings.isNullOrEmpty(query)) {
        preds.add(description(query));
    }
    preds.add(owner(query));
    return Predicate.or(preds);
}
#end_block

#method_before
@Test
public void byDescription() throws Exception {
    assertQuery("description:non-existing");
    GroupInfo group1 = createGroupWithDescription(name("group1"), "This is a test group.");
    GroupInfo group2 = createGroupWithDescription(name("group2"), "ANOTHER TEST GROUP.");
    createGroupWithDescription(name("group3"), "Maintainers of project foo.");
    assertQuery("description:test", group1, group2);
}
#method_after
@Test
public void byDescription() throws Exception {
    GroupInfo group1 = createGroupWithDescription(name("group1"), "This is a test group.");
    GroupInfo group2 = createGroupWithDescription(name("group2"), "ANOTHER TEST GROUP.");
    createGroupWithDescription(name("group3"), "Maintainers of project foo.");
    assertQuery("description:test", group1, group2);
    assertQuery("description:non-existing");
    exception.expect(BadRequestException.class);
    exception.expectMessage("description operator requires a value");
    assertQuery("description:\"\"");
}
#end_block

#method_before
protected GroupInfo createGroup(String name, AccountInfo... members) throws RestApiException {
    return createGroupWithDescription(name, null, members);
}
#method_after
protected GroupInfo createGroup(String name, AccountInfo... members) throws Exception {
    return createGroupWithDescription(name, null, members);
}
#end_block

#method_before
protected GroupInfo createGroupWithDescription(String name, String description, AccountInfo... members) throws RestApiException {
    GroupInput in = new GroupInput();
    in.name = name;
    in.description = description;
    in.members = Arrays.asList(members).stream().map(a -> String.valueOf(a._accountId)).collect(toList());
    return gApi.groups().create(in).get();
}
#method_after
protected GroupInfo createGroupWithDescription(String name, String description, AccountInfo... members) throws Exception {
    GroupInput in = new GroupInput();
    in.name = name;
    in.description = description;
    in.members = Arrays.asList(members).stream().map(a -> String.valueOf(a._accountId)).collect(toList());
    return gApi.groups().create(in).get();
}
#end_block

#method_before
protected GroupInfo createGroupWithOwner(String name, GroupInfo ownerGroup) throws RestApiException {
    GroupInput in = new GroupInput();
    in.name = name;
    in.ownerId = ownerGroup.id;
    return gApi.groups().create(in).get();
}
#method_after
protected GroupInfo createGroupWithOwner(String name, GroupInfo ownerGroup) throws Exception {
    GroupInput in = new GroupInput();
    in.name = name;
    in.ownerId = ownerGroup.id;
    return gApi.groups().create(in).get();
}
#end_block

#method_before
protected GroupInfo createGroupThatIsVisibleToAll(String name) throws RestApiException {
    GroupInput in = new GroupInput();
    in.name = name;
    in.visibleToAll = true;
    return gApi.groups().create(in).get();
}
#method_after
protected GroupInfo createGroupThatIsVisibleToAll(String name) throws Exception {
    GroupInput in = new GroupInput();
    in.name = name;
    in.visibleToAll = true;
    return gApi.groups().create(in).get();
}
#end_block

#method_before
protected GroupInfo getGroup(AccountGroup.UUID uuid) throws RestApiException {
    return gApi.groups().id(uuid.get()).get();
}
#method_after
protected GroupInfo getGroup(AccountGroup.UUID uuid) throws Exception {
    return gApi.groups().id(uuid.get()).get();
}
#end_block

#method_before
@Test
public void byDescription() throws Exception {
    assertQuery("description:non-existing");
    GroupInfo group1 = createGroupWithDescription(name("group1"), "This is a test group.");
    GroupInfo group2 = createGroupWithDescription(name("group2"), "ANOTHER TEST GROUP.");
    createGroupWithDescription(name("group3"), "Maintainers of project foo.");
    assertQuery("description:test", group1, group2);
}
#method_after
@Test
public void byDescription() throws Exception {
    GroupInfo group1 = createGroupWithDescription(name("group1"), "This is a test group.");
    GroupInfo group2 = createGroupWithDescription(name("group2"), "ANOTHER TEST GROUP.");
    createGroupWithDescription(name("group3"), "Maintainers of project foo.");
    assertQuery("description:test", group1, group2);
    assertQuery("description:non-existing");
    exception.expect(BadRequestException.class);
    exception.expectMessage("description operator requires a value");
    assertQuery("description:\"\"");
}
#end_block

#method_before
protected GroupInfo createGroup(String name, AccountInfo... members) throws RestApiException {
    return createGroupWithDescription(name, null, members);
}
#method_after
protected GroupInfo createGroup(String name, AccountInfo... members) throws Exception {
    return createGroupWithDescription(name, null, members);
}
#end_block

#method_before
protected GroupInfo createGroupWithDescription(String name, String description, AccountInfo... members) throws RestApiException {
    GroupInput in = new GroupInput();
    in.name = name;
    in.description = description;
    in.members = Arrays.asList(members).stream().map(a -> String.valueOf(a._accountId)).collect(toList());
    return gApi.groups().create(in).get();
}
#method_after
protected GroupInfo createGroupWithDescription(String name, String description, AccountInfo... members) throws Exception {
    GroupInput in = new GroupInput();
    in.name = name;
    in.description = description;
    in.members = Arrays.asList(members).stream().map(a -> String.valueOf(a._accountId)).collect(toList());
    return gApi.groups().create(in).get();
}
#end_block

#method_before
protected GroupInfo getGroup(AccountGroup.UUID uuid) throws RestApiException {
    return gApi.groups().id(uuid.get()).get();
}
#method_after
protected GroupInfo getGroup(AccountGroup.UUID uuid) throws Exception {
    return gApi.groups().id(uuid.get()).get();
}
#end_block

#method_before
@Operator
public Predicate<AccountGroup> description(String description) {
    return GroupPredicates.description(description);
}
#method_after
@Operator
public Predicate<AccountGroup> description(String description) throws QueryParseException {
    if (Strings.isNullOrEmpty(description)) {
        throw error("description operator requires a value");
    }
    return GroupPredicates.description(description);
}
#end_block

#method_before
@Test
public void byUuid() throws Exception {
    GroupInfo group = createGroup(name("group"));
    assertQuery("uuid:" + group.id, group);
}
#method_after
@Test
public void byUuid() throws Exception {
    assertQuery("uuid:6d70856bc40ded50f2585c4c0f7e179f3544a272");
    assertQuery("uuid:non-existing");
    GroupInfo group = createGroup(name("group"));
    assertQuery("uuid:" + group.id, group);
}
#end_block

#method_before
protected GroupInfo createGroup(String name, AccountInfo... members) throws RestApiException {
    GroupInput in = new GroupInput();
    in.name = name;
    in.members = Arrays.asList(members).stream().map(a -> String.valueOf(a._accountId)).collect(toList());
    return gApi.groups().create(in).get();
}
#method_after
protected GroupInfo createGroup(String name, AccountInfo... members) throws Exception {
    GroupInput in = new GroupInput();
    in.name = name;
    in.members = Arrays.asList(members).stream().map(a -> String.valueOf(a._accountId)).collect(toList());
    return gApi.groups().create(in).get();
}
#end_block

#method_before
protected GroupInfo getGroup(AccountGroup.UUID uuid) throws RestApiException {
    return gApi.groups().id(uuid.get()).get();
}
#method_after
protected GroupInfo getGroup(AccountGroup.UUID uuid) throws Exception {
    return gApi.groups().id(uuid.get()).get();
}
#end_block

#method_before
@Override
public void onCreateGroup(AccountGroup.NameKey newGroupName) {
    byName.invalidate(newGroupName.get());
}
#method_after
@Override
public void onCreateGroup(AccountGroup.NameKey newGroupName) throws IOException {
    byName.invalidate(newGroupName.get());
    indexer.get().index(get(newGroupName).getGroupUUID());
}
#end_block

#method_before
private static Term idTerm(AccountGroup as) {
    return idTerm(as.getGroupUUID());
}
#method_after
private static Term idTerm(AccountGroup group) {
    return idTerm(group.getGroupUUID());
}
#end_block

#method_before
@Override
public void replace(AccountGroup as) throws IOException {
    try {
        // No parts of FillArgs are currently required, just use null.
        replace(idTerm(as), toDocument(as, null)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public void replace(AccountGroup group) throws IOException {
    try {
        // No parts of FillArgs are currently required, just use null.
        replace(idTerm(group), toDocument(group, null)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private AccountGroup toAccountGroup(Document doc) {
    AccountGroup.UUID uuid = new AccountGroup.UUID(doc.getField(UUID.getName()).stringValue());
    // document (of which there shouldn't be any.
    return groupCache.get(uuid);
}
#method_after
private AccountGroup toAccountGroup(Document doc) {
    AccountGroup.UUID uuid = new AccountGroup.UUID(doc.getField(UUID.getName()).stringValue());
    // document (of which there shouldn't be any).
    return groupCache.get(uuid);
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    stdout.print(auth.authorize(user, args));
}
#method_after
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    LfsSshPluginAuth pluginAuth = auth.get();
    if (pluginAuth == null) {
        throw new Failure(1, "Server configuration error:" + " LFS auth over SSH is not properly configured.");
    }
    stdout.print(pluginAuth.authenticate(user.get(), args));
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    AccountExternalId id = dbProvider.get().accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME, user.getUserName()));
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    id.setPassword(newPassword);
    dbProvider.get().accountExternalIds().update(Collections.singleton(id));
    externalIdCache.update(id);
    accountCache.evict(user.getAccountId());
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#method_after
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    AccountExternalId id = dbProvider.get().accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME, user.getUserName()));
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    id.setPassword(newPassword);
    dbProvider.get().accountExternalIds().update(Collections.singleton(id));
    externalIdCache.onUpdate(id);
    accountCache.evict(user.getAccountId());
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#end_block

#method_before
public Account.Id lookup(String externalId) throws AccountException {
    try {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(externalId);
        return accountState != null ? accountState.getAccount().getId() : null;
    } catch (OrmException e) {
        throw new AccountException("Cannot lookup account " + externalId, e);
    }
}
#method_after
public Optional<Account.Id> lookup(String externalId) throws AccountException {
    try {
        AccountState accountState = accountQueryProvider.get().oneByExternalId(externalId);
        return accountState != null ? Optional.of(accountState.getAccount().getId()) : Optional.empty();
    } catch (OrmException e) {
        throw new AccountException("Cannot lookup account " + externalId, e);
    }
}
#end_block

#method_before
private void update(ReviewDb db, AuthRequest who, AccountExternalId extId) throws OrmException, IOException {
    IdentifiedUser user = userFactory.create(extId.getAccountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.getEmailAddress();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        extId.setEmailAddress(newEmail);
        db.accountExternalIds().update(Collections.singleton(extId));
        externalIdCache.update(extId);
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#method_after
private void update(ReviewDb db, AuthRequest who, AccountExternalId extId) throws OrmException, IOException {
    IdentifiedUser user = userFactory.create(extId.getAccountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.getEmailAddress();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        extId.setEmailAddress(newEmail);
        db.accountExternalIds().update(Collections.singleton(extId));
        externalIdCache.onUpdate(extId);
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#end_block

#method_before
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    Account account = new Account(newId, TimeUtil.nowTs());
    AccountExternalId extId = createId(newId, who);
    extId.setEmailAddress(who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.getEmailAddress());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        AccountExternalId existingExtId = db.accountExternalIds().get(extId.getKey());
        if (existingExtId != null && !existingExtId.getAccountId().equals(extId.getAccountId())) {
            // external ID is assigned to another account, do not overwrite
            db.accounts().delete(Collections.singleton(account));
            throw new AccountException("Cannot assign external ID \"" + extId.getExternalId() + "\" to account " + newId + "; external ID already in use.");
        }
        db.accountExternalIds().upsert(Collections.singleton(extId));
        externalIdCache.update(extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    byIdCache.evict(account.getId());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.getKey(), true);
}
#method_after
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    Account account = new Account(newId, TimeUtil.nowTs());
    AccountExternalId extId = createId(newId, who);
    extId.setEmailAddress(who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.getEmailAddress());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        AccountExternalId existingExtId = db.accountExternalIds().get(extId.getKey());
        if (existingExtId != null && !existingExtId.getAccountId().equals(extId.getAccountId())) {
            // external ID is assigned to another account, do not overwrite
            db.accounts().delete(Collections.singleton(account));
            throw new AccountException("Cannot assign external ID \"" + extId.getExternalId() + "\" to account " + newId + "; external ID already in use.");
        }
        db.accountExternalIds().upsert(Collections.singleton(extId));
        externalIdCache.onUpdate(extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    byIdCache.evict(account.getId());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.getKey(), true);
}
#end_block

#method_before
private void handleSettingUserNameFailure(ReviewDb db, Account account, AccountExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        db.accounts().delete(Collections.singleton(account));
        db.accountExternalIds().delete(Collections.singleton(extId));
        externalIdCache.remove(extId);
        throw new AccountUserNameException(errorMessage, e);
    }
}
#method_after
private void handleSettingUserNameFailure(ReviewDb db, Account account, AccountExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        db.accounts().delete(Collections.singleton(account));
        db.accountExternalIds().delete(Collections.singleton(extId));
        externalIdCache.onRemove(extId);
        throw new AccountUserNameException(errorMessage, e);
    }
}
#end_block

#method_before
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        List<AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), externalIdCache.byAccount(to));
        if (!filteredKeysByScheme.isEmpty() && (filteredKeysByScheme.size() > 1 || !filteredKeysByScheme.contains(key))) {
            db.accountExternalIds().deleteKeys(filteredKeysByScheme);
            externalIdCache.remove(to, filteredKeysByScheme);
        }
        byIdCache.evict(to);
        return link(to, who);
    }
}
#method_after
public AuthResult updateLink(Account.Id to, AuthRequest who) throws OrmException, AccountException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        List<AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), externalIdCache.byAccount(to));
        if (!filteredKeysByScheme.isEmpty() && (filteredKeysByScheme.size() > 1 || !filteredKeysByScheme.contains(key))) {
            db.accountExternalIds().deleteKeys(filteredKeysByScheme);
            externalIdCache.onRemove(to, filteredKeysByScheme);
        }
        byIdCache.evict(to);
        return link(to, who);
    }
}
#end_block

#method_before
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(key);
        if (extId != null) {
            if (!extId.getAccountId().equals(from)) {
                throw new AccountException("Identity '" + key.get() + "' in use by another account");
            }
            db.accountExternalIds().delete(Collections.singleton(extId));
            externalIdCache.remove(extId);
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                }
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(from);
            }
        } else {
            throw new AccountException("Identity '" + key.get() + "' not found");
        }
        return new AuthResult(from, key, false);
    }
}
#method_after
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = getAccountExternalId(key);
        if (extId != null) {
            if (!extId.getAccountId().equals(from)) {
                throw new AccountException("Identity '" + key.get() + "' in use by another account");
            }
            db.accountExternalIds().delete(Collections.singleton(extId));
            externalIdCache.onRemove(extId);
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                }
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(from);
            }
        } else {
            throw new AccountException("Identity '" + key.get() + "' not found");
        }
        return new AuthResult(from, key, false);
    }
}
#end_block

#method_before
@Override
public Response<?> apply(GpgKey rsrc, Input input) throws ResourceConflictException, PGPException, OrmException, IOException {
    PGPPublicKey key = rsrc.getKeyRing().getPublicKey();
    AccountExternalId.Key extIdKey = new AccountExternalId.Key(AccountExternalId.SCHEME_GPGKEY, BaseEncoding.base16().encode(key.getFingerprint()));
    db.get().accountExternalIds().deleteKeys(Collections.singleton(extIdKey));
    externalIdCache.remove(rsrc.getUser().getAccountId(), extIdKey);
    accountCache.evict(rsrc.getUser().getAccountId());
    try (PublicKeyStore store = storeProvider.get()) {
        store.remove(rsrc.getKeyRing().getPublicKey().getFingerprint());
        CommitBuilder cb = new CommitBuilder();
        PersonIdent committer = serverIdent.get();
        cb.setAuthor(rsrc.getUser().newCommitterIdent(committer.getWhen(), committer.getTimeZone()));
        cb.setCommitter(committer);
        cb.setMessage("Delete public key " + keyIdToString(key.getKeyID()));
        RefUpdate.Result saveResult = store.save(cb);
        switch(saveResult) {
            case NO_CHANGE:
            case FAST_FORWARD:
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new ResourceConflictException("Failed to delete public key: " + saveResult);
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GpgKey rsrc, Input input) throws ResourceConflictException, PGPException, OrmException, IOException {
    PGPPublicKey key = rsrc.getKeyRing().getPublicKey();
    AccountExternalId.Key extIdKey = new AccountExternalId.Key(AccountExternalId.SCHEME_GPGKEY, BaseEncoding.base16().encode(key.getFingerprint()));
    db.get().accountExternalIds().deleteKeys(Collections.singleton(extIdKey));
    externalIdCache.onRemove(rsrc.getUser().getAccountId(), extIdKey);
    accountCache.evict(rsrc.getUser().getAccountId());
    try (PublicKeyStore store = storeProvider.get()) {
        store.remove(rsrc.getKeyRing().getPublicKey().getFingerprint());
        CommitBuilder cb = new CommitBuilder();
        PersonIdent committer = serverIdent.get();
        cb.setAuthor(rsrc.getUser().newCommitterIdent(committer.getWhen(), committer.getTimeZone()));
        cb.setCommitter(committer);
        cb.setMessage("Delete public key " + keyIdToString(key.getKeyID()));
        RefUpdate.Result saveResult = store.save(cb);
        switch(saveResult) {
            case NO_CHANGE:
            case FAST_FORWARD:
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NEW:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new ResourceConflictException("Failed to delete public key: " + saveResult);
        }
    }
    return Response.none();
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, ListKey.class, new TypeLiteral<Multimap<Account.Id, AccountExternalId>>() {
            }).maximumWeight(1).loader(Loader.class);
            bind(ExternalIdCacheImpl.class);
            bind(ExternalIdCache.class).to(ExternalIdCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, AllKey.class, new TypeLiteral<ImmutableSetMultimap<Account.Id, AccountExternalId>>() {
            }).maximumWeight(1).loader(Loader.class);
            bind(ExternalIdCacheImpl.class);
            bind(ExternalIdCache.class).to(ExternalIdCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public void onCreate(Iterable<AccountExternalId> extIds) {
    lock.lock();
    try {
        Multimap<Account.Id, AccountExternalId> n = MultimapBuilder.hashKeys().arrayListValues().build(extIdsByAccount.get(ListKey.ALL));
        for (AccountExternalId extId : extIds) {
            n.put(extId.getAccountId(), extId);
        }
        extIdsByAccount.put(ListKey.ALL, ImmutableMultimap.copyOf(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list avaliable projects", e);
    } finally {
        lock.unlock();
    }
}
#method_after
@Override
public void onCreate(Iterable<AccountExternalId> extIds) {
    lock.lock();
    try {
        Multimap<Account.Id, AccountExternalId> n = MultimapBuilder.hashKeys().arrayListValues().build(extIdsByAccount.get(AllKey.ALL));
        for (AccountExternalId extId : extIds) {
            n.put(extId.getAccountId(), extId);
        }
        extIdsByAccount.put(AllKey.ALL, ImmutableSetMultimap.copyOf(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list external IDs", e);
    } finally {
        lock.unlock();
    }
}
#end_block

#method_before
@Override
public Collection<AccountExternalId> byAccount(Account.Id accountId) {
    try {
        return ImmutableSet.copyOf(extIdsByAccount.get(ListKey.ALL).get(accountId));
    } catch (ExecutionException e) {
        log.warn("Cannot list external ids", e);
        return Collections.emptySet();
    }
}
#method_after
@Override
public Collection<AccountExternalId> byAccount(Account.Id accountId) {
    try {
        return extIdsByAccount.get(AllKey.ALL).get(accountId);
    } catch (ExecutionException e) {
        log.warn("Cannot list external ids", e);
        return Collections.emptySet();
    }
}
#end_block

#method_before
@Override
public Multimap<Account.Id, AccountExternalId> load(ListKey key) throws Exception {
    try (ReviewDb db = schema.open()) {
        Multimap<Account.Id, AccountExternalId> extIdsByAccount = MultimapBuilder.hashKeys().arrayListValues().build();
        for (AccountExternalId extId : db.accountExternalIds().all()) {
            extIdsByAccount.put(extId.getAccountId(), extId);
        }
        return ImmutableMultimap.copyOf(extIdsByAccount);
    }
}
#method_after
@Override
public ImmutableSetMultimap<Account.Id, AccountExternalId> load(AllKey key) throws Exception {
    try (ReviewDb db = schema.open()) {
        Multimap<Account.Id, AccountExternalId> extIdsByAccount = MultimapBuilder.hashKeys().arrayListValues().build();
        for (AccountExternalId extId : db.accountExternalIds().all()) {
            extIdsByAccount.put(extId.getAccountId(), extId);
        }
        return ImmutableSetMultimap.copyOf(extIdsByAccount);
    }
}
#end_block

#method_before
@After
public void restoreExternalIds() throws Exception {
    if (savedExternalIds != null) {
        // savedExternalIds is null when we don't run SSH tests and the assume in
        // @Before in AbstractDaemonTest prevents this class' @Before method from
        // being executed.
        Collection<AccountExternalId> adminExtIds = getExternalIds(admin);
        db.accountExternalIds().delete(adminExtIds);
        externalIdCache.remove(adminExtIds);
        Collection<AccountExternalId> userExtIds = getExternalIds(user);
        db.accountExternalIds().delete(userExtIds);
        externalIdCache.remove(userExtIds);
        db.accountExternalIds().insert(savedExternalIds);
        externalIdCache.onCreate(savedExternalIds);
    }
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
}
#method_after
@After
public void restoreExternalIds() throws Exception {
    if (savedExternalIds != null) {
        // savedExternalIds is null when we don't run SSH tests and the assume in
        // @Before in AbstractDaemonTest prevents this class' @Before method from
        // being executed.
        Collection<AccountExternalId> adminExtIds = getExternalIds(admin);
        db.accountExternalIds().delete(adminExtIds);
        externalIdCache.onRemove(adminExtIds);
        Collection<AccountExternalId> userExtIds = getExternalIds(user);
        db.accountExternalIds().delete(userExtIds);
        externalIdCache.onRemove(userExtIds);
        db.accountExternalIds().insert(savedExternalIds);
        externalIdCache.onCreate(savedExternalIds);
    }
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
}
#end_block

#method_before
@Override
public Set<AccountExternalId.Key> call() throws OrmException, IOException {
    final Map<AccountExternalId.Key, AccountExternalId> have = have();
    List<AccountExternalId> toDelete = new ArrayList<>();
    for (AccountExternalId.Key k : keys) {
        final AccountExternalId id = have.get(k);
        if (id != null && id.canDelete()) {
            toDelete.add(id);
        }
    }
    if (!toDelete.isEmpty()) {
        db.accountExternalIds().delete(toDelete);
        externalIdCache.remove(toDelete);
        accountCache.evict(user.getAccountId());
        for (AccountExternalId e : toDelete) {
            byEmailCache.evict(e.getEmailAddress());
        }
    }
    return toKeySet(toDelete);
}
#method_after
@Override
public Set<AccountExternalId.Key> call() throws OrmException, IOException {
    final Map<AccountExternalId.Key, AccountExternalId> have = have();
    List<AccountExternalId> toDelete = new ArrayList<>();
    for (AccountExternalId.Key k : keys) {
        final AccountExternalId id = have.get(k);
        if (id != null && id.canDelete()) {
            toDelete.add(id);
        }
    }
    if (!toDelete.isEmpty()) {
        db.accountExternalIds().delete(toDelete);
        externalIdCache.onRemove(toDelete);
        accountCache.evict(user.getAccountId());
        for (AccountExternalId e : toDelete) {
            byEmailCache.evict(e.getEmailAddress());
        }
    }
    return toKeySet(toDelete);
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
        externalIdCache.onCreate(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
            externalIdCache.onCreate(extMailto);
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
                externalIdCache.remove(extUser);
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, AccountInput input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new AccountInput();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!OutgoingEmailValidator.isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
        externalIdCache.onCreate(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
            externalIdCache.onCreate(extMailto);
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
                externalIdCache.onRemove(extUser);
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    indexer.index(id);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
@Override
public Map<String, GpgKeyInfo> apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException, PGPException, OrmException, IOException {
    GpgKeys.checkVisible(self, rsrc);
    List<AccountExternalId> existingExtIds = GpgKeys.getGpgExtIds(externalIdCache, rsrc.getUser().getAccountId()).toList();
    try (PublicKeyStore store = storeProvider.get()) {
        Set<Fingerprint> toRemove = readKeysToRemove(input, existingExtIds);
        List<PGPPublicKeyRing> newKeys = readKeysToAdd(input, toRemove);
        List<AccountExternalId> newExtIds = new ArrayList<>(existingExtIds.size());
        for (PGPPublicKeyRing keyRing : newKeys) {
            PGPPublicKey key = keyRing.getPublicKey();
            AccountExternalId.Key extIdKey = toExtIdKey(key.getFingerprint());
            Account account = getAccountByExternalId(extIdKey.get());
            if (account != null) {
                if (!account.getId().equals(rsrc.getUser().getAccountId())) {
                    throw new ResourceConflictException("GPG key already associated with another account");
                }
            } else {
                newExtIds.add(new AccountExternalId(rsrc.getUser().getAccountId(), extIdKey));
            }
        }
        storeKeys(rsrc, newKeys, toRemove);
        if (!newExtIds.isEmpty()) {
            db.get().accountExternalIds().insert(newExtIds);
            externalIdCache.onCreate(newExtIds);
        }
        Iterable<AccountExternalId.Key> extIdKeysToRemove = Iterables.transform(toRemove, fp -> toExtIdKey(fp.get()));
        db.get().accountExternalIds().deleteKeys(extIdKeysToRemove);
        externalIdCache.remove(rsrc.getUser().getAccountId(), extIdKeysToRemove);
        accountCache.evict(rsrc.getUser().getAccountId());
        return toJson(newKeys, toRemove, store, rsrc.getUser());
    }
}
#method_after
@Override
public Map<String, GpgKeyInfo> apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException, PGPException, OrmException, IOException {
    GpgKeys.checkVisible(self, rsrc);
    List<AccountExternalId> existingExtIds = GpgKeys.getGpgExtIds(externalIdCache, rsrc.getUser().getAccountId()).toList();
    try (PublicKeyStore store = storeProvider.get()) {
        Set<Fingerprint> toRemove = readKeysToRemove(input, existingExtIds);
        List<PGPPublicKeyRing> newKeys = readKeysToAdd(input, toRemove);
        List<AccountExternalId> newExtIds = new ArrayList<>(existingExtIds.size());
        for (PGPPublicKeyRing keyRing : newKeys) {
            PGPPublicKey key = keyRing.getPublicKey();
            AccountExternalId.Key extIdKey = toExtIdKey(key.getFingerprint());
            Account account = getAccountByExternalId(extIdKey.get());
            if (account != null) {
                if (!account.getId().equals(rsrc.getUser().getAccountId())) {
                    throw new ResourceConflictException("GPG key already associated with another account");
                }
            } else {
                newExtIds.add(new AccountExternalId(rsrc.getUser().getAccountId(), extIdKey));
            }
        }
        storeKeys(rsrc, newKeys, toRemove);
        if (!newExtIds.isEmpty()) {
            db.get().accountExternalIds().insert(newExtIds);
            externalIdCache.onCreate(newExtIds);
        }
        List<AccountExternalId.Key> extIdKeysToRemove = toRemove.stream().map(fp -> toExtIdKey(fp.get())).collect(toList());
        db.get().accountExternalIds().deleteKeys(extIdKeysToRemove);
        externalIdCache.onRemove(rsrc.getUser().getAccountId(), extIdKeysToRemove);
        accountCache.evict(rsrc.getUser().getAccountId());
        return toJson(newKeys, toRemove, store, rsrc.getUser());
    }
}
#end_block

#method_before
@Test
public void noExternalIds() throws Exception {
    Collection<AccountExternalId> extIds = externalIdCache.byAccount(user.getAccountId());
    db.accountExternalIds().delete(extIds);
    externalIdCache.remove(extIds);
    reloadUser();
    TestKey key = validKeyWithSecondUserId();
    PublicKeyChecker checker = checkerFactory.create(user, store).disableTrust();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user; check" + " http://test/#/settings/web-identities");
    checker = checkerFactory.create().setStore(store).disableTrust();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "Key is not associated with any users");
    AccountExternalId extId = new AccountExternalId(user.getAccountId(), toExtIdKey(key.getPublicKey()));
    db.accountExternalIds().insert(Collections.singleton(extId));
    externalIdCache.onCreate(extId);
    reloadUser();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user");
}
#method_after
@Test
public void noExternalIds() throws Exception {
    Collection<AccountExternalId> extIds = externalIdCache.byAccount(user.getAccountId());
    db.accountExternalIds().delete(extIds);
    externalIdCache.onRemove(extIds);
    reloadUser();
    TestKey key = validKeyWithSecondUserId();
    PublicKeyChecker checker = checkerFactory.create(user, store).disableTrust();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user; check" + " http://test/#/settings/web-identities");
    checker = checkerFactory.create().setStore(store).disableTrust();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "Key is not associated with any users");
    AccountExternalId extId = new AccountExternalId(user.getAccountId(), toExtIdKey(key.getPublicKey()));
    db.accountExternalIds().insert(Collections.singleton(extId));
    externalIdCache.onCreate(extId);
    reloadUser();
    assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user");
}
#end_block

#method_before
@Override
public VoidResult call() throws OrmException, NameAlreadyUsedException, InvalidUserNameException, IOException {
    final Collection<AccountExternalId> old = old();
    if (!old.isEmpty()) {
        throw new IllegalStateException(USERNAME_CANNOT_BE_CHANGED);
    }
    if (newUsername != null && !newUsername.isEmpty()) {
        if (!USER_NAME_PATTERN.matcher(newUsername).matches()) {
            throw new InvalidUserNameException();
        }
        final AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, newUsername);
        try {
            final AccountExternalId id = new AccountExternalId(user.getAccountId(), key);
            for (AccountExternalId i : old) {
                if (i.getPassword() != null) {
                    id.setPassword(i.getPassword());
                }
            }
            db.accountExternalIds().insert(Collections.singleton(id));
            externalIdCache.onCreate(id);
        } catch (OrmDuplicateKeyException dupeErr) {
            // If we are using this identity, don't report the exception.
            // 
            AccountExternalId other = db.accountExternalIds().get(key);
            if (other != null && other.getAccountId().equals(user.getAccountId())) {
                return VoidResult.INSTANCE;
            }
            // 
            throw new NameAlreadyUsedException(newUsername);
        }
    }
    // If we have any older user names, remove them.
    // 
    db.accountExternalIds().delete(old);
    externalIdCache.remove(old);
    for (AccountExternalId i : old) {
        sshKeyCache.evict(i.getSchemeRest());
        accountCache.evictByUsername(i.getSchemeRest());
    }
    accountCache.evict(user.getAccountId());
    accountCache.evictByUsername(newUsername);
    sshKeyCache.evict(newUsername);
    return VoidResult.INSTANCE;
}
#method_after
@Override
public VoidResult call() throws OrmException, NameAlreadyUsedException, InvalidUserNameException, IOException {
    final Collection<AccountExternalId> old = old();
    if (!old.isEmpty()) {
        throw new IllegalStateException(USERNAME_CANNOT_BE_CHANGED);
    }
    if (newUsername != null && !newUsername.isEmpty()) {
        if (!USER_NAME_PATTERN.matcher(newUsername).matches()) {
            throw new InvalidUserNameException();
        }
        final AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, newUsername);
        try {
            final AccountExternalId id = new AccountExternalId(user.getAccountId(), key);
            for (AccountExternalId i : old) {
                if (i.getPassword() != null) {
                    id.setPassword(i.getPassword());
                }
            }
            db.accountExternalIds().insert(Collections.singleton(id));
            externalIdCache.onCreate(id);
        } catch (OrmDuplicateKeyException dupeErr) {
            // If we are using this identity, don't report the exception.
            // 
            AccountExternalId other = db.accountExternalIds().get(key);
            if (other != null && other.getAccountId().equals(user.getAccountId())) {
                return VoidResult.INSTANCE;
            }
            // 
            throw new NameAlreadyUsedException(newUsername);
        }
    }
    // If we have any older user names, remove them.
    // 
    db.accountExternalIds().delete(old);
    externalIdCache.onRemove(old);
    for (AccountExternalId i : old) {
        sshKeyCache.evict(i.getSchemeRest());
        accountCache.evictByUsername(i.getSchemeRest());
    }
    accountCache.evict(user.getAccountId());
    accountCache.evictByUsername(newUsername);
    sshKeyCache.evict(newUsername);
    return VoidResult.INSTANCE;
}
#end_block

#method_before
public String generateToken(String operation, AnyLongObjectId id, int expirationSeconds) {
    if (key.isPresent()) {
        try {
            byte[] initVector = new byte[IV_LENGTH];
            rndm.nextBytes(initVector);
            Cipher cipher = cipher(initVector, Cipher.ENCRYPT_MODE);
            return Base64.encodeBytes(Bytes.concat(initVector, cipher.doFinal(String.format("%s-%s-%s", operation, id.name(), timeout(expirationSeconds)).getBytes(StandardCharsets.UTF_8))));
        } catch (GeneralSecurityException e) {
            log.error("Token generation failed with error", e);
        }
    }
    return "not:required";
}
#method_after
public String generateToken(String operation, AnyLongObjectId id, int expirationSeconds) {
    try {
        byte[] initVector = new byte[IV_LENGTH];
        rndm.nextBytes(initVector);
        Cipher cipher = cipher(initVector, Cipher.ENCRYPT_MODE);
        return Base64.encodeBytes(Bytes.concat(initVector, cipher.doFinal(String.format("%s-%s-%s", operation, id.name(), timeout(expirationSeconds)).getBytes(StandardCharsets.UTF_8))));
    } catch (GeneralSecurityException e) {
        log.error("Token generation failed with error", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public boolean verifyAgainstToken(String token, String operation, AnyLongObjectId id) {
    if (!key.isPresent()) {
        return true;
    }
    if (Strings.isNullOrEmpty(token)) {
        return false;
    }
    byte[] bytes = Base64.decode(token);
    byte[] initVector = Arrays.copyOf(bytes, IV_LENGTH);
    try {
        Cipher cipher = cipher(initVector, Cipher.DECRYPT_MODE);
        String data = new String(cipher.doFinal(Arrays.copyOfRange(bytes, IV_LENGTH, bytes.length)), StandardCharsets.UTF_8);
        String oid = id.name();
        String prefix = String.format("%s-%s-", operation, oid);
        return data.startsWith(prefix) && onTime(data.substring(prefix.length()), operation, oid);
    } catch (GeneralSecurityException e) {
        log.error("Exception was thrown during token verification", e);
    }
    return false;
}
#method_after
public boolean verifyAgainstToken(String token, String operation, AnyLongObjectId id) {
    if (Strings.isNullOrEmpty(token)) {
        return false;
    }
    byte[] bytes = Base64.decode(token);
    byte[] initVector = Arrays.copyOf(bytes, IV_LENGTH);
    try {
        Cipher cipher = cipher(initVector, Cipher.DECRYPT_MODE);
        String data = new String(cipher.doFinal(Arrays.copyOfRange(bytes, IV_LENGTH, bytes.length)), StandardCharsets.UTF_8);
        String oid = id.name();
        String prefix = String.format("%s-%s-", operation, oid);
        return data.startsWith(prefix) && onTime(data.substring(prefix.length()), operation, oid);
    } catch (GeneralSecurityException e) {
        log.error("Exception was thrown during token verification", e);
    }
    return false;
}
#end_block

#method_before
private boolean onTime(String dateTime, String operation, String id) {
    DateTime deadline = ISODateTimeFormat.dateTimeParser().parseDateTime(dateTime);
    if (deadline.isBeforeNow()) {
        log.info("Operation {} on id {} timed out", operation, id);
        return false;
    }
    return true;
}
#method_after
boolean onTime(String dateTime, String operation, String id) {
    String now = DATE_TIME.print(now());
    if (now.compareTo(dateTime) > 0) {
        log.info("Operation {} on id {} timed out", operation, id);
        return false;
    }
    return true;
}
#end_block

#method_before
private String timeout(int expirationSeconds) {
    DateTime now = now();
    return ISODateTimeFormat.dateTime().print(now.plusSeconds(expirationSeconds));
}
#method_after
private String timeout(int expirationSeconds) {
    return DATE_TIME.print(now().plusSeconds(expirationSeconds));
}
#end_block

#method_before
private Cipher cipher(byte[] initVector, int mode) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, InvalidKeyException, InvalidAlgorithmParameterException {
    IvParameterSpec spec = new IvParameterSpec(initVector);
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
    AlgorithmParameters params = AlgorithmParameters.getInstance(ALGORITHM);
    params.init(spec);
    cipher.init(mode, key.get(), params);
    return cipher;
}
#method_after
private Cipher cipher(byte[] initVector, int mode) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, InvalidKeyException, InvalidAlgorithmParameterException {
    IvParameterSpec spec = new IvParameterSpec(initVector);
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
    AlgorithmParameters params = AlgorithmParameters.getInstance(ALGORITHM);
    params.init(spec);
    cipher.init(mode, key, params);
    return cipher;
}
#end_block

#method_before
private Optional<SecretKey> generateKey() {
    try {
        KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM);
        generator.init(128, rndm);
        return Optional.of(generator.generateKey());
    } catch (NoSuchAlgorithmException e) {
        log.error("Generating key failed with error", e);
    }
    return Optional.absent();
}
#method_after
private SecretKey generateKey() {
    try {
        KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM);
        generator.init(128, rndm);
        return generator.generateKey();
    } catch (NoSuchAlgorithmException e) {
        log.error("Generating key failed with error", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public Comment newComment(ChangeContext ctx, String path, PatchSet.Id psId, short side, String message) {
    Comment c = new Comment(new Comment.Key(ChangeUtil.messageUuid(), path, psId.get()), ctx.getUser().getAccountId(), ctx.getWhen(), side, message, serverId, false);
    ctx.getUser().updateRealAccountId(c::setRealAuthor);
    return c;
}
#method_after
public Comment newComment(ChangeContext ctx, String path, PatchSet.Id psId, short side, String message, @Nullable Boolean unresolved, @Nullable String parentUuid) throws OrmException, UnprocessableEntityException {
    if (unresolved == null) {
        if (parentUuid == null) {
            // Default to false if comment is not descended from another.
            unresolved = false;
        } else {
            // Inherit unresolved value from inReplyTo comment if not specified.
            Comment.Key key = new Comment.Key(parentUuid, path, psId.patchSetId);
            Optional<Comment> parent = get(ctx.getDb(), ctx.getNotes(), key);
            if (!parent.isPresent()) {
                throw new UnprocessableEntityException("Invalid parentUuid supplied for comment");
            }
            unresolved = parent.get().unresolved;
        }
    }
    Comment c = new Comment(new Comment.Key(ChangeUtil.messageUuid(), path, psId.get()), ctx.getUser().getAccountId(), ctx.getWhen(), side, message, serverId, unresolved);
    ctx.getUser().updateRealAccountId(c::setRealAuthor);
    return c;
}
#end_block

#method_before
@Test
public void draftComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment");
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void draftComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment", null);
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void draftAndPublishedComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "draft comment");
    putComment(user, id, 1, "published comment");
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void draftAndPublishedComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "draft comment", null);
    putComment(user, id, 1, "published comment");
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void publishDraftComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "draft comment");
    publishDrafts(user, id);
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void publishDraftComment() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "draft comment", null);
    publishDrafts(user, id);
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void noteDbChangeState() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    ObjectId changeMetaId = getMetaRef(project, changeMetaRef(id));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name());
    putDraft(user, id, 1, "comment by user");
    ObjectId userDraftsId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + user.getId() + "=" + userDraftsId.name());
    putDraft(admin, id, 2, "comment by admin");
    ObjectId adminDraftsId = getMetaRef(allUsers, refsDraftComments(id, admin.getId()));
    assertThat(admin.getId().get()).isLessThan(user.getId().get());
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
    putDraft(admin, id, 2, "revised comment by admin");
    adminDraftsId = getMetaRef(allUsers, refsDraftComments(id, admin.getId()));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
}
#method_after
@Test
public void noteDbChangeState() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    ObjectId changeMetaId = getMetaRef(project, changeMetaRef(id));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name());
    putDraft(user, id, 1, "comment by user", null);
    ObjectId userDraftsId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + user.getId() + "=" + userDraftsId.name());
    putDraft(admin, id, 2, "comment by admin", null);
    ObjectId adminDraftsId = getMetaRef(allUsers, refsDraftComments(id, admin.getId()));
    assertThat(admin.getId().get()).isLessThan(user.getId().get());
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
    putDraft(admin, id, 2, "revised comment by admin", null);
    adminDraftsId = getMetaRef(allUsers, refsDraftComments(id, admin.getId()));
    assertThat(getUnwrappedDb().changes().get(id).getNoteDbState()).isEqualTo(changeMetaId.name() + "," + admin.getId() + "=" + adminDraftsId.name() + "," + user.getId() + "=" + userDraftsId.name());
}
#end_block

#method_before
@Test
public void rebuildReturnsDraftResultWhenRebuildingInChangeNotesFails() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment by user");
    assertChangeUpToDate(true, id);
    ObjectId oldMetaId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    // Add a draft behind NoteDb's back.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "second comment by user");
    setInvalidNoteDbState(id);
    assertDraftsUpToDate(false, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Force the next rebuild attempt to fail (in ChangeNotes).
    rebuilderWrapper.failNextUpdate();
    setNotesMigration(true, true);
    ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
    notes.getDraftComments(user.getId());
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Not up to date, but the actual returned state matches anyway.
    assertDraftsUpToDate(false, id, user);
    ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
    ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
    assertThat(actual.differencesFrom(expected)).isEmpty();
    // Another rebuild attempt succeeds
    notesFactory.create(dbProvider.get(), project, id);
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(true, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isNotEqualTo(oldMetaId);
}
#method_after
@Test
public void rebuildReturnsDraftResultWhenRebuildingInChangeNotesFails() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment by user", null);
    assertChangeUpToDate(true, id);
    ObjectId oldMetaId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    // Add a draft behind NoteDb's back.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "second comment by user", null);
    setInvalidNoteDbState(id);
    assertDraftsUpToDate(false, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Force the next rebuild attempt to fail (in ChangeNotes).
    rebuilderWrapper.failNextUpdate();
    setNotesMigration(true, true);
    ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
    notes.getDraftComments(user.getId());
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Not up to date, but the actual returned state matches anyway.
    assertDraftsUpToDate(false, id, user);
    ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
    ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
    assertThat(actual.differencesFrom(expected)).isEmpty();
    // Another rebuild attempt succeeds
    notesFactory.create(dbProvider.get(), project, id);
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(true, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isNotEqualTo(oldMetaId);
}
#end_block

#method_before
@Test
public void rebuildReturnsDraftResultWhenRebuildingInDraftCommentNotesFails() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment by user");
    assertChangeUpToDate(true, id);
    ObjectId oldMetaId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    // Add a draft behind NoteDb's back.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "second comment by user");
    ReviewDb db = getUnwrappedDb();
    Change c = db.changes().get(id);
    // Leave change meta ID alone so DraftCommentNotes does the rebuild.
    ObjectId badSha = ObjectId.fromString("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef");
    NoteDbChangeState bogusState = new NoteDbChangeState(id, PrimaryStorage.REVIEW_DB, Optional.of(NoteDbChangeState.RefState.create(NoteDbChangeState.parse(c).getChangeMetaId(), ImmutableMap.of(user.getId(), badSha))));
    c.setNoteDbState(bogusState.toString());
    db.changes().update(Collections.singleton(c));
    assertDraftsUpToDate(false, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Force the next rebuild attempt to fail (in DraftCommentNotes).
    rebuilderWrapper.failNextUpdate();
    setNotesMigration(true, true);
    ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
    notes.getDraftComments(user.getId());
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Not up to date, but the actual returned state matches anyway.
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(false, id, user);
    ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
    ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
    assertThat(actual.differencesFrom(expected)).isEmpty();
    // Another rebuild attempt succeeds
    notesFactory.create(dbProvider.get(), project, id).getDraftComments(user.getId());
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(true, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isNotEqualTo(oldMetaId);
}
#method_after
@Test
public void rebuildReturnsDraftResultWhenRebuildingInDraftCommentNotesFails() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment by user", null);
    assertChangeUpToDate(true, id);
    ObjectId oldMetaId = getMetaRef(allUsers, refsDraftComments(id, user.getId()));
    // Add a draft behind NoteDb's back.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "second comment by user", null);
    ReviewDb db = getUnwrappedDb();
    Change c = db.changes().get(id);
    // Leave change meta ID alone so DraftCommentNotes does the rebuild.
    ObjectId badSha = ObjectId.fromString("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef");
    NoteDbChangeState bogusState = new NoteDbChangeState(id, PrimaryStorage.REVIEW_DB, Optional.of(NoteDbChangeState.RefState.create(NoteDbChangeState.parse(c).getChangeMetaId(), ImmutableMap.of(user.getId(), badSha))));
    c.setNoteDbState(bogusState.toString());
    db.changes().update(Collections.singleton(c));
    assertDraftsUpToDate(false, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Force the next rebuild attempt to fail (in DraftCommentNotes).
    rebuilderWrapper.failNextUpdate();
    setNotesMigration(true, true);
    ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
    notes.getDraftComments(user.getId());
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isEqualTo(oldMetaId);
    // Not up to date, but the actual returned state matches anyway.
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(false, id, user);
    ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
    ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
    assertThat(actual.differencesFrom(expected)).isEmpty();
    // Another rebuild attempt succeeds
    notesFactory.create(dbProvider.get(), project, id).getDraftComments(user.getId());
    assertChangeUpToDate(true, id);
    assertDraftsUpToDate(true, id, user);
    assertThat(getMetaRef(allUsers, refsDraftComments(id, user.getId()))).isNotEqualTo(oldMetaId);
}
#end_block

#method_before
@Test
public void rebuildAutomaticallyWhenDraftsOutOfDate() throws Exception {
    setNotesMigration(true, true);
    setApiUser(user);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment");
    assertDraftsUpToDate(true, id, user);
    // Make a ReviewDb change behind NoteDb's back and ensure it's detected.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "comment");
    setInvalidNoteDbState(id);
    assertDraftsUpToDate(false, id, user);
    // On next NoteDb read, the drafts are transparently rebuilt.
    setNotesMigration(true, true);
    assertThat(gApi.changes().id(id.get()).current().drafts()).containsKey(PushOneCommit.FILE_NAME);
    assertDraftsUpToDate(true, id, user);
}
#method_after
@Test
public void rebuildAutomaticallyWhenDraftsOutOfDate() throws Exception {
    setNotesMigration(true, true);
    setApiUser(user);
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment", null);
    assertDraftsUpToDate(true, id, user);
    // Make a ReviewDb change behind NoteDb's back and ensure it's detected.
    setNotesMigration(false, false);
    putDraft(user, id, 1, "comment", null);
    setInvalidNoteDbState(id);
    assertDraftsUpToDate(false, id, user);
    // On next NoteDb read, the drafts are transparently rebuilt.
    setNotesMigration(true, true);
    assertThat(gApi.changes().id(id.get()).current().drafts()).containsKey(PushOneCommit.FILE_NAME);
    assertDraftsUpToDate(true, id, user);
}
#end_block

#method_before
@Test
public void rebuildDeletesOldDraftRefs() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment");
    Account.Id otherAccountId = new Account.Id(user.getId().get() + 1234);
    String otherDraftRef = refsDraftComments(id, otherAccountId);
    try (Repository repo = repoManager.openRepository(allUsers);
        ObjectInserter ins = repo.newObjectInserter()) {
        ObjectId sha = ins.insert(OBJ_BLOB, "garbage data".getBytes(UTF_8));
        ins.flush();
        RefUpdate ru = repo.updateRef(otherDraftRef);
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(sha);
        assertThat(ru.update()).isEqualTo(RefUpdate.Result.NEW);
    }
    checker.rebuildAndCheckChanges(id);
    try (Repository repo = repoManager.openRepository(allUsers)) {
        assertThat(repo.exactRef(otherDraftRef)).isNull();
    }
}
#method_after
@Test
public void rebuildDeletesOldDraftRefs() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    putDraft(user, id, 1, "comment", null);
    Account.Id otherAccountId = new Account.Id(user.getId().get() + 1234);
    String otherDraftRef = refsDraftComments(id, otherAccountId);
    try (Repository repo = repoManager.openRepository(allUsers);
        ObjectInserter ins = repo.newObjectInserter()) {
        ObjectId sha = ins.insert(OBJ_BLOB, "garbage data".getBytes(UTF_8));
        ins.flush();
        RefUpdate ru = repo.updateRef(otherDraftRef);
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(sha);
        assertThat(ru.update()).isEqualTo(RefUpdate.Result.NEW);
    }
    checker.rebuildAndCheckChanges(id);
    try (Repository repo = repoManager.openRepository(allUsers)) {
        assertThat(repo.exactRef(otherDraftRef)).isNull();
    }
}
#end_block

#method_before
private void putDraft(TestAccount account, Change.Id id, int line, String msg) throws Exception {
    DraftInput in = new DraftInput();
    in.line = line;
    in.message = msg;
    in.path = PushOneCommit.FILE_NAME;
    AcceptanceTestRequestScope.Context old = setApiUser(account);
    try {
        gApi.changes().id(id.get()).current().createDraft(in);
    } finally {
        atrScope.set(old);
    }
}
#method_after
private void putDraft(TestAccount account, Change.Id id, int line, String msg, Boolean unresolved) throws Exception {
    DraftInput in = new DraftInput();
    in.line = line;
    in.message = msg;
    in.path = PushOneCommit.FILE_NAME;
    in.unresolved = unresolved;
    AcceptanceTestRequestScope.Context old = setApiUser(account);
    try {
        gApi.changes().id(id.get()).current().createDraft(in);
    } finally {
        atrScope.set(old);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= insertRobotComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, UnprocessableEntityException {
    user = ctx.getIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= insertRobotComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, Comment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<Comment> toDel = new ArrayList<>();
    List<Comment> toPublish = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            Comment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = commentsUtil.newComment(ctx, path, psId, c.side(), c.message);
            } else {
                e.writtenOn = ctx.getWhen();
                e.side = c.side();
                e.message = c.message;
            }
            if (parent != null) {
                e.parentUuid = parent;
            }
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toPublish.add(e);
        }
    }
    switch(in.drafts) {
        case KEEP:
        default:
            break;
        case DELETE:
            toDel.addAll(drafts.values());
            break;
        case PUBLISH:
            for (Comment e : drafts.values()) {
                toPublish.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, toPublish);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    commentsUtil.deleteComments(ctx.getDb(), u, toDel);
    commentsUtil.putComments(ctx.getDb(), u, Status.PUBLISHED, toPublish);
    comments.addAll(toPublish);
    return !toDel.isEmpty() || !toPublish.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException, UnprocessableEntityException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, Comment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<Comment> toDel = new ArrayList<>();
    List<Comment> toPublish = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            Comment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = commentsUtil.newComment(ctx, path, psId, c.side(), c.message, c.unresolved, parent);
            } else {
                e.writtenOn = ctx.getWhen();
                e.side = c.side();
                e.message = c.message;
            }
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toPublish.add(e);
        }
    }
    switch(in.drafts) {
        case KEEP:
        default:
            break;
        case DELETE:
            toDel.addAll(drafts.values());
            break;
        case PUBLISH:
            for (Comment e : drafts.values()) {
                toPublish.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, toPublish);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    commentsUtil.deleteComments(ctx.getDb(), u, toDel);
    commentsUtil.putComments(ctx.getDb(), u, Status.PUBLISHED, toPublish);
    comments.addAll(toPublish);
    return !toDel.isEmpty() || !toPublish.isEmpty();
}
#end_block

#method_before
public void atomicDelete(Project project) throws OrmException {
    List<ChangeData> changes = queryProvider.get().byProject(project.getNameKey());
    deleteChanges(changes);
}
#method_after
public void atomicDelete(Project project) throws OrmException {
    List<ChangeData> changes = queryProvider.get().byProject(project.getNameKey());
    deleteChanges(changes);
    for (AccountState a : accountQueryProvider.get().byWatchedProject(project.getNameKey())) {
        Account.Id accountId = a.getAccount().getId();
        for (ProjectWatchKey watchKey : a.getProjectWatches().keySet()) {
            if (project.getNameKey().equals(watchKey.project())) {
                try {
                    watchConfig.get().deleteProjectWatches(accountId, singleton(watchKey));
                } catch (IOException | ConfigInvalidException e) {
                    log.error("Removing watch entry for user {} in project {} failed.", a.getUserName(), project.getName(), e);
                }
            }
        }
    }
}
#end_block

#method_before
@Test
public void watchFile() throws Exception {
    // watch file in project
    String watchedProject = createProject("watchedProject").get();
    setApiUser(user);
    watch(watchedProject, "file:a.txt");
    // push a change to watched file -> should trigger email notification
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // push a change to non-watched file -> should not trigger email
    // notification
    r = pushFactory.create(db, admin.getIdent(), testRepo, "DONT_TRIGGER", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchFile() throws Exception {
    String watchedProject = createProject("watchedProject").get();
    String otherWatchedProject = createProject("otherWatchedProject").get();
    setApiUser(user);
    // watch file in project as user
    watch(watchedProject, "file:a.txt");
    // watch other project as user
    watch(otherWatchedProject, null);
    // push a change to watched file -> should trigger email notification for
    // user
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification for user
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
    sender.clear();
    // watch project as user2
    TestAccount user2 = accounts.create("user2", "user2@test.com", "User2");
    setApiUser(user2);
    watch(watchedProject, null);
    // push a change to non-watched file -> should not trigger email
    // notification for user, only for user2
    r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER_USER2", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user2.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER_USER2\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
public Map<ProjectWatchKey, Collection<NotifyType>> getProjectWatches(Account.Id accountId) throws IOException, ConfigInvalidException {
    try (Repository git = repoManager.openRepository(allUsersName);
        WatchConfig watchConfig = new WatchConfig(accountId)) {
        watchConfig.load(git);
        return watchConfig.getProjectWatches();
    }
}
#method_after
public Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches(Account.Id accountId) throws IOException, ConfigInvalidException {
    try (Repository git = repoManager.openRepository(allUsersName)) {
        WatchConfig watchConfig = new WatchConfig(accountId);
        watchConfig.load(git);
        return watchConfig.getProjectWatches();
    }
}
#end_block

#method_before
public void upsertProjectWatches(Account.Id accountId, Map<ProjectWatchKey, Collection<NotifyType>> newProjectWatches) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        projectWatches.putAll(newProjectWatches);
        commit(watchConfig);
    }
}
#method_after
public synchronized void upsertProjectWatches(Account.Id accountId, Map<ProjectWatchKey, Set<NotifyType>> newProjectWatches) throws IOException, ConfigInvalidException {
    WatchConfig watchConfig = read(accountId);
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = watchConfig.getProjectWatches();
    projectWatches.putAll(newProjectWatches);
    commit(watchConfig);
}
#end_block

#method_before
public void deleteProjectWatches(Account.Id accountId, Collection<ProjectWatchKey> projectWatchKeys) throws IOException, ConfigInvalidException {
    try (WatchConfig watchConfig = open(accountId)) {
        Map<ProjectWatchKey, Collection<NotifyType>> projectWatches = watchConfig.getProjectWatches();
        for (ProjectWatchKey key : projectWatchKeys) {
            projectWatches.remove(key);
        }
        commit(watchConfig);
    }
}
#method_after
public synchronized void deleteProjectWatches(Account.Id accountId, Collection<ProjectWatchKey> projectWatchKeys) throws IOException, ConfigInvalidException {
    WatchConfig watchConfig = read(accountId);
    Map<ProjectWatchKey, Set<NotifyType>> projectWatches = watchConfig.getProjectWatches();
    boolean commit = false;
    for (ProjectWatchKey key : projectWatchKeys) {
        if (projectWatches.remove(key) != null) {
            commit = true;
        }
    }
    if (commit) {
        commit(watchConfig);
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    projectWatches = new HashMap<>();
    Config cfg = readConfig(WATCH_CONFIG);
    for (String projectWatchKey : cfg.getSubsections(PROJECT)) {
        ProjectWatchKey key = ProjectWatchKey.parse(projectWatchKey);
        projectWatches.put(key, new HashSet<NotifyType>());
        List<String> notifyValues = Arrays.asList(cfg.getStringList(PROJECT, projectWatchKey, KEY_NOTIFY));
        if (!notifyValues.contains(NOTIFY_NONE)) {
            for (String notify : notifyValues) {
                try {
                    projectWatches.get(key).add(NotifyType.valueOf(notify));
                } catch (IllegalArgumentException e) {
                    log.warn(String.format("Project watch configuration %s of account %d" + " contains invalid notify type: %s", projectWatchKey, accountId.get(), notify), e);
                }
            }
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Config cfg = readConfig(WATCH_CONFIG);
    projectWatches = parse(accountId, cfg, this);
}
#end_block

#method_before
Map<ProjectWatchKey, Collection<NotifyType>> getProjectWatches() {
    checkLoaded();
    return projectWatches;
}
#method_after
Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches() {
    checkLoaded();
    return projectWatches;
}
#end_block

#method_before
public void setProjectWatches(Map<ProjectWatchKey, Collection<NotifyType>> projectWatches) {
    this.projectWatches = projectWatches;
}
#method_after
public void setProjectWatches(Map<ProjectWatchKey, Set<NotifyType>> projectWatches) {
    this.projectWatches = projectWatches;
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated watch configuration\n");
    }
    Config cfg = readConfig(WATCH_CONFIG);
    clearSection(cfg, PROJECT);
    for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : projectWatches.entrySet()) {
        if (e.getValue().isEmpty()) {
            // set notify to 'none' since empty sections are not persisted
            cfg.setString(PROJECT, e.getKey().toString(), KEY_NOTIFY, NOTIFY_NONE);
        } else {
            List<String> notifyValues = FluentIterable.from(e.getValue()).transform(new Function<NotifyType, String>() {

                @Override
                public String apply(NotifyType notify) {
                    return notify.name();
                }
            }).toList();
            cfg.setStringList(PROJECT, e.getKey().toString(), KEY_NOTIFY, notifyValues);
        }
    }
    saveConfig(WATCH_CONFIG, cfg);
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Updated watch configuration\n");
    }
    Config cfg = readConfig(WATCH_CONFIG);
    for (String projectName : cfg.getSubsections(PROJECT)) {
        cfg.unsetSection(PROJECT, projectName);
    }
    Multimap<String, String> notifyValuesByProject = MultimapBuilder.hashKeys().arrayListValues().build();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches.entrySet()) {
        NotifyValue notifyValue = NotifyValue.create(e.getKey().filter(), e.getValue());
        notifyValuesByProject.put(e.getKey().project().get(), notifyValue.toString());
    }
    for (Map.Entry<String, Collection<String>> e : notifyValuesByProject.asMap().entrySet()) {
        cfg.setStringList(PROJECT, e.getKey(), KEY_NOTIFY, new ArrayList<>(e.getValue()));
    }
    saveConfig(WATCH_CONFIG, cfg);
    return true;
}
#end_block

#method_before
private void checkLoaded() {
    checkNotNull(projectWatches, "project watches not loaded yet");
}
#method_after
private void checkLoaded() {
    checkState(projectWatches != null, "project watches not loaded yet");
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource rsrc, List<ProjectWatchInfo> input) throws AuthException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to edit project watches " + "of other users");
    }
    if (input == null) {
        return Response.none();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    deleteFromGit(accountId, input);
    accountCache.evict(accountId);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource rsrc, List<ProjectWatchInfo> input) throws AuthException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to edit project watches " + "of other users");
    }
    if (input == null) {
        return Response.none();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    watchConfig.deleteProjectWatches(accountId, input.stream().map(w -> ProjectWatchKey.create(new Project.NameKey(w.project), w.filter)).collect(toList()));
    accountCache.evict(accountId);
    return Response.none();
}
#end_block

#method_before
public Map<ProjectWatchKey, Collection<NotifyType>> getProjectWatches() {
    return projectWatches;
}
#method_after
public Map<ProjectWatchKey, Set<NotifyType>> getProjectWatches() {
    return projectWatches;
}
#end_block

#method_before
public <T> void put(PropertyKey<T> key, @Nullable T value) {
    Cache<PropertyKey<Object>, Object> p = properties(value != null);
    if (p != null || value != null) {
        @SuppressWarnings("unchecked")
        PropertyKey<Object> k = (PropertyKey<Object>) key;
        if (value != null) {
            p.put(k, value);
        } else {
            p.invalidate(k);
        }
    }
}
#method_after
public <T> void put(PropertyKey<T> key, @Nullable T value) {
    Cache<PropertyKey<Object>, Object> p = properties(value != null);
    if (p != null) {
        @SuppressWarnings("unchecked")
        PropertyKey<Object> k = (PropertyKey<Object>) key;
        if (value != null) {
            p.put(k, value);
        } else {
            p.invalidate(k);
        }
    }
}
#end_block

#method_before
private static AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Collection<AccountExternalId> ids = Collections.emptySet();
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(account, anon, ids, new HashMap<ProjectWatchKey, Collection<NotifyType>>());
}
#method_after
private static AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Collection<AccountExternalId> ids = Collections.emptySet();
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(account, anon, ids, new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
@Override
public Optional<Account.Id> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        final AccountExternalId.Key key = new // 
        AccountExternalId.Key(// 
        AccountExternalId.SCHEME_USERNAME, username);
        final AccountExternalId id = db.accountExternalIds().get(key);
        if (id != null) {
            return Optional.of(id.getAccountId());
        }
        return Optional.absent();
    }
}
#method_after
@Override
public Optional<Account.Id> load(String username) throws Exception {
    AccountExternalId.Key key = new // 
    AccountExternalId.Key(// 
    AccountExternalId.SCHEME_USERNAME, username);
    AccountState accountState = accountQueryProvider.get().oneByExternalId(key.get());
    return Optional.ofNullable(accountState).map(s -> s.getAccount().getId());
}
#end_block

#method_before
public Collection<SubscribeSection> getSubscribeSections(Branch.NameKey branch) {
    Collection<SubscribeSection> ret = new ArrayList<>();
    for (SubscribeSection s : subscribeSections.values()) {
        if (s.appliesTo(branch)) {
            ret.add(s);
        }
    }
    return ret;
}
#method_after
public Map<Project.NameKey, SubscribeSection> getSubscribeSections() {
    return subscribeSections;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    Map<String, GroupReference> groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    Map<String, GroupReference> groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        // The config must not contain more than one parent to inherit from
        // as there is no guarantee which of the parents would be used then.
        error(new ValidationError(PROJECT_CONFIG, "Cannot inherit from multiple projects"));
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setRejectImplicitMerges(getEnum(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, DEFAULT_SUBMIT_ACTION));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, DEFAULT_STATE_VALUE));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<>();
    sectionsWithUnknownPermissions = new HashSet<>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName) && isValidRegex(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                } else {
                    sectionsWithUnknownPermissions.add(as.getName());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#method_after
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<>();
    sectionsWithUnknownPermissions = new HashSet<>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName) && isValidRegex(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    n = convertLegacyPermission(n);
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                String convertedName = convertLegacyPermission(varName);
                if (isPermission(convertedName)) {
                    Permission perm = as.getPermission(convertedName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(convertedName));
                } else {
                    sectionsWithUnknownPermissions.add(as.getName());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#end_block

#method_before
private void loadLabelSections(Config rc) {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = new LinkedHashMap<>();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = new ArrayList<>();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String functionName = MoreObjects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        if (!values.isEmpty()) {
            short dv = (short) rc.getInt(LABEL, name, KEY_DEFAULT_VALUE, 0);
            if (isInRange(dv, values)) {
                label.setDefaultValue(dv);
            } else {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\"", KEY_DEFAULT_VALUE, dv, name)));
            }
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, LabelType.DEF_COPY_MIN_SCORE));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, LabelType.DEF_COPY_MAX_SCORE));
        label.setCopyAllScoresOnMergeFirstParentUpdate(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE));
        label.setCopyAllScoresIfNoCodeChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE));
        label.setCopyAllScoresIfNoChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, LabelType.DEF_CAN_OVERRIDE));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_Branch));
        labelSections.put(name, label);
    }
}
#method_after
private void loadLabelSections(Config rc) {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = new LinkedHashMap<>();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = new ArrayList<>();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String functionName = MoreObjects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        if (!values.isEmpty()) {
            short dv = (short) rc.getInt(LABEL, name, KEY_DEFAULT_VALUE, 0);
            if (isInRange(dv, values)) {
                label.setDefaultValue(dv);
            } else {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\"", KEY_DEFAULT_VALUE, dv, name)));
            }
        }
        label.setAllowPostSubmit(rc.getBoolean(LABEL, name, KEY_ALLOW_POST_SUBMIT, LabelType.DEF_ALLOW_POST_SUBMIT));
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, LabelType.DEF_COPY_MIN_SCORE));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, LabelType.DEF_COPY_MAX_SCORE));
        label.setCopyAllScoresOnMergeFirstParentUpdate(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE));
        label.setCopyAllScoresIfNoCodeChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE));
        label.setCopyAllScoresIfNoChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, LabelType.DEF_CAN_OVERRIDE));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_BRANCH));
        labelSections.put(name, label);
    }
}
#end_block

#method_before
private void loadSubscribeSections(Config rc) throws ConfigInvalidException {
    Set<String> subsections = rc.getSubsections(SUBSCRIBE_SECTION);
    subscribeSections = new HashMap<>();
    try {
        for (String projectName : subsections) {
            Project.NameKey p = new Project.NameKey(projectName);
            SubscribeSection ss = new SubscribeSection(p);
            for (String s : rc.getStringList(SUBSCRIBE_SECTION, projectName, SUBSCRIBE_REFS)) {
                ss.addRefSpec(s);
            }
            subscribeSections.put(p, ss);
        }
    } catch (IllegalArgumentException e) {
        throw new ConfigInvalidException(e.getMessage());
    }
}
#method_after
private void loadSubscribeSections(Config rc) throws ConfigInvalidException {
    Set<String> subsections = rc.getSubsections(SUBSCRIBE_SECTION);
    subscribeSections = new HashMap<>();
    try {
        for (String projectName : subsections) {
            Project.NameKey p = new Project.NameKey(projectName);
            SubscribeSection ss = new SubscribeSection(p);
            for (String s : rc.getStringList(SUBSCRIBE_SECTION, projectName, SUBSCRIBE_MULTI_MATCH_REFS)) {
                ss.addMultiMatchRefSpec(s);
            }
            for (String s : rc.getStringList(SUBSCRIBE_SECTION, projectName, SUBSCRIBE_MATCH_REFS)) {
                ss.addMatchingRefSpec(s);
            }
            subscribeSections.put(p, ss);
        }
    } catch (IllegalArgumentException e) {
        throw new ConfigInvalidException(e.getMessage());
    }
}
#end_block

#method_before
private void readGroupList() throws IOException {
    groupList = GroupList.parse(readUTF8(GroupList.FILE_NAME), this);
}
#method_after
private void readGroupList() throws IOException {
    groupList = GroupList.parse(projectName, readUTF8(GroupList.FILE_NAME), this);
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, p.getCreateNewChangeForAllNotInTarget(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, p.getEnableSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, p.getRequireSignedPush(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), defaultStateValue);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    savePluginSections(rc, keepGroups);
    groupList.retainUUIDs(keepGroups);
    saveLabelSections(rc);
    saveSubscribeSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, p.getCreateNewChangeForAllNotInTarget(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, p.getEnableSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, p.getRequireSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, p.getRejectImplicitMerges(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), DEFAULT_SUBMIT_ACTION);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), DEFAULT_STATE_VALUE);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    savePluginSections(rc, keepGroups);
    groupList.retainUUIDs(keepGroups);
    saveLabelSections(rc);
    saveSubscribeSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#end_block

#method_before
private void saveAccessSections(Config rc, Set<AccountGroup.UUID> keepGroups) {
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (!have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = Permission.hasRange(permission.getName());
            List<String> rules = new ArrayList<>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
}
#method_after
private void saveAccessSections(Config rc, Set<AccountGroup.UUID> keepGroups) {
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = resolve(rule.getGroup());
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (!have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = Permission.hasRange(permission.getName());
            List<String> rules = new ArrayList<>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = resolve(rule.getGroup());
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(convertLegacyPermission(varName)) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
}
#end_block

#method_before
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunctionName());
        rc.setInt(LABEL, name, KEY_DEFAULT_VALUE, label.getDefaultValue());
        setBooleanConfigKey(rc, name, KEY_COPY_MIN_SCORE, label.isCopyMinScore(), LabelType.DEF_COPY_MIN_SCORE);
        setBooleanConfigKey(rc, name, KEY_COPY_MAX_SCORE, label.isCopyMaxScore(), LabelType.DEF_COPY_MAX_SCORE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, label.isCopyAllScoresOnTrivialRebase(), LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, label.isCopyAllScoresIfNoCodeChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, label.isCopyAllScoresIfNoChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, label.isCopyAllScoresOnMergeFirstParentUpdate(), LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE);
        setBooleanConfigKey(rc, name, KEY_CAN_OVERRIDE, label.canOverride(), LabelType.DEF_CAN_OVERRIDE);
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#method_after
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunctionName());
        rc.setInt(LABEL, name, KEY_DEFAULT_VALUE, label.getDefaultValue());
        setBooleanConfigKey(rc, name, KEY_ALLOW_POST_SUBMIT, label.allowPostSubmit(), LabelType.DEF_ALLOW_POST_SUBMIT);
        setBooleanConfigKey(rc, name, KEY_COPY_MIN_SCORE, label.isCopyMinScore(), LabelType.DEF_COPY_MIN_SCORE);
        setBooleanConfigKey(rc, name, KEY_COPY_MAX_SCORE, label.isCopyMaxScore(), LabelType.DEF_COPY_MAX_SCORE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, label.isCopyAllScoresOnTrivialRebase(), LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, label.isCopyAllScoresIfNoCodeChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, label.isCopyAllScoresIfNoChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE);
        setBooleanConfigKey(rc, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, label.isCopyAllScoresOnMergeFirstParentUpdate(), LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE);
        setBooleanConfigKey(rc, name, KEY_CAN_OVERRIDE, label.canOverride(), LabelType.DEF_CAN_OVERRIDE);
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#end_block

#method_before
private void saveSubscribeSections(Config rc) {
    for (Project.NameKey p : subscribeSections.keySet()) {
        SubscribeSection s = subscribeSections.get(p);
        for (RefSpec r : s.getRefSpecs()) {
            rc.setString(SUBSCRIBE_SECTION, p.get(), SUBSCRIBE_REFS, r.toString());
        }
    }
}
#method_after
private void saveSubscribeSections(Config rc) {
    for (Project.NameKey p : subscribeSections.keySet()) {
        SubscribeSection s = subscribeSections.get(p);
        List<String> matchings = new ArrayList<>();
        for (RefSpec r : s.getMatchingRefSpecs()) {
            matchings.add(r.toString());
        }
        rc.setStringList(SUBSCRIBE_SECTION, p.get(), SUBSCRIBE_MATCH_REFS, matchings);
        List<String> multimatchs = new ArrayList<>();
        for (RefSpec r : s.getMultiMatchRefSpecs()) {
            multimatchs.add(r.toString());
        }
        rc.setStringList(SUBSCRIBE_SECTION, p.get(), SUBSCRIBE_MULTI_MATCH_REFS, multimatchs);
    }
}
#end_block

#method_before
private void migrateData(List<SchemaVersion> pending, UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    for (SchemaVersion v : pending) {
        ui.message(String.format("Migrating data to schema %d ...", v.getVersionNbr()));
        v.migrateData(db, ui);
        v.finish(curr, db);
    }
}
#method_after
private void migrateData(List<SchemaVersion> pending, UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    for (SchemaVersion v : pending) {
        Stopwatch sw = Stopwatch.createStarted();
        ui.message(String.format("Migrating data to schema %d ...", v.getVersionNbr()));
        v.migrateData(db, ui);
        v.finish(curr, db);
        ui.message(String.format("\t> Done (%.3f s)", sw.elapsed(TimeUnit.MILLISECONDS) / 1000d));
    }
}
#end_block

#method_before
private static AccountState newState(Account account) {
    return new AccountState(account, ImmutableSet.<AccountGroup.UUID>of(), ImmutableSet.<AccountExternalId>of(), new HashMap<ProjectWatchKey, Collection<NotifyType>>());
}
#method_after
private static AccountState newState(Account account) {
    return new AccountState(account, ImmutableSet.<AccountGroup.UUID>of(), ImmutableSet.<AccountExternalId>of(), new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
private Map<ProjectWatchKey, Collection<NotifyType>> asMap(List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException {
    Map<ProjectWatchKey, Collection<NotifyType>> m = new HashMap<>();
    for (ProjectWatchInfo info : input) {
        if (info.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        ProjectWatchKey key = ProjectWatchKey.create(projectsCollection.parse(info.project).getNameKey(), info.filter);
        if (m.containsKey(key)) {
            throw new BadRequestException("duplicate entry for project " + info.project + (info.filter != null ? " and filter " + info.filter : ""));
        }
        Set<NotifyType> notifyValues = new HashSet<>();
        if (toBoolean(info.notifyAbandonedChanges)) {
            notifyValues.add(NotifyType.ABANDONED_CHANGES);
        }
        if (toBoolean(info.notifyAllComments)) {
            notifyValues.add(NotifyType.ALL_COMMENTS);
        }
        if (toBoolean(info.notifyNewChanges)) {
            notifyValues.add(NotifyType.NEW_CHANGES);
        }
        if (toBoolean(info.notifyNewPatchSets)) {
            notifyValues.add(NotifyType.NEW_PATCHSETS);
        }
        if (toBoolean(info.notifySubmittedChanges)) {
            notifyValues.add(NotifyType.SUBMITTED_CHANGES);
        }
        m.put(key, notifyValues);
    }
    return m;
}
#method_after
private Map<ProjectWatchKey, Set<NotifyType>> asMap(List<ProjectWatchInfo> input) throws BadRequestException, UnprocessableEntityException, IOException {
    Map<ProjectWatchKey, Set<NotifyType>> m = new HashMap<>();
    for (ProjectWatchInfo info : input) {
        if (info.project == null) {
            throw new BadRequestException("project name must be specified");
        }
        ProjectWatchKey key = ProjectWatchKey.create(projectsCollection.parse(info.project).getNameKey(), info.filter);
        if (m.containsKey(key)) {
            throw new BadRequestException("duplicate entry for project " + format(info.project, info.filter));
        }
        Set<NotifyType> notifyValues = EnumSet.noneOf(NotifyType.class);
        if (toBoolean(info.notifyAbandonedChanges)) {
            notifyValues.add(NotifyType.ABANDONED_CHANGES);
        }
        if (toBoolean(info.notifyAllComments)) {
            notifyValues.add(NotifyType.ALL_COMMENTS);
        }
        if (toBoolean(info.notifyNewChanges)) {
            notifyValues.add(NotifyType.NEW_CHANGES);
        }
        if (toBoolean(info.notifyNewPatchSets)) {
            notifyValues.add(NotifyType.NEW_PATCHSETS);
        }
        if (toBoolean(info.notifySubmittedChanges)) {
            notifyValues.add(NotifyType.SUBMITTED_CHANGES);
        }
        m.put(key, notifyValues);
    }
    return m;
}
#end_block

#method_before
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to list project watches " + "of other users");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    List<ProjectWatchInfo> projectWatchInfos = new LinkedList<>();
    for (Map.Entry<ProjectWatchKey, Collection<NotifyType>> e : watchConfig.getProjectWatches(accountId).entrySet()) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = e.getKey().filter();
        pwi.project = e.getKey().project().get();
        pwi.notifyAbandonedChanges = toBoolean(e.getValue().contains(NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(e.getValue().contains(NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(e.getValue().contains(NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(e.getValue().contains(NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(e.getValue().contains(NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    return projectWatchInfos;
}
#method_after
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("It is not allowed to list project watches " + "of other users");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    List<ProjectWatchInfo> projectWatchInfos = new LinkedList<>();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : watchConfig.getProjectWatches(accountId).entrySet()) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = e.getKey().filter();
        pwi.project = e.getKey().project().get();
        pwi.notifyAbandonedChanges = toBoolean(e.getValue().contains(NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(e.getValue().contains(NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(e.getValue().contains(NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(e.getValue().contains(NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(e.getValue().contains(NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    Collections.sort(projectWatchInfos, new Comparator<ProjectWatchInfo>() {

        @Override
        public int compare(ProjectWatchInfo pwi1, ProjectWatchInfo pwi2) {
            return ComparisonChain.start().compare(pwi1.project, pwi2.project).compare(Strings.nullToEmpty(pwi1.filter), Strings.nullToEmpty(pwi2.filter)).result();
        }
    });
    return projectWatchInfos;
}
#end_block

#method_before
public List<SuggestedReviewerInfo> suggestReviewers(SuggestReviewers suggestReviewers, ProjectControl projectControl, VisibilityControl visibilityControl) throws IOException, OrmException, BadRequestException {
    String query = suggestReviewers.getQuery();
    boolean suggestAccounts = suggestReviewers.getSuggestAccounts();
    int suggestFrom = suggestReviewers.getSuggestFrom();
    int limit = suggestReviewers.getLimit();
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggestAccounts || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    Collection<AccountInfo> suggestedAccounts = suggestAccounts(suggestReviewers);
    List<SuggestedReviewerInfo> reviewer = new ArrayList<>();
    for (AccountInfo a : suggestedAccounts) {
        SuggestedReviewerInfo info = new SuggestedReviewerInfo();
        info.account = a;
        reviewer.add(info);
    }
    for (GroupReference g : suggestAccountGroup(suggestReviewers, projectControl)) {
        if (suggestGroupAsReviewer(suggestReviewers, projectControl.getProject(), g, visibilityControl)) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
            suggestedReviewerInfo.group = info;
            reviewer.add(suggestedReviewerInfo);
        }
    }
    reviewer = ORDERING.immutableSortedCopy(reviewer);
    if (reviewer.size() <= limit) {
        return reviewer;
    }
    return reviewer.subList(0, limit);
}
#method_after
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectControl projectControl, VisibilityControl visibilityControl, boolean excludeGroups) throws IOException, OrmException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        return Collections.emptyList();
    }
    List<Account.Id> candidateList = new ArrayList<>();
    if (!Strings.isNullOrEmpty(query)) {
        candidateList = suggestAccounts(suggestReviewers, visibilityControl);
    }
    List<Account.Id> sortedRecommendations = recommendAccounts(changeNotes, suggestReviewers, projectControl, candidateList);
    List<SuggestedReviewerInfo> suggestedReviewer = loadAccounts(sortedRecommendations);
    if (!excludeGroups && suggestedReviewer.size() < limit && !Strings.isNullOrEmpty(query)) {
        // Add groups at the end as individual accounts are usually more
        // important.
        suggestedReviewer.addAll(suggestAccountGroups(suggestReviewers, projectControl, visibilityControl, limit - suggestedReviewer.size()));
    }
    if (suggestedReviewer.size() <= limit) {
        return suggestedReviewer;
    }
    return suggestedReviewer.subList(0, limit);
}
#end_block

#method_before
private Collection<AccountInfo> suggestAccounts(SuggestReviewers suggestReviewers) throws OrmException {
    try {
        Map<Account.Id, AccountInfo> matches = new LinkedHashMap<>();
        QueryResult<AccountState> result = queryProcessor.setLimit(suggestReviewers.getLimit()).query(queryBuilder.defaultQuery(suggestReviewers.getQuery()));
        for (AccountState accountState : result.entities()) {
            Account.Id id = accountState.getAccount().getId();
            matches.put(id, accountLoader.get(id));
        }
        accountLoader.fill();
        return matches.values();
    } catch (QueryParseException e) {
        return ImmutableList.of();
    }
}
#method_after
private List<Account.Id> suggestAccounts(SuggestReviewers suggestReviewers, VisibilityControl visibilityControl) throws OrmException {
    try (Timer0.Context ctx = metrics.queryAccountsLatency.start()) {
        try {
            Set<Account.Id> matches = new HashSet<>();
            QueryResult<AccountState> result = accountQueryProcessor.setLimit(suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER).query(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery()));
            for (AccountState accountState : result.entities()) {
                Account.Id id = accountState.getAccount().getId();
                if (visibilityControl.isVisibleTo(id)) {
                    matches.add(id);
                }
            }
            return new ArrayList<>(matches);
        } catch (QueryParseException e) {
            return ImmutableList.of();
        }
    }
}
#end_block

#method_before
private boolean suggestGroupAsReviewer(SuggestReviewers suggestReviewers, Project project, GroupReference group, VisibilityControl visibilityControl) throws OrmException, IOException {
    int maxAllowed = suggestReviewers.getMaxAllowed();
    if (!PostReviewers.isLegalReviewerGroup(group.getUUID())) {
        return false;
    }
    try {
        Set<Account> members = groupMembersFactory.create(currentUser.get()).listAccounts(group.getUUID(), project.getNameKey());
        if (members.isEmpty()) {
            return false;
        }
        if (maxAllowed > 0 && members.size() > maxAllowed) {
            return false;
        }
        // require that at least one member in the group can see the change
        for (Account account : members) {
            if (visibilityControl.isVisibleTo(account.getId())) {
                return true;
            }
        }
    } catch (NoSuchGroupException e) {
        return false;
    } catch (NoSuchProjectException e) {
        return false;
    }
    return false;
}
#method_after
private GroupAsReviewer suggestGroupAsReviewer(SuggestReviewers suggestReviewers, Project project, GroupReference group, VisibilityControl visibilityControl) throws OrmException, IOException {
    GroupAsReviewer result = new GroupAsReviewer();
    int maxAllowed = suggestReviewers.getMaxAllowed();
    int maxAllowedWithoutConfirmation = suggestReviewers.getMaxAllowedWithoutConfirmation();
    if (!PostReviewers.isLegalReviewerGroup(group.getUUID())) {
        return result;
    }
    try {
        Set<Account> members = groupMembersFactory.create(currentUser.get()).listAccounts(group.getUUID(), project.getNameKey());
        if (members.isEmpty()) {
            return result;
        }
        result.size = members.size();
        if (maxAllowed > 0 && result.size > maxAllowed) {
            return result;
        }
        boolean needsConfirmation = result.size > maxAllowedWithoutConfirmation;
        // require that at least one member in the group can see the change
        for (Account account : members) {
            if (visibilityControl.isVisibleTo(account.getId())) {
                if (needsConfirmation) {
                    result.allowedWithConfirmation = true;
                } else {
                    result.allowed = true;
                }
                return result;
            }
        }
    } catch (NoSuchGroupException e) {
        return result;
    } catch (NoSuchProjectException e) {
        return result;
    }
    return result;
}
#end_block

#method_before
@Override
public String[] getList(String section, String subsection, String name) {
    return FluentIterable.from(Arrays.asList(sec.getStringList(section, subsection, name))).transform(decode).toArray(String.class);
}
#method_after
@Override
public String[] getList(String section, String subsection, String name) {
    return FluentIterable.from(Arrays.asList(sec.getStringList(section, subsection, name))).transform(codec.decodeFun).toArray(String.class);
}
#end_block

#method_before
@Override
public synchronized String[] getListForPlugin(String pluginName, String section, String subsection, String name) {
    FileBasedConfig cfg = null;
    if (pluginSec.containsKey(pluginName)) {
        cfg = pluginSec.get(pluginName);
    } else {
        String filename = pluginName + ".secure.config";
        File pluginConfigFile = site.etc_dir.resolve(filename).toFile();
        if (pluginConfigFile.exists()) {
            cfg = new FileBasedConfig(pluginConfigFile, FS.DETECTED);
            try {
                cfg.load();
                pluginSec.put(pluginName, cfg);
            } catch (IOException | ConfigInvalidException e) {
                throw new RuntimeException("Cannot load " + filename, e);
            }
        }
    }
    return cfg != null ? FluentIterable.from(Arrays.asList(cfg.getStringList(section, subsection, name))).transform(decode).toArray(String.class) : null;
}
#method_after
@Override
public synchronized String[] getListForPlugin(String pluginName, String section, String subsection, String name) {
    FileBasedConfig cfg = null;
    if (pluginSec.containsKey(pluginName)) {
        cfg = pluginSec.get(pluginName);
    } else {
        String filename = pluginName + ".secure.config";
        File pluginConfigFile = site.etc_dir.resolve(filename).toFile();
        if (pluginConfigFile.exists()) {
            cfg = new FileBasedConfig(pluginConfigFile, FS.DETECTED);
            try {
                cfg.load();
                pluginSec.put(pluginName, cfg);
            } catch (IOException | ConfigInvalidException e) {
                throw new RuntimeException("Cannot load " + filename, e);
            }
        }
    }
    return cfg != null ? FluentIterable.from(Arrays.asList(cfg.getStringList(section, subsection, name))).transform(codec.decodeFun).toArray(String.class) : null;
}
#end_block

#method_before
@Override
public void setList(String section, String subsection, String name, List<String> values) {
    if (values != null) {
        sec.setStringList(section, subsection, name, FluentIterable.from(values).transform(encode).toList());
    } else {
        sec.unset(section, subsection, name);
    }
    save();
}
#method_after
@Override
public void setList(String section, String subsection, String name, List<String> values) {
    if (values != null) {
        sec.setStringList(section, subsection, name, FluentIterable.from(values).transform(codec.encodeFun).toList());
    } else {
        sec.unset(section, subsection, name);
    }
    save();
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get comments", e);
    }
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get robot comments", e);
    }
}
#end_block

#method_before
@Test
public void addedRobotCommentsCanBeRetrievedByChange() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    RobotCommentInput in = createRobotCommentInput();
    addRobotComment(changeId, in);
    Map<String, List<RobotCommentInfo>> out = gApi.changes().id(changeId).robotComments();
    assertThat(out).hasSize(1);
    RobotCommentInfo comment = Iterables.getOnlyElement(out.get(in.path));
    assertRobotComment(comment, in, false);
}
#method_after
@Test
public void addedRobotCommentsCanBeRetrievedByChange() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    RobotCommentInput in = createRobotCommentInput();
    addRobotComment(changeId, in);
    pushFactory.create(db, admin.getIdent(), testRepo, changeId).to("refs/for/master");
    RobotCommentInput in2 = createRobotCommentInput();
    addRobotComment(changeId, in2);
    Map<String, List<RobotCommentInfo>> out = gApi.changes().id(changeId).robotComments();
    assertThat(out).hasSize(1);
    assertThat(out.get(in.path)).hasSize(2);
    RobotCommentInfo comment1 = out.get(in.path).get(0);
    assertRobotComment(comment1, in, false);
    RobotCommentInfo comment2 = out.get(in.path).get(1);
    assertRobotComment(comment2, in2, false);
}
#end_block

#method_before
private OwnersConfig getOwners(String ownersPath) {
    String owners = getContent(repository, "master", ownersPath);
    if (owners != null) {
        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
        try {
            return mapper.readValue(owners, OwnersConfig.class);
        } catch (IOException e) {
            log.warn("Invalid OWNERS file: {}", ownersPath, e);
            return null;
        }
    }
    return null;
}
#method_after
private OwnersConfig getOwners(String ownersPath) {
    try {
        return getBlobAsBytes(repository, "master", ownersPath).flatMap(this::parseYaml).orElse(null);
    } catch (Exception e) {
        log.warn("Invalid OWNERS file: {}", ownersPath, e);
        return null;
    }
}
#end_block

#method_before
@Override
public void start() {
    int cpus = Runtime.getRuntime().availableProcessors();
    if (config.getBoolean("cache", "projects", "loadOnStartup", false)) {
        final ThreadPoolExecutor pool = new ScheduledThreadPoolExecutor(config.getInt("cache", "projects", "loadThreads", cpus), new ThreadFactoryBuilder().setNameFormat("ProjectCacheLoader-%d").build());
        ExecutorService scheduler = Executors.newFixedThreadPool(1);
        log.info("Loading project cache");
        scheduler.execute(new Runnable() {

            @Override
            public void run() {
                for (final Project.NameKey name : cache.all()) {
                    pool.execute(new Runnable() {

                        @Override
                        public void run() {
                            cache.get(name);
                        }
                    });
                }
                pool.shutdown();
                try {
                    pool.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
                    log.info("Finished loading project cache");
                } catch (InterruptedException e) {
                    log.warn("Interrupted while waiting on project cache to load");
                }
            }
        });
    }
}
#method_after
@Override
public void start() {
    int cpus = Runtime.getRuntime().availableProcessors();
    if (config.getBoolean("cache", "projects", "loadOnStartup", false)) {
        final ThreadPoolExecutor pool = new ScheduledThreadPoolExecutor(config.getInt("cache", "projects", "loadThreads", cpus), new ThreadFactoryBuilder().setNameFormat("ProjectCacheLoader-%d").build());
        ExecutorService scheduler = Executors.newFixedThreadPool(1);
        log.info("Loading project cache");
        scheduler.execute(new Runnable() {

            @Override
            public void run() {
                for (final Project.NameKey name : cache.all()) {
                    pool.execute(new Runnable() {

                        @Override
                        public void run() {
                            cache.get(name);
                        }
                    });
                }
                pool.shutdown();
                try {
                    pool.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
                    log.info("Finished loading project cache");
                } catch (InterruptedException e) {
                    log.warn("Interrupted while waiting for project cache to load");
                }
            }
        });
    }
}
#end_block

#method_before
public void markCleanMerges(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final Set<RevCommit> alreadyAccepted) throws IntegrationException {
    if (mergeTip == null) {
        // 
        return;
    }
    try {
        rw.resetRetain(canMergeFlag);
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            // If branch was not created by this submit.
            if (c != mergeTip) {
                rw.markUninteresting(c);
            }
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.getPatchsetId() != null && c.getStatusCode() == null) {
                c.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Cannot mark clean merges", e);
    }
}
#method_after
public void markCleanMerges(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final Set<RevCommit> alreadyAccepted) throws IntegrationException {
    if (mergeTip == null) {
        // 
        return;
    }
    try {
        rw.resetRetain(canMergeFlag);
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            // If branch was not created by this submit.
            if (!Objects.equals(c, mergeTip)) {
                rw.markUninteresting(c);
            }
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.getPatchsetId() != null && c.getStatusCode() == null) {
                c.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Cannot mark clean merges", e);
    }
}
#end_block

#method_before
@Override
protected void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // If there is only one parent, a cherry-pick can be done by taking the
    // delta relative to that one parent and redoing that on the current merge
    // tip.
    args.rw.parseBody(toMerge);
    psId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
    String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(toMerge);
    PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
    try {
        newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, false);
    } catch (MergeConflictException mce) {
        // Keep going in the case of a single merge failure; the goal is to
        // cherry-pick as many commits as possible.
        toMerge.setStatusCode(CommitMergeStatus.PATH_CONFLICT);
        return;
    } catch (MergeIdenticalTreeException mie) {
        toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
        return;
    }
    // Initial copy doesn't have new patch set ID since change hasn't been
    // updated yet.
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(psId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commits.put(newCommit);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, psId.toRefName()));
    patchSetInfo = args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, psId);
}
#method_after
@Override
protected void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // If there is only one parent, a cherry-pick can be done by taking the
    // delta relative to that one parent and redoing that on the current merge
    // tip.
    args.rw.parseBody(toMerge);
    psId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
    RevCommit mergeTip = args.mergeTip.getCurrentTip();
    args.rw.parseBody(mergeTip);
    String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
    PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
    try {
        newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, false);
    } catch (MergeConflictException mce) {
        // Keep going in the case of a single merge failure; the goal is to
        // cherry-pick as many commits as possible.
        toMerge.setStatusCode(CommitMergeStatus.PATH_CONFLICT);
        return;
    } catch (MergeIdenticalTreeException mie) {
        toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
        return;
    }
    // Initial copy doesn't have new patch set ID since change hasn't been
    // updated yet.
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(psId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commits.put(newCommit);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, psId.toRefName()));
    patchSetInfo = args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, psId);
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = sort(toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    for (CodeReviewCommit c : sorted) {
        if (c.getParentCount() > 1) {
            // Since there is a merge commit, sort and prune again using
            // MERGE_IF_NECESSARY semantics to avoid creating duplicate
            // commits.
            // 
            sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, sorted);
            break;
        }
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            // TODO(tandrii): Cherry-Pick strategy does this too, but it's wrong
            // and can be fixed.
            ops.add(new FastForwardOp(args, n));
        } else if (n.getParentCount() == 0) {
            ops.add(new RebaseRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new RebaseOneOp(n));
        } else {
            ops.add(new RebaseMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = sort(toMerge, args.mergeTip.getCurrentTip());
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    for (CodeReviewCommit c : sorted) {
        if (c.getParentCount() > 1) {
            // Since there is a merge commit, sort and prune again using
            // MERGE_IF_NECESSARY semantics to avoid creating duplicate
            // commits.
            // 
            sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, sorted);
            break;
        }
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            // TODO(tandrii): Cherry-Pick strategy does this too, but it's wrong
            // and can be fixed.
            ops.add(new FastForwardOp(args, n));
        } else if (n.getParentCount() == 0) {
            ops.add(new RebaseRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new RebaseOneOp(n));
        } else {
            ops.add(new RebaseMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // BatchUpdate how to produce CodeReviewRevWalks.
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
        // TODO(tandrii): add extension point to customize this commit message.
        String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(toMerge);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, true);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            // this should not happen
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName()));
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getControl().getNotes(), toMerge.getPatchsetId());
        // TODO(tandrii): add extension point to customize commit message while
        // rebasing.
        rebaseOp = args.rebaseFactory.create(toMerge.getControl(), origPs, args.mergeTip.getCurrentTip().name()).setFireRevisionCreated(false).setCopyApprovals(false).setValidatePolicy(CommitValidators.Policy.NONE).setPostMessage(false);
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commits.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // BatchUpdate how to produce CodeReviewRevWalks.
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
        RevCommit mergeTip = args.mergeTip.getCurrentTip();
        args.rw.parseBody(mergeTip);
        String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, true);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            // this should not happen
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName()));
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getControl().getNotes(), toMerge.getPatchsetId());
        rebaseOp = args.rebaseFactory.create(toMerge.getControl(), origPs, args.mergeTip.getCurrentTip().name()).setFireRevisionCreated(false).setCopyApprovals(false).setValidatePolicy(CommitValidators.Policy.NONE).setDetailedCommitMessage(rebaseAlways).setPostMessage(false);
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commits.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // There are multiple parents, so this is a merge commit. We don't want
    // to rebase the merge as clients can't easily rebase their history with
    // that merge present and replaced by an equivalent merge with a different
    // first parent. So instead behave as though MERGE_IF_NECESSARY was
    // configured.
    // TODO(tandrii): this is not in spirit of RebaseAlways strategy because
    // the commit messages can not be modified in the process. It's also
    // possible to implement rebasing of merge commits. E.g., the Cherry Pick
    // REST endpoint already supports cherry-picking of merge commits.
    // For now, users of RebaseAlways strategy for whom changed commit footers
    // are important would be well advised to prohibit uploading patches with
    // merge commits.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(args.serverIdent, args.serverIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        mergeTip.moveTipTo(amendGitlink(newTip), toMerge);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    acceptMergeTip(mergeTip);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // There are multiple parents, so this is a merge commit. We don't want
    // to rebase the merge as clients can't easily rebase their history with
    // that merge present and replaced by an equivalent merge with a different
    // first parent. So instead behave as though MERGE_IF_NECESSARY was
    // configured.
    // TODO(tandrii): this is not in spirit of RebaseAlways strategy because
    // the commit messages can not be modified in the process. It's also
    // possible to implement rebasing of merge commits. E.g., the Cherry Pick
    // REST endpoint already supports cherry-picking of merge commits.
    // For now, users of RebaseAlways strategy for whom changed commit footers
    // are important would be well advised to prohibit uploading patches with
    // merge commits.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(args.serverIdent, args.serverIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        mergeTip.moveTipTo(amendGitlink(newTip), toMerge);
    }
    RevCommit initialTip = mergeTip.getInitialTip();
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), initialTip == null ? ImmutableSet.<RevCommit>of() : ImmutableSet.of(initialTip));
    acceptMergeTip(mergeTip);
}
#end_block

#method_before
private List<CodeReviewCommit> sort(Collection<CodeReviewCommit> toSort) throws IntegrationException {
    try {
        return new RebaseSorter(args.rw, args.alreadyAccepted, args.canMergeFlag, args.internalChangeQuery).sort(toSort);
    } catch (IOException e) {
        throw new IntegrationException("Commit sorting failed", e);
    }
}
#method_after
private List<CodeReviewCommit> sort(Collection<CodeReviewCommit> toSort, RevCommit initialTip) throws IntegrationException {
    try {
        return new RebaseSorter(args.rw, initialTip, args.alreadyAccepted, args.canMergeFlag).sort(toSort);
    } catch (IOException e) {
        throw new IntegrationException("Commit sorting failed", e);
    }
}
#end_block

#method_before
@Test
public void pathOfFixReplacementMustReferToFileOfComment() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    fixReplacementInfo.path = "anotherFile.txt";
    exception.expect(BadRequestException.class);
    exception.expectMessage(String.format("At the moment, replacements may only" + " be specified for the file %s on which the robot comment was added", withFixRobotCommentInput.path));
    addRobotComment(changeId, withFixRobotCommentInput);
}
#method_after
@Test
public void pathOfFixReplacementMustReferToFileOfComment() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    fixReplacementInfo.path = "anotherFile.txt";
    exception.expect(BadRequestException.class);
    exception.expectMessage(String.format("Replacements may only be specified " + "for the file %s on which the robot comment was added", withFixRobotCommentInput.path));
    addRobotComment(changeId, withFixRobotCommentInput);
}
#end_block

#method_before
private void ensureReplacementPathRefersToFileOfComment(String commentPath, String replacementPath) throws BadRequestException {
    if (!Objects.equals(commentPath, replacementPath)) {
        throw new BadRequestException(String.format("At the moment, replacements " + "may only be specified for the file %s on which the robot comment " + "was added", commentPath));
    }
}
#method_after
private void ensureReplacementPathRefersToFileOfComment(String commentPath, String replacementPath) throws BadRequestException {
    if (!Objects.equals(commentPath, replacementPath)) {
        throw new BadRequestException(String.format("Replacements may only be " + "specified for the file %s on which the robot comment was added", commentPath));
    }
}
#end_block

#method_before
void createNotes(String branch, ObjectId oldObjectId, ObjectId newObjectId, ProgressMonitor monitor) throws OrmException, IOException {
    if (ObjectId.zeroId().equals(newObjectId)) {
        return;
    }
    try (RevWalk rw = new RevWalk(git)) {
        try {
            RevCommit n = rw.parseCommit(newObjectId);
            rw.markStart(n);
            if (n.getParentCount() == 1 && n.getParent(0).equals(oldObjectId)) {
                rw.markUninteresting(rw.parseCommit(oldObjectId));
            } else {
                markUninteresting(git, branch, rw, oldObjectId);
            }
        } catch (Exception e) {
            log.error(e.getMessage(), e);
            return;
        }
        if (monitor == null) {
            monitor = NullProgressMonitor.INSTANCE;
        }
        for (RevCommit c : rw) {
            PatchSet ps = loadPatchSet(c, branch);
            if (ps != null) {
                ChangeNotes notes = notesFactory.create(reviewDb, project, ps.getId().getParentKey());
                ObjectId content = createNoteContent(notes, ps);
                if (content != null) {
                    monitor.update(1);
                    getNotes().set(c, content);
                    getMessage().append("* ").append(c.getShortMessage()).append("\n");
                }
            }
        }
    }
}
#method_after
void createNotes(String branch, ObjectId oldObjectId, ObjectId newObjectId, ProgressMonitor monitor) throws OrmException, IOException {
    if (ObjectId.zeroId().equals(newObjectId)) {
        return;
    }
    try (RevWalk rw = new RevWalk(git)) {
        try {
            RevCommit n = rw.parseCommit(newObjectId);
            rw.markStart(n);
            if (n.getParentCount() == 1 && n.getParent(0).equals(oldObjectId)) {
                rw.markUninteresting(rw.parseCommit(oldObjectId));
            } else {
                markUninteresting(git, branch, rw, oldObjectId);
            }
        } catch (Exception e) {
            log.error(e.getMessage(), e);
            return;
        }
        if (monitor == null) {
            monitor = NullProgressMonitor.INSTANCE;
        }
        for (RevCommit c : rw) {
            PatchSet ps = loadPatchSet(c, branch);
            if (ps != null) {
                ChangeNotes notes = notesFactory.create(reviewDb, project, ps.getId().getParentKey());
                ObjectId content = createNoteContent(notes, ps);
                if (content != null) {
                    monitor.update(1);
                    getNotes().set(c, content);
                    getMessage().append("* ").append(c.getShortMessage()).append("\n");
                }
            } else {
                log.debug("no note for this commit since it is a direct push: " + c.getName().substring(0, 7));
            }
        }
    }
}
#end_block

#method_before
private void export(ReviewDb db, Project.NameKey project, List<Change> changes) throws IOException, OrmException {
    try (Repository git = gitManager.openRepository(project)) {
        try {
            CreateReviewNotes crn = reviewNotesFactory.create(db, project, git);
            crn.createNotes(changes, monitor);
            crn.commitNotes();
        } catch (ConcurrentRefUpdateException e) {
            stderr.println(e.getMessage());
        }
    } catch (RepositoryNotFoundException e) {
        stderr.println("Unable to open project: " + project.get());
        return;
    }
}
#method_after
private void export(ReviewDb db, Project.NameKey project, List<Change> changes) throws IOException, OrmException {
    try (Repository git = gitManager.openRepository(project)) {
        CreateReviewNotes crn = reviewNotesFactory.create(db, project, git);
        crn.createNotes(changes, monitor);
        crn.commitNotes();
    } catch (RepositoryNotFoundException e) {
        stderr.println("Unable to open project: " + project.get());
    } catch (ConcurrentRefUpdateException e) {
        stderr.println(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void run() {
    try (ReviewDb db = database.open()) {
        for (; ; ) {
            Entry<Project.NameKey, List<Change>> next = next();
            if (next != null) {
                try {
                    export(db, next.getKey(), next.getValue());
                } catch (OrmException | IOException e) {
                    stderr.println(e.getMessage());
                }
            } else {
                break;
            }
        }
    } catch (OrmException e) {
        stderr.println(e.getMessage());
        return;
    } finally {
        monitor.endWorker();
    }
}
#method_after
@Override
public void run() {
    try (ReviewDb db = database.open()) {
        for (; ; ) {
            Entry<Project.NameKey, List<Change>> next = next();
            if (next != null) {
                try {
                    export(db, next.getKey(), next.getValue());
                } catch (OrmException | IOException e) {
                    stderr.println(e.getMessage());
                }
            } else {
                break;
            }
        }
    } catch (OrmException e) {
        stderr.println(e.getMessage());
    } finally {
        monitor.endWorker();
    }
}
#end_block

#method_before
private void createReviewNotes(Event e) {
    Project.NameKey projectName = new Project.NameKey(e.getProjectName());
    try (Repository git = repoManager.openRepository(projectName)) {
        try (ReviewDb reviewDb = schema.open()) {
            CreateReviewNotes crn = reviewNotesFactory.create(reviewDb, projectName, git);
            if (e.getRefName().startsWith("refs/heads/")) {
                crn.createNotes(e.getRefName(), ObjectId.fromString(e.getOldObjectId()), ObjectId.fromString(e.getNewObjectId()), null);
                crn.commitNotes();
            }
        } catch (OrmException | IOException | ConcurrentRefUpdateException x) {
            log.error(x.getMessage(), x);
            return;
        }
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
}
#method_after
private void createReviewNotes(Event e) {
    Project.NameKey projectName = new Project.NameKey(e.getProjectName());
    try (Repository git = repoManager.openRepository(projectName);
        ReviewDb reviewDb = schema.open()) {
        CreateReviewNotes crn = reviewNotesFactory.create(reviewDb, projectName, git);
        if (e.getRefName().startsWith("refs/heads/")) {
            crn.createNotes(e.getRefName(), ObjectId.fromString(e.getOldObjectId()), ObjectId.fromString(e.getNewObjectId()), null);
            crn.commitNotes();
        }
    } catch (OrmException | IOException | ConcurrentRefUpdateException x) {
        log.error(x.getMessage(), x);
    }
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    boolean hasComments = false;
    try (Repository repo = getRepository()) {
        List<Map<String, Object>> files = getCommentGroupsTemplateData(repo);
        soyContext.put("commentFiles", files);
        hasComments = !files.isEmpty();
    }
    soyContext.put("patchSetCommentBlocks", commentBlocksToSoyData(CommentFormatter.parse(patchSetComment)));
    soyContext.put("labels", getLabelSoyData(labels));
    soyContext.put("commentCount", inlineComments.size());
    soyContext.put("commentTimestamp", getCommentTimestamp());
    soyContext.put("coverLetterBlocks", commentBlocksToSoyData(CommentFormatter.parse(getCoverLetter())));
    footers.add("Gerrit-Comment-Date: " + getCommentTimestamp());
    footers.add("Gerrit-HasComments: " + (hasComments ? "Yes" : "No"));
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    boolean hasComments = false;
    try (Repository repo = getRepository()) {
        List<Map<String, Object>> files = getCommentGroupsTemplateData(repo);
        soyContext.put("commentFiles", files);
        hasComments = !files.isEmpty();
    }
    soyContext.put("patchSetCommentBlocks", commentBlocksToSoyData(CommentFormatter.parse(patchSetComment)));
    soyContext.put("labels", getLabelVoteSoyData(labels));
    soyContext.put("commentCount", inlineComments.size());
    soyContext.put("commentTimestamp", getCommentTimestamp());
    soyContext.put("coverLetterBlocks", commentBlocksToSoyData(CommentFormatter.parse(getCoverLetter())));
    footers.add("Gerrit-Comment-Date: " + getCommentTimestamp());
    footers.add("Gerrit-HasComments: " + (hasComments ? "Yes" : "No"));
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    removable.removeAll(fixed);
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, 0)) {
                removable.add(id);
            }
        }
    }
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, 0)) {
                removable.add(id);
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#end_block

#method_before
protected void setCacheHeaders(HttpServletRequest req, HttpServletResponse res) {
    String pragma = req.getHeader(HttpHeaders.PRAGMA);
    if (!Strings.isNullOrEmpty(pragma) && pragma.equals("no-cache")) {
        setNotCacheable(res);
        return;
    }
    String cacheControl = req.getHeader(HttpHeaders.CACHE_CONTROL);
    if (!Strings.isNullOrEmpty(cacheControl) && cacheControl.equals("no-cache")) {
        setNotCacheable(res);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    Revision rev = view.getRevision();
    if (rev.nameIsId()) {
        // Cache for 1 day.
        res.setHeader(HttpHeaders.CACHE_CONTROL, "private, max-age=86400");
        return;
    }
    setNotCacheable(res);
}
#method_after
protected void setCacheHeaders(HttpServletRequest req, HttpServletResponse res) {
    if (Strings.nullToEmpty(req.getHeader(HttpHeaders.PRAGMA)).equalsIgnoreCase("no-cache") || Strings.nullToEmpty(req.getHeader(HttpHeaders.CACHE_CONTROL)).equalsIgnoreCase("no-cache")) {
        setNotCacheable(res);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    Revision rev = view.getRevision();
    if (rev.nameIsId()) {
        res.setHeader(HttpHeaders.CACHE_CONTROL, "private, max-age=7200, stale-while-revalidate=604800");
        return;
    }
    setNotCacheable(res);
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getParentLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput, boolean dryrun) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.dryrun = dryrun;
    this.caller = caller;
    this.ts = TimeUtil.nowTs();
    submissionId = RequestId.forChange(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.setMergeOpRepoManager(orm).completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput, boolean dryrun) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.accountsToNotify = notifyUtil.resolveAccounts(submitInput.notifyDetails);
    this.dryrun = dryrun;
    this.caller = caller;
    this.ts = TimeUtil.nowTs();
    submissionId = RequestId.forChange(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.setMergeOpRepoManager(orm).completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify, submoduleOp, dryrun);
}
#method_after
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify, accountsToNotify, submoduleOp, dryrun);
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Updated watch configuration\n");
    }
    Config cfg = readConfig(WATCH_CONFIG);
    for (String projectName : cfg.getSubsections(PROJECT)) {
        cfg.unset(PROJECT, projectName, KEY_NOTIFY);
    }
    Multimap<String, String> notifyValuesByProject = MultimapBuilder.hashKeys().arrayListValues().build();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches.entrySet()) {
        NotifyValue notifyValue = NotifyValue.create(e.getKey().filter(), e.getValue());
        notifyValuesByProject.put(e.getKey().project().get(), notifyValue.toString());
    }
    for (Map.Entry<String, Collection<String>> e : notifyValuesByProject.asMap().entrySet()) {
        cfg.setStringList(PROJECT, e.getKey(), KEY_NOTIFY, new ArrayList<>(e.getValue()));
    }
    saveConfig(WATCH_CONFIG, cfg);
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    checkLoaded();
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Updated watch configuration\n");
    }
    Config cfg = readConfig(WATCH_CONFIG);
    for (String projectName : cfg.getSubsections(PROJECT)) {
        cfg.unsetSection(PROJECT, projectName);
    }
    Multimap<String, String> notifyValuesByProject = MultimapBuilder.hashKeys().arrayListValues().build();
    for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches.entrySet()) {
        NotifyValue notifyValue = NotifyValue.create(e.getKey().filter(), e.getValue());
        notifyValuesByProject.put(e.getKey().project().get(), notifyValue.toString());
    }
    for (Map.Entry<String, Collection<String>> e : notifyValuesByProject.asMap().entrySet()) {
        cfg.setStringList(PROJECT, e.getKey(), KEY_NOTIFY, new ArrayList<>(e.getValue()));
    }
    saveConfig(WATCH_CONFIG, cfg);
    return true;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
        }
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getParentLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(IndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    factory(AccountIndexer.Factory.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(IndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
}
#end_block

#method_before
@Override
public void evict(Account.Id accountId) throws IOException {
    if (accountId != null) {
        byId.invalidate(accountId);
        indexer.get().index(accountId);
    }
}
#method_after
@Override
public void evict(Account.Id accountId) throws IOException {
    if (accountId != null) {
        byId.invalidate(accountId);
        index(accountId);
    }
}
#end_block

#method_before
public List<WebLinkInfo> getFileHistoryLinks(String project, String revision, String file) {
    return filterLinks(fileHistoryLinks, webLink -> webLink.getFileHistoryWebLink(project, revision, file));
}
#method_after
public List<WebLinkInfoCommon> getFileHistoryLinks(String project, String revision, String file) {
    return FluentIterable.from(fileHistoryLinks).transform(webLink -> {
        WebLinkInfo info = webLink.getFileHistoryWebLink(project, revision, file);
        if (info == null) {
            return null;
        }
        WebLinkInfoCommon commonInfo = new WebLinkInfoCommon();
        commonInfo.name = info.name;
        commonInfo.imageUrl = info.imageUrl;
        commonInfo.url = info.url;
        commonInfo.target = info.target;
        return commonInfo;
    }).filter(INVALID_WEBLINK_COMMON).toList();
}
#end_block

#method_before
private List<WebLinkInfoCommon> getConfigFileLogLinks(String projectName) {
    List<WebLinkInfoCommon> links = webLinks.getFileHistoryLinksCommon(projectName, RefNames.REFS_CONFIG, ProjectConfig.PROJECT_CONFIG);
    return links.isEmpty() ? null : links;
}
#method_after
private List<WebLinkInfoCommon> getConfigFileLogLinks(String projectName) {
    List<WebLinkInfoCommon> links = webLinks.getFileHistoryLinks(projectName, RefNames.REFS_CONFIG, ProjectConfig.PROJECT_CONFIG);
    return links.isEmpty() ? null : links;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
@Override
public Response<?> apply(ProjectResource project, DeleteTagsInput input) throws OrmException, IOException, ResourceConflictException {
    if (input == null) {
        input = new DeleteTagsInput();
    }
    if (input.tags == null) {
        input.tags = Lists.newArrayListWithCapacity(1);
    }
    try (Repository r = repoManager.openRepository(project.getNameKey())) {
        BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate();
        for (String tag : input.tags) {
            batchUpdate.addCommand(createDeleteCommand(project, r, tag));
        }
        try (RevWalk rw = new RevWalk(r)) {
            batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        }
        StringBuilder errorMessages = new StringBuilder();
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() == Result.OK) {
                postDeletion(project, command);
            } else {
                appendAndLogErrorMessage(errorMessages, command);
            }
        }
        if (errorMessages.length() > 0) {
            throw new ResourceConflictException(errorMessages.toString());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ProjectResource project, DeleteTagsInput input) throws OrmException, RestApiException, IOException {
    if (input == null || input.tags == null || input.tags.isEmpty()) {
        throw new BadRequestException("tags must be specified");
    }
    deleteRefFactory.create(project).refs(input.tags).prefix(R_TAGS).delete();
    return Response.none();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    factory(DeleteRef.Factory.class);
}
#end_block

#method_before
Multimap<RecipientType, Account.Id> getAccountsToNotify() {
    if ((tos == null || tos.isEmpty()) && (ccs == null || ccs.isEmpty()) && (bccs == null || bccs.isEmpty())) {
        return null;
    }
    Multimap<RecipientType, Account.Id> accountsToNotify = ArrayListMultimap.create();
    if (tos != null) {
        accountsToNotify.putAll(RecipientType.TO, tos);
    }
    if (ccs != null) {
        accountsToNotify.putAll(RecipientType.CC, ccs);
    }
    if (bccs != null) {
        accountsToNotify.putAll(RecipientType.BCC, bccs);
    }
    return accountsToNotify;
}
#method_after
Multimap<RecipientType, Account.Id> getAccountsToNotify() {
    Multimap<RecipientType, Account.Id> accountsToNotify = ArrayListMultimap.create();
    accountsToNotify.putAll(RecipientType.TO, tos);
    accountsToNotify.putAll(RecipientType.CC, ccs);
    accountsToNotify.putAll(RecipientType.BCC, bccs);
    return accountsToNotify;
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.publish(editUtil.byChange(change).get(), NotifyHandling.NONE, null);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
}
#method_after
@Test
public void publishEdit() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.publish(editUtil.byChange(change).get(), NotifyHandling.NONE, ImmutableListMultimap.of());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
}
#end_block

#method_before
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String msg = String.format("New commit message\n\nChange-Id: %s\n", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get(), NotifyHandling.NONE, null);
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Commit message was updated."));
}
#method_after
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String msg = String.format("New commit message\n\nChange-Id: %s\n", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get(), NotifyHandling.NONE, ImmutableListMultimap.of());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Commit message was updated."));
}
#end_block

#method_before
@Test
public void updateMessageRest() throws Exception {
    adminRestSession.get(urlEditMessage(false)).assertNotFound();
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2_STR + "\n\nChange-Id: %s\n", change.getKey());
    adminRestSession.put(urlEditMessage(false), in).assertNoContent();
    RestResponse r = adminRestSession.getJsonAccept(urlEditMessage(false));
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s\n", change.getKey());
    adminRestSession.put(urlEditMessage(false), in).assertNoContent();
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    r = adminRestSession.getJsonAccept(urlEditMessage(true));
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        assertThat(readContentFromJson(r)).isEqualTo(commit.getFullMessage());
    }
    editUtil.publish(edit.get(), NotifyHandling.NONE, null);
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Commit message was updated."));
}
#method_after
@Test
public void updateMessageRest() throws Exception {
    adminRestSession.get(urlEditMessage(false)).assertNotFound();
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2_STR + "\n\nChange-Id: %s\n", change.getKey());
    adminRestSession.put(urlEditMessage(false), in).assertNoContent();
    RestResponse r = adminRestSession.getJsonAccept(urlEditMessage(false));
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s\n", change.getKey());
    adminRestSession.put(urlEditMessage(false), in).assertNoContent();
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    r = adminRestSession.getJsonAccept(urlEditMessage(true));
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        assertThat(readContentFromJson(r)).isEqualTo(commit.getFullMessage());
    }
    editUtil.publish(edit.get(), NotifyHandling.NONE, ImmutableListMultimap.of());
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Commit message was updated."));
}
#end_block

#method_before
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    String changeId = change.getKey().get();
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.<String, Short>of(cr, (short) 1);
    gApi.changes().id(changeId).revision(change.currentPatchSetId().get()).review(r);
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    assertThat(modifier.modifyMessage(edit.get(), newMsg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    editUtil.publish(edit.get(), NotifyHandling.NONE, null);
    ChangeInfo info = get(changeId);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#method_after
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    String changeId = change.getKey().get();
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.<String, Short>of(cr, (short) 1);
    gApi.changes().id(changeId).revision(change.currentPatchSetId().get()).review(r);
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    assertThat(modifier.modifyMessage(edit.get(), newMsg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    editUtil.publish(edit.get(), NotifyHandling.NONE, ImmutableListMultimap.of());
    ChangeInfo info = get(changeId);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#end_block

#method_before
@Test
public void testHasEditPredicate() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(queryEdits()).hasSize(1);
    PatchSet current = getCurrentPatchSet(changeId2);
    assertThat(modifier.createEdit(change2, current)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change2).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    assertThat(queryEdits()).hasSize(2);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.delete(editUtil.byChange(change).get());
    assertThat(queryEdits()).hasSize(1);
    editUtil.publish(editUtil.byChange(change2).get(), NotifyHandling.NONE, null);
    assertThat(queryEdits()).hasSize(0);
    setApiUser(user);
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(queryEdits()).hasSize(1);
    setApiUser(admin);
    assertThat(queryEdits()).hasSize(0);
}
#method_after
@Test
public void testHasEditPredicate() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(queryEdits()).hasSize(1);
    PatchSet current = getCurrentPatchSet(changeId2);
    assertThat(modifier.createEdit(change2, current)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change2).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    assertThat(queryEdits()).hasSize(2);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.delete(editUtil.byChange(change).get());
    assertThat(queryEdits()).hasSize(1);
    editUtil.publish(editUtil.byChange(change2).get(), NotifyHandling.NONE, ImmutableListMultimap.of());
    assertThat(queryEdits()).hasSize(0);
    setApiUser(user);
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(queryEdits()).hasSize(1);
    setApiUser(admin);
    assertThat(queryEdits()).hasSize(0);
}
#end_block

#method_before
public PatchSetInserter setAccountsToNotify(Multimap<RecipientType, Account.Id> accountsToNotify) {
    this.accountsToNotify = accountsToNotify;
    return this;
}
#method_after
public PatchSetInserter setAccountsToNotify(Multimap<RecipientType, Account.Id> accountsToNotify) {
    this.accountsToNotify = checkNotNull(accountsToNotify);
    return this;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (notify != NotifyHandling.NONE || (accountsToNotify != null && !accountsToNotify.isEmpty())) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(ctx.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.addReviewers(oldReviewers.byState(REVIEWER));
            cm.addExtraCC(oldReviewers.byState(CC));
            cm.setNotify(notify);
            cm.setAccountsToNotify(accountsToNotify);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty()) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(ctx.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.addReviewers(oldReviewers.byState(REVIEWER));
            cm.addExtraCC(oldReviewers.byState(CC));
            cm.setNotify(notify);
            cm.setAccountsToNotify(accountsToNotify);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
    }
}
#end_block

#method_before
public void setAccountsToNotify(Multimap<RecipientType, Account.Id> accountsToNotify) {
    this.accountsToNotify = accountsToNotify != null ? ImmutableListMultimap.copyOf(accountsToNotify) : null;
}
#method_after
public void setAccountsToNotify(Multimap<RecipientType, Account.Id> accountsToNotify) {
    this.accountsToNotify = checkNotNull(accountsToNotify);
}
#end_block

#method_before
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify) && (accountsToNotify == null || accountsToNotify.isEmpty())) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("HeaderHtml"));
    }
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if ((accountsToNotify == null || !accountsToNotify.containsValue(fromId)) && rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        String textPart = textBody.toString();
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = textPart;
        if (useHtml()) {
            va.htmlBody = htmlBody.toString();
        } else {
            va.htmlBody = null;
        }
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body, va.htmlBody);
    }
}
#method_after
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify) && accountsToNotify.isEmpty()) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("HeaderHtml"));
    }
    format();
    appendText(textTemplate("Footer"));
    if (useHtml()) {
        appendHtml(soyHtmlTemplate("FooterHtml"));
    }
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo();
            if (senderPrefs != null && senderPrefs.getEmailStrategy() == CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (!accountsToNotify.containsValue(fromId) && rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo();
                if (prefs == null || prefs.getEmailStrategy() == DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        String textPart = textBody.toString();
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = textPart;
        if (useHtml()) {
            va.htmlBody = htmlBody.toString();
        } else {
            va.htmlBody = null;
        }
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body, va.htmlBody);
    }
}
#end_block

#method_before
protected void init() throws EmailException {
    setupVelocityContext();
    setupSoyContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    if (accountsToNotify != null) {
        for (RecipientType recipientType : accountsToNotify.keySet()) {
            add(recipientType, accountsToNotify.get(recipientType));
        }
    }
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.getEmail().equals(a.getEmail())) {
            setHeader("Reply-To", a.getEmail());
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    textBody = new StringBuilder();
    htmlBody = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#method_after
protected void init() throws EmailException {
    setupVelocityContext();
    setupSoyContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    for (RecipientType recipientType : accountsToNotify.keySet()) {
        add(recipientType, accountsToNotify.get(recipientType));
    }
    if (fromId != null) {
        // If we have a user that this message is supposedly caused by
        // but the From header on the email does not match the user as
        // it is a generic header for this Gerrit server, include the
        // Reply-To header with the current user's email address.
        // 
        final Address a = toAddress(fromId);
        if (a != null && !smtpFromAddress.getEmail().equals(a.getEmail())) {
            setHeader("Reply-To", a.getEmail());
        }
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    textBody = new StringBuilder();
    htmlBody = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#end_block

#method_before
protected void setupSoyContext() {
    soyContext = new HashMap<>();
    soyContext.put("messageClass", messageClass);
    soyContextEmailData = new HashMap<>();
    soyContextEmailData.put("settingsUrl", getSettingsUrl());
    soyContextEmailData.put("gerritHost", getGerritHost());
    soyContextEmailData.put("gerritUrl", getGerritUrl());
    soyContext.put("email", soyContextEmailData);
}
#method_after
protected void setupSoyContext() {
    soyContext = new HashMap<>();
    footers = new ArrayList<>();
    soyContext.put("messageClass", messageClass);
    soyContext.put("footers", footers);
    soyContextEmailData = new HashMap<>();
    soyContextEmailData.put("settingsUrl", getSettingsUrl());
    soyContextEmailData.put("gerritHost", getGerritHost());
    soyContextEmailData.put("gerritUrl", getGerritUrl());
    soyContext.put("email", soyContextEmailData);
}
#end_block

#method_before
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
        actual = gApi.changes().id(change.getChangeId()).get(options);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            assertThat(original.getName()).isNotEqualTo(mergeTip.getName());
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
        actual = gApi.changes().id(change.getChangeId()).get(options);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    String projectName = branch.getParentKey().get();
    soyContext.put("projectName", projectName);
    // shortProjectName is the project name with the path abbreviated.
    soyContext.put("shortProjectName", projectName.replaceAll("/.*/", "..."));
    soyContextEmailData.put("sshHost", getSshHost());
    Map<String, String> branchData = new HashMap<>();
    branchData.put("shortName", branch.getShortName());
    soyContext.put("branch", branchData);
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    String projectName = branch.getParentKey().get();
    soyContext.put("projectName", projectName);
    // shortProjectName is the project name with the path abbreviated.
    soyContext.put("shortProjectName", projectName.replaceAll("/.*/", "..."));
    soyContextEmailData.put("sshHost", getSshHost());
    Map<String, String> branchData = new HashMap<>();
    branchData.put("shortName", branch.getShortName());
    soyContext.put("branch", branchData);
    footers.add("Gerrit-Project: " + branch.getParentKey().get());
    footers.add("Gerrit-Branch: " + branch.getShortName());
}
#end_block

#method_before
public ChangeInserter setAccountsToNotify(Multimap<RecipientType, Account.Id> accountsToNotify) {
    this.accountsToNotify = accountsToNotify;
    return this;
}
#method_after
public ChangeInserter setAccountsToNotify(Multimap<RecipientType, Account.Id> accountsToNotify) {
    this.accountsToNotify = checkNotNull(accountsToNotify);
    return this;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException, NoSuchChangeException {
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.setAccountsToNotify(accountsToNotify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
            List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException, NoSuchChangeException {
    if (sendMail && (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty())) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.setAccountsToNotify(accountsToNotify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
            List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#end_block

#method_before
public Change abandon(ChangeControl control) throws RestApiException, UpdateException {
    return abandon(control, "", NotifyHandling.ALL, null);
}
#method_after
public Change abandon(ChangeControl control) throws RestApiException, UpdateException {
    return abandon(control, "", NotifyHandling.ALL, ImmutableListMultimap.of());
}
#end_block

#method_before
public Change abandon(ChangeControl control, String msgTxt) throws RestApiException, UpdateException {
    return abandon(control, msgTxt, NotifyHandling.ALL, null);
}
#method_after
public Change abandon(ChangeControl control, String msgTxt) throws RestApiException, UpdateException {
    return abandon(control, msgTxt, NotifyHandling.ALL, ImmutableListMultimap.of());
}
#end_block

#method_before
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls, String msgTxt) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, msgTxt, NotifyHandling.ALL, null);
}
#method_after
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls, String msgTxt) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, msgTxt, NotifyHandling.ALL, ImmutableListMultimap.of());
}
#end_block

#method_before
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, "", NotifyHandling.ALL, null);
}
#method_after
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, "", NotifyHandling.ALL, ImmutableListMultimap.of());
}
#end_block

#method_before
Addition ccCurrentUser(CurrentUser user, RevisionResource revision) {
    return new Addition(user.getUserName(), revision.getChangeResource(), ImmutableMap.of(user.getAccountId(), revision.getControl()), CC, NotifyHandling.NONE, null);
}
#method_after
Addition ccCurrentUser(CurrentUser user, RevisionResource revision) {
    return new Addition(user.getUserName(), revision.getChangeResource(), ImmutableMap.of(user.getAccountId(), revision.getControl()), CC, NotifyHandling.NONE, ImmutableListMultimap.of());
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    changeData.put("changeNumber", Integer.toString(change.getChangeId()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    soyContext.put("reviewerEmails", getEmailsByState(ReviewerStateInternal.REVIEWER));
    soyContext.put("ccEmails", getEmailsByState(ReviewerStateInternal.CC));
// TODO(wyatta): patchSetInfo
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    changeData.put("changeNumber", Integer.toString(change.getChangeId()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    // TODO(wyatta): patchSetInfo
    footers.add("Gerrit-MessageType: " + messageClass);
    footers.add("Gerrit-Change-Id: " + change.getKey().get());
    footers.add("Gerrit-Change-Number: " + Integer.toString(change.getChangeId()));
    footers.add("Gerrit-PatchSet: " + patchSet.getPatchSetId());
    footers.add("Gerrit-Owner: " + getNameEmailFor(change.getOwner()));
    for (String reviewer : getEmailsByState(ReviewerStateInternal.REVIEWER)) {
        footers.add("Gerrit-Reviewer: " + reviewer);
    }
    for (String reviewer : getEmailsByState(ReviewerStateInternal.CC)) {
        footers.add("Gerrit-CC: " + reviewer);
    }
}
#end_block

#method_before
public Multimap<RecipientType, Account.Id> resolveAccounts(@Nullable Map<RecipientType, NotifyInfo> notifyDetails) throws OrmException, BadRequestException {
    if (isNullOrEmpty(notifyDetails)) {
        return null;
    }
    Multimap<RecipientType, Account.Id> m = null;
    for (Entry<RecipientType, NotifyInfo> e : notifyDetails.entrySet()) {
        List<String> accounts = e.getValue().accounts;
        if (accounts != null) {
            if (m == null) {
                m = ArrayListMultimap.create();
            }
            m.putAll(e.getKey(), find(dbProvider.get(), accounts));
        }
    }
    return m;
}
#method_after
public Multimap<RecipientType, Account.Id> resolveAccounts(@Nullable Map<RecipientType, NotifyInfo> notifyDetails) throws OrmException, BadRequestException {
    if (isNullOrEmpty(notifyDetails)) {
        return ImmutableListMultimap.of();
    }
    Multimap<RecipientType, Account.Id> m = null;
    for (Entry<RecipientType, NotifyInfo> e : notifyDetails.entrySet()) {
        List<String> accounts = e.getValue().accounts;
        if (accounts != null) {
            if (m == null) {
                m = ArrayListMultimap.create();
            }
            m.putAll(e.getKey(), find(dbProvider.get(), accounts));
        }
    }
    return m != null ? m : ImmutableListMultimap.of();
}
#end_block

#method_before
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> in) throws BadRequestException, OrmException {
    Iterator<? extends Map.Entry<String, List<T>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getControl()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<T>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.isMagic(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, revision.getChange().currentPatchSetId()));
        }
        List<T> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        if (Patch.isMagic(path)) {
            for (T comment : list) {
                if (comment.side == Side.PARENT && comment.parent == null) {
                    throw new BadRequestException(String.format("cannot comment on %s on auto-merge", path));
                }
            }
        }
        Iterator<T> listItr = list.iterator();
        while (listItr.hasNext()) {
            T c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line != null && c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.nullToEmpty(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#method_after
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> commentsPerPath) throws BadRequestException, OrmException {
    cleanUpComments(commentsPerPath);
    ensureCommentsAreAddable(revision, commentsPerPath);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0 || (accountsToNotify != null && !accountsToNotify.isEmpty())) {
        email.create(in.notify, accountsToNotify, notes, ps, user, message, comments).sendAsync();
    }
    commentAdded.fire(notes.getChange(), ps, user.getAccount(), message.getMessage(), approvals, oldApprovals, ctx.getWhen());
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0 || !accountsToNotify.isEmpty()) {
        email.create(in.notify, accountsToNotify, notes, ps, user, message, comments).sendAsync();
    }
    commentAdded.fire(notes.getChange(), ps, user.getAccount(), message.getMessage(), approvals, oldApprovals, ctx.getWhen());
}
#end_block

#method_before
@Override
public void start(PluginGuiceEnvironment env) throws Exception {
    super.start(env);
}
#method_after
@Override
public // Widen access modifier in derived class
void start(PluginGuiceEnvironment env) throws Exception {
    super.start(env);
}
#end_block

#method_before
@Override
public void stop(PluginGuiceEnvironment env) {
    super.stop(env);
}
#method_after
@Override
public // Widen access modifier in derived class
void stop(PluginGuiceEnvironment env) {
    super.stop(env);
}
#end_block

#method_before
private BinaryResult getBundles(RevisionResource rsrc, final ArchiveFormat f) throws OrmException, RestApiException {
    ReviewDb db = dbProvider.get();
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    BinaryResult bin;
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        final MergeOpRepoManager orm = op.getMergeOpRepoManager();
        final Set<Project.NameKey> projects = op.getAllProjects();
        bin = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try (ArchiveOutputStream aos = f.createArchiveOutputStream(out)) {
                    for (Project.NameKey p : projects) {
                        OpenRepo or = orm.getRepo(p);
                        BundleWriter bw = new BundleWriter(or.getRepo());
                        bw.setObjectCountCallback(null);
                        bw.setPackConfig(null);
                        Collection<ReceiveCommand> refs = or.getUpdate().getRefUpdates();
                        for (ReceiveCommand r : refs) {
                            bw.include(r.getRefName(), r.getNewId());
                            if (!r.getOldId().equals(ObjectId.zeroId())) {
                                bw.assume(or.getCodeReviewRevWalk().parseCommit(r.getOldId()));
                            }
                        }
                        // This naming scheme cannot produce directory/file conflicts
                        // as no projects contains ".git/":
                        String path = p.get() + ".git";
                        ByteArrayOutputStream bos = new ByteArrayOutputStream();
                        bw.writeBundle(NullProgressMonitor.INSTANCE, bos);
                        f.putEntry(aos, path, bos.toByteArray());
                    }
                }
            }
        };
    }
    return bin;
}
#method_after
private BinaryResult getBundles(RevisionResource rsrc, final ArchiveFormat f) throws OrmException, RestApiException {
    ReviewDb db = dbProvider.get();
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    BinaryResult bin;
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        final MergeOpRepoManager orm = op.getMergeOpRepoManager();
        final Set<Project.NameKey> projects = op.getAllProjects();
        bin = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try (ArchiveOutputStream aos = f.createArchiveOutputStream(out)) {
                    for (Project.NameKey p : projects) {
                        OpenRepo or = orm.getRepo(p);
                        BundleWriter bw = new BundleWriter(or.getRepo());
                        bw.setObjectCountCallback(null);
                        bw.setPackConfig(null);
                        Collection<ReceiveCommand> refs = or.getUpdate().getRefUpdates();
                        for (ReceiveCommand r : refs) {
                            bw.include(r.getRefName(), r.getNewId());
                            ObjectId oldId = r.getOldId();
                            if (!oldId.equals(ObjectId.zeroId())) {
                                bw.assume(or.getCodeReviewRevWalk().parseCommit(oldId));
                            }
                        }
                        // This naming scheme cannot produce directory/file conflicts
                        // as no projects contains ".git/":
                        String path = p.get() + ".git";
                        LimitedByteArrayOutputStream bos = new LimitedByteArrayOutputStream(maxBundleSize, 1024);
                        bw.writeBundle(NullProgressMonitor.INSTANCE, bos);
                        f.putEntry(aos, path, bos.toByteArray());
                    }
                } catch (LimitExceededException e) {
                    throw new NotImplementedException("The bundle is too big to " + "generate at the server");
                }
            }
        };
    }
    return bin;
}
#end_block

#method_before
public void process(MailMessage message) throws OrmException {
    MailMetadata metadata = MetadataParser.parse(message);
    if (!metadata.hasRequiredFields()) {
        log.error("Mail: Message " + message.id() + " is missing required metadata, have " + metadata + ". Will delete message.");
        return;
    }
    Set<Account.Id> accounts = accountByEmailCache.get(metadata.author);
    if (accounts.size() != 1) {
        log.error("Mail: Address " + metadata.author + " could not be matched to a unique account. It was matched to " + accounts + ". Will delete message.");
        return;
    }
    Account.Id account = accounts.iterator().next();
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(account)) {
        ChangeData cd = queryProvider.get().setLimit(1).byKey(Change.Key.parse(metadata.changeId)).get(0);
        if (existingMessageIds(cd).contains(message.id())) {
            log.info("Mail: Message " + message.id() + " was already processed. Will delete message.");
            return;
        }
        // Get all comments; filter and sort them to get the original list of
        // comments from the outbound email.
        // TODO(hiesel) Also filter by original comment author.
        Collection<Comment> comments = cd.publishedComments().stream().filter(c -> (c.writtenOn.getTime() / 1000) == (metadata.timestamp.getTime() / 1000)).sorted(CommentsUtil.COMMENT_ORDER).collect(Collectors.toList());
        Project.NameKey project = cd.project();
        String changeUrl = canonicalUrl.get() + "#/c/" + cd.getId().get();
        List<MailComment> parsedComments;
        if (useHtmlParser(message)) {
            parsedComments = HtmlParser.parse(message, comments, changeUrl);
        } else {
            parsedComments = TextParser.parse(message, comments, changeUrl);
        }
        if (parsedComments.isEmpty()) {
            log.error("Mail: Could not parse any comments from " + message.id() + ". Will delete message.");
            return;
        }
        Op o = new Op(new PatchSet.Id(cd.getId(), metadata.patchSet), parsedComments, message.id());
        BatchUpdate batchUpdate = buf.create(cd.db(), project, ctx.getUser(), TimeUtil.nowTs());
        batchUpdate.addOp(cd.getId(), o);
        try {
            batchUpdate.execute();
        } catch (UpdateException | RestApiException e) {
            // TODO(hiesel) Is this correct?
            throw new OrmException(e);
        }
    }
}
#method_after
public void process(MailMessage message) throws OrmException {
    MailMetadata metadata = MetadataParser.parse(message);
    if (!metadata.hasRequiredFields()) {
        log.error("Mail: Message " + message.id() + " is missing required metadata, have " + metadata + ". Will delete message.");
        return;
    }
    Set<Account.Id> accounts = accountByEmailCache.get(metadata.author);
    if (accounts.size() != 1) {
        log.error("Mail: Address " + metadata.author + " could not be matched to a unique account. It was matched to " + accounts + ". Will delete message.");
        return;
    }
    Account.Id account = accounts.iterator().next();
    if (!reviewDb.get().accounts().get(account).isActive()) {
        log.warn("Mail: Account " + account + " is inactive. Will delete message.");
        return;
    }
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(account)) {
        ChangeData cd = queryProvider.get().setLimit(1).byKey(Change.Key.parse(metadata.changeId)).get(0);
        if (existingMessageIds(cd).contains(message.id())) {
            log.info("Mail: Message " + message.id() + " was already processed. Will delete message.");
            return;
        }
        // Get all comments; filter and sort them to get the original list of
        // comments from the outbound email.
        // TODO(hiesel) Also filter by original comment author.
        Collection<Comment> comments = cd.publishedComments().stream().filter(c -> (c.writtenOn.getTime() / 1000) == (metadata.timestamp.getTime() / 1000)).sorted(CommentsUtil.COMMENT_ORDER).collect(Collectors.toList());
        Project.NameKey project = cd.project();
        String changeUrl = canonicalUrl.get() + "#/c/" + cd.getId().get();
        List<MailComment> parsedComments;
        if (useHtmlParser(message)) {
            parsedComments = HtmlParser.parse(message, comments, changeUrl);
        } else {
            parsedComments = TextParser.parse(message, comments, changeUrl);
        }
        if (parsedComments.isEmpty()) {
            log.warn("Mail: Could not parse any comments from " + message.id() + ". Will delete message.");
            return;
        }
        Op o = new Op(new PatchSet.Id(cd.getId(), metadata.patchSet), parsedComments, message.id());
        BatchUpdate batchUpdate = buf.create(cd.db(), project, ctx.getUser(), TimeUtil.nowTs());
        batchUpdate.addOp(cd.getId(), o);
        try {
            batchUpdate.execute();
        } catch (UpdateException | RestApiException e) {
            throw new OrmException(e);
        }
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    ChangeMessage msg;
    if (parsedComments.get(0).type == MailComment.CommentType.CHANGE_MESSAGE) {
        msg = ChangeMessagesUtil.newMessage(ctx, "Patch Set " + psId.get() + ":\n" + parsedComments.get(0).message, tag);
    } else {
        msg = ChangeMessagesUtil.newMessage(ctx, "Patch Set " + psId.get() + ":\n(" + parsedComments.size() + (parsedComments.size() > 1 ? " comments)" : " comment)"), tag);
    }
    changeMessagesUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), msg);
    List<Comment> comments = new ArrayList<>();
    for (MailComment c : parsedComments) {
        if (c.type == MailComment.CommentType.CHANGE_MESSAGE) {
            continue;
        }
        String fileName;
        // The patch set that this comment is based on is different if this
        // comment was sent in reply to a comment on a previous patch set.
        PatchSet psForComment;
        Side side;
        if (c.inReplyTo != null) {
            fileName = c.inReplyTo.key.filename;
            psForComment = psUtil.get(ctx.getDb(), ctx.getNotes(), new PatchSet.Id(ctx.getChange().getId(), c.inReplyTo.key.patchSetId));
            side = Side.fromShort(c.inReplyTo.side);
        } else {
            fileName = c.fileName;
            psForComment = ps;
            side = Side.REVISION;
        }
        Comment comment = commentsUtil.newComment(ctx, fileName, psForComment.getId(), (short) side.ordinal(), c.message);
        comment.tag = tag;
        if (c.inReplyTo != null) {
            comment.parentUuid = c.inReplyTo.key.uuid;
            comment.lineNbr = c.inReplyTo.lineNbr;
            comment.range = c.inReplyTo.range;
        }
        commentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), psForComment);
        comments.add(comment);
    }
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), Status.PUBLISHED, comments);
    ctx.bumpLastUpdatedOn(false);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new OrmException("patch set not found: " + psId);
    }
    String changeMsg = "Patch Set " + psId.get() + ":";
    if (parsedComments.get(0).type == MailComment.CommentType.CHANGE_MESSAGE) {
        if (parsedComments.size() > 1) {
            changeMsg += "\n" + numComments(parsedComments.size() - 1);
        }
        changeMsg += "\n" + parsedComments.get(0).message;
    } else {
        changeMsg += "\n" + numComments(parsedComments.size());
    }
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx, changeMsg, tag);
    changeMessagesUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), msg);
    List<Comment> comments = new ArrayList<>();
    for (MailComment c : parsedComments) {
        if (c.type == MailComment.CommentType.CHANGE_MESSAGE) {
            continue;
        }
        String fileName;
        // The patch set that this comment is based on is different if this
        // comment was sent in reply to a comment on a previous patch set.
        PatchSet psForComment;
        Side side;
        if (c.inReplyTo != null) {
            fileName = c.inReplyTo.key.filename;
            psForComment = psUtil.get(ctx.getDb(), ctx.getNotes(), new PatchSet.Id(ctx.getChange().getId(), c.inReplyTo.key.patchSetId));
            side = Side.fromShort(c.inReplyTo.side);
        } else {
            fileName = c.fileName;
            psForComment = ps;
            side = Side.REVISION;
        }
        Comment comment = commentsUtil.newComment(ctx, fileName, psForComment.getId(), (short) side.ordinal(), c.message);
        comment.tag = tag;
        if (c.inReplyTo != null) {
            comment.parentUuid = c.inReplyTo.key.uuid;
            comment.lineNbr = c.inReplyTo.lineNbr;
            comment.range = c.inReplyTo.range;
        }
        CommentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), psForComment);
        comments.add(comment);
    }
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), Status.PUBLISHED, comments);
    return true;
}
#end_block

#method_before
protected void dispatchMailProcessor(List<MailMessage> messages, boolean async) {
    for (MailMessage m : messages) {
        if (async) {
            Callable task = () -> {
                try {
                    mailProcessor.process(m);
                    requestDeletion(m.id());
                } catch (OrmException e) {
                    log.error("Mail: Can't process message " + m.id() + " . Won't delete.", e);
                }
                return null;
            };
            workQueue.getDefaultQueue().submit(task);
        } else {
            // Synchronous processing is used only in tests.
            try {
                mailProcessor.process(m);
                requestDeletion(m.id());
            } catch (OrmException e) {
                log.error("Mail: Can't process messages. Won't delete.", e);
            }
        }
    }
}
#method_after
protected void dispatchMailProcessor(List<MailMessage> messages, boolean async) {
    for (MailMessage m : messages) {
        if (async) {
            Callable<?> task = () -> {
                try {
                    mailProcessor.process(m);
                    requestDeletion(m.id());
                } catch (OrmException e) {
                    log.error("Mail: Can't process message " + m.id() + " . Won't delete.", e);
                }
                return null;
            };
            workQueue.getDefaultQueue().submit(task);
        } else {
            // Synchronous processing is used only in tests.
            try {
                mailProcessor.process(m);
                requestDeletion(m.id());
            } catch (OrmException e) {
                log.error("Mail: Can't process messages. Won't delete.", e);
            }
        }
    }
}
#end_block

#method_before
public static <S extends Subject<S, E>, E> ListSubject<S, E> assertThat(List<E> list, Function<E, S> elementAssertThatFunction) {
    // The ListSubjectFactory always returns ListSubjects.
    return (ListSubject<S, E>) assertAbout(new ListSubjectFactory<>(elementAssertThatFunction)).that(list);
}
#method_after
@SuppressWarnings("unchecked")
public static <S extends Subject<S, E>, E> ListSubject<S, E> assertThat(List<E> list, Function<E, S> elementAssertThatFunction) {
    // -> Casting is appropriate.
    return (ListSubject<S, E>) assertAbout(new ListSubjectFactory<>(elementAssertThatFunction)).that(list);
}
#end_block

#method_before
public S element(int index) {
    checkArgument(index >= 0, "index(%s) must be >= 0", index);
    // The constructor only accepts lists.
    List<E> list = (List<E>) actual();
    isNotNull();
    if (index >= list.size()) {
        fail("has an element at index " + index);
    }
    return elementAssertThatFunction.apply(list.get(index));
}
#method_after
public S element(int index) {
    checkArgument(index >= 0, "index(%s) must be >= 0", index);
    // The constructor only accepts lists.
    // -> Casting is appropriate.
    @SuppressWarnings("unchecked")
    List<E> list = (List<E>) actual();
    isNotNull();
    if (index >= list.size()) {
        fail("has an element at index " + index);
    }
    return elementAssertThatFunction.apply(list.get(index));
}
#end_block

#method_before
@Override
public ListSubject<S, E> named(String s, Object... objects) {
    // This object is returned which is of type ListSubject.
    return (ListSubject<S, E>) super.named(s, objects);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListSubject<S, E> named(String s, Object... objects) {
    // -> Casting is appropriate.
    return (ListSubject<S, E>) super.named(s, objects);
}
#end_block

#method_before
@Override
public ListSubject<S, T> getSubject(FailureStrategy failureStrategy, Iterable<?> objects) {
    // The constructor of ListSubject only accepts lists.
    return new ListSubject<>(failureStrategy, (List<T>) objects, elementAssertThatFunction);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListSubject<S, T> getSubject(FailureStrategy failureStrategy, Iterable<?> objects) {
    // -> Casting is appropriate.
    return new ListSubject<>(failureStrategy, (List<T>) objects, elementAssertThatFunction);
}
#end_block

#method_before
private void ensureFixReplacementsAreAddable(String path, List<FixReplacementInfo> fixReplacementInfos) throws BadRequestException {
    ensureReplacementsArePresent(path, fixReplacementInfos);
    for (FixReplacementInfo fixReplacementInfo : fixReplacementInfos) {
        ensureRangeIsSet(path, fixReplacementInfo.range);
        ensureReplacementStringIsSet(path, fixReplacementInfo.replacement);
    }
}
#method_after
private void ensureFixReplacementsAreAddable(String path, List<FixReplacementInfo> fixReplacementInfos) throws BadRequestException {
    ensureReplacementsArePresent(path, fixReplacementInfos);
    for (FixReplacementInfo fixReplacementInfo : fixReplacementInfos) {
        ensureRangeIsSet(path, fixReplacementInfo.range);
        ensureRangeIsValid(path, fixReplacementInfo.range);
        ensureReplacementStringIsSet(path, fixReplacementInfo.replacement);
    }
}
#end_block

#method_before
private void ensureRangeIsSet(String path, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        throw new BadRequestException(String.format("A range must be indicated " + "for the replacement of the robot comment on %s", path));
    }
}
#method_after
private void ensureRangeIsSet(String path, com.google.gerrit.extensions.client.Comment.Range range) throws BadRequestException {
    if (range == null) {
        throw new BadRequestException(String.format("A range must be given " + "for the replacement of the robot comment on %s", path));
    }
}
#end_block

#method_before
private List<RobotComment> getNewRobotComments(ChangeContext ctx) throws OrmException {
    List<RobotComment> toAdd = new ArrayList<>(in.robotComments.size());
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingRobotComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<RobotCommentInput>> ent : in.robotComments.entrySet()) {
        String path = ent.getKey();
        for (RobotCommentInput c : ent.getValue()) {
            RobotComment e = createRobotComment(ctx, path, c);
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toAdd.add(e);
        }
    }
    return toAdd;
}
#method_after
private List<RobotComment> getNewRobotComments(ChangeContext ctx) throws OrmException {
    List<RobotComment> toAdd = new ArrayList<>(in.robotComments.size());
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingRobotComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<RobotCommentInput>> ent : in.robotComments.entrySet()) {
        String path = ent.getKey();
        for (RobotCommentInput c : ent.getValue()) {
            RobotComment e = createRobotCommentFromInput(ctx, path, c);
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toAdd.add(e);
        }
    }
    return toAdd;
}
#end_block

#method_before
private FixSuggestionInfo createFixSuggestionInfo(FixReplacementInfo... fixReplacementInfos) {
    FixSuggestionInfo newFixSuggestionInfo = new FixSuggestionInfo();
    newFixSuggestionInfo.fixId = "An ID which must be overridden.";
    newFixSuggestionInfo.description = "A description for a suggested fix.";
    newFixSuggestionInfo.replacements = Arrays.asList(fixReplacementInfos);
    return newFixSuggestionInfo;
}
#method_after
private FixSuggestionInfo createFixSuggestionInfo(FixReplacementInfo... fixReplacementInfos) {
    FixSuggestionInfo newFixSuggestionInfo = new FixSuggestionInfo();
    newFixSuggestionInfo.fixId = "An ID which must be overwritten.";
    newFixSuggestionInfo.description = "A description for a suggested fix.";
    newFixSuggestionInfo.replacements = Arrays.asList(fixReplacementInfos);
    return newFixSuggestionInfo;
}
#end_block

#method_before
private List<RobotComment> getNewRobotComments(ChangeContext ctx) throws OrmException {
    List<RobotComment> toAdd = new ArrayList<>(in.robotComments.size());
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingRobotComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<RobotCommentInput>> ent : in.robotComments.entrySet()) {
        String path = ent.getKey();
        for (RobotCommentInput c : ent.getValue()) {
            RobotComment e = createRobotComment(ctx, path, c);
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toAdd.add(e);
        }
    }
    return toAdd;
}
#method_after
private List<RobotComment> getNewRobotComments(ChangeContext ctx) throws OrmException {
    List<RobotComment> toAdd = new ArrayList<>(in.robotComments.size());
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingRobotComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<RobotCommentInput>> ent : in.robotComments.entrySet()) {
        String path = ent.getKey();
        for (RobotCommentInput c : ent.getValue()) {
            RobotComment e = createRobotCommentFromInput(ctx, path, c);
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toAdd.add(e);
        }
    }
    return toAdd;
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RawInputUtil.create(CONTENT_NEW);
    adminRestSession.putRaw(urlEditFile(), in.content).assertNoContent();
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.byChange(change);
    RestResponse r = adminRestSession.getJsonAccept(urlEditFile());
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(new String(CONTENT_NEW2, StandardCharsets.UTF_8));
    r = adminRestSession.getJsonAccept(urlEditFile(true));
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(new String(CONTENT_OLD, StandardCharsets.UTF_8));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RawInputUtil.create(CONTENT_NEW);
    adminRestSession.putRaw(urlEditFile(), in.content).assertNoContent();
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RawInputUtil.create(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    RestResponse r = adminRestSession.getJsonAccept(urlEditFile());
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(new String(CONTENT_NEW2, UTF_8));
    r = adminRestSession.getJsonAccept(urlEditFile(true));
    r.assertOK();
    assertThat(readContentFromJson(r)).isEqualTo(new String(CONTENT_OLD, UTF_8));
}
#end_block

#method_before
public static List<MailComment> parse(MailMessage email, Collection<Comment> comments, String changeURL) {
    String body = email.textContent();
    // Replace CR-LF by \n
    body = body.replace("\r\n", "\n");
    List<MailComment> parsedComments = new ArrayList<>();
    // Some email clients (like GMail) use >> for enquoting text when there are
    // inline comments that the users typed. These will then be enquoted by a
    // single >. We sanitize this by unifying it into >. Inline comments typed
    // by the user will not be enquoted.
    // 
    // Example:
    // Some comment
    // >> Quoted Text
    // >> Quoted Text
    // > A comment typed in the email directly
    String singleQuotePattern = "\n> ";
    String doubleQuotePattern = "\n>> ";
    if (countOccurrences(body, doubleQuotePattern) > countOccurrences(body, singleQuotePattern)) {
        body = body.replace(doubleQuotePattern, singleQuotePattern);
    }
    PeekingIterator<Comment> iter = Iterators.peekingIterator(comments.iterator());
    String[] lines = body.split("\n");
    MailComment currentComment = null;
    String lastEncounteredFileName = null;
    Comment lastEncounteredComment = null;
    for (String line : lines) {
        if (line.startsWith("> ")) {
            line = line.substring("> ".length()).trim();
            // add previous comment to list if applicable
            if (currentComment != null) {
                parsedComments.add(currentComment);
                currentComment = null;
            }
            if (!iter.hasNext()) {
                continue;
            }
            Comment perspectiveComment = iter.peek();
            if (line.equals(ParserUtil.filePath(changeURL, perspectiveComment))) {
                if (lastEncounteredFileName == null || !lastEncounteredFileName.equals(perspectiveComment.key.filename)) {
                    // This is the annotation of a file
                    lastEncounteredFileName = perspectiveComment.key.filename;
                    lastEncounteredComment = null;
                } else if (perspectiveComment.lineNbr == 0) {
                    // This was originally a file-level comment
                    lastEncounteredComment = perspectiveComment;
                    iter.next();
                }
            } else if (line.equals(ParserUtil.filePath(changeURL, perspectiveComment) + "@" + perspectiveComment.lineNbr)) {
                lastEncounteredComment = perspectiveComment;
                iter.next();
            }
        } else {
            // create a new comment.
            if (currentComment == null) {
                // Start new comment
                currentComment = new MailComment();
                currentComment.message = line;
                if (lastEncounteredComment == null) {
                    if (lastEncounteredFileName == null) {
                        // Change message
                        currentComment.type = MailComment.CommentType.CHANGE_MESSAGE;
                    } else {
                        // File comment not sent in reply to another comment
                        currentComment.type = MailComment.CommentType.FILE_COMMENT;
                        currentComment.fileName = lastEncounteredFileName;
                    }
                } else {
                    // Comment sent in reply to another comment
                    currentComment.inReplyTo = lastEncounteredComment;
                    currentComment.type = MailComment.CommentType.INLINE_COMMENT;
                }
            } else {
                // Attach to previous comment
                currentComment.message += "\n" + line;
            }
        }
    }
    return parsedComments;
}
#method_after
public static List<MailComment> parse(MailMessage email, Collection<Comment> comments, String changeUrl) {
    String body = email.textContent();
    // Replace CR-LF by \n
    body = body.replace("\r\n", "\n");
    List<MailComment> parsedComments = new ArrayList<>();
    // Some email clients (like GMail) use >> for enquoting text when there are
    // inline comments that the users typed. These will then be enquoted by a
    // single >. We sanitize this by unifying it into >. Inline comments typed
    // by the user will not be enquoted.
    // 
    // Example:
    // Some comment
    // >> Quoted Text
    // >> Quoted Text
    // > A comment typed in the email directly
    String singleQuotePattern = "\n> ";
    String doubleQuotePattern = "\n>> ";
    if (countOccurrences(body, doubleQuotePattern) > countOccurrences(body, singleQuotePattern)) {
        body = body.replace(doubleQuotePattern, singleQuotePattern);
    }
    PeekingIterator<Comment> iter = Iterators.peekingIterator(comments.iterator());
    String[] lines = body.split("\n");
    MailComment currentComment = null;
    String lastEncounteredFileName = null;
    Comment lastEncounteredComment = null;
    for (String line : lines) {
        if (line.startsWith("> ")) {
            line = line.substring("> ".length()).trim();
            // add previous comment to list if applicable
            if (currentComment != null) {
                parsedComments.add(currentComment);
                currentComment = null;
            }
            if (!iter.hasNext()) {
                continue;
            }
            Comment perspectiveComment = iter.peek();
            if (line.equals(ParserUtil.filePath(changeUrl, perspectiveComment))) {
                if (lastEncounteredFileName == null || !lastEncounteredFileName.equals(perspectiveComment.key.filename)) {
                    // This is the annotation of a file
                    lastEncounteredFileName = perspectiveComment.key.filename;
                    lastEncounteredComment = null;
                } else if (perspectiveComment.lineNbr == 0) {
                    // This was originally a file-level comment
                    lastEncounteredComment = perspectiveComment;
                    iter.next();
                }
            } else if (ParserUtil.isCommentUrl(line, changeUrl, perspectiveComment)) {
                lastEncounteredComment = perspectiveComment;
                iter.next();
            }
        } else {
            // create a new comment.
            if (currentComment == null) {
                // Start new comment
                currentComment = new MailComment();
                currentComment.message = line;
                if (lastEncounteredComment == null) {
                    if (lastEncounteredFileName == null) {
                        // Change message
                        currentComment.type = MailComment.CommentType.CHANGE_MESSAGE;
                    } else {
                        // File comment not sent in reply to another comment
                        currentComment.type = MailComment.CommentType.FILE_COMMENT;
                        currentComment.fileName = lastEncounteredFileName;
                    }
                } else {
                    // Comment sent in reply to another comment
                    currentComment.inReplyTo = lastEncounteredComment;
                    currentComment.type = MailComment.CommentType.INLINE_COMMENT;
                }
            } else {
                // Attach to previous comment
                currentComment.message += "\n" + line;
            }
        }
    }
    return parsedComments;
}
#end_block

#method_before
public static List<MailComment> parse(MailMessage email, Collection<Comment> comments, String changeURL) {
    // TODO(hiesel) Add support for Gmail Mobile
    // TODO(hiesel) Add tests for other popular email clients
    // This parser goes though all html elements in the email and checks for
    // matching patterns. It keeps track of the last file and comments it
    // encountered to know in which context a parsed comment belongs.
    // It uses the href attributes of <a> tags to identify comments sent out by
    // Gerrit as these are generally more reliable then the text captions.
    List<MailComment> parsedComments = new ArrayList<>();
    Document d = Jsoup.parse(email.htmlContent());
    PeekingIterator<Comment> iter = Iterators.peekingIterator(comments.iterator());
    String lastEncounteredFileName = null;
    Comment lastEncounteredComment = null;
    for (Element e : d.body().getAllElements()) {
        String elementName = e.tagName();
        boolean isInBlockQuote = e.parents().stream().filter(p -> p.tagName().equals("blockquote")).findAny().isPresent();
        if (elementName.equals("a")) {
            String href = e.attr("href");
            // this <a> tag
            if (!iter.hasNext()) {
                continue;
            }
            Comment perspectiveComment = iter.peek();
            if (href.equals(ParserUtil.filePath(changeURL, perspectiveComment))) {
                if (lastEncounteredFileName == null || !lastEncounteredFileName.equals(perspectiveComment.key.filename)) {
                    // Not a file-level comment, but users could have typed a comment
                    // right after this file annotation to create a new file-level
                    // comment. If this file has a file-level comment, we have already
                    // set lastEncounteredComment to that file-level comment when we
                    // encountered the file link and should not reset it now.
                    lastEncounteredFileName = perspectiveComment.key.filename;
                    lastEncounteredComment = null;
                } else if (perspectiveComment.lineNbr == 0) {
                    // This was originally a file-level comment
                    lastEncounteredComment = perspectiveComment;
                    iter.next();
                }
            } else if (href.equals(ParserUtil.filePath(changeURL, perspectiveComment) + "@" + perspectiveComment.lineNbr)) {
                // This is a regular inline comment
                lastEncounteredComment = perspectiveComment;
                iter.next();
            }
        } else if (!isInBlockQuote && elementName.equals("div") && !e.className().startsWith("gmail")) {
            // This is a comment typed by the user
            String content = e.ownText().trim();
            if (!Strings.isNullOrEmpty(content)) {
                if (lastEncounteredComment == null && lastEncounteredFileName == null) {
                    // Remove quotation line, email signature and
                    // "Sent from my xyz device"
                    content = ParserUtil.trimQuotationLine(content);
                    // TODO(hiesel) Add more sanitizer
                    if (!Strings.isNullOrEmpty(content)) {
                        parsedComments.add(new MailComment(content, null, null, MailComment.CommentType.CHANGE_MESSAGE));
                    }
                } else if (lastEncounteredComment == null) {
                    parsedComments.add(new MailComment(content, lastEncounteredFileName, null, MailComment.CommentType.FILE_COMMENT));
                } else {
                    parsedComments.add(new MailComment(content, null, lastEncounteredComment, MailComment.CommentType.INLINE_COMMENT));
                }
            }
        }
    }
    return parsedComments;
}
#method_after
public static List<MailComment> parse(MailMessage email, Collection<Comment> comments, String changeUrl) {
    // TODO(hiesel) Add support for Gmail Mobile
    // TODO(hiesel) Add tests for other popular email clients
    // This parser goes though all html elements in the email and checks for
    // matching patterns. It keeps track of the last file and comments it
    // encountered to know in which context a parsed comment belongs.
    // It uses the href attributes of <a> tags to identify comments sent out by
    // Gerrit as these are generally more reliable then the text captions.
    List<MailComment> parsedComments = new ArrayList<>();
    Document d = Jsoup.parse(email.htmlContent());
    PeekingIterator<Comment> iter = Iterators.peekingIterator(comments.iterator());
    String lastEncounteredFileName = null;
    Comment lastEncounteredComment = null;
    for (Element e : d.body().getAllElements()) {
        String elementName = e.tagName();
        boolean isInBlockQuote = e.parents().stream().filter(p -> p.tagName().equals("blockquote")).findAny().isPresent();
        if (elementName.equals("a")) {
            String href = e.attr("href");
            // this <a> tag
            if (!iter.hasNext()) {
                continue;
            }
            Comment perspectiveComment = iter.peek();
            if (href.equals(ParserUtil.filePath(changeUrl, perspectiveComment))) {
                if (lastEncounteredFileName == null || !lastEncounteredFileName.equals(perspectiveComment.key.filename)) {
                    // Not a file-level comment, but users could have typed a comment
                    // right after this file annotation to create a new file-level
                    // comment. If this file has a file-level comment, we have already
                    // set lastEncounteredComment to that file-level comment when we
                    // encountered the file link and should not reset it now.
                    lastEncounteredFileName = perspectiveComment.key.filename;
                    lastEncounteredComment = null;
                } else if (perspectiveComment.lineNbr == 0) {
                    // This was originally a file-level comment
                    lastEncounteredComment = perspectiveComment;
                    iter.next();
                }
            } else if (ParserUtil.isCommentUrl(href, changeUrl, perspectiveComment)) {
                // This is a regular inline comment
                lastEncounteredComment = perspectiveComment;
                iter.next();
            }
        } else if (!isInBlockQuote && elementName.equals("div") && !e.className().startsWith("gmail")) {
            // This is a comment typed by the user
            String content = e.ownText().trim();
            if (!Strings.isNullOrEmpty(content)) {
                if (lastEncounteredComment == null && lastEncounteredFileName == null) {
                    // Remove quotation line, email signature and
                    // "Sent from my xyz device"
                    content = ParserUtil.trimQuotationLine(content);
                    // TODO(hiesel) Add more sanitizer
                    if (!Strings.isNullOrEmpty(content)) {
                        parsedComments.add(new MailComment(content, null, null, MailComment.CommentType.CHANGE_MESSAGE));
                    }
                } else if (lastEncounteredComment == null) {
                    parsedComments.add(new MailComment(content, lastEncounteredFileName, null, MailComment.CommentType.FILE_COMMENT));
                } else {
                    parsedComments.add(new MailComment(content, null, lastEncounteredComment, MailComment.CommentType.INLINE_COMMENT));
                }
            }
        }
    }
    return parsedComments;
}
#end_block

#method_before
protected String newHtmlBody(String changeMessage, String c1, String c2, String c3, String f1, String f2, String fc1) {
    String email = "" + "<div dir=\"ltr\">" + (changeMessage != null ? changeMessage : "") + "<div class=\"extra\"><br><div class=\"quote\">" + "On Fri, Nov 18, 2016 at 11:15 AM, foobar (Gerrit) noreply@gerrit.com" + "<span dir=\"ltr\">&lt;<a href=\"mailto:noreply@gerrit.com\" " + "target=\"_blank\">noreply@gerrit.com</a>&gt;</span> wrote:<br>" + "<blockquote class=\"quote\" " + "<p>foobar <strong>posted comments</strong> on this change.</p>" + "<p><a href=\"" + changeURL + "/1\" " + "target=\"_blank\">View Change</a></p><div>Patch Set 2: CR-1\n" + "\n" + "(3 comments)</div><ul><li>" + // File #1: test.txt
    "<p>" + "<a href=\"" + changeURL + "/1/gerrit-server/test.txt\">" + "File gerrit-server/<wbr>test.txt:</a></p>" + commentBlock(f1) + "<li><p>" + "<a href=\"" + changeURL + "/1/gerrit-server/test.txt\">" + "Patch Set #2:</a> </p>" + "<blockquote><pre>Some inline comment from Gerrit</pre>" + "</blockquote><p>Some comment on file 1</p>" + "</li>" + commentBlock(fc1) + "<li><p>" + "<a href=\"" + changeURL + "/1/gerrit-server/test.txt@2\">" + "Patch Set #2, Line 31:</a> </p>" + "<blockquote><pre>Some inline comment from Gerrit</pre>" + "</blockquote><p>Some text from original comment</p>" + "</li>" + commentBlock(c1) + // Inline comment #2
    "" + "<li><p>" + "<a href=\"" + changeURL + "/1/gerrit-server/test.txt@3\">" + "Patch Set #2, Line 47:</a> </p>" + "<blockquote><pre>Some comment posted on Gerrit</pre>" + "</blockquote><p>Some more comments from Gerrit</p>" + "</li>" + commentBlock(c2) + "<li><p>" + "<a href=\"" + changeURL + "/1/gerrit-server/test.txt@115\">" + "Patch Set #2, Line 115:</a> <code>some code</code></p>" + "<p>some comment</p></li></ul></li>" + "" + // File #2: test.txt
    "<li><p>" + "<a href=\"" + changeURL + "/1/gerrit-server/readme.txt\">" + "File gerrit-server/<wbr>readme.txt:</a></p>" + commentBlock(f2) + "<li><p>" + "<a href=\"" + changeURL + "/1/gerrit-server/readme.txt@3\">" + "Patch Set #2, Line 31:</a> </p>" + "<blockquote><pre>Some inline comment from Gerrit</pre>" + "</blockquote><p>Some text from original comment</p>" + "</li>" + commentBlock(c3) + // Inline comment #2
    "" + "</ul></li></ul>" + // Footer
    "" + "<p>To view, visit <a href=\"" + changeURL + "/1\">this change</a>. " + "To unsubscribe, visit <a href=\"https://someurl\">settings</a>." + "</p><p>Gerrit-MessageType: comment<br>" + "Footer omitted</p>" + "<div><div></div></div>" + "<p>Gerrit-HasComments: Yes</p></blockquote></div><br></div></div>";
    return email;
}
#method_after
@Override
protected String newHtmlBody(String changeMessage, String c1, String c2, String c3, String f1, String f2, String fc1) {
    String email = "" + "<div dir=\"ltr\">" + (changeMessage != null ? changeMessage : "") + "<div class=\"extra\"><br><div class=\"quote\">" + "On Fri, Nov 18, 2016 at 11:15 AM, foobar (Gerrit) noreply@gerrit.com" + "<span dir=\"ltr\">&lt;<a href=\"mailto:noreply@gerrit.com\" " + "target=\"_blank\">noreply@gerrit.com</a>&gt;</span> wrote:<br>" + "<blockquote class=\"quote\" " + "<p>foobar <strong>posted comments</strong> on this change.</p>" + "<p><a href=\"" + changeURL + "/1\" " + "target=\"_blank\">View Change</a></p><div>Patch Set 2: CR-1\n" + "\n" + "(3 comments)</div><ul><li>" + // File #1: test.txt
    "<p>" + "<a href=\"" + changeURL + "/1/gerrit-server/test.txt\">" + "File gerrit-server/<wbr>test.txt:</a></p>" + commentBlock(f1) + "<li><p>" + "<a href=\"" + changeURL + "/1/gerrit-server/test.txt\">" + "Patch Set #2:</a> </p>" + "<blockquote><pre>Some inline comment from Gerrit</pre>" + "</blockquote><p>Some comment on file 1</p>" + "</li>" + commentBlock(fc1) + "<li><p>" + "<a href=\"" + changeURL + "/1/gerrit-server/test.txt@2\">" + "Patch Set #2, Line 31:</a> </p>" + "<blockquote><pre>Some inline comment from Gerrit</pre>" + "</blockquote><p>Some text from original comment</p>" + "</li>" + commentBlock(c1) + // Inline comment #2
    "" + "<li><p>" + "<a href=\"" + changeURL + "/1/gerrit-server/test.txt@3\">" + "Patch Set #2, Line 47:</a> </p>" + "<blockquote><pre>Some comment posted on Gerrit</pre>" + "</blockquote><p>Some more comments from Gerrit</p>" + "</li>" + commentBlock(c2) + "<li><p>" + "<a href=\"" + changeURL + "/1/gerrit-server/test.txt@115\">" + "Patch Set #2, Line 115:</a> <code>some code</code></p>" + "<p>some comment</p></li></ul></li>" + "" + // File #2: test.txt
    "<li><p>" + "<a href=\"" + changeURL + "/1/gerrit-server/readme.txt\">" + "File gerrit-server/<wbr>readme.txt:</a></p>" + commentBlock(f2) + "<li><p>" + "<a href=\"" + changeURL + "/1/gerrit-server/readme.txt@3\">" + "Patch Set #2, Line 31:</a> </p>" + "<blockquote><pre>Some inline comment from Gerrit</pre>" + "</blockquote><p>Some text from original comment</p>" + "</li>" + commentBlock(c3) + // Inline comment #2
    "" + "</ul></li></ul>" + // Footer
    "" + "<p>To view, visit <a href=\"" + changeURL + "/1\">this change</a>. " + "To unsubscribe, visit <a href=\"https://someurl\">settings</a>." + "</p><p>Gerrit-MessageType: comment<br>" + "Footer omitted</p>" + "<div><div></div></div>" + "<p>Gerrit-HasComments: Yes</p></blockquote></div><br></div></div>";
    return email;
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw die("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw die("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("abandon and delete actions are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("abandon and rebase actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw die("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("publish and delete actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw die("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("json and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("json and delete actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw die("json and publish actions are mutually exclusive");
        }
        if (abandonChange) {
            throw die("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw die("json and message are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("json and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("json and move actions are mutually exclusive");
        }
        if (changeTag != null) {
            throw die("json and tag actions are mutually exclusive");
        }
    }
    if (rebaseChange) {
        if (deleteDraftPatchSet) {
            throw die("rebase and delete actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("rebase and submit actions are mutually exclusive");
        }
    }
    if (deleteDraftPatchSet && submitChange) {
        throw die("delete and submit actions are mutually exclusive");
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error", e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("error", "no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal", "internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw die("one or more reviews failed; review output above");
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw die("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw die("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("abandon and delete actions are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("abandon and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("abandon and move actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw die("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("publish and delete actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw die("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("json and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw die("json and delete actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw die("json and publish actions are mutually exclusive");
        }
        if (abandonChange) {
            throw die("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw die("json and message are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("json and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("json and move actions are mutually exclusive");
        }
        if (changeTag != null) {
            throw die("json and tag actions are mutually exclusive");
        }
    }
    if (rebaseChange) {
        if (deleteDraftPatchSet) {
            throw die("rebase and delete actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("rebase and submit actions are mutually exclusive");
        }
    }
    if (deleteDraftPatchSet && submitChange) {
        throw die("delete and submit actions are mutually exclusive");
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error", e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("error", "no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal", "internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw die("one or more reviews failed; review output above");
    }
}
#end_block

#method_before
private void reviewPatchSet(final PatchSet patchSet) throws Exception {
    if (notify == null) {
        notify = NotifyHandling.ALL;
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.tag = Strings.emptyToNull(changeTag);
    review.notify = notify;
    review.labels = new TreeMap<>();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = strictLabels;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // We don't need to add the review comment when abandoning/restoring.
    if (abandonChange || restoreChange) {
        review.message = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = Strings.emptyToNull(changeComment);
            applyReview(patchSet, review);
            changeApi(patchSet).abandon(input);
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).restore(input);
            applyReview(patchSet, review);
        } else {
            applyReview(patchSet, review);
        }
        if (moveToBranch != null) {
            MoveInput moveInput = new MoveInput();
            moveInput.destinationBranch = moveToBranch;
            moveInput.message = changeComment;
            changeApi(patchSet).move(moveInput);
        }
        if (rebaseChange) {
            revisionApi(patchSet).rebase();
        }
        if (submitChange) {
            revisionApi(patchSet).submit();
        }
        if (publishPatchSet) {
            revisionApi(patchSet).publish();
        } else if (deleteDraftPatchSet) {
            revisionApi(patchSet).delete();
        }
    } catch (IllegalStateException | RestApiException e) {
        throw die(e);
    }
}
#method_after
private void reviewPatchSet(final PatchSet patchSet) throws Exception {
    if (notify == null) {
        notify = NotifyHandling.ALL;
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.tag = Strings.emptyToNull(changeTag);
    review.notify = notify;
    review.labels = new TreeMap<>();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = strictLabels;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // We don't need to add the review comment when abandoning/restoring.
    if (abandonChange || restoreChange || moveToBranch != null) {
        review.message = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = Strings.emptyToNull(changeComment);
            applyReview(patchSet, review);
            changeApi(patchSet).abandon(input);
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).restore(input);
            applyReview(patchSet, review);
        } else {
            applyReview(patchSet, review);
        }
        if (moveToBranch != null) {
            MoveInput moveInput = new MoveInput();
            moveInput.destinationBranch = moveToBranch;
            moveInput.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).move(moveInput);
        }
        if (rebaseChange) {
            revisionApi(patchSet).rebase();
        }
        if (submitChange) {
            revisionApi(patchSet).submit();
        }
        if (publishPatchSet) {
            revisionApi(patchSet).publish();
        } else if (deleteDraftPatchSet) {
            revisionApi(patchSet).delete();
        }
    } catch (IllegalStateException | RestApiException e) {
        throw die(e);
    }
}
#end_block

#method_before
private <T extends CommentInput> void cleanUpComments(List<T> comments) {
    Iterator<T> commentsIterator = comments.iterator();
    while (commentsIterator.hasNext()) {
        T comment = commentsIterator.next();
        if (comment == null) {
            commentsIterator.remove();
            continue;
        }
        comment.message = trimToEmpty(comment.message);
        if (comment.message.isEmpty()) {
            commentsIterator.remove();
        }
    }
}
#method_after
private <T extends CommentInput> void cleanUpComments(List<T> comments) {
    Iterator<T> commentsIterator = comments.iterator();
    while (commentsIterator.hasNext()) {
        T comment = commentsIterator.next();
        if (comment == null) {
            commentsIterator.remove();
            continue;
        }
        comment.message = Strings.nullToEmpty(comment.message).trim();
        if (comment.message.isEmpty()) {
            commentsIterator.remove();
        }
    }
}
#end_block

#method_before
private void setUpWebLinks() {
    if (!value.isConfigVisible()) {
        history.getStyle().setDisplay(Display.NONE);
    } else {
        List<WebLinkInfoCommon> links = value.getFileHistoryLinks();
        if (links != null) {
            for (WebLinkInfoCommon link : links) {
                webLinkPanel.add(toAnchor(link));
            }
        } else {
            history.getStyle().setDisplay(Display.NONE);
        }
    }
}
#method_after
private void setUpWebLinks() {
    List<WebLinkInfoCommon> links = value.getFileHistoryLinks();
    if (!value.isConfigVisible() || links == null || links.isEmpty()) {
        history.getStyle().setDisplay(Display.NONE);
        return;
    }
    for (WebLinkInfoCommon link : links) {
        webLinkPanel.add(toAnchor(link));
    }
}
#end_block

#method_before
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    addReviewerIcon.setVisible(false);
    suggestBox.setFocus(true);
}
#method_after
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    addReviewerIcon.setVisible(false);
    suggestBox.setServeSuggestionsOnOracle(true);
    suggestBox.setFocus(true);
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    addReviewerIcon.setVisible(true);
    UIObject.setVisible(form, false);
    suggestBox.setFocus(false);
    suggestBox.setText("");
}
#method_after
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    addReviewerIcon.setVisible(true);
    UIObject.setVisible(form, false);
    suggestBox.setFocus(false);
    suggestBox.setText("");
    suggestBox.setServeSuggestionsOnOracle(false);
}
#end_block

#method_before
private void updateReviewerList() {
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            display(result);
        }
    });
}
#method_after
void updateReviewerList() {
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            display(result);
        }
    });
}
#end_block

#method_before
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        short labelMaxValue = LabelInfo.parseValue(label.maxValue());
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._accountId();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.hasMaxPermittedValue() && ai.maxPermittedValue() == labelMaxValue) {
                    ad.votable(name + " (" + label.maxValue() + ") ");
                } else if (ai.hasValue()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#method_after
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        short labelMaxValue = LabelInfo.parseValue(label.maxValue());
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._accountId();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.permittedVotingRange() != null && ai.permittedVotingRange().max() == labelMaxValue) {
                    ad.votable(name + " (" + label.maxValue() + ") ");
                } else if (ai.hasValue()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#end_block

#method_before
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.<PatchSet.Id>absent(), true);
}
#method_after
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.empty(), true);
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.<PatchSet.Id>absent());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(ctl, cd) : ImmutableMap.of();
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private boolean submittable(ChangeData cd) throws OrmException {
    List<SubmitRecord> records = new SubmitRuleEvaluator(cd).setFastEvalLabels(true).evaluate();
    for (SubmitRecord sr : records) {
        if (sr.status == SubmitRecord.Status.OK) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean submittable(ChangeData cd) throws OrmException {
    return SubmitRecord.findOkRecord(cd.submitRecords(SUBMIT_RULE_OPTIONS_STRICT)).isPresent();
}
#end_block

#method_before
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    // TODO(dborowitz): Handle this better at the ChangeData level.
    if (submitRecords == null) {
        submitRecords = new HashMap<>();
    }
    List<SubmitRecord> records = submitRecords.get(cd.getId());
    if (records == null) {
        records = new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate();
        submitRecords.put(cd.getId(), records);
    }
    return records;
}
#method_after
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    return cd.submitRecords(SUBMIT_RULE_OPTIONS_LENIENT);
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(ctl, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        Map<String, Collection<String>> permittedLabels = permittedLabels(ctl, cd);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            Integer maxPermittedValue = null;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (permittedLabels.containsKey(lt.getName())) {
                Collection<String> range = permittedLabels.get(lt.getName());
                for (String val : range) {
                    Integer v = parseRangeValue(val);
                    if (v != null && (maxPermittedValue == null || v > maxPermittedValue)) {
                        maxPermittedValue = v;
                    }
                }
            }
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, maxPermittedValue, tag, date));
        }
    }
}
#method_after
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        Map<String, VotingRangeInfo> pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            VotingRangeInfo permittedVotingRange = pvr.getOrDefault(lt.getName(), null);
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, permittedVotingRange, tag, date));
        }
    }
}
#end_block

#method_before
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Set<String> labelNames = new HashSet<>();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (String name : labelNames) {
        LabelType type = labelTypes.byLabel(name);
        LabelWithStatus l = LabelWithStatus.create(new LabelInfo(), null);
        if (detailed) {
            setLabelValues(type, l);
        }
        labels.put(type.getName(), l);
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        if (detailed) {
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, 0, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeControl baseCtrl, ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    Set<String> labelNames = new HashSet<>();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    Map<String, LabelWithStatus> labels;
    if (cd.change().getStatus() == Change.Status.MERGED) {
        // Since voting on merged changes is allowed all labels which apply to
        // the change must be returned. All applying labels can be retrieved from
        // the submit records, which is what initLabels does.
        // It's not possible to only compute the labels based on the approvals
        // since merged changes may not have approvals for all labels (e.g. if not
        // all labels are required for submit or if the change was auto-closed due
        // to direct push or if new labels were defined after the change was
        // merged).
        labels = initLabels(cd, labelTypes, standard);
        // it wouldn't be included in the submit records.
        for (String name : labelNames) {
            if (!labels.containsKey(name)) {
                labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
            }
        }
    } else {
        // For abandoned changes return only labels for which approvals exist.
        // Other labels are not needed since voting on abandoned changes is not
        // allowed.
        labels = new TreeMap<>(labelTypes.nameComparator());
        for (String name : labelNames) {
            labels.put(name, LabelWithStatus.create(new LabelInfo(), null));
        }
    }
    if (detailed) {
        labels.entrySet().stream().filter(e -> labelTypes.byLabel(e.getKey()) != null).forEach(e -> setLabelValues(labelTypes.byLabel(e.getKey()), e.getValue()));
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        Map<String, VotingRangeInfo> pvr = Collections.emptyMap();
        if (detailed) {
            ChangeControl ctl = baseCtrl.forUser(userFactory.create(accountId));
            pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.permittedVotingRange = pvr.getOrDefault(type.getName(), null);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
                if (psa.isPostSubmit()) {
                    info.postSubmit = true;
                }
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#end_block

#method_before
private ApprovalInfo approvalInfo(Account.Id id, Integer value, Integer maxPermittedValue, String tag, Timestamp date) {
    ApprovalInfo ai = getApprovalInfo(id, value, maxPermittedValue, tag, date);
    accountLoader.put(ai);
    return ai;
}
#method_after
private ApprovalInfo approvalInfo(Account.Id id, Integer value, VotingRangeInfo permittedVotingRange, String tag, Timestamp date) {
    ApprovalInfo ai = getApprovalInfo(id, value, permittedVotingRange, tag, date);
    accountLoader.put(ai);
    return ai;
}
#end_block

#method_before
public static ApprovalInfo getApprovalInfo(Account.Id id, Integer value, Integer maxPermittedValue, String tag, Timestamp date) {
    ApprovalInfo ai = new ApprovalInfo(id.get());
    ai.value = value;
    ai.maxPermittedValue = maxPermittedValue;
    ai.date = date;
    ai.tag = tag;
    return ai;
}
#method_after
public static ApprovalInfo getApprovalInfo(Account.Id id, Integer value, VotingRangeInfo permittedVotingRange, String tag, Timestamp date) {
    ApprovalInfo ai = new ApprovalInfo(id.get());
    ai.value = value;
    ai.permittedVotingRange = permittedVotingRange;
    ai.date = date;
    ai.tag = tag;
    return ai;
}
#end_block

#method_before
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                if (range.contains(v.getValue())) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#method_after
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null || !ctl.getUser().isIdentifiedUser()) {
        return null;
    }
    Map<String, Short> labels = null;
    boolean isMerged = ctl.getChange().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                boolean ok = range.contains(v.getValue());
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(ctl);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, false));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, false, changeInfo));
            }
        }
        return res;
    }
}
#end_block

#method_before
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, true);
        accountLoader.fill();
        return rev;
    }
}
#method_after
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, true, null);
        accountLoader.fill();
        return rev;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, boolean fillCommit) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
            }
            if (addFooters) {
                Ref ref = repo.exactRef(ctl.getChange().getDest().get());
                RevCommit mergeTip = null;
                if (ref != null) {
                    mergeTip = rw.parseCommit(ref.getObjectId());
                    rw.parseBody(mergeTip);
                }
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            checkState(!original.getName().equals(mergeTip.getName()), original.getName() + " == " + mergeTip.getName());
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
        actual = gApi.changes().id(change.getChangeId()).get(options);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            assertThat(original.getName()).isNotEqualTo(mergeTip.getName());
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
        actual = gApi.changes().id(change.getChangeId()).get(options);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
private void assertBlock(List<CommentFormatter.Block> list, int index, CommentFormatter.BlockType type, String text) {
    CommentFormatter.Block block = list.get(index);
    assertThat(block.type).isEqualTo(type);
    assertThat(block.text).isEqualTo(text);
    assertThat(block.items).isNull();
    assertThat(block.blocks).isNull();
}
#method_after
private void assertBlock(List<CommentFormatter.Block> list, int index, CommentFormatter.BlockType type, String text) {
    CommentFormatter.Block block = list.get(index);
    assertThat(block.type).isEqualTo(type);
    assertThat(block.text).isEqualTo(text);
    assertThat(block.items).isNull();
    assertThat(block.quotedBlocks).isNull();
}
#end_block

#method_before
private void assertListBlock(List<CommentFormatter.Block> list, int index, int itemIndex, String text) {
    CommentFormatter.Block block = list.get(index);
    assertThat(block.type).isEqualTo(LIST);
    assertThat(block.items.get(itemIndex)).isEqualTo(text);
    assertThat(block.text).isNull();
    assertThat(block.blocks).isNull();
}
#method_after
private void assertListBlock(List<CommentFormatter.Block> list, int index, int itemIndex, String text) {
    CommentFormatter.Block block = list.get(index);
    assertThat(block.type).isEqualTo(LIST);
    assertThat(block.items.get(itemIndex)).isEqualTo(text);
    assertThat(block.text).isNull();
    assertThat(block.quotedBlocks).isNull();
}
#end_block

#method_before
private void assertQuoteBlock(List<CommentFormatter.Block> list, int index, int size) {
    CommentFormatter.Block block = list.get(index);
    assertThat(block.type).isEqualTo(QUOTE);
    assertThat(block.items).isNull();
    assertThat(block.text).isNull();
    assertThat(block.blocks).hasSize(size);
}
#method_after
private void assertQuoteBlock(List<CommentFormatter.Block> list, int index, int size) {
    CommentFormatter.Block block = list.get(index);
    assertThat(block.type).isEqualTo(QUOTE);
    assertThat(block.items).isNull();
    assertThat(block.text).isNull();
    assertThat(block.quotedBlocks).hasSize(size);
}
#end_block

#method_before
@Test
public void testParseQuote() {
    String comment = "> Quote text";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(1);
    assertQuoteBlock(result, 0, 1);
    assertBlock(result.get(0).blocks, 0, PARAGRAPH, "Quote text");
}
#method_after
@Test
public void testParseQuote() {
    String comment = "> Quote text";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(1);
    assertQuoteBlock(result, 0, 1);
    assertBlock(result.get(0).quotedBlocks, 0, PARAGRAPH, "Quote text");
}
#end_block

#method_before
@Test
public void testParseQuoteLeadSpace() {
    String comment = " > Quote text";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(1);
    assertQuoteBlock(result, 0, 1);
    assertBlock(result.get(0).blocks, 0, PARAGRAPH, "Quote text");
}
#method_after
@Test
public void testParseQuoteLeadSpace() {
    String comment = " > Quote text";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(1);
    assertQuoteBlock(result, 0, 1);
    assertBlock(result.get(0).quotedBlocks, 0, PARAGRAPH, "Quote text");
}
#end_block

#method_before
@Test
public void testParseMultiLineQuote() {
    String comment = "> Quote line 1\n> Quote line 2\n > Quote line 3\n";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(1);
    assertQuoteBlock(result, 0, 1);
    assertBlock(result.get(0).blocks, 0, PARAGRAPH, "Quote line 1\nQuote line 2\nQuote line 3\n");
}
#method_after
@Test
public void testParseMultiLineQuote() {
    String comment = "> Quote line 1\n> Quote line 2\n > Quote line 3\n";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(1);
    assertQuoteBlock(result, 0, 1);
    assertBlock(result.get(0).quotedBlocks, 0, PARAGRAPH, "Quote line 1\nQuote line 2\nQuote line 3\n");
}
#end_block

#method_before
@Test
public void testParseMixedBlockTypes() {
    String comment = "Paragraph\nacross\na\nfew\nlines." + "\n\n" + "> Quote\n> across\n> not many lines." + "\n\n" + "Another paragraph" + "\n\n" + "* Series\n* of\n* list\n* items" + "\n\n" + "Yet another paragraph" + "\n\n" + "\tPreformatted text." + "\n\n" + "Parting words.";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(7);
    assertBlock(result, 0, PARAGRAPH, "Paragraph\nacross\na\nfew\nlines.");
    assertQuoteBlock(result, 1, 1);
    assertBlock(result.get(1).blocks, 0, PARAGRAPH, "Quote\nacross\nnot many lines.");
    assertBlock(result, 2, PARAGRAPH, "Another paragraph");
    assertListBlock(result, 3, 0, "Series");
    assertListBlock(result, 3, 1, "of");
    assertListBlock(result, 3, 2, "list");
    assertListBlock(result, 3, 3, "items");
    assertBlock(result, 4, PARAGRAPH, "Yet another paragraph");
    assertBlock(result, 5, PRE_FORMATTED, "\tPreformatted text.");
    assertBlock(result, 6, PARAGRAPH, "Parting words.");
}
#method_after
@Test
public void testParseMixedBlockTypes() {
    String comment = "Paragraph\nacross\na\nfew\nlines." + "\n\n" + "> Quote\n> across\n> not many lines." + "\n\n" + "Another paragraph" + "\n\n" + "* Series\n* of\n* list\n* items" + "\n\n" + "Yet another paragraph" + "\n\n" + "\tPreformatted text." + "\n\n" + "Parting words.";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(7);
    assertBlock(result, 0, PARAGRAPH, "Paragraph\nacross\na\nfew\nlines.");
    assertQuoteBlock(result, 1, 1);
    assertBlock(result.get(1).quotedBlocks, 0, PARAGRAPH, "Quote\nacross\nnot many lines.");
    assertBlock(result, 2, PARAGRAPH, "Another paragraph");
    assertListBlock(result, 3, 0, "Series");
    assertListBlock(result, 3, 1, "of");
    assertListBlock(result, 3, 2, "list");
    assertListBlock(result, 3, 3, "items");
    assertBlock(result, 4, PARAGRAPH, "Yet another paragraph");
    assertBlock(result, 5, PRE_FORMATTED, "\tPreformatted text.");
    assertBlock(result, 6, PARAGRAPH, "Parting words.");
}
#end_block

#method_before
@Test
public void testQuote1() {
    String comment = "> I'm happy\n > with quotes!\n\nSee above.";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(2);
    assertQuoteBlock(result, 0, 1);
    assertBlock(result.get(0).blocks, 0, PARAGRAPH, "I'm happy\nwith quotes!");
    assertBlock(result, 1, PARAGRAPH, "See above.");
}
#method_after
@Test
public void testQuote1() {
    String comment = "> I'm happy\n > with quotes!\n\nSee above.";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(2);
    assertQuoteBlock(result, 0, 1);
    assertBlock(result.get(0).quotedBlocks, 0, PARAGRAPH, "I'm happy\nwith quotes!");
    assertBlock(result, 1, PARAGRAPH, "See above.");
}
#end_block

#method_before
@Test
public void testQuote2() {
    String comment = "See this said:\n\n > a quoted\n > string block\n\nOK?";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(3);
    assertBlock(result, 0, PARAGRAPH, "See this said:");
    assertQuoteBlock(result, 1, 1);
    assertBlock(result.get(1).blocks, 0, PARAGRAPH, "a quoted\nstring block");
    assertBlock(result, 2, PARAGRAPH, "OK?");
}
#method_after
@Test
public void testQuote2() {
    String comment = "See this said:\n\n > a quoted\n > string block\n\nOK?";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(3);
    assertBlock(result, 0, PARAGRAPH, "See this said:");
    assertQuoteBlock(result, 1, 1);
    assertBlock(result.get(1).quotedBlocks, 0, PARAGRAPH, "a quoted\nstring block");
    assertBlock(result, 2, PARAGRAPH, "OK?");
}
#end_block

#method_before
@Test
public void testNestedQuotes1() {
    String comment = " > > prior\n > \n > next\n";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(1);
    assertQuoteBlock(result, 0, 2);
    assertQuoteBlock(result.get(0).blocks, 0, 1);
    assertBlock(result.get(0).blocks.get(0).blocks, 0, PARAGRAPH, "prior");
    assertBlock(result.get(0).blocks, 1, PARAGRAPH, "next\n");
}
#method_after
@Test
public void testNestedQuotes1() {
    String comment = " > > prior\n > \n > next\n";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(1);
    assertQuoteBlock(result, 0, 2);
    assertQuoteBlock(result.get(0).quotedBlocks, 0, 1);
    assertBlock(result.get(0).quotedBlocks.get(0).quotedBlocks, 0, PARAGRAPH, "prior");
    assertBlock(result.get(0).quotedBlocks, 1, PARAGRAPH, "next\n");
}
#end_block

#method_before
@Test
public void largeMixedQuote() {
    String comment = "> > Paragraph 1.\n" + "> > \n" + "> > > Paragraph 2.\n" + "> > \n" + "> > Paragraph 3.\n" + "> > \n" + "> >    pre line 1;\n" + "> >    pre line 2;\n" + "> > \n" + "> > Paragraph 4.\n" + "> > \n" + "> > * List item 1.\n" + "> > * List item 2.\n" + "> > \n" + "> > Paragraph 5.\n" + "> \n" + "> Paragraph 6.\n" + "\n" + "Paragraph 7.\n";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(2);
    assertQuoteBlock(result, 0, 2);
    assertQuoteBlock(result.get(0).blocks, 0, 7);
    List<CommentFormatter.Block> bigQuote = result.get(0).blocks.get(0).blocks;
    assertBlock(bigQuote, 0, PARAGRAPH, "Paragraph 1.");
    assertQuoteBlock(bigQuote, 1, 1);
    assertBlock(bigQuote.get(1).blocks, 0, PARAGRAPH, "Paragraph 2.");
    assertBlock(bigQuote, 2, PARAGRAPH, "Paragraph 3.");
    assertBlock(bigQuote, 3, PRE_FORMATTED, "   pre line 1;\n   pre line 2;");
    assertBlock(bigQuote, 4, PARAGRAPH, "Paragraph 4.");
    assertListBlock(bigQuote, 5, 0, "List item 1.");
    assertListBlock(bigQuote, 5, 1, "List item 2.");
    assertBlock(bigQuote, 6, PARAGRAPH, "Paragraph 5.");
    assertBlock(result.get(0).blocks, 1, PARAGRAPH, "Paragraph 6.");
    assertBlock(result, 1, PARAGRAPH, "Paragraph 7.\n");
}
#method_after
@Test
public void largeMixedQuote() {
    String comment = "> > Paragraph 1.\n" + "> > \n" + "> > > Paragraph 2.\n" + "> > \n" + "> > Paragraph 3.\n" + "> > \n" + "> >    pre line 1;\n" + "> >    pre line 2;\n" + "> > \n" + "> > Paragraph 4.\n" + "> > \n" + "> > * List item 1.\n" + "> > * List item 2.\n" + "> > \n" + "> > Paragraph 5.\n" + "> \n" + "> Paragraph 6.\n" + "\n" + "Paragraph 7.\n";
    List<CommentFormatter.Block> result = CommentFormatter.parse(comment);
    assertThat(result).hasSize(2);
    assertQuoteBlock(result, 0, 2);
    assertQuoteBlock(result.get(0).quotedBlocks, 0, 7);
    List<CommentFormatter.Block> bigQuote = result.get(0).quotedBlocks.get(0).quotedBlocks;
    assertBlock(bigQuote, 0, PARAGRAPH, "Paragraph 1.");
    assertQuoteBlock(bigQuote, 1, 1);
    assertBlock(bigQuote.get(1).quotedBlocks, 0, PARAGRAPH, "Paragraph 2.");
    assertBlock(bigQuote, 2, PARAGRAPH, "Paragraph 3.");
    assertBlock(bigQuote, 3, PRE_FORMATTED, "   pre line 1;\n   pre line 2;");
    assertBlock(bigQuote, 4, PARAGRAPH, "Paragraph 4.");
    assertListBlock(bigQuote, 5, 0, "List item 1.");
    assertListBlock(bigQuote, 5, 1, "List item 2.");
    assertBlock(bigQuote, 6, PARAGRAPH, "Paragraph 5.");
    assertBlock(result.get(0).quotedBlocks, 1, PARAGRAPH, "Paragraph 6.");
    assertBlock(result, 1, PARAGRAPH, "Paragraph 7.\n");
}
#end_block

#method_before
private List<Map<String, Object>> commentBlocksToSoyData(List<CommentFormatter.Block> blocks) {
    return blocks.stream().map(b -> {
        Map<String, Object> map = new HashMap<>();
        switch(b.type) {
            case PARAGRAPH:
                map.put("type", "paragraph");
                map.put("text", b.text);
                break;
            case PRE_FORMATTED:
                map.put("type", "pre");
                map.put("text", b.text);
                break;
            case QUOTE:
                map.put("type", "quote");
                map.put("blocks", commentBlocksToSoyData(b.blocks));
                break;
            case LIST:
                map.put("type", "list");
                map.put("items", b.items);
                break;
        }
        return map;
    }).collect(Collectors.toList());
}
#method_after
private List<Map<String, Object>> commentBlocksToSoyData(List<CommentFormatter.Block> blocks) {
    return blocks.stream().map(b -> {
        Map<String, Object> map = new HashMap<>();
        switch(b.type) {
            case PARAGRAPH:
                map.put("type", "paragraph");
                map.put("text", b.text);
                break;
            case PRE_FORMATTED:
                map.put("type", "pre");
                map.put("text", b.text);
                break;
            case QUOTE:
                map.put("type", "quote");
                map.put("quotedBlocks", commentBlocksToSoyData(b.quotedBlocks));
                break;
            case LIST:
                map.put("type", "list");
                map.put("items", b.items);
                break;
        }
        return map;
    }).collect(Collectors.toList());
}
#end_block

#method_before
public static List<Block> parse(@Nullable String source) {
    if (source == null || source.isEmpty()) {
        return Collections.emptyList();
    }
    List<Block> result = new ArrayList<>();
    for (String p : source.split("\n\n")) {
        if (isQuote(p)) {
            result.add(makeQuote(p));
        } else if (isPreFormat(p)) {
            result.add(makePre(p));
        } else if (isList(p)) {
            makeList(p, result);
        } else if (!p.isEmpty()) {
            result.add(makeParagraph(p));
        }
    }
    return result;
}
#method_after
public static List<Block> parse(@Nullable String source) {
    if (isNullOrEmpty(source)) {
        return Collections.emptyList();
    }
    List<Block> result = new ArrayList<>();
    for (String p : source.split("\n\n")) {
        if (isQuote(p)) {
            result.add(makeQuote(p));
        } else if (isPreFormat(p)) {
            result.add(makePre(p));
        } else if (isList(p)) {
            makeList(p, result);
        } else if (!p.isEmpty()) {
            result.add(makeParagraph(p));
        }
    }
    return result;
}
#end_block

#method_before
private static Block makeQuote(String p) {
    String quote = p.replaceAll("\n\\s?>\\s?", "\n");
    if (quote.startsWith("> ")) {
        quote = quote.substring(2);
    } else if (quote.startsWith(" > ")) {
        quote = quote.substring(3);
    }
    Block block = new Block();
    block.type = BlockType.QUOTE;
    block.blocks = CommentFormatter.parse(quote);
    return block;
}
#method_after
private static Block makeQuote(String p) {
    String quote = p.replaceAll("\n\\s?>\\s?", "\n");
    if (quote.startsWith("> ")) {
        quote = quote.substring(2);
    } else if (quote.startsWith(" > ")) {
        quote = quote.substring(3);
    }
    Block block = new Block();
    block.type = BlockType.QUOTE;
    block.quotedBlocks = CommentFormatter.parse(quote);
    return block;
}
#end_block

#method_before
@Override
public void onTopicEdited(TopicEditedListener.Event event) {
    ChangeInfo change = event.getChange();
    String oldTopic = event.getOldTopic();
    try {
        String revision = gApi.changes().id(change.id).get(EnumSet.of(ListChangesOption.CURRENT_REVISION)).currentRevision;
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.info("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, oldTopic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                log.info("Setting topic {} on {}", change.topic, changeNumber);
                gApi.changes().id(changeNumber).topic(change.topic);
            }
        }
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
    }
}
#method_after
@Override
public void onTopicEdited(TopicEditedListener.Event event) {
    ChangeInfo change = event.getChange();
    String oldTopic = event.getOldTopic();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.info("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, oldTopic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                log.info("Setting topic {} on {}", change.topic, changeNumber);
                gApi.changes().id(changeNumber).topic(change.topic);
            }
        } catch (RestApiException e) {
            log.error("RestApiException when editing downstream topics of {}", change.id, e);
        }
    }
}
#end_block

#method_before
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        String revision = gApi.changes().id(change.id).get(EnumSet.of(ListChangesOption.CURRENT_REVISION)).currentRevision;
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.info("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        Map<String, ApprovalInfo> approvals = event.getApprovals();
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                ChangeInfo downstreamChange = gApi.changes().id(changeNumber).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
                for (String label : approvals.keySet()) {
                    ApprovalInfo vote = approvals.get(label);
                    updateVote(downstreamChange, label, vote.value.shortValue());
                }
            }
        }
    } catch (RestApiException | IOException e) {
        log.error("Failed to edit downstream votes of {}", change.id, e);
    }
}
#method_after
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    RevisionInfo eventRevision = event.getRevision();
    if (!eventRevision.isCurrent) {
        log.info("Not updating downstream votes since revision {} is not current.", eventRevision._number);
        return;
    }
    ChangeInfo change = event.getChange();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException e) {
        log.error("Failed to update downstream votes of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    Map<String, ApprovalInfo> approvals = event.getApprovals();
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                ChangeInfo downstreamChange = gApi.changes().id(changeNumber).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
                for (Map.Entry<String, ApprovalInfo> label : approvals.entrySet()) {
                    updateVote(downstreamChange, label.getKey(), label.getValue().value.shortValue());
                }
            }
        } catch (RestApiException e) {
            log.error("RestApiException when updating downstream votes of {}", change.id, e);
        }
    }
}
#end_block

#method_before
private void abandonDownstream(ChangeInfo change, String revision) {
    try {
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.info("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            log.info("Abandoning existing downstreams: {}", existingDownstream);
            for (Integer changeNumber : existingDownstream) {
                abandonChange(changeNumber);
            }
        }
    } catch (RestApiException | IOException e) {
        log.error("Failed to abandon downstreams of {}", change.id, e);
    }
}
#method_after
private void abandonDownstream(ChangeInfo change, String revision) {
    try {
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            log.info("Abandoning existing downstreams: {}", existingDownstream);
            for (Integer changeNumber : existingDownstream) {
                abandonChange(changeNumber);
            }
        }
    } catch (RestApiException | IOException e) {
        log.error("Failed to abandon downstreams of {}", change.id, e);
    }
}
#end_block

#method_before
private void updateVote(ChangeInfo change, String label, Short vote) throws RestApiException {
    if (label.equals(config.getAutomergeLabel())) {
        log.info("Not updating automerge label, as it blocks when there is a merge conflict.");
        return;
    }
    log.info("Giving {} for label {} to {}", vote, label, change.id);
    // Vote on all downstream branches unless merge conflict.
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    labels.put(label, vote);
    reviewInput.labels = labels;
    gApi.changes().id(change.id).revision(change.currentRevision).review(reviewInput);
}
#method_after
private void updateVote(ChangeInfo change, String label, short vote) throws RestApiException {
    if (label.equals(config.getAutomergeLabel())) {
        log.info("Not updating automerge label, as it blocks when there is a merge conflict.");
        return;
    }
    log.info("Giving {} for label {} to {}", vote, label, change.id);
    // Vote on all downstream branches unless merge conflict.
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    labels.put(label, vote);
    reviewInput.labels = labels;
    gApi.changes().id(change.id).revision(change.currentRevision).review(reviewInput);
}
#end_block

