969
#method_before
@Override
protected void executeCommand() {
    List<Network> providedNetworks = getAllNetworks();
    Set<String> providedNetworkIds = externalIds(providedNetworks);
    List<Network> providerNetworksInDb = networkDao.getAllForProvider(getProvider().getId());
    List<Cluster> clusters = clusterDao.getAllClustersByDefaultNetworkProviderId(getProvider().getId());
    Set<Guid> dataCenterIds = clusters.stream().map(Cluster::getStoragePoolId).filter(Objects::nonNull).collect(Collectors.toSet());
    for (Guid dataCenterId : dataCenterIds) {
        Map<String, Network> providerNetworksInDataCenter = providerNetworksInDb.stream().filter(network -> dataCenterId.equals(network.getDataCenterId())).collect(Collectors.toMap(network -> network.getProvidedBy().getExternalId(), network -> network));
        providerNetworksInDataCenter.values().stream().filter(network -> !providedNetworkIds.contains(network.getProvidedBy().getExternalId())).forEach(network -> removeNetwork(network.getId()));
        List<Cluster> clustersInDataCenter = clusters.stream().filter(cluster -> dataCenterId.equals(cluster.getStoragePoolId())).collect(Collectors.toList());
        List<Guid> allClustersInDataCenterIds = clustersInDataCenter.stream().map(Cluster::getId).collect(Collectors.toList());
        List<Guid> allClustersWithOvsSwitchTypeIds = clustersInDataCenter.stream().filter(cluster -> cluster.hasRequiredSwitchType(SwitchType.OVS)).map(Cluster::getId).collect(Collectors.toList());
        for (Network network : providedNetworks) {
            Network networkInDataCenter = providerNetworksInDataCenter.get(network.getProvidedBy().getExternalId());
            if (networkInDataCenter == null) {
                ActionReturnValue importReturnValue = importNetwork(dataCenterId, network);
                if (importReturnValue.getSucceeded()) {
                    network.setId(importReturnValue.getActionReturnValue());
                    propagateReturnValue(networkHelper.attachNetworkToClusters(network.getId(), network.getProvidedBy().isLinkedToPhysicalNetwork() ? allClustersWithOvsSwitchTypeIds : allClustersInDataCenterIds));
                }
            } else {
                updateNetwork(dataCenterId, network, networkInDataCenter);
                updateNetworkClusters(network.getProvidedBy().isLinkedToPhysicalNetwork() ? allClustersWithOvsSwitchTypeIds : allClustersInDataCenterIds, network, networkInDataCenter);
            }
        }
    }
    setSucceeded(!errorOccurred);
}
#method_after
@Override
protected void executeCommand() {
    List<Network> providedNetworks = getAllNetworks();
    Set<String> providedNetworkIds = externalIds(providedNetworks);
    List<Network> providerNetworksInDb = networkDao.getAllForProvider(getProvider().getId());
    List<Cluster> clusters = clusterDao.getAllClustersByDefaultNetworkProviderId(getProvider().getId());
    Set<Guid> dataCenterIds = clusters.stream().map(Cluster::getStoragePoolId).filter(Objects::nonNull).collect(Collectors.toSet());
    for (Guid dataCenterId : dataCenterIds) {
        Map<String, Network> providerNetworksInDataCenter = providerNetworksInDb.stream().filter(network -> dataCenterId.equals(network.getDataCenterId())).collect(Collectors.toMap(network -> network.getProvidedBy().getExternalId(), network -> network));
        providerNetworksInDataCenter.values().stream().filter(network -> !providedNetworkIds.contains(network.getProvidedBy().getExternalId())).forEach(network -> removeNetwork(network.getId()));
        List<Cluster> idsOfClustersInDataCenter = clusters.stream().filter(cluster -> dataCenterId.equals(cluster.getStoragePoolId())).collect(Collectors.toList());
        List<Guid> allClustersInDataCenterIds = idsOfClustersInDataCenter.stream().map(Cluster::getId).collect(Collectors.toList());
        List<Guid> clustersWithOvsSwitchTypeIds = idsOfClustersInDataCenter.stream().filter(cluster -> cluster.hasRequiredSwitchType(SwitchType.OVS)).map(Cluster::getId).collect(Collectors.toList());
        for (Network network : providedNetworks) {
            Network networkInDataCenter = providerNetworksInDataCenter.get(network.getProvidedBy().getExternalId());
            List<Guid> clusterIds = network.getProvidedBy().isLinkedToPhysicalNetwork() ? clustersWithOvsSwitchTypeIds : allClustersInDataCenterIds;
            if (networkInDataCenter == null) {
                ActionReturnValue importReturnValue = importNetwork(dataCenterId, network);
                if (importReturnValue.getSucceeded()) {
                    network.setId(importReturnValue.getActionReturnValue());
                    propagateReturnValue(networkHelper.attachNetworkToClusters(network.getId(), clusterIds));
                }
            } else {
                updateNetwork(dataCenterId, network, networkInDataCenter);
                updateNetworkClusters(clusterIds, network, networkInDataCenter);
            }
        }
    }
    setSucceeded(!errorOccurred);
}
#end_block

#method_before
private void updateNetwork(Guid dataCenterId, Network externalNetwork, Network networkInDataCenter) {
    if (!networkInDataCenter.getName().equals(externalNetwork.getName())) {
        networkInDataCenter.setName(externalNetwork.getName());
        AddNetworkStoragePoolParameters parameters = new AddNetworkStoragePoolParameters(dataCenterId, networkInDataCenter);
        propagateReturnValue(runInternalAction(ActionType.UpdateNetwork, parameters, getInternalCommandContext()));
    }
}
#method_after
private void updateNetwork(Guid dataCenterId, Network externalNetwork, Network networkInDataCenter) {
    boolean changed = false;
    if (!networkInDataCenter.getName().equals(externalNetwork.getName())) {
        networkInDataCenter.setName(externalNetwork.getName());
        changed = true;
    }
    if (networkInDataCenter.getMtu() != externalNetwork.getMtu()) {
        networkInDataCenter.setMtu(externalNetwork.getMtu());
        changed = true;
    }
    if (changed) {
        AddNetworkStoragePoolParameters parameters = new AddNetworkStoragePoolParameters(dataCenterId, networkInDataCenter);
        propagateReturnValue(runInternalAction(ActionType.UpdateNetwork, parameters, getInternalCommandContext()));
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(externalId, providerId, physicalNetworkId, customPhysicalNetwork);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(externalId, providerId, physicalNetworkId, customPhysicalNetworkName, externalVlanId, providerNetworkType);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof ProviderNetwork)) {
        return false;
    }
    ProviderNetwork other = (ProviderNetwork) obj;
    return Objects.equals(externalId, other.externalId) && Objects.equals(providerId, other.providerId) && Objects.equals(physicalNetworkId, other.physicalNetworkId) && Objects.equals(customPhysicalNetwork, other.customPhysicalNetwork);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof ProviderNetwork)) {
        return false;
    }
    ProviderNetwork other = (ProviderNetwork) obj;
    return Objects.equals(externalId, other.externalId) && Objects.equals(providerId, other.providerId) && Objects.equals(physicalNetworkId, other.physicalNetworkId) && Objects.equals(customPhysicalNetworkName, other.customPhysicalNetworkName) && Objects.equals(externalVlanId, other.externalVlanId) && Objects.equals(providerNetworkType, other.providerNetworkType);
}
#end_block

#method_before
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("providerId", getProviderId()).append("externalId", getExternalId()).append("physicalNetworkId", getPhysicalNetworkId()).append("customPhysicalNetwork", getCustomPhysicalNetwork()).build();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("providerId", getProviderId()).append("externalId", getExternalId()).append("physicalNetworkId", getPhysicalNetworkId()).append("customPhysicalNetworkName", getCustomPhysicalNetworkName()).append("externalVlanId", getExternalVlanId()).append("providerNetworkType", getProviderNetworkType()).build();
}
#end_block

#method_before
private void commit() {
    if (getEntity() != null) {
        if (getWindow() != null) {
            return;
        }
        Snapshot snapshot = getSelectedItem();
        ConfirmationModel model = new ConfirmationModel();
        setWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().commitSnapshotTitle());
        model.setHelpTag(HelpTag.commit_snapshot);
        // $NON-NLS-1$
        model.setHashName("commit_snapshot");
        model.setMessage(ConstantsManager.getInstance().getMessages().areYouSureYouWantToCommitSanpshot(DateTimeFormat.getFormat(DATE_FORMAT).format(snapshot.getCreationDate()), snapshot.getDescription()));
        // $NON-NLS-1$
        UICommand tempVar = UICommand.createDefaultOkUiCommand("OnCommit", this);
        model.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
        model.getCommands().add(tempVar2);
    }
}
#method_after
private void commit() {
    if (getEntity() != null) {
        if (getWindow() != null) {
            return;
        }
        Snapshot snapshot = getSelectedItem();
        ConfirmationModel model = new ConfirmationModel();
        setWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().commitSnapshotTitle());
        model.setHelpTag(HelpTag.commit_snapshot);
        // $NON-NLS-1$
        model.setHashName("commit_snapshot");
        model.setMessage(ConstantsManager.getInstance().getMessages().areYouSureYouWantToCommitSnapshot(DateTimeFormat.getFormat(DATE_FORMAT).format(snapshot.getCreationDate()), snapshot.getDescription()));
        // $NON-NLS-1$
        model.getCommands().add(UICommand.createDefaultOkUiCommand("OnCommit", this));
        // $NON-NLS-1$
        model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
    }
}
#end_block

#method_before
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM resultVm = new VM();
    resultVm.setId(vm.getId());
    BuilderExecutor.build(model, resultVm.getStaticData(), new CommonUnitToVmBaseBuilder());
    BuilderExecutor.build(vm.getStaticData(), resultVm.getStaticData(), new VmBaseToVmBaseForTemplateCompositeBaseBuilder());
    return resultVm;
}
#method_after
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM resultVm = new VM();
    resultVm.setId(vm.getId());
    BuilderExecutor.build(model, resultVm.getStaticData(), new CommonUnitToVmBaseBuilder(), new MultiQueuesVmBaseBuilder());
    BuilderExecutor.build(vm.getStaticData(), resultVm.getStaticData(), new VmBaseToVmBaseForTemplateCompositeBaseBuilder());
    return resultVm;
}
#end_block

#method_before
@Test
public void searchUsingTags() {
    String[] searchTexts = { "Users: type=user and vm.id=12345678-1234-1234-1234-1234-123456789012", "Users: type=user and tag = foo", "Hosts: tag=foo" };
    for (String searchText : searchTexts) {
        assertTrue(new SyntaxChecker(20).analyzeSyntaxState(searchText, false).isSearchUsingTags());
    }
}
#method_after
@Test
public void searchUsingTags() {
    assertEquals(expected, new SyntaxChecker(20).analyzeSyntaxState(input, false).isSearchUsingTags());
}
#end_block

#method_before
@Override
public void onBind() {
    super.onBind();
    registerHandler(getView().getDismissAllButton().addClickHandler(event -> dismissAll()));
    registerHandler(getView().getDnd10Minutes().addClickHandler(event -> dnd10Minutes()));
    registerHandler(getView().getDnd1Hour().addClickHandler(event -> dnd1Hour()));
    registerHandler(getView().getDnd1Day().addClickHandler(event -> dnd1Day()));
    registerHandler(getView().getDndNextLogin().addClickHandler(event -> dndNextLogin()));
}
#method_after
@Override
public void onBind() {
    super.onBind();
    registerHandler(getView().getDismissAllButton().addClickHandler(event -> dismissAll()));
    registerHandler(getView().getDoNotDisturb10Minutes().addClickHandler(event -> doNotDisturb10Minutes()));
    registerHandler(getView().getDoNotDisturb1Hour().addClickHandler(event -> doNotDisturb1Hour()));
    registerHandler(getView().getDoNotDisturb1Day().addClickHandler(event -> doNotDisturb1Day()));
    registerHandler(getView().getDoNotDisturbNextLogin().addClickHandler(event -> doNotDisturbNextLogin()));
}
#end_block

#method_before
public ToastNotification createNotification(String text, ToastNotification.NotificationStatus status) {
    ToastNotification notification = new ToastNotification(text, status);
    if (doNotDisturb) {
        // some callers style the notification, so return a stub that won't be shown
        return notification;
    }
    // manual close
    HandlerRegistration handlerRegistration = notification.addCloseClickHandler(event -> hideNotification(notification));
    registerHandler(handlerRegistration);
    // auto close
    Timer closeTimer = new Timer() {

        @Override
        public void run() {
            hideNotification(notification);
            handlerRegistration.removeHandler();
        }
    };
    closeTimer.schedule(1000 * AUTO_CLOSE_DELAY_SECONDS);
    notifications.add(notification);
    getView().showNotification(notification);
    updateVisibility();
    return notification;
}
#method_after
public ToastNotification createNotification(String text, ToastNotification.NotificationStatus status) {
    ToastNotification notification = new ToastNotification(text, status);
    if (isDoNotDisturb()) {
        // some callers style the notification, so return a stub that won't be shown
        return notification;
    }
    // manual close
    HandlerRegistration handlerRegistration = notification.addCloseClickHandler(event -> hideNotification(notification));
    registerHandler(handlerRegistration);
    // auto close
    Timer closeTimer = new Timer() {

        @Override
        public void run() {
            hideNotification(notification);
            handlerRegistration.removeHandler();
        }
    };
    closeTimer.schedule(1000 * AUTO_CLOSE_DELAY_SECONDS);
    notifications.add(notification);
    getView().showNotification(notification);
    updateVisibility();
    return notification;
}
#end_block

#method_before
private boolean shouldFencingBeSkipped(VDS vds) {
    // check if fencing in cluster is enabled
    Cluster cluster = clusterDao.get(vds.getClusterId());
    if (cluster != null && !cluster.getFencingPolicy().isFencingEnabled()) {
        log.info("Host '{}' ({}) not fenced since fencing is disabled by cluster policy.", getVdsName(), getVdsId());
        AuditLogable alb = createAuditLogableForHost(vds);
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_FENCE_DISABLED_BY_CLUSTER_POLICY);
        return true;
    }
    // check if connectivity is not broken
    if (isConnectivityBrokenThresholdReached(getVds())) {
        log.info("Host '{}' ({}) not fenced since connectivity broken threshold reached.", getVdsName(), getVdsId());
        return true;
    }
    // fencing will be executed
    return false;
}
#method_after
private boolean shouldFencingBeSkipped(VDS vds) {
    // check if fencing in cluster is enabled
    Cluster cluster = clusterDao.get(vds.getClusterId());
    if (cluster != null && !cluster.getFencingPolicy().isFencingEnabled()) {
        AuditLogable alb = createAuditLogableForHost(vds);
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_FENCE_DISABLED_BY_CLUSTER_POLICY);
        return true;
    }
    // check if connectivity is not broken
    if (isConnectivityBrokenThresholdReached(getVds())) {
        return true;
    }
    // fencing will be executed
    return false;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDS host = getVds();
    if (!previousHostedEngineHost.isPreviousHostId(host.getId()) && !fenceValidator.isStartupTimeoutPassed() && !host.isInFenceFlow()) {
        log.error("Failed to run Fence script on vds '{}'.", getVdsName());
        alertIfPowerManagementOperationSkipped();
        // If fencing can't be done and the host is the SPM, set storage-pool to non-operational
        if (host.getSpmStatus() != VdsSpmStatus.None) {
            setStoragePoolNonOperational();
        }
        return;
    }
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    boolean shouldBeFenced = getVds().shouldVdsBeFenced();
    ActionReturnValue restartVdsResult = null;
    if (shouldBeFenced) {
        getParameters().setParentCommand(ActionType.VdsNotRespondingTreatment);
        ActionReturnValue retVal;
        retVal = runInternalAction(ActionType.SshSoftFencing, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // SSH Soft Fencing was successful and host is Up, stop non responding treatment
            getReturnValue().setSucceeded(true);
            setCommandShouldBeLogged(false);
            return;
        }
        // proceed with non responding treatment only if PM action are allowed and PM enabled for host
        if (!monitoringStrategyFactory.getMonitoringStrategyForVds(getVds()).isPowerManagementSupported() || !getVds().isPmEnabled()) {
            log.info("Host '{}' ({}) not fenced since power management is not supported or enabled.", getVdsName(), getVdsId());
            setSucceeded(false);
            setCommandShouldBeLogged(false);
            return;
        }
        retVal = runInternalAction(ActionType.VdsKdumpDetection, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = clusterDao.get(getVds().getClusterId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        waitUntilSkipFencingIfSDActiveAllowed(fencingPolicy.isSkipFencingIfSDActive());
        restartVdsResult = runInternalAction(ActionType.RestartVds, getParameters(), cloneContext().withoutExecutionContext());
    } else {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (restartVdsResult != null && restartVdsResult.<RestartVdsResult>getActionReturnValue() != null && restartVdsResult.<RestartVdsResult>getActionReturnValue().isSkippedDueToFencingPolicy()) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogable alb = createAuditLogableForHost(getVds());
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#method_after
@Override
protected void executeCommand() {
    VDS host = getVds();
    if (!previousHostedEngineHost.isPreviousHostId(host.getId()) && !fenceValidator.isStartupTimeoutPassed() && !host.isInFenceFlow()) {
        alertIfFenceOperationSkipped();
        // If fencing can't be done and the host is the SPM, set storage-pool to non-operational
        if (host.getSpmStatus() != VdsSpmStatus.None) {
            setStoragePoolNonOperational();
        }
        return;
    }
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    boolean shouldBeFenced = getVds().shouldVdsBeFenced();
    ActionReturnValue restartVdsResult = null;
    if (shouldBeFenced) {
        getParameters().setParentCommand(ActionType.VdsNotRespondingTreatment);
        ActionReturnValue retVal;
        retVal = runInternalAction(ActionType.SshSoftFencing, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // SSH Soft Fencing was successful and host is Up, stop non responding treatment
            getReturnValue().setSucceeded(true);
            setCommandShouldBeLogged(false);
            return;
        }
        // proceed with non responding treatment only if PM action are allowed and PM enabled for host
        if (!monitoringStrategyFactory.getMonitoringStrategyForVds(getVds()).isPowerManagementSupported() || !getVds().isPmEnabled()) {
            alertIfPowerManagementOperationSkipped();
            setSucceeded(false);
            setCommandShouldBeLogged(false);
            return;
        }
        retVal = runInternalAction(ActionType.VdsKdumpDetection, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = clusterDao.get(getVds().getClusterId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        waitUntilSkipFencingIfSDActiveAllowed(fencingPolicy.isSkipFencingIfSDActive());
        restartVdsResult = runInternalAction(ActionType.RestartVds, getParameters(), cloneContext().withoutExecutionContext());
    } else {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (restartVdsResult != null && restartVdsResult.<RestartVdsResult>getActionReturnValue() != null && restartVdsResult.<RestartVdsResult>getActionReturnValue().isSkippedDueToFencingPolicy()) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogable alb = createAuditLogableForHost(getVds());
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = null;
            if (vnicProfile != null) {
                queues = vnicProfile.getCustomProperties().remove("queues");
            }
            if (queues == null && vmInfoBuildUtils.isInterfaceQueuable(device, nic)) {
                queues = String.valueOf(vmInfoBuildUtils.getOptimalNumOfQueuesPerVnic(vm.getNumOfCpus()));
            }
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic, vnicProfile);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = null;
            if (vnicProfile != null) {
                queues = vnicProfile.getCustomProperties().remove("queues");
            }
            if (queues == null && vmInfoBuildUtils.isInterfaceQueuable(device, nic)) {
                queues = String.valueOf(vmInfoBuildUtils.getOptimalNumOfQueuesPerVnic(vm.getNumOfCpus()));
            }
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    if (!networkless && !vnicProfile.isPassthrough()) {
        writer.writeStartElement("mtu");
        writer.writeAttributeString("size", String.valueOf(NetworkUtils.getVmMtuActualValue(network)));
        writer.writeEndElement();
    }
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic, vnicProfile);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void showNic(NetworkInterfaceModel nic) {
    contents.removeAllRows();
    VdsNetworkInterface entity = nic.getOriginalIface();
    addRow(templates.titleSetupNetworkTooltip(nic.getName(), SafeStylesUtils.forTrustedBackgroundColor(BACKGROUND_COLOR)));
    if (nic.getItems().isEmpty() && !nic.isBonded()) {
        insertHorizontalLine();
        addMtuInfo(entity.getMtu());
        addBootProtoAndIpInfo(new InterfacePropertiesAccessor.FromNic(entity, null));
    }
    if (nic instanceof BondNetworkInterfaceModel) {
        CreateOrUpdateBond createOrUpdateBond = ((BondNetworkInterfaceModel) nic).getCreateOrUpdateBond();
        String bondOptions = entity.getBondOptions();
        if (createOrUpdateBond != null) {
            bondOptions = createOrUpdateBond.getBondOptions();
        }
        addRow(constants.bondOptionsItemInfo(), // $NON-NLS-1$
        bondOptions.replace(BOND_OPTIONS_IP_SEPARATOR, BOND_OPTIONS_IP_SEPARATOR + " "));
    } else {
        addLldpInfo(nic);
    }
    if (nic.isVf()) {
        addRow(constants.physicalFunction(), nic.getPhysicalFunction());
    }
    HostNicVfsConfig vfsConfig = nic.getSetupModel().getVfConfig(nic.getOriginalIface().getId());
    addNonNullOrEmptyValueRow(constants.enabledVirtualFunctions(), vfsConfig != null ? String.valueOf(vfsConfig.getNumOfVfs()) : null);
    addNonNullOrEmptyValueRow(constants.freeVirtualFunctions(), vfsConfig != null ? String.valueOf(vfsConfig.getNumOfFreeVfs()) : null);
}
#method_after
private void showNic(NetworkInterfaceModel nic) {
    contents.removeAllRows();
    VdsNetworkInterface entity = nic.getOriginalIface();
    addRow(templates.titleSetupNetworkTooltip(nic.getName(), SafeStylesUtils.forTrustedBackgroundColor(BACKGROUND_COLOR)));
    if (nic.getItems().isEmpty() && !nic.isBonded()) {
        insertHorizontalLine();
        addMtuInfo(entity.getMtu());
        addBootProtoAndIpInfo(new InterfacePropertiesAccessor.FromNic(entity, null));
    }
    if (nic instanceof BondNetworkInterfaceModel) {
        CreateOrUpdateBond createOrUpdateBond = ((BondNetworkInterfaceModel) nic).getCreateOrUpdateBond();
        String bondOptions = entity.getBondOptions();
        if (createOrUpdateBond != null) {
            bondOptions = createOrUpdateBond.getBondOptions();
        }
        addRow(constants.bondOptionsItemInfo(), // $NON-NLS-1$
        bondOptions.replace(BOND_OPTIONS_IP_SEPARATOR, BOND_OPTIONS_IP_SEPARATOR + " "));
    } else {
        addLldpInfo(nic);
    }
    if (nic.isVf()) {
        addRow(constants.physicalFunction(), nic.getPhysicalFunction());
    }
    HostNicVfsConfig vfsConfig = nic.getSetupModel().getVfConfig(nic.getOriginalIface().getId());
    if (nic.isSriovEnabled()) {
        addNonNullOrEmptyValueRow(constants.enabledVirtualFunctions(), String.valueOf(vfsConfig.getNumOfVfs()));
        addNonNullOrEmptyValueRow(constants.freeVirtualFunctions(), String.valueOf(vfsConfig.getNumOfFreeVfs()));
    }
}
#end_block

#method_before
private List<Network> map(List<com.woorea.openstack.quantum.model.Network> externalNetworks) {
    List<Network> networks = new ArrayList<>(externalNetworks.size());
    for (com.woorea.openstack.quantum.model.Network externalNetwork : externalNetworks) {
        Network network = new Network();
        network.setVmNetwork(true);
        network.setProvidedBy(new ProviderNetwork(getProvider().getId(), externalNetwork.getId()));
        network.setName(externalNetwork.getName());
        network.setMtu(externalNetwork.getMtu() == null ? 0 : externalNetwork.getMtu());
        networks.add(network);
    }
    return networks;
}
#method_after
private List<Network> map(List<com.woorea.openstack.quantum.model.Network> externalNetworks) {
    List<Network> networks = new ArrayList<>(externalNetworks.size());
    for (com.woorea.openstack.quantum.model.Network externalNetwork : externalNetworks) {
        Network network = new Network();
        network.setVmNetwork(true);
        network.setProvidedBy(new ProviderNetwork(getProvider().getId(), externalNetwork.getId()));
        network.setName(externalNetwork.getName());
        if (externalNetwork.getMtu() != null) {
            network.setMtu(externalNetwork.getMtu());
        }
        networks.add(network);
    }
    return networks;
}
#end_block

#method_before
@Override
public Map<String, String> allocate(Network network, VnicProfile vnicProfile, VmNic nic, VDS host, boolean ignoreSecurityGroupsOnUpdate) {
    Port port = locatePort(nic);
    List<String> securityGroups = getSecurityGroups(vnicProfile);
    String hostId = getHostId(host);
    if (port == null) {
        com.woorea.openstack.quantum.model.Network externalNetwork = getExternalNetwork(network.getProvidedBy());
        Port portForCreate = createNewPortForAllocate(nic, securityGroups, hostId, externalNetwork);
        port = execute(getClient().ports().create(portForCreate));
    } else {
        boolean securityGroupsChanged = !ignoreSecurityGroupsOnUpdate && securityGroupsChanged(port.getSecurityGroups(), securityGroups);
        boolean hostChanged = hostChanged(port, hostId);
        updatePort(port, securityGroupsChanged, hostChanged, securityGroups, hostId, nic);
    }
    Map<String, String> runtimeProperties = createPortAllocationRuntimeProperties(port);
    return runtimeProperties;
}
#method_after
@Override
public Map<String, String> allocate(Network network, VnicProfile vnicProfile, VmNic nic, VDS host, boolean ignoreSecurityGroupsOnUpdate, String hostBindingId) {
    if (hostBindingId == null) {
        hostBindingId = getHostId(host);
        log.warn("Host binding id for external network {} on host {} is null, using host id {} to allocate vNIC " + " {} instead. Please provide an after_get_caps hook for the plugin type {} on host {}", network.getName(), host.getName(), hostBindingId, nic.getName(), getProvider().getAdditionalProperties().getPluginType(), host.getName());
    }
    Port port = locatePort(nic);
    List<String> securityGroups = getSecurityGroups(vnicProfile);
    if (port == null) {
        com.woorea.openstack.quantum.model.Network externalNetwork = getExternalNetwork(network.getProvidedBy());
        Port portForCreate = createNewPortForAllocate(nic, securityGroups, hostBindingId, externalNetwork);
        port = execute(getClient().ports().create(portForCreate));
    } else {
        boolean securityGroupsChanged = !ignoreSecurityGroupsOnUpdate && securityGroupsChanged(port.getSecurityGroups(), securityGroups);
        updatePort(port, securityGroupsChanged, securityGroups, hostBindingId, nic);
    }
    Map<String, String> runtimeProperties = createPortAllocationRuntimeProperties(port);
    return runtimeProperties;
}
#end_block

#method_before
private Port updatePort(Port port, boolean securityGroupsChanged, boolean hostChanged, List<String> securityGroups, String hostId, VmNic nic) {
    if (securityGroupsChanged || hostChanged) {
        List<String> modifiedSecurityGroups = securityGroupsChanged ? securityGroups : port.getSecurityGroups();
        Port portForUpdate = modifyPortForAllocate(port, hostId, hostChanged, securityGroupsChanged, modifiedSecurityGroups, nic.getMacAddress());
        return execute(getClient().ports().update(portForUpdate));
    }
    return port;
}
#method_after
private Port updatePort(Port port, boolean securityGroupsChanged, List<String> securityGroups, String hostBindingId, VmNic nic) {
    boolean hostChanged = hostChanged(port, hostBindingId);
    if (securityGroupsChanged || hostChanged) {
        List<String> modifiedSecurityGroups = securityGroupsChanged ? securityGroups : port.getSecurityGroups();
        Port portForUpdate = modifyPortForAllocate(port, hostBindingId, hostChanged, securityGroupsChanged, modifiedSecurityGroups, nic.getMacAddress());
        return execute(getClient().ports().update(portForUpdate));
    }
    return port;
}
#end_block

#method_before
protected Port modifyPortForAllocate(Port port, String hostId, boolean hostChanged, boolean securityGroupsChanged, List<String> modifiedSecurityGroups, String macAddress) {
    Port portForUpdate = securityGroupsChanged ? new PortForUpdate() : new Port();
    portForUpdate.setId(port.getId());
    if (securityGroupsChanged) {
        portForUpdate.setSecurityGroups(modifiedSecurityGroups);
    }
    if (hostChanged) {
        portForUpdate.setBinding(new Binding());
        portForUpdate.getBinding().setHostId(hostId);
        portForUpdate.setMacAddress(macAddress);
    }
    return portForUpdate;
}
#method_after
protected Port modifyPortForAllocate(Port port, String hostBindingId, boolean hostChanged, boolean securityGroupsChanged, List<String> modifiedSecurityGroups, String macAddress) {
    Port portForUpdate = securityGroupsChanged ? new PortForUpdate() : new Port();
    portForUpdate.setId(port.getId());
    if (securityGroupsChanged) {
        portForUpdate.setSecurityGroups(modifiedSecurityGroups);
    }
    if (hostChanged) {
        portForUpdate.setBinding(new Binding());
        portForUpdate.getBinding().setHostId(hostBindingId);
        portForUpdate.setMacAddress(macAddress);
    }
    return portForUpdate;
}
#end_block

#method_before
protected Port createNewPortForAllocate(VmNic nic, List<String> securityGroups, String hostId, com.woorea.openstack.quantum.model.Network externalNetwork) {
    Port portForCreate = new Port();
    portForCreate.setAdminStateUp(true);
    portForCreate.setName(nic.getName());
    portForCreate.setMacAddress(nic.getMacAddress());
    portForCreate.setNetworkId(externalNetwork.getId());
    portForCreate.setDeviceOwner(DEVICE_OWNER);
    portForCreate.setDeviceId(nic.getId().toString());
    portForCreate.setSecurityGroups(securityGroups);
    portForCreate.setBinding(new Binding());
    portForCreate.getBinding().setHostId(hostId);
    portForCreate.setTenantId(externalNetwork.getTenantId());
    return portForCreate;
}
#method_after
protected Port createNewPortForAllocate(VmNic nic, List<String> securityGroups, String hostBindingId, com.woorea.openstack.quantum.model.Network externalNetwork) {
    Port portForCreate = new Port();
    portForCreate.setAdminStateUp(true);
    portForCreate.setName(nic.getName());
    portForCreate.setMacAddress(nic.getMacAddress());
    portForCreate.setNetworkId(externalNetwork.getId());
    portForCreate.setDeviceOwner(DEVICE_OWNER);
    portForCreate.setDeviceId(nic.getId().toString());
    portForCreate.setSecurityGroups(securityGroups);
    portForCreate.setBinding(new Binding());
    portForCreate.getBinding().setHostId(hostBindingId);
    portForCreate.setTenantId(externalNetwork.getTenantId());
    return portForCreate;
}
#end_block

#method_before
private boolean hostChanged(Port port, String hostId) {
    return port.getBinding() == null || !StringUtils.equals(port.getBinding().getHostId(), hostId);
}
#method_after
private boolean hostChanged(Port port, String hostId) {
    return port.getBinding() == null || hostId == null || !StringUtils.equals(port.getBinding().getHostId(), hostId);
}
#end_block

#method_before
protected void readGeneralData(XmlNode content) {
    vmBase.setVmInit(new VmInit());
    consumeReadProperty(content, DESCRIPTION, val -> vmBase.setDescription(val));
    consumeReadProperty(content, COMMENT, val -> vmBase.setComment(val));
    consumeReadProperty(content, DOMAIN, val -> vmBase.getVmInit().setDomain(val));
    consumeReadProperty(content, CREATION_DATE, val -> vmBase.setCreationDate(OvfParser.utcDateStringToLocalDate(val)));
    consumeReadProperty(content, EXPORT_DATE, val -> vmBase.setExportDate(OvfParser.utcDateStringToLocalDate(val)));
    consumeReadProperty(content, DEFAULT_BOOT_SEQUENCE, val -> vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, INITRD_URL, val -> vmBase.setInitrdUrl(val));
    consumeReadProperty(content, KERNEL_URL, val -> vmBase.setKernelUrl(val));
    consumeReadProperty(content, KERNEL_PARAMS, val -> vmBase.setKernelParams(val));
    consumeReadProperty(content, GENERATION, val -> vmBase.setDbGeneration(Long.parseLong(val)), () -> vmBase.setDbGeneration(1L));
    XmlNode node = selectSingleNode(content, CUSTOM_COMPATIBILITY_VERSION);
    if (node != null) {
        vmBase.setCustomCompatibilityVersion(new Version(node.innerText));
    }
    // the originating ENGINE version
    Version originVersion = new Version(getVersion());
    node = selectSingleNode(content, CLUSTER_COMPATIBILITY_VERSION);
    if (node != null) {
        originVersion = new Version(node.innerText);
    }
    vmBase.setClusterCompatibilityVersionOrigin(originVersion);
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    consumeReadProperty(content, getDefaultDisplayTypeStringRepresentation(), val -> vmBase.setDefaultDisplayType(DisplayType.forValue(Integer.parseInt(val))));
    // after reading the hardware section, if graphics device is still absent, add a default one
    addDefaultGraphicsDevice();
    fixDiskVmElements();
    // due to dependency on vmBase.getOsId() must be read AFTER readOsSection
    consumeReadProperty(content, TIMEZONE, val -> vmBase.setTimeZone(val), () -> {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    });
    consumeReadProperty(content, ORIGIN, val -> vmBase.setOrigin(OriginType.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, VM_TYPE, val -> vmBase.setVmType(VmType.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, RESUME_BEHAVIOR, val -> vmBase.setResumeBehavior(VmResumeBehavior.valueOf(val)));
    consumeReadProperty(content, IS_SMARTCARD_ENABLED, val -> vmBase.setSmartcardEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, NUM_OF_IOTHREADS, val -> vmBase.setNumOfIoThreads(Integer.parseInt(val)));
    consumeReadProperty(content, DELETE_PROTECTED, val -> vmBase.setDeleteProtected(Boolean.parseBoolean(val)));
    consumeReadProperty(content, SSO_METHOD, val -> vmBase.setSsoMethod(SsoMethod.fromString(val)));
    consumeReadProperty(content, TUNNEL_MIGRATION, val -> vmBase.setTunnelMigration(Boolean.parseBoolean(val)));
    consumeReadProperty(content, VNC_KEYBOARD_LAYOUT, val -> vmBase.setVncKeyboardLayout(val));
    consumeReadProperty(content, MIN_ALLOCATED_MEMORY, val -> vmBase.setMinAllocatedMem(Integer.parseInt(val)));
    consumeReadProperty(content, IS_STATELESS, val -> vmBase.setStateless(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_RUN_AND_PAUSE, val -> vmBase.setRunAndPause(Boolean.parseBoolean(val)));
    consumeReadProperty(content, CREATED_BY_USER_ID, val -> vmBase.setCreatedByUserId(Guid.createGuidFromString(val)));
    consumeReadProperty(content, MIGRATION_DOWNTIME, val -> vmBase.setMigrationDowntime(Integer.parseInt(val)));
    consumeReadProperty(content, MIGRATION_SUPPORT, val -> vmBase.setMigrationSupport(MigrationSupport.forValue(Integer.parseInt(val))));
    // TODO dedicated to multiple hosts
    readDedicatedHostsList(content);
    consumeReadProperty(content, SERIAL_NUMBER_POLICY, val -> vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, CUSTOM_SERIAL_NUMBER, val -> vmBase.setCustomSerialNumber(val));
    consumeReadProperty(content, AUTO_STARTUP, val -> vmBase.setAutoStartup(Boolean.parseBoolean(val)));
    consumeReadProperty(content, PRIORITY, val -> vmBase.setPriority(Integer.parseInt(val)));
    consumeReadProperty(content, IS_BOOT_MENU_ENABLED, val -> vmBase.setBootMenuEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_SPICE_FILE_TRANSFER_ENABLED, val -> vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_SPICE_COPY_PASTE_ENABLED, val -> vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, ALLOW_CONSOLE_RECONNECT, val -> vmBase.setAllowConsoleReconnect(Boolean.parseBoolean(val)));
    consumeReadProperty(content, CONSOLE_DISCONNECT_ACTION, val -> vmBase.setConsoleDisconnectAction(ConsoleDisconnectAction.fromString(val)));
    consumeReadProperty(content, IS_AUTO_CONVERGE, val -> vmBase.setAutoConverge(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_MIGRATE_COMPRESSED, val -> vmBase.setMigrateCompressed(Boolean.parseBoolean(val)));
    consumeReadProperty(content, MIGRATION_POLICY_ID, val -> vmBase.setMigrationPolicyId(Guid.createGuidFromString(val)));
    consumeReadProperty(content, CUSTOM_EMULATED_MACHINE, val -> vmBase.setCustomEmulatedMachine(val));
    consumeReadProperty(content, CUSTOM_CPU_NAME, val -> vmBase.setCustomCpuName(val));
    consumeReadProperty(content, PREDEFINED_PROPERTIES, val -> vmBase.setPredefinedProperties(val));
    consumeReadProperty(content, USER_DEFINED_PROPERTIES, val -> vmBase.setUserDefinedProperties(val));
    consumeReadProperty(content, MAX_MEMORY_SIZE_MB, val -> vmBase.setMaxMemorySizeMb(Integer.parseInt(val)));
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    consumeReadProperty(content, VM_LEASE, val -> vmBase.setLeaseStorageDomainId(new Guid(val)));
    consumeReadProperty(content, MULTI_QUEUES_ENABLED, val -> vmBase.setMultiQueuesEnabled(Boolean.parseBoolean(val)), () -> vmBase.setMultiQueuesEnabled(true));
    readVmInit(content);
}
#method_after
protected void readGeneralData(XmlNode content) {
    vmBase.setVmInit(new VmInit());
    consumeReadProperty(content, DESCRIPTION, val -> vmBase.setDescription(val));
    consumeReadProperty(content, COMMENT, val -> vmBase.setComment(val));
    consumeReadProperty(content, DOMAIN, val -> vmBase.getVmInit().setDomain(val));
    consumeReadProperty(content, CREATION_DATE, val -> vmBase.setCreationDate(OvfParser.utcDateStringToLocalDate(val)));
    consumeReadProperty(content, EXPORT_DATE, val -> vmBase.setExportDate(OvfParser.utcDateStringToLocalDate(val)));
    consumeReadProperty(content, DEFAULT_BOOT_SEQUENCE, val -> vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, INITRD_URL, val -> vmBase.setInitrdUrl(val));
    consumeReadProperty(content, KERNEL_URL, val -> vmBase.setKernelUrl(val));
    consumeReadProperty(content, KERNEL_PARAMS, val -> vmBase.setKernelParams(val));
    consumeReadProperty(content, GENERATION, val -> vmBase.setDbGeneration(Long.parseLong(val)), () -> vmBase.setDbGeneration(1L));
    XmlNode node = selectSingleNode(content, CUSTOM_COMPATIBILITY_VERSION);
    if (node != null) {
        vmBase.setCustomCompatibilityVersion(new Version(node.innerText));
    }
    // the originating ENGINE version
    Version originVersion = new Version(getVersion());
    node = selectSingleNode(content, CLUSTER_COMPATIBILITY_VERSION);
    if (node != null) {
        originVersion = new Version(node.innerText);
    }
    vmBase.setClusterCompatibilityVersionOrigin(originVersion);
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    consumeReadProperty(content, getDefaultDisplayTypeStringRepresentation(), val -> vmBase.setDefaultDisplayType(DisplayType.forValue(Integer.parseInt(val))));
    // after reading the hardware section, if graphics device is still absent, add a default one
    addDefaultGraphicsDevice();
    fixDiskVmElements();
    // due to dependency on vmBase.getOsId() must be read AFTER readOsSection
    consumeReadProperty(content, TIMEZONE, val -> vmBase.setTimeZone(val), () -> {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    });
    consumeReadProperty(content, ORIGIN, val -> vmBase.setOrigin(OriginType.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, VM_TYPE, val -> vmBase.setVmType(VmType.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, RESUME_BEHAVIOR, val -> vmBase.setResumeBehavior(VmResumeBehavior.valueOf(val)));
    consumeReadProperty(content, IS_SMARTCARD_ENABLED, val -> vmBase.setSmartcardEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, NUM_OF_IOTHREADS, val -> vmBase.setNumOfIoThreads(Integer.parseInt(val)));
    consumeReadProperty(content, DELETE_PROTECTED, val -> vmBase.setDeleteProtected(Boolean.parseBoolean(val)));
    consumeReadProperty(content, SSO_METHOD, val -> vmBase.setSsoMethod(SsoMethod.fromString(val)));
    consumeReadProperty(content, TUNNEL_MIGRATION, val -> vmBase.setTunnelMigration(Boolean.parseBoolean(val)));
    consumeReadProperty(content, VNC_KEYBOARD_LAYOUT, val -> vmBase.setVncKeyboardLayout(val));
    consumeReadProperty(content, MIN_ALLOCATED_MEMORY, val -> vmBase.setMinAllocatedMem(Integer.parseInt(val)));
    consumeReadProperty(content, IS_STATELESS, val -> vmBase.setStateless(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_RUN_AND_PAUSE, val -> vmBase.setRunAndPause(Boolean.parseBoolean(val)));
    consumeReadProperty(content, CREATED_BY_USER_ID, val -> vmBase.setCreatedByUserId(Guid.createGuidFromString(val)));
    consumeReadProperty(content, MIGRATION_DOWNTIME, val -> vmBase.setMigrationDowntime(Integer.parseInt(val)));
    consumeReadProperty(content, MIGRATION_SUPPORT, val -> vmBase.setMigrationSupport(MigrationSupport.forValue(Integer.parseInt(val))));
    // TODO dedicated to multiple hosts
    readDedicatedHostsList(content);
    consumeReadProperty(content, SERIAL_NUMBER_POLICY, val -> vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, CUSTOM_SERIAL_NUMBER, val -> vmBase.setCustomSerialNumber(val));
    consumeReadProperty(content, AUTO_STARTUP, val -> vmBase.setAutoStartup(Boolean.parseBoolean(val)));
    consumeReadProperty(content, PRIORITY, val -> vmBase.setPriority(Integer.parseInt(val)));
    consumeReadProperty(content, IS_BOOT_MENU_ENABLED, val -> vmBase.setBootMenuEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_SPICE_FILE_TRANSFER_ENABLED, val -> vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_SPICE_COPY_PASTE_ENABLED, val -> vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(val)));
    consumeReadProperty(content, ALLOW_CONSOLE_RECONNECT, val -> vmBase.setAllowConsoleReconnect(Boolean.parseBoolean(val)));
    consumeReadProperty(content, CONSOLE_DISCONNECT_ACTION, val -> vmBase.setConsoleDisconnectAction(ConsoleDisconnectAction.fromString(val)));
    consumeReadProperty(content, IS_AUTO_CONVERGE, val -> vmBase.setAutoConverge(Boolean.parseBoolean(val)));
    consumeReadProperty(content, IS_MIGRATE_COMPRESSED, val -> vmBase.setMigrateCompressed(Boolean.parseBoolean(val)));
    consumeReadProperty(content, MIGRATION_POLICY_ID, val -> vmBase.setMigrationPolicyId(Guid.createGuidFromString(val)));
    consumeReadProperty(content, CUSTOM_EMULATED_MACHINE, val -> vmBase.setCustomEmulatedMachine(val));
    consumeReadProperty(content, BIOS_TYPE, val -> vmBase.setBiosType(BiosType.forValue(Integer.parseInt(val))));
    consumeReadProperty(content, CUSTOM_CPU_NAME, val -> vmBase.setCustomCpuName(val));
    consumeReadProperty(content, PREDEFINED_PROPERTIES, val -> vmBase.setPredefinedProperties(val));
    consumeReadProperty(content, USER_DEFINED_PROPERTIES, val -> vmBase.setUserDefinedProperties(val));
    consumeReadProperty(content, MAX_MEMORY_SIZE_MB, val -> vmBase.setMaxMemorySizeMb(Integer.parseInt(val)));
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    consumeReadProperty(content, VM_LEASE, val -> vmBase.setLeaseStorageDomainId(new Guid(val)));
    consumeReadProperty(content, MULTI_QUEUES_ENABLED, val -> vmBase.setMultiQueuesEnabled(Boolean.parseBoolean(val)));
    readVmInit(content);
}
#end_block

#method_before
protected void writeGeneralData() {
    _writer.writeElement(NAME, vmBase.getName());
    if (vmBase.getDescription() != null) {
        _writer.writeElement(DESCRIPTION, vmBase.getDescription());
    }
    if (vmBase.getComment() != null) {
        _writer.writeElement(COMMENT, vmBase.getComment());
    }
    _writer.writeElement(CREATION_DATE, OvfParser.localDateToUtcDateString(vmBase.getCreationDate()));
    _writer.writeElement(EXPORT_DATE, OvfParser.localDateToUtcDateString(new Date()));
    _writer.writeElement(DELETE_PROTECTED, String.valueOf(vmBase.isDeleteProtected()));
    if (vmBase.getSsoMethod() != null) {
        _writer.writeElement(SSO_METHOD, vmBase.getSsoMethod().toString());
    }
    _writer.writeElement(IS_SMARTCARD_ENABLED, String.valueOf(vmBase.isSmartcardEnabled()));
    if (vmBase.getNumOfIoThreads() != 0) {
        _writer.writeElement(NUM_OF_IOTHREADS, String.valueOf(vmBase.getNumOfIoThreads()));
    }
    _writer.writeElement(TIMEZONE, vmBase.getTimeZone());
    _writer.writeElement(DEFAULT_BOOT_SEQUENCE, String.valueOf(vmBase.getDefaultBootSequence().getValue()));
    if (!StringUtils.isBlank(vmBase.getInitrdUrl())) {
        _writer.writeElement(INITRD_URL, vmBase.getInitrdUrl());
    }
    if (!StringUtils.isBlank(vmBase.getKernelUrl())) {
        _writer.writeElement(KERNEL_URL, vmBase.getKernelUrl());
    }
    if (!StringUtils.isBlank(vmBase.getKernelParams())) {
        _writer.writeElement(KERNEL_PARAMS, vmBase.getKernelParams());
    }
    _writer.writeElement(GENERATION, String.valueOf(vmBase.getDbGeneration()));
    if (vmBase.getCustomCompatibilityVersion() != null) {
        _writer.writeElement(CUSTOM_COMPATIBILITY_VERSION, String.valueOf(vmBase.getCustomCompatibilityVersion()));
    }
    // cluster version the VM/Snapshot
    _writer.writeElement(CLUSTER_COMPATIBILITY_VERSION, String.valueOf(version));
    // originates from
    _writer.writeElement(VM_TYPE, String.valueOf(vmBase.getVmType().getValue()));
    if (vmBase.getResumeBehavior() != null) {
        _writer.writeElement(RESUME_BEHAVIOR, String.valueOf(vmBase.getResumeBehavior()));
    }
    if (vmBase.getTunnelMigration() != null) {
        _writer.writeElement(TUNNEL_MIGRATION, String.valueOf(vmBase.getTunnelMigration()));
    }
    if (vmBase.getVncKeyboardLayout() != null) {
        _writer.writeElement(VNC_KEYBOARD_LAYOUT, vmBase.getVncKeyboardLayout());
    }
    _writer.writeElement(MIN_ALLOCATED_MEMORY, String.valueOf(vmBase.getMinAllocatedMem()));
    _writer.writeElement(IS_STATELESS, String.valueOf(vmBase.isStateless()));
    _writer.writeElement(IS_RUN_AND_PAUSE, String.valueOf(vmBase.isRunAndPause()));
    _writer.writeElement(AUTO_STARTUP, String.valueOf(vmBase.isAutoStartup()));
    _writer.writeElement(PRIORITY, String.valueOf(vmBase.getPriority()));
    if (vmBase.getCreatedByUserId() != null) {
        _writer.writeElement(CREATED_BY_USER_ID, String.valueOf(vmBase.getCreatedByUserId()));
    }
    if (vmBase.getMigrationDowntime() != null) {
        _writer.writeElement(MIGRATION_DOWNTIME, String.valueOf(vmBase.getMigrationDowntime()));
    }
    writeVmInit();
    if (vmBase.getMigrationSupport() != null) {
        _writer.writeElement(MIGRATION_SUPPORT, String.valueOf(vmBase.getMigrationSupport().getValue()));
    }
    // TODO dedicated to multiple hosts - are we breaking any standard here?
    vmBase.getDedicatedVmForVdsList().forEach(d -> _writer.writeElement(DEDICATED_VM_FOR_VDS, String.valueOf(d)));
    if (vmBase.getSerialNumberPolicy() != null) {
        _writer.writeElement(SERIAL_NUMBER_POLICY, String.valueOf(vmBase.getSerialNumberPolicy().getValue()));
    }
    if (vmBase.getCustomSerialNumber() != null) {
        _writer.writeElement(CUSTOM_SERIAL_NUMBER, vmBase.getCustomSerialNumber());
    }
    _writer.writeElement(IS_BOOT_MENU_ENABLED, String.valueOf(vmBase.isBootMenuEnabled()));
    _writer.writeElement(IS_SPICE_FILE_TRANSFER_ENABLED, String.valueOf(vmBase.isSpiceFileTransferEnabled()));
    _writer.writeElement(IS_SPICE_COPY_PASTE_ENABLED, String.valueOf(vmBase.isSpiceCopyPasteEnabled()));
    _writer.writeElement(ALLOW_CONSOLE_RECONNECT, String.valueOf(vmBase.isAllowConsoleReconnect()));
    _writer.writeElement(CONSOLE_DISCONNECT_ACTION, String.valueOf(vmBase.getConsoleDisconnectAction()));
    if (vmBase.getAutoConverge() != null) {
        _writer.writeElement(IS_AUTO_CONVERGE, String.valueOf(vmBase.getAutoConverge()));
    }
    if (vmBase.getMigrateCompressed() != null) {
        _writer.writeElement(IS_MIGRATE_COMPRESSED, String.valueOf(vmBase.getMigrateCompressed()));
    }
    if (vmBase.getMigrationPolicyId() != null) {
        _writer.writeElement(MIGRATION_POLICY_ID, String.valueOf(vmBase.getMigrationPolicyId()));
    }
    writeCustomEmulatedMachine();
    writeCustomCpuName();
    _writer.writeElement(PREDEFINED_PROPERTIES, vmBase.getPredefinedProperties());
    _writer.writeElement(USER_DEFINED_PROPERTIES, vmBase.getUserDefinedProperties());
    _writer.writeElement(MAX_MEMORY_SIZE_MB, String.valueOf(vmBase.getMaxMemorySizeMb()));
    if (vmBase.getLeaseStorageDomainId() != null) {
        _writer.writeElement(VM_LEASE, vmBase.getLeaseStorageDomainId().toString());
    }
    _writer.writeElement(MULTI_QUEUES_ENABLED, String.valueOf(vmBase.isMultiQueuesEnabled()));
}
#method_after
protected void writeGeneralData() {
    _writer.writeElement(NAME, vmBase.getName());
    if (vmBase.getDescription() != null) {
        _writer.writeElement(DESCRIPTION, vmBase.getDescription());
    }
    if (vmBase.getComment() != null) {
        _writer.writeElement(COMMENT, vmBase.getComment());
    }
    _writer.writeElement(CREATION_DATE, OvfParser.localDateToUtcDateString(vmBase.getCreationDate()));
    _writer.writeElement(EXPORT_DATE, OvfParser.localDateToUtcDateString(new Date()));
    _writer.writeElement(DELETE_PROTECTED, String.valueOf(vmBase.isDeleteProtected()));
    if (vmBase.getSsoMethod() != null) {
        _writer.writeElement(SSO_METHOD, vmBase.getSsoMethod().toString());
    }
    _writer.writeElement(IS_SMARTCARD_ENABLED, String.valueOf(vmBase.isSmartcardEnabled()));
    if (vmBase.getNumOfIoThreads() != 0) {
        _writer.writeElement(NUM_OF_IOTHREADS, String.valueOf(vmBase.getNumOfIoThreads()));
    }
    _writer.writeElement(TIMEZONE, vmBase.getTimeZone());
    _writer.writeElement(DEFAULT_BOOT_SEQUENCE, String.valueOf(vmBase.getDefaultBootSequence().getValue()));
    if (!StringUtils.isBlank(vmBase.getInitrdUrl())) {
        _writer.writeElement(INITRD_URL, vmBase.getInitrdUrl());
    }
    if (!StringUtils.isBlank(vmBase.getKernelUrl())) {
        _writer.writeElement(KERNEL_URL, vmBase.getKernelUrl());
    }
    if (!StringUtils.isBlank(vmBase.getKernelParams())) {
        _writer.writeElement(KERNEL_PARAMS, vmBase.getKernelParams());
    }
    _writer.writeElement(GENERATION, String.valueOf(vmBase.getDbGeneration()));
    if (vmBase.getCustomCompatibilityVersion() != null) {
        _writer.writeElement(CUSTOM_COMPATIBILITY_VERSION, String.valueOf(vmBase.getCustomCompatibilityVersion()));
    }
    // cluster version the VM/Snapshot
    _writer.writeElement(CLUSTER_COMPATIBILITY_VERSION, String.valueOf(version));
    // originates from
    _writer.writeElement(VM_TYPE, String.valueOf(vmBase.getVmType().getValue()));
    if (vmBase.getResumeBehavior() != null) {
        _writer.writeElement(RESUME_BEHAVIOR, String.valueOf(vmBase.getResumeBehavior()));
    }
    if (vmBase.getTunnelMigration() != null) {
        _writer.writeElement(TUNNEL_MIGRATION, String.valueOf(vmBase.getTunnelMigration()));
    }
    if (vmBase.getVncKeyboardLayout() != null) {
        _writer.writeElement(VNC_KEYBOARD_LAYOUT, vmBase.getVncKeyboardLayout());
    }
    _writer.writeElement(MIN_ALLOCATED_MEMORY, String.valueOf(vmBase.getMinAllocatedMem()));
    _writer.writeElement(IS_STATELESS, String.valueOf(vmBase.isStateless()));
    _writer.writeElement(IS_RUN_AND_PAUSE, String.valueOf(vmBase.isRunAndPause()));
    _writer.writeElement(AUTO_STARTUP, String.valueOf(vmBase.isAutoStartup()));
    _writer.writeElement(PRIORITY, String.valueOf(vmBase.getPriority()));
    if (vmBase.getCreatedByUserId() != null) {
        _writer.writeElement(CREATED_BY_USER_ID, String.valueOf(vmBase.getCreatedByUserId()));
    }
    if (vmBase.getMigrationDowntime() != null) {
        _writer.writeElement(MIGRATION_DOWNTIME, String.valueOf(vmBase.getMigrationDowntime()));
    }
    writeVmInit();
    if (vmBase.getMigrationSupport() != null) {
        _writer.writeElement(MIGRATION_SUPPORT, String.valueOf(vmBase.getMigrationSupport().getValue()));
    }
    // TODO dedicated to multiple hosts - are we breaking any standard here?
    vmBase.getDedicatedVmForVdsList().forEach(d -> _writer.writeElement(DEDICATED_VM_FOR_VDS, String.valueOf(d)));
    if (vmBase.getSerialNumberPolicy() != null) {
        _writer.writeElement(SERIAL_NUMBER_POLICY, String.valueOf(vmBase.getSerialNumberPolicy().getValue()));
    }
    if (vmBase.getCustomSerialNumber() != null) {
        _writer.writeElement(CUSTOM_SERIAL_NUMBER, vmBase.getCustomSerialNumber());
    }
    _writer.writeElement(IS_BOOT_MENU_ENABLED, String.valueOf(vmBase.isBootMenuEnabled()));
    _writer.writeElement(IS_SPICE_FILE_TRANSFER_ENABLED, String.valueOf(vmBase.isSpiceFileTransferEnabled()));
    _writer.writeElement(IS_SPICE_COPY_PASTE_ENABLED, String.valueOf(vmBase.isSpiceCopyPasteEnabled()));
    _writer.writeElement(ALLOW_CONSOLE_RECONNECT, String.valueOf(vmBase.isAllowConsoleReconnect()));
    _writer.writeElement(CONSOLE_DISCONNECT_ACTION, String.valueOf(vmBase.getConsoleDisconnectAction()));
    if (vmBase.getAutoConverge() != null) {
        _writer.writeElement(IS_AUTO_CONVERGE, String.valueOf(vmBase.getAutoConverge()));
    }
    if (vmBase.getMigrateCompressed() != null) {
        _writer.writeElement(IS_MIGRATE_COMPRESSED, String.valueOf(vmBase.getMigrateCompressed()));
    }
    if (vmBase.getMigrationPolicyId() != null) {
        _writer.writeElement(MIGRATION_POLICY_ID, String.valueOf(vmBase.getMigrationPolicyId()));
    }
    writeCustomEmulatedMachine();
    _writer.writeElement(BIOS_TYPE, String.valueOf(vmBase.getBiosType().getValue()));
    writeCustomCpuName();
    _writer.writeElement(PREDEFINED_PROPERTIES, vmBase.getPredefinedProperties());
    _writer.writeElement(USER_DEFINED_PROPERTIES, vmBase.getUserDefinedProperties());
    _writer.writeElement(MAX_MEMORY_SIZE_MB, String.valueOf(vmBase.getMaxMemorySizeMb()));
    if (vmBase.getLeaseStorageDomainId() != null) {
        _writer.writeElement(VM_LEASE, vmBase.getLeaseStorageDomainId().toString());
    }
    _writer.writeElement(MULTI_QUEUES_ENABLED, String.valueOf(vmBase.isMultiQueuesEnabled()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setType(getParameters().getTransferType());
    entity.setActive(false);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(getParameters().getTransferSize());
    entity.setClientInactivityTimeout(getParameters().getClientInactivityTimeout() != null ? getParameters().getClientInactivityTimeout() : getTransferImageClientInactivityTimeoutInSeconds());
    imageTransferDao.save(entity);
    if (isImageProvided()) {
        handleImageIsReadyForTransfer();
    } else {
        if (getParameters().getTransferType() == TransferType.Download) {
            failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
            setSucceeded(false);
            return;
        }
        log.info("Creating {} image", getImageType());
        createImage();
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setType(getParameters().getTransferType());
    entity.setActive(false);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(isImageProvided() ? getTransferSize() : getParameters().getTransferSize());
    entity.setClientInactivityTimeout(getParameters().getClientInactivityTimeout() != null ? getParameters().getClientInactivityTimeout() : getTransferImageClientInactivityTimeoutInSeconds());
    imageTransferDao.save(entity);
    if (isImageProvided()) {
        handleImageIsReadyForTransfer();
    } else {
        if (getParameters().getTransferType() == TransferType.Download) {
            failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
            setSucceeded(false);
            return;
        }
        log.info("Creating {} image", getImageType());
        createImage();
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#end_block

#method_before
protected void handleImageIsReadyForTransfer() {
    DiskImage image = getDiskImage();
    Guid domainId = image.getStorageIds().get(0);
    getParameters().setStorageDomainId(domainId);
    getParameters().setDestinationImageId(image.getImageId());
    // ovirt-imageio-daemon must know the boundaries of the target image for writing permissions.
    getParameters().setTransferSize(getTransferSize(image, domainId));
    persistCommand(getParameters().getParentCommand(), true);
    setImage(image);
    setStorageDomainId(domainId);
    log.info("Successfully added {} for image transfer command '{}'", getTransferDescription(), getCommandId());
    // ImageGroup is empty when downloading a disk snapshot
    if (!Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        ImageTransfer updates = new ImageTransfer();
        updates.setDiskId(getParameters().getImageGroupID());
        updateEntity(updates);
    }
    // The image will remain locked until the transfer command has completed.
    lockImage();
    startImageTransferSession();
    log.info("Returning from proceedCommandExecution after starting transfer session" + " for image transfer command '{}'", getCommandId());
    resetPeriodicPauseLogTime(0);
}
#method_after
protected void handleImageIsReadyForTransfer() {
    DiskImage image = getDiskImage();
    Guid domainId = image.getStorageIds().get(0);
    getParameters().setStorageDomainId(domainId);
    getParameters().setDestinationImageId(image.getImageId());
    // ovirt-imageio-daemon must know the boundaries of the target image for writing permissions.
    getParameters().setTransferSize(getTransferSize());
    persistCommand(getParameters().getParentCommand(), true);
    setImage(image);
    setStorageDomainId(domainId);
    log.info("Successfully added {} for image transfer command '{}'", getTransferDescription(), getCommandId());
    // ImageGroup is empty when downloading a disk snapshot
    if (!Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        ImageTransfer updates = new ImageTransfer();
        updates.setDiskId(getParameters().getImageGroupID());
        updateEntity(updates);
    }
    // The image will remain locked until the transfer command has completed.
    lockImage();
    startImageTransferSession();
    log.info("Returning from proceedCommandExecution after starting transfer session" + " for image transfer command '{}'", getCommandId());
    resetPeriodicPauseLogTime(0);
}
#end_block

#method_before
private long getTransferSize(DiskImage image, Guid domainId) {
    if (getParameters().getTransferType() == TransferType.Download) {
        DiskImage imageInfoFromVdsm = imagesHandler.getVolumeInfoFromVdsm(image.getStoragePoolId(), domainId, image.getId(), image.getImageId());
        return imageInfoFromVdsm.getVolumeFormat() == VolumeFormat.COW ? imageInfoFromVdsm.getApparentSizeInBytes() : imageInfoFromVdsm.getActualSizeInBytes();
    }
    // Upload
    if (getParameters().getTransferSize() != 0) {
        // TransferSize is only set by the webadmin
        return getParameters().getTransferSize();
    }
    boolean isBlockDomain = getDiskImage().getStorageTypes().get(0).isBlockDomain();
    return isBlockDomain ? getDiskImage().getActualSizeInBytes() : getDiskImage().getSize();
}
#method_after
private long getTransferSize() {
    DiskImage image = getDiskImage();
    Guid domainId = image.getStorageIds().get(0);
    if (getParameters().getTransferType() == TransferType.Download) {
        if (image.getVolumeFormat() == VolumeFormat.COW) {
            DiskImage imageInfoFromVdsm = imagesHandler.getVolumeInfoFromVdsm(image.getStoragePoolId(), domainId, image.getId(), image.getImageId());
            return imageInfoFromVdsm.getApparentSizeInBytes();
        } else {
            // RAW
            return image.getSize();
        }
    }
    // Upload
    if (getParameters().getTransferSize() != 0) {
        // TransferSize is only set by the webadmin
        return getParameters().getTransferSize();
    }
    boolean isBlockDomain = getDiskImage().getStorageTypes().get(0).isBlockDomain();
    return isBlockDomain ? getDiskImage().getActualSizeInBytes() : image.getSize();
}
#end_block

#method_before
private void proceedDisappearedVm() {
    if (System.nanoTime() - getVmManager().getPowerOffTimeout() < 0) {
        auditVmOnDownNormal(true);
        clearVm(VmExitStatus.Normal, getPowerOffExitMessage(), VmExitReason.Success);
        resourceManager.removeAsyncRunningVm(dbVm.getId());
        return;
    }
    switch(dbVm.getStatus()) {
        case MigratingFrom:
            if (dbVm.getMigratingToVds() != null) {
                handOverVm();
                break;
            }
            abortVmMigration(VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", getVmManager().getName()), VmExitReason.GenericError);
            break;
        case PoweringDown:
            clearVm(VmExitStatus.Normal, String.format("VM %s shutdown complete", getVmManager().getName()), VmExitReason.Success);
            // not sure about that..
            if (getVmManager().isColdReboot()) {
                setColdRebootFlag();
            }
            break;
        default:
            clearVm(VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", getVmManager().getName()), VmExitReason.GenericError);
            if (resourceManager.isVmInAsyncRunningList(dbVm.getId())) {
                setRerunFlag();
                break;
            }
            if (getVmManager().isColdReboot()) {
                setColdRebootFlag();
                break;
            }
            if (getVmManager().isAutoStart()) {
                setAutoRunFlag();
                break;
            }
    }
}
#method_after
private void proceedDisappearedVm() {
    if (System.nanoTime() - getVmManager().getPowerOffTimeout() < 0) {
        auditVmOnDownNormal(true);
        resourceManager.removeAsyncRunningVm(dbVm.getId());
        clearVm(VmExitStatus.Normal, getPowerOffExitMessage(), VmExitReason.Success);
        return;
    }
    switch(dbVm.getStatus()) {
        case MigratingFrom:
            if (dbVm.getMigratingToVds() != null) {
                handOverVm();
                break;
            }
            abortVmMigration(VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", getVmManager().getName()), VmExitReason.GenericError);
            break;
        case PoweringDown:
            clearVm(VmExitStatus.Normal, String.format("VM %s shutdown complete", getVmManager().getName()), VmExitReason.Success);
            // not sure about that..
            if (getVmManager().isColdReboot()) {
                setColdRebootFlag();
            }
            break;
        default:
            clearVm(VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", getVmManager().getName()), VmExitReason.GenericError);
            if (resourceManager.isVmInAsyncRunningList(dbVm.getId())) {
                setRerunFlag();
                break;
            }
            if (getVmManager().isColdReboot()) {
                setColdRebootFlag();
                break;
            }
            if (getVmManager().isAutoStart()) {
                setAutoRunFlag();
                break;
            }
    }
}
#end_block

#method_before
private void cleanup() {
    // Clean myself up.
    clickRegistration.removeHandler();
    ToastNotification.this.removeFromParent();
    if (container.getWidgetCount() == 0) {
        container.setVisible(false);
    }
}
#method_after
private void cleanup() {
    // Clean myself up.
    clickRegistration.removeHandler();
    removeFromContainer(this);
}
#end_block

#method_before
public static ToastNotification createNotification(String text, NotificationStatus status) {
    ToastNotification result = new ToastNotification(text);
    result.setStatus(status);
    container.addStyleName(result.getStyle().container());
    container.add(result);
    container.setVisible(true);
    return result;
}
#method_after
public static ToastNotification createNotification(String text, NotificationStatus status) {
    ToastNotification toast = new ToastNotification(text, status);
    addToContainer(toast);
    return toast;
}
#end_block

#method_before
@Override
public void edit(final IscsiStorageModel object) {
    driver.edit(object);
    initLists(object);
    // Add event handlers
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        String propName = args.propertyName;
        if (propName.equals("IsValid")) {
            // $NON-NLS-1$
            onIsValidPropertyChange(object);
        } else if (propName.equals("IsGroupedByTarget")) {
            // $NON-NLS-1$
            updateListByGrouping(object);
        }
    });
    // Edit sub-views
    iscsiTargetToLunView.edit(object);
    iscsiLunToTargetView.edit(object);
    // Add click handlers
    targetsToLunTab.addClickHandler(event -> {
        iscsiLunToTargetView.disableItemsUpdate();
        object.setIsGroupedByTarget(true);
    });
    lunToTargetsTab.addClickHandler(event -> {
        iscsiTargetToLunView.disableItemsUpdate();
        object.setIsGroupedByTarget(false);
    });
    // Update selected tab and list
    dialogTabPanel.switchTab(object.getIsGroupedByTarget() ? targetsToLunTab : lunToTargetsTab);
    updateListByGrouping(object);
    // Set labels above table
    if (!object.getContainer().isNewStorage()) {
        switch(object.getContainer().getStorage().getStatus()) {
            case Maintenance:
                mainLabel.setText(constants.storageIscsiRemoveLUNsLabel());
                subLabel.setText(constants.storageIscsiAvailableActionsOnMaintenanceLabel());
                break;
            case Active:
                mainLabel.setText(constants.storageIscsiActionsLabel());
                subLabel.setText(constants.storageIscsiAvailableActionsForActiveDomainsLabel());
                break;
        }
    }
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        String propName = args.propertyName;
        if (propName.equals("SelectedLunWarning")) {
            // $NON-NLS-1$
            String warningText = object.getSelectedLunWarning();
            warning.setText(warningText);
            warning.setVisible(!StringHelper.isNullOrEmpty(warningText));
        }
    });
}
#method_after
@Override
public void edit(final IscsiStorageModel object) {
    driver.edit(object);
    initLists(object);
    // Add event handlers
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        String propName = args.propertyName;
        if (propName.equals("IsValid")) {
            // $NON-NLS-1$
            onIsValidPropertyChange(object);
        } else if (propName.equals("IsGroupedByTarget")) {
            // $NON-NLS-1$
            updateListByGrouping(object);
        }
    });
    // Edit sub-views
    iscsiTargetToLunView.edit(object);
    iscsiLunToTargetView.edit(object);
    // Add click handlers
    targetsToLunTab.addClickHandler(event -> {
        iscsiLunToTargetView.disableItemsUpdate();
        object.setIsGroupedByTarget(true);
    });
    lunToTargetsTab.addClickHandler(event -> {
        iscsiTargetToLunView.disableItemsUpdate();
        object.setIsGroupedByTarget(false);
    });
    // Update selected tab and list
    dialogTabPanel.switchTab(object.getIsGroupedByTarget() ? targetsToLunTab : lunToTargetsTab);
    updateListByGrouping(object);
    // Set labels above table
    if (!object.getContainer().isNewStorage()) {
        switch(object.getContainer().getStorage().getStatus()) {
            case Maintenance:
                mainLabel.setText(constants.storageIscsiRemoveLUNsLabel());
                subLabel.setText(constants.storageIscsiAvailableActionsOnMaintenanceLabel());
                break;
            case Active:
                mainLabel.setText(constants.storageIscsiActionsLabel());
                subLabel.setText(constants.storageIscsiAvailableActionsForActiveDomainsLabel());
                break;
        }
    }
    if (object.getContainer().isNewStorage()) {
        dialogTabPanel.setBarStyle(multiSelection ? style.barNewDomain() : style.barNewDisk());
    } else {
        dialogTabPanel.setBarStyle(style.barEditDomain());
    }
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        String propName = args.propertyName;
        if (propName.equals("SelectedLunWarning")) {
            // $NON-NLS-1$
            String warningText = object.getSelectedLunWarning();
            warning.clearMessages();
            warning.setType(AlertPanel.Type.WARNING);
            warning.addMessage(SafeHtmlUtils.fromString(warningText));
            warning.setVisible(!StringHelper.isNullOrEmpty(warningText));
        }
    });
}
#end_block

#method_before
@Override
public void edit(final IscsiStorageModel object) {
    driver.edit(object);
    initLists(object);
    // Add event handlers
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        String propName = args.propertyName;
        if (propName.equals("IsValid")) {
            // $NON-NLS-1$
            onIsValidPropertyChange(object);
        } else if (propName.equals("IsGroupedByTarget")) {
            // $NON-NLS-1$
            updateListByGrouping(object);
        }
    });
    // Edit sub-views
    iscsiTargetToLunView.edit(object);
    iscsiLunToTargetView.edit(object);
    // Add click handlers
    targetsToLunTab.addClickHandler(event -> {
        iscsiLunToTargetView.disableItemsUpdate();
        object.setIsGroupedByTarget(true);
    });
    lunToTargetsTab.addClickHandler(event -> {
        iscsiTargetToLunView.disableItemsUpdate();
        object.setIsGroupedByTarget(false);
    });
    // Update selected tab and list
    dialogTabPanel.switchTab(object.getIsGroupedByTarget() ? targetsToLunTab : lunToTargetsTab);
    updateListByGrouping(object);
    // Set labels above table
    if (!object.getContainer().isNewStorage()) {
        switch(object.getContainer().getStorage().getStatus()) {
            case Maintenance:
                mainLabel.setText(constants.storageIscsiRemoveLUNsLabel());
                subLabel.setText(constants.storageIscsiAvailableActionsOnMaintenanceLabel());
                break;
            case Active:
                mainLabel.setText(constants.storageIscsiActionsLabel());
                subLabel.setText(constants.storageIscsiAvailableActionsForActiveDomainsLabel());
                break;
        }
    }
    dialogTabPanel.setBarStyle(object.getContainer().isNewStorage() ? (!multiSelection ? style.barNewDisk() : style.barShort()) : style.barLong());
}
#method_after
@Override
public void edit(final IscsiStorageModel object) {
    driver.edit(object);
    initLists(object);
    // Add event handlers
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        String propName = args.propertyName;
        if (propName.equals("IsValid")) {
            // $NON-NLS-1$
            onIsValidPropertyChange(object);
        } else if (propName.equals("IsGroupedByTarget")) {
            // $NON-NLS-1$
            updateListByGrouping(object);
        }
    });
    // Edit sub-views
    iscsiTargetToLunView.edit(object);
    iscsiLunToTargetView.edit(object);
    // Add click handlers
    targetsToLunTab.addClickHandler(event -> {
        iscsiLunToTargetView.disableItemsUpdate();
        object.setIsGroupedByTarget(true);
    });
    lunToTargetsTab.addClickHandler(event -> {
        iscsiTargetToLunView.disableItemsUpdate();
        object.setIsGroupedByTarget(false);
    });
    // Update selected tab and list
    dialogTabPanel.switchTab(object.getIsGroupedByTarget() ? targetsToLunTab : lunToTargetsTab);
    updateListByGrouping(object);
    // Set labels above table
    if (!object.getContainer().isNewStorage()) {
        switch(object.getContainer().getStorage().getStatus()) {
            case Maintenance:
                mainLabel.setText(constants.storageIscsiRemoveLUNsLabel());
                subLabel.setText(constants.storageIscsiAvailableActionsOnMaintenanceLabel());
                break;
            case Active:
                mainLabel.setText(constants.storageIscsiActionsLabel());
                subLabel.setText(constants.storageIscsiAvailableActionsForActiveDomainsLabel());
                break;
        }
    }
    if (object.getContainer().isNewStorage()) {
        dialogTabPanel.setBarStyle(multiSelection ? style.barNewDomain() : style.barNewDisk());
    } else {
        dialogTabPanel.setBarStyle(style.barEditDomain());
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<Disk> allDisks = diskDao.getAllFromDisksIncludingSnapshotsByDiskId(getParameters().getId(), getUserID(), getParameters().isFiltered());
    // In case of LUN disk
    if (allDisks.size() == 1 && allDisks.get(0).getDiskStorageType() == DiskStorageType.LUN) {
        getQueryReturnValue().setReturnValue(allDisks.get(0));
        return;
    }
    DiskImage diskWithSnapshots = imagesHandler.aggregateDiskImagesSnapshots(allDisks.stream().map(DiskImage.class::cast).collect(Collectors.toList())).stream().findFirst().orElse(null);
    getQueryReturnValue().setReturnValue(diskWithSnapshots);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<Disk> allDisks = diskDao.getAllFromDisksIncludingSnapshotsByDiskId(getParameters().getId(), getUserID(), getParameters().isFiltered());
    // In case of LUN disk
    if (allDisks.size() == 1 && allDisks.get(0).getDiskStorageType() == DiskStorageType.LUN) {
        getQueryReturnValue().setReturnValue(allDisks.get(0));
        return;
    }
    // In case of disk without snapshots still need to aggregate the disk with its base image
    DiskImage diskWithSnapshots = imagesHandler.aggregateDiskImagesSnapshots(allDisks.stream().map(DiskImage.class::cast).collect(Collectors.toList())).stream().findFirst().orElse(null);
    getQueryReturnValue().setReturnValue(diskWithSnapshots);
}
#end_block

#method_before
private void filterNonRequiredNetworks(List<Network> networks, List<Network> selected) {
    AsyncDataProvider.getInstance().getNetworkClustersByDataCenterId(new AsyncQuery<>(networkClusters -> {
        List<Network> filteredNetworks = networks.stream().filter(network -> {
            // Filter non-required networks
            List<NetworkCluster> clusters = networkClusters.stream().filter(networkCluster -> networkCluster.getNetworkId().equals(network.getId())).collect(Collectors.toList());
            return clusters.stream().noneMatch(NetworkCluster::isRequired);
        }).collect(Collectors.toList());
        getNetworks().setItems(filteredNetworks);
        getNetworks().setSelectedItems(selected);
    }), getStoragePool().getId());
}
#method_after
private void filterNonRequiredNetworks(List<Network> networks, List<Network> selected) {
    AsyncDataProvider.getInstance().getRequiredNetworksByDataCenterId(new AsyncQuery<>(reqNetworks -> {
        // Filter non-required networks
        networks.removeAll(reqNetworks);
        getNetworks().setItems(networks);
        getNetworks().setSelectedItems(selected);
    }), getStoragePool().getId());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getParameters().getIds().stream().map(id -> diskImageDao.getAncestor(id, getUserID(), getParameters().isFiltered())).collect(Collectors.toSet()));
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getParameters().getIds().stream().collect(Collectors.toMap(Function.identity(), id -> diskImageDao.getAncestor(id, getUserID(), getParameters().isFiltered()))));
}
#end_block

#method_before
private void executeNextOperation() {
    if (getParameters().getPhase() == StorageDomainParametersBase.Phase.PROCESS_OVF_UPDATE_FOR_STORAGE_DOMAIN) {
        ActionReturnValue returnValue = runInternalActionWithTasksContext(ActionType.ProcessOvfUpdateForStorageDomain, createProcessOvfUpdateForDomainParams());
        if (!returnValue.getSucceeded()) {
            propagateFailure(returnValue);
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(true);
            throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
        }
        setCommandStatus(CommandStatus.SUCCEEDED);
        setSucceeded(true);
    }
}
#method_after
private void executeNextOperation() {
    if (getParameters().getPhase() == StorageDomainParametersBase.Phase.PROCESS_OVF_UPDATE_FOR_STORAGE_DOMAIN) {
        ActionReturnValue returnValue = runInternalActionWithTasksContext(ActionType.ProcessOvfUpdateForStorageDomain, createProcessOvfUpdateForDomainParams());
        if (!returnValue.getSucceeded()) {
            propagateFailure(returnValue);
            setCommandStatus(CommandStatus.FAILED);
            throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
        }
        setCommandStatus(CommandStatus.SUCCEEDED);
        setSucceeded(true);
    }
}
#end_block

#method_before
protected boolean amendDiskRequested() {
    // if the updated disk is the base snapshot, no amend operation needed
    if (getNewDisk().getDiskStorageType() == DiskStorageType.IMAGE && !(getNewDisk().isDiskSnapshot() && ((DiskImage) getNewDisk()).getImage().getVolumeFormat() == VolumeFormat.RAW)) {
        QcowCompat qcowCompat = ((DiskImage) getNewDisk()).getQcowCompat();
        return getDiskImages(getOldDisk().getId()).stream().anyMatch(disk -> disk.isQcowFormat() && disk.getQcowCompat() != qcowCompat);
    }
    return false;
}
#method_after
protected boolean amendDiskRequested() {
    // if the updated disk is the base snapshot, no amend operation needed;
    if (getNewDisk().getDiskStorageType() == DiskStorageType.IMAGE && !isBaseSnapshotDisk()) {
        QcowCompat qcowCompat = ((DiskImage) getNewDisk()).getQcowCompat();
        return getDiskImages(getOldDisk().getId()).stream().anyMatch(disk -> disk.isQcowFormat() && disk.getQcowCompat() != qcowCompat);
    }
    return false;
}
#end_block

#method_before
private void addCheckBoxColumn(boolean hideCheckbox, boolean showSelectAllCheckbox) {
    if (!hideCheckbox) {
        // Add selection column
        Column<EntityModel, Boolean> checkColumn = null;
        if (getSelectionModel() instanceof SingleSelectionModel) {
            checkColumn = new Column<EntityModel, Boolean>(new RadioboxCell(true, false)) {

                @Override
                public Boolean getValue(EntityModel object) {
                    return getSelectionModel().isSelected(object);
                }
            };
            addColumn(checkColumn, SafeHtmlUtils.fromSafeConstant(constants.htmlNonBreakingSpace()));
        } else if (getSelectionModel() instanceof MultiSelectionModel) {
            checkColumn = new Column<EntityModel, Boolean>(new CheckboxCell(true, false)) {

                @Override
                public Boolean getValue(EntityModel object) {
                    return getSelectionModel().isSelected(object);
                }
            };
            if (showSelectAllCheckbox) {
                AbstractSelectAllCheckBoxHeader<EntityModel> selectAllHeader = new AbstractSelectAllCheckBoxHeader<EntityModel>() {

                    @Override
                    protected void selectionChanged(Boolean value) {
                        if (getListModel() == null || getListModel().getItems() == null) {
                            return;
                        }
                        handleSelection(value, getListModel(), getSelectionModel());
                    }

                    @Override
                    public Boolean getValue() {
                        if (getListModel() == null || getListModel().getItems() == null) {
                            return false;
                        }
                        return getCheckValue(getListModel().getItems(), getSelectionModel());
                    }
                };
                addColumn(checkColumn, selectAllHeader);
            } else {
                addColumn(checkColumn, SafeHtmlUtils.fromSafeConstant(constants.htmlNonBreakingSpace()));
            }
        }
        if (checkColumn != null) {
            setColumnWidth(checkColumn, CHECK_COLUMN_WIDTH, Unit.PX);
            selectionColumnPresent = true;
        }
        addCellPreviewHandler(event -> {
            int columnIndex = event.getColumn();
            Cell<?> cell = getColumn(columnIndex).getCell();
            if (cell instanceof EventHandlingCell && ((EventHandlingCell) cell).handlesEvent(event)) {
                return;
            }
            if (BrowserEvents.CLICK.equals(event.getNativeEvent().getType()) && !(getSelectionModel() instanceof NoSelectionModel)) {
                // Let the selection column deal with this
                if (event.getColumn() == 0) {
                    return;
                }
                if (getSelectionModel() instanceof MultiSelectionModel) {
                    getSelectionModel().setSelected(event.getValue(), !getSelectionModel().isSelected(event.getValue()));
                }
                if (getSelectionModel() instanceof SingleSelectionModel) {
                    getSelectionModel().setSelected(event.getValue(), true);
                }
            }
        });
    }
}
#method_after
private void addCheckBoxColumn(boolean hideCheckbox, boolean showSelectAllCheckbox) {
    if (!hideCheckbox) {
        // Add selection column
        Column<EntityModel, Boolean> checkColumn = null;
        if (getSelectionModel() instanceof SingleSelectionModel) {
            checkColumn = new Column<EntityModel, Boolean>(new RadioboxCell(true, false)) {

                @Override
                public Boolean getValue(EntityModel object) {
                    return getSelectionModel().isSelected(object);
                }
            };
            addColumn(checkColumn, SafeHtmlUtils.fromSafeConstant(constants.htmlNonBreakingSpace()));
        } else if (getSelectionModel() instanceof MultiSelectionModel) {
            checkColumn = new Column<EntityModel, Boolean>(new CheckboxCell(true, false)) {

                @Override
                public Boolean getValue(EntityModel object) {
                    return getSelectionModel().isSelected(object);
                }
            };
            if (showSelectAllCheckbox) {
                AbstractSelectAllCheckBoxHeader<EntityModel> selectAllHeader = new AbstractSelectAllCheckBoxHeader<EntityModel>() {

                    @Override
                    protected void selectionChanged(Boolean value) {
                        if (getListModel() == null || getListModel().getItems() == null) {
                            return;
                        }
                        handleSelection(value, getListModel(), getSelectionModel());
                    }

                    @Override
                    public Boolean getValue() {
                        if (getListModel() == null || getListModel().getItems() == null) {
                            return false;
                        }
                        return getCheckValue(getListModel().getItems(), getSelectionModel());
                    }
                };
                addColumn(checkColumn, selectAllHeader);
            } else {
                addColumn(checkColumn, SafeHtmlUtils.fromSafeConstant(constants.htmlNonBreakingSpace()));
            }
        }
        if (checkColumn != null) {
            setColumnWidth(checkColumn, CHECK_COLUMN_WIDTH, Unit.PX);
            selectionColumnPresent = true;
        }
        addCellPreviewHandler(event -> {
            int columnIndex = event.getColumn();
            Cell<?> cell = getColumn(columnIndex).getCell();
            if (cell instanceof EventHandlingCell && ((EventHandlingCell) cell).handlesEvent(event)) {
                return;
            }
            if (BrowserEvents.CLICK.equals(event.getNativeEvent().getType()) && !(getSelectionModel() instanceof NoSelectionModel)) {
                // Let the selection column deal with this
                if (event.getColumn() == 0) {
                    return;
                }
                if (getSelectionModel() instanceof MultiSelectionModel) {
                    getSelectionModel().setSelected(event.getValue(), !getSelectionModel().isSelected(event.getValue()));
                } else if (getSelectionModel() instanceof SingleSelectionModel) {
                    // Setting the value only here is fine as we clear all the values in the selection change
                    // handler
                    getSelectionModel().setSelected(event.getValue(), true);
                }
            }
        });
    }
}
#end_block

#method_before
@Override
public Response addFromVmSnapshot(Template template) {
    validateIconParameters(template);
    validateSnapshotExistence(template.getVm());
    String snapshotId = getSnapshotId(template.getVm().getSnapshots());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getVmConfiguration(snapshotId);
    Guid clusterId = null;
    if (namedCluster(template)) {
        clusterId = getClusterId(template);
    }
    if (template.getVersion() != null) {
        validateParameters(template.getVersion(), "baseTemplate");
    }
    VmStatic originalVm = vmConfiguration.getStaticData();
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, originalVm);
    if (namedCluster(template)) {
        staticVm.setClusterId(clusterId);
    }
    AddVmTemplateFromSnapshotParameters params = new AddVmTemplateFromSnapshotParameters(staticVm, template.getName(), template.getDescription(), Guid.createGuidFromString(snapshotId));
    return addTemplate(template, originalVm, vmConfiguration.getDiskMap().keySet(), params, ActionType.AddVmTemplateFromSnapshot);
}
#method_after
@Override
public Response addFromVmSnapshot(Template template) {
    validateIconParameters(template);
    validateSnapshotExistence(template.getVm());
    Guid snapshotId = getSnapshotId(template.getVm().getSnapshots());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getVmConfiguration(snapshotId);
    if (template.getVersion() != null) {
        validateParameters(template.getVersion(), "baseTemplate");
    }
    VmStatic originalVm = vmConfiguration.getStaticData();
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, originalVm);
    if (namedCluster(template)) {
        Guid clusterId = getClusterId(template);
        staticVm.setClusterId(clusterId);
    }
    AddVmTemplateFromSnapshotParameters params = new AddVmTemplateFromSnapshotParameters(staticVm, template.getName(), template.getDescription(), snapshotId);
    return addTemplate(template, originalVm, vmConfiguration.getDiskMap().keySet(), params, ActionType.AddVmTemplateFromSnapshot);
}
#end_block

#method_before
private Response addTemplate(Template template, VmStatic originalVm, Set<Guid> snapshotDisksIds, AddVmTemplateParameters params, ActionType actionType) {
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    if (template.getVersion() != null) {
        params.setBaseTemplateId(Guid.createGuidFromString(template.getVersion().getBaseTemplate().getId()));
        params.setTemplateVersionName(template.getVersion().getVersionName());
    }
    params.setConsoleEnabled(template.getConsole() != null && template.getConsole().isSetEnabled() ? template.getConsole().isEnabled() : !getConsoleDevicesForEntity(originalVm.getId()).isEmpty());
    params.setVirtioScsiEnabled(template.isSetVirtioScsi() && template.getVirtioScsi().isSetEnabled() ? template.getVirtioScsi().isEnabled() : null);
    params.setSoundDeviceEnabled(template.isSetSoundcardEnabled() ? template.isSoundcardEnabled() : !VmHelper.getSoundDevicesForEntity(this, originalVm.getId()).isEmpty());
    if (template.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(template.getRngDevice(), null));
    }
    DisplayHelper.setGraphicsToParams(template.getDisplay(), params);
    boolean domainSet = template.isSetStorageDomain() && template.getStorageDomain().isSetId();
    if (domainSet) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
    }
    params.setDiskInfoDestinationMap(getDestinationTemplateDiskMap(template.getVm(), originalVm.getId(), params.getDestinationStorageDomainId(), domainSet, snapshotDisksIds));
    setupOptionalParameters(params);
    IconHelper.setIconToParams(template, params);
    Response response = performCreate(actionType, params, new QueryIdResolver<Guid>(QueryType.GetVmTemplate, GetVmTemplateParameters.class));
    Template result = (Template) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
    }
    return response;
}
#method_after
private Response addTemplate(Template template, VmStatic originalVm, Set<Guid> snapshotDisksIds, AddVmTemplateParameters params, ActionType actionType) {
    if (template.getVersion() != null) {
        params.setBaseTemplateId(Guid.createGuidFromString(template.getVersion().getBaseTemplate().getId()));
        params.setTemplateVersionName(template.getVersion().getVersionName());
    }
    params.setConsoleEnabled(template.getConsole() != null && template.getConsole().isSetEnabled() ? template.getConsole().isEnabled() : !getConsoleDevicesForEntity(originalVm.getId()).isEmpty());
    params.setVirtioScsiEnabled(template.isSetVirtioScsi() && template.getVirtioScsi().isSetEnabled() ? template.getVirtioScsi().isEnabled() : null);
    params.setSoundDeviceEnabled(template.isSetSoundcardEnabled() ? template.isSoundcardEnabled() : !VmHelper.getSoundDevicesForEntity(this, originalVm.getId()).isEmpty());
    if (template.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(template.getRngDevice(), null));
    }
    DisplayHelper.setGraphicsToParams(template.getDisplay(), params);
    boolean domainSet = template.isSetStorageDomain() && template.getStorageDomain().isSetId();
    if (domainSet) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
    }
    params.setDiskInfoDestinationMap(getDestinationTemplateDiskMap(template.getVm(), originalVm.getId(), params.getDestinationStorageDomainId(), domainSet, snapshotDisksIds));
    setupOptionalParameters(params);
    IconHelper.setIconToParams(template, params);
    Response response = performCreate(actionType, params, new QueryIdResolver<Guid>(QueryType.GetVmTemplate, GetVmTemplateParameters.class));
    Template result = (Template) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
    }
    return response;
}
#end_block

#method_before
private void validateSnapshotExistence(Vm vm) {
    // null and emptiness were previously tested
    Snapshot snapshot = vm.getSnapshots().getSnapshots().get(0);
    validateParameters(snapshot, "id");
}
#method_after
private void validateSnapshotExistence(Vm vm) {
    Snapshot snapshot = vm.getSnapshots().getSnapshots().get(0);
    validateParameters(snapshot, "id");
}
#end_block

#method_before
private String getSnapshotId(Snapshots snapshots) {
    return (snapshots.getSnapshots() != null && !snapshots.getSnapshots().isEmpty()) ? snapshots.getSnapshots().get(0).getId() : Guid.Empty.toString();
}
#method_after
private Guid getSnapshotId(Snapshots snapshots) {
    return asGuid(snapshots.getSnapshots().get(0).getId());
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VM getVmConfiguration(String snapshotId) {
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, QueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(asGuid(snapshotId)), "");
    return vmConfiguration;
}
#method_after
private org.ovirt.engine.core.common.businessentities.VM getVmConfiguration(Guid snapshotId) {
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, QueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotId), "");
    return vmConfiguration;
}
#end_block

#method_before
@Override
public Response addFromConfiguration(Template template) {
    Initialization initialization = template.getInitialization();
    Configuration config = initialization.getConfiguration();
    org.ovirt.engine.core.common.businessentities.VmTemplate templateConfiguration = getEntity(org.ovirt.engine.core.common.businessentities.VmTemplate.class, QueryType.GetVmTemplateFromConfiguration, new GetVmFromConfigurationQueryParameters(VmMapper.map(config.getType(), null), config.getData().trim()), "");
    TemplateMapper.map(template, templateConfiguration);
    Guid clusterId = namedCluster(template) ? getClusterId(template) : asGuid(template.getCluster().getId());
    ImportVmTemplateFromConfParameters parameters = new ImportVmTemplateFromConfParameters();
    parameters.setVmTemplate(templateConfiguration);
    parameters.setClusterId(clusterId);
    if (initialization.isSetRegenerateIds()) {
        parameters.setImportAsNewEntity(initialization.isRegenerateIds());
    }
    return performCreate(ActionType.ImportVmTemplateFromConfiguration, parameters, new QueryIdResolver<Guid>(QueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#method_after
@Override
public Response addFromConfiguration(Template template) {
    Initialization initialization = template.getInitialization();
    Configuration config = initialization.getConfiguration();
    org.ovirt.engine.core.common.businessentities.VmTemplate templateConfiguration = getEntity(org.ovirt.engine.core.common.businessentities.VmTemplate.class, QueryType.GetVmTemplateFromConfiguration, new GetVmFromConfigurationQueryParameters(VmMapper.map(config.getType(), null), config.getData().trim()), "");
    // if configuration is provided, the initialization parameters cannot be overridden
    template.setInitialization(null);
    TemplateMapper.map(template, templateConfiguration);
    Guid clusterId = namedCluster(template) ? getClusterId(template) : asGuid(template.getCluster().getId());
    ImportVmTemplateFromConfParameters parameters = new ImportVmTemplateFromConfParameters();
    parameters.setVmTemplate(templateConfiguration);
    parameters.setClusterId(clusterId);
    if (initialization.isSetRegenerateIds()) {
        parameters.setImportAsNewEntity(initialization.isRegenerateIds());
    }
    return performCreate(ActionType.ImportVmTemplateFromConfiguration, parameters, new QueryIdResolver<Guid>(QueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#end_block

#method_before
public void attemptResolution() {
    Set<Guid> images;
    if (vmDynamicDao.get(getParameters().getVmId()).getStatus().isNotRunning()) {
        StoragePool pool = storagePoolDao.get(getParameters().getStoragePoolId());
        if (pool.getSpmVdsId() == null || pool.getStatus() != StoragePoolStatus.Up) {
            log.info("VM down, waiting on SPM election to resolve Live Merge");
            setSucceeded(true);
            return;
        } else {
            log.error("VM is not running, proceeding with Live Merge recovery");
            images = getVolumeChainFromRecovery();
        }
    } else {
        images = getVolumeChain();
    }
    if (images == null || images.isEmpty()) {
        log.error("Failed to retrieve images list of VM {}. Retrying ...", getParameters().getVmId());
        setCommandStatus(CommandStatus.SUCCEEDED);
        setSucceeded(true);
        // As this command is executed only during live merge flow, the following casting is safe.
        ((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters()).setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
        return;
    }
    Guid topImage = getParameters().getTopImage().getImageId();
    if (images.contains(topImage)) {
        log.error("Failed to live merge, still in volume chain: {}", topImage);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (!images.contains(getParameters().getBaseImage().getImageId())) {
        // If the base image isn't found in qemu chain, it means that the image was already deleted.
        // In this case, we will not allow PULL merge but rather ask the user to check if the parent
        // snapshot contains illegal volume(s). If so, that snapshot must be deleted before deleting
        // other snapshots
        addCustomValue("SnapshotName", snapshotDao.get(getParameters().getBaseImage().getSnapshotId()).getDescription());
        addCustomValue("BaseVolumeId", getParameters().getBaseImage().getImageId().toString());
        auditLog(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_BASE_IMAGE_NOT_FOUND);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    log.info("Successfully removed volume: {} from the chain", topImage);
    // For now, only COMMIT type is supported
    log.info("Volume merge type '{}'", VmBlockJobType.COMMIT.name());
    MergeStatusReturnValue returnValue = new MergeStatusReturnValue(VmBlockJobType.COMMIT, Collections.singleton(topImage));
    getReturnValue().setActionReturnValue(returnValue);
    setSucceeded(true);
    persistCommand(getParameters().getParentCommand(), true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#method_after
public void attemptResolution() {
    Set<Guid> images;
    if (vmDynamicDao.get(getParameters().getVmId()).getStatus().isNotRunning()) {
        StoragePool pool = storagePoolDao.get(getParameters().getStoragePoolId());
        if (pool.getSpmVdsId() == null || pool.getStatus() != StoragePoolStatus.Up) {
            log.info("VM down, waiting on SPM election to resolve Live Merge");
            setSucceeded(true);
            return;
        } else {
            log.error("VM is not running, proceeding with Live Merge recovery");
            images = getVolumeChainFromRecovery();
        }
    } else {
        images = getVolumeChain();
    }
    if (images == null || images.isEmpty()) {
        log.error("Failed to retrieve images list of VM {}. Retrying ...", getParameters().getVmId());
        setCommandStatus(CommandStatus.SUCCEEDED);
        setSucceeded(true);
        // As this command is executed only during live merge flow, the following casting is safe.
        ((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters()).setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
        return;
    }
    Guid topImage = getParameters().getTopImage().getImageId();
    if (images.contains(topImage)) {
        // If the top volume is found in qemu chain, it means that the top volume wasn't deleted,
        // thus we have to fail live merge, reporting that the top volume is still in the chain.
        log.error("Failed to live merge. Top volume {} is still in qemu chain {}", topImage, images);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (!images.contains(getParameters().getBaseImage().getImageId())) {
        // If the base image isn't found in qemu chain, it means that the image was already deleted.
        // In this case, we will not allow PULL merge but rather ask the user to check if the parent
        // snapshot contains illegal volume(s). If so, that snapshot must be deleted before deleting
        // other snapshots
        addCustomValue("SnapshotName", snapshotDao.get(getParameters().getBaseImage().getSnapshotId()).getDescription());
        addCustomValue("BaseVolumeId", getParameters().getBaseImage().getImageId().toString());
        auditLog(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_BASE_IMAGE_NOT_FOUND);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    log.info("Successfully removed volume {} from the chain", topImage);
    // For now, only COMMIT type is supported
    log.info("Volume merge type '{}'", VmBlockJobType.COMMIT.name());
    MergeStatusReturnValue returnValue = new MergeStatusReturnValue(VmBlockJobType.COMMIT, Collections.singleton(topImage));
    getReturnValue().setActionReturnValue(returnValue);
    setSucceeded(true);
    persistCommand(getParameters().getParentCommand(), true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#end_block

#method_before
protected ValidationResult validateIsoPath(VM vm, String diskPath, String floppyPath, Guid activeIsoDomainId) {
    if (vm.isAutoStartup()) {
        return ValidationResult.VALID;
    }
    if (StringUtils.isEmpty(vm.getIsoPath()) && StringUtils.isEmpty(diskPath) && StringUtils.isEmpty(floppyPath)) {
        return ValidationResult.VALID;
    }
    if (!StringUtils.isEmpty(floppyPath) && activeIsoDomainId == null) {
        return new ValidationResult(EngineMessage.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    String effectiveIsoPath = StringUtils.isEmpty(diskPath) ? vm.getIsoPath() : diskPath;
    if (!StringUtils.isEmpty(effectiveIsoPath)) {
        if (effectiveIsoPath.matches(ValidationUtils.GUID)) {
            BaseDisk disk = diskDao.get(Guid.createGuidFromString(effectiveIsoPath));
            if (disk == null || disk.getContentType() != DiskContentType.ISO) {
                return new ValidationResult(EngineMessage.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
            }
            if (((DiskImage) disk).getImageStatus() != ImageStatus.OK) {
                return new ValidationResult(EngineMessage.ERROR_ISO_IMAGE_STATUS_ILLEGAL, String.format("$status %s", ((DiskImage) disk).getImageStatus().toString()));
            }
            Guid domainId = ((DiskImage) disk).getStorageIds().get(0);
            StoragePoolIsoMap spim = storagePoolIsoMapDao.get(new StoragePoolIsoMapId(domainId, vm.getStoragePoolId()));
            if (spim == null || spim.getStatus() != StorageDomainStatus.Active) {
                return new ValidationResult(EngineMessage.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
            }
        } else if (activeIsoDomainId == null) {
            return new ValidationResult(EngineMessage.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
        } else if (!isRepoImageExists(effectiveIsoPath, activeIsoDomainId, ImageFileType.ISO)) {
            return new ValidationResult(EngineMessage.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
        }
        return ValidationResult.VALID;
    }
    if (!StringUtils.isEmpty(floppyPath) && !isRepoImageExists(floppyPath, activeIsoDomainId, ImageFileType.Floppy)) {
        return new ValidationResult(EngineMessage.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH);
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateIsoPath(VM vm, String diskPath, String floppyPath, Guid activeIsoDomainId) {
    if (vm.isAutoStartup()) {
        return ValidationResult.VALID;
    }
    if (StringUtils.isEmpty(vm.getIsoPath()) && StringUtils.isEmpty(diskPath) && StringUtils.isEmpty(floppyPath)) {
        return ValidationResult.VALID;
    }
    if (!StringUtils.isEmpty(floppyPath) && activeIsoDomainId == null) {
        return new ValidationResult(EngineMessage.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    String effectiveIsoPath = StringUtils.isEmpty(diskPath) ? vm.getIsoPath() : diskPath;
    if (!StringUtils.isEmpty(effectiveIsoPath)) {
        if (effectiveIsoPath.matches(ValidationUtils.GUID)) {
            BaseDisk disk = diskDao.get(Guid.createGuidFromString(effectiveIsoPath));
            if (disk == null || disk.getContentType() != DiskContentType.ISO) {
                return new ValidationResult(EngineMessage.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
            }
            // ISO disks are always images
            ImageStatus imageStatus = ((DiskImage) disk).getImageStatus();
            if (imageStatus != ImageStatus.OK) {
                return new ValidationResult(EngineMessage.ERROR_ISO_IMAGE_STATUS_ILLEGAL, String.format("$status %s", imageStatus.toString()));
            }
            Guid domainId = ((DiskImage) disk).getStorageIds().get(0);
            StoragePoolIsoMap spim = storagePoolIsoMapDao.get(new StoragePoolIsoMapId(domainId, vm.getStoragePoolId()));
            if (spim == null || spim.getStatus() != StorageDomainStatus.Active) {
                return new ValidationResult(EngineMessage.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
            }
        } else if (activeIsoDomainId == null) {
            return new ValidationResult(EngineMessage.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
        } else if (!isRepoImageExists(effectiveIsoPath, activeIsoDomainId, ImageFileType.ISO)) {
            return new ValidationResult(EngineMessage.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
        }
        return ValidationResult.VALID;
    }
    if (!StringUtils.isEmpty(floppyPath) && !isRepoImageExists(floppyPath, activeIsoDomainId, ImageFileType.Floppy)) {
        return new ValidationResult(EngineMessage.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public void addMenuListItem(final ActionButtonDefinition<T> menuItemDef) {
    ActionButton newActionMenuListItem = getView().addMenuListItem(menuItemDef);
    registerSelectionChangeHandler(menuItemDef);
    // Add menu item widget click handler
    registerHandler(newActionMenuListItem.addClickHandler(e -> {
        menuItemDef.onClick(getSelectedItems());
    }));
    // Update menu item whenever its definition gets re-initialized
    registerHandler(menuItemDef.addInitializeHandler(e -> {
        updateMenuItem(menuItemDef);
    }));
    updateMenuItem(menuItemDef);
}
#method_after
@Override
public void addMenuListItem(final ActionButtonDefinition<T> menuItemDef) {
    ActionButton newActionMenuListItem = getView().addMenuListItem(menuItemDef);
    registerSelectionChangeHandler(menuItemDef);
    // Add menu item widget click handler
    registerHandler(newActionMenuListItem.addClickHandler(e -> {
        menuItemDef.onClick(getSelectedItems());
    }));
    // Update menu item whenever its definition gets re-initialized
    registerHandler(menuItemDef.addInitializeHandler(e -> {
        updateMenuItem(menuItemDef);
    }));
    updateMenuItem(menuItemDef);
}
#end_block

#method_before
public void addActionButton(ActionButtonDefinition<T> buttonDef) {
    ActionButton newButton = getView().addActionButton(buttonDef);
    actionButtonDefinitions.add(buttonDef);
    initButton(buttonDef, newButton);
}
#method_after
@Override
public void addActionButton(ActionButtonDefinition<T> buttonDef) {
    ActionButton newButton = getView().addActionButton(buttonDef);
    if (buttonDef.getIndex() > actionButtonDefinitions.size()) {
        actionButtonDefinitions.add(buttonDef);
    } else {
        actionButtonDefinitions.add(buttonDef.getIndex(), buttonDef);
    }
    initButton(buttonDef, newButton);
}
#end_block

#method_before
@Override
public ActionButton addMenuListItem(ActionButtonDefinition<T> menuItemDef) {
    ActionAnchorListItem menuItem = new ActionAnchorListItem(menuItemDef.getText());
    // Set menu item ID for better accessibility
    String menuItemId = menuItemDef.getUniqueId();
    if (menuItemId != null) {
        menuItem.asWidget().getElement().setId(ElementIdUtils.createElementId(getElementId(), menuItemId));
    }
    actionItemMap.put(menuItemDef, menuItem);
    actionKebab.addMenuItem(menuItem);
    return menuItem;
}
#method_after
@Override
public ActionButton addMenuListItem(ActionButtonDefinition<T> menuItemDef) {
    ActionAnchorListItem menuItem = new ActionAnchorListItem(menuItemDef.getText());
    // Set menu item ID for better accessibility
    String menuItemId = menuItemDef.getUniqueId();
    if (menuItemId != null) {
        menuItem.asWidget().getElement().setId(ElementIdUtils.createElementId(getElementId(), menuItemId));
    }
    actionItemMap.put(menuItemDef, menuItem);
    actionKebab.addMenuItem(menuItem, menuItemDef.getIndex());
    return menuItem;
}
#end_block

#method_before
public ActionButton addActionButton(ActionButtonDefinition<T> buttonDef) {
    SimpleActionButton newActionButton = createNewActionButton(buttonDef);
    initButton(buttonDef, newActionButton);
    return newActionButton;
}
#method_after
@Override
public ActionButton addActionButton(ActionButtonDefinition<T> buttonDef) {
    SimpleActionButton newActionButton = createNewActionButton(buttonDef);
    initButton(buttonDef, newActionButton);
    return newActionButton;
}
#end_block

#method_before
public ActionButton addDropdownActionButton(ActionButtonDefinition<T> buttonDef, List<ActionButtonDefinition<T>> subActions, SelectedItemsProvider<T> selectedItemsProvider) {
    DropdownActionButton<T> dropdownActionButton = new DropdownActionButton<>(subActions, selectedItemsProvider);
    initButton(buttonDef, dropdownActionButton);
    return dropdownActionButton;
}
#method_after
@Override
public ActionButton addDropdownActionButton(ActionButtonDefinition<T> buttonDef, List<ActionButtonDefinition<T>> subActions, SelectedItemsProvider<T> selectedItemsProvider) {
    DropdownActionButton<T> dropdownActionButton = new DropdownActionButton<>(subActions, selectedItemsProvider);
    initButton(buttonDef, dropdownActionButton);
    return dropdownActionButton;
}
#end_block

#method_before
public ActionButton addDropdownComboActionButton(ActionButtonDefinition<T> buttonDef, List<ActionButtonDefinition<T>> subActions, SelectedItemsProvider<T> selectedItemsProvider) {
    DropdownActionButton<T> dropdownActionButton;
    if (buttonDef.getIcon() instanceof IconType) {
        dropdownActionButton = new DropdownActionButton<>(subActions, selectedItemsProvider, true, (IconType) buttonDef.getIcon());
    } else {
        dropdownActionButton = new DropdownActionButton<>(subActions, selectedItemsProvider, true, null);
    }
    initButton(buttonDef, dropdownActionButton);
    return dropdownActionButton;
}
#method_after
@Override
public ActionButton addDropdownComboActionButton(ActionButtonDefinition<T> buttonDef, List<ActionButtonDefinition<T>> subActions, SelectedItemsProvider<T> selectedItemsProvider) {
    DropdownActionButton<T> dropdownActionButton;
    if (buttonDef.getIcon() instanceof IconType) {
        dropdownActionButton = new DropdownActionButton<>(subActions, selectedItemsProvider, true, (IconType) buttonDef.getIcon());
    } else {
        dropdownActionButton = new DropdownActionButton<>(subActions, selectedItemsProvider, true, null);
    }
    initButton(buttonDef, dropdownActionButton);
    return dropdownActionButton;
}
#end_block

#method_before
private void initButton(ActionButtonDefinition<T> buttonDef, ActionButton button) {
    button.setText(buttonDef.getText());
    // Set button element ID for better accessibility
    String buttonId = buttonDef.getUniqueId();
    if (buttonId != null) {
        button.asWidget().getElement().setId(ElementIdUtils.createElementId(getElementId(), buttonId));
    }
    // No insert available so need to remove the kebab and then add it at the end.
    actionFormGroup.remove(actionKebab);
    actionFormGroup.add(button);
    actionFormGroup.add(actionKebab);
    actionItemMap.put(buttonDef, button);
}
#method_after
private void initButton(ActionButtonDefinition<T> buttonDef, ActionButton button) {
    button.setText(buttonDef.getText());
    // Set button element ID for better accessibility
    String buttonId = buttonDef.getUniqueId();
    if (buttonId != null) {
        button.asWidget().getElement().setId(ElementIdUtils.createElementId(getElementId(), buttonId));
    }
    // No insert available so need to remove the kebab and then add it at the end.
    actionFormGroup.remove(actionKebab);
    if (buttonDef.getIndex() >= actionFormGroup.getWidgetCount()) {
        // Add the button at the end
        actionFormGroup.add(button);
        actionFormGroup.add(actionKebab);
    } else {
        // Re-create ordered button list
        List<Widget> currentButtons = new ArrayList<>();
        for (int i = 0; i < actionFormGroup.getWidgetCount(); i++) {
            currentButtons.add(actionFormGroup.getWidget(i));
        }
        currentButtons.add(buttonDef.getIndex(), button.asWidget());
        // Re-add all buttons
        actionFormGroup.clear();
        currentButtons.forEach(existingButton -> actionFormGroup.add(existingButton));
        actionFormGroup.add(actionKebab);
    }
    actionItemMap.put(buttonDef, button);
}
#end_block

#method_before
public boolean isSearchUsingTags() {
    return origText.contains("tag") || getSearchObjectStr() != null && getSearchObjectStr().equals(SearchObjects.VDC_USER_OBJ_NAME) && origText.contains("vm") || getCrossRefObjList().contains(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME) || getCrossRefObjList().contains(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME);
}
#method_after
public boolean isSearchUsingTags() {
    return origText.contains("tag") || isUserSearchUsingTags() || getCrossRefObjList().contains(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME) || getCrossRefObjList().contains(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME);
}
#end_block

#method_before
protected void volumeType_SelectedItemChanged() {
    if (getVolumeType().getSelectedItem() == null || getDataCenter().getSelectedItem() == null || getStorageDomain().getSelectedItem() == null) {
        return;
    }
    if (!isInStorageDomainUpdate) {
        isUserSelectVolumeType = true;
    }
    VolumeType volumeType = getVolumeType().getSelectedItem();
    StorageType storageType = getStorageDomain().getSelectedItem().getStorageType();
    updateShareable(volumeType, storageType);
}
#method_after
protected void volumeType_SelectedItemChanged() {
    if (getVolumeType().getSelectedItem() == null || getDataCenter().getSelectedItem() == null || getStorageDomain().getSelectedItem() == null) {
        return;
    }
    if (!isInStorageDomainUpdate) {
        isUserSelectedVolumeType = true;
    }
    VolumeType volumeType = getVolumeType().getSelectedItem();
    StorageType storageType = getStorageDomain().getSelectedItem().getStorageType();
    updateShareable(volumeType, storageType);
}
#end_block

#method_before
private void storageDomain_SelectedItemChanged() {
    StorageDomain selectedStorage = getStorageDomain().getSelectedItem();
    if (selectedStorage != null) {
        updateVolumeType(selectedStorage.getStorageType());
        if (getIsNew()) {
            getIsWipeAfterDelete().setEntity(selectedStorage.getWipeAfterDelete());
        }
    }
    updateQuota(getDataCenter().getSelectedItem());
    updateDiskProfiles(getDataCenter().getSelectedItem());
    updateCinderVolumeTypes();
    updatePassDiscardAvailability();
    updatePassDiscardChangeability();
    updateWipeAfterDeleteChangeability();
}
#method_after
private void storageDomain_SelectedItemChanged() {
    StorageDomain selectedStorage = getStorageDomain().getSelectedItem();
    if (selectedStorage != null) {
        isInStorageDomainUpdate = true;
        updateVolumeType(selectedStorage.getStorageType());
        isInStorageDomainUpdate = false;
        if (getIsNew()) {
            getIsWipeAfterDelete().setEntity(selectedStorage.getWipeAfterDelete());
        }
    }
    updateQuota(getDataCenter().getSelectedItem());
    updateDiskProfiles(getDataCenter().getSelectedItem());
    updateCinderVolumeTypes();
    updatePassDiscardAvailability();
    updatePassDiscardChangeability();
    updateWipeAfterDeleteChangeability();
}
#end_block

#method_before
@Override
protected void updateVolumeType(StorageType storageType) {
    isInStorageDomainUpdate = true;
    if (!isUserSelectVolumeType) {
        getVolumeType().setSelectedItem(storageType.isBlockDomain() ? VolumeType.Preallocated : VolumeType.Sparse);
    }
    isInStorageDomainUpdate = false;
}
#method_after
@Override
protected void updateVolumeType(StorageType storageType) {
    // domain type
    if (!isUserSelectedVolumeType) {
        getVolumeType().setSelectedItem(storageType.isBlockDomain() ? VolumeType.Preallocated : VolumeType.Sparse);
    }
}
#end_block

#method_before
@Override
public void init() {
    super.init();
    setStorageDomainId(getDiskImage().getStorageIds().get(0));
    setStoragePoolId(getDiskImage().getStoragePoolId());
    setImageGroupId(getDiskImage().getId());
    setVm(vmDao.getVmsWithPlugInfo(getDiskImage().getId()).stream().filter(p -> p.getFirst().getStatus() != VMStatus.Down).filter(p -> p.getSecond().isPlugged()).map(Pair::getFirst).findFirst().orElse(null));
    if (getVm() != null) {
        setVdsId(getVm().getRunOnVds());
    }
}
#method_after
@Override
public void init() {
    super.init();
    if (getDiskImage() == null) {
        return;
    }
    setStorageDomainId(getDiskImage().getStorageIds().get(0));
    setStoragePoolId(getDiskImage().getStoragePoolId());
    setImageGroupId(getDiskImage().getId());
    setVm(vmDao.getVmsWithPlugInfo(getDiskImage().getId()).stream().filter(p -> p.getSecond().isPlugged()).map(Pair::getFirst).findFirst().orElse(null));
    if (getVm() != null && getVm().isRunning()) {
        setVdsId(getVm().getRunOnVds());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (isInternalExecution()) {
        // so no need to validate again.
        return true;
    }
    DiskValidator diskValidator = createDiskValidator();
    if (!validate(diskValidator.isDiskExists())) {
        return false;
    }
    if (getDiskImage().isShareable()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REDUCE_IMAGE_NOT_SUPPORTED_FOR_SHAREABLE_DISK);
    }
    if (getStorageDomain().getStorageType().isFileDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REDUCE_IMAGE_NOT_SUPPORTED_FOR_FILE_DOMAINS);
    }
    if (!isReduceVolumeSupported()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REDUCE_IMAGE_NOT_SUPPORTED_BY_DC_VERSION, String.format("$dataCenterVersion %s", getStoragePool().getCompatibilityVersion()));
    }
    if (!isInternalMerge()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REDUCE_IMAGE_NOT_SUPPORTED_FOR_ACTIVE_IMAGE);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    DiskValidator diskValidator = createDiskValidator();
    if (!validate(diskValidator.isDiskExists())) {
        return false;
    }
    if (getDiskImage().isShareable()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REDUCE_IMAGE_NOT_SUPPORTED_FOR_SHAREABLE_DISK);
    }
    if (getStorageDomain().getStorageType().isFileDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REDUCE_IMAGE_NOT_SUPPORTED_FOR_FILE_DOMAINS);
    }
    if (!isReduceVolumeSupported()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REDUCE_IMAGE_NOT_SUPPORTED_BY_DC_VERSION, String.format("$dataCenterVersion %s", getStoragePool().getCompatibilityVersion()));
    }
    if (getVm() != null && getVm().isRunning() && !isInternalMerge()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REDUCE_IMAGE_NOT_SUPPORTED_FOR_ACTIVE_IMAGE_LIVE_MERGE);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getImageGroupId()));
    boolean prepareImageSucceeded = false;
    boolean reduceImageSucceeded = false;
    if (!isVmRunningOnSpm()) {
        // The VM isn't running on the SPM but the reduce command is performed on the SPM, hence
        // we have to prepare the image on the SPM
        log.debug("Preparing image {}/{} on the SPM", getImageGroupId(), getImageId());
        try {
            prepareImage();
            prepareImageSucceeded = true;
        } catch (EngineException e) {
            log.error("Failed to prepare image {}/{} on the SPM", getImageGroupId(), getImageId());
        }
    }
    if (!isVmRunningOnSpm() && !prepareImageSucceeded) {
        // As we don't want to fail the live merge because of a failure to reduce the image, we still mark the
        // command as succeeded.
        setSucceeded(true);
        return;
    }
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ReduceImage, createReduceImageVDSCommandParameters());
        if (vdsReturnValue.getSucceeded()) {
            reduceImageSucceeded = true;
        }
    } catch (EngineException e) {
        log.error("Reducing image {}/{} failed", getImageGroupId(), getImageId());
    }
    if (prepareImageSucceeded && !reduceImageSucceeded) {
        try {
            teardownImage();
        } catch (EngineException e) {
            log.error("Failed to teardown image {}/{} on the SPM", getImageGroupId(), getImageId());
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getImageGroupId()));
    boolean prepareImageSucceeded = false;
    boolean reduceImageSucceeded = false;
    if (!isVmRunningOnSpm()) {
        // The VM isn't running on the SPM but the reduce command is performed on the SPM, hence
        // we have to prepare the image on the SPM
        log.debug("Preparing image {}/{} on the SPM", getImageGroupId(), getImageId());
        try {
            prepareImage();
            prepareImageSucceeded = true;
        } catch (EngineException e) {
            log.error("Failed to prepare image {}/{} on the SPM", getImageGroupId(), getImageId());
        }
    }
    if (!isVmRunningOnSpm() && !prepareImageSucceeded) {
        // As we don't want to fail the live merge because of a failure to reduce the image, we still mark the
        // command as succeeded.
        setSucceeded(true);
        return;
    }
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ReduceImage, createReduceImageVDSCommandParameters());
        if (vdsReturnValue.getSucceeded()) {
            Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
            getTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
            reduceImageSucceeded = true;
        }
    } catch (EngineException e) {
        log.error("Reducing image {}/{} failed", getImageGroupId(), getImageId());
    }
    if (prepareImageSucceeded && !reduceImageSucceeded) {
        try {
            teardownImage();
        } catch (EngineException e) {
            log.error("Failed to teardown image {}/{} on the SPM", getImageGroupId(), getImageId());
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public ActionReturnValue endAction() {
    if (!isVmRunningOnSpm()) {
        // Teardown the image on the SPM
        log.debug("Tearing down image {}/{} on the SPM", getImageGroupId(), getImageId());
        try {
            teardownImage();
        } catch (EngineException e) {
            log.error("Failed to teardown image {}/{} on the SPM", getImageGroupId(), getImageId());
        }
        if (getVdsId() != null) {
            // Refresh image on the host running the VM
            log.debug("Refreshing image {}/{} on its running host {}", getImageGroupId(), getImageId(), getVdsId());
            try {
                runInternalAction(ActionType.RefreshVolume, createRefreshVolumeParameters());
            } catch (EngineException e) {
                log.error("Failed to refresh image {}/{} on its running host {}", getImageGroupId(), getImageId(), getVdsId());
            }
        }
    }
    // We mark the action as succeeded, even if it failed, in order not to fail the live merge operation.
    setSucceeded(true);
    setCommandStatus(CommandStatus.SUCCEEDED);
    return getReturnValue();
}
#method_after
@Override
public ActionReturnValue endAction() {
    if (!isVmRunningOnSpm()) {
        // Teardown the image on the SPM
        log.debug("Tearing down image {}/{} on the SPM", getImageGroupId(), getImageId());
        try {
            teardownImage();
        } catch (EngineException e) {
            log.error("Failed to teardown image {}/{} on the SPM", getImageGroupId(), getImageId());
        }
        if (!Guid.isNullOrEmpty(getVdsId())) {
            // Refresh image on the host running the VM
            log.debug("Refreshing image {}/{} on its running host {}", getImageGroupId(), getImageId(), getVdsId());
            try {
                runInternalAction(ActionType.RefreshVolume, createRefreshVolumeParameters());
            } catch (EngineException e) {
                log.error("Failed to refresh image {}/{} on its running host {}", getImageGroupId(), getImageId(), getVdsId());
            }
        }
    }
    // We mark the action as succeeded, even if it failed, in order not to fail the live merge operation.
    setSucceeded(true);
    setCommandStatus(CommandStatus.SUCCEEDED);
    return super.endAction();
}
#end_block

#method_before
private boolean isInternalMerge() {
    return getVmId() != null && getActiveDiskImage() != null && !getActiveDiskImage().getParentId().equals(getImageId());
}
#method_after
private boolean isInternalMerge() {
    return getActiveDiskImage() != null && !getActiveDiskImage().getParentId().equals(getImageId());
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!isInternalExecution()) {
        return Collections.singletonMap(getImageGroupId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED));
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!isExecutedAsChildCommand()) {
        return Collections.singletonMap(getImageGroupId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED));
    }
    return null;
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters());
    Guid currentChildId = getCurrentChildId(getParameters());
    ActionReturnValue actionReturnValue = null;
    if (currentChildId != null) {
        actionReturnValue = commandCoordinatorUtil.getCommandReturnValue(currentChildId);
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<ActionType, ? extends ActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(ActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(ActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            nextCommand = new Pair<>(ActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (actionReturnValue != null) {
                getParameters().setMergeStatusReturnValue(actionReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = buildDestroyCommand(ActionType.DestroyImage, getActionType(), new ArrayList<>(getParameters().getMergeStatusReturnValue().getImagesToRemove()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.REDUCE_IMAGE);
            break;
        case REDUCE_IMAGE:
            Pair<ActionType, ? extends ActionParametersBase> reduceImageCommand = buildReduceImageCommand();
            ActionReturnValue returnValue = CommandHelper.validate(reduceImageCommand.getFirst(), reduceImageCommand.getSecond(), getContext().clone());
            if (returnValue.isValid()) {
                nextCommand = reduceImageCommand;
                getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.COMPLETE);
            } else {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            break;
        case COMPLETE:
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        commandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters());
    Guid currentChildId = getCurrentChildId(getParameters());
    ActionReturnValue actionReturnValue = null;
    if (currentChildId != null) {
        actionReturnValue = commandCoordinatorUtil.getCommandReturnValue(currentChildId);
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<ActionType, ? extends ActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(ActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(ActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            nextCommand = new Pair<>(ActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (actionReturnValue != null) {
                getParameters().setMergeStatusReturnValue(actionReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = buildDestroyCommand(ActionType.DestroyImage, getActionType(), new ArrayList<>(getParameters().getMergeStatusReturnValue().getImagesToRemove()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.REDUCE_IMAGE);
            break;
        case REDUCE_IMAGE:
            Pair<ActionType, ? extends ActionParametersBase> reduceImageCommand = buildReduceImageCommand();
            ActionReturnValue returnValue = CommandHelper.validate(reduceImageCommand.getFirst(), reduceImageCommand.getSecond(), getContext().clone());
            if (returnValue.isValid()) {
                nextCommand = reduceImageCommand;
                getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.COMPLETE);
            } else {
                // Couldn't validate reduce image command for execution, however, we don't
                // want to fail the remove snapshot command as this step isn't mandatory.
                log.warn("Couldn't validate reduce image command, skipping its execution.");
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            break;
        case COMPLETE:
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        commandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
public void setDomain(String value) {
    domain = (value == null) ? "" : value;
}
#method_after
public void setDomain(String value) {
    domain = value == null ? "" : value;
}
#end_block

#method_before
public void setName(String value) {
    name = (value == null) ? "" : value;
}
#method_after
public void setName(String value) {
    name = value == null ? "" : value;
}
#end_block

#method_before
public void setDistinguishedName(String distinguishedName) {
    this.distinguishedName = (distinguishedName == null) ? "" : distinguishedName;
}
#method_after
public void setDistinguishedName(String distinguishedName) {
    this.distinguishedName = distinguishedName == null ? "" : distinguishedName;
}
#end_block

#method_before
public void setDescription(String value) {
    this.description = (value == null) ? "" : value;
}
#method_after
public void setDescription(String value) {
    this.description = value == null ? "" : value;
}
#end_block

#method_before
public void setComment(String value) {
    comment = (value == null) ? "" : value;
}
#method_after
public void setComment(String value) {
    comment = value == null ? "" : value;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, autoStartup, cpuPerSocket, threadsPerCpu, creationDate, defaultBootSequence, description, failBack, initrdUrl, isoPath, kernelParams, kernelUrl, osId, memSizeMb, maxMemorySizeMb, niceLevel, cpuShares, numOfSockets, numOfMonitors, origin, priority, stateless, smartcardEnabled, timeZone, usbPolicy, clusterId, vmType, quotaId, allowConsoleReconnect, dedicatedVmForVdsList, migrationSupport, tunnelMigration, vncKeyboardLayout, createdByUserId, defaultDisplayType, migrationDowntime, serialNumberPolicy, customSerialNumber, bootMenuEnabled, spiceFileTransferEnabled, spiceCopyPasteEnabled, cpuProfileId, numaTuneMode, vNumaNodeList, autoConverge, migrateCompressed, predefinedProperties, userDefinedProperties, customEmulatedMachine, customCpuName, smallIconId, largeIconId, consoleDisconnectAction, customCompatibilityVersion, resumeBehavior);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, autoStartup, cpuPerSocket, threadsPerCpu, creationDate, defaultBootSequence, description, failBack, initrdUrl, isoPath, kernelParams, kernelUrl, osId, memSizeMb, maxMemorySizeMb, niceLevel, cpuShares, numOfSockets, numOfMonitors, origin, priority, stateless, smartcardEnabled, timeZone, usbPolicy, clusterId, vmType, quotaId, allowConsoleReconnect, dedicatedVmForVdsList, migrationSupport, tunnelMigration, vncKeyboardLayout, createdByUserId, defaultDisplayType, migrationDowntime, serialNumberPolicy, customSerialNumber, bootMenuEnabled, spiceFileTransferEnabled, spiceCopyPasteEnabled, cpuProfileId, numaTuneMode, vNumaNodeList, autoConverge, migrateCompressed, predefinedProperties, userDefinedProperties, customEmulatedMachine, biosType, customCpuName, smallIconId, largeIconId, consoleDisconnectAction, customCompatibilityVersion, resumeBehavior);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return Objects.equals(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && Objects.equals(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && Objects.equals(description, other.description) && failBack == other.failBack && Objects.equals(initrdUrl, other.initrdUrl) && Objects.equals(isoPath, other.isoPath) && Objects.equals(kernelParams, other.kernelParams) && Objects.equals(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && maxMemorySizeMb == other.maxMemorySizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && threadsPerCpu == other.threadsPerCpu && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && Objects.equals(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && Objects.equals(clusterId, other.clusterId) && vmType == other.vmType && Objects.equals(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && Objects.equals(dedicatedVmForVdsList, other.dedicatedVmForVdsList) && migrationSupport == other.migrationSupport && Objects.equals(tunnelMigration, other.tunnelMigration) && Objects.equals(vncKeyboardLayout, other.vncKeyboardLayout) && Objects.equals(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && Objects.equals(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && Objects.equals(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && Objects.equals(cpuProfileId, other.cpuProfileId) && Objects.equals(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && Objects.equals(vNumaNodeList, other.vNumaNodeList) && Objects.equals(autoConverge, other.autoConverge) && Objects.equals(migrateCompressed, other.migrateCompressed) && Objects.equals(predefinedProperties, other.predefinedProperties) && Objects.equals(userDefinedProperties, other.userDefinedProperties) && Objects.equals(customEmulatedMachine, other.customEmulatedMachine) && Objects.equals(customCpuName, other.customCpuName) && Objects.equals(smallIconId, other.smallIconId) && Objects.equals(largeIconId, other.largeIconId) && Objects.equals(consoleDisconnectAction, other.consoleDisconnectAction) && Objects.equals(resumeBehavior, other.resumeBehavior) && Objects.equals(customCompatibilityVersion, other.customCompatibilityVersion);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return Objects.equals(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && Objects.equals(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && Objects.equals(description, other.description) && failBack == other.failBack && Objects.equals(initrdUrl, other.initrdUrl) && Objects.equals(isoPath, other.isoPath) && Objects.equals(kernelParams, other.kernelParams) && Objects.equals(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && maxMemorySizeMb == other.maxMemorySizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && threadsPerCpu == other.threadsPerCpu && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && Objects.equals(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && Objects.equals(clusterId, other.clusterId) && vmType == other.vmType && Objects.equals(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && Objects.equals(dedicatedVmForVdsList, other.dedicatedVmForVdsList) && migrationSupport == other.migrationSupport && Objects.equals(tunnelMigration, other.tunnelMigration) && Objects.equals(vncKeyboardLayout, other.vncKeyboardLayout) && Objects.equals(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && Objects.equals(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && Objects.equals(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && Objects.equals(cpuProfileId, other.cpuProfileId) && Objects.equals(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && Objects.equals(vNumaNodeList, other.vNumaNodeList) && Objects.equals(autoConverge, other.autoConverge) && Objects.equals(migrateCompressed, other.migrateCompressed) && Objects.equals(predefinedProperties, other.predefinedProperties) && Objects.equals(userDefinedProperties, other.userDefinedProperties) && Objects.equals(customEmulatedMachine, other.customEmulatedMachine) && biosType == other.biosType && Objects.equals(customCpuName, other.customCpuName) && Objects.equals(smallIconId, other.smallIconId) && Objects.equals(largeIconId, other.largeIconId) && Objects.equals(consoleDisconnectAction, other.consoleDisconnectAction) && Objects.equals(resumeBehavior, other.resumeBehavior) && Objects.equals(customCompatibilityVersion, other.customCompatibilityVersion);
}
#end_block

#method_before
public void setDescription(String value) {
    description = (value == null) ? "" : value;
}
#method_after
public void setDescription(String value) {
    description = value == null ? "" : value;
}
#end_block

#method_before
@Override
public void setComment(String value) {
    comment = (value == null) ? "" : value;
}
#method_after
@Override
public void setComment(String value) {
    comment = value == null ? "" : value;
}
#end_block

#method_before
public void setAlias(String alias) {
    this.alias = (alias == null) ? "" : alias;
}
#method_after
public void setAlias(String alias) {
    this.alias = alias == null ? "" : alias;
}
#end_block

#method_before
public void setDescription(String description) {
    this.description = (description == null) ? "" : description;
}
#method_after
public void setDescription(String description) {
    this.description = description == null ? "" : description;
}
#end_block

#method_before
public void setFirstName(String value) {
    firstName = (value == null) ? "" : value;
}
#method_after
public void setFirstName(String value) {
    firstName = value == null ? "" : value;
}
#end_block

#method_before
public void setLastName(String value) {
    lastName = (value == null) ? "" : value;
}
#method_after
public void setLastName(String value) {
    lastName = value == null ? "" : value;
}
#end_block

#method_before
public void setDepartment(String value) {
    department = (value == null) ? "" : value;
}
#method_after
public void setDepartment(String value) {
    department = value == null ? "" : value;
}
#end_block

#method_before
public void setDescription(String value) {
    this.description = (value == null) ? "" : value;
}
#method_after
public void setDescription(String value) {
    this.description = value == null ? "" : value;
}
#end_block

#method_before
public void setComment(String value) {
    comment = (value == null) ? "" : value;
}
#method_after
public void setComment(String value) {
    comment = value == null ? "" : value;
}
#end_block

#method_before
public void setName(String value) {
    this.name = (value == null) ? "" : value;
}
#method_after
public void setName(String value) {
    this.name = value == null ? "" : value;
}
#end_block

#method_before
public void setLabel(String label) {
    this.label = (label == null) ? "" : label;
}
#method_after
public void setLabel(String label) {
    this.label = label;
}
#end_block

#method_before
public void setUserName(String userName) {
    this.userName = (userName == null) ? "" : userName;
}
#method_after
public void setUserName(String userName) {
    this.userName = userName == null ? "" : userName;
}
#end_block

#method_before
public void setQuotaName(String quotaName) {
    this.quotaName = (quotaName == null) ? "" : quotaName;
}
#method_after
public void setQuotaName(String quotaName) {
    this.quotaName = quotaName == null ? "" : quotaName;
}
#end_block

#method_before
public void setVdsName(String vdsName) {
    this.vdsName = (vdsName == null) ? "" : vdsName;
}
#method_after
public void setVdsName(String vdsName) {
    this.vdsName = vdsName == null ? "" : vdsName;
}
#end_block

#method_before
public void setVmTemplateName(String vmTemplateName) {
    this.vmTemplateName = (vmTemplateName == null) ? "" : vmTemplateName;
}
#method_after
public void setVmTemplateName(String vmTemplateName) {
    this.vmTemplateName = vmTemplateName == null ? "" : vmTemplateName;
}
#end_block

#method_before
public void setVmName(String vmName) {
    this.vmName = (vmName == null) ? "" : vmName;
}
#method_after
public void setVmName(String vmName) {
    this.vmName = vmName == null ? "" : vmName;
}
#end_block

#method_before
public void setStoragePoolName(String storagePoolName) {
    this.storagePoolName = (storagePoolName == null) ? "" : storagePoolName;
}
#method_after
public void setStoragePoolName(String storagePoolName) {
    this.storagePoolName = storagePoolName == null ? "" : storagePoolName;
}
#end_block

#method_before
public void setStorageDomainName(String storageDomainName) {
    this.storageDomainName = (storageDomainName == null) ? "" : storageDomainName;
}
#method_after
public void setStorageDomainName(String storageDomainName) {
    this.storageDomainName = storageDomainName == null ? "" : storageDomainName;
}
#end_block

#method_before
public void setClusterName(String clusterName) {
    this.clusterName = (clusterName == null) ? "" : clusterName;
}
#method_after
public void setClusterName(String clusterName) {
    this.clusterName = clusterName == null ? "" : clusterName;
}
#end_block

#method_before
public void setGlusterVolumeName(String glusterVolumeName) {
    this.glusterVolumeName = (glusterVolumeName == null) ? "" : glusterVolumeName;
}
#method_after
public void setGlusterVolumeName(String glusterVolumeName) {
    this.glusterVolumeName = glusterVolumeName == null ? "" : glusterVolumeName;
}
#end_block

#method_before
public void setDescription(String description) {
    this.description = (description == null) ? "" : description;
}
#method_after
public void setDescription(String description) {
    this.description = description == null ? "" : description;
}
#end_block

#method_before
public void setComment(String value) {
    comment = (value == null) ? "" : value;
}
#method_after
public void setComment(String value) {
    comment = value == null ? "" : value;
}
#end_block

#method_before
protected void alertActionSkippedAlreadyInStatus(FenceActionType fenceActionType, PowerStatus powerStatus) {
    AuditLogable auditLogable = new AuditLogableImpl();
    auditLogable.addCustomValue("HostName", fencedHost.getName());
    auditLogable.addCustomValue("AgentStatus", powerStatus.name());
    auditLogable.addCustomValue("Operation", fenceActionType.getValue());
    auditLogDirector.log(auditLogable, AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS);
}
#method_after
protected void alertActionSkippedAlreadyInStatus(FenceActionType fenceActionType, PowerStatus powerStatus) {
    AuditLogable auditLogable = new AuditLogableImpl();
    auditLogable.addCustomValue("HostName", fencedHost.getName());
    auditLogable.addCustomValue("AgentStatus", powerStatus.name());
    auditLogable.addCustomValue("Operation", fenceActionType.getValue());
    Injector.get(AuditLogDirector.class).log(auditLogable, AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS);
}
#end_block

#method_before
protected void alertActionSkippedFencingDisabledInPolicy() {
    AuditLogable auditLogable = new AuditLogableImpl();
    auditLogable.addCustomValue("VdsName", fencedHost.getName());
    auditLogDirector.log(auditLogable, AuditLogType.VDS_ALERT_FENCE_DISABLED_BY_CLUSTER_POLICY);
}
#method_after
protected void alertActionSkippedFencingDisabledInPolicy() {
    AuditLogable auditLogable = new AuditLogableImpl();
    auditLogable.addCustomValue("VdsName", fencedHost.getName());
    Injector.get(AuditLogDirector.class).log(auditLogable, AuditLogType.VDS_ALERT_FENCE_DISABLED_BY_CLUSTER_POLICY);
}
#end_block

#method_before
@Before
public void setup() {
    injectorRule.bind(FenceAgentDao.class, fenceAgentDao);
    when(fencedHost.getId()).thenReturn(FENCECD_HOST_ID);
    executor = spy(new HostFenceActionExecutor(fencedHost, new FencingPolicy()));
    doReturn(agentExecutor1).doReturn(agentExecutor2).when(executor).createFenceActionExecutor(any());
    doNothing().when(executor).alertActionSkippedAlreadyInStatus(any(), any());
    doNothing().when(executor).alertActionSkippedFencingDisabledInPolicy();
}
#method_after
@BeforeEach
public void setup() {
    when(fencedHost.getId()).thenReturn(FENCECD_HOST_ID);
    executor = spy(new HostFenceActionExecutor(fencedHost, new FencingPolicy()));
    doReturn(agentExecutor1).doReturn(agentExecutor2).when(executor).createFenceActionExecutor(any());
    doNothing().when(executor).alertActionSkippedAlreadyInStatus(any(), any());
    doNothing().when(executor).alertActionSkippedFencingDisabledInPolicy();
}
#end_block

#method_before
private void setIconType(Span icon, AuditLog model) {
    switch(((AuditLog) model).getSeverity()) {
        case ALERT:
            icon.addStyleName(PatternflyConstants.PFICON_WARNING_TRIANGLE_O);
            break;
        case ERROR:
            icon.addStyleName(PatternflyConstants.PFICON_ERROR_CIRCLE_O);
            break;
        case NORMAL:
            icon.addStyleName(PatternflyConstants.PFICON_INFO);
            break;
        case WARNING:
            icon.addStyleName(PatternflyConstants.PFICON_WARNING_TRIANGLE_O);
            break;
        default:
            icon.addStyleName(PatternflyConstants.PFICON_OK);
            break;
    }
}
#method_after
private void setIconType(Span icon, AuditLog model) {
    switch(model.getSeverity()) {
        case ALERT:
            icon.addStyleName(PatternflyConstants.PFICON_WARNING_TRIANGLE_O);
            break;
        case ERROR:
            icon.addStyleName(PatternflyConstants.PFICON_ERROR_CIRCLE_O);
            break;
        case NORMAL:
            icon.addStyleName(PatternflyConstants.PFICON_INFO);
            break;
        case WARNING:
            icon.addStyleName(PatternflyConstants.PFICON_WARNING_TRIANGLE_O);
            break;
        default:
            icon.addStyleName(PatternflyConstants.PFICON_OK);
            break;
    }
}
#end_block

#method_before
public void addActionButton(ActionButton actionButton) {
    notificationKebab.addMenuItem(actionButton, Integer.MAX_VALUE);
    notificationKebab.setVisible(notificationKebab.getWidgetCount() > 0);
}
#method_after
public void addActionButton(ActionButton actionButton) {
    notificationKebab.addMenuItem(actionButton);
    notificationKebab.setVisible(notificationKebab.getWidgetCount() > 0);
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    Scheduler.get().scheduleDeferred(() -> addPluginActionButtons(actionButtonPluginHandler.getButtons(getProxy().getTargetHistoryToken())));
    // Register this handler for whichever tab opens first, it is bound before the plugin fires its events and
    // before the actionButtonPluginHandler is instantiated and listening to events.
    registerHandler(getEventBus().addHandler(AddActionButtonEvent.getType(), event -> {
        if (getProxy().getTargetHistoryToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList);
        }
    }));
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    Scheduler.get().scheduleDeferred(() -> {
        addPluginActionButtons(actionButtonPluginHandler.getButtons(getProxy().getTargetHistoryToken()), false);
        addPluginActionButtons(actionButtonPluginHandler.getMenuItems(getProxy().getTargetHistoryToken()), true);
    });
    // Register this handler for whichever tab opens first, it is bound before the plugin fires
    // its events and before the actionButtonPluginHandler is instantiated and listening to events.
    registerHandler(getEventBus().addHandler(AddActionButtonEvent.getType(), event -> {
        if (getProxy().getTargetHistoryToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList, false);
        }
    }));
    registerHandler(getEventBus().addHandler(AddKebabMenuListItemEvent.getType(), event -> {
        if (getProxy().getTargetHistoryToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList, true);
        }
    }));
}
#end_block

#method_before
private void addPluginActionButtons(List<ActionButtonDefinition<?>> pluginActionButtonList) {
    if (getActionPanelPresenterWidget() != null) {
        for (ActionButtonDefinition<?> buttonDef : pluginActionButtonList) {
            int order = 0;
            if (buttonDef.getPriority() > 0) {
                order = (int) buttonDef.getPriority();
            }
            getActionPanelPresenterWidget().addActionButton((ActionButtonDefinition) buttonDef, order);
        }
    }
}
#method_after
private void addPluginActionButtons(List<ActionButtonDefinition<?>> pluginActionButtonList, boolean isMenuItem) {
    if (getActionPanelPresenterWidget() != null) {
        for (ActionButtonDefinition<?> buttonDef : pluginActionButtonList) {
            if (isMenuItem) {
                getActionPanelPresenterWidget().addMenuListItem((ActionButtonDefinition) buttonDef);
            } else {
                getActionPanelPresenterWidget().addActionButton((ActionButtonDefinition) buttonDef);
            }
        }
    }
}
#end_block

#method_before
public void addMenuListItem(final ActionButtonDefinition<T> menuItemDef) {
    addMenuListItem(menuItemDef, Integer.MAX_VALUE);
}
#method_after
@Override
public void addMenuListItem(final ActionButtonDefinition<T> menuItemDef) {
    ActionButton newActionMenuListItem = getView().addMenuListItem(menuItemDef);
    registerSelectionChangeHandler(menuItemDef);
    // Add menu item widget click handler
    registerHandler(newActionMenuListItem.addClickHandler(e -> {
        menuItemDef.onClick(getSelectedItems());
    }));
    // Update menu item whenever its definition gets re-initialized
    registerHandler(menuItemDef.addInitializeHandler(e -> {
        updateMenuItem(menuItemDef);
    }));
    updateMenuItem(menuItemDef);
}
#end_block

#method_before
public void addActionButton(ActionButtonDefinition<T> buttonDef) {
    addActionButton(buttonDef, Integer.MAX_VALUE);
}
#method_after
@Override
public void addActionButton(ActionButtonDefinition<T> buttonDef) {
    ActionButton newButton = getView().addActionButton(buttonDef);
    if (buttonDef.getIndex() > actionButtonDefinitions.size()) {
        actionButtonDefinitions.add(buttonDef);
    } else {
        actionButtonDefinitions.add(buttonDef.getIndex(), buttonDef);
    }
    initButton(buttonDef, newButton);
}
#end_block

#method_before
@Override
public ActionButton addMenuListItem(ActionButtonDefinition<T> menuItemDef, int order) {
    ActionAnchorListItem menuItem = new ActionAnchorListItem(menuItemDef.getText());
    // Set menu item ID for better accessibility
    String menuItemId = menuItemDef.getUniqueId();
    if (menuItemId != null) {
        menuItem.asWidget().getElement().setId(ElementIdUtils.createElementId(getElementId(), menuItemId));
    }
    actionItemMap.put(menuItemDef, menuItem);
    actionKebab.addMenuItem(menuItem, order);
    return menuItem;
}
#method_after
@Override
public ActionButton addMenuListItem(ActionButtonDefinition<T> menuItemDef) {
    ActionAnchorListItem menuItem = new ActionAnchorListItem(menuItemDef.getText());
    // Set menu item ID for better accessibility
    String menuItemId = menuItemDef.getUniqueId();
    if (menuItemId != null) {
        menuItem.asWidget().getElement().setId(ElementIdUtils.createElementId(getElementId(), menuItemId));
    }
    actionItemMap.put(menuItemDef, menuItem);
    actionKebab.addMenuItem(menuItem, menuItemDef.getIndex());
    return menuItem;
}
#end_block

#method_before
@Override
public ActionButton addActionButton(ActionButtonDefinition<T> buttonDef, int order) {
    SimpleActionButton newActionButton = createNewActionButton(buttonDef);
    initButton(buttonDef, newActionButton, order);
    return newActionButton;
}
#method_after
@Override
public ActionButton addActionButton(ActionButtonDefinition<T> buttonDef) {
    SimpleActionButton newActionButton = createNewActionButton(buttonDef);
    initButton(buttonDef, newActionButton);
    return newActionButton;
}
#end_block

#method_before
public ActionButton addDropdownActionButton(ActionButtonDefinition<T> buttonDef, List<ActionButtonDefinition<T>> subActions, SelectedItemsProvider<T> selectedItemsProvider) {
    DropdownActionButton<T> dropdownActionButton = new DropdownActionButton<>(subActions, selectedItemsProvider);
    initButton(buttonDef, dropdownActionButton, Integer.MAX_VALUE);
    return dropdownActionButton;
}
#method_after
@Override
public ActionButton addDropdownActionButton(ActionButtonDefinition<T> buttonDef, List<ActionButtonDefinition<T>> subActions, SelectedItemsProvider<T> selectedItemsProvider) {
    DropdownActionButton<T> dropdownActionButton = new DropdownActionButton<>(subActions, selectedItemsProvider);
    initButton(buttonDef, dropdownActionButton);
    return dropdownActionButton;
}
#end_block

#method_before
public ActionButton addDropdownComboActionButton(ActionButtonDefinition<T> buttonDef, List<ActionButtonDefinition<T>> subActions, SelectedItemsProvider<T> selectedItemsProvider) {
    DropdownActionButton<T> dropdownActionButton;
    if (buttonDef.getIcon() instanceof IconType) {
        dropdownActionButton = new DropdownActionButton<>(subActions, selectedItemsProvider, true, (IconType) buttonDef.getIcon());
    } else {
        dropdownActionButton = new DropdownActionButton<>(subActions, selectedItemsProvider, true, null);
    }
    initButton(buttonDef, dropdownActionButton, Integer.MAX_VALUE);
    return dropdownActionButton;
}
#method_after
@Override
public ActionButton addDropdownComboActionButton(ActionButtonDefinition<T> buttonDef, List<ActionButtonDefinition<T>> subActions, SelectedItemsProvider<T> selectedItemsProvider) {
    DropdownActionButton<T> dropdownActionButton;
    if (buttonDef.getIcon() instanceof IconType) {
        dropdownActionButton = new DropdownActionButton<>(subActions, selectedItemsProvider, true, (IconType) buttonDef.getIcon());
    } else {
        dropdownActionButton = new DropdownActionButton<>(subActions, selectedItemsProvider, true, null);
    }
    initButton(buttonDef, dropdownActionButton);
    return dropdownActionButton;
}
#end_block

#method_before
private void initButton(ActionButtonDefinition<T> buttonDef, ActionButton button, int order) {
    button.setText(buttonDef.getText());
    // Set button element ID for better accessibility
    String buttonId = buttonDef.getUniqueId();
    if (buttonId != null) {
        button.asWidget().getElement().setId(ElementIdUtils.createElementId(getElementId(), buttonId));
    }
    // No insert available so need to remove the kebab and then add it at the end.
    actionFormGroup.remove(actionKebab);
    if (order < actionFormGroup.getWidgetCount()) {
        List<Widget> currentButtons = new ArrayList<>();
        for (int i = 0; i < actionFormGroup.getWidgetCount(); i++) {
            currentButtons.add(actionFormGroup.getWidget(i));
        }
        actionFormGroup.clear();
        currentButtons.add(order, button.asWidget());
        currentButtons.forEach(existingButton -> actionFormGroup.add(existingButton));
        actionFormGroup.add(actionKebab);
    } else {
        actionFormGroup.add(button);
        actionFormGroup.add(actionKebab);
    }
    actionItemMap.put(buttonDef, button);
}
#method_after
private void initButton(ActionButtonDefinition<T> buttonDef, ActionButton button) {
    button.setText(buttonDef.getText());
    // Set button element ID for better accessibility
    String buttonId = buttonDef.getUniqueId();
    if (buttonId != null) {
        button.asWidget().getElement().setId(ElementIdUtils.createElementId(getElementId(), buttonId));
    }
    // No insert available so need to remove the kebab and then add it at the end.
    actionFormGroup.remove(actionKebab);
    if (buttonDef.getIndex() >= actionFormGroup.getWidgetCount()) {
        // Add the button at the end
        actionFormGroup.add(button);
        actionFormGroup.add(actionKebab);
    } else {
        // Re-create ordered button list
        List<Widget> currentButtons = new ArrayList<>();
        for (int i = 0; i < actionFormGroup.getWidgetCount(); i++) {
            currentButtons.add(actionFormGroup.getWidget(i));
        }
        currentButtons.add(buttonDef.getIndex(), button.asWidget());
        // Re-add all buttons
        actionFormGroup.clear();
        currentButtons.forEach(existingButton -> actionFormGroup.add(existingButton));
        actionFormGroup.add(actionKebab);
    }
    actionItemMap.put(buttonDef, button);
}
#end_block

#method_before
public void addMenuPlaceActionButton(EntityType entityType, String label, ActionButtonInterface actionButtonInterface) {
    String historyToken = entityType.getMainHistoryToken();
    if (historyToken != null) {
        ActionButtonDefinition<?> actionButton = createButtonDefinition(label, actionButtonInterface);
        actionButton.setPriority(actionButtonInterface.getPriority());
        AddActionButtonEvent.fire(this, historyToken, actionButton);
    }
}
#method_after
public void addMenuPlaceActionButton(EntityType entityType, String label, ActionButtonInterface actionButtonInterface) {
    String historyToken = entityType.getMainHistoryToken();
    if (historyToken != null) {
        ActionButtonDefinition<?> actionButton = createButtonDefinition(label, actionButtonInterface);
        if (actionButtonInterface.isInMoreMenu()) {
            AddKebabMenuListItemEvent.fire(this, historyToken, actionButton);
        } else {
            AddActionButtonEvent.fire(this, historyToken, actionButton);
        }
    }
}
#end_block

#method_before
public void addDetailPlaceActionButton(EntityType mainTabEntityType, EntityType subTabEntityType, String label, ActionButtonInterface actionButtonInterface) {
    String historyToken = mainTabEntityType.getSubTabHistoryToken(subTabEntityType);
    if (historyToken != null) {
        ActionButtonDefinition<?> actionButton = createButtonDefinition(label, actionButtonInterface);
        actionButton.setPriority(actionButtonInterface.getPriority());
        AddActionButtonEvent.fire(this, historyToken, actionButton);
    }
}
#method_after
public void addDetailPlaceActionButton(EntityType mainTabEntityType, EntityType subTabEntityType, String label, ActionButtonInterface actionButtonInterface) {
    String historyToken = mainTabEntityType.getSubTabHistoryToken(subTabEntityType);
    if (historyToken != null) {
        ActionButtonDefinition<?> actionButton = createButtonDefinition(label, actionButtonInterface);
        if (actionButtonInterface.isInMoreMenu()) {
            AddKebabMenuListItemEvent.fire(this, historyToken, actionButton);
        } else {
            AddActionButtonEvent.fire(this, historyToken, actionButton);
        }
    }
}
#end_block

#method_before
<T> ActionButtonDefinition<T> createButtonDefinition(String label, final ActionButtonInterface actionButtonInterface) {
    return new AbstractButtonDefinition<T>(eventBus, label) {

        @Override
        public void onClick(List<T> selectedItems) {
            actionButtonInterface.onClick().invoke(EntityObject.arrayFrom(selectedItems != null ? selectedItems : Collections.emptyList()), null);
        }

        @Override
        public boolean isEnabled(List<T> selectedItems) {
            return JsFunctionResultHelper.invokeAndGetResultAsBoolean(actionButtonInterface.isEnabled(), EntityObject.arrayFrom(selectedItems != null ? selectedItems : Collections.emptyList()), null, true);
        }

        @Override
        public boolean isAccessible(List<T> selectedItems) {
            return JsFunctionResultHelper.invokeAndGetResultAsBoolean(actionButtonInterface.isAccessible(), EntityObject.arrayFrom(selectedItems != null ? selectedItems : Collections.emptyList()), null, true);
        }
    };
}
#method_after
<T> ActionButtonDefinition<T> createButtonDefinition(String label, ActionButtonInterface actionButtonInterface) {
    return new AbstractButtonDefinition<T>(eventBus, label) {

        @Override
        public void onClick(List<T> selectedItems) {
            actionButtonInterface.onClick().invoke(EntityObject.arrayFrom(selectedItems != null ? selectedItems : Collections.emptyList()), null);
        }

        @Override
        public boolean isEnabled(List<T> selectedItems) {
            return JsFunctionResultHelper.invokeAndGetResultAsBoolean(actionButtonInterface.isEnabled(), EntityObject.arrayFrom(selectedItems != null ? selectedItems : Collections.emptyList()), null, true);
        }

        @Override
        public boolean isAccessible(List<T> selectedItems) {
            return JsFunctionResultHelper.invokeAndGetResultAsBoolean(actionButtonInterface.isAccessible(), EntityObject.arrayFrom(selectedItems != null ? selectedItems : Collections.emptyList()), null, true);
        }

        @Override
        public int getIndex() {
            return actionButtonInterface.getIndex();
        }
    };
}
#end_block

#method_before
public void addMenuItem(ActionButton actionButton, int order) {
    if (order > kebabMenu.getWidgetCount()) {
        kebabMenu.add(actionButton);
    } else {
        // Order should never be < 0
        kebabMenu.insert(actionButton.asWidget(), order);
    }
}
#method_after
public void addMenuItem(ActionButton actionButton) {
    addMenuItem(actionButton, Integer.MAX_VALUE);
}
#end_block

#method_before
public void addMenuItem(ActionButton actionButton, int order) {
    if (order > kebabMenu.getWidgetCount()) {
        kebabMenu.add(actionButton);
    } else {
        // Order should never be < 0
        kebabMenu.insert(actionButton.asWidget(), order);
    }
}
#method_after
public void addMenuItem(ActionButton actionButton, int index) {
    if (index > kebabMenu.getWidgetCount()) {
        kebabMenu.add(actionButton);
    } else {
        kebabMenu.insert(actionButton.asWidget(), index);
    }
}
#end_block

#method_before
@Override
public void dataCenterWithClusterSelectedItemChanged() {
    super.dataCenterWithClusterSelectedItemChanged();
    if (snapshotId != null) {
        AsyncDataProvider.getInstance().getVmConfigurationBySnapshot(asyncQuery(vm -> {
            List<Disk> snapshotDisks = vm.getStaticData().getDiskList().stream().map(diskImage -> (Disk) diskImage).collect(Collectors.toList());
            InitDisksAndStorageDomains(snapshotDisks);
        }), snapshotId);
    } else {
        // If a VM has at least one disk, present its storage domain.
        AsyncDataProvider.getInstance().getVmDiskList(asyncQuery(vmDisks -> InitDisksAndStorageDomains(vmDisks)), vm.getId(), true);
    }
}
#method_after
@Override
public void dataCenterWithClusterSelectedItemChanged() {
    super.dataCenterWithClusterSelectedItemChanged();
    if (snapshotId != null) {
        // In case of creating a template from a snapshot, the snapshot VM configuration is needed
        AsyncDataProvider.getInstance().getVmConfigurationBySnapshot(asyncQuery(vm -> initDisksAndStorageDomains(new ArrayList<>(vm.getDiskMap().values()))), snapshotId);
    } else {
        // If a VM has at least one disk, present its storage domain.
        AsyncDataProvider.getInstance().getVmDiskList(asyncQuery(this::initDisksAndStorageDomains), vm.getId(), true);
    }
}
#end_block

#method_before
private void writeFeatures() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    // Currently only
    // <features>
    // <acpi/>
    // <features/>
    // for hyperv:
    // <features>
    // <acpi/>
    // <hyperv>
    // <relaxed state='on'/>
    // </hyperv>
    // <features/>
    boolean acpiEnabled = vm.getAcpiEnable();
    if (!acpiEnabled && !hypervEnabled) {
        return;
    }
    writer.writeStartElement("features");
    if (acpiEnabled) {
        writer.writeStartElement("acpi");
        writer.writeEndElement();
    }
    if (hypervEnabled) {
        writer.writeStartElement("hyperv");
        writer.writeStartElement("relaxed");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("vapic");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("spinlocks");
        writer.writeAttributeString("state", "on");
        writer.writeAttributeString("retries", "8191");
        writer.writeEndElement();
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeFeatures() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    // Currently only
    // <features>
    // <acpi/>
    // <features/>
    // for hyperv:
    // <features>
    // <acpi/>
    // <hyperv>
    // <relaxed state='on'/>
    // </hyperv>
    // <features/>
    boolean acpiEnabled = vm.getAcpiEnable();
    boolean kaslr = vmInfoBuildUtils.isKASLRDumpEnabled(vm.getVmOsId());
    if (!acpiEnabled && !hypervEnabled && !kaslr) {
        return;
    }
    writer.writeStartElement("features");
    if (acpiEnabled) {
        writer.writeStartElement("acpi");
        writer.writeEndElement();
    }
    if (hypervEnabled) {
        writer.writeStartElement("hyperv");
        writer.writeStartElement("relaxed");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("vapic");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("spinlocks");
        writer.writeAttributeString("state", "on");
        writer.writeAttributeString("retries", "8191");
        writer.writeEndElement();
        writer.writeEndElement();
    }
    if (kaslr) {
        writer.writeElement("vmcoreinfo");
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writeLeases();
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllersForDomainXml(devices));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writeLeases();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeGraphics(VmDevice device) {
    GraphicsType graphicsType = GraphicsType.fromString(device.getDevice());
    if (graphicsType == null) {
        log.error("Unsupported graphics type: {}", device.getDevice());
        return;
    }
    // <graphics type='spice' port='5900' tlsPort='5901' autoport='yes'
    // listen='0' keymap='en-us'
    // passwdValidTo='1970-01-01T00:00:01'>
    // <listen type='address' address='0'/>
    // <clipboard copypaste='no'/>
    // </graphics>
    // or:
    // <graphics type='vnc' port='5900' autoport='yes' listen='0'
    // keymap='en-us' passwdValidTo='1970-01-01T00:00:01'>
    // <listen type='address' address='0'/>
    // </graphics>
    writer.writeStartElement("graphics");
    writer.writeAttributeString("type", device.getDevice());
    writer.writeAttributeString("port", String.valueOf(LIBVIRT_PORT_AUTOSELECT));
    writer.writeAttributeString("autoport", "yes");
    // TODO: defaultMode
    writer.writeAttributeString("passwd", "*****");
    writer.writeAttributeString("passwdValidTo", "1970-01-01T00:00:01");
    Network displayNetwork = vmInfoBuildUtils.getDisplayNetwork(vm);
    if (displayNetwork == null) {
        writer.writeAttributeString("listen", "0");
    }
    switch(graphicsType) {
        case SPICE:
            writer.writeAttributeString("tlsPort", String.valueOf(LIBVIRT_PORT_AUTOSELECT));
            if (!vm.isSpiceFileTransferEnabled()) {
                writer.writeStartElement("filetransfer");
                writer.writeAttributeString("enable", "no");
                writer.writeEndElement();
            }
            if (!vm.isSpiceCopyPasteEnabled()) {
                writer.writeStartElement("clipboard");
                writer.writeAttributeString("copypaste", "no");
                writer.writeEndElement();
            }
            if ((boolean) Config.getValue(ConfigValues.SSLEnabled)) {
                String channels = Config.getValue(ConfigValues.SpiceSecureChannels, vm.getCompatibilityVersion().toString());
                adjustSpiceSecureChannels(channels.split(",")).forEach(channel -> {
                    writer.writeStartElement("channel");
                    writer.writeAttributeString("name", channel);
                    writer.writeAttributeString("mode", "secure");
                    writer.writeEndElement();
                });
            }
            break;
        case VNC:
            writer.writeAttributeString("keymap", vm.getDynamicData().getVncKeyboardLayout() != null ? vm.getDynamicData().getVncKeyboardLayout() : vm.getDefaultVncKeyboardLayout() != null ? vm.getDefaultVncKeyboardLayout() : Config.getValue(ConfigValues.VncKeyboardLayout));
            break;
    }
    if (displayNetwork != null) {
        writer.writeStartElement("listen");
        String displayIp = (String) device.getSpecParams().get("displayIp");
        if (displayIp == null) {
            writer.writeAttributeString("type", "network");
            writer.writeAttributeString("network", String.format("vdsm-%s", displayNetwork.getName()));
        } else {
            writer.writeAttributeString("type", "address");
            writer.writeAttributeString("address", displayIp);
        }
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeGraphics(VmDevice device) {
    GraphicsType graphicsType = GraphicsType.fromString(device.getDevice());
    if (graphicsType == null) {
        log.error("Unsupported graphics type: {}", device.getDevice());
        return;
    }
    // <graphics type='spice' port='5900' tlsPort='5901' autoport='yes'
    // listen='0' keymap='en-us'
    // passwdValidTo='1970-01-01T00:00:01'>
    // <listen type='address' address='0'/>
    // <clipboard copypaste='no'/>
    // </graphics>
    // or:
    // <graphics type='vnc' port='5900' autoport='yes' listen='0'
    // keymap='en-us' passwdValidTo='1970-01-01T00:00:01'>
    // <listen type='address' address='0'/>
    // </graphics>
    writer.writeStartElement("graphics");
    writer.writeAttributeString("type", device.getDevice());
    writer.writeAttributeString("port", String.valueOf(LIBVIRT_PORT_AUTOSELECT));
    writer.writeAttributeString("autoport", "yes");
    // TODO: defaultMode
    writer.writeAttributeString("passwd", "*****");
    writer.writeAttributeString("passwdValidTo", "1970-01-01T00:00:01");
    Network displayNetwork = vmInfoBuildUtils.getDisplayNetwork(vm);
    if (displayNetwork == null) {
        writer.writeAttributeString("listen", "0");
    }
    switch(graphicsType) {
        case SPICE:
            writer.writeAttributeString("tlsPort", String.valueOf(LIBVIRT_PORT_AUTOSELECT));
            if (!vm.isSpiceFileTransferEnabled()) {
                writer.writeStartElement("filetransfer");
                writer.writeAttributeString("enable", "no");
                writer.writeEndElement();
            }
            if (!vm.isSpiceCopyPasteEnabled()) {
                writer.writeStartElement("clipboard");
                writer.writeAttributeString("copypaste", "no");
                writer.writeEndElement();
            }
            if ((boolean) Config.getValue(ConfigValues.SSLEnabled)) {
                String channels = Config.getValue(ConfigValues.SpiceSecureChannels, vm.getCompatibilityVersion().toString());
                adjustSpiceSecureChannels(channels.split(",")).forEach(channel -> {
                    writer.writeStartElement("channel");
                    writer.writeAttributeString("name", channel);
                    writer.writeAttributeString("mode", "secure");
                    writer.writeEndElement();
                });
            }
            break;
        case VNC:
            writer.writeAttributeString("keymap", vm.getDynamicData().getVncKeyboardLayout() != null ? vm.getDynamicData().getVncKeyboardLayout() : vm.getDefaultVncKeyboardLayout() != null ? vm.getDefaultVncKeyboardLayout() : Config.getValue(ConfigValues.VncKeyboardLayout));
            break;
    }
    if (displayNetwork != null) {
        writer.writeStartElement("listen");
        String displayIp = (String) device.getSpecParams().get("displayIp");
        if (displayIp == null) {
            writer.writeAttributeString("type", "network");
            writer.writeAttributeString("network", String.format("vdsm-%s", displayNetwork.getVdsmName()));
        } else {
            writer.writeAttributeString("type", "address");
            writer.writeAttributeString("address", displayIp);
        }
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDisk(VmDevice device, Disk disk, DiskVmElement dve, String dev, int pinTo) {
    // <disk type='file' device='disk' snapshot='no'>
    // <driver name='qemu' type='qcow2' cache='none'/>
    // <source file='/path/to/image'/>
    // <target dev='hda' bus='ide'/>
    // <serial>54-a672-23e5b495a9ea</serial>
    // </disk>
    writer.writeStartElement("disk");
    writeGeneralDiskAttributes(device, disk, dve);
    writeDiskTarget(dve, dev);
    writeDiskSource(disk, dev);
    writeDiskDriver(device, disk, dve, pinTo);
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    if (disk.getDiskStorageType() != DiskStorageType.LUN) {
        writer.writeElement("serial", disk.getId().toString());
    }
    if (device.getReadOnly()) {
        writer.writeElement("readonly");
    }
    if (device.getSnapshotId() == null && disk.isShareable()) {
        writer.writeElement("shareable");
    }
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        writeIoTune((DiskImage) disk);
    }
    if (disk.getDiskStorageType() == DiskStorageType.CINDER) /**
     * && case RBD
     */
    {
        writeNetworkDiskAuth((CinderDisk) disk);
    }
    writer.writeEndElement();
}
#method_after
private void writeDisk(VmDevice device, Disk disk, DiskVmElement dve, String dev, int pinTo) {
    // <disk type='file' device='disk' snapshot='no'>
    // <driver name='qemu' type='qcow2' cache='none'/>
    // <source file='/path/to/image'/>
    // <target dev='hda' bus='ide'/>
    // <serial>54-a672-23e5b495a9ea</serial>
    // </disk>
    writer.writeStartElement("disk");
    writeGeneralDiskAttributes(device, disk, dve);
    writeDiskTarget(dve, dev);
    writeDiskSource(device, disk, dev);
    writeDiskDriver(device, disk, dve, pinTo);
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    if (disk.getDiskStorageType() != DiskStorageType.LUN) {
        writer.writeElement("serial", disk.getId().toString());
    }
    if (device.getReadOnly()) {
        writer.writeElement("readonly");
    }
    if (device.getSnapshotId() == null && disk.isShareable()) {
        writer.writeElement("shareable");
    }
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        writeIoTune((DiskImage) disk);
    }
    if (disk.getDiskStorageType() == DiskStorageType.CINDER) /**
     * && case RBD
     */
    {
        writeNetworkDiskAuth((CinderDisk) disk);
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskDriver(VmDevice device, Disk disk, DiskVmElement dve, int pinTo) {
    writer.writeStartElement("driver");
    writer.writeAttributeString("name", "qemu");
    if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion()) && dve.isPassDiscard()) {
        writer.writeAttributeString("discard", "unmap");
    }
    if (pinTo > 0) {
        writer.writeAttributeString("iothread", String.valueOf(pinTo));
    }
    boolean nativeIO = false;
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            nativeIO = !"file".equals(diskType);
            writer.writeAttributeString("io", nativeIO ? "native" : "threads");
            writer.writeAttributeString("type", diskImage.getVolumeFormat() == VolumeFormat.COW ? "qcow2" : "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case LUN:
            nativeIO = true;
            writer.writeAttributeString("io", "native");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("io", "threads");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", "stop");
            break;
    }
    if (device.getSnapshotId() != null) {
        // transient disk
        /**
         *            Force the cache to be writethrough, which is qemu's default.
         *            This is done to ensure that we don't ever use cache=none for
         *            transient disks, since we create them in /var/run/vdsm which
         *            may end up on tmpfs and don't support O_DIRECT, and qemu uses
         *            O_DIRECT when cache=none and hence hotplug might fail with
         *            error that one can take eternity to debug the reason behind it!
         */
        writer.writeAttributeString("cache", "writethrough");
    } else {
        switch(dve.getDiskInterface()) {
            case VirtIO:
            case VirtIO_SCSI:
                String viodiskcache = vmCustomProperties.get("viodiskcache");
                if (viodiskcache != null && !nativeIO) {
                    writer.writeAttributeString("cache", viodiskcache);
                    break;
                }
            default:
                writer.writeAttributeString("cache", "none");
        }
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskDriver(VmDevice device, Disk disk, DiskVmElement dve, int pinTo) {
    writer.writeStartElement("driver");
    writer.writeAttributeString("name", "qemu");
    if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion()) && dve.isPassDiscard()) {
        writer.writeAttributeString("discard", "unmap");
    }
    if (pinTo > 0) {
        writer.writeAttributeString("iothread", String.valueOf(pinTo));
    }
    boolean nativeIO = false;
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage, device);
            nativeIO = !"file".equals(diskType);
            writer.writeAttributeString("io", nativeIO ? "native" : "threads");
            writer.writeAttributeString("type", diskImage.getVolumeFormat() == VolumeFormat.COW ? "qcow2" : "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case LUN:
            nativeIO = true;
            writer.writeAttributeString("io", "native");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("io", "threads");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", "stop");
            break;
    }
    if (device.getSnapshotId() != null) {
        // transient disk
        /**
         *            Force the cache to be writethrough, which is qemu's default.
         *            This is done to ensure that we don't ever use cache=none for
         *            transient disks, since we create them in /var/run/vdsm which
         *            may end up on tmpfs and don't support O_DIRECT, and qemu uses
         *            O_DIRECT when cache=none and hence hotplug might fail with
         *            error that one can take eternity to debug the reason behind it!
         */
        writer.writeAttributeString("cache", "writethrough");
    } else {
        switch(dve.getDiskInterface()) {
            case VirtIO:
            case VirtIO_SCSI:
                String viodiskcache = vmCustomProperties.get("viodiskcache");
                if (viodiskcache != null && !nativeIO) {
                    writer.writeAttributeString("cache", viodiskcache);
                    break;
                }
            default:
                writer.writeAttributeString("cache", "none");
        }
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            // Change parameters for the HE disk
            if (vm.isHostedEngine()) {
                // Hosted engine disk images have to have empty storage pool ID,
                // so they can be mounted even if storage pool is not connected.
                diskImage.setStoragePoolId(Guid.Empty);
                diskImage.setPropagateErrors(PropagateErrors.Off);
                // The disk requires a lease
                addVolumeLease(diskImage.getImageId(), diskImage.getStorageIds().get(0));
            }
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    // drop to the 'file' case as a fallback.
                    if (volInfo != null) {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskSource(VmDevice device, Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            // Change parameters for the HE disk
            if (vm.isHostedEngine()) {
                // Hosted engine disk images have to have empty storage pool ID,
                // so they can be mounted even if storage pool is not connected.
                diskImage.setStoragePoolId(Guid.Empty);
                diskImage.setPropagateErrors(PropagateErrors.Off);
                // The disk requires a lease
                addVolumeLease(diskImage.getImageId(), diskImage.getStorageIds().get(0));
            }
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage, device);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    // drop to the 'file' case as a fallback.
                    if (volInfo != null) {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeGeneralDiskAttributes(VmDevice device, Disk disk, DiskVmElement dve) {
    writer.writeAttributeString("snapshot", "no");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            writer.writeAttributeString("type", this.vmInfoBuildUtils.getDiskType(this.vm, (DiskImage) disk));
            break;
        case LUN:
            writer.writeAttributeString("type", "block");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("type", "network");
            break;
    }
    switch(dve.getDiskInterface()) {
        case VirtIO_SCSI:
            if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                writer.writeAttributeString("device", VmDeviceType.LUN.getName());
                writer.writeAttributeString("sgio", disk.getSgio().toString().toLowerCase());
                break;
            }
        default:
            writer.writeAttributeString("device", device.getDevice());
    }
}
#method_after
private void writeGeneralDiskAttributes(VmDevice device, Disk disk, DiskVmElement dve) {
    writer.writeAttributeString("snapshot", "no");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            writer.writeAttributeString("type", this.vmInfoBuildUtils.getDiskType(this.vm, (DiskImage) disk, device));
            break;
        case LUN:
            writer.writeAttributeString("type", "block");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("type", "network");
            break;
    }
    switch(dve.getDiskInterface()) {
        case VirtIO_SCSI:
            if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                writer.writeAttributeString("device", VmDeviceType.LUN.getName());
                writer.writeAttributeString("sgio", disk.getSgio().toString().toLowerCase());
                break;
            }
        default:
            writer.writeAttributeString("device", device.getDevice());
    }
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    writer.writeStartElement("mtu");
    writer.writeAttributeString("size", String.valueOf(NetworkUtils.getMtuActualValue(network)));
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    if (!networkless) {
        writer.writeStartElement("mtu");
        writer.writeAttributeString("size", String.valueOf(NetworkUtils.getVmMtuActualValue(network)));
        writer.writeEndElement();
    }
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void refreshBrickDetails(GlusterVolumeEntity volume, GlusterVolumeAdvancedDetails volumeAdvancedDetails, Map<Guid, GlusterLocalVolumeInfo> localVolumeInfo) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<>();
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            if (brickProperties.getDevice() != null) {
                brickProperties.setConfirmedFreeSize(localVolumeInfo.get(brick.getServerId()).getAvailableThinSizeForDevice(brickProperties.getDevice()).map(Long::doubleValue).map(v -> v / SizeConverter.BYTES_IN_MB).orElseGet(null));
                brickProperties.setConfirmedTotalSize(localVolumeInfo.get(brick.getServerId()).getTotalThinSizeForDevice(brickProperties.getDevice()).map(Long::doubleValue).map(v -> v / SizeConverter.BYTES_IN_MB).orElseGet(null));
            }
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        brickDao.addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        brickDao.updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        brickDao.updateBrickStatuses(bricksToUpdate);
    }
}
#method_after
private void refreshBrickDetails(GlusterVolumeEntity volume, GlusterVolumeAdvancedDetails volumeAdvancedDetails, Map<Guid, GlusterLocalVolumeInfo> localVolumeInfo) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<>();
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            if (brickProperties.getDevice() != null) {
                brickProperties.setConfirmedFreeSize(localVolumeInfo.get(brick.getServerId()).getAvailableThinSizeForDevice(brickProperties.getDevice()).map(Long::doubleValue).map(v -> v / SizeConverter.BYTES_IN_MB).orElse(null));
                brickProperties.setConfirmedTotalSize(localVolumeInfo.get(brick.getServerId()).getTotalThinSizeForDevice(brickProperties.getDevice()).map(Long::doubleValue).map(v -> v / SizeConverter.BYTES_IN_MB).orElse(null));
            }
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        brickDao.addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        brickDao.updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        brickDao.updateBrickStatuses(bricksToUpdate);
    }
}
#end_block

#method_before
private void refreshVolumeCapacity(GlusterVolumeEntity volume, GlusterVolumeAdvancedDetails volumeAdvancedDetails) {
    Long confirmedFreeSize = calculateConfirmedVolumeCapacity(volume);
    if (volume.getAdvancedDetails().getCapacityInfo() == null) {
        volumeDao.addVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
    } else {
        volumeAdvancedDetails.getCapacityInfo().setConfirmedFreeSize(confirmedFreeSize);
        volumeDao.updateVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
    }
    if (confirmedFreeSize != null) {
        Long percentUsedSize = (1 - confirmedFreeSize / calculateConfirmedVolumeTotal(volume)) * 100;
        List<Guid> sdId = storageDomainStaticDao.getAllForStoragePool(clusterDao.get(volume.getClusterId()).getStoragePoolId()).stream().map(StorageDomainStatic::getId).filter(sd -> storageServerConnectionDao.getAllForDomain(sd).stream().anyMatch(c -> volume.getId().equals(c.getGlusterVolumeId()))).collect(Collectors.toList());
        sdId.stream().map(i -> storageDomainDynamicDao.get(i)).forEach(d -> {
            d.setConfirmedAvailableDiskSize((int) (confirmedFreeSize / SizeConverter.BYTES_IN_GB));
            storageDomainDynamicDao.updateConfirmedSize(d);
        });
        sdId.stream().map(storageDomainStaticDao::get).filter(s -> s.getWarningLowConfirmedSpaceIndicator() != null).filter(s -> s.getWarningLowConfirmedSpaceIndicator() < percentUsedSize).forEach(sd -> {
            AuditLogable event = new AuditLogableImpl();
            event.setStorageDomainId(sd.getId());
            event.setStorageDomainName(sd.getName());
            event.setRepeatable(true);
            event.addCustomValue("DiskSpace", confirmedFreeSize.toString());
            auditLogDirector.log(event, AuditLogType.IRS_CONFIRMED_DISK_SPACE_LOW);
        });
    }
}
#method_after
private void refreshVolumeCapacity(GlusterVolumeEntity volume, GlusterVolumeAdvancedDetails volumeAdvancedDetails) {
    Long confirmedFreeSize = calculateConfirmedVolumeCapacity(volume);
    if (volume.getAdvancedDetails().getCapacityInfo() == null) {
        volumeDao.addVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
    } else {
        volumeAdvancedDetails.getCapacityInfo().setConfirmedFreeSize(confirmedFreeSize);
        volumeDao.updateVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
    }
    if (confirmedFreeSize != null) {
        Long confirmedTotalSize = calculateConfirmedVolumeTotal(volume);
        Double percentUsedSize = (1 - confirmedFreeSize.doubleValue() / confirmedTotalSize) * 100;
        List<Guid> sdId = storageDomainStaticDao.getAllForStoragePool(clusterDao.get(volume.getClusterId()).getStoragePoolId()).stream().map(StorageDomainStatic::getId).filter(sd -> storageServerConnectionDao.getAllForDomain(sd).stream().anyMatch(c -> volume.getId().equals(c.getGlusterVolumeId()))).collect(Collectors.toList());
        sdId.stream().map(i -> storageDomainDynamicDao.get(i)).forEach(d -> {
            d.setConfirmedAvailableDiskSize((int) (confirmedFreeSize / SizeConverter.BYTES_IN_GB));
            storageDomainDynamicDao.updateConfirmedSize(d);
        });
        sdId.stream().map(storageDomainStaticDao::get).filter(s -> s.getWarningLowConfirmedSpaceIndicator() != null).filter(s -> s.getWarningLowConfirmedSpaceIndicator() < percentUsedSize).forEach(sd -> {
            AuditLogable event = new AuditLogableImpl();
            event.setStorageDomainId(sd.getId());
            event.setStorageDomainName(sd.getName());
            event.setRepeatable(true);
            event.addCustomValue("DiskSpace", String.valueOf(confirmedFreeSize / SizeConverter.BYTES_IN_GB));
            auditLogDirector.log(event, AuditLogType.IRS_CONFIRMED_DISK_SPACE_LOW);
        });
    }
}
#end_block

#method_before
private Long calculateConfirmedVolume(GlusterVolumeEntity volume, Function<BrickProperties, Double> field) {
    List<BrickProperties> bricks = volume.getBricks().stream().map(GlusterBrickEntity::getId).map(b -> brickDao.getById(b)).filter(Objects::nonNull).map(GlusterBrickEntity::getBrickProperties).collect(Collectors.toList());
    if (bricks.stream().map(BrickProperties::getConfirmedFreeSize).anyMatch(Objects::isNull)) {
        // If we have bricks missing confirmed size, we can't calculate it for the volume.
        log.info("Volume {} have non-thin bricks, skipping confirmed free size calculation", volume.getName());
        return null;
    }
    Stream<Double> brickSizes = bricks.stream().map(field).map(v -> v * 1024 * 1024);
    switch(volume.getVolumeType()) {
        case REPLICATE:
            return brickSizes.map(Double::longValue).min(Long::compare).orElseGet(null);
        case DISTRIBUTE:
        case DISTRIBUTED_REPLICATE:
        case STRIPE:
        case DISTRIBUTED_STRIPE:
        case STRIPED_REPLICATE:
        case DISTRIBUTED_STRIPED_REPLICATE:
        case DISPERSE:
        default:
            return brickSizes.mapToLong(Double::longValue).sum();
    }
}
#method_after
private Long calculateConfirmedVolume(GlusterVolumeEntity volume, Function<BrickProperties, Double> field) {
    List<BrickProperties> bricks = volume.getBricks().stream().map(GlusterBrickEntity::getId).map(b -> brickDao.getById(b)).filter(Objects::nonNull).map(GlusterBrickEntity::getBrickProperties).collect(Collectors.toList());
    if (bricks.stream().map(BrickProperties::getConfirmedFreeSize).anyMatch(Objects::isNull)) {
        // If we have bricks missing confirmed size, we can't calculate it for the volume.
        log.info("Volume {} have non-thin bricks, skipping confirmed free size calculation", volume.getName());
        return null;
    }
    Stream<Double> brickSizes = bricks.stream().map(field).map(v -> v * 1024 * 1024);
    switch(volume.getVolumeType()) {
        case REPLICATE:
            return brickSizes.map(Double::longValue).min(Long::compare).orElse(null);
        case DISTRIBUTE:
        case DISTRIBUTED_REPLICATE:
        case STRIPE:
        case DISTRIBUTED_STRIPE:
        case STRIPED_REPLICATE:
        case DISTRIBUTED_STRIPED_REPLICATE:
        case DISPERSE:
        default:
            return brickSizes.mapToLong(Double::longValue).sum();
    }
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    getView().setPlaceTransitionHandler(this);
    registerHandler(getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        // Update main model selection
        modelProvider.setSelectedItems(getSelectedItems());
        // Let others know that the table selection has changed
        fireTableSelectionChangeEvent();
    }));
    registerHandler(getEventBus().addHandler(ApplySearchStringEvent.getType(), event -> {
        applySearchString(event.getSearchString());
    }));
    modelProvider.getModel().getPropertyChangedEvent().addListener((event, sender, args) -> {
        // Update search string when 'SearchString' property changes
        if ("SearchString".equals(args.propertyName)) {
            // $NON-NLS-1$
            placeManager.setFragmentParameters(getFragmentParameters(modelProvider.getModel().getSearchString()));
        }
    });
    registerHandler(getView().addWindowResizeHandler(e -> {
        if (!resizing) {
            Scheduler.get().scheduleDeferred(() -> {
                getView().resizeToFullHeight();
                resizing = false;
            });
            resizing = true;
        }
    }));
    String searchString = searchStringCollector.getSearchStringPrefix(modelProvider.getModel().getSearchString());
    if (searchString != null) {
        // Someone set search string before we were instantiated, update the search string.
        applySearchString(searchString);
    }
    Scheduler.get().scheduleDeferred(() -> addPluginActionButtons(actionButtonPluginHandler.getButtons(getProxy().getNameToken()), false));
    Scheduler.get().scheduleDeferred(() -> addPluginActionButtons(actionButtonPluginHandler.getMenuItems(getProxy().getNameToken()), true));
    registerHandler(getEventBus().addHandler(AddActionButtonEvent.getType(), event -> {
        if (getProxy().getNameToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList, false);
        }
    }));
    registerHandler(getEventBus().addHandler(AddKebabMenuListItemEvent.getType(), event -> {
        if (getProxy().getNameToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList, true);
        }
    }));
    if (hasSearchPanelPresenterWidget()) {
        setInSlot(TYPE_SetSearchPanel, searchPanelPresenterWidget);
    }
    if (hasActionPanelPresenterWidget()) {
        setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
    }
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    getView().setPlaceTransitionHandler(this);
    registerHandler(getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        // Update main model selection
        modelProvider.setSelectedItems(getSelectedItems());
        // Let others know that the table selection has changed
        fireTableSelectionChangeEvent();
    }));
    registerHandler(getEventBus().addHandler(ApplySearchStringEvent.getType(), event -> {
        applySearchString(event.getSearchString());
    }));
    modelProvider.getModel().getPropertyChangedEvent().addListener((event, sender, args) -> {
        // Update search string when 'SearchString' property changes
        if ("SearchString".equals(args.propertyName)) {
            // $NON-NLS-1$
            placeManager.setFragmentParameters(getFragmentParameters(modelProvider.getModel().getSearchString()));
        }
    });
    registerHandler(getView().addWindowResizeHandler(e -> {
        if (!resizing) {
            Scheduler.get().scheduleDeferred(() -> {
                getView().resizeToFullHeight();
                resizing = false;
            });
            resizing = true;
        }
    }));
    String searchString = searchStringCollector.getSearchStringPrefix(modelProvider.getModel().getSearchString());
    if (searchString != null) {
        // Someone set search string before we were instantiated, update the search string.
        applySearchString(searchString);
    }
    Scheduler.get().scheduleDeferred(() -> {
        addPluginActionButtons(actionButtonPluginHandler.getButtons(getProxy().getNameToken()), false);
        addPluginActionButtons(actionButtonPluginHandler.getMenuItems(getProxy().getNameToken()), true);
    });
    registerHandler(getEventBus().addHandler(AddActionButtonEvent.getType(), event -> {
        if (getProxy().getNameToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList, false);
        }
    }));
    registerHandler(getEventBus().addHandler(AddKebabMenuListItemEvent.getType(), event -> {
        if (getProxy().getNameToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList, true);
        }
    }));
    if (hasSearchPanelPresenterWidget()) {
        setInSlot(TYPE_SetSearchPanel, searchPanelPresenterWidget);
    }
    if (hasActionPanelPresenterWidget()) {
        setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
    }
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    Scheduler.get().scheduleDeferred(() -> addPluginActionButtons(actionButtonPluginHandler.getButtons(getProxy().getTargetHistoryToken()), false));
    Scheduler.get().scheduleDeferred(() -> addPluginActionButtons(actionButtonPluginHandler.getMenuItems(getProxy().getTargetHistoryToken()), false));
    // Register this handler for whichever tab opens first, it is bound before the plugin fires its events and
    // before the actionButtonPluginHandler is instantiated and listening to events.
    registerHandler(getEventBus().addHandler(AddActionButtonEvent.getType(), event -> {
        if (getProxy().getTargetHistoryToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList, false);
        }
    }));
    registerHandler(getEventBus().addHandler(AddKebabMenuListItemEvent.getType(), event -> {
        if (getProxy().getTargetHistoryToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList, true);
        }
    }));
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    Scheduler.get().scheduleDeferred(() -> {
        addPluginActionButtons(actionButtonPluginHandler.getButtons(getProxy().getTargetHistoryToken()), false);
        addPluginActionButtons(actionButtonPluginHandler.getMenuItems(getProxy().getTargetHistoryToken()), true);
    });
    // Register this handler for whichever tab opens first, it is bound before the plugin fires its events and
    // before the actionButtonPluginHandler is instantiated and listening to events.
    registerHandler(getEventBus().addHandler(AddActionButtonEvent.getType(), event -> {
        if (getProxy().getTargetHistoryToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList, false);
        }
    }));
    registerHandler(getEventBus().addHandler(AddKebabMenuListItemEvent.getType(), event -> {
        if (getProxy().getTargetHistoryToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList, true);
        }
    }));
}
#end_block

#method_before
private void destroyVm() {
    runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(vdsManager.getVdsId(), getVmId(), null, false, 0, true));
}
#method_after
private void destroyVm() {
    DestroyVmVDSCommandParameters parameters = new DestroyVmVDSCommandParameters(vdsManager.getVdsId(), getVmId());
    parameters.setIgnoreNoVm(true);
    runVdsCommand(VDSCommandType.Destroy, parameters);
}
#end_block

#method_before
private void destroyVmOnDestinationHost() {
    VDSReturnValue destoryReturnValue = runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(dbVm.getMigratingToVds(), dbVm.getId(), false, 0));
    if (destoryReturnValue.getSucceeded()) {
        log.info("Stopped migrating VM: '{}'({}) on VDS: '{}'", dbVm.getId(), getVmManager().getName(), dbVm.getMigratingToVds());
    } else {
        log.info("Could not stop migrating VM: '{}'({}) on VDS: '{}', Error: '{}'", dbVm.getId(), getVmManager().getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
    }
}
#method_after
private void destroyVmOnDestinationHost() {
    VDSReturnValue destoryReturnValue = runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(dbVm.getMigratingToVds(), dbVm.getId()));
    if (destoryReturnValue.getSucceeded()) {
        log.info("Stopped migrating VM: '{}'({}) on VDS: '{}'", dbVm.getId(), getVmManager().getName(), dbVm.getMigratingToVds());
    } else {
        log.info("Could not stop migrating VM: '{}'({}) on VDS: '{}', Error: '{}'", dbVm.getId(), getVmManager().getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
    }
}
#end_block

#method_before
private void updateVmDynamicData() {
    if (vdsmVm.getVmDynamic().getGuestAgentNicsHash() != dbVm.getGuestAgentNicsHash()) {
        vmGuestAgentNics = filterGuestAgentInterfaces(vdsmVm.getVmGuestAgentInterfaces());
        dbVm.setIp(extractVmIpsFromGuestAgentInterfaces(vmGuestAgentNics));
    }
    // check if dynamic data changed - update cache and DB
    List<String> changedFields = getChangedFields(dbVm, vdsmVm.getVmDynamic());
    // remove all fields that should not be checked:
    changedFields.removeAll(UNCHANGEABLE_FIELDS_BY_VDSM);
    if (vdsmVm.getVmDynamic().getStatus() != VMStatus.Up) {
        changedFields.remove(VmDynamic.APPLICATIONS_LIST_FIELD_NAME);
        vdsmVm.getVmDynamic().setAppList(dbVm.getAppList());
    }
    // if something relevant changed
    if (!changedFields.isEmpty()) {
        dbVm.updateRuntimeData(vdsmVm.getVmDynamic(), vdsManager.getVdsId());
        saveDynamic(dbVm);
    }
}
#method_after
private void updateVmDynamicData() {
    if (vdsmVm.getVmDynamic().getGuestAgentNicsHash() != dbVm.getGuestAgentNicsHash()) {
        vmGuestAgentNics = filterGuestAgentInterfaces(nullToEmptyList(vdsmVm.getVmGuestAgentInterfaces()));
        dbVm.setIp(extractVmIps(vmGuestAgentNics));
    }
    // check if dynamic data changed - update cache and DB
    List<String> changedFields = getChangedFields(dbVm, vdsmVm.getVmDynamic());
    // remove all fields that should not be checked:
    changedFields.removeAll(UNCHANGEABLE_FIELDS_BY_VDSM);
    if (vdsmVm.getVmDynamic().getStatus() != VMStatus.Up) {
        changedFields.remove(VmDynamic.APPLICATIONS_LIST_FIELD_NAME);
        vdsmVm.getVmDynamic().setAppList(dbVm.getAppList());
    }
    // if something relevant changed
    if (!changedFields.isEmpty()) {
        dbVm.updateRuntimeData(vdsmVm.getVmDynamic(), vdsManager.getVdsId());
        saveDynamic(dbVm);
    }
}
#end_block

#method_before
/**
 * * Helpers and sub-methods ***
 */
private List<VmGuestAgentInterface> filterGuestAgentInterfaces(List<VmGuestAgentInterface> nics) {
    nics = nics.stream().filter(this::isNotBlacklisted).collect(Collectors.toList());
    nics.forEach(this::filterIpv4Addresses);
    nics.forEach(this::filterIpv6Addresses);
    return nics;
}
#method_after
/**
 * * Helpers and sub-methods ***
 */
private List<VmGuestAgentInterface> filterGuestAgentInterfaces(List<VmGuestAgentInterface> nics) {
    if (!nics.isEmpty()) {
        nics = nics.stream().filter(this::isNotBlacklisted).collect(Collectors.toList());
        nics.forEach(this::filterIpv4Addresses);
        nics.forEach(this::filterIpv6Addresses);
    }
    return nics;
}
#end_block

#method_before
public List<VmGuestAgentInterface> getVmGuestAgentNics() {
    return vmGuestAgentNics != null ? vmGuestAgentNics : Collections.emptyList();
}
#method_after
public List<VmGuestAgentInterface> getVmGuestAgentNics() {
    return vmGuestAgentNics;
}
#end_block

#method_before
private String guestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    Guid isoDomainId = getActiveIsoDomainId();
    if (osRepository.isWindows(getVm().getVmOsId()) && null != isoDomainId) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (new Version("4.4").equals(clusterVer)) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoImage> repoFilesMap = getIsoDomainListSynchronizer().getCachedIsoListByDomainId(isoDomainId, ImageFileType.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoImage map : repoFilesMap) {
            String fileName = StringUtils.defaultString(map.getRepoImageId(), "");
            Matcher matchToolPattern = Pattern.compile(IsoDomainListSynchronizer.REGEX_TOOL_PATTERN).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                Version clusterVer = new Version(matchToolPattern.group(IsoDomainListSynchronizer.TOOL_CLUSTER_LEVEL));
                int toolVersion = Integer.parseInt(matchToolPattern.group(IsoDomainListSynchronizer.TOOL_VERSION));
                if (clusterVer.compareTo(getVm().getCompatibilityVersion()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if (clusterVer.equals(bestClusterVer) && toolVersion > bestToolVer) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (vmToolsClusterVersion.equals(bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = Integer.toString(bestToolVer);
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        String rhevToolsPath = String.format("%1$s%2$s_%3$s.iso", IsoDomainListSynchronizer.getGuestToolsSetupIsoPrefix(), selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) runVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getStoragePoolId())).getReturnValue();
        rhevToolsPath = isoDir + File.separator + rhevToolsPath;
        return rhevToolsPath;
    }
    return null;
}
#method_after
private String guestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    Guid isoDomainId = getActiveIsoDomainId();
    if (osRepository.isWindows(getVm().getVmOsId()) && null != isoDomainId) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (new Version("4.4").equals(clusterVer)) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoImage> repoFilesMap = getIsoDomainListSynchronizer().getCachedIsoListByDomainId(isoDomainId, ImageFileType.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoImage map : repoFilesMap) {
            String fileName = StringUtils.defaultString(map.getRepoImageId(), "");
            Matcher matchToolPattern = Pattern.compile(isoDomainListSynchronizer.getRegexToolPattern()).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                Version clusterVer = new Version(matchToolPattern.group(IsoDomainListSynchronizer.TOOL_CLUSTER_LEVEL));
                int toolVersion = Integer.parseInt(matchToolPattern.group(IsoDomainListSynchronizer.TOOL_VERSION));
                if (clusterVer.compareTo(getVm().getCompatibilityVersion()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if (clusterVer.equals(bestClusterVer) && toolVersion > bestToolVer) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (vmToolsClusterVersion.equals(bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = Integer.toString(bestToolVer);
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        String rhevToolsPath = String.format("%1$s%2$s_%3$s.iso", isoDomainListSynchronizer.getGuestToolsSetupIsoPrefix(), selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) runVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getStoragePoolId())).getReturnValue();
        rhevToolsPath = isoDir + File.separator + rhevToolsPath;
        return rhevToolsPath;
    }
    return null;
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    vmPoolMonitor.startingVmCompleted(getVmId(), "endWithFailure");
    if (shouldEndSnapshotCreation()) {
        ActionReturnValue actionReturnValue = backend.endAction(ActionType.CreateSnapshotForVm, getParameters().getImagesParameters().get(0), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(actionReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#method_after
@Override
protected void endWithFailure() {
    if (shouldEndSnapshotCreation()) {
        ActionReturnValue actionReturnValue = backend.endAction(ActionType.CreateSnapshotForVm, getParameters().getImagesParameters().get(0), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(actionReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
    if (getVm().getVmPoolId() != null) {
        vmPoolMonitor.startingVmCompleted(getVmId(), "endWithFailure");
    }
}
#end_block

#method_before
@Override
public void runningSucceded() {
    vmPoolMonitor.startingVmCompleted(getVmId(), "runningSucceded");
    removeMemoryFromActiveSnapshot();
    setFlow(RunVmFlow.RUNNING_SUCCEEDED);
    vmStaticDao.incrementDbGeneration(getVm().getId());
    super.runningSucceded();
}
#method_after
@Override
public void runningSucceded() {
    removeMemoryFromActiveSnapshot();
    setFlow(RunVmFlow.RUNNING_SUCCEEDED);
    vmStaticDao.incrementDbGeneration(getVm().getId());
    super.runningSucceded();
    if (getVm().getVmPoolId() != null) {
        vmPoolMonitor.startingVmCompleted(getVmId(), "runningSucceded");
    }
}
#end_block

#method_before
@Override
protected void runningFailed() {
    vmPoolMonitor.startingVmCompleted(getVmId(), "runningFailed");
    cleanupPassthroughVnics();
    if (memoryFromSnapshotUsed) {
        removeMemoryFromActiveSnapshot();
    }
    super.runningFailed();
}
#method_after
@Override
protected void runningFailed() {
    cleanupPassthroughVnics();
    if (memoryFromSnapshotUsed) {
        removeMemoryFromActiveSnapshot();
    }
    super.runningFailed();
    if (getVm().getVmPoolId() != null) {
        vmPoolMonitor.startingVmCompleted(getVmId(), "runningFailed");
    }
}
#end_block

#method_before
public void startingVmCompleted(Guid vmId, String cause) {
    log.info("Startup of VM {} completed ({})", vmId, cause);
    startingVms.remove(vmId);
}
#method_after
public void startingVmCompleted(Guid vmId, String cause) {
    if (startingVms.remove(vmId)) {
        log.debug("Startup of VM {} completed ({})", vmId, cause);
    }
}
#end_block

#method_before
@Override
protected List<DiskImage> getVmDisksFromDb() {
    VM vmFromConfiguration = getVmFromConfiguration();
    List<DiskImage> disksFromDb = DisksFilter.filterImageDisks(vmFromConfiguration.getDiskMap().values(), ONLY_SNAPABLE, ONLY_ACTIVE);
    disksFromDb.addAll(DisksFilter.filterCinderDisks(getVm().getDiskMap().values(), ONLY_PLUGGED));
    return disksFromDb;
}
#method_after
@Override
protected List<DiskImage> getVmDisksFromDb() {
    VM vmFromConfiguration = getVmFromConfiguration();
    if (vmFromConfiguration == null) {
        log.debug("No VM configuration found for snapshot id '{}'", getParameters().getSnapshotId());
        return Collections.emptyList();
    }
    List<DiskImage> disksFromDb = DisksFilter.filterImageDisks(vmFromConfiguration.getDiskMap().values(), ONLY_SNAPABLE, ONLY_ACTIVE);
    disksFromDb.addAll(DisksFilter.filterCinderDisks(getVm().getDiskMap().values(), ONLY_PLUGGED));
    return disksFromDb;
}
#end_block

#method_before
protected VM getVmFromConfiguration() {
    QueryReturnValue queryReturnValue = runInternalQuery(QueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(getParameters().getSnapshotId()));
    return queryReturnValue.getSucceeded() ? queryReturnValue.getReturnValue() : null;
}
#method_after
private VM getVmFromConfiguration() {
    QueryReturnValue queryReturnValue = runInternalQuery(QueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(getParameters().getSnapshotId()));
    return queryReturnValue.getSucceeded() ? queryReturnValue.getReturnValue() : null;
}
#end_block

#method_before
private void updateNics(List<NetworkInterfaceModel> nics) {
    nicList.clear();
    Collections.sort(nics);
    List<NetworkGroup> groups = new ArrayList<>();
    for (NetworkInterfaceModel nic : nics) {
        groups.add(new NetworkGroup(nic, eventBus, style));
    }
    nicList.addAll(groups, !rendered);
    nicGroups = groups;
}
#method_after
private void updateNics(List<NetworkInterfaceModel> nics) {
    nicList.clear();
    Collections.sort(nics);
    nicGroups = new ArrayList<>();
    for (NetworkInterfaceModel nic : nics) {
        nicGroups.add(new NetworkGroup(nic, eventBus, style));
    }
    nicList.addAll(nicGroups, !rendered);
}
#end_block

#method_before
private MenuBar menuFor(NetworkItemModel<?> item) {
    MenuBar menu = rootMenu(item);
    Map<NetworkOperation, List<NetworkCommand>> operationMap = item.getSetupModel().commandsFor(item);
    for (final Entry<NetworkOperation, List<NetworkCommand>> entry : operationMap.entrySet()) {
        final List<NetworkCommand> commands = entry.getValue();
        if (entry.getKey().isUnary()) {
            // $NON-NLS-1$
            assert commands.size() == 1 : "Got a NetworkCommand List with more than one Unary Operation";
            menu.addItem(entry.getKey().getVerb(item), () -> executeCommand(entry.getKey(), commands.get(0)));
        } else {
            // Collections.sort(commands, Comparator.comparing(NetworkCommand::getName, new LexoNumericComparator()));
            MenuBar subMenu = subMenu();
            for (final NetworkCommand command : commands) {
                subMenu.addItem(new MenuItem(command.getName(), () -> executeCommand(entry.getKey(), command)));
            }
            menu.addItem(entry.getKey().getVerb(item), subMenu);
        }
    }
    return menu;
}
#method_after
private MenuBar menuFor(NetworkItemModel<?> item) {
    MenuBar menu = rootMenu(item);
    Map<NetworkOperation, List<NetworkCommand>> operationMap = item.getSetupModel().commandsFor(item);
    for (final Entry<NetworkOperation, List<NetworkCommand>> entry : operationMap.entrySet()) {
        final List<NetworkCommand> commands = entry.getValue();
        if (entry.getKey().isUnary()) {
            // $NON-NLS-1$
            assert commands.size() == 1 : "Got a NetworkCommand List with more than one Unary Operation";
            menu.addItem(entry.getKey().getVerb(item), () -> executeCommand(entry.getKey(), commands.get(0)));
        } else {
            Collections.sort(commands, Comparator.comparing(NetworkCommand::getName, new LexoNumericComparator()));
            MenuBar subMenu = subMenu();
            for (final NetworkCommand command : commands) {
                subMenu.addItem(new MenuItem(command.getName(), () -> executeCommand(entry.getKey(), command)));
            }
            menu.addItem(entry.getKey().getVerb(item), subMenu);
        }
    }
    return menu;
}
#end_block

#method_before
private void applyVmInterfaceSpecificStyles() {
    mainInfoPanel.getElement().getStyle().setPaddingBottom(0, Style.Unit.PX);
    mainInfoPanel.getElement().getStyle().setPaddingTop(0, Style.Unit.PX);
    detailedInfoContainer.getElement().getStyle().setMarginLeft(0, Style.Unit.PX);
    detailedInfoContainer.getElement().getStyle().setWidth(100, Style.Unit.PCT);
    descriptionPanel.getElement().getStyle().setWidth(10, Style.Unit.PCT);
    descriptionHeaderPanel.getElement().getStyle().setWidth(100, Style.Unit.PCT);
    descriptionHeaderPanel.getElement().getStyle().setFontSize(20, Style.Unit.PX);
    descriptionPanel.removeStyleName(PatternflyConstants.PF_LIST_VIEW_DESCRIPTION);
}
#method_after
private void applyVmInterfaceSpecificStyles() {
    listGroupItem.addStyleName(NETWORK_LIST_ITEM);
    descriptionPanel.getElement().getStyle().setWidth(10, Style.Unit.PCT);
    descriptionPanel.removeStyleName(PatternflyConstants.PF_LIST_VIEW_DESCRIPTION);
}
#end_block

#method_before
protected ValidationResult macAvailable() {
    VmNic nic = getParameters().getNic();
    if (new VmInterfaceManager().tooManyPluggedInterfaceWithSameMac(nic, getMacPool())) {
        return new ValidationResult(EngineMessage.NETWORK_MAC_ADDRESS_IN_USE, ReplacementUtils.createSetVariableString(VAR_MAC_IN_USE, nic.getMacAddress()), ReplacementUtils.createSetVariableString(VAR_IN_USE_BY, getVm().getName()));
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult macAvailable() {
    VmNic nic = getParameters().getNic();
    Optional<VM> optionalVm = new VmInterfaceManager().getVmWithSameMacIfDuplicateIsNotAllowed(nic, getMacPool());
    if (optionalVm.isPresent()) {
        return new ValidationResult(EngineMessage.NETWORK_MAC_ADDRESS_IN_USE, ReplacementUtils.createSetVariableString(MacAddressValidator.VAR_MAC_ADDRESS, nic.getMacAddress()), ReplacementUtils.createSetVariableString(MacAddressValidator.VAR_VM_NAME, optionalVm.get().getName()));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult isMacAssignableValidator() {
    boolean allowDupMacs = macPool.isDuplicateMacAddressesAllowed();
    boolean illegalDuplicateMacUsage = !allowDupMacs && macPool.isMacInUse(macAddress);
    if (illegalDuplicateMacUsage) {
        Optional<VM> optionalVm = macsUsedAcrossWholeSystem.getVmUsingMac(macPool.getId(), macAddress);
        if (!optionalVm.isPresent()) {
            optionalVm = macsUsedAcrossWholeSystem.getSnapshotUsingMac(macPool.getId(), macAddress);
        }
        return new ValidationResult(EngineMessage.NETWORK_MAC_ADDRESS_IN_USE, ReplacementUtils.createSetVariableString(VAR_MAC_IN_USE, macAddress), ReplacementUtils.createSetVariableString(VAR_IN_USE_BY, optionalVm.isPresent() ? optionalVm.get().getName() : ""));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isMacAssignableValidator() {
    boolean allowDupMacs = macPool.isDuplicateMacAddressesAllowed();
    boolean illegalDuplicateMacUsage = !allowDupMacs && macPool.isMacInUse(macAddress);
    if (illegalDuplicateMacUsage) {
        Optional<VM> optionalVm = macsUsedAcrossWholeSystem.getVmUsingMac(macPool.getId(), macAddress);
        if (!optionalVm.isPresent()) {
            optionalVm = macsUsedAcrossWholeSystem.getSnapshotUsingMac(macPool.getId(), macAddress);
        }
        return new ValidationResult(EngineMessage.NETWORK_MAC_ADDRESS_IN_USE, ReplacementUtils.createSetVariableString(VAR_MAC_ADDRESS, macAddress), ReplacementUtils.createSetVariableString(VAR_VM_NAME, optionalVm.isPresent() ? optionalVm.get().getName() : ""));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public List<String> getMacsForMacPool(Guid macPoolId) {
    List<Guid> idsOfAllClustersHavingMacPool = getIdsOfAllClustersHavingMacPool(macPoolId);
    Map<Guid, VM> vmsById = getAllVmsInSystem(idsOfAllClustersHavingMacPool).collect(Collectors.toMap(VM::getId, Function.identity()));
    Stream<Guid> idsOfRunningStatelessVMs = getAllStatelessVms(vmsById.values()).map(VM::getId);
    Stream<VM> statelessSnapshotsOfRunningVMs = idsOfRunningStatelessVMs.map(snapshotsManager::getVmConfigurationInStatelessSnapshotOfVm).filter(Optional::isPresent).map(Optional::get);
    Map<Guid, List<VmNetworkInterface>> snapshottedInterfacesByVmId = statelessSnapshotsOfRunningVMs.collect(Collectors.toMap(VM::getId, VM::getInterfaces));
    List<String> macsToBeAllocated = vmsById.keySet().stream().flatMap(vmId -> calculateAllMacsUsedInVmAndItsSnapshot(getVmInterfaces(vmId), snapshottedInterfacesByVmId.get(vmId))).collect(Collectors.toList());
    return macsToBeAllocated;
}
#method_after
public List<String> getMacsForMacPool(Guid macPoolId) {
    List<Guid> idsOfAllClustersHavingMacPool = getIdsOfAllClustersHavingMacPool(macPoolId);
    Map<Guid, VM> vmsById = getAllVmsInClusters(idsOfAllClustersHavingMacPool).collect(Collectors.toMap(VM::getId, Function.identity()));
    Stream<Guid> idsOfRunningStatelessVMs = getAllStatelessVms(vmsById.values()).map(VM::getId);
    Stream<VM> statelessSnapshotsOfRunningVMs = idsOfRunningStatelessVMs.map(snapshotsManager::getVmConfigurationInStatelessSnapshotOfVm).filter(Optional::isPresent).map(Optional::get);
    Map<Guid, List<VmNetworkInterface>> snapshottedInterfacesByVmId = statelessSnapshotsOfRunningVMs.collect(Collectors.toMap(VM::getId, VM::getInterfaces));
    List<String> macsToBeAllocated = vmsById.keySet().stream().flatMap(vmId -> calculateAllMacsUsedInVmAndItsSnapshot(getVmInterfaces(vmId), snapshottedInterfacesByVmId.get(vmId))).collect(Collectors.toList());
    return macsToBeAllocated;
}
#end_block

#method_before
public Optional<VM> getVmUsingMac(Guid macPoolId, String mac) {
    Map<Guid, VM> vmsById = getAllVmsInSystem(getIdsOfAllClustersHavingMacPool(macPoolId)).filter(vm -> !vm.isStateless()).collect(Collectors.toMap(VM::getId, Function.identity()));
    Optional<Guid> vmUsingMacId = getVmIdUsingMac(vmsById.keySet().stream().flatMap(vmId -> getVmInterfaces(vmId).stream()), mac);
    return vmUsingMacId.map(vmsById::get);
}
#method_after
public Optional<VM> getVmUsingMac(Guid macPoolId, String mac) {
    Map<Guid, VM> vmsById = getAllVmsInClusters(getIdsOfAllClustersHavingMacPool(macPoolId)).collect(Collectors.toMap(VM::getId, Function.identity()));
    Optional<Guid> vmUsingMacId = getVmIdUsingMac(vmsById.keySet().stream().flatMap(vmId -> getVmInterfaces(vmId).stream()), mac);
    return vmUsingMacId.map(vmsById::get);
}
#end_block

#method_before
public Optional<VM> getSnapshotUsingMac(Guid macPoolId, String mac) {
    List<VM> allVms = getAllVmsInSystem(getIdsOfAllClustersHavingMacPool(macPoolId)).collect(Collectors.toList());
    Map<Guid, VM> snapshotsById = getAllStatelessVms(allVms).map(VM::getId).map(snapshotsManager::getVmConfigurationInStatelessSnapshotOfVm).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toMap(VM::getId, Function.identity()));
    Optional<Guid> snapshotUsingMacId = getVmIdUsingMac(snapshotsById.values().stream().flatMap(vm -> vm.getInterfaces().stream()), mac);
    return snapshotUsingMacId.map(snapshotsById::get);
}
#method_after
public Optional<VM> getSnapshotUsingMac(Guid macPoolId, String mac) {
    List<VM> allVms = getAllVmsInClusters(getIdsOfAllClustersHavingMacPool(macPoolId)).collect(Collectors.toList());
    Map<Guid, VM> snapshotsById = getAllStatelessVms(allVms).map(VM::getId).map(snapshotsManager::getVmConfigurationInStatelessSnapshotOfVm).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toMap(VM::getId, Function.identity()));
    Optional<Guid> snapshotUsingMacId = getVmIdUsingMac(snapshotsById.values().stream().flatMap(vm -> vm.getInterfaces().stream()), mac);
    return snapshotUsingMacId.map(snapshotsById::get);
}
#end_block

#method_before
public void loadVmFromOva() {
    clearForLoad();
    if (!validateOvaConfiguration()) {
        return;
    }
    startProgress();
    AsyncDataProvider.getInstance().getVmFromOva(new AsyncQuery<>(returnValue -> {
        if (returnValue.getSucceeded()) {
            Map<VM, String> vmToOva = returnValue.getReturnValue();
            List<VM> vms = new ArrayList<>(vmToOva.keySet());
            vmNameToOva = vms.stream().collect(Collectors.toMap(VM::getName, vm -> vmToOva.get(vm)));
            updateVms(vms);
        } else {
            setError(messages.failedToLoadOva(getOvaPath().getEntity()));
        }
        stopProgress();
    }), getHosts().getSelectedItem().getId(), getOvaPath().getEntity());
}
#method_after
public void loadVmFromOva() {
    clearForLoad();
    if (!validateOvaConfiguration()) {
        return;
    }
    startProgress();
    AsyncDataProvider.getInstance().getVmFromOva(new AsyncQuery<>(returnValue -> {
        if (returnValue.getSucceeded()) {
            Map<VM, String> vmToOva = returnValue.getReturnValue();
            vmNameToOva = vmToOva.entrySet().stream().collect(Collectors.toMap(e -> e.getKey().getName(), Entry::getValue));
            updateVms(vmToOva.keySet());
        } else {
            setError(messages.failedToLoadOva(getOvaPath().getEntity()));
        }
        stopProgress();
    }), getHosts().getSelectedItem().getId(), getOvaPath().getEntity());
}
#end_block

#method_before
private void updateVms(List<VM> vms) {
    clearVms();
    externalVmModels.setItems(vms.stream().map(EntityModel::new).collect(Collectors.toList()));
    stopProgress();
}
#method_after
private void updateVms(Collection<VM> vms) {
    clearVms();
    externalVmModels.setItems(vms.stream().map(EntityModel::new).collect(Collectors.toList()));
    stopProgress();
}
#end_block

#method_before
private Map<String, Object> createUsbControllerSpecParams(String model, int index) {
    final HashMap<String, Object> specParams = new HashMap<>();
    specParams.put(VdsProperties.Model, model);
    specParams.put(VdsProperties.Index, Integer.toString(index));
    return specParams;
}
#method_after
private Map<String, Object> createUsbControllerSpecParams(String model, int index) {
    final Map<String, Object> specParams = new HashMap<>();
    specParams.put(VdsProperties.Model, model);
    specParams.put(VdsProperties.Index, Integer.toString(index));
    return specParams;
}
#end_block

#method_before
protected DiskImage getDiskImage() {
    if (!Guid.isNullOrEmpty(getParameters().getImageId())) {
        setImageId(getParameters().getImageId());
        return super.getDiskImage();
    }
    return (DiskImage) diskDao.get(getParameters().getImageGroupID());
}
#method_after
protected DiskImage getDiskImage() {
    if (!Guid.isNullOrEmpty(getParameters().getImageId())) {
        setImageId(getParameters().getImageId());
        return super.getDiskImage();
    }
    DiskImage diskImage = super.getDiskImage();
    if (diskImage == null) {
        diskImage = (DiskImage) diskDao.get(getParameters().getImageGroupID());
    }
    return diskImage;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setType(getParameters().getTransferType());
    entity.setActive(false);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(getParameters().getTransferSize());
    imageTransferDao.save(entity);
    if (isImageProvided()) {
        handleImageIsReadyForTransfer();
    } else {
        if (getParameters().getTransferType() == TransferType.Download) {
            failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
            setSucceeded(false);
            return;
        }
        log.info("Creating {} image", getImageType());
        createImage();
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setType(getParameters().getTransferType());
    entity.setActive(false);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(getParameters().getTransferSize());
    entity.setClientInactivityTimeout(getParameters().getClientInactivityTimeout() != null ? getParameters().getClientInactivityTimeout() : getTransferImageClientInactivityTimeoutInSeconds());
    imageTransferDao.save(entity);
    if (isImageProvided()) {
        handleImageIsReadyForTransfer();
    } else {
        if (getParameters().getTransferType() == TransferType.Download) {
            failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
            setSucceeded(false);
            return;
        }
        log.info("Creating {} image", getImageType());
        createImage();
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#end_block

#method_before
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful transfer for {}", getTransferDescription());
    // If stopping the session did not succeed, don't change the transfer state.
    if (stopImageTransferSession(context.entity)) {
        Guid transferingVdsId = context.entity.getVdsId();
        // Verify image is relevant only on upload
        if (getParameters().getTransferType() == TransferType.Download) {
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
            setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else // We want to use the transferring vds for image actions for having a coherent log when transferring.
        if (verifyImage(transferingVdsId)) {
            setVolumeLegalityInStorage(LEGAL_IMAGE);
            if (getDiskImage().getVolumeFormat().equals(VolumeFormat.COW)) {
                setQcowCompat(getDiskImage().getImage(), getStoragePool().getId(), getDiskImage().getId(), getDiskImage().getImageId(), getStorageDomainId(), transferingVdsId);
                imageDao.update(getDiskImage().getImage());
            }
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
            setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else {
            setImageStatus(ImageStatus.ILLEGAL);
            updateEntityPhase(ImageTransferPhase.FINALIZING_FAILURE);
        }
        // Finished using the image, tear it down.
        tearDownImage(context.entity.getVdsId());
    }
}
#method_after
private void handleFinalizingSuccess(final StateContext context) {
    log.info("Finalizing successful transfer for {}", getTransferDescription());
    // If stopping the session did not succeed, don't change the transfer state.
    if (stopImageTransferSession(context.entity)) {
        Guid transferingVdsId = context.entity.getVdsId();
        // Verify image is relevant only on upload
        if (getParameters().getTransferType() == TransferType.Download) {
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
            setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else if (verifyImage(transferingVdsId)) {
            // We want to use the transferring vds for image actions for having a coherent log when transferring.
            setVolumeLegalityInStorage(LEGAL_IMAGE);
            if (getDiskImage().getVolumeFormat().equals(VolumeFormat.COW)) {
                setQcowCompat(getDiskImage().getImage(), getStoragePool().getId(), getDiskImage().getId(), getDiskImage().getImageId(), getStorageDomainId(), transferingVdsId);
                imageDao.update(getDiskImage().getImage());
            }
            unLockImage();
            updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
            setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_SUCCESS);
        } else {
            setImageStatus(ImageStatus.ILLEGAL);
            updateEntityPhase(ImageTransferPhase.FINALIZING_FAILURE);
        }
        // Finished using the image, tear it down.
        tearDownImage(context.entity.getVdsId());
    }
}
#end_block

#method_before
private boolean shouldAbortOnClientInactivityTimeout(ImageTransfer entity, long ts, Integer idleTimeFromTicket) {
    int inactivityTimeout = getTransferImageClientInactivityTimeoutInSeconds();
    // For new daemon (1.3.0), we check timeout according to 'idle_time' in ticket;
    // otherwise, fallback to check according to entity's 'lastUpdated'.
    boolean timeoutExceeded = idleTimeFromTicket != null ? idleTimeFromTicket > inactivityTimeout : ts > (entity.getLastUpdated().getTime() / 1000) + inactivityTimeout;
    return inactivityTimeout > 0 && timeoutExceeded && !entity.getActive();
}
#method_after
private boolean shouldAbortOnClientInactivityTimeout(ImageTransfer entity, long ts, Integer idleTimeFromTicket) {
    int inactivityTimeout = entity.getClientInactivityTimeout();
    // For new daemon (1.3.0), we check timeout according to 'idle_time' in ticket;
    // otherwise, fallback to check according to entity's 'lastUpdated'.
    boolean timeoutExceeded = idleTimeFromTicket != null ? idleTimeFromTicket > inactivityTimeout : ts > (entity.getLastUpdated().getTime() / 1000) + inactivityTimeout;
    return inactivityTimeout > 0 && timeoutExceeded && !entity.getActive();
}
#end_block

#method_before
// Return a string describing the transfer, safe for use before the new image
private String getTransferDescription() {
    return String.format("%s %s '%s' (id '%s')", getParameters().getTransferType().name(), getImageType(), getImageAlias(), getImageGroupIdNullSafe());
}
#method_after
// Return a string describing the transfer, safe for use before the new image
private String getTransferDescription() {
    return String.format("%s %s '%s' (disk id: '%s', image id: '%s')", getParameters().getTransferType().name(), getImageType(), getImageAlias(), getDiskImage().getId(), getDiskImage().getImageId());
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (getParameters().getTransferType() == TransferType.Upload) {
        // Do rollback only for upload
        super.endWithFailure();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    if (getParameters().getTransferType() == TransferType.Upload) {
        // Do rollback only for upload - i.e. remove the disk added in 'createImage()'
        runInternalAction(ActionType.RemoveDisk, new RemoveDiskParameters(getParameters().getImageGroupID()));
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    Guid createdSnapshotId = updateActiveSnapshotId();
    setActionReturnValue(createdSnapshotId);
    getParameters().setCreatedSnapshotId(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    freezeVm();
    ActionReturnValue actionReturnValue = createSnapshotsForDisks();
    if (actionReturnValue.getSucceeded()) {
        memoryImageBuilder.build();
        addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
        fastForwardDisksToActiveSnapshot();
        setSucceeded(true);
    } else {
        getParameters().setCreatedSnapshotId(null);
        setSucceeded(false);
    }
}
#method_after
@Override
protected void executeVmCommand() {
    Guid createdSnapshotId = updateActiveSnapshotId();
    setActionReturnValue(createdSnapshotId);
    getParameters().setCreatedSnapshotId(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    freezeVm();
    ActionReturnValue actionReturnValue = createSnapshotsForDisks();
    if (actionReturnValue.getSucceeded()) {
        memoryImageBuilder.build();
        addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
        fastForwardDisksToActiveSnapshot();
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getCreateSnapshotStage() == CreateSnapshotForVmParameters.CreateSnapshotStage.CREATE_VOLUME) {
        Snapshot createdSnapshot = snapshotDao.get(getParameters().getCreatedSnapshotId());
        // if the snapshot was not created in the DB
        // the command should also be handled as a failure
        getParameters().setTaskGroupSuccess(createdSnapshot != null && getParameters().getTaskGroupSuccess());
        if (getParameters().getTaskGroupSuccess()) {
            snapshotDao.updateStatus(createdSnapshot.getId(), Snapshot.SnapshotStatus.OK);
            getParameters().setLiveSnapshotRequired(shouldPerformLiveSnapshot(createdSnapshot));
            if (getParameters().isLiveSnapshotRequired()) {
                getParameters().setLiveSnapshotSucceeded(performLiveSnapshot(createdSnapshot));
            } else if (snapshotWithMemory(createdSnapshot)) {
                logMemorySavingFailed();
                snapshotDao.removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
        getParameters().setCreateSnapshotStage(CreateSnapshotForVmParameters.CreateSnapshotStage.CREATE_SNAPSHOT_COMPLETED);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getCreateSnapshotStage() == CreateSnapshotForVmParameters.CreateSnapshotStage.CREATE_VOLUME) {
        getParameters().setCreateSnapshotStage(CreateSnapshotForVmParameters.CreateSnapshotStage.CREATE_SNAPSHOT_STARTED);
        Snapshot createdSnapshot = snapshotDao.get(getParameters().getCreatedSnapshotId());
        // if the snapshot was not created in the DB
        // the command should also be handled as a failure
        getParameters().setTaskGroupSuccess(createdSnapshot != null && getParameters().getTaskGroupSuccess());
        if (getParameters().getTaskGroupSuccess()) {
            snapshotDao.updateStatus(createdSnapshot.getId(), Snapshot.SnapshotStatus.OK);
            getParameters().setLiveSnapshotRequired(shouldPerformLiveSnapshot(createdSnapshot));
            if (getParameters().isLiveSnapshotRequired()) {
                getParameters().setLiveSnapshotSucceeded(performLiveSnapshot(createdSnapshot));
            } else if (snapshotWithMemory(createdSnapshot)) {
                logMemorySavingFailed();
                snapshotDao.removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
        getParameters().setCreateSnapshotStage(CreateSnapshotForVmParameters.CreateSnapshotStage.CREATE_SNAPSHOT_COMPLETED);
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    if (!getParameters().getTaskGroupSuccess()) {
        Snapshot createdSnapshot = snapshotDao.get(getParameters().getCreatedSnapshotId());
        if (getParameters().getCreatedSnapshotId() != null) {
            revertToActiveSnapshot(getParameters().getCreatedSnapshotId());
            // Note that the memory volumes might not have been created
            if (snapshotWithMemory(createdSnapshot)) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    thawVm();
    endActionOnDisks();
    setSucceeded(getParameters().getTaskGroupSuccess() && (!getParameters().isLiveSnapshotRequired() || getParameters().isLiveSnapshotSucceeded()));
    getReturnValue().setEndActionTryAgain(false);
}
#method_after
@Override
protected void endVmCommand() {
    if (!getParameters().getTaskGroupSuccess()) {
        Snapshot createdSnapshot = snapshotDao.get(getParameters().getCreatedSnapshotId());
        if (getParameters().getCreatedSnapshotId() != null && getParameters().getCreateSnapshotStage() == CreateSnapshotForVmParameters.CreateSnapshotStage.CREATE_SNAPSHOT_STARTED || getParameters().getCreateSnapshotStage() == CreateSnapshotForVmParameters.CreateSnapshotStage.CREATE_SNAPSHOT_COMPLETED) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (snapshotWithMemory(createdSnapshot)) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    // In case of failure the memory disks will remain on the storage but not on the engine
    // this will be handled in: https://bugzilla.redhat.com/1568887
    incrementVmGeneration();
    thawVm();
    endActionOnDisks();
    setSucceeded(getParameters().getTaskGroupSuccess() && (!getParameters().isLiveSnapshotRequired() || getParameters().isLiveSnapshotSucceeded()));
    getReturnValue().setEndActionTryAgain(false);
}
#end_block

#method_before
@Override
protected boolean overrideChildCommandSuccess() {
    return false;
}
#method_after
@Override
protected boolean overrideChildCommandSuccess() {
    // If this command fails we would want the children to execute their endWithFailure flow
    return true;
}
#end_block

#method_before
public VolumeType getVolumeType(VolumeFormat volumeFormat, StorageType storageType) {
    switch(volumeFormat) {
        case COW:
            return VolumeType.Sparse;
        case RAW:
        default:
            return VolumeType.Preallocated;
    }
}
#method_after
public VolumeType getVolumeType(VolumeFormat volumeFormat) {
    switch(volumeFormat) {
        case COW:
            return VolumeType.Sparse;
        case RAW:
        default:
            return VolumeType.Preallocated;
    }
}
#end_block

#method_before
private Response performCreate(ImageTransfer imageTransfer, TransferDiskImageParameters params) {
    updateTransferType(imageTransfer, params);
    if (imageTransfer.isSetHost() && imageTransfer.getHost().isSetId()) {
        params.setVdsId(Guid.createGuidFromString(imageTransfer.getHost().getId()));
    }
    if (imageTransfer.isSetClientInactivityTimeout()) {
        params.setClientInactivityTimeout(imageTransfer.getClientInactivityTimeout());
    }
    return performCreate(ActionType.TransferDiskImage, params, new QueryIdResolver<Guid>(QueryType.GetImageTransferById, IdQueryParameters.class));
}
#method_after
private Response performCreate(ImageTransfer imageTransfer, TransferDiskImageParameters params) {
    updateTransferType(imageTransfer, params);
    if (imageTransfer.isSetHost() && imageTransfer.getHost().isSetId()) {
        params.setVdsId(Guid.createGuidFromString(imageTransfer.getHost().getId()));
    }
    if (imageTransfer.isSetInactivityTimeout()) {
        params.setClientInactivityTimeout(imageTransfer.getInactivityTimeout());
    }
    return performCreate(ActionType.TransferDiskImage, params, new QueryIdResolver<Guid>(QueryType.GetImageTransferById, IdQueryParameters.class));
}
#end_block

#method_before
@Override
protected RowMapper<ImageTransfer> createEntityRowMapper() {
    return (rs, rowNum) -> {
        ImageTransfer entity = new ImageTransfer();
        entity.setId(getGuidDefaultEmpty(rs, "command_id"));
        entity.setCommandType(ActionType.forValue(rs.getInt("command_type")));
        entity.setPhase(ImageTransferPhase.forValue(rs.getInt("phase")));
        entity.setType(TransferType.forValue(rs.getInt("type")));
        entity.setActive(rs.getBoolean("active"));
        entity.setLastUpdated(new Date(rs.getTimestamp("last_updated").getTime()));
        entity.setMessage(rs.getString("message"));
        entity.setVdsId(getGuid(rs, "vds_id"));
        entity.setDiskId(getGuid(rs, "disk_id"));
        entity.setImagedTicketId(getGuid(rs, "imaged_ticket_id"));
        entity.setProxyUri(rs.getString("proxy_uri"));
        entity.setDaemonUri(rs.getString("daemon_uri"));
        entity.setSignedTicket(rs.getString("signed_ticket"));
        entity.setBytesSent(rs.getLong("bytes_sent"));
        entity.setBytesTotal(rs.getLong("bytes_total"));
        entity.setClientInactivityTimeout(rs.getInt("client_inactivity_timeout"));
        return entity;
    };
}
#method_after
@Override
protected RowMapper<ImageTransfer> createEntityRowMapper() {
    return (rs, rowNum) -> {
        ImageTransfer entity = new ImageTransfer();
        entity.setId(getGuidDefaultEmpty(rs, "command_id"));
        entity.setCommandType(ActionType.forValue(rs.getInt("command_type")));
        entity.setPhase(ImageTransferPhase.forValue(rs.getInt("phase")));
        entity.setType(TransferType.forValue(rs.getInt("type")));
        entity.setActive(rs.getBoolean("active"));
        entity.setLastUpdated(new Date(rs.getTimestamp("last_updated").getTime()));
        entity.setMessage(rs.getString("message"));
        entity.setVdsId(getGuid(rs, "vds_id"));
        entity.setDiskId(getGuid(rs, "disk_id"));
        entity.setImagedTicketId(getGuid(rs, "imaged_ticket_id"));
        entity.setProxyUri(rs.getString("proxy_uri"));
        entity.setDaemonUri(rs.getString("daemon_uri"));
        entity.setSignedTicket(rs.getString("signed_ticket"));
        entity.setBytesSent(rs.getLong("bytes_sent"));
        entity.setBytesTotal(rs.getLong("bytes_total"));
        entity.setClientInactivityTimeout((Integer) rs.getObject("client_inactivity_timeout"));
        return entity;
    };
}
#end_block

#method_before
public SpmStatus getSpmStatus() {
    return privateSpmStatus;
}
#method_after
public SpmStatus getSpmStatus() {
    return spmStatus;
}
#end_block

#method_before
public void setSpmStatus(SpmStatus value) {
    privateSpmStatus = value;
}
#method_after
public void setSpmStatus(SpmStatus value) {
    spmStatus = value;
}
#end_block

#method_before
public String getSpmLVER() {
    return privateSpmLVER;
}
#method_after
public String getSpmLVER() {
    return spmLVER;
}
#end_block

#method_before
public void setSpmLVER(String value) {
    privateSpmLVER = value;
}
#method_after
public void setSpmLVER(String value) {
    spmLVER = value;
}
#end_block

#method_before
public int getSpmId() {
    return privateSpmId;
}
#method_after
public int getSpmId() {
    return spmId;
}
#end_block

#method_before
public void setSpmId(int value) {
    privateSpmId = value;
}
#method_after
public void setSpmId(int value) {
    spmId = value;
}
#end_block

#method_before
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("Private SPM Id", privateSpmId).append("Private SPM Version", privateSpmLVER).append("SPM Status", privateSpmStatus).build();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("SPM Id", spmId).append("SPM LVER", spmLVER).append("SPM Status", spmStatus).build();
}
#end_block

#method_before
public static void toStringBuilder(Object object, StringBuilder builder) {
    if (object == null) {
        return;
    }
    if (object instanceof Object[]) {
        toStringBuilder((Object[]) object, builder);
    } else if (object instanceof Map) {
        toStringBuilder((Map<String, Object>) object, builder);
    } else if (!(object instanceof String) && object instanceof Iterable) {
        toStringBuilder((Iterable) object, builder);
    } else {
        builder.append(object.toString());
    }
}
#method_after
public static void toStringBuilder(Object object, StringBuilder builder) {
    if (object == null) {
        return;
    }
    if (object instanceof Iterable) {
        toStringBuilder((Iterable<Object>) object, builder);
    } else if (object instanceof Object[]) {
        toStringBuilder(Arrays.asList((Object[]) object), builder);
    } else if (object instanceof Map) {
        toStringBuilder((Map<String, Object>) object, builder);
    } else {
        builder.append(object.toString());
    }
}
#end_block

#method_before
public static void toStringBuilder(Map<String, ?> map, StringBuilder builder) {
    if (map == null) {
        builder.append("{}");
        return;
    }
    builder.append("{");
    Iterator<? extends Map.Entry<String, ?>> iterator = map.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, ?> entry = iterator.next();
        builder.append(String.format("%1$s=", entry.getKey()));
        toStringBuilder(entry.getValue(), builder);
        if (iterator.hasNext()) {
            builder.append(", ");
        }
    }
    builder.append("}");
}
#method_after
private static void toStringBuilder(Map<String, ?> map, StringBuilder builder) {
    builder.append("{");
    Iterator<? extends Map.Entry<String, ?>> iterator = map.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, ?> entry = iterator.next();
        builder.append(String.format("%1$s=", entry.getKey()));
        toStringBuilder(entry.getValue(), builder);
        if (iterator.hasNext()) {
            builder.append(", ");
        }
    }
    builder.append("}");
}
#end_block

#method_before
private boolean shouldAbortOnClientInactivityTimeout(ImageTransfer entity, long ts, Integer idleTimeFromTicket) {
    int inactivityTimeout = getTransferImageClientInactivityTimeoutInSeconds();
    // For new daemon (1.3.0), we check timeout according to 'idle_time' in ticket;
    // otherwise, fallback to check according to entity's 'lastUpdated'.
    boolean timeoutExceeded = idleTimeFromTicket != null ? idleTimeFromTicket > inactivityTimeout : ts > (entity.getLastUpdated().getTime() / 1000) + inactivityTimeout;
    return inactivityTimeout > 0 && timeoutExceeded && entity.getPhase().canBePaused() && !entity.getActive();
}
#method_after
private boolean shouldAbortOnClientInactivityTimeout(ImageTransfer entity, long ts, Integer idleTimeFromTicket) {
    int inactivityTimeout = getTransferImageClientInactivityTimeoutInSeconds();
    // For new daemon (1.3.0), we check timeout according to 'idle_time' in ticket;
    // otherwise, fallback to check according to entity's 'lastUpdated'.
    boolean timeoutExceeded = idleTimeFromTicket != null ? idleTimeFromTicket > inactivityTimeout : ts > (entity.getLastUpdated().getTime() / 1000) + inactivityTimeout;
    return inactivityTimeout > 0 && timeoutExceeded && !entity.getActive();
}
#end_block

#method_before
public static VM buildVmsDataFromExternalProvider(Map<String, Object> struct) {
    VmStatic vmStatic = buildVmStaticDataFromExternalProvider(struct);
    if (vmStatic == null) {
        return null;
    }
    VmDynamic vmDynamic = buildVMDynamicDataFromList(struct);
    VM vm = new VM(vmStatic, vmDynamic, new VmStatistics());
    for (DiskImage image : vm.getImages()) {
        vm.getDiskMap().put(Guid.newGuid(), image);
    }
    try {
        vm.setClusterArch(parseArchitecture(struct));
    } catch (IllegalArgumentException ex) {
        log.warn("Illegal architecture type: {}, replacing with x86_64", struct.get(VdsProperties.vm_arch));
        vm.setClusterArch(ArchitectureType.x86_64);
    } catch (NullPointerException ex) {
        log.warn("null architecture type, replacing with x86_64, {}", vm);
        vm.setClusterArch(ArchitectureType.x86_64);
    }
    return vm;
}
#method_after
public VM buildVmsDataFromExternalProvider(Map<String, Object> struct) {
    VmStatic vmStatic = buildVmStaticDataFromExternalProvider(struct);
    if (vmStatic == null) {
        return null;
    }
    VmDynamic vmDynamic = buildVMDynamicDataFromList(struct);
    VM vm = new VM(vmStatic, vmDynamic, new VmStatistics());
    for (DiskImage image : vm.getImages()) {
        vm.getDiskMap().put(Guid.newGuid(), image);
    }
    try {
        vm.setClusterArch(parseArchitecture(struct));
    } catch (IllegalArgumentException ex) {
        log.warn("Illegal architecture type: {}, replacing with x86_64", struct.get(VdsProperties.vm_arch));
        vm.setClusterArch(ArchitectureType.x86_64);
    } catch (NullPointerException ex) {
        log.warn("null architecture type, replacing with x86_64, {}", vm);
        vm.setClusterArch(ArchitectureType.x86_64);
    }
    return vm;
}
#end_block

#method_before
public static ArrayList<DiskImage> buildDiskImagesFromDevices(Map<String, Object> vmStruct, Guid vmId) {
    ArrayList<DiskImage> diskImages = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.Disk.equals(deviceMap.get(VdsProperties.Device))) {
                DiskImage image = new DiskImage();
                image.setDiskAlias((String) deviceMap.get(VdsProperties.Alias));
                Long size = assignLongValue(deviceMap, VdsProperties.disk_apparent_size);
                image.setSize(size != null ? size : 0);
                Double actualSize = assignDoubleValue(deviceMap, VdsProperties.disk_true_size);
                image.setActualSize(actualSize != null ? actualSize : 0);
                image.setVolumeFormat(VolumeFormat.valueOf(((String) deviceMap.get(VdsProperties.Format)).toUpperCase()));
                image.setShareable(false);
                String id = assignStringValue(deviceMap, VdsProperties.DeviceId);
                if (id == null) {
                    id = assignStringValue(deviceMap, VdsProperties.ImageId);
                }
                image.setId(Guid.createGuidFromString(id));
                image.setImageId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.VolumeId)));
                Guid domainId = Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DomainId));
                List<Guid> domainIds = Collections.singletonList(domainId);
                image.setStorageIds(new ArrayList<>(domainIds));
                // TODO not sure how to extract that info
                image.setVolumeType(VolumeType.Preallocated);
                DiskVmElement dve = new DiskVmElement(image.getId(), vmId);
                image.setDiskVmElements(Collections.singletonList(dve));
                switch((String) deviceMap.get("iface")) {
                    case "virtio":
                        dve.setDiskInterface(DiskInterface.VirtIO);
                        break;
                    case "iscsi":
                    case "scsi":
                        dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
                        break;
                    case "ide":
                        dve.setDiskInterface(DiskInterface.IDE);
                        break;
                }
                diskImages.add(image);
            }
        }
    }
    return diskImages;
}
#method_after
public ArrayList<DiskImage> buildDiskImagesFromDevices(Map<String, Object> vmStruct, Guid vmId) {
    ArrayList<DiskImage> diskImages = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.Disk.equals(deviceMap.get(VdsProperties.Device))) {
                DiskImage image = new DiskImage();
                image.setDiskAlias((String) deviceMap.get(VdsProperties.Alias));
                Long size = assignLongValue(deviceMap, VdsProperties.disk_apparent_size);
                image.setSize(size != null ? size : 0);
                Double actualSize = assignDoubleValue(deviceMap, VdsProperties.disk_true_size);
                image.setActualSize(actualSize != null ? actualSize : 0);
                image.setVolumeFormat(VolumeFormat.valueOf(((String) deviceMap.get(VdsProperties.Format)).toUpperCase()));
                image.setShareable(false);
                String id = assignStringValue(deviceMap, VdsProperties.DeviceId);
                if (id == null) {
                    id = assignStringValue(deviceMap, VdsProperties.ImageId);
                }
                image.setId(Guid.createGuidFromString(id));
                image.setImageId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.VolumeId)));
                Guid domainId = Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DomainId));
                List<Guid> domainIds = Collections.singletonList(domainId);
                image.setStorageIds(new ArrayList<>(domainIds));
                // TODO not sure how to extract that info
                image.setVolumeType(VolumeType.Preallocated);
                DiskVmElement dve = new DiskVmElement(image.getId(), vmId);
                image.setDiskVmElements(Collections.singletonList(dve));
                switch((String) deviceMap.get("iface")) {
                    case "virtio":
                        dve.setDiskInterface(DiskInterface.VirtIO);
                        break;
                    case "iscsi":
                    case "scsi":
                        dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
                        break;
                    case "ide":
                        dve.setDiskInterface(DiskInterface.IDE);
                        break;
                }
                diskImages.add(image);
            }
        }
    }
    return diskImages;
}
#end_block

#method_before
public static ArrayList<VmNetworkInterface> buildVmNetworkInterfacesFromDevices(Map<String, Object> vmStruct) {
    ArrayList<VmNetworkInterface> nics = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get(VdsProperties.Devices);
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.VM_INTERFACE_DEVICE_TYPE.equals(deviceMap.get(VdsProperties.Type))) {
                VmNetworkInterface nic = new VmNetworkInterface();
                nic.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                nic.setMacAddress((String) deviceMap.get(VdsProperties.MAC_ADDR));
                nic.setName((String) deviceMap.get(VdsProperties.Name));
                // FIXME we can't deduce the network profile by the network name. its many to many.
                nic.setNetworkName((String) deviceMap.get(VdsProperties.NETWORK));
                String nicModel = (String) deviceMap.get(VdsProperties.NIC_TYPE);
                if ("virtio".equals(nicModel)) {
                    nicModel = "pv";
                }
                nic.setType(VmInterfaceType.valueOf(nicModel).getValue());
                if (deviceMap.containsKey(VdsProperties.Model)) {
                    String model = (String) deviceMap.get(VdsProperties.Model);
                    for (VmInterfaceType type : VmInterfaceType.values()) {
                        if (model.equals(type.getInternalName())) {
                            nic.setType(type.getValue());
                            break;
                        }
                    }
                }
                nics.add(nic);
            }
        }
    }
    return nics;
}
#method_after
public ArrayList<VmNetworkInterface> buildVmNetworkInterfacesFromDevices(Map<String, Object> vmStruct) {
    ArrayList<VmNetworkInterface> nics = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get(VdsProperties.Devices);
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.VM_INTERFACE_DEVICE_TYPE.equals(deviceMap.get(VdsProperties.Type))) {
                VmNetworkInterface nic = new VmNetworkInterface();
                nic.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                nic.setMacAddress((String) deviceMap.get(VdsProperties.MAC_ADDR));
                nic.setName((String) deviceMap.get(VdsProperties.Name));
                // FIXME we can't deduce the network profile by the network name. its many to many.
                nic.setNetworkName((String) deviceMap.get(VdsProperties.NETWORK));
                String nicModel = (String) deviceMap.get(VdsProperties.NIC_TYPE);
                if ("virtio".equals(nicModel)) {
                    nicModel = "pv";
                }
                nic.setType(VmInterfaceType.valueOf(nicModel).getValue());
                if (deviceMap.containsKey(VdsProperties.Model)) {
                    String model = (String) deviceMap.get(VdsProperties.Model);
                    for (VmInterfaceType type : VmInterfaceType.values()) {
                        if (model.equals(type.getInternalName())) {
                            nic.setType(type.getValue());
                            break;
                        }
                    }
                }
                nics.add(nic);
            }
        }
    }
    return nics;
}
#end_block

#method_before
public static VmDevice buildConsoleDevice(Map<String, Object> vmStruct, Guid vmId) {
    Object[] devices = (Object[]) vmStruct.get(VdsProperties.Devices);
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> vdsmDevice = (Map<String, Object>) device;
            String deviceName = (String) vdsmDevice.get(VdsProperties.Device);
            if (VmDeviceType.CONSOLE.getName().equals(deviceName)) {
                String typeName = (String) vdsmDevice.get(VdsProperties.Type);
                String alias = StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias));
                Guid newDeviceId = Guid.createGuidFromString((String) vdsmDevice.get(VdsProperties.DeviceId));
                VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
                VmDevice consoleDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, "", new HashMap<>(), false, true, false, alias, null, null, null);
                return consoleDevice;
            }
        }
    }
    return null;
}
#method_after
public VmDevice buildConsoleDevice(Map<String, Object> vmStruct, Guid vmId) {
    Object[] devices = (Object[]) vmStruct.get(VdsProperties.Devices);
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> vdsmDevice = (Map<String, Object>) device;
            String deviceName = (String) vdsmDevice.get(VdsProperties.Device);
            if (VmDeviceType.CONSOLE.getName().equals(deviceName)) {
                String typeName = (String) vdsmDevice.get(VdsProperties.Type);
                String alias = StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias));
                Guid newDeviceId = Guid.createGuidFromString((String) vdsmDevice.get(VdsProperties.DeviceId));
                VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
                VmDevice consoleDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, "", new HashMap<>(), false, true, false, alias, null, null, null);
                return consoleDevice;
            }
        }
    }
    return null;
}
#end_block

#method_before
private static VmStatic buildVmStaticDataFromExternalProvider(Map<String, Object> struct) {
    if (!struct.containsKey(VdsProperties.vm_guid) || !struct.containsKey(VdsProperties.vm_name) || !struct.containsKey(VdsProperties.mem_size_mb) || !struct.containsKey(VdsProperties.num_of_cpus)) {
        return null;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(Guid.createGuidFromString((String) struct.get(VdsProperties.vm_guid)));
    vmStatic.setName((String) struct.get(VdsProperties.vm_name));
    vmStatic.setMemSizeMb(parseIntVdsProperty(struct.get(VdsProperties.mem_size_mb)));
    vmStatic.setNumOfSockets(parseIntVdsProperty(struct.get(VdsProperties.num_of_cpus)));
    vmStatic.setCustomCpuName((String) struct.get(VdsProperties.cpu_model));
    vmStatic.setCustomEmulatedMachine((String) struct.get(VdsProperties.emulatedMachine));
    addGraphicsDeviceFromExternalProvider(vmStatic, struct);
    if (struct.containsKey(VdsProperties.vm_disks)) {
        for (Object disk : (Object[]) struct.get(VdsProperties.vm_disks)) {
            Map<String, Object> diskMap = (Map<String, Object>) disk;
            if (VdsProperties.Disk.equals(diskMap.get(VdsProperties.type))) {
                DiskImage image = buildDiskImageFromExternalProvider(diskMap, vmStatic.getId());
                vmStatic.getImages().add(image);
            }
        }
    }
    if (struct.containsKey(VdsProperties.NETWORKS)) {
        int idx = 0;
        for (Object networkMap : (Object[]) struct.get(VdsProperties.NETWORKS)) {
            VmNetworkInterface nic = buildNetworkInterfaceFromExternalProvider((Map<String, Object>) networkMap);
            nic.setName(String.format("nic%d", ++idx));
            nic.setVmName(vmStatic.getName());
            nic.setVmId(vmStatic.getId());
            vmStatic.getInterfaces().add(nic);
        }
    }
    return vmStatic;
}
#method_after
private VmStatic buildVmStaticDataFromExternalProvider(Map<String, Object> struct) {
    if (!struct.containsKey(VdsProperties.vm_guid) || !struct.containsKey(VdsProperties.vm_name) || !struct.containsKey(VdsProperties.mem_size_mb) || !struct.containsKey(VdsProperties.num_of_cpus)) {
        return null;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(Guid.createGuidFromString((String) struct.get(VdsProperties.vm_guid)));
    vmStatic.setName((String) struct.get(VdsProperties.vm_name));
    vmStatic.setMemSizeMb(parseIntVdsProperty(struct.get(VdsProperties.mem_size_mb)));
    vmStatic.setNumOfSockets(parseIntVdsProperty(struct.get(VdsProperties.num_of_cpus)));
    vmStatic.setCustomCpuName((String) struct.get(VdsProperties.cpu_model));
    vmStatic.setCustomEmulatedMachine((String) struct.get(VdsProperties.emulatedMachine));
    addGraphicsDeviceFromExternalProvider(vmStatic, struct);
    if (struct.containsKey(VdsProperties.vm_disks)) {
        for (Object disk : (Object[]) struct.get(VdsProperties.vm_disks)) {
            Map<String, Object> diskMap = (Map<String, Object>) disk;
            if (VdsProperties.Disk.equals(diskMap.get(VdsProperties.type))) {
                DiskImage image = buildDiskImageFromExternalProvider(diskMap, vmStatic.getId());
                vmStatic.getImages().add(image);
            }
        }
    }
    if (struct.containsKey(VdsProperties.NETWORKS)) {
        int idx = 0;
        for (Object networkMap : (Object[]) struct.get(VdsProperties.NETWORKS)) {
            VmNetworkInterface nic = buildNetworkInterfaceFromExternalProvider((Map<String, Object>) networkMap);
            nic.setName(String.format("nic%d", ++idx));
            nic.setVmName(vmStatic.getName());
            nic.setVmId(vmStatic.getId());
            vmStatic.getInterfaces().add(nic);
        }
    }
    return vmStatic;
}
#end_block

#method_before
public static VmDynamic buildVMDynamicDataFromList(Map<String, Object> struct) {
    VmDynamic vmdynamic = new VmDynamic();
    if (struct.containsKey(VdsProperties.vm_guid)) {
        vmdynamic.setId(new Guid((String) struct.get(VdsProperties.vm_guid)));
    }
    if (struct.containsKey(VdsProperties.status)) {
        vmdynamic.setStatus(convertToVmStatus((String) struct.get(VdsProperties.status)));
    }
    return vmdynamic;
}
#method_after
public VmDynamic buildVMDynamicDataFromList(Map<String, Object> struct) {
    VmDynamic vmdynamic = new VmDynamic();
    if (struct.containsKey(VdsProperties.vm_guid)) {
        vmdynamic.setId(new Guid((String) struct.get(VdsProperties.vm_guid)));
    }
    if (struct.containsKey(VdsProperties.status)) {
        vmdynamic.setStatus(convertToVmStatus((String) struct.get(VdsProperties.status)));
    }
    return vmdynamic;
}
#end_block

#method_before
public static Double getVdsmCallTimestamp(Map<String, Object> struct) {
    if (struct.containsKey(VdsProperties.statusTime)) {
        return assignDoubleValue(struct, VdsProperties.statusTime);
    }
    return -1d;
}
#method_after
public Double getVdsmCallTimestamp(Map<String, Object> struct) {
    if (struct.containsKey(VdsProperties.statusTime)) {
        return assignDoubleValue(struct, VdsProperties.statusTime);
    }
    return -1d;
}
#end_block

#method_before
public static String getVmDevicesHash(Map<String, Object> struct) {
    if (struct.containsKey(VdsProperties.hash)) {
        return (String) struct.get(VdsProperties.hash);
    }
    return null;
}
#method_after
public String getVmDevicesHash(Map<String, Object> struct) {
    if (struct.containsKey(VdsProperties.hash)) {
        return (String) struct.get(VdsProperties.hash);
    }
    return null;
}
#end_block

#method_before
public static VmDynamic buildVMDynamicData(Map<String, Object> struct, VDS host) {
    VmDynamic vmdynamic = new VmDynamic();
    updateVMDynamicData(vmdynamic, struct, host);
    return vmdynamic;
}
#method_after
public VmDynamic buildVMDynamicData(Map<String, Object> struct, VDS host) {
    VmDynamic vmdynamic = new VmDynamic();
    updateVMDynamicData(vmdynamic, struct, host);
    return vmdynamic;
}
#end_block

#method_before
public static StoragePool buildStoragePool(Map<String, Object> struct) {
    StoragePool sPool = new StoragePool();
    if (struct.containsKey("type")) {
        sPool.setIsLocal(StorageType.valueOf(struct.get("type").toString()).isLocal());
    }
    sPool.setName(assignStringValue(struct, "name"));
    Integer masterVersion = assignIntValue(struct, "master_ver");
    if (masterVersion != null) {
        sPool.setMasterDomainVersion(masterVersion);
    }
    return sPool;
}
#method_after
public StoragePool buildStoragePool(Map<String, Object> struct) {
    StoragePool sPool = new StoragePool();
    if (struct.containsKey("type")) {
        sPool.setIsLocal(StorageType.valueOf(struct.get("type").toString()).isLocal());
    }
    sPool.setName(assignStringValue(struct, "name"));
    Integer masterVersion = assignIntValue(struct, "master_ver");
    if (masterVersion != null) {
        sPool.setMasterDomainVersion(masterVersion);
    }
    return sPool;
}
#end_block

#method_before
public static VmStatistics buildVMStatisticsData(Map<String, Object> struct) {
    VmStatistics vmStatistics = new VmStatistics();
    updateVMStatisticsData(vmStatistics, struct);
    return vmStatistics;
}
#method_after
public VmStatistics buildVMStatisticsData(Map<String, Object> struct) {
    VmStatistics vmStatistics = new VmStatistics();
    updateVMStatisticsData(vmStatistics, struct);
    return vmStatistics;
}
#end_block

#method_before
public static Map<String, LUNs> buildVmLunDisksData(Map<String, Object> struct) {
    Map<String, Object> disks = (Map<String, Object>) struct.get(VdsProperties.vm_disks);
    if (disks == null) {
        return Collections.emptyMap();
    }
    Map<String, LUNs> lunsMap = new HashMap<>();
    for (Object diskAsObj : disks.values()) {
        Map<String, Object> disk = (Map<String, Object>) diskAsObj;
        String lunGuidString = assignStringValue(disk, VdsProperties.lun_guid);
        if (!StringUtils.isEmpty(lunGuidString)) {
            LUNs lun = new LUNs();
            lun.setLUNId(lunGuidString);
            if (disk.containsKey(VdsProperties.disk_true_size)) {
                long sizeInBytes = assignLongValue(disk, VdsProperties.disk_true_size);
                int sizeInGB = SizeConverter.convert(sizeInBytes, SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GiB).intValue();
                lun.setDeviceSize(sizeInGB);
            }
            lunsMap.put(lunGuidString, lun);
        }
    }
    return lunsMap;
}
#method_after
public Map<String, LUNs> buildVmLunDisksData(Map<String, Object> struct) {
    Map<String, Object> disks = (Map<String, Object>) struct.get(VdsProperties.vm_disks);
    if (disks == null) {
        return Collections.emptyMap();
    }
    Map<String, LUNs> lunsMap = new HashMap<>();
    for (Object diskAsObj : disks.values()) {
        Map<String, Object> disk = (Map<String, Object>) diskAsObj;
        String lunGuidString = assignStringValue(disk, VdsProperties.lun_guid);
        if (!StringUtils.isEmpty(lunGuidString)) {
            LUNs lun = new LUNs();
            lun.setLUNId(lunGuidString);
            if (disk.containsKey(VdsProperties.disk_true_size)) {
                long sizeInBytes = assignLongValue(disk, VdsProperties.disk_true_size);
                int sizeInGB = SizeConverter.convert(sizeInBytes, SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GiB).intValue();
                lun.setDeviceSize(sizeInGB);
            }
            lunsMap.put(lunGuidString, lun);
        }
    }
    return lunsMap;
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> struct, VDS host) {
    if (struct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) struct.get(VdsProperties.vm_guid)));
    }
    if (struct.containsKey(VdsProperties.session)) {
        String session = (String) struct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (struct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) struct.get(VdsProperties.acpiEnable)));
    }
    if (struct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) struct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, struct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, struct);
    }
    adjustDisplayIp(vm.getGraphicsInfos(), host);
    if (struct.containsKey(VdsProperties.utc_diff)) {
        String utc_diff = struct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    // ------------- vm internal agent data
    if (struct.containsKey(VdsProperties.vm_host)) {
        vm.setVmHost(assignStringValue(struct, VdsProperties.vm_host));
    }
    if (struct.containsKey(VdsProperties.guest_cur_user_name)) {
        vm.setGuestCurrentUserName(assignStringValue(struct, VdsProperties.guest_cur_user_name));
    }
    initAppsList(struct, vm);
    initGuestContainers(struct, vm);
    if (struct.containsKey(VdsProperties.guest_os)) {
        vm.setGuestOs(assignStringValue(struct, VdsProperties.guest_os));
    }
    if (struct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setFqdn(assignStringValue(struct, VdsProperties.VM_FQDN));
        String fqdn = vm.getFqdn().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setFqdn(null);
        } else {
            vm.setFqdn(fqdn);
        }
    }
    if (struct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = struct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (struct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) struct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (struct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = struct.get(VdsProperties.exit_reason).toString();
        VmExitReason exitReason = VmExitReason.forValue(Integer.parseInt(exitReasonStr));
        if (exitReason == null) {
            log.warn("Illegal exit reason: {}, replacing with Unknown", exitReasonStr);
            exitReason = VmExitReason.Unknown;
        }
        vm.setExitReason(exitReason);
    }
    // if monitorResponse returns negative it means its erroneous
    if (struct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(struct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (struct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(struct.get(VdsProperties.clientIp).toString());
    }
    if (struct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) struct.get(VdsProperties.pauseCode);
        try {
            vm.setPauseStatus(VmPauseStatus.valueOf(pauseCodeStr));
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
        }
    }
    if (struct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) struct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (struct.containsKey(VdsProperties.CDRom)) {
        Path fileName = Paths.get((String) struct.get(VdsProperties.CDRom)).getFileName();
        if (fileName != null) {
            String isoName = fileName.toString();
            vm.setCurrentCd(isoName);
        }
    }
    if (struct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(assignIntValue(struct, VdsProperties.GUEST_CPU_COUNT));
    }
    // Guest OS Info
    if (struct.containsKey(VdsProperties.GUEST_OS_INFO)) {
        updateGuestOsInfo(vm, struct);
    }
    // Guest Timezone
    if (struct.containsKey(VdsProperties.GUEST_TIMEZONE)) {
        Map<String, Object> guestTimeZoneStruct = (Map<String, Object>) struct.get(VdsProperties.GUEST_TIMEZONE);
        vm.setGuestOsTimezoneName(assignStringValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_ZONE));
        vm.setGuestOsTimezoneOffset(assignIntValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_OFFSET));
    }
}
#method_after
public void updateVMDynamicData(VmDynamic vm, Map<String, Object> struct, VDS host) {
    if (struct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) struct.get(VdsProperties.vm_guid)));
    }
    if (struct.containsKey(VdsProperties.session)) {
        String session = (String) struct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (struct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) struct.get(VdsProperties.acpiEnable)));
    }
    if (struct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) struct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, struct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, struct);
    }
    adjustDisplayIp(vm.getGraphicsInfos(), host);
    if (struct.containsKey(VdsProperties.utc_diff)) {
        String utc_diff = struct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    // ------------- vm internal agent data
    if (struct.containsKey(VdsProperties.vm_host)) {
        vm.setVmHost(assignStringValue(struct, VdsProperties.vm_host));
    }
    if (struct.containsKey(VdsProperties.guest_cur_user_name)) {
        vm.setGuestCurrentUserName(assignStringValue(struct, VdsProperties.guest_cur_user_name));
    }
    initAppsList(struct, vm);
    initGuestContainers(struct, vm);
    if (struct.containsKey(VdsProperties.guest_os)) {
        vm.setGuestOs(assignStringValue(struct, VdsProperties.guest_os));
    }
    if (struct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setFqdn(assignStringValue(struct, VdsProperties.VM_FQDN));
        String fqdn = vm.getFqdn().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setFqdn(null);
        } else {
            vm.setFqdn(fqdn);
        }
    }
    if (struct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = struct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (struct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) struct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (struct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = struct.get(VdsProperties.exit_reason).toString();
        VmExitReason exitReason = VmExitReason.forValue(Integer.parseInt(exitReasonStr));
        if (exitReason == null) {
            log.warn("Illegal exit reason: {}, replacing with Unknown", exitReasonStr);
            exitReason = VmExitReason.Unknown;
        }
        vm.setExitReason(exitReason);
    }
    // if monitorResponse returns negative it means its erroneous
    if (struct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(struct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (struct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(struct.get(VdsProperties.clientIp).toString());
    }
    if (struct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) struct.get(VdsProperties.pauseCode);
        try {
            vm.setPauseStatus(VmPauseStatus.valueOf(pauseCodeStr));
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
        }
    }
    if (struct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) struct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (struct.containsKey(VdsProperties.CDRom)) {
        Path fileName = Paths.get((String) struct.get(VdsProperties.CDRom)).getFileName();
        if (fileName != null) {
            String isoName = fileName.toString();
            vm.setCurrentCd(isoName);
        }
    }
    if (struct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(assignIntValue(struct, VdsProperties.GUEST_CPU_COUNT));
    }
    // Guest OS Info
    if (struct.containsKey(VdsProperties.GUEST_OS_INFO)) {
        updateGuestOsInfo(vm, struct);
    }
    // Guest Timezone
    if (struct.containsKey(VdsProperties.GUEST_TIMEZONE)) {
        Map<String, Object> guestTimeZoneStruct = (Map<String, Object>) struct.get(VdsProperties.GUEST_TIMEZONE);
        vm.setGuestOsTimezoneName(assignStringValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_ZONE));
        vm.setGuestOsTimezoneOffset(assignIntValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_OFFSET));
    }
}
#end_block

#method_before
public static int parseIntVdsProperty(Object vdsProperty) {
    if (vdsProperty instanceof Integer) {
        return (Integer) vdsProperty;
    } else {
        return Integer.parseInt((String) vdsProperty);
    }
}
#method_after
public int parseIntVdsProperty(Object vdsProperty) {
    if (vdsProperty instanceof Integer) {
        return (Integer) vdsProperty;
    } else {
        return Integer.parseInt((String) vdsProperty);
    }
}
#end_block

#method_before
public static List<VmNetworkInterface> buildInterfaceStatisticsData(Map<String, Object> struct) {
    // ------------- vm network statistics -----------------------
    if (!struct.containsKey(VdsProperties.VM_NETWORK)) {
        return null;
    }
    Map networkStruct = (Map) struct.get(VdsProperties.VM_NETWORK);
    List<VmNetworkInterface> interfaceStatistics = new ArrayList<>();
    for (Object tempNic : networkStruct.values()) {
        Map nic = (Map) tempNic;
        VmNetworkInterface stats = new VmNetworkInterface();
        if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
            stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
        }
        extractInterfaceStatistics(nic, stats);
        stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
        interfaceStatistics.add(stats);
    }
    return interfaceStatistics;
}
#method_after
public List<VmNetworkInterface> buildInterfaceStatisticsData(Map<String, Object> struct) {
    // ------------- vm network statistics -----------------------
    if (!struct.containsKey(VdsProperties.VM_NETWORK)) {
        return null;
    }
    Map networkStruct = (Map) struct.get(VdsProperties.VM_NETWORK);
    List<VmNetworkInterface> interfaceStatistics = new ArrayList<>();
    for (Object tempNic : networkStruct.values()) {
        Map nic = (Map) tempNic;
        VmNetworkInterface stats = new VmNetworkInterface();
        if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
            stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
        }
        extractInterfaceStatistics(nic, stats);
        stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
        interfaceStatistics.add(stats);
    }
    return interfaceStatistics;
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> struct) {
    if (struct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) struct.get(VdsProperties.vm_guid)));
    }
    vm.setElapsedTime(assignDoubleValue(struct, VdsProperties.elapsed_time));
    if (struct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(struct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setCpuSys(assignDoubleValue(struct, VdsProperties.cpu_sys));
    vm.setCpuUser(assignDoubleValue(struct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setUsageMemPercent(assignIntValue(struct, VdsProperties.vm_usage_mem_percent));
    if (struct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) struct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        }
    }
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = assignIntValue(struct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
}
#method_after
public void updateVMStatisticsData(VmStatistics vm, Map<String, Object> struct) {
    if (struct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) struct.get(VdsProperties.vm_guid)));
    }
    vm.setElapsedTime(assignDoubleValue(struct, VdsProperties.elapsed_time));
    if (struct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(struct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setCpuSys(assignDoubleValue(struct, VdsProperties.cpu_sys));
    vm.setCpuUser(assignDoubleValue(struct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setUsageMemPercent(assignIntValue(struct, VdsProperties.vm_usage_mem_percent));
    if (struct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) struct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        }
    }
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = assignIntValue(struct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
}
#end_block

#method_before
public static VmBalloonInfo buildVmBalloonInfo(Map<String, Object> struct) {
    VmBalloonInfo vmBalloonInfo = new VmBalloonInfo();
    Map<String, Object> balloonInfo = (Map<String, Object>) struct.get(VdsProperties.vm_balloonInfo);
    if (balloonInfo != null && !balloonInfo.isEmpty()) {
        vmBalloonInfo.setCurrentMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_cur));
        vmBalloonInfo.setBalloonMaxMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_max));
        vmBalloonInfo.setBalloonTargetMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_target));
        vmBalloonInfo.setBalloonMinMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_min));
        // only if all 4 properties are found the balloon is considered enabled (available from 3.3)
        vmBalloonInfo.setBalloonDeviceEnabled(balloonInfo.size() >= 4);
    }
    return vmBalloonInfo;
}
#method_after
public VmBalloonInfo buildVmBalloonInfo(Map<String, Object> struct) {
    VmBalloonInfo vmBalloonInfo = new VmBalloonInfo();
    Map<String, Object> balloonInfo = (Map<String, Object>) struct.get(VdsProperties.vm_balloonInfo);
    if (balloonInfo != null && !balloonInfo.isEmpty()) {
        vmBalloonInfo.setCurrentMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_cur));
        vmBalloonInfo.setBalloonMaxMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_max));
        vmBalloonInfo.setBalloonTargetMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_target));
        vmBalloonInfo.setBalloonMinMemory(assignLongValue(balloonInfo, VdsProperties.vm_balloon_min));
        // only if all 4 properties are found the balloon is considered enabled (available from 3.3)
        vmBalloonInfo.setBalloonDeviceEnabled(balloonInfo.size() >= 4);
    }
    return vmBalloonInfo;
}
#end_block

#method_before
public static List<VmJob> buildVmJobsData(Map<String, Object> struct) {
    if (!struct.containsKey(VdsProperties.vmJobs)) {
        return null;
    }
    Guid vmId = new Guid((String) struct.get(VdsProperties.vm_guid));
    return ((Map<String, Object>) struct.get(VdsProperties.vmJobs)).values().stream().map(jobMap -> buildVmJobData(vmId, (Map<String, Object>) jobMap)).collect(Collectors.toList());
}
#method_after
public List<VmJob> buildVmJobsData(Map<String, Object> struct) {
    if (!struct.containsKey(VdsProperties.vmJobs)) {
        return null;
    }
    Guid vmId = new Guid((String) struct.get(VdsProperties.vm_guid));
    return ((Map<String, Object>) struct.get(VdsProperties.vmJobs)).values().stream().map(jobMap -> buildVmJobData(vmId, (Map<String, Object>) jobMap)).collect(Collectors.toList());
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, String> vdsmNameMap, Map<String, Object> struct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(struct, VdsProperties.supported_cluster_levels));
    setDnsResolverConfigurationData(vds, struct);
    updateNetworkData(vds, vdsmNameMap, struct);
    updateNumaNodesData(vds, struct);
    vds.setCpuThreads(assignIntValue(struct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(struct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(struct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(struct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(struct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(struct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(struct, VdsProperties.physical_mem_mb));
    vds.setKernelArgs(assignStringValue(struct, VdsProperties.kernel_args));
    vds.setKvmEnabled(assignBoolValue(struct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(struct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(struct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(struct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, struct);
    vds.setSupportedEngines(assignStringValueFromArray(struct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(struct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(struct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, struct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (struct.containsKey(VdsProperties.hooks)) {
        hooksStr = struct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) struct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(struct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(struct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(struct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) struct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    vds.setHostedEngineConfigured(assignBoolValue(struct, VdsProperties.hosted_engine_configured));
    updateAdditionalFeatures(vds, struct);
    vds.setKernelFeatures((Map<String, Object>) struct.get(VdsProperties.kernelFeatures));
    vds.setOpenstackBindingHostIds((Map<String, Object>) struct.get(VdsProperties.OPENSTACK_BINDING_HOST_IDS));
}
#method_after
public void updateVDSDynamicData(VDS vds, Map<String, String> vdsmNameMap, Map<String, Object> struct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(struct, VdsProperties.supported_cluster_levels));
    setDnsResolverConfigurationData(vds, struct);
    updateNetworkData(vds, vdsmNameMap, struct);
    updateNumaNodesData(vds, struct);
    vds.setCpuThreads(assignIntValue(struct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(struct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(struct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(struct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(struct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(struct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(struct, VdsProperties.physical_mem_mb));
    vds.setKernelArgs(assignStringValue(struct, VdsProperties.kernel_args));
    vds.setKvmEnabled(assignBoolValue(struct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(struct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(struct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(struct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, struct);
    vds.setSupportedEngines(assignStringValueFromArray(struct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(struct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(struct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, struct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (struct.containsKey(VdsProperties.hooks)) {
        hooksStr = struct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) struct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(struct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(struct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(struct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) struct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    vds.setHostedEngineConfigured(assignBoolValue(struct, VdsProperties.hosted_engine_configured));
    updateAdditionalFeatures(vds, struct);
    vds.setKernelFeatures((Map<String, Object>) struct.get(VdsProperties.kernelFeatures));
    vds.setOpenstackBindingHostIds((Map<String, Object>) struct.get(VdsProperties.OPENSTACK_BINDING_HOST_IDS));
}
#end_block

#method_before
public static void checkTimeDrift(VDS vds, Map<String, Object> struct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = assignDatetimeValue(struct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogable logable = createAuditLogableForHost(vds);
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#method_after
public void checkTimeDrift(VDS vds, Map<String, Object> struct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = assignDatetimeValue(struct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogable logable = createAuditLogableForHost(vds);
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#end_block

#method_before
public static void updateHardwareSystemInformation(Map<String, Object> hwInfo, VDS vds) {
    vds.setHardwareManufacturer(assignStringValue(hwInfo, VdsProperties.hwManufacturer));
    vds.setHardwareProductName(assignStringValue(hwInfo, VdsProperties.hwProductName));
    vds.setHardwareVersion(assignStringValue(hwInfo, VdsProperties.hwVersion));
    vds.setHardwareSerialNumber(assignStringValue(hwInfo, VdsProperties.hwSerialNumber));
    vds.setHardwareUUID(assignStringValue(hwInfo, VdsProperties.hwUUID));
    vds.setHardwareFamily(assignStringValue(hwInfo, VdsProperties.hwFamily));
}
#method_after
public void updateHardwareSystemInformation(Map<String, Object> hwInfo, VDS vds) {
    vds.setHardwareManufacturer(assignStringValue(hwInfo, VdsProperties.hwManufacturer));
    vds.setHardwareProductName(assignStringValue(hwInfo, VdsProperties.hwProductName));
    vds.setHardwareVersion(assignStringValue(hwInfo, VdsProperties.hwVersion));
    vds.setHardwareSerialNumber(assignStringValue(hwInfo, VdsProperties.hwSerialNumber));
    vds.setHardwareUUID(assignStringValue(hwInfo, VdsProperties.hwUUID));
    vds.setHardwareFamily(assignStringValue(hwInfo, VdsProperties.hwFamily));
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> struct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(assignIntValue(struct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) struct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder();
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(assignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkCommonUtils.isVlan(existingIface) && !existingIface.isPartOfBond()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface);
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(assignDoubleValue(struct, VdsProperties.cpu_sys));
    vds.setCpuUser(assignDoubleValue(struct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = assignDoubleValue(struct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(assignDoubleValue(struct, VdsProperties.cpu_idle));
    vds.setMemAvailable(assignLongValue(struct, VdsProperties.mem_available));
    vds.setMemFree(assignLongValue(struct, VdsProperties.memFree));
    vds.setMemShared(assignLongValue(struct, VdsProperties.mem_shared));
    vds.setSwapFree(assignLongValue(struct, VdsProperties.swap_free));
    vds.setSwapTotal(assignLongValue(struct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(assignIntValue(struct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(assignLongValue(struct, VdsProperties.ksm_pages));
    vds.setKsmState(assignBoolValue(struct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (struct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, struct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (struct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(assignIntValue(struct, VdsProperties.anonymous_transparent_huge_pages));
    }
    if (struct.containsKey(VdsProperties.hugepages)) {
        Object hugepages = struct.get(VdsProperties.hugepages);
        if (hugepages instanceof Map) {
            Map<String, Map<String, String>> hugepagesMap = (Map<String, Map<String, String>>) hugepages;
            List<HugePage> parsedHugePages = hugepagesMap.entrySet().stream().map(entry -> new HugePage(Integer.parseInt(entry.getKey()), assignIntValue(entry.getValue(), VdsProperties.free_hugepages))).collect(Collectors.toList());
            vds.setHugePages(parsedHugePages);
        }
    }
    vds.setNetConfigDirty(assignBoolValue(struct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(assignDoubleValue(struct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(assignDoubleValue(struct, VdsProperties.images_last_delay));
    Integer vm_count = assignIntValue(struct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(assignIntValue(struct, VdsProperties.vm_active));
    vds.setVmMigrating(assignIntValue(struct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = assignIntValue(struct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = assignIntValue(struct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, struct);
    updateLocalDisksUsage(vds, struct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (struct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) struct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = assignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = assignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = assignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = assignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = assignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = assignIntValue(struct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = haScore > 0;
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(assignLongValue(struct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, struct);
    updateV2VJobs(vds, struct);
}
#method_after
public void updateVDSStatisticsData(VDS vds, Map<String, Object> struct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(assignIntValue(struct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) struct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder();
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(assignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkCommonUtils.isVlan(existingIface) && !existingIface.isPartOfBond()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface);
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(assignDoubleValue(struct, VdsProperties.cpu_sys));
    vds.setCpuUser(assignDoubleValue(struct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = assignDoubleValue(struct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(assignDoubleValue(struct, VdsProperties.cpu_idle));
    vds.setMemAvailable(assignLongValue(struct, VdsProperties.mem_available));
    vds.setMemFree(assignLongValue(struct, VdsProperties.memFree));
    vds.setMemShared(assignLongValue(struct, VdsProperties.mem_shared));
    vds.setSwapFree(assignLongValue(struct, VdsProperties.swap_free));
    vds.setSwapTotal(assignLongValue(struct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(assignIntValue(struct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(assignLongValue(struct, VdsProperties.ksm_pages));
    vds.setKsmState(assignBoolValue(struct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (struct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, struct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (struct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(assignIntValue(struct, VdsProperties.anonymous_transparent_huge_pages));
    }
    if (struct.containsKey(VdsProperties.hugepages)) {
        Object hugepages = struct.get(VdsProperties.hugepages);
        if (hugepages instanceof Map) {
            Map<String, Map<String, String>> hugepagesMap = (Map<String, Map<String, String>>) hugepages;
            List<HugePage> parsedHugePages = hugepagesMap.entrySet().stream().map(entry -> new HugePage(Integer.parseInt(entry.getKey()), assignIntValue(entry.getValue(), VdsProperties.free_hugepages))).collect(Collectors.toList());
            vds.setHugePages(parsedHugePages);
        }
    }
    vds.setNetConfigDirty(assignBoolValue(struct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(assignDoubleValue(struct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(assignDoubleValue(struct, VdsProperties.images_last_delay));
    Integer vm_count = assignIntValue(struct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(assignIntValue(struct, VdsProperties.vm_active));
    vds.setVmMigrating(assignIntValue(struct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = assignIntValue(struct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = assignIntValue(struct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, struct);
    updateLocalDisksUsage(vds, struct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (struct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) struct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = assignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = assignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = assignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = assignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = assignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = assignIntValue(struct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = haScore > 0;
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(assignLongValue(struct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, struct);
    updateV2VJobs(vds, struct);
}
#end_block

#method_before
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> struct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vds.getNumaNodeList() != null && !vds.getNumaNodeList().isEmpty()) {
        vdsNumaNodes.addAll(vds.getNumaNodeList());
    }
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (struct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) struct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = assignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode nodeWithStatistics = buildVdsNumaNodeStatistics(percentageFormatter, item);
            if (vdsNumaNodes.isEmpty()) {
                vdsNumaNodes.add(nodeWithStatistics);
            } else {
                boolean foundNumaNode = false;
                // append the statistics to the correct numaNode (search by its Index.)
                for (VdsNumaNode currNumaNode : vdsNumaNodes) {
                    if (currNumaNode.getIndex() == nodeWithStatistics.getIndex()) {
                        currNumaNode.setNumaNodeStatistics(nodeWithStatistics.getNumaNodeStatistics());
                        foundNumaNode = true;
                        break;
                    }
                }
                // append new numaNode (contains only statistics) if not found existing
                if (!foundNumaNode) {
                    vdsNumaNodes.add(nodeWithStatistics);
                }
            }
        }
    }
    if (struct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.parseInt(item.getKey()));
            if (node != null && node.getNumaNodeStatistics() != null) {
                node.getNumaNodeStatistics().setMemFree(assignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(assignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#method_after
public void updateNumaStatisticsData(VDS vds, Map<String, Object> struct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vds.getNumaNodeList() != null && !vds.getNumaNodeList().isEmpty()) {
        vdsNumaNodes.addAll(vds.getNumaNodeList());
    }
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (struct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) struct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = assignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode nodeWithStatistics = buildVdsNumaNodeStatistics(percentageFormatter, item);
            if (vdsNumaNodes.isEmpty()) {
                vdsNumaNodes.add(nodeWithStatistics);
            } else {
                boolean foundNumaNode = false;
                // append the statistics to the correct numaNode (search by its Index.)
                for (VdsNumaNode currNumaNode : vdsNumaNodes) {
                    if (currNumaNode.getIndex() == nodeWithStatistics.getIndex()) {
                        currNumaNode.setNumaNodeStatistics(nodeWithStatistics.getNumaNodeStatistics());
                        foundNumaNode = true;
                        break;
                    }
                }
                // append new numaNode (contains only statistics) if not found existing
                if (!foundNumaNode) {
                    vdsNumaNodes.add(nodeWithStatistics);
                }
            }
        }
    }
    if (struct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.parseInt(item.getKey()));
            if (node != null && node.getNumaNodeStatistics() != null) {
                node.getNumaNodeStatistics().setMemFree(assignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(assignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#end_block

#method_before
protected static void updateLocalDisksUsage(VDS vds, Map<String, Object> struct) {
    if (struct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) struct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<>();
        // collect(Collectors.toMap(...)) will not work here as it uses merge() internally and
        // will fail on null values
        diskStatsStruct.entrySet().forEach(e -> diskStats.put(e.getKey(), assignLongValue((Map<String, Object>) e.getValue(), VdsProperties.DISK_STATS_FREE)));
        vds.setLocalDisksUsage(diskStats);
    }
}
#method_after
protected void updateLocalDisksUsage(VDS vds, Map<String, Object> struct) {
    if (struct.containsKey(VdsProperties.DISK_STATS)) {
        Map<String, Object> diskStatsStruct = (Map<String, Object>) struct.get(VdsProperties.DISK_STATS);
        Map<String, Long> diskStats = new HashMap<>();
        // collect(Collectors.toMap(...)) will not work here as it uses merge() internally and
        // will fail on null values
        diskStatsStruct.entrySet().forEach(e -> diskStats.put(e.getKey(), assignLongValue((Map<String, Object>) e.getValue(), VdsProperties.DISK_STATS_FREE)));
        vds.setLocalDisksUsage(diskStats);
    }
}
#end_block

#method_before
public static List<DiskImageDynamic> buildVmDiskStatistics(Map<String, Object> vmStruct) {
    Map<String, Object> disks = (Map<String, Object>) vmStruct.get(VdsProperties.vm_disks);
    if (disks == null) {
        return Collections.emptyList();
    }
    List<DiskImageDynamic> disksData = new ArrayList<>();
    for (Object diskAsObj : disks.values()) {
        Map<String, Object> disk = (Map<String, Object>) diskAsObj;
        DiskImageDynamic diskData = new DiskImageDynamic();
        String imageGroupIdString = assignStringValue(disk, VdsProperties.image_group_id);
        if (!StringUtils.isEmpty(imageGroupIdString)) {
            Guid imageGroupIdGuid = new Guid(imageGroupIdString);
            diskData.setId(imageGroupIdGuid);
            diskData.setReadRate(assignIntValue(disk, VdsProperties.vm_disk_read_rate));
            diskData.setWriteRate(assignIntValue(disk, VdsProperties.vm_disk_write_rate));
            if (disk.containsKey(VdsProperties.disk_true_size)) {
                Long size = assignLongValue(disk, VdsProperties.disk_true_size);
                diskData.setActualSize(size != null ? size : 0);
            }
            if (disk.containsKey(VdsProperties.vm_disk_read_latency)) {
                diskData.setReadLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_read_latency) / NANO_SECONDS);
            }
            if (disk.containsKey(VdsProperties.vm_disk_write_latency)) {
                diskData.setWriteLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_write_latency) / NANO_SECONDS);
            }
            if (disk.containsKey(VdsProperties.vm_disk_flush_latency)) {
                diskData.setFlushLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_flush_latency) / NANO_SECONDS);
            }
            disksData.add(diskData);
        }
    }
    return disksData;
}
#method_after
public List<DiskImageDynamic> buildVmDiskStatistics(Map<String, Object> vmStruct) {
    Map<String, Object> disks = (Map<String, Object>) vmStruct.get(VdsProperties.vm_disks);
    if (disks == null) {
        return Collections.emptyList();
    }
    List<DiskImageDynamic> disksData = new ArrayList<>();
    for (Object diskAsObj : disks.values()) {
        Map<String, Object> disk = (Map<String, Object>) diskAsObj;
        DiskImageDynamic diskData = new DiskImageDynamic();
        String imageGroupIdString = assignStringValue(disk, VdsProperties.image_group_id);
        if (!StringUtils.isEmpty(imageGroupIdString)) {
            Guid imageGroupIdGuid = new Guid(imageGroupIdString);
            diskData.setId(imageGroupIdGuid);
            diskData.setReadRate(assignIntValue(disk, VdsProperties.vm_disk_read_rate));
            diskData.setWriteRate(assignIntValue(disk, VdsProperties.vm_disk_write_rate));
            if (disk.containsKey(VdsProperties.disk_true_size)) {
                Long size = assignLongValue(disk, VdsProperties.disk_true_size);
                diskData.setActualSize(size != null ? size : 0);
            }
            if (disk.containsKey(VdsProperties.vm_disk_read_latency)) {
                diskData.setReadLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_read_latency) / NANO_SECONDS);
            }
            if (disk.containsKey(VdsProperties.vm_disk_write_latency)) {
                diskData.setWriteLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_write_latency) / NANO_SECONDS);
            }
            if (disk.containsKey(VdsProperties.vm_disk_flush_latency)) {
                diskData.setFlushLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_flush_latency) / NANO_SECONDS);
            }
            disksData.add(diskData);
        }
    }
    return disksData;
}
#end_block

#method_before
public static VMStatus convertToVmStatus(String status) {
    switch(status) {
        case VdsProperties.MIGRATION_SOURCE:
            return VMStatus.MigratingFrom;
        case VdsProperties.MIGRATION_DESTINATION:
            return VMStatus.MigratingTo;
        default:
            status = status.replace(" ", "");
            try {
                return EnumUtils.valueOf(VMStatus.class, status, true);
            } catch (Exception e) {
                log.error("Illegal VM status: '{}'.", status);
                return VMStatus.Unassigned;
            }
    }
}
#method_after
public VMStatus convertToVmStatus(String status) {
    switch(status) {
        case VdsProperties.MIGRATION_SOURCE:
            return VMStatus.MigratingFrom;
        case VdsProperties.MIGRATION_DESTINATION:
            return VMStatus.MigratingTo;
        default:
            status = status.replace(" ", "");
            try {
                return EnumUtils.valueOf(VMStatus.class, status, true);
            } catch (Exception e) {
                log.error("Illegal VM status: '{}'.", status);
                return VMStatus.Unassigned;
            }
    }
}
#end_block

#method_before
public static void updateNetworkData(VDS vds, Map<String, String> vdsmNameMap, Map<String, Object> struct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, struct);
    addHostVlanDevices(vds, struct);
    addHostBondDevices(vds, struct);
    addHostNetworksAndUpdateInterfaces(vds, vdsmNameMap, struct);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (struct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(assignBoolValue(struct, VdsProperties.netConfigDirty));
    }
    setVlanSpeeds(vds);
}
#method_after
public void updateNetworkData(VDS vds, Map<String, String> vdsmNameMap, Map<String, Object> struct) {
    List<VdsNetworkInterface> oldInterfaces = interfaceDao.getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, struct);
    addHostVlanDevices(vds, struct);
    addHostBondDevices(vds, struct);
    addHostNetworksAndUpdateInterfaces(vds, vdsmNameMap, struct);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (struct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(assignBoolValue(struct, VdsProperties.netConfigDirty));
    }
    setVlanSpeeds(vds);
}
#end_block

#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS host, Map<String, String> vdsmNameMap, Map<String, Object> struct) {
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORK_BRIDGES);
    final String hostActiveNicName = findActiveNicName(host, bridges);
    host.setActiveNic(hostActiveNicName);
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORKS);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(host.getInterfaces());
    if (networks != null) {
        host.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String vdsmName = entry.getKey();
            String networkName = vdsmNameMap.containsKey(vdsmName) ? vdsmNameMap.get(vdsmName) : vdsmName;
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                SwitchType switchType = getSwitchType(host.getSupportedClusterVersionsSet().stream().filter(v -> Version.getLast().compareTo(v) >= 0).max(Comparator.naturalOrder()).orElse(Version.getLowest()), networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String v4addr = extractAddress(effectiveProperties);
                String v4Subnet = extractSubnet(effectiveProperties);
                String v4gateway = extractGateway(effectiveProperties);
                boolean v4DefaultRoute = assignBoolValue(effectiveProperties, VdsProperties.IPV4_DEFAULT_ROUTE);
                final String rawIpv6Address = getIpv6Address(effectiveProperties);
                String v6Addr = extractIpv6Address(rawIpv6Address);
                Integer v6Prefix = extractIpv6Prefix(rawIpv6Address);
                String v6gateway = extractIPV6gateway(effectiveProperties);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setIpv4Address(v4addr);
                    iface.setIpv4Subnet(v4Subnet);
                    iface.setIpv4DefaultRoute(v4DefaultRoute);
                    iface.setIpv6Address(v6Addr);
                    iface.setIpv6Prefix(v6Prefix);
                    iface.setBridged(bridgedNetwork);
                    iface.setReportedSwitchType(switchType);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), host.getClusterId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    if (StringUtils.isNotEmpty(v4gateway)) {
                        iface.setIpv4Gateway(v4gateway);
                    }
                    if (StringUtils.isNotEmpty(v6gateway)) {
                        iface.setIpv6Gateway(v6gateway);
                    }
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, iface);
                    }
                }
                host.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, host);
            }
        }
    }
}
#method_after
private void addHostNetworksAndUpdateInterfaces(VDS host, Map<String, String> vdsmNameMap, Map<String, Object> struct) {
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORK_BRIDGES);
    final String hostActiveNicName = findActiveNicName(host, bridges);
    host.setActiveNic(hostActiveNicName);
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORKS);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(host.getInterfaces());
    if (networks != null) {
        host.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String vdsmName = entry.getKey();
            String networkName = vdsmNameMap.containsKey(vdsmName) ? vdsmNameMap.get(vdsmName) : vdsmName;
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                SwitchType switchType = getSwitchType(host.getSupportedClusterVersionsSet().stream().filter(v -> Version.getLast().compareTo(v) >= 0).max(Comparator.naturalOrder()).orElse(Version.getLowest()), networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String v4addr = extractAddress(effectiveProperties);
                String v4Subnet = extractSubnet(effectiveProperties);
                String v4gateway = extractGateway(effectiveProperties);
                boolean v4DefaultRoute = assignBoolValue(effectiveProperties, VdsProperties.IPV4_DEFAULT_ROUTE);
                final String rawIpv6Address = getIpv6Address(effectiveProperties);
                String v6Addr = extractIpv6Address(rawIpv6Address);
                Integer v6Prefix = extractIpv6Prefix(rawIpv6Address);
                String v6gateway = extractIpv6Gateway(effectiveProperties);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setIpv4Address(v4addr);
                    iface.setIpv4Subnet(v4Subnet);
                    iface.setIpv4Gateway(v4gateway);
                    iface.setIpv4DefaultRoute(v4DefaultRoute);
                    iface.setIpv6Address(v6Addr);
                    iface.setIpv6Gateway(v6gateway);
                    iface.setIpv6Prefix(v6Prefix);
                    iface.setBridged(bridgedNetwork);
                    iface.setReportedSwitchType(switchType);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), host.getClusterId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, iface);
                    }
                }
                host.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, host);
            }
        }
    }
}
#end_block

#method_before
private static String findActiveNicName(VDS vds, Map<String, Map<String, Object>> bridges) {
    final String hostIp = NetworkUtils.getHostIp(vds);
    final String activeBridge = findActiveBridge(hostIp, bridges);
    if (activeBridge != null) {
        return activeBridge;
    }
    // by now, if the host is communicating with engine over a valid interface,
    // the interface will have the host's engine IP
    final VdsNetworkInterface activeIface = resolveActiveNic(vds, hostIp);
    String hostActiveNic = (activeIface == null) ? null : activeIface.getName();
    return hostActiveNic;
}
#method_after
private String findActiveNicName(VDS vds, Map<String, Map<String, Object>> bridges) {
    final String hostIp = NetworkUtils.getHostIp(vds);
    final String activeBridge = findActiveBridge(hostIp, bridges);
    if (activeBridge != null) {
        return activeBridge;
    }
    // by now, if the host is communicating with engine over a valid interface,
    // the interface will have the host's engine IP
    final VdsNetworkInterface activeIface = resolveActiveNic(vds, hostIp);
    String hostActiveNic = (activeIface == null) ? null : activeIface.getName();
    return hostActiveNic;
}
#end_block

#method_before
private static String findActiveBridge(String ipAddress, Map<String, Map<String, Object>> bridges) {
    if (bridges != null) {
        final Predicate<String> ipAddressPredicate = new IpAddressPredicate(ipAddress);
        for (Entry<String, Map<String, Object>> entry : bridges.entrySet()) {
            Map<String, Object> bridgeProperties = entry.getValue();
            String bridgeName = entry.getKey();
            if (bridgeProperties != null) {
                String bridgeIpv4Address = (String) bridgeProperties.get("addr");
                String bridgeIpv6Address = extractIpv6Address(getIpv6Address(bridgeProperties));
                // in case host is communicating with engine over a bridge
                if (ipAddressPredicate.test(bridgeIpv4Address) || ipAddressPredicate.test(bridgeIpv6Address)) {
                    return bridgeName;
                }
            }
        }
    }
    return null;
}
#method_after
private String findActiveBridge(String ipAddress, Map<String, Map<String, Object>> bridges) {
    if (bridges != null) {
        final Predicate<String> ipAddressPredicate = new IpAddressPredicate(ipAddress);
        for (Entry<String, Map<String, Object>> entry : bridges.entrySet()) {
            Map<String, Object> bridgeProperties = entry.getValue();
            String bridgeName = entry.getKey();
            if (bridgeProperties != null) {
                String bridgeIpv4Address = (String) bridgeProperties.get("addr");
                String bridgeIpv6Address = extractIpv6Address(getIpv6Address(bridgeProperties));
                // in case host is communicating with engine over a bridge
                if (ipAddressPredicate.test(bridgeIpv4Address) || ipAddressPredicate.test(bridgeIpv6Address)) {
                    return bridgeName;
                }
            }
        }
    }
    return null;
}
#end_block

#method_before
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogable logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", interfaces.stream().map(VdsNetworkInterface::getName).collect(Collectors.joining(",")));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#method_after
private void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogable logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", interfaces.stream().map(VdsNetworkInterface::getName).collect(Collectors.joining(",")));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> struct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            Bond bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                bond.setBondOptions(parseBondOptions((Map<String, Object>) bondProperties.get("opts")));
                bond.setAdPartnerMac((String) bondProperties.get("ad_partner_mac"));
                bond.setActiveSlave((String) bondProperties.get("active_slave"));
            }
        }
    }
}
#method_after
private void addHostBondDevices(VDS vds, Map<String, Object> struct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            Bond bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                bond.setBondOptions(parseBondOptions((Map<String, Object>) bondProperties.get("opts")));
                bond.setAdPartnerMac((String) bondProperties.get("ad_partner_mac"));
                bond.setActiveSlave((String) bondProperties.get("active_slave"));
            }
        }
    }
}
#end_block

#method_before
private static void addHostVlanDevices(VDS vds, Map<String, Object> struct) {
    // vlans
    Map<String, Map<String, Object>> vlans = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Map<String, Object>> entry : vlans.entrySet()) {
            VdsNetworkInterface vlan = new Vlan();
            updateCommonInterfaceData(vlan, vds, entry);
            String vlanDeviceName = entry.getKey();
            Map<String, Object> vlanProperties = entry.getValue();
            if (vlanProperties.get(VdsProperties.VLAN_ID) != null && vlanProperties.get(VdsProperties.BASE_INTERFACE) != null) {
                vlan.setVlanId((Integer) vlanProperties.get(VdsProperties.VLAN_ID));
                vlan.setBaseInterface((String) vlanProperties.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                vlan.setVlanId(Integer.parseInt(vlanId));
                vlan.setBaseInterface(names[0]);
            }
            vds.getInterfaces().add(vlan);
        }
    }
}
#method_after
private void addHostVlanDevices(VDS vds, Map<String, Object> struct) {
    // vlans
    Map<String, Map<String, Object>> vlans = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Map<String, Object>> entry : vlans.entrySet()) {
            VdsNetworkInterface vlan = new Vlan();
            updateCommonInterfaceData(vlan, vds, entry);
            String vlanDeviceName = entry.getKey();
            Map<String, Object> vlanProperties = entry.getValue();
            if (vlanProperties.get(VdsProperties.VLAN_ID) != null && vlanProperties.get(VdsProperties.BASE_INTERFACE) != null) {
                vlan.setVlanId((Integer) vlanProperties.get(VdsProperties.VLAN_ID));
                vlan.setBaseInterface((String) vlanProperties.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                vlan.setVlanId(Integer.parseInt(vlanId));
                vlan.setBaseInterface(names[0]);
            }
            vds.getInterfaces().add(vlan);
        }
    }
}
#end_block

#method_before
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> struct) {
    Map<String, Map<String, Object>> nics = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Map<String, Object>> entry : nics.entrySet()) {
            VdsNetworkInterface nic = new Nic();
            updateCommonInterfaceData(nic, vds, entry);
            Map<String, Object> nicProperties = entry.getValue();
            if (nicProperties != null) {
                nic.setMacAddress((String) nicProperties.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                String mac = (String) nicProperties.get("permhwaddr");
                if (mac != null) {
                    // TODO remove when the minimal supported vdsm version is >=3.6
                    // in older VDSM version, slave's Mac is in upper case
                    nic.setMacAddress(mac.toLowerCase());
                }
            }
            vds.getInterfaces().add(nic);
        }
    }
}
#method_after
private void addHostNetworkInterfaces(VDS vds, Map<String, Object> struct) {
    Map<String, Map<String, Object>> nics = (Map<String, Map<String, Object>>) struct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Map<String, Object>> entry : nics.entrySet()) {
            VdsNetworkInterface nic = new Nic();
            updateCommonInterfaceData(nic, vds, entry);
            Map<String, Object> nicProperties = entry.getValue();
            if (nicProperties != null) {
                nic.setMacAddress((String) nicProperties.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                String mac = (String) nicProperties.get("permhwaddr");
                if (mac != null) {
                    // TODO remove when the minimal supported vdsm version is >=3.6
                    // in older VDSM version, slave's Mac is in upper case
                    nic.setMacAddress(mac.toLowerCase());
                }
            }
            vds.getInterfaces().add(nic);
        }
    }
}
#end_block

#method_before
private static void updateCommonInterfaceData(VdsNetworkInterface iface, VDS host, Entry<String, Map<String, Object>> ifaceEntry) {
    iface.setName(ifaceEntry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(host.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(host.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nicProperties = ifaceEntry.getValue();
    if (nicProperties != null) {
        Object speed = nicProperties.get("speed");
        if (speed != null) {
            iface.setSpeed((Integer) speed);
        }
        iface.setIpv4Address(extractAddress(nicProperties));
        iface.setIpv4Subnet(extractSubnet(nicProperties));
        final String ipv6Address = getIpv6Address(nicProperties);
        iface.setIpv6Address(extractIpv6Address(ipv6Address));
        iface.setIpv6Prefix(extractIpv6Prefix(ipv6Address));
        final Integer mtu = assignIntValue(nicProperties, VdsProperties.MTU);
        if (mtu != null) {
            iface.setMtu(mtu);
        }
        addBootProtocol(nicProperties, iface);
        addAdAggregatorId(nicProperties, iface);
    }
}
#method_after
private void updateCommonInterfaceData(VdsNetworkInterface iface, VDS host, Entry<String, Map<String, Object>> ifaceEntry) {
    iface.setName(ifaceEntry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(host.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(host.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nicProperties = ifaceEntry.getValue();
    if (nicProperties != null) {
        Object speed = nicProperties.get("speed");
        if (speed != null) {
            iface.setSpeed((Integer) speed);
        }
        iface.setIpv4Address(extractAddress(nicProperties));
        iface.setIpv4Subnet(extractSubnet(nicProperties));
        final String ipv6Address = getIpv6Address(nicProperties);
        iface.setIpv6Address(extractIpv6Address(ipv6Address));
        iface.setIpv6Prefix(extractIpv6Prefix(ipv6Address));
        final Integer mtu = assignIntValue(nicProperties, VdsProperties.MTU);
        if (mtu != null) {
            iface.setMtu(mtu);
        }
        addBootProtocol(nicProperties, iface);
        addAdAggregatorId(nicProperties, iface);
    }
}
#end_block

#method_before
static Integer extractIpv6Prefix(String ipv6Address) {
    if (ipv6Address == null) {
        return null;
    }
    final Matcher matcher = IPV6_ADDRESS_CAPTURE_PREFIX_PATTERN.matcher(ipv6Address);
    if (matcher.matches()) {
        final String prefixString = matcher.group(1);
        return Integer.valueOf(prefixString);
    }
    return null;
}
#method_after
Integer extractIpv6Prefix(String ipv6Address) {
    if (ipv6Address == null) {
        return null;
    }
    final Matcher matcher = IPV6_ADDRESS_CAPTURE_PREFIX_PATTERN.matcher(ipv6Address);
    if (matcher.matches()) {
        final String prefixString = matcher.group(1);
        return Integer.valueOf(prefixString);
    }
    return null;
}
#end_block

#method_before
static String extractAddress(Map<String, Object> properties) {
    String address = (String) properties.get(ADDR);
    return StringUtils.isEmpty(address) ? null : address;
}
#method_after
String extractAddress(Map<String, Object> properties) {
    return extractNonEmptyProperty(properties, VdsProperties.ADDR);
}
#end_block

#method_before
static String extractSubnet(Map<String, Object> properties) {
    String netmask = (String) properties.get(NETMASK);
    return StringUtils.isEmpty(netmask) ? null : netmask;
}
#method_after
String extractSubnet(Map<String, Object> properties) {
    return extractNonEmptyProperty(properties, VdsProperties.NETMASK);
}
#end_block

#method_before
static String extractGateway(Map<String, Object> properties) {
    String gateway = (String) properties.get(VdsProperties.GLOBAL_GATEWAY);
    return StringUtils.isEmpty(gateway) ? null : gateway;
}
#method_after
String extractGateway(Map<String, Object> properties) {
    return extractNonEmptyProperty(properties, VdsProperties.GLOBAL_GATEWAY);
}
#end_block

#method_before
static String extractIpv6Address(String address) {
    if (StringUtils.isEmpty(address)) {
        return null;
    }
    final Matcher matcher = IPV6_ADDRESS_CAPTURE_PATTERN.matcher(address);
    return matcher.matches() ? matcher.group(1) : address;
}
#method_after
String extractIpv6Address(String address) {
    if (StringUtils.isEmpty(address)) {
        return null;
    }
    final Matcher matcher = IPV6_ADDRESS_CAPTURE_PATTERN.matcher(address);
    return matcher.matches() ? matcher.group(1) : address;
}
#end_block

#method_before
public static List<VmGuestAgentInterface> buildVmGuestAgentInterfacesData(Guid vmId, Map<String, Object> struct) {
    if (!struct.containsKey(VdsProperties.VM_NETWORK_INTERFACES)) {
        return null;
    }
    List<VmGuestAgentInterface> interfaces = new ArrayList<>();
    for (Object ifaceStruct : (Object[]) struct.get(VdsProperties.VM_NETWORK_INTERFACES)) {
        VmGuestAgentInterface nic = new VmGuestAgentInterface();
        Map ifaceMap = (Map) ifaceStruct;
        nic.setInterfaceName(assignStringValue(ifaceMap, VdsProperties.VM_INTERFACE_NAME));
        nic.setMacAddress(getMacAddress(ifaceMap));
        nic.setIpv4Addresses(extractList(ifaceMap, VdsProperties.VM_IPV4_ADDRESSES, true));
        nic.setIpv6Addresses(extractList(ifaceMap, VdsProperties.VM_IPV6_ADDRESSES, true));
        nic.setVmId(vmId);
        interfaces.add(nic);
    }
    return interfaces;
}
#method_after
public List<VmGuestAgentInterface> buildVmGuestAgentInterfacesData(Guid vmId, Map<String, Object> struct) {
    if (!struct.containsKey(VdsProperties.VM_NETWORK_INTERFACES)) {
        return null;
    }
    List<VmGuestAgentInterface> interfaces = new ArrayList<>();
    for (Object ifaceStruct : (Object[]) struct.get(VdsProperties.VM_NETWORK_INTERFACES)) {
        VmGuestAgentInterface nic = new VmGuestAgentInterface();
        Map ifaceMap = (Map) ifaceStruct;
        nic.setInterfaceName(assignStringValue(ifaceMap, VdsProperties.VM_INTERFACE_NAME));
        nic.setMacAddress(getMacAddress(ifaceMap));
        nic.setIpv4Addresses(extractList(ifaceMap, VdsProperties.VM_IPV4_ADDRESSES, true));
        nic.setIpv6Addresses(extractList(ifaceMap, VdsProperties.VM_IPV6_ADDRESSES, true));
        nic.setVmId(vmId);
        interfaces.add(nic);
    }
    return interfaces;
}
#end_block

#method_before
public static List<HostDevice> buildHostDevices(Map<String, Map<String, Map<String, Object>>> deviceList) {
    List<HostDevice> devices = new ArrayList<>();
    for (Entry<String, Map<String, Map<String, Object>>> entry : deviceList.entrySet()) {
        Map<String, Object> params = entry.getValue().get(VdsProperties.PARAMS);
        String deviceName = entry.getKey();
        HostDevice device = new HostDevice();
        device.setDeviceName(entry.getKey());
        device.setCapability(params.get(VdsProperties.CAPABILITY).toString());
        // special case for root device "computer"
        device.setParentDeviceName(VdsProperties.ROOT_HOST_DEVICE.equals(deviceName) ? // set parent to self, for DB integrity
        VdsProperties.ROOT_HOST_DEVICE : params.get(VdsProperties.PARENT_NAME).toString());
        device.setAssignable(params.containsKey(VdsProperties.IS_ASSIGNABLE) ? assignBoolValue(params, VdsProperties.IS_ASSIGNABLE) : true);
        if (params.containsKey(VdsProperties.MDEV)) {
            device.setMdevTypes(((Map<String, Object>) params.get(VdsProperties.MDEV)).keySet());
        }
        if (params.containsKey(VdsProperties.IOMMU_GROUP)) {
            device.setIommuGroup(Integer.parseInt(params.get(VdsProperties.IOMMU_GROUP).toString()));
        }
        if (params.containsKey(VdsProperties.PRODUCT_ID)) {
            device.setProductId(params.get(VdsProperties.PRODUCT_ID).toString());
        }
        if (params.containsKey(VdsProperties.PRODUCT_NAME)) {
            device.setProductName(params.get(VdsProperties.PRODUCT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_NAME)) {
            device.setVendorName(params.get(VdsProperties.VENDOR_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_ID)) {
            device.setVendorId(params.get(VdsProperties.VENDOR_ID).toString());
        }
        if (params.containsKey(VdsProperties.PHYSICAL_FUNCTION)) {
            device.setParentPhysicalFunction(params.get(VdsProperties.PHYSICAL_FUNCTION).toString());
        }
        if (params.containsKey(VdsProperties.TOTAL_VFS)) {
            device.setTotalVirtualFunctions(Integer.parseInt(params.get(VdsProperties.TOTAL_VFS).toString()));
        }
        if (params.containsKey(VdsProperties.NET_INTERFACE_NAME)) {
            device.setNetworkInterfaceName(params.get(VdsProperties.NET_INTERFACE_NAME).toString());
        }
        if (params.containsKey(VdsProperties.DRIVER)) {
            device.setDriver(params.get(VdsProperties.DRIVER).toString());
        }
        if (params.containsKey(VdsProperties.Address)) {
            device.setAddress((Map<String, String>) params.get(VdsProperties.Address));
        }
        devices.add(device);
    }
    return devices;
}
#method_after
public List<HostDevice> buildHostDevices(Map<String, Map<String, Map<String, Object>>> deviceList) {
    List<HostDevice> devices = new ArrayList<>();
    for (Entry<String, Map<String, Map<String, Object>>> entry : deviceList.entrySet()) {
        Map<String, Object> params = entry.getValue().get(VdsProperties.PARAMS);
        String deviceName = entry.getKey();
        HostDevice device = new HostDevice();
        device.setDeviceName(entry.getKey());
        device.setCapability(params.get(VdsProperties.CAPABILITY).toString());
        // special case for root device "computer"
        device.setParentDeviceName(VdsProperties.ROOT_HOST_DEVICE.equals(deviceName) ? // set parent to self, for DB integrity
        VdsProperties.ROOT_HOST_DEVICE : params.get(VdsProperties.PARENT_NAME).toString());
        device.setAssignable(params.containsKey(VdsProperties.IS_ASSIGNABLE) ? assignBoolValue(params, VdsProperties.IS_ASSIGNABLE) : true);
        if (params.containsKey(VdsProperties.MDEV)) {
            device.setMdevTypes(((Map<String, Object>) params.get(VdsProperties.MDEV)).keySet());
        }
        if (params.containsKey(VdsProperties.IOMMU_GROUP)) {
            device.setIommuGroup(Integer.parseInt(params.get(VdsProperties.IOMMU_GROUP).toString()));
        }
        if (params.containsKey(VdsProperties.PRODUCT_ID)) {
            device.setProductId(params.get(VdsProperties.PRODUCT_ID).toString());
        }
        if (params.containsKey(VdsProperties.PRODUCT_NAME)) {
            device.setProductName(params.get(VdsProperties.PRODUCT_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_NAME)) {
            device.setVendorName(params.get(VdsProperties.VENDOR_NAME).toString());
        }
        if (params.containsKey(VdsProperties.VENDOR_ID)) {
            device.setVendorId(params.get(VdsProperties.VENDOR_ID).toString());
        }
        if (params.containsKey(VdsProperties.PHYSICAL_FUNCTION)) {
            device.setParentPhysicalFunction(params.get(VdsProperties.PHYSICAL_FUNCTION).toString());
        }
        if (params.containsKey(VdsProperties.TOTAL_VFS)) {
            device.setTotalVirtualFunctions(Integer.parseInt(params.get(VdsProperties.TOTAL_VFS).toString()));
        }
        if (params.containsKey(VdsProperties.NET_INTERFACE_NAME)) {
            device.setNetworkInterfaceName(params.get(VdsProperties.NET_INTERFACE_NAME).toString());
        }
        if (params.containsKey(VdsProperties.DRIVER)) {
            device.setDriver(params.get(VdsProperties.DRIVER).toString());
        }
        if (params.containsKey(VdsProperties.Address)) {
            device.setAddress((Map<String, String>) params.get(VdsProperties.Address));
        }
        devices.add(device);
    }
    return devices;
}
#end_block

#method_before
public static Double removeNotifyTimeFromVmStatusEvent(Map<String, Object> struct) {
    Object notifyTime = struct.remove(VdsProperties.notify_time);
    if (Long.class.isInstance(notifyTime)) {
        return ((Long) notifyTime).doubleValue();
    }
    return null;
}
#method_after
public Double removeNotifyTimeFromVmStatusEvent(Map<String, Object> struct) {
    Object notifyTime = struct.remove(VdsProperties.notify_time);
    if (Long.class.isInstance(notifyTime)) {
        return ((Long) notifyTime).doubleValue();
    }
    return null;
}
#end_block

#method_before
public static LeaseStatus buildLeaseStatus(Map<String, Object> struct) {
    return new LeaseStatus(extractList(struct, "owners", true));
}
#method_after
public LeaseStatus buildLeaseStatus(Map<String, Object> struct) {
    return new LeaseStatus(extractList(struct, "owners", true));
}
#end_block

#method_before
@Test
public void testNullDisksUsages() {
    VmStatistics vmStatistics = getVmStatistics();
    Map<String, Object> xml = setDisksUsage(null);
    VdsBrokerObjectsBuilder.updateVMStatisticsData(vmStatistics, xml);
    assertNull(vmStatistics.getDisksUsage());
}
#method_after
@Test
public void testNullDisksUsages() {
    VmStatistics vmStatistics = getVmStatistics();
    Map<String, Object> xml = setDisksUsage(null);
    vdsBrokerObjectsBuilder.updateVMStatisticsData(vmStatistics, xml);
    assertNull(vmStatistics.getDisksUsage());
}
#end_block

#method_before
@Test
public void testFlushLatency() {
    String doubleValue = "1";
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_flush_latency, doubleValue);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = VdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(new Double("0.000000001"), disks.get(0).getFlushLatency());
}
#method_after
@Test
public void testFlushLatency() {
    String doubleValue = "1";
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_flush_latency, doubleValue);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = vdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(new Double("0.000000001"), disks.get(0).getFlushLatency());
}
#end_block

#method_before
@Test
public void testReadLatency() {
    String doubleValue = "2";
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_read_latency, doubleValue);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = VdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(new Double("0.000000002"), disks.get(0).getReadLatency());
}
#method_after
@Test
public void testReadLatency() {
    String doubleValue = "2";
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_read_latency, doubleValue);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = vdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(new Double("0.000000002"), disks.get(0).getReadLatency());
}
#end_block

#method_before
@Test
public void testWriteLatency() {
    String doubleValue = "3";
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_write_latency, doubleValue);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = VdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(new Double("0.000000003"), disks.get(0).getWriteLatency());
}
#method_after
@Test
public void testWriteLatency() {
    String doubleValue = "3";
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_write_latency, doubleValue);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = vdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(new Double("0.000000003"), disks.get(0).getWriteLatency());
}
#end_block

#method_before
@Test
public void testOneSecondLatency() {
    String doubleValue = "1000000000";
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_write_latency, doubleValue);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = VdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(new Double("1"), disks.get(0).getWriteLatency());
}
#method_after
@Test
public void testOneSecondLatency() {
    String doubleValue = "1000000000";
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_write_latency, doubleValue);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = vdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(new Double("1"), disks.get(0).getWriteLatency());
}
#end_block

#method_before
@Test
public void testZeroLatency() {
    String doubleValue = "0";
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_write_latency, doubleValue);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = VdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(new Double("0"), disks.get(0).getWriteLatency());
}
#method_after
@Test
public void testZeroLatency() {
    String doubleValue = "0";
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_write_latency, doubleValue);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = vdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(new Double("0"), disks.get(0).getWriteLatency());
}
#end_block

#method_before
@Test
public void testMaximumLatency() {
    String doubleValue = "999999999000000000";
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_write_latency, doubleValue);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = VdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(new Double("999999999"), disks.get(0).getWriteLatency());
}
#method_after
@Test
public void testMaximumLatency() {
    String doubleValue = "999999999000000000";
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_write_latency, doubleValue);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = vdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(new Double("999999999"), disks.get(0).getWriteLatency());
}
#end_block

#method_before
@Test
public void testNullValuesLatency() {
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_write_latency, null);
    diskData.put(VdsProperties.vm_disk_read_latency, null);
    diskData.put(VdsProperties.vm_disk_flush_latency, null);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = VdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(disks.get(0).getWriteLatency(), new Double(DEFAULT_VALUE));
    assertEquals(disks.get(0).getReadLatency(), new Double(DEFAULT_VALUE));
    assertEquals(disks.get(0).getFlushLatency(), new Double(DEFAULT_VALUE));
}
#method_after
@Test
public void testNullValuesLatency() {
    Map<String, Object> diskData = setDiskData();
    diskData.put(VdsProperties.vm_disk_write_latency, null);
    diskData.put(VdsProperties.vm_disk_read_latency, null);
    diskData.put(VdsProperties.vm_disk_flush_latency, null);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = vdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertEquals(disks.get(0).getWriteLatency(), new Double(DEFAULT_VALUE));
    assertEquals(disks.get(0).getReadLatency(), new Double(DEFAULT_VALUE));
    assertEquals(disks.get(0).getFlushLatency(), new Double(DEFAULT_VALUE));
}
#end_block

#method_before
@Test
public void testWhenVDSMNotSendingFields() {
    Map<String, Object> diskData = new HashMap<>();
    diskData.put(VdsProperties.vm_disk_read_rate, DEFAULT_VALUE);
    diskData.put(VdsProperties.ImageId, IMAGE_ID.toString());
    diskData.put(VdsProperties.vm_disk_write_rate, DEFAULT_VALUE);
    // Set the default values to the fields.
    diskData.put(VdsProperties.vm_disk_flush_latency, DEFAULT_VALUE);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = VdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertNull(disks.get(0).getWriteLatency());
    assertNull(disks.get(0).getReadLatency());
    assertEquals(disks.get(0).getFlushLatency(), new Double(DEFAULT_VALUE));
}
#method_after
@Test
public void testWhenVDSMNotSendingFields() {
    Map<String, Object> diskData = new HashMap<>();
    diskData.put(VdsProperties.vm_disk_read_rate, DEFAULT_VALUE);
    diskData.put(VdsProperties.ImageId, IMAGE_ID.toString());
    diskData.put(VdsProperties.vm_disk_write_rate, DEFAULT_VALUE);
    // Set the default values to the fields.
    diskData.put(VdsProperties.vm_disk_flush_latency, DEFAULT_VALUE);
    Map<String, Object> xml = setMockForTesting(diskData);
    List<DiskImageDynamic> disks = vdsBrokerObjectsBuilder.buildVmDiskStatistics(xml);
    assertNull(disks.get(0).getWriteLatency());
    assertNull(disks.get(0).getReadLatency());
    assertEquals(disks.get(0).getFlushLatency(), new Double(DEFAULT_VALUE));
}
#end_block

#method_before
@Test
public void testNoDiskStats() {
    VDS vds = getVds();
    VdsBrokerObjectsBuilder.updateLocalDisksUsage(vds, new HashMap<>());
    assertNull(vds.getLocalDisksUsage());
}
#method_after
@Test
public void testNoDiskStats() {
    VDS vds = getVds();
    vdsBrokerObjectsBuilder.updateLocalDisksUsage(vds, new HashMap<>());
    assertNull(vds.getLocalDisksUsage());
}
#end_block

#method_before
private void validateVmNetworkInterfaceId(String nicId, Map<String, Object> vmStruct) {
    List<VmNetworkInterface> vmNetworkInterfaceList = VdsBrokerObjectsBuilder.buildVmNetworkInterfacesFromDevices(vmStruct);
    assertNotNull(vmNetworkInterfaceList);
    assertEquals(1, vmNetworkInterfaceList.size());
    VmNetworkInterface vmNetworkInterface = vmNetworkInterfaceList.get(0);
    assertEquals(Guid.createGuidFromString(nicId), vmNetworkInterface.getId());
}
#method_after
private void validateVmNetworkInterfaceId(String nicId, Map<String, Object> vmStruct) {
    List<VmNetworkInterface> vmNetworkInterfaceList = vdsBrokerObjectsBuilder.buildVmNetworkInterfacesFromDevices(vmStruct);
    assertNotNull(vmNetworkInterfaceList);
    assertEquals(1, vmNetworkInterfaceList.size());
    VmNetworkInterface vmNetworkInterface = vmNetworkInterfaceList.get(0);
    assertEquals(Guid.createGuidFromString(nicId), vmNetworkInterface.getId());
}
#end_block

#method_before
private static void validateDisksUsagesList(VmStatistics vmStatistics, Object[] disksUsages, Map<String, Object> xml) {
    VdsBrokerObjectsBuilder.updateVMStatisticsData(vmStatistics, xml);
    assertEquals(Arrays.asList(disksUsages), new JsonObjectDeserializer().deserializeUnformattedJson(vmStatistics.getDisksUsage(), ArrayList.class));
}
#method_after
private void validateDisksUsagesList(VmStatistics vmStatistics, Object[] disksUsages, Map<String, Object> xml) {
    vdsBrokerObjectsBuilder.updateVMStatisticsData(vmStatistics, xml);
    assertEquals(Arrays.asList(disksUsages), new JsonObjectDeserializer().deserializeUnformattedJson(vmStatistics.getDisksUsage(), ArrayList.class));
}
#end_block

#method_before
private static void validateDisksStatsList(VDS vds, Map<String, Object> xml, boolean assertNullValues) {
    VdsBrokerObjectsBuilder.updateLocalDisksUsage(vds, xml);
    assertNotNull(vds.getLocalDisksUsage());
    for (Long usage : vds.getLocalDisksUsage().values()) {
        if (assertNullValues) {
            assertNull(usage);
        } else {
            assertEquals(SIZE_FOR_DISK_STATS, usage.longValue());
        }
    }
}
#method_after
private void validateDisksStatsList(VDS vds, Map<String, Object> xml, boolean assertNullValues) {
    vdsBrokerObjectsBuilder.updateLocalDisksUsage(vds, xml);
    assertNotNull(vds.getLocalDisksUsage());
    for (Long usage : vds.getLocalDisksUsage().values()) {
        if (assertNullValues) {
            assertNull(usage);
        } else {
            assertEquals(SIZE_FOR_DISK_STATS, usage.longValue());
        }
    }
}
#end_block

#method_before
private LeaseStatus getLeaseStatus(Object[] owners) {
    return VdsBrokerObjectsBuilder.buildLeaseStatus(Collections.singletonMap("owners", owners));
}
#method_after
private LeaseStatus getLeaseStatus(Object[] owners) {
    return vdsBrokerObjectsBuilder.buildLeaseStatus(Collections.singletonMap("owners", owners));
}
#end_block

#method_before
@Test
public void testExtractIpv6Prefix() {
    assertThat(VdsBrokerObjectsBuilder.extractIpv6Prefix("::/128"), is(128));
}
#method_after
@Test
public void testExtractIpv6Prefix() {
    assertThat(vdsBrokerObjectsBuilder.extractIpv6Prefix("::/128"), is(128));
}
#end_block

#method_before
@Test
public void testExtractIpv6PrefixNull() {
    assertThat(VdsBrokerObjectsBuilder.extractIpv6Prefix(null), nullValue());
}
#method_after
@Test
public void testExtractIpv6PrefixNull() {
    assertThat(vdsBrokerObjectsBuilder.extractIpv6Prefix(null), nullValue());
}
#end_block

#method_before
@Test
public void testExtractIpv6PrefixNoPrefix() {
    assertThat(VdsBrokerObjectsBuilder.extractIpv6Prefix("::"), nullValue());
}
#method_after
@Test
public void testExtractIpv6PrefixNoPrefix() {
    assertThat(vdsBrokerObjectsBuilder.extractIpv6Prefix("::"), nullValue());
}
#end_block

#method_before
@Test
public void testExtractIpv6PrefixInvalidPrefix() {
    assertThat(VdsBrokerObjectsBuilder.extractIpv6Prefix("::/zzz"), nullValue());
}
#method_after
@Test
public void testExtractIpv6PrefixInvalidPrefix() {
    assertThat(vdsBrokerObjectsBuilder.extractIpv6Prefix("::/zzz"), nullValue());
}
#end_block

#method_before
@Test
public void testExtractProperIpv6AddressWithPrefix() {
    assertThat(VdsBrokerObjectsBuilder.extractIpv6Address("::/123"), is("::"));
}
#method_after
@Test
public void testExtractProperIpv6AddressWithPrefix() {
    assertThat(vdsBrokerObjectsBuilder.extractIpv6Address("::/123"), is("::"));
}
#end_block

#method_before
@Test
public void testExtractProperIpv6AddressWithTooLongPrefix() {
    assertThat(VdsBrokerObjectsBuilder.extractIpv6Address("::/1234"), is("::/1234"));
}
#method_after
@Test
public void testExtractProperIpv6AddressWithTooLongPrefix() {
    assertThat(vdsBrokerObjectsBuilder.extractIpv6Address("::/1234"), is("::/1234"));
}
#end_block

#method_before
@Test
public void testExtractProperIpv6AddressWithInvalidPrefix() {
    assertThat(VdsBrokerObjectsBuilder.extractIpv6Address("::/a"), is("::/a"));
}
#method_after
@Test
public void testExtractProperIpv6AddressWithInvalidPrefix() {
    assertThat(vdsBrokerObjectsBuilder.extractIpv6Address("::/a"), is("::/a"));
}
#end_block

#method_before
@Test
public void testExtractProperIpv6AddressWithNoPrefix() {
    assertThat(VdsBrokerObjectsBuilder.extractIpv6Address("::/"), is("::/"));
}
#method_after
@Test
public void testExtractProperIpv6AddressWithNoPrefix() {
    assertThat(vdsBrokerObjectsBuilder.extractIpv6Address("::/"), is("::/"));
}
#end_block

#method_before
@Test
public void testExtractProperIpv6AddressWithoutSlash() {
    assertThat(VdsBrokerObjectsBuilder.extractIpv6Address("::"), is("::"));
}
#method_after
@Test
public void testExtractProperIpv6AddressWithoutSlash() {
    assertThat(vdsBrokerObjectsBuilder.extractIpv6Address("::"), is("::"));
}
#end_block

#method_before
@Test
public void testExtractProperIpv6AddressMultipleSlashes() {
    assertThat(VdsBrokerObjectsBuilder.extractIpv6Address(":/:/123"), is(":/:/123"));
}
#method_after
@Test
public void testExtractProperIpv6AddressMultipleSlashes() {
    assertThat(vdsBrokerObjectsBuilder.extractIpv6Address(":/:/123"), is(":/:/123"));
}
#end_block

#method_before
@Test
public void testExtractIpv6AddressEmptyString() {
    assertThat(VdsBrokerObjectsBuilder.extractIpv6Address(""), nullValue());
}
#method_after
@Test
public void testExtractIpv6AddressEmptyString() {
    assertThat(vdsBrokerObjectsBuilder.extractIpv6Address(""), nullValue());
}
#end_block

#method_before
@Test
public void testExtractIpv4AddressEmptyString() {
    assertThat(VdsBrokerObjectsBuilder.extractAddress(ImmutableMap.of(ADDR, "")), nullValue());
}
#method_after
@Test
public void testExtractIpv4AddressEmptyString() {
    assertThat(vdsBrokerObjectsBuilder.extractAddress(ImmutableMap.of(VdsProperties.ADDR, "")), nullValue());
}
#end_block

#method_before
@Test
public void testExtractIpv4SubnetEmptyString() {
    assertThat(VdsBrokerObjectsBuilder.extractSubnet(ImmutableMap.of(NETMASK, "")), nullValue());
}
#method_after
@Test
public void testExtractIpv4SubnetEmptyString() {
    assertThat(vdsBrokerObjectsBuilder.extractSubnet(ImmutableMap.of(VdsProperties.NETMASK, "")), nullValue());
}
#end_block

#method_before
@Test
public void testExtractIpv4GatewayEmptyString() {
    assertThat(VdsBrokerObjectsBuilder.extractGateway(ImmutableMap.of(VdsProperties.GLOBAL_GATEWAY, "")), nullValue());
}
#method_after
@Test
public void testExtractIpv4GatewayEmptyString() {
    assertThat(vdsBrokerObjectsBuilder.extractGateway(ImmutableMap.of(VdsProperties.GLOBAL_GATEWAY, "")), nullValue());
}
#end_block

#method_before
private void logFailedStorageConnections(Map<String, String> returnValue) {
    StringBuilder failedDomainNames = new StringBuilder();
    String namesSeparator = ",";
    for (Entry<String, String> result : returnValue.entrySet()) {
        if (!"0".equals(result.getValue())) {
            List<StorageDomain> domains = DbFacade.getInstance().getStorageDomainDao().getAllByConnectionId(new Guid(result.getKey()));
            if (!domains.isEmpty()) {
                for (StorageDomain domain : domains) {
                    if (failedDomainNames.length() > 0) {
                        failedDomainNames.append(namesSeparator);
                    }
                    failedDomainNames.append(domain.getStorageName());
                }
            }
        }
    }
    if (failedDomainNames.length() > 0) {
        AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(getParameters().getVdsId()));
        logable.addCustomValue("failedStorageDomains", failedDomainNames.toString());
        auditLogDirector.log(logable, AuditLogType.VDS_STORAGES_CONNECTION_FAILED);
    }
}
#method_after
private void logFailedStorageConnections(Map<String, String> returnValue) {
    StringBuilder failedDomainNames = new StringBuilder();
    String namesSeparator = ",";
    for (Entry<String, String> result : returnValue.entrySet()) {
        if (!"0".equals(result.getValue())) {
            List<StorageDomain> domains = storageDomainDao.getAllByConnectionId(new Guid(result.getKey()));
            if (!domains.isEmpty()) {
                for (StorageDomain domain : domains) {
                    if (failedDomainNames.length() > 0) {
                        failedDomainNames.append(namesSeparator);
                    }
                    failedDomainNames.append(domain.getStorageName());
                }
            }
        }
    }
    if (failedDomainNames.length() > 0) {
        AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(getParameters().getVdsId()));
        logable.addCustomValue("failedStorageDomains", failedDomainNames.toString());
        auditLogDirector.log(logable, AuditLogType.VDS_STORAGES_CONNECTION_FAILED);
    }
}
#end_block

#method_before
protected void executeVdsCommandWithNetworkEvent(boolean sendNetworkEvent) {
    try {
        executeVdsBrokerCommand();
    } catch (VDSNetworkException ex) {
        printReturnValue();
        updateNetworkException(ex, ex.getMessage());
        if (sendNetworkEvent) {
            networkError.fire(ex);
        }
        throw ex;
    } catch (VDSExceptionBase ex) {
        printReturnValue();
        throw ex;
    } catch (TransportRunTimeException ex) {
        VDSNetworkException networkException = createNetworkException(ex);
        printReturnValue();
        if (sendNetworkEvent) {
            networkError.fire(networkException);
        }
        throw networkException;
    }// TODO: look for invalid certificates error handling
     catch (RuntimeException e) {
        printReturnValue();
        if (getAndSetVdsStatic() == null) {
            log.error("Failed in '{}' method, for vds id: '{}': {}", getCommandName(), getParameters().getVdsId(), e.getMessage());
        } else {
            log.error("Failed in '{}' method, for vds: '{}'; host: '{}': {}", getCommandName(), getAndSetVdsStatic().getName(), getAndSetVdsStatic().getHostName(), e.getMessage());
        }
        throw e;
    }
}
#method_after
protected void executeVdsCommandWithNetworkEvent(boolean sendNetworkErrorEvent) {
    try {
        executeVdsBrokerCommand();
    } catch (VDSNetworkException ex) {
        printReturnValue();
        updateNetworkException(ex, ex.getMessage());
        if (sendNetworkErrorEvent) {
            networkError.fire(ex);
        }
        throw ex;
    } catch (VDSExceptionBase ex) {
        printReturnValue();
        throw ex;
    } catch (TransportRunTimeException ex) {
        VDSNetworkException networkException = createNetworkException(ex);
        printReturnValue();
        if (sendNetworkErrorEvent) {
            networkError.fire(networkException);
        }
        throw networkException;
    }// TODO: look for invalid certificates error handling
     catch (RuntimeException e) {
        printReturnValue();
        if (getAndSetVdsStatic() == null) {
            log.error("Failed in '{}' method, for vds id: '{}': {}", getCommandName(), getParameters().getVdsId(), e.getMessage());
        } else {
            log.error("Failed in '{}' method, for vds: '{}'; host: '{}': {}", getCommandName(), getAndSetVdsStatic().getName(), getAndSetVdsStatic().getHostName(), e.getMessage());
        }
        throw e;
    }
}
#end_block

#method_before
private boolean connectFileStorageServers(StorageType storageType, List<StorageServerConnections> connections) {
    Map<StorageDomainType, List<StorageServerConnections>> connByType = connections.stream().collect(Collectors.groupingBy(c -> storageDomainDao.getAllByConnectionId(Guid.createGuidFromString(c.getId())).get(0).getStorageDomainType()));
    boolean connectSucceeded = connectStorageServer(storageType, connByType.get(StorageDomainType.Data), true);
    try {
        connectStorageServer(storageType, connByType.get(StorageDomainType.ISO), false);
        connectStorageServer(storageType, connByType.get(StorageDomainType.ImportExport), false);
    } catch (EngineException e) {
        log.info("Ignoring failed connection to domain of type ISO/Import-Export.'");
    }
    return connectSucceeded;
}
#method_after
private boolean connectFileStorageServers(StorageType storageType, List<StorageServerConnections> connections) {
    Map<StorageDomainType, List<StorageServerConnections>> connByType = connections.stream().collect(Collectors.groupingBy(c -> storageDomainDao.getAllByConnectionId(Guid.createGuidFromString(c.getId())).get(0).getStorageDomainType()));
    boolean connectSucceeded = connectStorageServer(storageType, connByType.get(StorageDomainType.Master), true);
    connectSucceeded &= connectStorageServer(storageType, connByType.get(StorageDomainType.Data), true);
    connectStorageServerIgnoreFailure(storageType, connByType.get(StorageDomainType.ISO), StorageDomainType.ISO);
    connectStorageServerIgnoreFailure(storageType, connByType.get(StorageDomainType.ImportExport), StorageDomainType.ImportExport);
    return connectSucceeded;
}
#end_block

#method_before
private boolean connectStorageServer(StorageType storageType, List<StorageServerConnections> connections, boolean sendNetworkEventOnFailure) {
    if (connections == null) {
        return true;
    }
    StorageServerConnectionManagementVDSParameters parameters = new StorageServerConnectionManagementVDSParameters(getVds().getId(), getStoragePool().getId(), storageType, connections);
    parameters.setSendNetworkEventOnFailure(sendNetworkEventOnFailure);
    Map<String, String> retValues = (Map<String, String>) runVdsCommand(VDSCommandType.ConnectStorageServer, parameters).getReturnValue();
    return storageHelperDirector.getItem(storageType).isConnectSucceeded(retValues, connections);
}
#method_after
private boolean connectStorageServer(StorageType storageType, List<StorageServerConnections> connections, boolean sendNetworkEventOnFailure) {
    if (connections == null || connections.isEmpty()) {
        return true;
    }
    StorageServerConnectionManagementVDSParameters parameters = new StorageServerConnectionManagementVDSParameters(getVds().getId(), getStoragePool().getId(), storageType, connections);
    parameters.setSendNetworkEventOnFailure(sendNetworkEventOnFailure);
    Map<String, String> retValues = (Map<String, String>) runVdsCommand(VDSCommandType.ConnectStorageServer, parameters).getReturnValue();
    return storageHelperDirector.getItem(storageType).isConnectSucceeded(retValues, connections);
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    boolean spaprVscsiControllerExists = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                    case "scsi":
                        Map<String, String> addressMap = StringMapUtils.string2Map(device.getAddress());
                        if (vm.getClusterArch().getFamily() == ArchitectureType.ppc && !addressMap.isEmpty() && addressMap.get("type").equals(VdsProperties.spapr_vio)) {
                            spaprVscsiControllerExists = true;
                        }
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (vm.getClusterArch().getFamily() == ArchitectureType.ppc && !spaprVscsiControllerExists) {
        writeSpaprVscsiController();
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writeLeases();
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllersForDomainXml(devices));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writeLeases();
    writer.writeEndElement();
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> score(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    long lowMemoryLimit = parameters.containsKey(PolicyUnitParameter.LOW_MEMORY_LIMIT_FOR_OVER_UTILIZED.getDbName()) ? Long.parseLong(parameters.get(PolicyUnitParameter.LOW_MEMORY_LIMIT_FOR_OVER_UTILIZED.getDbName())) : 0L;
    long highMemoryLimit = parameters.containsKey(PolicyUnitParameter.HIGH_MEMORY_LIMIT_FOR_UNDER_UTILIZED.getDbName()) ? Long.parseLong(parameters.get(PolicyUnitParameter.HIGH_MEMORY_LIMIT_FOR_UNDER_UTILIZED.getDbName())) : Long.MAX_VALUE;
    // The max memory is set higher than the maximum of free memory of all hosts.
    // So overutilized hosts have worse score than the host with maximum free memory
    float maxMemory = getMaxMemoryOfVdsInCluster(hosts) * 1.1f;
    List<Pair<Guid, Integer>> scores = new ArrayList<>();
    for (VDS vds : hosts) {
        scores.add(new Pair<>(vds.getId(), calcHostScore(vds.getMaxSchedulingMemory(), maxMemory, lowMemoryLimit, highMemoryLimit)));
    }
    return scores;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    long lowMemoryLimit = parameters.containsKey(PolicyUnitParameter.LOW_MEMORY_LIMIT_FOR_OVER_UTILIZED.getDbName()) ? Long.parseLong(parameters.get(PolicyUnitParameter.LOW_MEMORY_LIMIT_FOR_OVER_UTILIZED.getDbName())) : 0L;
    long highMemoryLimit = parameters.containsKey(PolicyUnitParameter.HIGH_MEMORY_LIMIT_FOR_UNDER_UTILIZED.getDbName()) ? Long.parseLong(parameters.get(PolicyUnitParameter.HIGH_MEMORY_LIMIT_FOR_UNDER_UTILIZED.getDbName())) : Long.MAX_VALUE;
    /* The 'maxMemory' is set higher than the maximum of scheduling memory of all hosts.
           So overutilized hosts have worse score than the host with maximum free memory

           This is to handle for example the following case:
             - LOW_MEMORY_LIMIT_FOR_OVER_UTILIZED = 1 GB
             - HIGH_MEMORY_LIMIT_FOR_UNDER_UTILIZED = 4 GB
             - 3 hosts:
                A - MaxSchedulingMemory = 512 MB
                B - MaxSchedulingMemory = 2 GB
                C - MaxSchedulingMemory = 2 GB

             The scores are:
               A -> Is overutilized, so its score is computed as if: A.MaxSchedulingMemory == maxMemory
                    Score = MaxSchedulerWeight

               B -> Score = (1 / 1.1) * (MaxSchedulerWeight - 1) + 1
               C -> Score = (1 / 1.1) * (MaxSchedulerWeight - 1) + 1

           In case the 'maxMemory' was not higher than the maximum of scheduling memory of all hosts,
           the scores of hosts A, B, C would be identical. Which is not what we want.
           Host A has to be worse candidate than B or C.
        */
    float maxMemory = getMaxMemoryOfVdsInCluster(hosts) * 1.1f;
    List<Pair<Guid, Integer>> scores = new ArrayList<>();
    for (VDS vds : hosts) {
        scores.add(new Pair<>(vds.getId(), calcHostScore(vds.getMaxSchedulingMemory(), maxMemory, lowMemoryLimit, highMemoryLimit)));
    }
    return scores;
}
#end_block

#method_before
private boolean isConsoleCommandsExecutionAllowed() {
    if (getSelectedItem() == null) {
        return false;
    }
    // return true, if at least one console is available
    return getSelectedItems().stream().map(consolesFactory::getVmConsolesForVm).anyMatch(VmConsoles::canConnectToConsole);
}
#method_after
private boolean isConsoleCommandsExecutionAllowed() {
    if (getSelectedItems() == null) {
        return false;
    }
    // return true, if at least one console is available
    return getSelectedItems().stream().map(consolesFactory::getVmConsolesForVm).anyMatch(VmConsoles::canConnectToConsole);
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    mandatory(template().name());
    or(mandatory(template().vm().id()), mandatory(template().vm().name()));
    optional(template().bios().bootMenu().enabled());
    optional(template().cluster().id());
    optional(template().cluster().name());
    optional(template().comment());
    optional(template().console().enabled());
    optional(template().cpu().architecture());
    optional(template().cpu().topology().cores());
    optional(template().cpu().topology().sockets());
    optional(template().cpu().topology().threads());
    optional(template().cpuProfile().id());
    optional(template().cpuShares());
    optional(template().customCpuModel());
    optional(template().customEmulatedMachine());
    optional(template().deleteProtected());
    optional(template().description());
    optional(template().display().allowOverride());
    optional(template().display().copyPasteEnabled());
    optional(template().display().disconnectAction());
    optional(template().display().fileTransferEnabled());
    optional(template().display().keyboardLayout());
    optional(template().display().monitors());
    optional(template().display().smartcardEnabled());
    optional(template().display().type());
    optional(template().domain().name());
    optional(template().highAvailability().enabled());
    optional(template().highAvailability().priority());
    optional(template().initialization().configuration().data());
    optional(template().initialization().configuration().type());
    optional(template().io().threads());
    optional(template().largeIcon().data());
    optional(template().largeIcon().id());
    optional(template().largeIcon().mediaType());
    optional(template().memory());
    optional(template().memoryPolicy().ballooning());
    optional(template().memoryPolicy().guaranteed());
    optional(template().migration().autoConverge());
    optional(template().migration().compressed());
    optional(template().migrationDowntime());
    optional(template().origin());
    optional(template().os().cmdline());
    optional(template().os().initrd());
    optional(template().os().kernel());
    optional(template().os().type());
    // TODO: check
    optional(template().vm().placementPolicy().affinity());
    optional(template().serialNumber().policy());
    optional(template().serialNumber().value());
    optional(template().smallIcon().id());
    optional(template().soundcardEnabled());
    optional(template().startPaused());
    optional(template().stateless());
    optional(template().storageDomain().id());
    optional(template().timeZone().name());
    optional(template().tunnelMigration());
    optional(template().type());
    optional(template().usb().enabled());
    optional(template().usb().type());
    optional(template().version().baseTemplate().id());
    optional(template().version().versionName());
    optional(template().virtioScsi().enabled());
    optional(template().display().singleQxlPci());
    optional(template().rngDevice().rate().bytes());
    optional(template().rngDevice().rate().period());
    optional(template().rngDevice().source());
    optional(template().vm().diskAttachments()[COLLECTION].name());
    optional(template().vm().diskAttachments()[COLLECTION].description());
    optional(template().vm().diskAttachments()[COLLECTION].id());
    // optional(template().vm().diskAttachments()[COLLECTION].storageDomain--collection()); //TODO: check
    optional(template().customProperties()[COLLECTION].name());
    optional(template().customProperties()[COLLECTION].value());
    optional(template().os().boot().devices()[COLLECTION]);
    optional(template().cpu().cpuTune().vcpuPins()[COLLECTION].cpuSet());
    optional(template().cpu().cpuTune().vcpuPins()[COLLECTION].vcpu());
    optional(template().sso().methods()[COLLECTION].id());
    optional(template().storageErrorResumeBehaviour());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(template().name());
    or(mandatory(template().vm().id()), mandatory(template().vm().name()));
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    mandatory(template().initialization().configuration().data());
    mandatory(template().initialization().configuration().type());
    or(mandatory(template().cluster().id()), mandatory(template().cluster().name()));
    optional(template().initialization().regenerateIds());
    optional(template().name());
// optional(template().os().boot().devices()[COLLECTION]); // TODO: check
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(template().initialization().configuration().data());
    mandatory(template().initialization().configuration().type());
    or(mandatory(template().cluster().id()), mandatory(template().cluster().name()));
    optional(template().initialization().regenerateIds());
    optional(template().name());
}
#end_block

#method_before
protected void runningFailed() {
    try {
        decreasePendingVm();
        getVdsBroker().removeAsyncRunningCommand(getVmId());
        setCommandShouldBeLogged(false);
        _isRerun = false;
        setSucceeded(false);
        log();
        processVmOnDown();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        executionHandler.endJob(getExecutionContext(), false);
    } finally {
        freeLock();
    }
}
#method_after
protected void runningFailed() {
    try {
        decreasePendingVm();
        vdsBroker.removeAsyncRunningCommand(getVmId());
        setCommandShouldBeLogged(false);
        _isRerun = false;
        setSucceeded(false);
        log();
        processVmOnDown();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        executionHandler.endJob(getExecutionContext(), false);
    } finally {
        freeLock();
    }
}
#end_block

#method_before
protected void initParametersForExternalNetworks(VDS vds, boolean isMigration) {
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        VnicProfile vnicProfile = vnicProfileDao.get(iface.getVnicProfileId());
        Network network = networkHelper.getNetworkByVnicProfile(vnicProfile);
        if (network != null && network.isExternal() && iface.isPlugged()) {
            Provider<?> provider = providerDao.get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = providerProxyFactory.create(provider);
            String pluginType = StringUtils.defaultString(((OpenstackNetworkProviderProperties) provider.getAdditionalProperties()).getPluginType());
            String hostBindingId = StringUtils.defaultString(hostProviderBindingDao.get(vds.getId(), pluginType));
            Map<String, String> deviceProperties = providerProxy.allocate(network, vnicProfile, iface, vds, isMigration, hostBindingId);
            getVm().getRuntimeDeviceCustomProperties().put(new VmDeviceId(iface.getId(), getVmId()), deviceProperties);
        }
    }
}
#method_after
protected void initParametersForExternalNetworks(VDS vds, boolean isMigration) {
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        VnicProfile vnicProfile = vnicProfileDao.get(iface.getVnicProfileId());
        Network network = networkHelper.getNetworkByVnicProfile(vnicProfile);
        if (network != null && network.isExternal() && iface.isPlugged()) {
            Provider<?> provider = providerDao.get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = providerProxyFactory.create(provider);
            String pluginType = ((OpenstackNetworkProviderProperties) provider.getAdditionalProperties()).getPluginType();
            String hostBindingId = hostProviderBindingDao.get(vds.getId(), pluginType);
            Map<String, String> deviceProperties = providerProxy.allocate(network, vnicProfile, iface, vds, isMigration, hostBindingId);
            getVm().getRuntimeDeviceCustomProperties().put(new VmDeviceId(iface.getId(), getVmId()), deviceProperties);
        }
    }
}
#end_block

#method_before
@Override
public String add(Network network) {
    com.woorea.openstack.quantum.model.Network networkForCreate = createNewNetworkEntity(network);
    try {
        com.woorea.openstack.quantum.model.Network createdNetwork = getClient().networks().create(networkForCreate).execute();
        return createdNetwork.getId();
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public String add(Network network) {
    com.woorea.openstack.quantum.model.Network networkForCreate = createNewNetworkEntity(network);
    com.woorea.openstack.quantum.model.Network createdNetwork = execute(getClient().networks().create(networkForCreate));
    return createdNetwork.getId();
}
#end_block

#method_before
@Override
public void remove(String id) {
    try {
        getClient().networks().delete(id).execute();
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public void remove(String id) {
    execute(getClient().networks().delete(id));
}
#end_block

#method_before
@Override
public List<Network> getAll() {
    try {
        Networks networks = getClient().networks().list().execute();
        return map(networks.getList());
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public List<Network> getAll() {
    Networks networks = execute(getClient().networks().list());
    return map(networks.getList());
}
#end_block

#method_before
@Override
public List<ExternalSubnet> getAllSubnets(ProviderNetwork network) {
    List<ExternalSubnet> result = new ArrayList<>();
    Subnets subnets = getClient().subnets().list().execute();
    for (Subnet subnet : subnets.getList()) {
        if (network.getExternalId().equals(subnet.getNetworkId())) {
            result.add(map(subnet, network));
        }
    }
    return result;
}
#method_after
@Override
public List<ExternalSubnet> getAllSubnets(ProviderNetwork network) {
    List<ExternalSubnet> result = new ArrayList<>();
    Subnets subnets = execute(getClient().subnets().list());
    for (Subnet subnet : subnets.getList()) {
        if (network.getExternalId().equals(subnet.getNetworkId())) {
            result.add(map(subnet, network));
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void addSubnet(ExternalSubnet subnet) {
    com.woorea.openstack.quantum.model.Network externalNetwork = getExternalNetwork(subnet.getExternalNetwork());
    Subnet subnetForCreate = createNewSubnetEntity(subnet, externalNetwork);
    try {
        getClient().subnets().create(subnetForCreate).execute();
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public void addSubnet(ExternalSubnet subnet) {
    com.woorea.openstack.quantum.model.Network externalNetwork = getExternalNetwork(subnet.getExternalNetwork());
    Subnet subnetForCreate = createNewSubnetEntity(subnet, externalNetwork);
    execute(getClient().subnets().create(subnetForCreate));
}
#end_block

#method_before
@Override
public void removeSubnet(String id) {
    try {
        getClient().subnets().delete(id).execute();
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public void removeSubnet(String id) {
    execute(getClient().subnets().delete(id));
}
#end_block

#method_before
@Override
public void testConnection() {
    try {
        getClient().execute(new OpenStackRequest<>(getClient(), HttpMethod.GET, "", null, ApiRootResponse.class));
    } catch (OpenStackResponseException e) {
        log.error("{} (OpenStack response error code: {})", e.getMessage(), e.getStatus());
        log.debug("Exception", e);
        throw new EngineException(EngineError.PROVIDER_FAILURE, e);
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public void testConnection() {
    execute(new OpenStackRequest<>(getClient(), HttpMethod.GET, "", null, ApiRootResponse.class));
}
#end_block

#method_before
@Override
public Map<String, String> allocate(Network network, VnicProfile vnicProfile, VmNic nic, VDS host, boolean ignoreSecurityGroupsOnUpdate, String hostBindingId) {
    try {
        Port port = locatePort(nic);
        List<String> securityGroups = getSecurityGroups(vnicProfile);
        String hostId = getHostId(host);
        if (port == null) {
            com.woorea.openstack.quantum.model.Network externalNetwork = getExternalNetwork(network.getProvidedBy());
            Port portForCreate = createNewPortForAllocate(nic, securityGroups, hostBindingId, externalNetwork);
            port = getClient().ports().create(portForCreate).execute();
        } else {
            boolean securityGroupsChanged = !ignoreSecurityGroupsOnUpdate && securityGroupsChanged(port.getSecurityGroups(), securityGroups);
            boolean hostChanged = hostChanged(port, hostId);
            updatePort(port, securityGroupsChanged, hostChanged, securityGroups, hostBindingId, nic);
        }
        Map<String, String> runtimeProperties = createPortAllocationRuntimeProperties(port);
        return runtimeProperties;
    } catch (RuntimeException e) {
        log.error("!!!!!!!!!!!!!!!!!!!!!!!!!!! ERROR:  ", e);
        throw new EngineException(EngineError.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public Map<String, String> allocate(Network network, VnicProfile vnicProfile, VmNic nic, VDS host, boolean ignoreSecurityGroupsOnUpdate, String hostBindingId) {
    if (hostBindingId == null) {
        hostBindingId = getHostId(host);
        log.warn("Host binding id for external network {} on host {} is null, using host id {} to allocate vNIC " + " {} instead. Please provide an after_get_caps hook for the plugin type {} on host {}", network.getName(), host.getName(), hostBindingId, nic.getName(), getProvider().getAdditionalProperties().getPluginType(), host.getName());
    }
    Port port = locatePort(nic);
    List<String> securityGroups = getSecurityGroups(vnicProfile);
    if (port == null) {
        com.woorea.openstack.quantum.model.Network externalNetwork = getExternalNetwork(network.getProvidedBy());
        Port portForCreate = createNewPortForAllocate(nic, securityGroups, hostBindingId, externalNetwork);
        port = execute(getClient().ports().create(portForCreate));
    } else {
        boolean securityGroupsChanged = !ignoreSecurityGroupsOnUpdate && securityGroupsChanged(port.getSecurityGroups(), securityGroups);
        updatePort(port, securityGroupsChanged, securityGroups, hostBindingId, nic);
    }
    Map<String, String> runtimeProperties = createPortAllocationRuntimeProperties(port);
    return runtimeProperties;
}
#end_block

#method_before
private Port updatePort(Port port, boolean securityGroupsChanged, boolean hostChanged, List<String> securityGroups, String portBinding, VmNic nic) {
    if (securityGroupsChanged || hostChanged) {
        List<String> modifiedSecurityGroups = securityGroupsChanged ? securityGroups : port.getSecurityGroups();
        Port portForUpdate = modifyPortForAllocate(port, portBinding, hostChanged, securityGroupsChanged, modifiedSecurityGroups, nic.getMacAddress());
        return getClient().ports().update(portForUpdate).execute();
    }
    return port;
}
#method_after
private Port updatePort(Port port, boolean securityGroupsChanged, List<String> securityGroups, String hostBindingId, VmNic nic) {
    boolean hostChanged = hostChanged(port, hostBindingId);
    if (securityGroupsChanged || hostChanged) {
        List<String> modifiedSecurityGroups = securityGroupsChanged ? securityGroups : port.getSecurityGroups();
        Port portForUpdate = modifyPortForAllocate(port, hostBindingId, hostChanged, securityGroupsChanged, modifiedSecurityGroups, nic.getMacAddress());
        return execute(getClient().ports().update(portForUpdate));
    }
    return port;
}
#end_block

#method_before
protected Port modifyPortForAllocate(Port port, String portBinding, boolean hostChanged, boolean securityGroupsChanged, List<String> modifiedSecurityGroups, String macAddress) {
    Port portForUpdate = securityGroupsChanged ? new PortForUpdate() : new Port();
    portForUpdate.setId(port.getId());
    if (securityGroupsChanged) {
        portForUpdate.setSecurityGroups(modifiedSecurityGroups);
    }
    if (hostChanged) {
        portForUpdate.setBinding(new Binding());
        portForUpdate.getBinding().setHostId(portBinding);
        portForUpdate.setMacAddress(macAddress);
    }
    return portForUpdate;
}
#method_after
protected Port modifyPortForAllocate(Port port, String hostBindingId, boolean hostChanged, boolean securityGroupsChanged, List<String> modifiedSecurityGroups, String macAddress) {
    Port portForUpdate = securityGroupsChanged ? new PortForUpdate() : new Port();
    portForUpdate.setId(port.getId());
    if (securityGroupsChanged) {
        portForUpdate.setSecurityGroups(modifiedSecurityGroups);
    }
    if (hostChanged) {
        portForUpdate.setBinding(new Binding());
        portForUpdate.getBinding().setHostId(hostBindingId);
        portForUpdate.setMacAddress(macAddress);
    }
    return portForUpdate;
}
#end_block

#method_before
protected Port createNewPortForAllocate(VmNic nic, List<String> securityGroups, String portBinding, com.woorea.openstack.quantum.model.Network externalNetwork) {
    Port portForCreate = new Port();
    portForCreate.setAdminStateUp(true);
    portForCreate.setName(nic.getName());
    portForCreate.setMacAddress(nic.getMacAddress());
    portForCreate.setNetworkId(externalNetwork.getId());
    portForCreate.setDeviceOwner(DEVICE_OWNER);
    portForCreate.setDeviceId(nic.getId().toString());
    portForCreate.setSecurityGroups(securityGroups);
    portForCreate.setBinding(new Binding());
    portForCreate.getBinding().setHostId(portBinding);
    portForCreate.setTenantId(externalNetwork.getTenantId());
    return portForCreate;
}
#method_after
protected Port createNewPortForAllocate(VmNic nic, List<String> securityGroups, String hostBindingId, com.woorea.openstack.quantum.model.Network externalNetwork) {
    Port portForCreate = new Port();
    portForCreate.setAdminStateUp(true);
    portForCreate.setName(nic.getName());
    portForCreate.setMacAddress(nic.getMacAddress());
    portForCreate.setNetworkId(externalNetwork.getId());
    portForCreate.setDeviceOwner(DEVICE_OWNER);
    portForCreate.setDeviceId(nic.getId().toString());
    portForCreate.setSecurityGroups(securityGroups);
    portForCreate.setBinding(new Binding());
    portForCreate.getBinding().setHostId(hostBindingId);
    portForCreate.setTenantId(externalNetwork.getTenantId());
    return portForCreate;
}
#end_block

#method_before
private com.woorea.openstack.quantum.model.Network getExternalNetwork(ProviderNetwork providerNetwork) {
    return getClient().networks().show(providerNetwork.getExternalId()).execute();
}
#method_after
private com.woorea.openstack.quantum.model.Network getExternalNetwork(ProviderNetwork providerNetwork) {
    return execute(getClient().networks().show(providerNetwork.getExternalId()));
}
#end_block

#method_before
private boolean hostChanged(Port port, String hostId) {
    return port.getBinding() == null || !StringUtils.equals(port.getBinding().getHostId(), hostId);
}
#method_after
private boolean hostChanged(Port port, String hostId) {
    return port.getBinding() == null || hostId == null || !StringUtils.equals(port.getBinding().getHostId(), hostId);
}
#end_block

#method_before
@Override
public void deallocate(VmNic nic) {
    try {
        Port port = locatePort(nic);
        if (port != null) {
            getClient().ports().delete(port.getId()).execute();
        }
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public void deallocate(VmNic nic) {
    Port port = locatePort(nic);
    if (port != null) {
        execute(getClient().ports().delete(port.getId()));
    }
}
#end_block

#method_before
private Port locatePort(VmNic nic) {
    List<Port> ports = getClient().ports().list().execute().getList();
    for (Port port : ports) {
        if (DEVICE_OWNER.equals(port.getDeviceOwner()) && nic.getId().toString().equals(port.getDeviceId())) {
            return port;
        }
    }
    return null;
}
#method_after
private Port locatePort(VmNic nic) {
    List<Port> ports = execute(getClient().ports().list()).getList();
    for (Port port : ports) {
        if (DEVICE_OWNER.equals(port.getDeviceOwner()) && nic.getId().toString().equals(port.getDeviceId())) {
            return port;
        }
    }
    return null;
}
#end_block

#method_before
private void plugToExternalNetwork() {
    Provider<?> provider = providerDao.get(getNetwork().getProvidedBy().getProviderId());
    String pluginType = StringUtils.defaultString(((OpenstackNetworkProviderProperties) provider.getAdditionalProperties()).getPluginType());
    String hostBindingId = StringUtils.defaultString(hostProviderBindingDao.get(getVds().getId(), pluginType));
    Map<String, String> runtimeProperties = getProviderProxy().allocate(getNetwork(), vnicProfile, getParameters().getNic(), getVds(), false, hostBindingId);
    if (runtimeProperties != null) {
        getVm().getRuntimeDeviceCustomProperties().put(vmDevice.getId(), runtimeProperties);
    }
}
#method_after
private void plugToExternalNetwork() {
    Provider provider = getProvider();
    if (provider == null) {
        throw new RuntimeException("No provider for network");
    }
    String pluginType = ((OpenstackNetworkProviderProperties) provider.getAdditionalProperties()).getPluginType();
    String hostBindingId = hostProviderBindingDao.get(getVds().getId(), pluginType);
    Map<String, String> runtimeProperties = getProviderProxy().allocate(getNetwork(), vnicProfile, getParameters().getNic(), getVds(), false, hostBindingId);
    if (runtimeProperties != null) {
        getVm().getRuntimeDeviceCustomProperties().put(vmDevice.getId(), runtimeProperties);
    }
}
#end_block

#method_before
private NetworkProviderProxy getProviderProxy() {
    if (providerProxy == null) {
        Provider<?> provider = providerDao.get(getNetwork().getProvidedBy().getProviderId());
        providerProxy = providerProxyFactory.create(provider);
    }
    return providerProxy;
}
#method_after
private NetworkProviderProxy getProviderProxy() {
    if (providerProxy == null) {
        Provider<?> provider = getProvider();
        providerProxy = providerProxyFactory.create(provider);
    }
    return providerProxy;
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> score(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    Map<Guid, Integer> hostViolations = getHostViolationCount(false, hosts, vm, new PerHostMessages());
    Guid currentHostId = vm.getRunOnVds();
    int currentHostScore = hostViolations.getOrDefault(currentHostId, MaxSchedulerWeight);
    List<Pair<Guid, Integer>> retList = new ArrayList<>();
    for (VDS host : hosts) {
        int score = hostViolations.getOrDefault(host.getId(), DEFAULT_SCORE);
        // This is to avoid migration loops between two hosts with the same score.
        if (score >= currentHostScore && !host.getId().equals(currentHostId)) {
            score += 1;
        }
        retList.add(new Pair<>(host.getId(), Math.min(score, MaxSchedulerWeight)));
    }
    return retList;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    Map<Guid, Integer> hostViolations = getHostViolationCount(false, hosts, vm, new PerHostMessages());
    Guid currentHostId = vm.getRunOnVds();
    int currentHostScore = hostViolations.getOrDefault(currentHostId, MaxSchedulerWeight);
    List<Pair<Guid, Integer>> retList = new ArrayList<>();
    for (VDS host : hosts) {
        int score = hostViolations.getOrDefault(host.getId(), DEFAULT_SCORE);
        // the host where the VM is running is preferred.
        if (score >= currentHostScore && !host.getId().equals(currentHostId)) {
            score += 1;
        }
        retList.add(new Pair<>(host.getId(), Math.min(score, MaxSchedulerWeight)));
    }
    return retList;
}
#end_block

#method_before
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/devices/watchdog/models").put("value", WATCH_DOG_MODELS);
    preferences.node("/os/rhel7/devices/maxPciDevices").put("value", MAX_PCI_DEVICES);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.6", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    preferences.node("/os/rhel7/devices/display/protocols").put("value", "VNC/cirrus,SPICE/qxl");
    preferences.node("/os/rhel7/devices/balloon/enabled").put("value", "true");
    preferences.node("/os/rhel7/devices/audio/enabled").put("value", "true");
    preferences.node("/os/rhel7/devices/floppy/support").put("value", "true");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/devices/cdInterface").put("value", CD_INTERFACE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    preferences.node("/os/windows_7/id").put("value", "11");
    preferences.node("/os/windows_7/sysprepFileName").put("value", UNATTEND_XML);
    preferences.node("/os/windows_7/devices/hyperv/enabled").put("value", "true");
    preferences.node("/os/windows_8/cpu/unsupported").put("value", "conroe, opteron_g1");
    preferences.node("/os/windows_8/sysprepFileName").put("value", UNATTEND_XML);
    preferences.node("/os/windows_xp/id").put("value", "1");
    preferences.node("/os/windows_xp/sysprepFileName").put("value", SYSPREP_INF);
    preferences.node("/os/rhel7/devices/usb/controller").put("value", "nec-xhci,q35/qemu_xhci");
    preferences.node("/os/rhel6/id").put("value", "999");
    preferences.node("/os/rhel6/devices/usb/controller").put("value", "nec-xhci");
    preferences.node("/os/rhel6/devices/usb/controller").put("value.4.0", "none");
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#method_after
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/devices/watchdog/models").put("value", WATCH_DOG_MODELS);
    preferences.node("/os/rhel7/devices/maxPciDevices").put("value", MAX_PCI_DEVICES);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.6", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    preferences.node("/os/rhel7/devices/display/protocols").put("value", "VNC/cirrus,SPICE/qxl");
    preferences.node("/os/rhel7/devices/balloon/enabled").put("value", "true");
    preferences.node("/os/rhel7/devices/audio/enabled").put("value", "true");
    preferences.node("/os/rhel7/devices/floppy/support").put("value", "true");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/devices/cdInterface").put("value", CD_INTERFACE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    preferences.node("/os/windows_7/id").put("value", "11");
    preferences.node("/os/windows_7/sysprepFileName").put("value", UNATTEND_XML);
    preferences.node("/os/windows_7/devices/hyperv/enabled").put("value", "true");
    preferences.node("/os/windows_8/cpu/unsupported").put("value", "conroe, opteron_g1");
    preferences.node("/os/windows_8/sysprepFileName").put("value", UNATTEND_XML);
    preferences.node("/os/windows_xp/id").put("value", "1");
    preferences.node("/os/windows_xp/sysprepFileName").put("value", SYSPREP_INF);
    preferences.node("/os/rhel7/devices/usb/controller").put("value", "nec-xhci,q35/qemu-xhci");
    preferences.node("/os/rhel6/id").put("value", "999");
    preferences.node("/os/rhel6/devices/usb/controller").put("value", "nec-xhci");
    preferences.node("/os/rhel6/devices/usb/controller").put("value.4.0", "none");
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#end_block

#method_before
@Test
public void testGetSoundDevice() throws Exception {
    assertEquals(SOUND_DEVICE, OsRepositoryImpl.INSTANCE.getSoundDevice(777, null, ChipsetType.I440FX));
}
#method_after
@Test
public void testGetSoundDevice() throws Exception {
    assertEquals("ac97", OsRepositoryImpl.INSTANCE.getSoundDevice(777, null, ChipsetType.I440FX));
}
#end_block

#method_before
public VmDevice addSoundDevice(VmBase vmBase, Supplier<Cluster> clusterSupplier) {
    ChipsetType chipset = EmulatedMachineUtils.getEffectiveChipset(vmBase, clusterSupplier);
    if (vmBase instanceof VmTemplate) {
        return addSoundDevice(vmBase.getId(), vmBase.getOsId(), CompatibilityVersionUtils.getEffective((VmBase) null, clusterSupplier), chipset);
    }
    return addSoundDevice(vmBase.getId(), vmBase.getOsId(), clusterUtils.getCompatibilityVersion(vmBase), chipset);
}
#method_after
public VmDevice addSoundDevice(VmBase vmBase, Supplier<Cluster> clusterSupplier) {
    ChipsetType chipset = EmulatedMachineUtils.getEffectiveChipset(vmBase, clusterSupplier);
    Version compatibilityVersion = CompatibilityVersionUtils.getEffective(vmBase, clusterSupplier);
    return addSoundDevice(vmBase.getId(), vmBase.getOsId(), compatibilityVersion, chipset);
}
#end_block

#method_before
private void setDefaultNames8() {
    VDS host = context.host;
    List<StoragePool> dataCenters = context.dataCenterList;
    List<Cluster> clusters = context.clusterList;
    // $NON-NLS-1$
    setCommonName(host.getName().replace('.', '-') + "-Local");
    StoragePool candidate = null;
    // Check if current settings suitable for local setup (in case just SD creation failed - re-using the same
    // setup)
    boolean useCurrentSettings = false;
    if (host.getStoragePoolId() != null) {
        StoragePool tempCandidate = context.hostDataCenter;
        if (isLocalDataCenterEmpty(tempCandidate)) {
            candidate = tempCandidate;
            useCurrentSettings = true;
        } else {
            if (tempCandidate != null && tempCandidate.isLocal()) {
                setMessage(ConstantsManager.getInstance().getConstants().noteLocalStorageAlreadyConfiguredForThisHostMsg() + " " + host.getStoragePoolName() + " " + // $NON-NLS-1$ //$NON-NLS-2$
                ConstantsManager.getInstance().getConstants().withLocalStorageDomainMsg());
            }
        }
    }
    // Check if there is other DC suitable for re-use
    if (candidate == null) {
        for (StoragePool dataCenter : dataCenters) {
            // Need to check if the new DC is without host.
            if (isLocalDataCenterEmpty(dataCenter) && context.localStorageHostByDataCenterMap.get(dataCenter) == null) {
                candidate = dataCenter;
                break;
            }
        }
    }
    ArrayList<String> names;
    // In case we found a suitable candidate for re-use:
    if (candidate != null) {
        getDataCenter().setDataCenterId(candidate.getId());
        getDataCenter().getName().setEntity(candidate.getName());
        getDataCenter().getDescription().setEntity(candidate.getdescription());
        Version version = candidate.getCompatibilityVersion();
        getDataCenter().getVersion().setSelectedItem(version);
        getCluster().getVersion().setSelectedItem(version);
        setCandidateDataCenter(candidate);
        // If we use current settings there is no need to create cluster.
        if (useCurrentSettings) {
            getCluster().setClusterId(host.getClusterId());
            getCluster().getName().setEntity(host.getClusterName());
            Cluster cluster = context.hostCluster;
            if (cluster != null) {
                getCluster().getDescription().setEntity(cluster.getDescription());
                ServerCpu cpu = new ServerCpu();
                cpu.setCpuName(cluster.getCpuName());
                getCluster().getCPU().setSelectedItem(cpu);
            }
            setCandidateCluster(cluster);
        } else // Use different cluster
        {
            // Check the DC cluster list (for re-use)
            clusters = context.clusterListByDataCenterMap.get(candidate);
            // No clusters available - pick up new name.
            if (clusters == null || clusters.isEmpty()) {
                names = new ArrayList<>();
                List<Cluster> listClusters = context.clusterList;
                for (Cluster cluster : listClusters) {
                    names.add(cluster.getName());
                }
                getCluster().getName().setEntity(availableName(names));
            } else {
                // Use the DC cluster.
                Cluster cluster = Linq.firstOrNull(clusters);
                getCluster().setClusterId(cluster.getId());
                getCluster().getName().setEntity(cluster.getName());
                getCluster().getDescription().setEntity(cluster.getDescription());
                cluster = Linq.firstOrNull(context.clusterList, new Linq.IdPredicate<>(getCluster().getClusterId()));
                if (cluster != null) {
                    ServerCpu cpu = new ServerCpu();
                    cpu.setCpuName(cluster.getCpuName());
                    getCluster().getCPU().setSelectedItem(cpu);
                }
                setCandidateCluster(cluster);
            }
        }
    } else {
        // Didn't found DC to re-use, so we select new names.
        names = new ArrayList<>();
        for (StoragePool dataCenter : dataCenters) {
            names.add(dataCenter.getName());
        }
        getDataCenter().getName().setEntity(availableName(names));
        // Choose a Data Center version corresponding to the host.
        if (!StringHelper.isNullOrEmpty(host.getSupportedClusterLevels())) {
            // The supported_cluster_levels are sorted.
            // $NON-NLS-1$
            String[] array = host.getSupportedClusterLevels().split("[,]", -1);
            Version maxVersion = null;
            for (int i = 0; i < array.length; i++) {
                Version vdsVersion = new Version(array[i]);
                for (Version version : getDataCenter().getVersion().getItems()) {
                    if (version.equals(vdsVersion) && version.compareTo(maxVersion) > 0) {
                        maxVersion = version;
                    }
                }
            }
            if (maxVersion != null) {
                getDataCenter().getVersion().setSelectedItem(maxVersion);
                getCluster().getVersion().setSelectedItem(maxVersion);
            }
        }
        names = new ArrayList<>();
        if (clusters != null) {
            for (Cluster cluster : clusters) {
                names.add(cluster.getName());
            }
        }
        getCluster().getName().setEntity(availableName(names));
    }
    // Choose default CPU name to match host.
    List<ServerCpu> serverCpus = (List<ServerCpu>) getCluster().getCPU().getItems();
    if (host.getCpuName() != null) {
        getCluster().getCPU().setSelectedItem(serverCpus.get(0));
    } else {
        getCluster().getCPU().setSelectedItem(serverCpus.isEmpty() ? null : serverCpus.get(0));
    }
    // Always choose a available storage name.
    List<StorageDomain> storages = context.storageList;
    names = new ArrayList<>();
    for (StorageDomain storageDomain : storages) {
        names.add(storageDomain.getStorageName());
    }
    getFormattedStorageName().setEntity(availableName(names));
}
#method_after
private void setDefaultNames8() {
    VDS host = context.host;
    List<StoragePool> dataCenters = context.dataCenterList;
    List<Cluster> clusters = context.clusterList;
    // $NON-NLS-1$
    setCommonName(host.getName().replace('.', '-') + "-Local");
    StoragePool candidate = null;
    // Check if current settings suitable for local setup (in case just SD creation failed - re-using the same
    // setup)
    boolean useCurrentSettings = false;
    if (host.getStoragePoolId() != null) {
        StoragePool tempCandidate = context.hostDataCenter;
        if (isLocalDataCenterEmpty(tempCandidate)) {
            candidate = tempCandidate;
            useCurrentSettings = true;
        } else {
            if (tempCandidate != null && tempCandidate.isLocal()) {
                setMessage(ConstantsManager.getInstance().getConstants().noteLocalStorageAlreadyConfiguredForThisHostMsg() + " " + host.getStoragePoolName() + " " + // $NON-NLS-1$ //$NON-NLS-2$
                ConstantsManager.getInstance().getConstants().withLocalStorageDomainMsg());
            }
        }
    }
    // Check if there is other DC suitable for re-use
    if (candidate == null) {
        for (StoragePool dataCenter : dataCenters) {
            // Need to check if the new DC is without host.
            if (isLocalDataCenterEmpty(dataCenter) && context.localStorageHostByDataCenterMap.get(dataCenter) == null) {
                candidate = dataCenter;
                break;
            }
        }
    }
    ArrayList<String> names;
    // In case we found a suitable candidate for re-use:
    if (candidate != null) {
        getDataCenter().setDataCenterId(candidate.getId());
        getDataCenter().getName().setEntity(candidate.getName());
        getDataCenter().getDescription().setEntity(candidate.getdescription());
        Version version = candidate.getCompatibilityVersion();
        getDataCenter().getVersion().setSelectedItem(version);
        getCluster().getVersion().setSelectedItem(version);
        setCandidateDataCenter(candidate);
        // If we use current settings there is no need to create cluster.
        if (useCurrentSettings) {
            getCluster().setClusterId(host.getClusterId());
            getCluster().getName().setEntity(host.getClusterName());
            Cluster cluster = context.hostCluster;
            if (cluster != null) {
                getCluster().getDescription().setEntity(cluster.getDescription());
                ServerCpu cpu = new ServerCpu();
                cpu.setCpuName(cluster.getCpuName());
                getCluster().getCPU().setSelectedItem(cpu);
            }
            setCandidateCluster(cluster);
        } else // Use different cluster
        {
            // Check the DC cluster list (for re-use)
            clusters = context.clusterListByDataCenterMap.get(candidate);
            // No clusters available - pick up new name.
            if (clusters == null || clusters.isEmpty()) {
                names = new ArrayList<>();
                List<Cluster> listClusters = context.clusterList;
                for (Cluster cluster : listClusters) {
                    names.add(cluster.getName());
                }
                getCluster().getName().setEntity(availableName(names));
            } else {
                // Use the DC cluster.
                Cluster cluster = Linq.firstOrNull(clusters);
                getCluster().setClusterId(cluster.getId());
                getCluster().getName().setEntity(cluster.getName());
                getCluster().getDescription().setEntity(cluster.getDescription());
                cluster = Linq.firstOrNull(context.clusterList, new Linq.IdPredicate<>(getCluster().getClusterId()));
                if (cluster != null) {
                    ServerCpu cpu = new ServerCpu();
                    cpu.setCpuName(cluster.getCpuName());
                    getCluster().getCPU().setSelectedItem(cpu);
                }
                setCandidateCluster(cluster);
            }
        }
    } else {
        // Didn't found DC to re-use, so we select new names.
        names = new ArrayList<>();
        for (StoragePool dataCenter : dataCenters) {
            names.add(dataCenter.getName());
        }
        getDataCenter().getName().setEntity(availableName(names));
        // Choose a Data Center version corresponding to the host.
        if (!StringHelper.isNullOrEmpty(host.getSupportedClusterLevels())) {
            // The supported_cluster_levels are sorted.
            // $NON-NLS-1$
            String[] array = host.getSupportedClusterLevels().split("[,]", -1);
            Version maxVersion = null;
            for (int i = 0; i < array.length; i++) {
                Version vdsVersion = new Version(array[i]);
                for (Version version : getDataCenter().getVersion().getItems()) {
                    if (version.equals(vdsVersion) && version.compareTo(maxVersion) > 0) {
                        maxVersion = version;
                    }
                }
            }
            if (maxVersion != null) {
                getDataCenter().getVersion().setSelectedItem(maxVersion);
                getCluster().getVersion().setSelectedItem(maxVersion);
            }
        }
        names = new ArrayList<>();
        if (clusters != null) {
            for (Cluster cluster : clusters) {
                names.add(cluster.getName());
            }
        }
        getCluster().getName().setEntity(availableName(names));
    }
    // Choose default CPU name to match host.
    List<ServerCpu> serverCpus = (List<ServerCpu>) getCluster().getCPU().getItems();
    getCluster().getCPU().setSelectedItem(serverCpus.isEmpty() ? null : serverCpus.get(0));
    // Always choose a available storage name.
    List<StorageDomain> storages = context.storageList;
    names = new ArrayList<>();
    for (StorageDomain storageDomain : storages) {
        names.add(storageDomain.getStorageName());
    }
    getFormattedStorageName().setEntity(availableName(names));
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    quotaEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    increaseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    maxMemorySizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    threadsPerCoreEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    poolStatefulEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    isHeadlessModeEnabledEditor.setTabIndex(nextTabIndex++);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    consoleDisconnectActionEditor.setTabIndexes(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationPolicyEditor.setTabIndex(nextTabIndex++);
    migrationPolicyEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    customCompatibilityVersionEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceUrandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    // ==Foreman Tab==
    nextTabIndex = foremanTab.setTabIndexes(nextTabIndex);
    // ==Affinity Labels Tab==
    nextTabIndex = affinityLabelsTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    quotaEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    increaseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    maxMemorySizeEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    threadsPerCoreEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    poolStatefulEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    isHeadlessModeEnabledEditor.setTabIndex(nextTabIndex++);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    consoleDisconnectActionEditor.setTabIndexes(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationPolicyEditor.setTabIndex(nextTabIndex++);
    migrationPolicyEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    customCompatibilityVersionEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceUrandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    // ==Foreman Tab==
    nextTabIndex = foremanTab.setTabIndexes(nextTabIndex);
    // ==Affinity Labels Tab==
    nextTabIndex = affinityLabelsTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    if (getParameters().getConfigurationType() == null) {
        log.error("received invalid configuration type: null");
        return;
    }
    switch(getParameters().getConfigurationType()) {
        case OVF:
            try {
                getQueryReturnValue().setReturnValue(ovfHelper.readVmTemplateFromOvf(getParameters().getVmConfiguration()).getVm());
                getQueryReturnValue().setSucceeded(true);
            } catch (OvfReaderException e) {
                log.debug("failed to parse a given ovf configuration: \n" + getParameters().getVmConfiguration(), e);
                getQueryReturnValue().setExceptionString("failed to parse a given ovf configuration " + e.getMessage());
            }
            break;
        case OVA:
            try {
                getQueryReturnValue().setReturnValue(ovfHelper.readVmTemplateFromOva(getParameters().getVmConfiguration()));
                getQueryReturnValue().setSucceeded(true);
            } catch (OvfReaderException e) {
                log.debug("failed to parse a given ovf configuration: \n" + getParameters().getVmConfiguration(), e);
                getQueryReturnValue().setExceptionString("failed to parse a given ovf configuration " + e.getMessage());
            }
            break;
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    if (getParameters().getConfigurationType() == null) {
        log.error("received invalid configuration type: null");
        getQueryReturnValue().setSucceeded(false);
        getQueryReturnValue().setExceptionString("received invalid configuration type: null");
        return;
    }
    switch(getParameters().getConfigurationType()) {
        case OVF:
            try {
                getQueryReturnValue().setReturnValue(ovfHelper.readVmTemplateFromOvf(getParameters().getVmConfiguration()).getVm());
            } catch (OvfReaderException e) {
                log.warn("failed to parse a given ovf configuration: \n" + getParameters().getVmConfiguration(), e);
                getQueryReturnValue().setSucceeded(false);
                getQueryReturnValue().setExceptionString("failed to parse a given ovf configuration " + e.getMessage());
            }
            break;
        case OVA:
            try {
                getQueryReturnValue().setReturnValue(ovfHelper.readVmTemplateFromOva(getParameters().getVmConfiguration()));
            } catch (OvfReaderException e) {
                log.warn("failed to parse a given ovf configuration: \n" + getParameters().getVmConfiguration(), e);
                getQueryReturnValue().setSucceeded(false);
                getQueryReturnValue().setExceptionString("failed to parse a given ovf configuration " + e.getMessage());
            }
            break;
    }
}
#end_block

#method_before
public VmTemplate readVmTemplateFromOva(String ovf) throws OvfReaderException {
    ovf = format(ovf);
    VmTemplate template = new VmTemplate();
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(template);
    ovfManager.importTemplateFromOva(ovf, fullEntityOvfData);
    template.setInterfaces(fullEntityOvfData.getInterfaces());
    // add disk map
    for (DiskImage disk : fullEntityOvfData.getDiskImages()) {
        template.getDiskTemplateMap().put(disk.getId(), disk);
    }
    return template;
}
#method_after
public VmTemplate readVmTemplateFromOva(String ovf) throws OvfReaderException {
    ovf = format(ovf);
    VmTemplate template = new VmTemplate();
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(template);
    ovfManager.importTemplateFromOva(ovf, fullEntityOvfData);
    template.setInterfaces(fullEntityOvfData.getInterfaces());
    // add disk map
    fullEntityOvfData.getDiskImages().forEach(disk -> template.getDiskTemplateMap().put(disk.getId(), disk));
    return template;
}
#end_block

#method_before
public FullEntityOvfData readVmTemplateFromOvf(String ovf) throws OvfReaderException {
    VmTemplate template = new VmTemplate();
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(template);
    ovfManager.importTemplate(ovf, fullEntityOvfData);
    template.setInterfaces(fullEntityOvfData.getInterfaces());
    // add disk map
    for (DiskImage disk : fullEntityOvfData.getDiskImages()) {
        template.getDiskTemplateMap().put(disk.getId(), disk);
    }
    return fullEntityOvfData;
}
#method_after
public FullEntityOvfData readVmTemplateFromOvf(String ovf) throws OvfReaderException {
    VmTemplate template = new VmTemplate();
    FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(template);
    ovfManager.importTemplate(ovf, fullEntityOvfData);
    template.setInterfaces(fullEntityOvfData.getInterfaces());
    // add disk map
    fullEntityOvfData.getDiskImages().forEach(disk -> template.getDiskTemplateMap().put(disk.getId(), disk));
    return fullEntityOvfData;
}
#end_block

#method_before
private ValidationResult validateRequiredNetworksAvailable(VDS vds, VM vm, List<VmNetworkInterface> vmNICs, Network displayNetwork, Map<String, Network> networksByName, List<String> hostNetworks, VdsNetworkInterface displayNic) {
    List<String> missingIfs = new ArrayList<>();
    boolean onlyRequiredNetworks = Config.<Boolean>getValue(ConfigValues.OnlyRequiredNetworksMandatoryForVdsSelection);
    for (final VmNetworkInterface vmIf : vmNICs) {
        boolean found = false;
        boolean skipNetworkExistenceCheckForVnicPassthrough = vmIf.isPassthrough();
        if (vmIf.getNetworkName() == null) {
            found = true;
        } else {
            for (String networkName : hostNetworks) {
                if (skipNetworkExistenceCheckForVnicPassthrough || !networkRequiredOnVds(vmIf, networksByName, onlyRequiredNetworks) || StringUtils.equals(vmIf.getNetworkName(), networkName)) {
                    found = true;
                    break;
                }
            }
        }
        if (!found) {
            missingIfs.add(vmIf.getNetworkName());
        }
        Network network = networksByName.get(vmIf.getNetworkName());
        if (network.isExternal()) {
            checkExternalNetworkConnection(network, hostNetworks).ifPresent(missingIfs::add);
        }
    }
    if (!missingIfs.isEmpty()) {
        String nics = StringUtils.join(missingIfs, ", ");
        log.warn("host {} is missing networks required by VM nics {}", vds.getName(), nics);
        return new ValidationResult(EngineMessage.VAR__DETAIL__NETWORK_MISSING, String.format("$networkNames %1$s", nics));
    }
    return validateDisplayNetworkAvailability(vds, onlyRequiredNetworks, displayNic, displayNetwork);
}
#method_after
private ValidationResult validateRequiredNetworksAvailable(VDS vds, VM vm, List<VmNetworkInterface> vmNICs, Network displayNetwork, Map<String, Network> networksByName, List<String> hostNetworks, VdsNetworkInterface displayNic) {
    List<String> missingIfs = new ArrayList<>();
    boolean onlyRequiredNetworks = Config.<Boolean>getValue(ConfigValues.OnlyRequiredNetworksMandatoryForVdsSelection);
    for (final VmNetworkInterface vmIf : vmNICs) {
        boolean found = false;
        boolean skipNetworkExistenceCheckForVnicPassthrough = vmIf.isPassthrough();
        if (vmIf.getNetworkName() == null) {
            found = true;
        } else {
            for (String networkName : hostNetworks) {
                if (skipNetworkExistenceCheckForVnicPassthrough || !networkRequiredOnVds(vmIf, networksByName, onlyRequiredNetworks) || StringUtils.equals(vmIf.getNetworkName(), networkName)) {
                    found = true;
                    break;
                }
            }
            Network network = networksByName.get(vmIf.getNetworkName());
            if (network.isExternal()) {
                findPhysicalNetworkNotConnectedAndLinkedTo(network, hostNetworks).ifPresent(missingIfs::add);
            }
        }
        if (!found) {
            missingIfs.add(vmIf.getNetworkName());
        }
    }
    if (!missingIfs.isEmpty()) {
        String nics = StringUtils.join(missingIfs, ", ");
        log.warn("host {} is missing networks required by VM nics {}", vds.getName(), nics);
        return new ValidationResult(EngineMessage.VAR__DETAIL__NETWORK_MISSING, String.format("$networkNames %1$s", nics));
    }
    return validateDisplayNetworkAvailability(vds, onlyRequiredNetworks, displayNic, displayNetwork);
}
#end_block

#method_before
public static void notifyClientOfAuditLogEvent(SsoContext ssoContext, String clientId, String userName, String loginErrMsg) throws Exception {
    ClientInfo clientInfo = ssoContext.getClienInfo(clientId);
    if (clientInfo != null) {
        String url = clientInfo.getClientNotificationCallback();
        if (StringUtils.isNotEmpty(url)) {
            HttpPost request = createPost(url);
            List<BasicNameValuePair> form = new ArrayList<>(3);
            form.add(new BasicNameValuePair("event", "auditLog"));
            form.add(new BasicNameValuePair("userName", userName));
            form.add(new BasicNameValuePair("loginErrMsg", loginErrMsg));
            form.add(new BasicNameValuePair("clientSecret", clientInfo.getClientSecret()));
            request.setEntity(new UrlEncodedFormEntity(form, StandardCharsets.UTF_8));
            execute(request, ssoContext, clientId);
        }
    }
}
#method_after
public static void notifyClientOfAuditLogEvent(SsoContext ssoContext, String sourceIp, String clientId, String userName, String loginErrMsg) throws Exception {
    ClientInfo clientInfo = ssoContext.getClienInfo(clientId);
    if (clientInfo != null) {
        String url = clientInfo.getClientNotificationCallback();
        if (StringUtils.isNotEmpty(url)) {
            HttpPost request = createPost(url);
            List<BasicNameValuePair> form = new ArrayList<>();
            form.add(new BasicNameValuePair("event", "auditLog"));
            form.add(new BasicNameValuePair("userName", userName));
            form.add(new BasicNameValuePair("loginErrMsg", loginErrMsg));
            form.add(new BasicNameValuePair("clientSecret", clientInfo.getClientSecret()));
            form.add(new BasicNameValuePair("sourceIp", sourceIp));
            request.setEntity(new UrlEncodedFormEntity(form, StandardCharsets.UTF_8));
            execute(request, ssoContext, clientId);
        }
    }
}
#end_block

#method_before
public static void handleCredentials(SsoContext ssoContext, HttpServletRequest request, Credentials credentials, boolean interactive) throws Exception {
    log.debug("Entered AuthenticationUtils.handleCredentials");
    if (StringUtils.isEmpty(credentials.getUsername()) || StringUtils.isEmpty(credentials.getProfile())) {
        throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_PROVIDE_USERNAME_PASSWORD_AND_PROFILE, (Locale) request.getAttribute(SsoConstants.LOCALE)));
    }
    SsoSession ssoSession = login(ssoContext, request, credentials, null, interactive);
    log.info("User {}@{} successfully logged in with scopes: {}", credentials.getUsername(), credentials.getProfile(), ssoSession.getScope());
}
#method_after
public static void handleCredentials(SsoContext ssoContext, HttpServletRequest request, Credentials credentials, boolean interactive) throws Exception {
    log.debug("Entered AuthenticationUtils.handleCredentials");
    if (StringUtils.isEmpty(credentials.getUsername()) || StringUtils.isEmpty(credentials.getProfile())) {
        throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_PROVIDE_USERNAME_PASSWORD_AND_PROFILE, (Locale) request.getAttribute(SsoConstants.LOCALE)));
    }
    SsoSession ssoSession = login(ssoContext, request, credentials, null, interactive);
    log.info("User {} successfully logged in with scopes: {}", credentials.getUsernameWithProfile(), ssoSession.getScope());
}
#end_block

#method_before
private static SsoSession login(SsoContext ssoContext, HttpServletRequest request, Credentials credentials, ExtMap authRecord, boolean interactive) throws Exception {
    ExtensionProfile profile = getExtensionProfile(ssoContext, credentials.getProfile());
    String user = mapUser(profile, credentials);
    if (authRecord == null) {
        log.debug("AuthenticationUtils.handleCredentials invoking AUTHENTICATE_CREDENTIALS on authn");
        ExtMap outputMap = profile.authn.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, credentials.getPassword()));
        if (outputMap.<Integer>get(Base.InvokeKeys.RESULT) != Base.InvokeResult.SUCCESS || outputMap.<Integer>get(Authn.InvokeKeys.RESULT) != Authn.AuthResult.SUCCESS) {
            if (interactive) {
                SsoUtils.getSsoSession(request).setChangePasswdCredentials(credentials);
            }
            log.debug("AuthenticationUtils.handleCredentials AUTHENTICATE_CREDENTIALS on authn failed");
            String loginErrMsg = AuthnMessageMapper.mapMessageErrorCode(request, credentials.getProfile(), outputMap);
            SsoUtils.notifyClientOfAuditLogEvent(ssoContext, ssoContext.getSsoLocalConfig().getProperty("ENGINE_SSO_CLIENT_ID"), Optional.ofNullable(credentials).map(Credentials::getUsernameWithProfile).orElse("N/A"), ssoContext.getLocalizationUtils().localize(loginErrMsg, Locale.ENGLISH));
            throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(loginErrMsg, (Locale) request.getAttribute(SsoConstants.LOCALE)));
        }
        log.debug("AuthenticationUtils.handleCredentials AUTHENTICATE_CREDENTIALS on authn succeeded");
        authRecord = outputMap.get(Authn.InvokeKeys.AUTH_RECORD);
    }
    if (profile.mapper != null) {
        log.debug("AuthenticationUtils.handleCredentials invoking MAP_AUTH_RECORD on mapper");
        authRecord = profile.mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    log.debug("AuthenticationUtils.handleCredentials invoking FETCH_PRINCIPAL_RECORD on authz");
    ExtMap output = profile.authz.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord).mput(Authz.InvokeKeys.QUERY_FLAGS, Authz.QueryFlags.RESOLVE_GROUPS | Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE));
    log.debug("AuthenticationUtils.handleCredentials saving data in session data");
    return SsoUtils.persistAuthInfoInContextWithToken(request, credentials.getPassword(), credentials.getProfile(), authRecord, output.get(Authz.InvokeKeys.PRINCIPAL_RECORD));
}
#method_after
private static SsoSession login(SsoContext ssoContext, HttpServletRequest request, Credentials credentials, ExtMap authRecord, boolean interactive) throws Exception {
    ExtensionProfile profile = getExtensionProfile(ssoContext, credentials.getProfile());
    String user = mapUser(profile, credentials);
    if (authRecord == null) {
        log.debug("AuthenticationUtils.handleCredentials invoking AUTHENTICATE_CREDENTIALS on authn");
        ExtMap outputMap = profile.authn.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, credentials.getPassword()));
        if (outputMap.<Integer>get(Base.InvokeKeys.RESULT) != Base.InvokeResult.SUCCESS || outputMap.<Integer>get(Authn.InvokeKeys.RESULT) != Authn.AuthResult.SUCCESS) {
            if (interactive) {
                SsoUtils.getSsoSession(request).setChangePasswdCredentials(credentials);
            }
            log.debug("AuthenticationUtils.handleCredentials AUTHENTICATE_CREDENTIALS on authn failed");
            String loginErrMsg = AuthnMessageMapper.mapMessageErrorCode(request, credentials.getProfile(), outputMap);
            SsoSession ssoSession = SsoUtils.getSsoSession(request, false);
            String sourceAddr = ssoSession == null ? null : ssoSession.getSourceAddr();
            SsoUtils.notifyClientOfAuditLogEvent(ssoContext, sourceAddr == null ? request.getRemoteAddr() : sourceAddr, ssoContext.getSsoLocalConfig().getProperty("ENGINE_SSO_CLIENT_ID"), Optional.ofNullable(credentials).map(Credentials::getUsernameWithProfile).orElse("N/A"), ssoContext.getLocalizationUtils().localize(loginErrMsg, Locale.ENGLISH));
            throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(loginErrMsg, (Locale) request.getAttribute(SsoConstants.LOCALE)));
        }
        log.debug("AuthenticationUtils.handleCredentials AUTHENTICATE_CREDENTIALS on authn succeeded");
        authRecord = outputMap.get(Authn.InvokeKeys.AUTH_RECORD);
    }
    if (profile.mapper != null) {
        log.debug("AuthenticationUtils.handleCredentials invoking MAP_AUTH_RECORD on mapper");
        authRecord = profile.mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    log.debug("AuthenticationUtils.handleCredentials invoking FETCH_PRINCIPAL_RECORD on authz");
    ExtMap output = profile.authz.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord).mput(Authz.InvokeKeys.QUERY_FLAGS, Authz.QueryFlags.RESOLVE_GROUPS | Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE));
    log.debug("AuthenticationUtils.handleCredentials saving data in session data");
    return SsoUtils.persistAuthInfoInContextWithToken(request, credentials.getPassword(), credentials.getProfile(), authRecord, output.get(Authz.InvokeKeys.PRINCIPAL_RECORD));
}
#end_block

#method_before
public String getUsernameWithProfile() {
    String user = String.format("%s@%s", StringUtils.defaultIfEmpty(username, ""), StringUtils.defaultIfEmpty(profile, ""));
    return "@".equals(user) ? "N/A" : user;
}
#method_after
public String getUsernameWithProfile() {
    String user = String.format("%s@%s", Objects.toString(username, ""), Objects.toString(profile, ""));
    return "@".equals(user) ? "N/A" : user;
}
#end_block

#method_before
@Override
public String toString() {
    String user = String.format("%s@%s", StringUtils.defaultIfEmpty(username, ""), StringUtils.defaultIfEmpty(profile, ""));
    return "@".equals(user) ? "" : (" for user " + user);
}
#method_after
@Override
public String toString() {
    String user = getUsernameWithProfile();
    return "N/A".equals(user) ? "" : (" for user " + user);
}
#end_block

#method_before
private void handleAuditLog(HttpServletRequest request, HttpServletResponse response) {
    try {
        String clientSecret = request.getParameter("clientSecret");
        String engineClientSecret = EngineLocalConfig.getInstance().getProperty("ENGINE_SSO_CLIENT_SECRET");
        if (EnvelopePBE.check(clientSecret, engineClientSecret)) {
            String loginErrMsg = request.getParameter("loginErrMsg");
            String userName = request.getParameter("userName");
            AuditLogable event = new AuditLogableImpl();
            event.addCustomValue("LoginErrMsg", loginErrMsg);
            event.setUserName(userName);
            auditLogDirector.log(event, AuditLogType.USER_LOGIN_FAILED_WITH_MSG);
        }
    } catch (Exception ex) {
        response.setStatus(HttpURLConnection.HTTP_INTERNAL_ERROR);
    } finally {
        response.setStatus(HttpURLConnection.HTTP_OK);
    }
}
#method_after
private void handleAuditLog(HttpServletRequest request, HttpServletResponse response) {
    try {
        String clientSecret = request.getParameter("clientSecret");
        String engineClientSecret = EngineLocalConfig.getInstance().getProperty("ENGINE_SSO_CLIENT_SECRET");
        // Check if the client secret passed by Sso matches the client secret in config
        if (EnvelopePBE.check(clientSecret, engineClientSecret)) {
            String loginErrMsg = request.getParameter("loginErrMsg");
            String userName = request.getParameter("userName");
            String sourceIp = request.getParameter("sourceIp");
            AuditLogable event = new AuditLogableImpl();
            event.addCustomValue("LoginErrMsg", String.format(" : '%s'", loginErrMsg));
            event.addCustomValue("SourceIP", sourceIp);
            event.setUserName(userName);
            auditLogDirector.log(event, AuditLogType.USER_VDC_LOGIN_FAILED);
        }
    } catch (Exception ex) {
        response.setStatus(HttpURLConnection.HTTP_INTERNAL_ERROR);
    } finally {
        response.setStatus(HttpURLConnection.HTTP_OK);
    }
}
#end_block

#method_before
@Override
public void storagePoolStatusChanged(Guid storagePoolId, StoragePoolStatus status) {
    StoragePoolStatusHandler.poolStatusChanged(storagePoolId, status);
}
#method_after
@Override
public void storagePoolStatusChanged(Guid storagePoolId, StoragePoolStatus status) {
    storagePoolStatusHandler.poolStatusChanged(storagePoolId, status);
}
#end_block

#method_before
// used by AuditLogger via reflection
@SuppressWarnings("unused")
public String getDueToMigrationError() {
    if (migrationErrorCode != null) {
        return " due to an Error: " + Backend.getInstance().getVdsErrorsTranslator().translateErrorTextSingle(migrationErrorCode.name(), true);
    }
    return " ";
}
#method_after
// used by AuditLogger via reflection
@SuppressWarnings("unused")
public String getDueToMigrationError() {
    if (migrationErrorCode != null) {
        return " due to an Error: " + backend.getVdsErrorsTranslator().translateErrorTextSingle(migrationErrorCode.name(), true);
    }
    return " ";
}
#end_block

#method_before
protected boolean perform() {
    try {
        getParameters().setTotalMigrationTime(new Date());
        if (unplugPassthroughNics() && connectLunDisks(getDestinationVdsId()) && migrateVm()) {
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            return true;
        }
        // otherwise
        runningFailed();
        return false;
    } catch (Exception e) {
        runningFailed();
        throw e;
    }
}
#method_after
protected boolean perform() {
    try {
        getParameters().setTotalMigrationTime(new Date());
        getParameters().resetStartTime();
        if (unplugPassthroughNics() && connectLunDisks(getDestinationVdsId()) && migrateVm()) {
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            return true;
        }
        // otherwise
        runningFailed();
        return false;
    } catch (Exception e) {
        runningFailed();
        throw e;
    }
}
#end_block

#method_before
private boolean migrateVm() {
    setActionReturnValue(getVdsBroker().runAsyncVdsCommand(VDSCommandType.Migrate, createMigrateVDSCommandParameters(), this).getReturnValue());
    return getActionReturnValue() == VMStatus.MigratingFrom;
}
#method_after
private boolean migrateVm() {
    setActionReturnValue(vdsBroker.runAsyncVdsCommand(VDSCommandType.Migrate, createMigrateVDSCommandParameters(), this).getReturnValue());
    return getActionReturnValue() == VMStatus.MigratingFrom;
}
#end_block

#method_before
@Override
protected void logValidationFailed() {
    addCustomValue("DueToMigrationError", " due to a failed validation: " + Backend.getInstance().getErrorsTranslator().translateErrorText(getReturnValue().getValidationMessages()));
    auditLogDirector.log(this, AuditLogType.VM_MIGRATION_FAILED);
}
#method_after
@Override
protected void logValidationFailed() {
    addCustomValue("DueToMigrationError", " due to a failed validation: " + backend.getErrorsTranslator().translateErrorText(getReturnValue().getValidationMessages()));
    auditLogDirector.log(this, AuditLogType.VM_MIGRATION_FAILED);
}
#end_block

#method_before
private void resumeVm() {
    setVdsId(getVm().getRunOnVds());
    if (getVds() != null) {
        try {
            VDSReturnValue result = getVdsBroker().runAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
        } finally {
            freeLock();
        }
    } else {
        setActionReturnValue(getVm().getStatus());
    }
}
#method_after
private void resumeVm() {
    setVdsId(getVm().getRunOnVds());
    if (getVds() != null) {
        try {
            VDSReturnValue result = vdsBroker.runAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
        } finally {
            freeLock();
        }
    } else {
        setActionReturnValue(getVm().getStatus());
    }
}
#end_block

#method_before
protected VMStatus createVm() {
    updateCdPath();
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    initParametersForExternalNetworks(getVds(), false);
    VMStatus vmStatus = (VMStatus) getVdsBroker().runAsyncVdsCommand(VDSCommandType.Create, buildCreateVmParameters(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotUsed = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#method_after
protected VMStatus createVm() {
    updateCdPath();
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    initParametersForExternalNetworks(getVds(), false);
    VMStatus vmStatus = (VMStatus) vdsBroker.runAsyncVdsCommand(VDSCommandType.Create, buildCreateVmParameters(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotUsed = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#end_block

#method_before
@Override
protected void logValidationFailed() {
    addCustomValue("DueToError", " due to a failed validation: " + Backend.getInstance().getErrorsTranslator().translateErrorText(getReturnValue().getValidationMessages()));
    auditLogDirector.log(this, AuditLogType.USER_FAILED_RUN_VM);
}
#method_after
@Override
protected void logValidationFailed() {
    addCustomValue("DueToError", " due to a failed validation: " + backend.getErrorsTranslator().translateErrorText(getReturnValue().getValidationMessages()));
    auditLogDirector.log(this, AuditLogType.USER_FAILED_RUN_VM);
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    StorageDomainSharedStatusColumn sharedStatusColumn = new StorageDomainSharedStatusColumn();
    sharedStatusColumn.setContextMenuTitle(constants.sharedStatusStorage());
    // $NON-NLS-1$
    getTable().addColumn(sharedStatusColumn, constants.empty(), "30px");
    StorageDomainAdditionalStatusColumn additionalStatusColumn = new StorageDomainAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusStorage());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "60px");
    AbstractTextColumn<StorageDomain> nameColumn = new AbstractLinkColumn<StorageDomain>(new FieldUpdater<StorageDomain, String>() {

        @Override
        public void update(int index, StorageDomain storageDomain, String value) {
            Map<String, String> parameters = new HashMap<>();
            parameters.put(FragmentParams.NAME.getName(), storageDomain.getName());
            // The link was clicked, now fire an event to switch to details.
            getPlaceTransitionHandler().handlePlaceTransition(WebAdminApplicationPlaces.storageGeneralSubTabPlace, parameters);
        }
    }) {

        @Override
        public String getValue(StorageDomain object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(StorageDomainFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.domainNameStorage(), "150px");
    CommentColumn<StorageDomain> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<StorageDomain> domainTypeColumn = new AbstractEnumColumn<StorageDomain, StorageDomainType>() {

        @Override
        protected StorageDomainType getRawValue(StorageDomain object) {
            return object.getStorageDomainType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(domainTypeColumn, constants.domainTypeStorage(), "150px");
    AbstractTextColumn<StorageDomain> storageTypeColumn = new AbstractEnumColumn<StorageDomain, StorageType>() {

        @Override
        protected StorageType getRawValue(StorageDomain object) {
            return object.getStorageType();
        }
    };
    storageTypeColumn.makeSortable(StorageDomainFieldAutoCompleter.TYPE);
    // $NON-NLS-1$
    getTable().addColumn(storageTypeColumn, constants.storageTypeStorage(), "150px");
    AbstractTextColumn<StorageDomain> formatColumn = new AbstractEnumColumn<StorageDomain, StorageFormatType>() {

        @Override
        protected StorageFormatType getRawValue(StorageDomain object) {
            return object.getStorageFormat();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(formatColumn, constants.formatStorage(), "140px");
    AbstractTextColumn<StorageDomain> crossDataCenterStatusColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            if (object.getStorageDomainType() == StorageDomainType.ISO) {
                return EnumTranslator.getInstance().translate(object.getStorageDomainSharedStatus());
            } else {
                return EnumTranslator.getInstance().translate(object.getStatus());
            }
        }
    };
    crossDataCenterStatusColumn.makeSortable(StorageDomainFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(crossDataCenterStatusColumn, constants.crossDcStatusStorage(), "210px");
    AbstractStorageSizeColumn<StorageDomain> totalSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer totalSpace = object.getTotalDiskSize();
            return totalSpace == null ? null : Long.valueOf(totalSpace);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(totalSpaceColumn, constants.totalSpaceStorage(), "130px");
    AbstractStorageSizeColumn<StorageDomain> freeSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer availableDiskSize = object.getAvailableDiskSize();
            return availableDiskSize == null ? null : Long.valueOf(availableDiskSize);
        }
    };
    freeSpaceColumn.makeSortable(StorageDomainFieldAutoCompleter.SIZE);
    // $NON-NLS-1$
    getTable().addColumn(freeSpaceColumn, constants.freeSpaceStorage(), "130px");
    AbstractStorageSizeColumn<StorageDomain> confirmedFreeSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer confirmedAvailableSize = object.getConfirmedAvailableDiskSize();
            Long availableDiskSize = object.getAvailableDiskSize() == null ? null : Long.valueOf(object.getAvailableDiskSize());
            return confirmedAvailableSize == null ? availableDiskSize : Long.valueOf(confirmedAvailableSize);
        }

        @Override
        public SafeHtml getTooltip(StorageDomain object) {
            if (object.getConfirmedAvailableDiskSize() == null) {
                return SafeHtmlUtils.fromString(constants.confirmedFreeSpaceStorageNonThinTooltip());
            }
            return SafeHtmlUtils.fromString(constants.confirmedFreeSpaceStorageThinTooltip());
        }
    };
    confirmedFreeSpaceColumn.makeSortable(StorageDomainFieldAutoCompleter.SIZE);
    // $NON-NLS-1$
    getTable().addColumn(confirmedFreeSpaceColumn, constants.confirmedFreeSpaceStorage(), "180px");
    AbstractTextColumn<StorageDomain> descriptionColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(StorageDomainFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.domainDescriptionStorage(), "200px");
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    StorageDomainSharedStatusColumn sharedStatusColumn = new StorageDomainSharedStatusColumn();
    sharedStatusColumn.setContextMenuTitle(constants.sharedStatusStorage());
    // $NON-NLS-1$
    getTable().addColumn(sharedStatusColumn, constants.empty(), "30px");
    StorageDomainAdditionalStatusColumn additionalStatusColumn = new StorageDomainAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusStorage());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "60px");
    AbstractTextColumn<StorageDomain> nameColumn = new AbstractLinkColumn<StorageDomain>(new FieldUpdater<StorageDomain, String>() {

        @Override
        public void update(int index, StorageDomain storageDomain, String value) {
            Map<String, String> parameters = new HashMap<>();
            parameters.put(FragmentParams.NAME.getName(), storageDomain.getName());
            // The link was clicked, now fire an event to switch to details.
            getPlaceTransitionHandler().handlePlaceTransition(WebAdminApplicationPlaces.storageGeneralSubTabPlace, parameters);
        }
    }) {

        @Override
        public String getValue(StorageDomain object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(StorageDomainFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.domainNameStorage(), "150px");
    CommentColumn<StorageDomain> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<StorageDomain> domainTypeColumn = new AbstractEnumColumn<StorageDomain, StorageDomainType>() {

        @Override
        protected StorageDomainType getRawValue(StorageDomain object) {
            return object.getStorageDomainType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(domainTypeColumn, constants.domainTypeStorage(), "150px");
    AbstractTextColumn<StorageDomain> storageTypeColumn = new AbstractEnumColumn<StorageDomain, StorageType>() {

        @Override
        protected StorageType getRawValue(StorageDomain object) {
            return object.getStorageType();
        }
    };
    storageTypeColumn.makeSortable(StorageDomainFieldAutoCompleter.TYPE);
    // $NON-NLS-1$
    getTable().addColumn(storageTypeColumn, constants.storageTypeStorage(), "150px");
    AbstractTextColumn<StorageDomain> formatColumn = new AbstractEnumColumn<StorageDomain, StorageFormatType>() {

        @Override
        protected StorageFormatType getRawValue(StorageDomain object) {
            return object.getStorageFormat();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(formatColumn, constants.formatStorage(), "140px");
    AbstractTextColumn<StorageDomain> crossDataCenterStatusColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            if (object.getStorageDomainType() == StorageDomainType.ISO) {
                return EnumTranslator.getInstance().translate(object.getStorageDomainSharedStatus());
            } else {
                return EnumTranslator.getInstance().translate(object.getStatus());
            }
        }
    };
    crossDataCenterStatusColumn.makeSortable(StorageDomainFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(crossDataCenterStatusColumn, constants.crossDcStatusStorage(), "210px");
    AbstractStorageSizeColumn<StorageDomain> totalSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer totalSpace = object.getTotalDiskSize();
            return totalSpace == null ? null : Long.valueOf(totalSpace);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(totalSpaceColumn, constants.totalSpaceStorage(), "130px");
    AbstractStorageSizeColumn<StorageDomain> freeSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer availableDiskSize = object.getAvailableDiskSize();
            return availableDiskSize == null ? null : Long.valueOf(availableDiskSize);
        }
    };
    freeSpaceColumn.makeSortable(StorageDomainFieldAutoCompleter.SIZE);
    // $NON-NLS-1$
    getTable().addColumn(freeSpaceColumn, constants.freeSpaceStorage(), "130px");
    AbstractStorageSizeColumn<StorageDomain> confirmedFreeSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer confirmedAvailableSize = object.getConfirmedAvailableDiskSize();
            Long availableDiskSize = object.getAvailableDiskSize() == null ? null : Long.valueOf(object.getAvailableDiskSize());
            return confirmedAvailableSize == null ? availableDiskSize : Long.valueOf(confirmedAvailableSize);
        }

        @Override
        public SafeHtml getTooltip(StorageDomain object) {
            if (object.getConfirmedAvailableDiskSize() == null) {
                return SafeHtmlUtils.fromString(constants.confirmedFreeSpaceStorageNonThinTooltip());
            }
            return SafeHtmlUtils.fromString(constants.confirmedFreeSpaceStorageThinTooltip());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(confirmedFreeSpaceColumn, constants.confirmedFreeSpaceStorage(), "180px");
    AbstractTextColumn<StorageDomain> descriptionColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(StorageDomainFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.domainDescriptionStorage(), "200px");
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getHostProviderBindingDao();
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
}
#end_block

#method_before
@Test
public void testGet() {
    String result = dao.get(FixturesTool.PROVIDER_BINDING_HOST_ID_VDS_ID, FixturesTool.PROVIDER_BINDING_HOST_ID_PLUGIN_TYPE);
    assertEquals(result, FixturesTool.PROVIDER_BINDING_HOST_ID_HOST_ID);
}
#method_after
@Test
public void testGet() {
    String result = dao.get(FixturesTool.PROVIDER_BINDING_HOST_ID_HOST_ID, FixturesTool.PROVIDER_BINDING_HOST_ID_PLUGIN_TYPE);
    assertEquals(result, FixturesTool.PROVIDER_BINDING_HOST_PLUGIN_ID);
}
#end_block

#method_before
@Test
public void testGetNonexistingPluginType() {
    String result = dao.get(FixturesTool.PROVIDER_BINDING_HOST_ID_VDS_ID, "anything");
    assertNull(result);
}
#method_after
@Test
public void testGetNonexistingPluginType() {
    String result = dao.get(FixturesTool.PROVIDER_BINDING_HOST_ID_HOST_ID, "anything");
    assertNull(result);
}
#end_block

#method_before
@Test
public void testUpdate() {
    Guid vdsId = Guid.newGuid();
    String plugin1 = "OVS";
    String hostId1 = "bee5-1590d-bee5-15g00d";
    String plugin2 = "other-provider";
    String hostId2 = "other value";
    Map<String, Object> values = new HashMap();
    values.put(plugin1, hostId1);
    values.put(plugin2, hostId2);
    dao.update(FixturesTool.PROVIDER_BINDING_HOST_ID_VDS_ID, values);
    String result = dao.get(FixturesTool.PROVIDER_BINDING_HOST_ID_VDS_ID, plugin1);
    assertEquals(result, hostId1);
    result = dao.get(FixturesTool.PROVIDER_BINDING_HOST_ID_VDS_ID, plugin2);
    assertEquals(result, hostId2);
}
#method_after
@Test
public void testUpdate() {
    Guid vdsId = Guid.newGuid();
    String plugin1 = "OVS";
    String hostId1 = "bee5-1590d-bee5-15g00d";
    String plugin2 = "other-provider";
    String hostId2 = "other value";
    Map<String, Object> values = new HashMap();
    values.put(plugin1, hostId1);
    values.put(plugin2, hostId2);
    dao.update(FixturesTool.PROVIDER_BINDING_HOST_ID_HOST_ID, values);
    String result = dao.get(FixturesTool.PROVIDER_BINDING_HOST_ID_HOST_ID, plugin1);
    assertEquals(result, hostId1);
    result = dao.get(FixturesTool.PROVIDER_BINDING_HOST_ID_HOST_ID, plugin2);
    assertEquals(result, hostId2);
}
#end_block

#method_before
@Test
public void testValueIsRemovedIfNotPresentInUpdate() {
    Guid vdsId = Guid.newGuid();
    String plugin = "OVS";
    String hostId = "bee5-1590d-bee5-15g00d";
    Map<String, Object> values = new HashMap();
    values.put(plugin, hostId);
    dao.update(FixturesTool.PROVIDER_BINDING_HOST_ID_VDS_ID, values);
    String result = dao.get(FixturesTool.PROVIDER_BINDING_HOST_ID_VDS_ID, plugin);
    assertEquals(result, hostId);
    values = new HashMap();
    values.put("OTHER", hostId);
    dao.update(FixturesTool.PROVIDER_BINDING_HOST_ID_VDS_ID, values);
    result = dao.get(FixturesTool.PROVIDER_BINDING_HOST_ID_VDS_ID, plugin);
    assertNull(result);
}
#method_after
@Test
public void testValueIsRemovedIfNotPresentInUpdate() {
    Guid vdsId = Guid.newGuid();
    String plugin = "OVS";
    String hostId = "bee5-1590d-bee5-15g00d";
    Map<String, Object> values = new HashMap();
    values.put(plugin, hostId);
    dao.update(FixturesTool.PROVIDER_BINDING_HOST_ID_HOST_ID, values);
    String result = dao.get(FixturesTool.PROVIDER_BINDING_HOST_ID_HOST_ID, plugin);
    assertEquals(result, hostId);
    values = new HashMap();
    values.put("OTHER", hostId);
    dao.update(FixturesTool.PROVIDER_BINDING_HOST_ID_HOST_ID, values);
    result = dao.get(FixturesTool.PROVIDER_BINDING_HOST_ID_HOST_ID, plugin);
    assertNull(result);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    StorageDomain storageDomain = storageDomainDao.get(storageDomainId);
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        QueryReturnValue returnValue = runInternalQuery(QueryType.GetUnregisteredCinderDiskByIdAndStorageDomainId, new GetCinderEntityByStorageDomainIdParameters(diskId, getParameters().getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    } else if (storageDomain.getStorageDomainType().isIsoOrImportExportDomain()) {
        getQueryReturnValue().setExceptionString("Operation not allowed for non-data storage domains.");
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = runVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = runVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    if (!fetchQcowCompat(storagePoolId, storageDomainId, diskId, volumeId, newDiskImage)) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (StringUtils.isNotEmpty(newDiskImage.getDescription())) {
        try {
            metadataDiskDescriptionHandler.enrichDiskByJsonDescription(newDiskImage.getDescription(), newDiskImage);
        } catch (IOException | DecoderException e) {
            log.warn("Could not parse the description ({}) of disk ID '{}'. The description is expected to be in " + "JSON format.", newDiskImage.getDescription(), newDiskImage.getId());
            log.debug("Exception while parsing JSON for disk", e);
        }
    }
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    StorageDomain storageDomain = storageDomainDao.get(storageDomainId);
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        QueryReturnValue returnValue = runInternalQuery(QueryType.GetUnregisteredCinderDiskByIdAndStorageDomainId, new GetCinderEntityByStorageDomainIdParameters(diskId, getParameters().getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    } else if (!storageDomain.getStorageDomainType().isDataDomain()) {
        getQueryReturnValue().setExceptionString("Operation not allowed for non-data storage domains.");
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = runVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = runVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    if (!fetchQcowCompat(storagePoolId, storageDomainId, diskId, volumeId, newDiskImage)) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (StringUtils.isNotEmpty(newDiskImage.getDescription())) {
        try {
            metadataDiskDescriptionHandler.enrichDiskByJsonDescription(newDiskImage.getDescription(), newDiskImage);
        } catch (IOException | DecoderException e) {
            log.warn("Could not parse the description ({}) of disk ID '{}'. The description is expected to be in " + "JSON format.", newDiskImage.getDescription(), newDiskImage.getId());
            log.debug("Exception while parsing JSON for disk", e);
        }
    }
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    StorageDomain storageDomain = storageDomainDao.get(getStorageDomainId());
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        QueryReturnValue returnValue = runInternalQuery(QueryType.GetUnregisteredCinderDisksByStorageDomainId, new IdQueryParameters(getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    } else if (storageDomain.getStorageDomainType().isIsoOrImportExportDomain()) {
        getQueryReturnValue().setExceptionString("Operation not allowed for non-data storage domains.");
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSReturnValue imagesListResult = runVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the Dao
    List<DiskImage> fromDao = diskImageDao.getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        QueryReturnValue unregQueryReturn = runInternalQuery(QueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.getReturnValue());
        } else {
            log.debug("Could not get populated disk: {}", unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#method_after
@Override
protected void executeQueryCommand() {
    StorageDomain storageDomain = storageDomainDao.get(getStorageDomainId());
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        QueryReturnValue returnValue = runInternalQuery(QueryType.GetUnregisteredCinderDisksByStorageDomainId, new IdQueryParameters(getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    } else if (!storageDomain.getStorageDomainType().isDataDomain()) {
        getQueryReturnValue().setExceptionString("Operation not allowed for non-data storage domains.");
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSReturnValue imagesListResult = runVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the Dao
    List<DiskImage> fromDao = diskImageDao.getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        QueryReturnValue unregQueryReturn = runInternalQuery(QueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.getReturnValue());
        } else {
            log.debug("Could not get populated disk: {}", unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        deactivateCinderStorageDomain();
        return;
    }
    StorageDomainStatus lastStatus = getStorageDomain().getStatus();
    final StoragePoolIsoMap map = storagePoolIsoMapDao.get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    final StorageDomain newMaster;
    boolean isMaster = getStorageDomain().getStorageDomainType() == StorageDomainType.Master;
    if (isMaster) {
        newMaster = electNewMaster();
    } else {
        newMaster = null;
    }
    final Guid newMasterId = newMaster != null ? newMaster.getId() : Guid.Empty;
    boolean deactivateSucceeded = true;
    if (!getParameters().isInactive()) {
        if (isMaster) {
            updateStoragePoolMasterDomainVersionInDiffTransaction();
        }
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), newMasterId, getStoragePool().getMasterDomainVersion()));
        deactivateSucceeded = vdsReturnValue.getSucceeded();
    }
    if (deactivateSucceeded) {
        if (isMaster) {
            isLastMaster = proceedStorageDomainTreatmentByDomainType(newMaster, true);
        }
        if (isLastMaster) {
            executeInNewTransaction(() -> {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                storagePoolDao.updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            });
            StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
            getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
            getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
        }
    }
    freeLock();
    if (!deactivateSucceeded && !getParameters().isInactive()) {
        log.error("Failed to deactivate storage domain '{}'", getParameters().getStorageDomainId());
        changeStorageDomainStatusInTransaction(map, lastStatus);
        setSucceeded(false);
        return;
    }
    VDS spm = null;
    if (getStoragePool().getSpmVdsId() != null) {
        spm = vdsDao.get(getStoragePool().getSpmVdsId());
    }
    if (isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure to stop SPM");
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        getEventQueue().submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), () -> {
            runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), isLastMaster, newMasterId);
            return null;
        });
        if (spm != null) {
            getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
        }
    }
    executeInNewTransaction(() -> {
        if (getParameters().isInactive()) {
            map.setStatus(StorageDomainStatus.Inactive);
        } else if (isLastMaster) {
            map.setStatus(StorageDomainStatus.Maintenance);
        } else {
            log.info("Domain '{}' will remain in '{}' status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
        }
        storagePoolIsoMapDao.updateStatus(map.getId(), map.getStatus());
        if (newMaster != null) {
            StoragePoolIsoMap mapOfNewMaster = newMaster.getStoragePoolIsoMapData();
            mapOfNewMaster.setStatus(StorageDomainStatus.Active);
            storagePoolIsoMapDao.updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
        }
        return null;
    });
    if (!getParameters().isSkipChecks()) {
        notifyAsyncTasks();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        deactivateCinderStorageDomain();
        return;
    }
    StorageDomainStatus lastStatus = getStorageDomain().getStatus();
    final StoragePoolIsoMap map = storagePoolIsoMapDao.get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    final StorageDomain newMaster;
    boolean isMaster = getStorageDomain().getStorageDomainType() == StorageDomainType.Master;
    if (isMaster) {
        newMaster = electNewMaster();
    } else {
        newMaster = null;
    }
    final Guid newMasterId = newMaster != null ? newMaster.getId() : Guid.Empty;
    boolean deactivateSucceeded = true;
    if (!getParameters().isInactive()) {
        if (isMaster) {
            updateStoragePoolMasterDomainVersionInDiffTransaction();
        }
        try {
            deactivateSucceeded = runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), newMasterId, getStoragePool().getMasterDomainVersion())).getSucceeded();
        } catch (Exception e) {
            log.error("DeactivateStorageDomainVDS failed '{}'", getParameters().getStorageDomainId(), e);
            deactivateSucceeded = false;
        }
    } else {
        log.info("DeactivateStorageDomainVDS is skipped '{}'", getParameters().getStorageDomainId());
    }
    if (deactivateSucceeded) {
        isLastMaster = isMaster ? proceedStorageDomainTreatmentByDomainType(newMaster, true) : false;
        if (isLastMaster) {
            executeInNewTransaction(() -> {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                storagePoolDao.updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            });
            StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
            getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
            getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
        }
    }
    freeLock();
    if (!deactivateSucceeded) {
        log.error("Failed to deactivate storage domain '{}'", getParameters().getStorageDomainId());
        changeStorageDomainStatusInTransaction(map, lastStatus);
        setSucceeded(false);
        return;
    }
    VDS spm = null;
    if (getStoragePool().getSpmVdsId() != null) {
        spm = vdsDao.get(getStoragePool().getSpmVdsId());
    }
    if (isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure to stop SPM");
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        getEventQueue().submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), () -> {
            runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), isLastMaster, newMasterId);
            return null;
        });
        if (spm != null) {
            getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
        }
    }
    executeInNewTransaction(() -> {
        if (getParameters().isInactive()) {
            map.setStatus(StorageDomainStatus.Inactive);
        } else if (isLastMaster) {
            map.setStatus(StorageDomainStatus.Maintenance);
        } else {
            log.info("Domain '{}' will remain in '{}' status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
        }
        storagePoolIsoMapDao.updateStatus(map.getId(), map.getStatus());
        if (newMaster != null) {
            StoragePoolIsoMap mapOfNewMaster = newMaster.getStoragePoolIsoMapData();
            mapOfNewMaster.setStatus(StorageDomainStatus.Active);
            storagePoolIsoMapDao.updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
        }
        return null;
    });
    if (!getParameters().isSkipChecks()) {
        notifyAsyncTasks();
    }
    setSucceeded(true);
}
#end_block

#method_before
private MapSqlParameterSource createBrickPropertiesParam(BrickProperties brickProperties) {
    return getCustomMapSqlParameterSource().addValue("brick_id", brickProperties.getBrickId()).addValue("total_space", brickProperties.getTotalSize() * SizeConverter.BYTES_IN_MB).addValue("used_space", (brickProperties.getTotalSize() - brickProperties.getFreeSize()) * SizeConverter.BYTES_IN_MB).addValue("free_space", brickProperties.getFreeSize() * SizeConverter.BYTES_IN_MB).addValue("confirmed_free_space", brickProperties.getConfirmedFreeSize() * SizeConverter.BYTES_IN_MB);
}
#method_after
private MapSqlParameterSource createBrickPropertiesParam(BrickProperties brickProperties) {
    Double confirmedFreeSize = brickProperties.getConfirmedFreeSize();
    if (confirmedFreeSize != null) {
        confirmedFreeSize = confirmedFreeSize * SizeConverter.BYTES_IN_MB;
    }
    return getCustomMapSqlParameterSource().addValue("brick_id", brickProperties.getBrickId()).addValue("total_space", brickProperties.getTotalSize() * SizeConverter.BYTES_IN_MB).addValue("used_space", (brickProperties.getTotalSize() - brickProperties.getFreeSize()) * SizeConverter.BYTES_IN_MB).addValue("free_space", brickProperties.getFreeSize() * SizeConverter.BYTES_IN_MB).addValue("confirmed_free_space", confirmedFreeSize);
}
#end_block

#method_before
public double getConfirmedFreeSize() {
    return confirmedFreeSize;
}
#method_after
public Double getConfirmedFreeSize() {
    return confirmedFreeSize;
}
#end_block

#method_before
public void setConfirmedFreeSize(double confirmedFreeSize) {
    this.confirmedFreeSize = confirmedFreeSize;
}
#method_after
public void setConfirmedFreeSize(Double confirmedFreeSize) {
    this.confirmedFreeSize = confirmedFreeSize;
}
#end_block

#method_before
private Map<Guid, GlusterLocalVolumeInfo> getLocalVolumeInfo(Guid clusterId) {
    Map<Guid, GlusterLocalVolumeInfo> localVolumeInfoMap = new HashMap<>();
    for (VDS vds : vdsDao.getAllForCluster(clusterId)) {
        if (vds.getStatus() != VDSStatus.Up) {
            continue;
        }
        log.debug("Getting LVM/VDO information for the host {}", vds.getName());
        GlusterLocalVolumeInfo localVolumeInfo = new GlusterLocalVolumeInfo();
        VDSReturnValue logicalVolumesResult = runVdsCommand(VDSCommandType.GetGlusterLocalLogicalVolumeList, new VdsIdVDSCommandParametersBase(vds.getId()));
        if (logicalVolumesResult.getSucceeded()) {
            localVolumeInfo.setLogicalVolumes((List<GlusterLocalLogicalVolume>) logicalVolumesResult.getReturnValue());
        }
        VDSReturnValue physicalVolumesResult = runVdsCommand(VDSCommandType.GetGlusterLocalPhysicalVolumeList, new VdsIdVDSCommandParametersBase(vds.getId()));
        if (physicalVolumesResult.getSucceeded()) {
            localVolumeInfo.setPhysicalVolumes((List<GlusterLocalPhysicalVolume>) physicalVolumesResult.getReturnValue());
        }
        VDSReturnValue vdoVolumesResult = runVdsCommand(VDSCommandType.GetGlusterVDOVolumeList, new VdsIdVDSCommandParametersBase(vds.getId()));
        if (vdoVolumesResult.getSucceeded()) {
            localVolumeInfo.setVdoVolumes((List<GlusterVDOVolume>) vdoVolumesResult.getReturnValue());
        }
        localVolumeInfoMap.put(vds.getId(), localVolumeInfo);
    }
    return localVolumeInfoMap;
}
#method_after
private Map<Guid, GlusterLocalVolumeInfo> getLocalVolumeInfo(Guid clusterId) {
    Map<Guid, GlusterLocalVolumeInfo> localVolumeInfoMap = new HashMap<>();
    for (VDS vds : vdsDao.getAllForCluster(clusterId)) {
        if (vds.getStatus() != VDSStatus.Up) {
            continue;
        }
        try {
            log.debug("Getting LVM/VDO information for the host {}", vds.getName());
            GlusterLocalVolumeInfo localVolumeInfo = new GlusterLocalVolumeInfo();
            VDSReturnValue logicalVolumesResult = runVdsCommand(VDSCommandType.GetGlusterLocalLogicalVolumeList, new VdsIdVDSCommandParametersBase(vds.getId()));
            if (logicalVolumesResult.getSucceeded()) {
                localVolumeInfo.setLogicalVolumes((List<GlusterLocalLogicalVolume>) logicalVolumesResult.getReturnValue());
            }
            VDSReturnValue physicalVolumesResult = runVdsCommand(VDSCommandType.GetGlusterLocalPhysicalVolumeList, new VdsIdVDSCommandParametersBase(vds.getId()));
            if (physicalVolumesResult.getSucceeded()) {
                localVolumeInfo.setPhysicalVolumes((List<GlusterLocalPhysicalVolume>) physicalVolumesResult.getReturnValue());
            }
            VDSReturnValue vdoVolumesResult = runVdsCommand(VDSCommandType.GetGlusterVDOVolumeList, new VdsIdVDSCommandParametersBase(vds.getId()));
            if (vdoVolumesResult.getSucceeded()) {
                localVolumeInfo.setVdoVolumes((List<GlusterVDOVolume>) vdoVolumesResult.getReturnValue());
            }
            localVolumeInfoMap.put(vds.getId(), localVolumeInfo);
        } catch (Exception ex) {
            log.debug("Getting VDSM/VDO information failed at host {}, old vdsm?", vds.getName());
        }
    }
    return localVolumeInfoMap;
}
#end_block

#method_before
private void refreshBrickDetails(GlusterVolumeEntity volume, GlusterVolumeAdvancedDetails volumeAdvancedDetails, Map<Guid, GlusterLocalVolumeInfo> localVolumeInfo) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<>();
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            brickProperties.setConfirmedFreeSize(localVolumeInfo.get(brick.getServerId()).getThinSizeForDevice(brickProperties.getDevice()).map(Long::doubleValue).map(v -> v / 1048576).orElseGet(null));
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        brickDao.addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        brickDao.updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        brickDao.updateBrickStatuses(bricksToUpdate);
    }
}
#method_after
private void refreshBrickDetails(GlusterVolumeEntity volume, GlusterVolumeAdvancedDetails volumeAdvancedDetails, Map<Guid, GlusterLocalVolumeInfo> localVolumeInfo) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<>();
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            if (brickProperties.getDevice() != null) {
                brickProperties.setConfirmedFreeSize(localVolumeInfo.get(brick.getServerId()).getAvailableThinSizeForDevice(brickProperties.getDevice()).map(Long::doubleValue).map(v -> v / SizeConverter.BYTES_IN_MB).orElseGet(null));
            }
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        brickDao.addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        brickDao.updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        brickDao.updateBrickStatuses(bricksToUpdate);
    }
}
#end_block

#method_before
private Optional<Long> getLvmSizeForDevice(String device) {
    Optional<GlusterLocalLogicalVolume> thinVolume = logicalVolumes.stream().filter(lvmMatchMapperName(device)).filter(v -> !"".equals(v.getPoolName().trim())).findAny();
    thinVolume = thinVolume.flatMap(v -> logicalVolumes.stream().filter(lv -> v.getPoolName().equals(lv.getLogicalVolumeName())).findAny());
    Optional<Long> result = thinVolume.map(GlusterLocalLogicalVolume::getFree);
    List<String> physicalDevices = thinVolume.map(GlusterLocalLogicalVolume::getVolumeGroupName).map(v -> physicalVolumes.stream().filter(g -> g.getVolumeGroupName().equals(v)).map(GlusterLocalPhysicalVolume::getPhysicalVolumeName).collect(Collectors.toList())).orElseGet(Collections::emptyList);
    if (physicalDevices.size() != 1) {
        // We can not handle other number of physical devices
        return result;
    }
    Optional<Long> innerResult = getThinSizeForDevice(physicalDevices.get(0));
    if (innerResult.isPresent()) {
        result = result.map(s -> s > innerResult.get() ? innerResult.get() : s);
    }
    return result;
}
#method_after
private Optional<Long> getLvmSizeForDevice(String device) {
    Optional<GlusterLocalLogicalVolume> thinVolume = logicalVolumes.stream().filter(lvmMatchMapperName(device)).filter(v -> !v.getPoolName().trim().isEmpty()).findAny();
    thinVolume = thinVolume.flatMap(v -> logicalVolumes.stream().filter(lv -> v.getPoolName().equals(lv.getLogicalVolumeName())).findAny());
    Optional<Long> result = thinVolume.map(GlusterLocalLogicalVolume::getFree);
    List<String> physicalDevices = thinVolume.map(GlusterLocalLogicalVolume::getVolumeGroupName).map(v -> physicalVolumes.stream().filter(g -> g.getVolumeGroupName().equals(v)).map(GlusterLocalPhysicalVolume::getPhysicalVolumeName).collect(Collectors.toList())).orElseGet(Collections::emptyList);
    if (physicalDevices.size() != 1) {
        // We can not handle other number of physical devices
        return result;
    }
    Optional<Long> innerResult = getAvailableThinSizeForDevice(physicalDevices.get(0));
    if (innerResult.isPresent()) {
        result = result.map(s -> s > innerResult.get() ? innerResult.get() : s);
    }
    return result;
}
#end_block

#method_before
private Optional<Long> getVdoSizeForDevice(String device) {
    Optional<GlusterVDOVolume> vdoVolume = vdoVolumes.stream().filter(v -> device.equals(v.getName())).findAny();
    Optional<Long> result = vdoVolume.map(GlusterVDOVolume::getFree);
    Optional<Long> innerResult = vdoVolume.flatMap(v -> getThinSizeForDevice(v.getDevice()));
    if (innerResult.isPresent()) {
        result = result.map(s -> s > innerResult.get() ? innerResult.get() : s);
    }
    return result;
}
#method_after
private Optional<Long> getVdoSizeForDevice(String device) {
    Optional<GlusterVDOVolume> vdoVolume = vdoVolumes.stream().filter(v -> device.equals(v.getName())).findAny();
    Optional<Long> result = vdoVolume.map(GlusterVDOVolume::getFree);
    Optional<Long> innerResult = vdoVolume.flatMap(v -> getAvailableThinSizeForDevice(v.getDevice()));
    if (innerResult.isPresent()) {
        result = result.map(s -> s > innerResult.get() ? innerResult.get() : s);
    }
    return result;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    volumeInfo = new GlusterLocalVolumeInfo();
    volumeInfo.setLogicalVolumes(getLogicalVolumes());
    volumeInfo.setPhysicalVolumes(getPhysicalVolumes());
    volumeInfo.setVdoVolumes(getVDOVolumes());
}
#method_after
/*
        This test uses following disk layout:
        sdb
         |-sdb1 (PV)
            |- vg0 (VG)
                |- engine (LV)
                |- pool (Thin Pool)
                    |- iso (Thin LV)
                    |- vdobase (Thin LV)
                         |- vdodata (VDO, PV)
                              |- INTERNAL (VG)
                                   |- internal_pool (Thin Pool)
                                        |- vdoreplica (Thin LV)
                    |- vdosecond (Thin LV)
                         |- vdonext (VDO)
        sdc
         |- sdc1
             |- vdophysical (VDO)

     */
@Before
public void setUp() throws Exception {
    volumeInfo = new GlusterLocalVolumeInfo();
    volumeInfo.setLogicalVolumes(getLogicalVolumes());
    volumeInfo.setPhysicalVolumes(getPhysicalVolumes());
    volumeInfo.setVdoVolumes(getVDOVolumes());
}
#end_block

#method_before
@Test
public void testEmpty() {
    assertFalse(new GlusterLocalVolumeInfo().getThinSizeForDevice("/dev/sdc").isPresent());
}
#method_after
@Test
public void testEmpty() {
    assertFalse(new GlusterLocalVolumeInfo().getAvailableThinSizeForDevice("/dev/sdc").isPresent());
}
#end_block

#method_before
@Test
public void testNonLvm() {
    assertFalse(volumeInfo.getThinSizeForDevice("/dev/sdc").isPresent());
}
#method_after
@Test
public void testNonLvm() {
    assertFalse(volumeInfo.getAvailableThinSizeForDevice("/dev/sdc").isPresent());
}
#end_block

#method_before
@Test
public void testNonThinLvm() {
    assertFalse(volumeInfo.getThinSizeForDevice("/dev/mapper/vg0-engine").isPresent());
}
#method_after
@Test
public void testNonThinLvm() {
    assertFalse(volumeInfo.getAvailableThinSizeForDevice("/dev/mapper/vg0-engine").isPresent());
}
#end_block

#method_before
@Test
public void testThinLvm() {
    assertTrue(volumeInfo.getThinSizeForDevice("/dev/mapper/vg0-iso").isPresent());
    assertThat(volumeInfo.getThinSizeForDevice("/dev/mapper/vg0-iso").get(), is(19391777341L));
}
#method_after
@Test
public void testThinLvm() {
    assertTrue(volumeInfo.getAvailableThinSizeForDevice("/dev/mapper/vg0-iso").isPresent());
    assertThat(volumeInfo.getAvailableThinSizeForDevice("/dev/mapper/vg0-iso").get(), is(19391777341L));
}
#end_block

#method_before
@Test
public void testVdo() {
    assertTrue(volumeInfo.getThinSizeForDevice("/dev/mapper/vdophysical").isPresent());
    assertThat(volumeInfo.getThinSizeForDevice("/dev/mapper/vdophysical").get(), is(6483109092L));
}
#method_after
@Test
public void testVdo() {
    assertTrue(volumeInfo.getAvailableThinSizeForDevice("/dev/mapper/vdophysical").isPresent());
    assertThat(volumeInfo.getAvailableThinSizeForDevice("/dev/mapper/vdophysical").get(), is(6483109092L));
}
#end_block

#method_before
@Test
public void testThinLvmVdo() {
    assertTrue(volumeInfo.getThinSizeForDevice("/dev/mapper/vdonext").isPresent());
    assertThat(volumeInfo.getThinSizeForDevice("/dev/mapper/vdonext").get(), is(6438100992L));
}
#method_after
@Test
public void testThinLvmVdo() {
    assertTrue(volumeInfo.getAvailableThinSizeForDevice("/dev/mapper/vdonext").isPresent());
    assertThat(volumeInfo.getAvailableThinSizeForDevice("/dev/mapper/vdonext").get(), is(6438100992L));
}
#end_block

#method_before
@Test
public void testThinLvmVdoThinLvm() {
    assertTrue(volumeInfo.getThinSizeForDevice("/dev/mapper/INTERNAL-vdoreplica").isPresent());
    assertThat(volumeInfo.getThinSizeForDevice("/dev/mapper/INTERNAL-vdoreplica").get(), is(6415818752L));
}
#method_after
@Test
public void testThinLvmVdoThinLvm() {
    assertTrue(volumeInfo.getAvailableThinSizeForDevice("/dev/mapper/INTERNAL-vdoreplica").isPresent());
    assertThat(volumeInfo.getAvailableThinSizeForDevice("/dev/mapper/INTERNAL-vdoreplica").get(), is(6415818752L));
}
#end_block

#method_before
public DomainXmlListReturn dumpxmls(List<String> vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.dumpxmls").withOptionalParameterAsList("vmList", vmIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domxmls").withResponseType(Object[].class);
    return new DomainXmlListReturn(response);
}
#method_after
@Override
public DomainXmlListReturn dumpxmls(List<String> vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.dumpxmls").withOptionalParameterAsList("vmList", vmIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domxmls").withResponseType(Object[].class);
    return new DomainXmlListReturn(response);
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    mandatory(directory());
    optional(filename());
    or(mandatory(host().id()), mandatory(host().name()));
}
#method_after
@InputDetail
default void inputDetail() {
    or(mandatory(host().id()), mandatory(host().name()));
    mandatory(directory());
    optional(filename());
}
#end_block

#method_before
public DomainXmlListReturn dumpxmls(List<String> vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.dumpxmls").withOptionalParameterAsList("vmList", vmIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domxmls").withResponseType(Object[].class);
    return new DomainXmlListReturn(response);
}
#method_after
@Override
public DomainXmlListReturn dumpxmls(List<String> vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.dumpxmls").withOptionalParameterAsList("vmList", vmIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domxmls").withResponseType(Object[].class);
    return new DomainXmlListReturn(response);
}
#end_block

#method_before
public Long getSize() {
    return size;
}
#method_after
public long getSize() {
    return size;
}
#end_block

#method_before
public Long getFree() {
    return free;
}
#method_after
public long getFree() {
    return free;
}
#end_block

#method_before
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    Guid cmdId = command.getCommandId();
    if (status == CommandExecutionStatus.EXECUTED) {
        SerialChildExecutingCommand serialChildExecutingCommand = (SerialChildExecutingCommand) command;
        if (!anyFailed || serialChildExecutingCommand.ignoreChildCommandFailure()) {
            try {
                boolean endCommand = !serialChildExecutingCommand.performNextOperation(completedChildren);
                if (!endCommand) {
                    return;
                }
            } catch (Exception e) {
                log.error("Command '{}' id: '{}' failed when attempting to perform the next operation, marking as FAILED '{}'", command.getActionType(), cmdId, childCmdIds, command.getCommandStatus(), e);
                serialChildExecutingCommand.handleFailure();
                anyFailed = true;
            }
        } else {
            serialChildExecutingCommand.handleFailure();
        }
    } else {
        log.info("Command '{}' id: '{}' execution didn't complete, not proceeding to perform the next operation", command.getActionType(), cmdId);
    }
    setCommandEndStatus(command, anyFailed, status, childCmdIds);
}
#method_after
@Override
protected void childCommandsExecutionEnded(CommandBase<?> command, boolean anyFailed, List<Guid> childCmdIds, CommandExecutionStatus status, int completedChildren) {
    Guid cmdId = command.getCommandId();
    if (status == CommandExecutionStatus.EXECUTED) {
        SerialChildExecutingCommand serialChildExecutingCommand = (SerialChildExecutingCommand) command;
        if (!anyFailed || serialChildExecutingCommand.ignoreChildCommandFailure()) {
            try {
                boolean endCommand = !serialChildExecutingCommand.performNextOperation(completedChildren);
                if (!endCommand) {
                    return;
                }
            } catch (Exception e) {
                log.error("Command '{}' id: '{}' with children {} failed when attempting to perform the next operation, marking as '{}'", command.getActionType(), cmdId, childCmdIds, command.getCommandStatus());
                log.error(e.getMessage(), e);
                serialChildExecutingCommand.handleFailure();
                anyFailed = true;
            }
        } else {
            serialChildExecutingCommand.handleFailure();
        }
    } else {
        log.info("Command '{}' id: '{}' execution didn't complete, not proceeding to perform the next operation", command.getActionType(), cmdId);
    }
    setCommandEndStatus(command, anyFailed, status, childCmdIds);
}
#end_block

#method_before
public boolean hasDnsServers() {
    return getDnsServers() != null && getDnsServers().length() > 0;
}
#method_after
public boolean hasDnsServers() {
    return getDnsServers() != null && !getDnsServers().isEmpty();
}
#end_block

#method_before
public boolean hasDnsSearch() {
    return getDnsSearch() != null && getDnsSearch().length() > 0;
}
#method_after
public boolean hasDnsSearch() {
    return getDnsSearch() != null && !getDnsSearch().isEmpty();
}
#end_block

#method_before
public ValidationResult notLinkedToExternalNetwork() {
    List<Network> linkedExternalNetworks = getNetworkDao().getAllExternalNetworksLikedToPhysicalNetwork(network.getId());
    String linkedExternalNetworkNames = linkedExternalNetworks.stream().map(Network::getName).collect(joining(","));
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_PHYSICAL_NETWORK_LINKED_TO_EXTERNAL_NETWORK, ReplacementUtils.createSetVariableString(NETWORK_LIST_REPLACEMENT, linkedExternalNetworkNames)).when(!linkedExternalNetworks.isEmpty());
}
#method_after
public ValidationResult notLinkedToExternalNetwork() {
    List<Network> linkedExternalNetworks = getNetworkDao().getAllExternalNetworksLinkedToPhysicalNetwork(network.getId());
    String linkedExternalNetworkNames = linkedExternalNetworks.stream().map(Network::getName).collect(joining(", "));
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_PHYSICAL_NETWORK_LINKED_TO_EXTERNAL_NETWORK, ReplacementUtils.createSetVariableString(NETWORK_LIST_REPLACEMENT, linkedExternalNetworkNames)).when(!linkedExternalNetworks.isEmpty());
}
#end_block

#method_before
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(LockProperties.Scope.Execution);
}
#method_after
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(LockProperties.Scope.Execution).withWait(true);
}
#end_block

#method_before
@Before
public void setUp() {
    cluster = new Cluster();
    physicalNetwork = new Network();
    setUpPhysicalNetwork(true, true);
    setUpCluster(true, true);
    when(networkDao.get(PHYSICAL_NETWORK_ID)).thenReturn(physicalNetwork);
    when(networkClusterDao.getAllForNetwork(PHYSICAL_NETWORK_ID)).thenReturn(createNetworkClusters());
    when(clusterDao.get(CLUSTER_ID)).thenReturn(cluster);
}
#method_after
@Before
public void setUp() {
    cluster = new Cluster();
    physicalNetwork = new Network();
    setUpPhysicalNetwork(HAS_SHORT_NAME, IS_VM_NETWORK);
    setUpCluster(IS_CLUSTER_SWITCH_OVS, HAS_CLUSTER_VALID_PROVIDER);
    ActionReturnValue actionReturnValue = new ActionReturnValue();
    actionReturnValue.setSucceeded(true);
    actionReturnValue.setActionReturnValue(EXTERNAL_NETWORK_ID);
    when(networkDao.get(PHYSICAL_NETWORK_ID)).thenReturn(physicalNetwork);
    when(networkClusterDao.getAllForNetwork(PHYSICAL_NETWORK_ID)).thenReturn(createNetworkClusters());
    when(clusterDao.get(CLUSTER_ID)).thenReturn(cluster);
    when(backend.runInternalAction(eq(ActionType.AddNetworkOnProvider), any(), any())).thenReturn(actionReturnValue);
    doReturn(engineLock).when(command).acquireLockForProvider(eq(CLUSTER_DEFAULT_PROVIDER_ID));
    doNothing().when(engineLock).close();
}
#end_block

#method_before
@Test
public void testCommandSuccessLongName() {
    setUpPhysicalNetwork(false, true);
    command.executeCommand();
    verify(backend).runInternalAction(eq(ActionType.AddNetworkOnProvider), any(), any());
}
#method_after
@Test
public void testCommandSuccessLongName() {
    setUpPhysicalNetwork(!HAS_SHORT_NAME, IS_VM_NETWORK);
    command.executeCommand();
    verify(backend).runInternalAction(eq(ActionType.AddNetworkOnProvider), any(), any());
    verify(networkHelper).createNetworkClusters(eq(Collections.singletonList(CLUSTER_ID)));
}
#end_block

#method_before
@Test
public void testCommandNonVmNetwork() {
    setUpPhysicalNetwork(true, false);
    physicalNetwork.setVmNetwork(false);
    command.executeCommand();
    verify(backend, never()).runInternalAction(eq(ActionType.AddNetworkOnProvider), any(), any());
}
#method_after
@Test
public void testCommandNonVmNetwork() {
    setUpPhysicalNetwork(HAS_SHORT_NAME, !IS_VM_NETWORK);
    Assert.assertFalse(command.validate());
    Assert.assertTrue(command.getReturnValue().getValidationMessages().contains(EngineMessage.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK.name()));
}
#end_block

#method_before
@Test
public void testCommandSuccess() {
    setUpPhysicalNetwork(true, true);
    command.executeCommand();
    verify(backend).runInternalAction(eq(ActionType.AddNetworkOnProvider), any(), any());
}
#method_after
@Test
public void testCommandSuccess() {
    setUpPhysicalNetwork(HAS_SHORT_NAME, IS_VM_NETWORK);
    command.executeCommand();
    verify(backend).runInternalAction(eq(ActionType.AddNetworkOnProvider), any(), any());
    verify(networkHelper).createNetworkClusters(eq(Collections.singletonList(CLUSTER_ID)));
}
#end_block

#method_before
@Test
public void testCommandWrongSwitchType() {
    setUpCluster(false, true);
    command.executeCommand();
    verify(backend, never()).runInternalAction(eq(ActionType.AddNetworkOnProvider), any(), any());
}
#method_after
@Test
public void testCommandWrongSwitchType() {
    setUpCluster(!IS_CLUSTER_SWITCH_OVS, HAS_CLUSTER_VALID_PROVIDER);
    command.executeCommand();
    verify(backend, never()).runInternalAction(eq(ActionType.AddNetworkOnProvider), any(), any());
}
#end_block

#method_before
@Test
public void testCommandInvalidProviderId() {
    setUpCluster(true, false);
    command.executeCommand();
    verify(backend, never()).runInternalAction(eq(ActionType.AddNetworkOnProvider), any(), any());
    verify(auditLogDirector).log(any(), eq(AuditLogType.NETWORK_AUTO_DEFINE_INVALID_EXTERNAL_PROVIDER));
}
#method_after
@Test
public void testCommandInvalidProviderId() {
    setUpCluster(IS_CLUSTER_SWITCH_OVS, !HAS_CLUSTER_VALID_PROVIDER);
    command.executeCommand();
    verify(backend, never()).runInternalAction(eq(ActionType.AddNetworkOnProvider), any(), any());
}
#end_block

#method_before
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Execution);
}
#method_after
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Execution).withWait(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getNetwork().setId(Guid.newGuid());
    NetworkUtils.setNetworkVdsmName(getNetwork());
    TransactionSupport.executeInNewTransaction(() -> {
        networkDao.save(getNetwork());
        if (getNetwork().isVmNetwork() && getParameters().isVnicProfileRequired()) {
            vnicProfileDao.save(networkHelper.createVnicProfile(getNetwork()));
        }
        networkHelper.addPermissionsOnNetwork(getUserId(), getNetwork().getId());
        return null;
    });
    Guid networkId = getNetwork().getId();
    List<NetworkCluster> networkAttachments = getParameters().getNetworkClusterList();
    boolean clusterAttachmentsSucceeded = true;
    if (networkAttachments != null) {
        clusterAttachmentsSucceeded = attachToClusters(networkAttachments).getSucceeded();
    }
    runInternalAction(ActionType.AutodefineExternalNetwork, new IdParameters(networkId));
    getReturnValue().setActionReturnValue(clusterAttachmentsSucceeded ? networkId : null);
    setSucceeded(clusterAttachmentsSucceeded);
}
#method_after
@Override
protected void executeCommand() {
    getNetwork().setId(Guid.newGuid());
    NetworkUtils.setNetworkVdsmName(getNetwork());
    TransactionSupport.executeInNewTransaction(() -> {
        networkDao.save(getNetwork());
        networkHelper.addPermissionsOnNetwork(getUserId(), getNetwork().getId());
        return null;
    });
    // Run cluster attachment, AddVnicProfile and  auto-define in separated thread
    CompletableFuture.runAsync(this::runClusterAttachment, ThreadPoolUtil.getExecutorService()).thenRunAsync(this::runAddVnicProfile).thenRunAsync(this::runAutodefine);
    getReturnValue().setActionReturnValue(getNetwork().getId());
    setSucceeded(true);
}
#end_block

#method_before
private ActionReturnValue attachToClusters(List<NetworkCluster> networkAttachments) {
    networkAttachments.forEach(networkCluster -> networkCluster.setNetworkId(getNetwork().getId()));
    return runInternalAction(ActionType.ManageNetworkClusters, new ManageNetworkClustersParameters(networkAttachments));
}
#method_after
private void attachToClusters(List<NetworkCluster> networkAttachments, Guid networkId) {
    networkAttachments.forEach(networkCluster -> networkCluster.setNetworkId(networkId));
    runInternalAction(ActionType.ManageNetworkClusters, new ManageNetworkClustersParameters(networkAttachments), getContext().clone().withoutLock());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (isOperationAllowed()) {
        List<Cluster> clusters = getClustersWithOvsSwitchType(getNetwork().getId());
        checkValidDefaultProvider(clusters);
        List<Cluster> clustersWithOVS = getClustersWithValidDefaultProvider(clusters);
        createListOfClustersByProvider(clustersWithOVS);
        List<Guid> providerIds = new ArrayList<>(listOfClustersByProvider.keySet());
        IntStream.range(0, providerIds.size()).forEach(i -> runAutodefineForOneProvider(providerIds.get(i), i));
    }
    // The operation has to succeed every time to prevent trigger of transactional rollback
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<Cluster> clustersWithOvs = getClustersWithOvsSwitchType(getNetwork().getId());
    logInvalidDefaultProvider(clustersWithOvs);
    List<Cluster> clustersWithProvider = getClustersWithValidDefaultProvider(clustersWithOvs);
    createListOfClustersByProvider(clustersWithProvider);
    List<Guid> providerIds = new ArrayList<>(clustersByProvider.keySet());
    IntStream.range(0, providerIds.size()).forEach(i -> runAutodefineForOneProvider(providerIds.get(i), i));
    // The operation has to succeed every time to prevent trigger of transactional rollback
    setSucceeded(true);
}
#end_block

#method_before
private List<Cluster> getClustersWithOvsSwitchType(Guid networkId) {
    List<NetworkCluster> physicalNetworkClusters = networkClusterDao.getAllForNetwork(networkId);
    return physicalNetworkClusters.stream().map(networkCluster -> clusterDao.get(networkCluster.getClusterId())).filter(cluster -> cluster.getRequiredSwitchTypeForCluster().equals(SwitchType.OVS)).collect(Collectors.toList());
}
#method_after
private List<Cluster> getClustersWithOvsSwitchType(Guid networkId) {
    List<NetworkCluster> physicalNetworkClusters = networkClusterDao.getAllForNetwork(networkId);
    return physicalNetworkClusters.stream().map(networkCluster -> clusterDao.get(networkCluster.getClusterId())).filter(cluster -> cluster.hasRequiredSwitchType(SwitchType.OVS)).collect(Collectors.toList());
}
#end_block

#method_before
private List<Guid> getClusterIdsFilteredByProviderId(List<Cluster> clusters, Guid providerId) {
    return clusters.stream().filter(cluster -> Objects.equals(providerId, cluster.getDefaultNetworkProviderId())).map(Cluster::getId).collect(Collectors.toList());
}
#method_after
private List<Guid> getClusterIdsFilteredByProviderId(List<Cluster> clusters, Guid providerId) {
    return clusters.stream().filter(cluster -> cluster.hasDefaultNetworkProviderId(providerId)).map(Cluster::getId).collect(Collectors.toList());
}
#end_block

#method_before
private List<Cluster> getClustersWithValidDefaultProvider(List<Cluster> clusters) {
    return clusters.stream().filter(cluster -> Objects.nonNull(cluster.getDefaultNetworkProviderId())).collect(Collectors.toList());
}
#method_after
private List<Cluster> getClustersWithValidDefaultProvider(List<Cluster> clusters) {
    return clusters.stream().filter(Cluster::isSetDefaultNetworkProviderId).collect(Collectors.toList());
}
#end_block

#method_before
private void createListOfClustersByProvider(List<Cluster> clusters) {
    listOfClustersByProvider = new HashMap<>();
    clusters.stream().map(Cluster::getDefaultNetworkProviderId).distinct().forEach(providerId -> listOfClustersByProvider.put(providerId, getClusterIdsFilteredByProviderId(clusters, providerId)));
}
#method_after
private void createListOfClustersByProvider(List<Cluster> clusters) {
    clustersByProvider = clusters.stream().map(Cluster::getDefaultNetworkProviderId).distinct().collect(Collectors.toMap(providerId -> providerId, providerId -> getClusterIdsFilteredByProviderId(clusters, providerId)));
}
#end_block

#method_before
private void runAutodefineForOneProvider(Guid providerId, int index) {
    Network externalNetwork = createExternalNetwork(getNetworkName(index), providerId, EXTERNAL_DESCRIPTION);
    AddNetworkStoragePoolParameters storagePoolParameters = new AddNetworkStoragePoolParameters(getNetwork().getStoragePoolId(), externalNetwork);
    storagePoolParameters.setNetworkClusterList(createNetworkClusters(listOfClustersByProvider.get(providerId)));
    runInternalAction(ActionType.AddNetworkOnProvider, storagePoolParameters);
}
#method_after
private void runAutodefineForOneProvider(Guid providerId, int index) {
    try (EngineLock lock = acquireLockForProvider(providerId)) {
        Network externalNetwork = createExternalNetwork(calcExternalNetworkName(index), providerId);
        AddNetworkStoragePoolParameters storagePoolParameters = new AddNetworkStoragePoolParameters(getNetwork().getStoragePoolId(), externalNetwork);
        storagePoolParameters.setNetworkClusterList(networkHelper.createNetworkClusters(clustersByProvider.get(providerId)));
        storagePoolParameters.setVnicProfilePublicUse(false);
        runInternalAction(ActionType.AddNetworkOnProvider, storagePoolParameters);
    }
}
#end_block

#method_before
private Network createExternalNetwork(String name, Guid providerId, String description) {
    final Network network = getNetwork();
    Network externalNetwork = new Network();
    externalNetwork.setName(name);
    externalNetwork.setDescription(description);
    externalNetwork.setDataCenterId(network.getDataCenterId());
    ProviderNetwork providerNetwork = new ProviderNetwork();
    providerNetwork.setProviderId(providerId);
    providerNetwork.setPhysicalNetworkId(network.getId());
    externalNetwork.setProvidedBy(providerNetwork);
    return externalNetwork;
}
#method_after
private Network createExternalNetwork(String name, Guid providerId) {
    final Network network = getNetwork();
    Network externalNetwork = new Network();
    externalNetwork.setName(name);
    externalNetwork.setDescription(EXTERNAL_DESCRIPTION);
    externalNetwork.setDataCenterId(network.getDataCenterId());
    ProviderNetwork providerNetwork = new ProviderNetwork();
    providerNetwork.setProviderId(providerId);
    providerNetwork.setPhysicalNetworkId(network.getId());
    externalNetwork.setProvidedBy(providerNetwork);
    return externalNetwork;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    oldMacPool = macPoolDao.get(getMacPoolId());
    return validate(new MacPoolValidator(oldMacPool).macPoolExists()) && validate(new MacPoolValidator(getMacPoolEntity()).hasUniqueName()) && validate(validateDefaultFlagIsNotChanged(oldMacPool, getMacPoolEntity())) && validate(validateDuplicatesConfiguration());
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    oldMacPool = macPoolDao.get(getMacPoolId());
    MacPoolValidator validator = new MacPoolValidator(getMacPoolEntity());
    return validate(new MacPoolValidator(oldMacPool).macPoolExists()) && validate(validator.hasUniqueName()) && validate(validator.validateDuplicates(macPoolPerCluster)) && validate(validateDefaultFlagIsNotChanged(oldMacPool, getMacPoolEntity()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    registerRollbackHandler((TransactionRollbackListener) () -> TransactionSupport.executeInNewTransaction((TransactionMethod<Void>) () -> {
        macPoolPerCluster.createPool(oldMacPool);
        return null;
    }));
    macPoolDao.update(getMacPoolEntity());
    macPoolPerCluster.modifyPool(getMacPoolEntity());
    setSucceeded(true);
    getReturnValue().setActionReturnValue(getMacPoolId());
}
#method_after
@Override
protected void executeCommand() {
    registerRollbackHandler((TransactionRollbackListener) () -> macPoolPerCluster.modifyPool(oldMacPool));
    macPoolDao.update(getMacPoolEntity());
    macPoolPerCluster.modifyPool(getMacPoolEntity());
    setSucceeded(true);
    getReturnValue().setActionReturnValue(getMacPoolId());
}
#end_block

#method_before
void initialize(boolean engineStartup, List<String> macsForMacPool) {
    log.info("Initializing {}", this);
    this.macsStorage = createMacsStorage(this.rangesBoundaries);
    log.debug("Initializing {} with macs: {}", this, macsForMacPool);
    List<String> notAddedMacs = addMacs(macsForMacPool);
    if (!notAddedMacs.isEmpty()) {
        if (engineStartup) {
            String auditLogMessage = "Following MACs violates duplicity restriction, and was pushed into MAC pool without respect to it:" + notAddedMacs;
            auditLogDirector.log(new AuditLogableImpl(), AuditLogType.MAC_ADDRESS_VIOLATES_NO_DUPLICATES_SETTING, auditLogMessage);
            forceAddMacs(notAddedMacs);
        } else {
            throw new EngineException(EngineError.MAC_POOL_INITIALIZATION_FAILED, UNABLE_TO_INITIALIZE_MAC_POOL_DUE_TO_EXISTING_DUPLICATES);
        }
    }
    log.info("Finished initializing {}. Available MACs in pool: {}", this, macsStorage.getAvailableMacsCount());
}
#method_after
void initialize(boolean engineStartup, List<String> macsForMacPool) {
    log.info("Initializing {}", this);
    this.macsStorage = createMacsStorage(this.rangesBoundaries);
    log.debug("Initializing {} with macs: {}", this, macsForMacPool);
    List<String> notAddedMacs = addMacs(macsForMacPool);
    if (!notAddedMacs.isEmpty()) {
        if (engineStartup) {
            String auditLogMessage = "Following MACs violates duplicity restriction, and was pushed into MAC pool without respect to it:" + notAddedMacs;
            auditLogDirector.log(new AuditLogableImpl(), AuditLogType.MAC_ADDRESS_VIOLATES_NO_DUPLICATES_SETTING, auditLogMessage);
            forceAddMacs(notAddedMacs);
        } else {
            throw new EngineException(EngineError.MAC_POOL_INITIALIZATION_FAILED, "Unable to initialize MAC pool due to existing duplicates");
        }
    }
    log.info("Finished initializing {}. Available MACs in pool: {}", this, macsStorage.getAvailableMacsCount());
}
#end_block

#method_before
private ActionReturnValue addNetwork(Guid dataCenterId, Network network, boolean attachToAllClusters) {
    AddNetworkStoragePoolParameters params = new AddNetworkStoragePoolParameters(dataCenterId, network);
    if (attachToAllClusters) {
        params.setNetworkClusterList(networkHelper.createNetworkClusters(getAllClusterIdsInDataCenter(dataCenterId)));
    }
    return runInternalAction(ActionType.AddNetwork, params);
}
#method_after
private ActionReturnValue addNetwork(Guid dataCenterId, Network network, boolean attachToAllClusters) {
    AddNetworkStoragePoolParameters params = new AddNetworkStoragePoolParameters(dataCenterId, network);
    params.setVnicProfilePublicUse(getParameters().isPublicUse());
    if (attachToAllClusters) {
        params.setNetworkClusterList(networkHelper.createNetworkClusters(getAllClusterIdsInDataCenter(dataCenterId)));
    }
    return runInternalAction(ActionType.AddNetwork, params);
}
#end_block

#method_before
public VnicProfile createVnicProfile(Network net) {
    VnicProfile profile = new VnicProfile();
    profile.setId(Guid.newGuid());
    profile.setName(net.getName());
    profile.setNetworkId(net.getId());
    profile.setPortMirroring(false);
    NetworkFilter defaultNetworkFilter = resolveVnicProfileDefaultNetworkFilter();
    profile.setNetworkFilterId(defaultNetworkFilter == null ? null : defaultNetworkFilter.getId());
    return profile;
}
#method_after
public VnicProfile createVnicProfile(Network net) {
    VnicProfile profile = new VnicProfile();
    profile.setId(Guid.newGuid());
    profile.setName(net.getName());
    profile.setNetworkId(net.getId());
    profile.setPortMirroring(false);
    if (!net.isExternal()) {
        NetworkFilter defaultNetworkFilter = resolveVnicProfileDefaultNetworkFilter();
        profile.setNetworkFilterId(defaultNetworkFilter == null ? null : defaultNetworkFilter.getId());
    }
    return profile;
}
#end_block

#method_before
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Execution);
}
#method_after
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Execution).withWait(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getNetwork().setId(Guid.newGuid());
    NetworkUtils.setNetworkVdsmName(getNetwork());
    TransactionSupport.executeInNewTransaction(() -> {
        networkDao.save(getNetwork());
        if (getNetwork().isVmNetwork() && getParameters().isVnicProfileRequired()) {
            createVnicProfile();
        }
        networkHelper.addPermissionsOnNetwork(getUserId(), getNetwork().getId());
        return null;
    });
    runClusterAttachment();
    getReturnValue().setActionReturnValue(getNetwork().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getNetwork().setId(Guid.newGuid());
    NetworkUtils.setNetworkVdsmName(getNetwork());
    TransactionSupport.executeInNewTransaction(() -> {
        networkDao.save(getNetwork());
        networkHelper.addPermissionsOnNetwork(getUserId(), getNetwork().getId());
        return null;
    });
    // Run cluster attachment and AddVnicProfile in separated thread
    CompletableFuture.runAsync(this::runClusterAttachment, ThreadPoolUtil.getExecutorService()).thenRunAsync(this::runAddVnicProfile);
    getReturnValue().setActionReturnValue(getNetwork().getId());
    setSucceeded(true);
}
#end_block

#method_before
private void runClusterAttachment() {
    List<NetworkCluster> networkAttachments = getParameters().getNetworkClusterList();
    if (networkAttachments != null) {
        ThreadPoolUtil.execute(() -> attachToClusters(networkAttachments, getNetwork().getId()));
    }
}
#method_after
private void runClusterAttachment() {
    List<NetworkCluster> networkAttachments = getParameters().getNetworkClusterList();
    if (networkAttachments != null) {
        attachToClusters(networkAttachments, getNetwork().getId());
    }
}
#end_block

#method_before
@SuppressWarnings("incomplete-switch")
private void writeCpu(boolean addVmNumaNodes) {
    writer.writeStartElement("cpu");
    String cpuType = vm.getCpuName();
    if (vm.isUseHostCpuFlags()) {
        cpuType = "hostPassthrough";
    }
    switch(vm.getClusterArch().getFamily()) {
        case x86:
            writer.writeAttributeString("match", "exact");
            // is this a list of strings??..
            switch(cpuType) {
                case "hostPassthrough":
                    writer.writeAttributeString("mode", "host-passthrough");
                    break;
                case "hostModel":
                    writer.writeAttributeString("mode", "host-model");
                    break;
                default:
                    writer.writeStartElement("model");
                    writer.writeRaw(cpuType);
                    // TODO: features
                    writer.writeEndElement();
                    break;
            }
            break;
        case ppc:
            writer.writeAttributeString("mode", "host-model");
            writer.writeElement("model", "power8");
    }
    if ((boolean) Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        writer.writeStartElement("topology");
        writer.writeAttributeString("cores", Integer.toString(vm.getCpuPerSocket()));
        writer.writeAttributeString("threads", Integer.toString(vm.getThreadsPerCpu()));
        int vcpus = FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch()) ? VmCpuCountHelper.calcMaxVCpu(vm, vm.getClusterCompatibilityVersion()) : vm.getNumOfCpus();
        writer.writeAttributeString("sockets", String.valueOf(vcpus / vm.getCpuPerSocket() / vm.getThreadsPerCpu()));
        writer.writeEndElement();
    }
    if (addVmNumaNodes) {
        writer.writeStartElement("numa");
        NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodesSupplier.get()).forEach(vmNumaNode -> {
            writer.writeStartElement("cell");
            writer.writeAttributeString("cpus", vmNumaNode.get(VdsProperties.NUMA_NODE_CPU_LIST).toString());
            writer.writeAttributeString("memory", String.valueOf(Integer.parseInt((String) vmNumaNode.get(VdsProperties.VM_NUMA_NODE_MEM)) * 1024));
            if (HugePageUtils.isHugepagesShared(vm.getStaticData())) {
                writer.writeAttributeString("memAccess", "shared");
            }
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
@SuppressWarnings("incomplete-switch")
private void writeCpu(boolean addVmNumaNodes) {
    writer.writeStartElement("cpu");
    String cpuType = vm.getCpuName();
    if (vm.isUseHostCpuFlags()) {
        cpuType = "hostPassthrough";
    }
    switch(vm.getClusterArch().getFamily()) {
        case x86:
            writer.writeAttributeString("match", "exact");
            // is this a list of strings??..
            switch(cpuType) {
                case "hostPassthrough":
                    writer.writeAttributeString("mode", "host-passthrough");
                    break;
                case "hostModel":
                    writer.writeAttributeString("mode", "host-model");
                    break;
                default:
                    writer.writeStartElement("model");
                    writer.writeRaw(cpuType);
                    // TODO: features
                    writer.writeEndElement();
                    break;
            }
            break;
        case ppc:
            writer.writeAttributeString("mode", "host-model");
            writer.writeStartElement("model");
            // needs to be lowercase for libvirt
            writer.writeRaw(cpuType.toLowerCase());
            writer.writeEndElement();
    }
    if ((boolean) Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        writer.writeStartElement("topology");
        writer.writeAttributeString("cores", Integer.toString(vm.getCpuPerSocket()));
        writer.writeAttributeString("threads", Integer.toString(vm.getThreadsPerCpu()));
        int vcpus = FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch()) ? VmCpuCountHelper.calcMaxVCpu(vm, vm.getClusterCompatibilityVersion()) : vm.getNumOfCpus();
        writer.writeAttributeString("sockets", String.valueOf(vcpus / vm.getCpuPerSocket() / vm.getThreadsPerCpu()));
        writer.writeEndElement();
    }
    if (addVmNumaNodes) {
        writer.writeStartElement("numa");
        NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodesSupplier.get()).forEach(vmNumaNode -> {
            writer.writeStartElement("cell");
            writer.writeAttributeString("id", vmNumaNode.get(VdsProperties.NUMA_NODE_INDEX).toString());
            writer.writeAttributeString("cpus", vmNumaNode.get(VdsProperties.NUMA_NODE_CPU_LIST).toString());
            writer.writeAttributeString("memory", String.valueOf(Integer.parseInt((String) vmNumaNode.get(VdsProperties.VM_NUMA_NODE_MEM)) * 1024));
            if (HugePageUtils.isHugepagesShared(vm.getStaticData())) {
                writer.writeAttributeString("memAccess", "shared");
            }
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private List<VmDevice> overrideDevicesForRunOnce(List<VmDevice> devices) {
    if (!vm.isRunOnce()) {
        return devices;
    }
    // video device handling
    DisplayType displayType = vm.getDefaultDisplayType();
    if (displayType != null) {
        // remove existing video device
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.VIDEO).collect(Collectors.toList());
        // add new video device
        if (displayType != DisplayType.none) {
            devices.add(vmInfoBuildUtils.createVideoDeviceByDisplayType(displayType, vm.getId()));
        }
    }
    // graphics device handling
    if (displayType == DisplayType.none || (vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty())) {
        // remove existing graphics devices
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.GRAPHICS).collect(Collectors.toList());
        if (displayType != DisplayType.none) {
            // add new graphics devices
            Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
            Map<String, Object> specParamsFromVm = new HashMap<>();
            vmInfoBuildUtils.addVmGraphicsOptions(infos, specParamsFromVm, vm);
            devices.addAll(vmInfoBuildUtils.createGraphicsDevices(infos, specParamsFromVm, vm.getId()));
        }
    }
    // the user may specify floppy path while there is no device in the database
    if (!StringUtils.isEmpty(vm.getFloppyPath()) && !devices.stream().anyMatch(dev -> dev.getDevice().equals(VmDeviceType.FLOPPY.getName()))) {
        devices.add(vmInfoBuildUtils.createFloppyDevice(vm));
    }
    return devices;
}
#method_after
private List<VmDevice> overrideDevicesForRunOnce(List<VmDevice> devices) {
    if (!vm.isRunOnce()) {
        return devices;
    }
    // video device handling
    DisplayType displayType = vm.getDefaultDisplayType();
    if (displayType != null) {
        // remove existing video device
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.VIDEO).collect(Collectors.toList());
        // add new video device
        if (displayType != DisplayType.none) {
            devices.add(vmInfoBuildUtils.createVideoDeviceByDisplayType(displayType, vm.getId()));
        }
    }
    // graphics device handling
    if (displayType == DisplayType.none || (vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty())) {
        // remove existing graphics devices
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.GRAPHICS).collect(Collectors.toList());
        if (displayType != DisplayType.none) {
            // add new graphics devices
            Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
            Map<String, Object> specParamsFromVm = new HashMap<>();
            vmInfoBuildUtils.addVmGraphicsOptions(infos, specParamsFromVm, vm);
            devices.addAll(vmInfoBuildUtils.createGraphicsDevices(infos, specParamsFromVm, vm.getId()));
        }
    }
    // the user may specify floppy path while there is no device in the database
    if (!StringUtils.isEmpty(vm.getFloppyPath()) && devices.stream().noneMatch(dev -> dev.getDevice().equals(VmDeviceType.FLOPPY.getName()))) {
        devices.add(vmInfoBuildUtils.createFloppyDevice(vm));
    }
    return devices;
}
#end_block

#method_before
private void writeDisks(List<VmDevice> devices) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    int ideIndex = -1;
    int scsiIndex = -1;
    int virtioIndex = -1;
    int pinnedDriveIndex = 0;
    Map<Disk, VmDevice> vmDisksToDevices = vm.getDiskMap().values().stream().map(d -> new Pair<>(d, deviceIdToDevice.get(new VmDeviceId(d.getId(), vm.getId())))).filter(p -> p.getSecond() != null && p.getSecond().isManaged()).collect(Collectors.toMap(Pair::getFirst, Pair::getSecond));
    for (Entry<Disk, VmDevice> diskAndDevice : vmInfoBuildUtils.getSortedDisks(vmDisksToDevices, vm.getId())) {
        Disk disk = diskAndDevice.getKey();
        VmDevice device = diskAndDevice.getValue();
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        DiskInterface diskInterface = dve.getDiskInterface();
        int index = 0;
        int pinTo = 0;
        switch(diskInterface) {
            case IDE:
                ideIndex++;
                if (diskInterface.getName().equals(cdInterface)) {
                    while (ideIndex == payloadIndex || ideIndex == cdRomIndex) {
                        ideIndex++;
                    }
                }
                index = ideIndex;
                break;
            case VirtIO:
                pinTo = vmInfoBuildUtils.pinToIoThreads(vm, pinnedDriveIndex++);
                virtioIndex++;
                if (diskInterface.getName().equals(cdInterface)) {
                    while (virtioIndex == payloadIndex || virtioIndex == cdRomIndex) {
                        virtioIndex++;
                    }
                }
                index = virtioIndex;
                break;
            case SPAPR_VSCSI:
            case VirtIO_SCSI:
                scsiIndex++;
                if (diskInterface.getName().equals(cdInterface)) {
                    while (scsiIndex == payloadIndex || scsiIndex == cdRomIndex) {
                        scsiIndex++;
                    }
                }
                index = scsiIndex;
                vmInfoBuildUtils.calculateAddressForScsiDisk(vm, disk, device, vmDeviceSpaprVscsiUnitMap, vmDeviceVirtioScsiUnitMap);
                break;
        }
        String dev = vmInfoBuildUtils.makeDiskName(dve.getDiskInterface().getName(), index);
        writeDisk(device, disk, dve, dev, pinTo);
    }
}
#method_after
private void writeDisks(List<VmDevice> devices) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    int hdIndex = -1;
    int sdIndex = -1;
    int vdIndex = -1;
    int pinnedDriveIndex = 0;
    Map<Disk, VmDevice> vmDisksToDevices = vm.getDiskMap().values().stream().map(d -> new Pair<>(d, deviceIdToDevice.get(new VmDeviceId(d.getId(), vm.getId())))).filter(p -> p.getSecond() != null && p.getSecond().isManaged()).collect(Collectors.toMap(Pair::getFirst, Pair::getSecond));
    for (Entry<Disk, VmDevice> diskAndDevice : vmInfoBuildUtils.getSortedDisks(vmDisksToDevices, vm.getId())) {
        Disk disk = diskAndDevice.getKey();
        VmDevice device = diskAndDevice.getValue();
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        DiskInterface diskInterface = dve.getDiskInterface();
        int index = 0;
        int pinTo = 0;
        switch(diskInterface) {
            case IDE:
                index = hdIndex = skipCdIndices(++hdIndex, diskInterface);
                break;
            case VirtIO:
                pinTo = vmInfoBuildUtils.pinToIoThreads(vm, pinnedDriveIndex++);
                index = vdIndex = skipCdIndices(++vdIndex, diskInterface);
                break;
            case SPAPR_VSCSI:
            case VirtIO_SCSI:
                vmInfoBuildUtils.calculateAddressForScsiDisk(vm, disk, device, vmDeviceSpaprVscsiUnitMap, vmDeviceVirtioScsiUnitMap);
            case SATA:
                index = sdIndex = skipCdIndices(++sdIndex, diskInterface);
                break;
        }
        String dev = vmInfoBuildUtils.makeDiskName(dve.getDiskInterface().getName(), index);
        writeDisk(device, disk, dve, dev, pinTo);
    }
}
#end_block

#method_before
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw' error_policy='report' />
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        String name = vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex);
        writer.writeAttributeString("dev", name);
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        writeAlias(device);
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        payloadMetadata = new Pair<>(name, new VmPayload(device));
        writer.writeEndElement();
    });
    // add a device that points to vm.getCdPath()
    String cdPath = vm.getCdPath();
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(cdPath))) {
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        String dev = vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex);
        boolean isoOnBlockDomain = vmInfoBuildUtils.isBlockDomainPath(cdPath);
        if (isoOnBlockDomain) {
            diskMetadata.put(dev, vmInfoBuildUtils.createDiskUuidsMap(vm, cdPath));
        }
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", isoOnBlockDomain ? "block" : "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString(isoOnBlockDomain ? "dev" : "file", cdPath);
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", dev);
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAlias(nonPayload);
            writeAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#method_after
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw' error_policy='report' />
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        String name = vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex);
        writer.writeAttributeString("dev", name);
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        writeAlias(device);
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        payloadMetadata = new Pair<>(name, new VmPayload(device));
        writer.writeEndElement();
    });
    // add a device that points to vm.getCdPath()
    String cdPath = vm.getCdPath();
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(cdPath))) {
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        String dev = vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex);
        boolean isoOnBlockDomain = vmInfoBuildUtils.isBlockDomainPath(cdPath);
        if (isoOnBlockDomain) {
            diskMetadata.put(dev, vmInfoBuildUtils.createDiskUuidsMap(vm, cdPath));
        }
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", isoOnBlockDomain ? "block" : "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString(isoOnBlockDomain ? "dev" : "file", cdPath);
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", dev);
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAlias(nonPayload);
            if ("scsi".equals(cdInterface)) {
                writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, cdRomIndex));
            } else {
                writeAddress(nonPayload);
            }
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network != null ? network.getVdsmName() : "");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(network != null ? network.getName() : "");
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (network != null && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
public void update(Guid vdsId, Map<String, Object> values) {
    int entryCount = values != null ? values.size() : 0;
    String[] pluginTypes = new String[entryCount];
    String[] bindingIds = new String[entryCount];
    if (values != null) {
        int i = 0;
        for (Map.Entry<String, Object> pair : values.entrySet()) {
            pluginTypes[i] = pair.getKey();
            bindingIds[i] = (String) pair.getValue();
        }
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", vdsId).addValue("plugin_types", createArrayOf("text", pluginTypes)).addValue("provider_binding_host_ids", createArrayOf("text", bindingIds));
    getCallsHandler().executeModification("UpdateHostProviderBinding", parameterSource);
}
#method_after
public void update(Guid vdsId, Map<String, Object> values) {
    int entryCount = values != null ? values.size() : 0;
    String[] pluginTypes = new String[entryCount];
    String[] bindingIds = new String[entryCount];
    if (values != null) {
        int i = 0;
        for (Map.Entry<String, Object> pair : values.entrySet()) {
            pluginTypes[i] = pair.getKey();
            bindingIds[i] = (String) pair.getValue();
            i++;
        }
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", vdsId).addValue("plugin_types", createArrayOf("text", pluginTypes)).addValue("provider_binding_host_ids", createArrayOf("text", bindingIds));
    getCallsHandler().executeModification("UpdateHostProviderBinding", parameterSource);
}
#end_block

#method_before
public DomainXmlListReturn dumpxmls(List<String> vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.dumpxmls").withOptionalParameterAsList("vmList", vmIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domxmls").withResponseType(Object[].class);
    return new DomainXmlListReturn(response);
}
#method_after
@Override
public DomainXmlListReturn dumpxmls(List<String> vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.dumpxmls").withOptionalParameterAsList("vmList", vmIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domxmls").withResponseType(Object[].class);
    return new DomainXmlListReturn(response);
}
#end_block

#method_before
private void onRemove() {
    RemoveDiskModel model = (RemoveDiskModel) getWindow();
    ArrayList<ActionParametersBase> parameterList = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        ActionParametersBase parameters = new RemoveDiskParameters(disk.getId());
        parameterList.add(parameters);
    }
    selectNextItem();
    model.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.RemoveDisk, parameterList, result -> {
        DiskListModel localModel = (DiskListModel) result.getState();
        if (result.getReturnValue().stream().anyMatch(rv -> !rv.isValid())) {
            restorePreviousSelectedItem();
        }
        localModel.stopProgress();
        cancel();
    }, this);
}
#method_after
private void onRemove() {
    RemoveDiskModel model = (RemoveDiskModel) getWindow();
    ArrayList<ActionParametersBase> parameterList = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        ActionParametersBase parameters = new RemoveDiskParameters(disk.getId());
        parameterList.add(parameters);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(ActionType.RemoveDisk, parameterList, result -> {
        DiskListModel localModel = (DiskListModel) result.getState();
        localModel.stopProgress();
        cancel();
    }, this);
}
#end_block

#method_before
public void updateHostStatusAfterSuccessfulUpgrade() {
    VdsDynamic dynamicHostData = vdsDynamicDao.get(getVdsId());
    dynamicHostData.setUpdateAvailable(false);
    vdsDynamicDao.update(dynamicHostData);
    if (getVds().getVdsType() == VDSType.VDS && !getParameters().isReboot()) {
        if (getParameters().getInitialStatus() == VDSStatus.Maintenance) {
            setVdsStatus(VDSStatus.Maintenance);
        } else {
            if (getVds().getHighlyAvailableIsConfigured()) {
                haMaintenanceFailed = !hostedEngineHelper.updateHaLocalMaintenanceMode(getVds(), false);
            }
            setVdsStatus(VDSStatus.Initializing);
        }
    }
}
#method_after
public void updateHostStatusAfterSuccessfulUpgrade() {
    VdsDynamic dynamicHostData = vdsDynamicDao.get(getVdsId());
    dynamicHostData.setUpdateAvailable(false);
    vdsDynamicDao.update(dynamicHostData);
    if (getVds().getVdsType() == VDSType.VDS && !getParameters().isReboot()) {
        if (getParameters().getInitialStatus() == VDSStatus.Maintenance) {
            setVdsStatus(VDSStatus.Maintenance);
        } else {
            setVdsStatus(VDSStatus.Initializing);
        }
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return haMaintenanceFailed ? AuditLogType.HOST_UPGRADE_FINISHED_MANUAL_HA : AuditLogType.HOST_UPGRADE_FINISHED;
    }
    return AuditLogType.HOST_UPGRADE_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.HOST_UPGRADE_FINISHED : AuditLogType.HOST_UPGRADE_FAILED;
}
#end_block

#method_before
protected void setDefaultSwitchTypeIfNeeded() {
    Cluster cluster = getCluster();
    if (cluster.hasRequiredSwitchType(null)) {
        SwitchType defaultSwitchType = DefaultSwitchType.getDefaultSwitchType(cluster.getCompatibilityVersion());
        cluster.setRequiredSwitchTypeForCluster(defaultSwitchType);
    }
}
#method_after
protected void setDefaultSwitchTypeIfNeeded() {
    Cluster cluster = getCluster();
    if (!cluster.isSetRequiredSwitchType()) {
        SwitchType defaultSwitchType = DefaultSwitchType.getDefaultSwitchType(cluster.getCompatibilityVersion());
        cluster.setRequiredSwitchTypeForCluster(defaultSwitchType);
    }
}
#end_block

#method_before
private void updateSwitchTypeUponVersionChange(Version version) {
    ListModel<SwitchType> switchType = getSwitchType();
    boolean ovsSupported = isOvsSupported(version);
    switchType.setIsChangeable(ovsSupported);
    if (!ovsSupported && switchType.getSelectedItem().equals(SwitchType.OVS)) {
        switchType.setSelectedItem(SwitchType.LEGACY);
    }
}
#method_after
private void updateSwitchTypeUponVersionChange(Version version) {
    ListModel<SwitchType> switchType = getSwitchType();
    boolean ovsSupported = isOvsSupported(version);
    switchType.setIsChangeable(ovsSupported && !getIsEdit());
    if (!ovsSupported && switchType.getSelectedItem().equals(SwitchType.OVS)) {
        switchType.setSelectedItem(SwitchType.LEGACY);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    macPool = getMacPool();
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (!validate(vmStatusLegal(vmDynamicDao.get(getParameters().getVmId()).getStatus()))) {
        return false;
    }
    List<VmNic> interfaces = vmNicDao.getAllForVm(getParameters().getVmId());
    if (!uniqueInterfaceName(interfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    Version compatibilityVersion = getVm().getClusterCompatibilityVersion();
    VmNicValidator nicValidator = new VmNicValidator(getInterface(), compatibilityVersion, getVm().getOs());
    if (!validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.profileValid(getVm().getClusterId())) || !validate(nicValidator.typeMatchesProfile()) || !validate(nicValidator.passthroughIsLinked()) || !validate(nicValidator.validateProfileNotEmptyForHostedEngineVm(getVm()))) {
        return false;
    }
    if (StringUtils.isNotEmpty(getMacAddress())) {
        if (!validate(macAvailable())) {
            return false;
        }
    } else if (macPool.getAvailableMacsCount() <= 0) {
        addValidationMessage(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    macPool = getMacPool();
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (!validate(vmStatusLegal(vmDynamicDao.get(getParameters().getVmId()).getStatus()))) {
        return false;
    }
    List<VmNic> interfaces = vmNicDao.getAllForVm(getParameters().getVmId());
    if (!uniqueInterfaceName(interfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    Version compatibilityVersion = getVm().getClusterCompatibilityVersion();
    VmNicValidator nicValidator = new VmNicValidator(getInterface(), compatibilityVersion, getVm().getOs());
    if (!validate(nicValidator.isNetworkSupportedByClusterSwitchType(getCluster())) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.profileValid(getVm().getClusterId())) || !validate(nicValidator.typeMatchesProfile()) || !validate(nicValidator.passthroughIsLinked()) || !validate(nicValidator.validateProfileNotEmptyForHostedEngineVm(getVm()))) {
        return false;
    }
    if (StringUtils.isNotEmpty(getMacAddress())) {
        if (!validate(macAvailable())) {
            return false;
        }
    } else if (macPool.getAvailableMacsCount() <= 0) {
        addValidationMessage(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    initVmData();
    if (oldIface == null || oldVmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!updateVnicForBackwardCompatibility(oldIface)) {
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(vmInterfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(vmInterfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getClusterCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(getVm().getClusterId())) || !validate(nicValidator.canVnicWithExternalNetworkBePlugged()) || !validate(nicValidator.typeMatchesProfile()) || !validate(nicValidator.passthroughIsLinked()) || !validate(nicValidator.validateProfileNotEmptyForHostedEngineVm(getVm()))) {
        return false;
    }
    Network network = networkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = networkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    initMacPoolData();
    if (macShouldBeChanged && macShouldBeAddedIntoPool() && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    initVmData();
    if (oldIface == null || oldVmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!updateVnicForBackwardCompatibility(oldIface)) {
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(vmInterfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(vmInterfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getClusterCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.isNetworkSupportedByClusterSwitchType(getCluster())) || !validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(getVm().getClusterId())) || !validate(nicValidator.canVnicWithExternalNetworkBePlugged()) || !validate(nicValidator.typeMatchesProfile()) || !validate(nicValidator.passthroughIsLinked()) || !validate(nicValidator.validateProfileNotEmptyForHostedEngineVm(getVm()))) {
        return false;
    }
    Network network = networkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = networkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    initMacPoolData();
    if (macShouldBeChanged && macShouldBeAddedIntoPool() && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@SuppressWarnings("incomplete-switch")
private void writeCpu(boolean addVmNumaNodes) {
    writer.writeStartElement("cpu");
    String cpuType = vm.getCpuName();
    if (vm.isUseHostCpuFlags()) {
        cpuType = "hostPassthrough";
    }
    switch(vm.getClusterArch().getFamily()) {
        case x86:
            writer.writeAttributeString("match", "exact");
            // is this a list of strings??..
            switch(cpuType) {
                case "hostPassthrough":
                    writer.writeAttributeString("mode", "host-passthrough");
                    break;
                case "hostModel":
                    writer.writeAttributeString("mode", "host-model");
                    break;
                default:
                    writer.writeStartElement("model");
                    writer.writeRaw(cpuType);
                    // TODO: features
                    writer.writeEndElement();
                    break;
            }
            break;
        case ppc:
            writer.writeElement("model", cpuType);
    }
    if ((boolean) Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        writer.writeStartElement("topology");
        writer.writeAttributeString("cores", Integer.toString(vm.getCpuPerSocket()));
        writer.writeAttributeString("threads", Integer.toString(vm.getThreadsPerCpu()));
        int vcpus = FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch()) ? VmCpuCountHelper.calcMaxVCpu(vm, vm.getClusterCompatibilityVersion()) : vm.getNumOfCpus();
        writer.writeAttributeString("sockets", String.valueOf(vcpus / vm.getCpuPerSocket() / vm.getThreadsPerCpu()));
        writer.writeEndElement();
    }
    if (addVmNumaNodes) {
        writer.writeStartElement("numa");
        NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodesSupplier.get()).forEach(vmNumaNode -> {
            writer.writeStartElement("cell");
            writer.writeAttributeString("cpus", vmNumaNode.get(VdsProperties.NUMA_NODE_CPU_LIST).toString());
            writer.writeAttributeString("memory", String.valueOf(Integer.parseInt((String) vmNumaNode.get(VdsProperties.VM_NUMA_NODE_MEM)) * 1024));
            if (HugePageUtils.isHugepagesShared(vm.getStaticData())) {
                writer.writeAttributeString("memAccess", "shared");
            }
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (vm.getVmType() == VmType.HighPerformance) {
        writer.writeStartElement("cache");
        writer.writeAttributeString("level", "3");
        writer.writeAttributeString("mode", "emulate");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
@SuppressWarnings("incomplete-switch")
private void writeCpu(boolean addVmNumaNodes) {
    writer.writeStartElement("cpu");
    String cpuType = vm.getCpuName();
    if (vm.isUseHostCpuFlags()) {
        cpuType = "hostPassthrough";
    }
    switch(vm.getClusterArch().getFamily()) {
        case x86:
            writer.writeAttributeString("match", "exact");
            // is this a list of strings??..
            switch(cpuType) {
                case "hostPassthrough":
                    writer.writeAttributeString("mode", "host-passthrough");
                    break;
                case "hostModel":
                    writer.writeAttributeString("mode", "host-model");
                    break;
                default:
                    writer.writeStartElement("model");
                    writer.writeRaw(cpuType);
                    // TODO: features
                    writer.writeEndElement();
                    break;
            }
            break;
        case ppc:
            writer.writeElement("model", cpuType);
    }
    if ((boolean) Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        writer.writeStartElement("topology");
        writer.writeAttributeString("cores", Integer.toString(vm.getCpuPerSocket()));
        writer.writeAttributeString("threads", Integer.toString(vm.getThreadsPerCpu()));
        int vcpus = FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch()) ? VmCpuCountHelper.calcMaxVCpu(vm, vm.getClusterCompatibilityVersion()) : vm.getNumOfCpus();
        writer.writeAttributeString("sockets", String.valueOf(vcpus / vm.getCpuPerSocket() / vm.getThreadsPerCpu()));
        writer.writeEndElement();
    }
    if (addVmNumaNodes) {
        writer.writeStartElement("numa");
        NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodesSupplier.get()).forEach(vmNumaNode -> {
            writer.writeStartElement("cell");
            writer.writeAttributeString("cpus", vmNumaNode.get(VdsProperties.NUMA_NODE_CPU_LIST).toString());
            writer.writeAttributeString("memory", String.valueOf(Integer.parseInt((String) vmNumaNode.get(VdsProperties.VM_NUMA_NODE_MEM)) * 1024));
            if (HugePageUtils.isHugepagesShared(vm.getStaticData())) {
                writer.writeAttributeString("memAccess", "shared");
            }
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private List<VmDevice> overrideDevicesForRunOnce(List<VmDevice> devices) {
    if (!vm.isRunOnce()) {
        return devices;
    }
    // video device handling
    DisplayType displayType = vm.getDefaultDisplayType();
    if (displayType != null) {
        // remove existing video device
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.VIDEO).collect(Collectors.toList());
        // add new video device
        if (displayType != DisplayType.none) {
            devices.add(vmInfoBuildUtils.createVideoDeviceByDisplayType(displayType, vm.getId()));
        }
    }
    // graphics device handling
    if (displayType == DisplayType.none || (vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty())) {
        // remove existing graphics devices
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.GRAPHICS).collect(Collectors.toList());
        if (displayType != DisplayType.none) {
            // add new graphics devices
            Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
            Map<String, Object> specParamsFromVm = new HashMap<>();
            vmInfoBuildUtils.addVmGraphicsOptions(infos, specParamsFromVm, vm);
            devices.addAll(vmInfoBuildUtils.createGraphicsDevices(infos, specParamsFromVm, vm.getId()));
        }
    }
    // the user may specify floppy path while there is no device in the database
    if (!StringUtils.isEmpty(vm.getFloppyPath()) && !devices.stream().anyMatch(dev -> dev.getDevice().equals(VmDeviceType.FLOPPY.getName()))) {
        devices.add(vmInfoBuildUtils.createFloppyDevice(vm));
    }
    return devices;
}
#method_after
private List<VmDevice> overrideDevicesForRunOnce(List<VmDevice> devices) {
    if (!vm.isRunOnce()) {
        return devices;
    }
    // video device handling
    DisplayType displayType = vm.getDefaultDisplayType();
    if (displayType != null) {
        // remove existing video device
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.VIDEO).collect(Collectors.toList());
        // add new video device
        if (displayType != DisplayType.none) {
            devices.add(vmInfoBuildUtils.createVideoDeviceByDisplayType(displayType, vm.getId()));
        }
    }
    // graphics device handling
    if (displayType == DisplayType.none || (vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty())) {
        // remove existing graphics devices
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.GRAPHICS).collect(Collectors.toList());
        if (displayType != DisplayType.none) {
            // add new graphics devices
            Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
            Map<String, Object> specParamsFromVm = new HashMap<>();
            vmInfoBuildUtils.addVmGraphicsOptions(infos, specParamsFromVm, vm);
            devices.addAll(vmInfoBuildUtils.createGraphicsDevices(infos, specParamsFromVm, vm.getId()));
        }
    }
    // the user may specify floppy path while there is no device in the database
    if (!StringUtils.isEmpty(vm.getFloppyPath()) && devices.stream().noneMatch(dev -> dev.getDevice().equals(VmDeviceType.FLOPPY.getName()))) {
        devices.add(vmInfoBuildUtils.createFloppyDevice(vm));
    }
    return devices;
}
#end_block

#method_before
private void writeDisks(List<VmDevice> devices) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    int ideIndex = -1;
    int scsiIndex = -1;
    int virtioIndex = -1;
    int pinnedDriveIndex = 0;
    Map<Disk, VmDevice> vmDisksToDevices = vm.getDiskMap().values().stream().map(d -> new Pair<>(d, deviceIdToDevice.get(new VmDeviceId(d.getId(), vm.getId())))).filter(p -> p.getSecond() != null && p.getSecond().isManaged()).collect(Collectors.toMap(Pair::getFirst, Pair::getSecond));
    for (Entry<Disk, VmDevice> diskAndDevice : vmInfoBuildUtils.getSortedDisks(vmDisksToDevices, vm.getId())) {
        Disk disk = diskAndDevice.getKey();
        VmDevice device = diskAndDevice.getValue();
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        DiskInterface diskInterface = dve.getDiskInterface();
        int index = 0;
        int pinTo = 0;
        switch(diskInterface) {
            case IDE:
                ideIndex++;
                if (diskInterface.getName().equals(cdInterface)) {
                    while (ideIndex == payloadIndex || ideIndex == cdRomIndex) {
                        ideIndex++;
                    }
                }
                index = ideIndex;
                break;
            case VirtIO:
                pinTo = vmInfoBuildUtils.pinToIoThreads(vm, pinnedDriveIndex++);
                virtioIndex++;
                if (diskInterface.getName().equals(cdInterface)) {
                    while (virtioIndex == payloadIndex || virtioIndex == cdRomIndex) {
                        virtioIndex++;
                    }
                }
                index = virtioIndex;
                break;
            case SPAPR_VSCSI:
            case VirtIO_SCSI:
                scsiIndex++;
                if (diskInterface.getName().equals(cdInterface)) {
                    while (scsiIndex == payloadIndex || scsiIndex == cdRomIndex) {
                        scsiIndex++;
                    }
                }
                index = scsiIndex;
                vmInfoBuildUtils.calculateAddressForScsiDisk(vm, disk, device, vmDeviceSpaprVscsiUnitMap, vmDeviceVirtioScsiUnitMap);
                break;
        }
        String dev = vmInfoBuildUtils.makeDiskName(dve.getDiskInterface().getName(), index);
        writeDisk(device, disk, dve, dev, pinTo);
    }
}
#method_after
private void writeDisks(List<VmDevice> devices) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    int hdIndex = -1;
    int sdIndex = -1;
    int vdIndex = -1;
    int pinnedDriveIndex = 0;
    Map<Disk, VmDevice> vmDisksToDevices = vm.getDiskMap().values().stream().map(d -> new Pair<>(d, deviceIdToDevice.get(new VmDeviceId(d.getId(), vm.getId())))).filter(p -> p.getSecond() != null && p.getSecond().isManaged()).collect(Collectors.toMap(Pair::getFirst, Pair::getSecond));
    for (Entry<Disk, VmDevice> diskAndDevice : vmInfoBuildUtils.getSortedDisks(vmDisksToDevices, vm.getId())) {
        Disk disk = diskAndDevice.getKey();
        VmDevice device = diskAndDevice.getValue();
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        DiskInterface diskInterface = dve.getDiskInterface();
        int index = 0;
        int pinTo = 0;
        switch(diskInterface) {
            case IDE:
                index = hdIndex = skipCdIndices(++hdIndex, diskInterface);
                break;
            case VirtIO:
                pinTo = vmInfoBuildUtils.pinToIoThreads(vm, pinnedDriveIndex++);
                index = vdIndex = skipCdIndices(++vdIndex, diskInterface);
                break;
            case SPAPR_VSCSI:
            case VirtIO_SCSI:
                index = sdIndex = skipCdIndices(++sdIndex, diskInterface);
                vmInfoBuildUtils.calculateAddressForScsiDisk(vm, disk, device, vmDeviceSpaprVscsiUnitMap, vmDeviceVirtioScsiUnitMap);
                break;
        }
        String dev = vmInfoBuildUtils.makeDiskName(dve.getDiskInterface().getName(), index);
        writeDisk(device, disk, dve, dev, pinTo);
    }
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network != null ? network.getVdsmName() : "");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(network != null ? network.getName() : "");
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (network != null && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
public int getAvailableUnitForScsiDisk(Map<VmDevice, Integer> vmDeviceUnitMap, boolean reserveFirstTwoLuns, boolean reserveForScsiCd) {
    int cdPayloadUnitIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex("scsi");
    int cdUnitIndex = VmDeviceCommonUtils.getCdDeviceIndex("scsi");
    int unit = reserveFirstTwoLuns ? reserveForScsiCd ? Math.max(cdPayloadUnitIndex, cdUnitIndex) + 1 : 2 : 0;
    if (vmDeviceUnitMap == null) {
        return unit;
    }
    while (reserveForScsiCd && unit == cdPayloadUnitIndex || reserveForScsiCd && unit == cdUnitIndex || vmDeviceUnitMap.containsValue(unit)) {
        unit++;
    }
    return unit;
}
#method_after
public int getAvailableUnitForScsiDisk(Map<VmDevice, Integer> vmDeviceUnitMap, boolean reserveFirstTwoLuns, boolean reserveForScsiCd) {
    int unit = reserveFirstTwoLuns ? 2 : 0;
    int cdPayloadUnitIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex("scsi");
    int cdUnitIndex = VmDeviceCommonUtils.getCdDeviceIndex("scsi");
    while (reserveForScsiCd && unit == cdPayloadUnitIndex || reserveForScsiCd && unit == cdUnitIndex || (vmDeviceUnitMap != null && vmDeviceUnitMap.containsValue(unit))) {
        unit++;
    }
    return unit;
}
#end_block

#method_before
private String diskInterfaceToDevName(String iface) {
    switch(iface) {
        case "virtio":
            return "vd";
        case "fdc":
            return "fd";
        case "scsi":
        case "sata":
            return "sd";
        case "ide":
        default:
            return "hd";
    }
}
#method_after
public String diskInterfaceToDevName(String iface) {
    switch(iface) {
        case "virtio":
            return "vd";
        case "fdc":
            return "fd";
        case "scsi":
        case "sata":
            return "sd";
        case "ide":
        default:
            return "hd";
    }
}
#end_block

#method_before
public void calculateAddressForScsiDisk(VM vm, Disk disk, VmDevice device, Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap, Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap) {
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int defaultSpaprVscsiControllerIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    int defaultVirtioScsiControllerIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    Integer unitIndex = null;
    switch(disk.getDiskVmElementForVm(vm.getId()).getDiskInterface()) {
        case SPAPR_VSCSI:
            if (StringUtils.isEmpty(device.getAddress())) {
                unitIndex = vmDeviceSpaprVscsiUnitMap.get(defaultSpaprVscsiControllerIndex).get(device);
                device.setAddress(createAddressForScsiDisk(defaultSpaprVscsiControllerIndex, unitIndex).toString());
            }
            break;
        case VirtIO_SCSI:
            int controllerIndex = defaultVirtioScsiControllerIndex;
            VmDevice deviceFromMap = device;
            for (Map.Entry<Integer, Map<VmDevice, Integer>> controllerToDevices : vmDeviceVirtioScsiUnitMap.entrySet()) {
                Optional<VmDevice> maybeDeviceFromMap = controllerToDevices.getValue().keySet().stream().filter(d -> d.getId().equals(device.getId())).findFirst();
                if (maybeDeviceFromMap.isPresent()) {
                    deviceFromMap = maybeDeviceFromMap.get();
                    controllerIndex = controllerToDevices.getKey();
                    unitIndex = controllerToDevices.getValue().get(deviceFromMap);
                    break;
                }
            }
            if (StringUtils.isEmpty(deviceFromMap.getAddress())) {
                if (unitIndex == null) {
                    // should never get here, but for safety having this fallback and generating a new unit id
                    unitIndex = getAvailableUnitForScsiDisk(vmDeviceVirtioScsiUnitMap.get(controllerIndex), false, controllerIndex == 0);
                    log.debug("The unit was null for disk '{}' on controller '{}', generating a new one '{}'", disk.getId(), controllerIndex, unitIndex);
                }
                device.setAddress(createAddressForScsiDisk(controllerIndex, unitIndex).toString());
            }
            break;
    }
}
#method_after
public void calculateAddressForScsiDisk(VM vm, Disk disk, VmDevice device, Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap, Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap) {
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int defaultSpaprVscsiControllerIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    int defaultVirtioScsiControllerIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    Integer unitIndex = null;
    switch(disk.getDiskVmElementForVm(vm.getId()).getDiskInterface()) {
        case SPAPR_VSCSI:
            if (StringUtils.isEmpty(device.getAddress())) {
                unitIndex = vmDeviceSpaprVscsiUnitMap.get(defaultSpaprVscsiControllerIndex).get(device);
                device.setAddress(createAddressForScsiDisk(defaultSpaprVscsiControllerIndex, unitIndex).toString());
            }
            break;
        case VirtIO_SCSI:
            int controllerIndex = defaultVirtioScsiControllerIndex;
            VmDevice deviceFromMap = device;
            for (Map.Entry<Integer, Map<VmDevice, Integer>> controllerToDevices : vmDeviceVirtioScsiUnitMap.entrySet()) {
                Optional<VmDevice> maybeDeviceFromMap = controllerToDevices.getValue().keySet().stream().filter(d -> d.getId().equals(device.getId())).findFirst();
                if (maybeDeviceFromMap.isPresent()) {
                    deviceFromMap = maybeDeviceFromMap.get();
                    controllerIndex = controllerToDevices.getKey();
                    unitIndex = controllerToDevices.getValue().get(deviceFromMap);
                    break;
                }
            }
            if (StringUtils.isEmpty(deviceFromMap.getAddress())) {
                if (unitIndex == null) {
                    // should never get here, but for safety having this fallback and generating a new unit id
                    unitIndex = getAvailableUnitForScsiDisk(vmDeviceVirtioScsiUnitMap.get(controllerIndex), false, false);
                    log.debug("The unit was null for disk '{}' on controller '{}', generating a new one '{}'", disk.getId(), controllerIndex, unitIndex);
                }
                device.setAddress(createAddressForScsiDisk(controllerIndex, unitIndex).toString());
            }
            break;
    }
}
#end_block

#method_before
public static List<Guid> getMemoryDiskIdsFromSnapshots(List<Snapshot> snapshots) {
    List<Guid> memoryDiskIds = new ArrayList<>();
    for (Snapshot snapshot : snapshots) {
        if (snapshot.containsMemory()) {
            memoryDiskIds.add(snapshot.getMemoryDiskId());
            memoryDiskIds.add(snapshot.getMetadataDiskId());
        }
    }
    return memoryDiskIds;
}
#method_after
public static Set<Guid> getMemoryDiskIdsFromSnapshots(List<Snapshot> snapshots) {
    Set<Guid> memoryDiskIds = new HashSet<>();
    for (Snapshot snapshot : snapshots) {
        if (snapshot.containsMemory()) {
            memoryDiskIds.add(snapshot.getMemoryDiskId());
            memoryDiskIds.add(snapshot.getMetadataDiskId());
        }
    }
    return memoryDiskIds;
}
#end_block

#method_before
private void writeSnapshotsSection() {
    List<Snapshot> snapshots = vm.getSnapshots();
    if (snapshots == null || snapshots.isEmpty()) {
        return;
    }
    _writer.writeStartElement("Section");
    _writer.writeAttributeString(XSI_URI, "type", "ovf:SnapshotsSection_Type");
    for (Snapshot snapshot : snapshots) {
        _writer.writeStartElement("Snapshot");
        _writer.writeAttributeString(OVF_URI, "id", snapshot.getId().toString());
        _writer.writeElement("Type", snapshot.getType().name());
        _writer.writeElement("Description", snapshot.getDescription());
        _writer.writeElement("CreationDate", OvfParser.localDateToUtcDateString(snapshot.getCreationDate()));
        if (snapshot.containsMemory()) {
            DiskImage memoryDump = memoryDisks.get(snapshot.getMemoryDiskId());
            DiskImage memoryConf = memoryDisks.get(snapshot.getMetadataDiskId());
            String memoryVolume = String.format("%1$s,%2$s,%3$s,%4$s,%5$s,%6$s", memoryDump.getStorageIds().get(0), memoryDump.getStoragePoolId(), memoryDump.getId(), memoryDump.getImageId(), memoryConf.getId(), memoryConf.getImageId());
            _writer.writeElement("Memory", memoryVolume);
        }
        if (snapshot.getAppList() != null) {
            _writer.writeElement("ApplicationList", snapshot.getAppList());
        }
        if (snapshot.getVmConfiguration() != null) {
            _writer.writeElement("VmConfiguration", Base64.encodeBase64String(snapshot.getVmConfiguration().getBytes()));
        }
        _writer.writeEndElement();
    }
    _writer.writeEndElement();
}
#method_after
private void writeSnapshotsSection() {
    List<Snapshot> snapshots = vm.getSnapshots();
    if (snapshots == null || snapshots.isEmpty()) {
        return;
    }
    _writer.writeStartElement("Section");
    _writer.writeAttributeString(XSI_URI, "type", "ovf:SnapshotsSection_Type");
    for (Snapshot snapshot : snapshots) {
        _writer.writeStartElement("Snapshot");
        _writer.writeAttributeString(getOvfUri(), "id", snapshot.getId().toString());
        _writer.writeElement("Type", snapshot.getType().name());
        _writer.writeElement("Description", snapshot.getDescription());
        _writer.writeElement("CreationDate", OvfParser.localDateToUtcDateString(snapshot.getCreationDate()));
        if (snapshot.containsMemory()) {
            DiskImage memoryDump = memoryDisks.get(snapshot.getMemoryDiskId());
            DiskImage memoryConf = memoryDisks.get(snapshot.getMetadataDiskId());
            String memoryVolume = String.format("%1$s,%2$s,%3$s,%4$s,%5$s,%6$s", memoryDump.getStorageIds().get(0), memoryDump.getStoragePoolId(), memoryDump.getId(), memoryDump.getImageId(), memoryConf.getId(), memoryConf.getImageId());
            _writer.writeElement("Memory", memoryVolume);
        }
        if (snapshot.getAppList() != null) {
            _writer.writeElement("ApplicationList", snapshot.getAppList());
        }
        if (snapshot.getVmConfiguration() != null) {
            _writer.writeElement("VmConfiguration", Base64.encodeBase64String(snapshot.getVmConfiguration().getBytes()));
        }
        _writer.writeEndElement();
    }
    _writer.writeEndElement();
}
#end_block

#method_before
private void writeAffinityGroups() {
    List<AffinityGroup> affinityGroups = fullEntityOvfData.getAffinityGroups();
    if (affinityGroups == null || affinityGroups.isEmpty()) {
        return;
    }
    _writer.writeStartElement("Section");
    _writer.writeAttributeString(XSI_URI, "type", "ovf:AffinityGroupsSection_Type");
    affinityGroups.forEach(affinityGroup -> {
        _writer.writeStartElement(OvfProperties.AFFINITY_GROUP);
        _writer.writeAttributeString(OVF_URI, "name", affinityGroup.getName());
        _writer.writeEndElement();
    });
    _writer.writeEndElement();
}
#method_after
private void writeAffinityGroups() {
    List<AffinityGroup> affinityGroups = fullEntityOvfData.getAffinityGroups();
    if (affinityGroups == null || affinityGroups.isEmpty()) {
        return;
    }
    _writer.writeStartElement("Section");
    _writer.writeAttributeString(XSI_URI, "type", "ovf:AffinityGroupsSection_Type");
    affinityGroups.forEach(affinityGroup -> {
        _writer.writeStartElement(OvfProperties.AFFINITY_GROUP);
        _writer.writeAttributeString(getOvfUri(), "name", affinityGroup.getName());
        _writer.writeEndElement();
    });
    _writer.writeEndElement();
}
#end_block

#method_before
private void writeAffinityLabels() {
    List<Label> affinityLabelsNames = fullEntityOvfData.getAffinityLabels();
    if (affinityLabelsNames == null || affinityLabelsNames.isEmpty()) {
        return;
    }
    _writer.writeStartElement("Section");
    _writer.writeAttributeString(XSI_URI, "type", "ovf:AffinityLabelsSection_Type");
    affinityLabelsNames.forEach(label -> {
        _writer.writeStartElement(OvfProperties.AFFINITY_LABEL);
        _writer.writeAttributeString(OVF_URI, "name", label.getName());
        _writer.writeEndElement();
    });
    _writer.writeEndElement();
}
#method_after
private void writeAffinityLabels() {
    List<Label> affinityLabelsNames = fullEntityOvfData.getAffinityLabels();
    if (affinityLabelsNames == null || affinityLabelsNames.isEmpty()) {
        return;
    }
    _writer.writeStartElement("Section");
    _writer.writeAttributeString(XSI_URI, "type", "ovf:AffinityLabelsSection_Type");
    affinityLabelsNames.forEach(label -> {
        _writer.writeStartElement(OvfProperties.AFFINITY_LABEL);
        _writer.writeAttributeString(getOvfUri(), "name", label.getName());
        _writer.writeEndElement();
    });
    _writer.writeEndElement();
}
#end_block

#method_before
private void restoreConfiguration(Snapshot targetSnapshot) {
    removedSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    snapshotsToRemove.add(removedSnapshot.getId());
    getSnapshotsManager().removeAllIllegalDisks(removedSnapshot.getId(), getVmId());
    getSnapshotsManager().attempToRestoreVmConfigurationFromSnapshot(getVm(), targetSnapshot, targetSnapshot.getId(), null, getCompensationContext(), getCurrentUser(), new VmInterfaceManager(getMacPool()), targetSnapshot.containsMemory());
    snapshotDao.remove(targetSnapshot.getId());
    // add active snapshot with status locked, so that other commands that depend on the VM's snapshots won't run in parallel
    getSnapshotsManager().addActiveSnapshot(targetSnapshot.getId(), getVm(), SnapshotStatus.LOCKED, null, null, getCompensationContext());
}
#method_after
private void restoreConfiguration(Snapshot targetSnapshot) {
    removedSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    snapshotsToRemove.add(removedSnapshot.getId());
    getSnapshotsManager().removeAllIllegalDisks(removedSnapshot.getId(), getVmId());
    getSnapshotsManager().attempToRestoreVmConfigurationFromSnapshot(getVm(), targetSnapshot, targetSnapshot.getId(), null, getCompensationContext(), getCurrentUser(), new VmInterfaceManager(getMacPool()), targetSnapshot.containsMemory());
    snapshotDao.remove(targetSnapshot.getId());
    // add active snapshot with status locked, so that other commands that depend on the VM's snapshots won't run in parallel
    getSnapshotsManager().addActiveSnapshot(targetSnapshot.getId(), getVm(), SnapshotStatus.LOCKED, targetSnapshot.getMemoryDiskId(), targetSnapshot.getMetadataDiskId(), getCompensationContext());
}
#end_block

#method_before
private String generateOvfReaderErrorMessage(OvfReader ovf, Exception ex) {
    StringBuilder message = new StringBuilder();
    if (ovf == null) {
        message.append("Error loading ovf, message").append(ex.getMessage());
    } else {
        message.append("OVF error: ").append(ovf.getName()).append(": cannot read '").append(ovf.getLastReadEntry()).append("' with value: ").append(ex.getMessage());
    }
    return message.toString();
}
#method_after
private String generateOvfReaderErrorMessage(OvfReader ovf, Exception ex) {
    StringBuilder message = new StringBuilder();
    if (ovf == null) {
        message.append("Error loading ovf, message ").append(ex.getMessage());
    } else {
        message.append("OVF error: ").append(ovf.getName()).append(": cannot read '").append(ovf.getLastReadEntry()).append("' with value: ").append(ex.getMessage());
    }
    return message.toString();
}
#end_block

#method_before
public ValidationResult validateStorageExistForUnregisteredEntity(List<DiskImage> images, boolean allowPartial, Map<Guid, Guid> imageToDestinationDomainMap, Map<Guid, String> failedDisksToImport) {
    for (DiskImage image : new ArrayList<>(images)) {
        StorageDomain sd = getStorageDomainDao().getForStoragePool(image.getStorageIds().get(0), getStoragePool().getId());
        ValidationResult result = new StorageDomainValidator(sd).isDomainExistAndActive();
        if (!result.isValid()) {
            log.error("Storage Domain '{}' with id '{}', could not be found for disk alias '{}' with image id '{}'", sd == null ? null : sd.getStorageName(), image.getStorageIds().get(0), image.getDiskAlias(), image.getId());
            if (!allowPartial) {
                return result;
            }
            failedDisksToImport.putIfAbsent(image.getId(), image.getDiskAlias());
            imageToDestinationDomainMap.remove(image.getId());
            images.remove(image);
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateStorageExistForUnregisteredEntity(List<DiskImage> images, boolean allowPartial, Map<Guid, Guid> imageToDestinationDomainMap, Map<Guid, String> failedDisksToImport) {
    for (DiskImage image : new ArrayList<>(images)) {
        StorageDomain sd = getStorageDomainDao().getForStoragePool(image.getStorageIds().get(0), params.getStoragePoolId());
        ValidationResult result = new StorageDomainValidator(sd).isDomainExistAndActive();
        if (!result.isValid()) {
            log.error("Storage Domain '{}' with id '{}', could not be found for disk alias '{}' with image id '{}'", sd == null ? null : sd.getStorageName(), image.getStorageIds().get(0), image.getDiskAlias(), image.getId());
            if (!allowPartial) {
                return result;
            }
            failedDisksToImport.putIfAbsent(image.getId(), image.getDiskAlias());
            imageToDestinationDomainMap.remove(image.getId());
            images.remove(image);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private Collection<Snapshot> getSnapshotsToBeExportedWithMemory() {
    if (getParameters().getCopyCollapse()) {
        Snapshot activeSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
        return activeSnapshot.containsMemory() ? Collections.singleton(activeSnapshot) : Collections.emptyList();
    } else {
        return snapshotDao.getAll(getVmId()).stream().filter(s -> s.containsMemory()).collect(Collectors.toList());
    }
}
#method_after
private Collection<Snapshot> getSnapshotsToBeExportedWithMemory() {
    if (getParameters().getCopyCollapse()) {
        Snapshot activeSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
        return activeSnapshot.containsMemory() ? Collections.singleton(activeSnapshot) : Collections.emptyList();
    } else {
        return snapshotDao.getAll(getVmId()).stream().filter(Snapshot::containsMemory).collect(Collectors.toList());
    }
}
#end_block

#method_before
private void copyAllMemoryImages(Guid containerId) {
    for (Snapshot snapshot : getVm().getSnapshots()) {
        if (!snapshot.containsMemory()) {
            continue;
        }
        // copy the memory dump image
        ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, memoryDiskDomainMap.get(snapshot.getMemoryDiskId()), snapshot.getMemoryDiskId(), getMemoryDiskImageId(snapshot.getMemoryDiskId())));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy memory image");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, memoryDiskDomainMap.get(snapshot.getMetadataDiskId()), snapshot.getMetadataDiskId(), getMemoryDiskImageId(snapshot.getMetadataDiskId())));
        if (!vdcRetValue.getSucceeded()) {
            throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy metadata image");
        }
        // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
        getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerId) {
    Set<Guid> handledMemoryDisks = new HashSet<>();
    for (Snapshot snapshot : getVm().getSnapshots()) {
        if (!snapshot.containsMemory()) {
            continue;
        }
        Guid memoryDiskId = snapshot.getMemoryDiskId();
        if (!handledMemoryDisks.contains(memoryDiskId)) {
            handledMemoryDisks.add(memoryDiskId);
            // copy the memory dump image
            ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, memoryDiskDomainMap.get(memoryDiskId), memoryDiskId, getMemoryDiskImageId(memoryDiskId)));
            if (!vdcRetValue.getSucceeded()) {
                throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy memory image");
            }
            // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
            getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
        }
        Guid confDiskId = snapshot.getMetadataDiskId();
        if (!handledMemoryDisks.contains(confDiskId)) {
            handledMemoryDisks.add(confDiskId);
            // copy the memory configuration (of the VM) image
            ActionReturnValue vdcRetValue = runInternalActionWithTasksContext(ActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, memoryDiskDomainMap.get(confDiskId), confDiskId, getMemoryDiskImageId(confDiskId)));
            if (!vdcRetValue.getSucceeded()) {
                throw new EngineException(vdcRetValue.getFault().getError(), "Failed to copy metadata image");
            }
            // TODO: Currently REST-API doesn't support coco for async commands, remove when bug 1199011 fixed
            getTaskIdList().addAll(vdcRetValue.getVdsmTaskIdList());
        }
    }
}
#end_block

#method_before
private void addMemoryImages() {
    getVm().getSnapshots().stream().filter(snapshot -> snapshot.containsMemory()).forEach(snapshot -> {
        addDisk(createMemoryDisk(snapshot));
        addDisk(createMetadataDisk(getVm(), snapshot));
    });
}
#method_after
private void addMemoryImages() {
    getVm().getSnapshots().stream().filter(Snapshot::containsMemory).forEach(snapshot -> {
        addDisk(createMemoryDisk(snapshot));
        addDisk(createMetadataDisk(getVm(), snapshot));
    });
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    checkTrustedService();
    endActionOnAllImageGroups();
    vmHandler.unLockVm(getVm());
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    checkTrustedService();
    super.endSuccessfully();
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading it form DB
    setVm(null);
    if (getVm() != null) {
        removeVmSnapshots();
        endActionOnAllImageGroups();
        removeVmNetworkInterfaces();
        vmDynamicDao.remove(getVmId());
        vmStatisticsDao.remove(getVmId());
        vmStaticDao.remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(getParameters().getVm());
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
}
#method_after
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading it form DB
    setVm(null);
    if (getVm() != null) {
        removeVmSnapshots();
        endActionOnDisks();
        removeVmNetworkInterfaces();
        vmDynamicDao.remove(getVmId());
        vmStatisticsDao.remove(getVmId());
        vmStaticDao.remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(getParameters().getVm());
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
}
#end_block

#method_before
protected boolean shouldRestoreMemory() {
    // non coherent with the memory, thus we don't want to try to restore the memory again
    return !memoryFromSnapshotUsed && (getFlow() == RunVmFlow.RESUME_HIBERNATE || FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getCompatibilityVersion())) && getActiveSnapshot().getMemoryDiskId() != null;
}
#method_after
protected boolean shouldRestoreMemory() {
    // non coherent with the memory, thus we don't want to try to restore the memory again
    return !memoryFromSnapshotUsed && (getFlow() == RunVmFlow.RESUME_HIBERNATE || FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getCompatibilityVersion())) && getActiveSnapshot().containsMemory();
}
#end_block

#method_before
protected CreateVDSCommandParameters buildCreateVmParameters() {
    CreateVDSCommandParameters parameters = new CreateVDSCommandParameters(getVdsId(), getVm());
    parameters.setRunInUnknownStatus(getParameters().isRunInUnknownStatus());
    parameters.setVmPayload(vmPayload);
    if (shouldRestoreMemory()) {
        DiskImage memoryDump = (DiskImage) diskDao.get(getActiveSnapshot().getMemoryDiskId());
        DiskImage memoryConf = (DiskImage) diskDao.get(getActiveSnapshot().getMetadataDiskId());
        if (FeatureSupported.isMemoryDisksOnDifferentDomainsSupported(getVm().getCompatibilityVersion()) && getActiveSnapshot().containsMemory()) {
            parameters.setMemoryDumpImage(memoryDump);
            parameters.setMemoryConfImage(memoryConf);
        } else {
            parameters.setHibernationVolHandle(MemoryUtils.createHibernationVolumeString(memoryDump, memoryConf));
        }
        parameters.setDownSince(getVm().getStatus() == VMStatus.Suspended ? getVm().getLastStopTime() : getActiveSnapshot().getCreationDate());
    }
    parameters.setPassthroughVnicToVfMap(flushPassthroughVnicToVfMap());
    if (initializationType == InitializationType.Sysprep && osRepository.isWindows(getVm().getVmOsId()) && (getVm().getFloppyPath() == null || "".equals(getVm().getFloppyPath()))) {
        parameters.setInitializationType(InitializationType.Sysprep);
    }
    if (initializationType == InitializationType.CloudInit && !osRepository.isWindows(getVm().getVmOsId())) {
        parameters.setInitializationType(InitializationType.CloudInit);
    }
    return parameters;
}
#method_after
protected CreateVDSCommandParameters buildCreateVmParameters() {
    CreateVDSCommandParameters parameters = new CreateVDSCommandParameters(getVdsId(), getVm());
    parameters.setRunInUnknownStatus(getParameters().isRunInUnknownStatus());
    parameters.setVmPayload(vmPayload);
    if (shouldRestoreMemory()) {
        DiskImage memoryDump = (DiskImage) diskDao.get(getActiveSnapshot().getMemoryDiskId());
        DiskImage memoryConf = (DiskImage) diskDao.get(getActiveSnapshot().getMetadataDiskId());
        if (FeatureSupported.isMemoryDisksOnDifferentDomainsSupported(getVm().getCompatibilityVersion())) {
            parameters.setMemoryDumpImage(memoryDump);
            parameters.setMemoryConfImage(memoryConf);
        } else {
            parameters.setHibernationVolHandle(MemoryUtils.createHibernationVolumeString(memoryDump, memoryConf));
        }
        parameters.setDownSince(getVm().getStatus() == VMStatus.Suspended ? getVm().getLastStopTime() : getActiveSnapshot().getCreationDate());
    }
    parameters.setPassthroughVnicToVfMap(flushPassthroughVnicToVfMap());
    if (initializationType == InitializationType.Sysprep && osRepository.isWindows(getVm().getVmOsId()) && (getVm().getFloppyPath() == null || "".equals(getVm().getFloppyPath()))) {
        parameters.setInitializationType(InitializationType.Sysprep);
    }
    if (initializationType == InitializationType.CloudInit && !osRepository.isWindows(getVm().getVmOsId())) {
        parameters.setInitializationType(InitializationType.CloudInit);
    }
    return parameters;
}
#end_block

#method_before
protected String getEffectiveEmulatedMachine() {
    if (getVm().getCustomEmulatedMachine() != null) {
        return getVm().getCustomEmulatedMachine();
    }
    // The 'default' to be set
    String recentClusterDefault = getCluster().getEmulatedMachine();
    if (getVm().getCustomCompatibilityVersion() == null) {
        return recentClusterDefault;
    }
    String bestMatch = findBestMatchForEmulatedMachine(recentClusterDefault, Config.getValue(ConfigValues.ClusterEmulatedMachines, getVm().getCustomCompatibilityVersion().getValue()));
    log.info("Emulated machine '{}' selected since Custom Compatibility Version is set for '{}'", bestMatch, getVm());
    return bestMatch;
}
#method_after
protected String getEffectiveEmulatedMachine() {
    return EmulatedMachineUtils.getEffective(getVm().getStaticData(), this::getCluster);
}
#end_block

#method_before
protected void updateVmDevicesOnRun() {
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    getVmDeviceUtils().updateVmDevicesOnRun(getVm());
}
#method_after
protected void updateVmDevicesOnRun() {
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    getVmDeviceUtils().updateVmDevicesOnRun(getVm(), this::getCluster);
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.Snapshot.class, to = Snapshot.class)
public static Snapshot map(org.ovirt.engine.core.common.businessentities.Snapshot entity, Snapshot template) {
    Snapshot model = template != null ? template : new Snapshot();
    model.setId(entity.getId().toString());
    if (entity.getDescription() != null) {
        model.setDescription(entity.getDescription());
    }
    if (entity.getCreationDate() != null) {
        model.setDate(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getStatus() != null) {
        model.setSnapshotStatus(map(entity.getStatus(), null));
    }
    if (entity.getType() != null) {
        model.setSnapshotType(map(entity.getType(), null));
    }
    if (entity.containsMemory()) {
        model.setPersistMemorystate(true);
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.Snapshot.class, to = Snapshot.class)
public static Snapshot map(org.ovirt.engine.core.common.businessentities.Snapshot entity, Snapshot template) {
    Snapshot model = template != null ? template : new Snapshot();
    model.setId(entity.getId().toString());
    if (entity.getDescription() != null) {
        model.setDescription(entity.getDescription());
    }
    if (entity.getCreationDate() != null) {
        model.setDate(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getStatus() != null) {
        model.setSnapshotStatus(map(entity.getStatus(), null));
    }
    if (entity.getType() != null) {
        model.setSnapshotType(map(entity.getType(), null));
    }
    model.setPersistMemorystate(entity.containsMemory());
    return model;
}
#end_block

#method_before
private void removeDiskImages() {
    List<DiskImage> images = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    boolean shouldWipe = false;
    for (DiskImage image : images) {
        image.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
        image.setStoragePoolId(getParameters().getStoragePoolId());
        shouldWipe |= image.isWipeAfterDelete();
    }
    List<Guid> allMemoryDisks = MemoryUtils.getMemoryDiskIdsFromSnapshots(getVm().getSnapshots());
    for (Guid memoryDiskId : allMemoryDisks) {
        DiskImage metadataDisk = createMemoryDisk(memoryDiskId, shouldWipe);
        images.add(metadataDisk);
    }
    removeVmImages(images);
}
#method_after
private void removeDiskImages() {
    List<DiskImage> images = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    boolean shouldWipe = false;
    for (DiskImage image : images) {
        image.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
        image.setStoragePoolId(getParameters().getStoragePoolId());
        shouldWipe |= image.isWipeAfterDelete();
    }
    Set<Guid> allMemoryDisks = MemoryUtils.getMemoryDiskIdsFromSnapshots(getVm().getSnapshots());
    for (Guid memoryDiskId : allMemoryDisks) {
        DiskImage metadataDisk = createMemoryDisk(memoryDiskId, shouldWipe);
        images.add(metadataDisk);
    }
    removeVmImages(images);
}
#end_block

#method_before
private void updateNetworkClusters(List<Guid> clusterInDataCenterIds, Network externalNetwork, Network networkInDataCenter) {
    Set<Guid> networkClusters = networkClusterDao.getAllForNetwork(networkInDataCenter.getId()).stream().map(NetworkCluster::getClusterId).collect(Collectors.toSet());
    List<Guid> clustersToAttach = clusterInDataCenterIds.stream().filter(id -> !networkClusters.contains(id)).collect(Collectors.toList());
    if (clustersToAttach.size() > 0) {
        propagateReturnValue(networkHelper.attachNetworkToClusters(networkInDataCenter.getId(), clustersToAttach));
    }
}
#method_after
private void updateNetworkClusters(List<Guid> clusterInDataCenterIds, Network externalNetwork, Network networkInDataCenter) {
    Set<Guid> networkClustersWithNetwork = networkClusterDao.getAllForNetwork(networkInDataCenter.getId()).stream().map(NetworkCluster::getClusterId).collect(Collectors.toSet());
    List<Guid> clustersToAttach = clusterInDataCenterIds.stream().filter(id -> !networkClustersWithNetwork.contains(id)).collect(Collectors.toList());
    if (clustersToAttach.size() > 0) {
        propagateReturnValue(networkHelper.attachNetworkToClusters(networkInDataCenter.getId(), clustersToAttach));
    }
}
#end_block

#method_before
private ActionReturnValue propagateReturnValue(ActionReturnValue internalReturnValue) {
    if (!internalReturnValue.getSucceeded()) {
        propagateFailure(internalReturnValue);
        errorOccurred = true;
    }
    return internalReturnValue;
}
#method_after
private ActionReturnValue propagateReturnValue(ActionReturnValue internalReturnValue) {
    setInternalCommandTriggered();
    if (!internalReturnValue.getSucceeded()) {
        propagateFailure(internalReturnValue);
        errorOccurred = true;
    }
    return internalReturnValue;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue("ProviderName", getProviderName());
    return getSucceeded() ? AuditLogType.PROVIDER_SYNCHRONIZED : AuditLogType.PROVIDER_SYNCHRONIZED_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue("ProviderName", getProviderName());
    if (isInternalCommandTriggered() && getSucceeded()) {
        return AuditLogType.PROVIDER_SYNCHRONIZED_PERFORMED;
    }
    if (isInternalCommandTriggered() && !getSucceeded()) {
        return AuditLogType.PROVIDER_SYNCHRONIZED_PERFORMED_FAILED;
    }
    if (!isInternalCommandTriggered() && getSucceeded()) {
        return AuditLogType.UNASSIGNED;
    }
    return AuditLogType.PROVIDER_SYNCHRONIZED_FAILED;
}
#end_block

#method_before
@Override
public String getMessage() {
    return String.format("%1$s (Failed with error %2$s and code %3$s)", super.getMessage(), privateVdsError.getCode(), privateVdsError.getCode().getValue());
}
#method_after
@Override
public String getMessage() {
    return String.format("%1$s (Failed with error %2$s and code %3$s)", super.getMessage(), useRootCause ? super.getCause().getMessage() : privateVdsError.getCode(), privateVdsError.getCode().getValue());
}
#end_block

#method_before
@Override
public String add(Network network) {
    com.woorea.openstack.quantum.model.Network networkForCreate = createNewNetworkEntity(network);
    try {
        com.woorea.openstack.quantum.model.Network createdNetwork = getClient().networks().create(networkForCreate).execute();
        return createdNetwork.getId();
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e, true);
    }
}
#method_after
@Override
public String add(Network network) {
    com.woorea.openstack.quantum.model.Network networkForCreate = createNewNetworkEntity(network);
    com.woorea.openstack.quantum.model.Network createdNetwork = execute(getClient().networks().create(networkForCreate));
    return createdNetwork.getId();
}
#end_block

#method_before
@Override
public void remove(String id) {
    try {
        getClient().networks().delete(id).execute();
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e, true);
    }
}
#method_after
@Override
public void remove(String id) {
    execute(getClient().networks().delete(id));
}
#end_block

#method_before
@Override
public List<Network> getAll() {
    try {
        Networks networks = getClient().networks().list().execute();
        return map(networks.getList());
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e, true);
    }
}
#method_after
@Override
public List<Network> getAll() {
    Networks networks = execute(getClient().networks().list());
    return map(networks.getList());
}
#end_block

#method_before
@Override
public List<ExternalSubnet> getAllSubnets(ProviderNetwork network) {
    List<ExternalSubnet> result = new ArrayList<>();
    Subnets subnets = getClient().subnets().list().execute();
    for (Subnet subnet : subnets.getList()) {
        if (network.getExternalId().equals(subnet.getNetworkId())) {
            result.add(map(subnet, network));
        }
    }
    return result;
}
#method_after
@Override
public List<ExternalSubnet> getAllSubnets(ProviderNetwork network) {
    List<ExternalSubnet> result = new ArrayList<>();
    Subnets subnets = execute(getClient().subnets().list());
    for (Subnet subnet : subnets.getList()) {
        if (network.getExternalId().equals(subnet.getNetworkId())) {
            result.add(map(subnet, network));
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void addSubnet(ExternalSubnet subnet) {
    com.woorea.openstack.quantum.model.Network externalNetwork = getExternalNetwork(subnet.getExternalNetwork());
    Subnet subnetForCreate = createNewSubnetEntity(subnet, externalNetwork);
    try {
        getClient().subnets().create(subnetForCreate).execute();
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e, true);
    }
}
#method_after
@Override
public void addSubnet(ExternalSubnet subnet) {
    com.woorea.openstack.quantum.model.Network externalNetwork = getExternalNetwork(subnet.getExternalNetwork());
    Subnet subnetForCreate = createNewSubnetEntity(subnet, externalNetwork);
    execute(getClient().subnets().create(subnetForCreate));
}
#end_block

#method_before
@Override
public void removeSubnet(String id) {
    try {
        getClient().subnets().delete(id).execute();
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e, true);
    }
}
#method_after
@Override
public void removeSubnet(String id) {
    execute(getClient().subnets().delete(id));
}
#end_block

#method_before
@Override
public void testConnection() {
    try {
        getClient().execute(new OpenStackRequest<>(getClient(), HttpMethod.GET, "", null, ApiRootResponse.class));
    } catch (OpenStackResponseException e) {
        log.error("{} (OpenStack response error code: {})", e.getMessage(), e.getStatus());
        log.debug("Exception", e);
        throw new EngineException(EngineError.PROVIDER_FAILURE, e, true);
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e, true);
    }
}
#method_after
@Override
public void testConnection() {
    execute(new OpenStackRequest<>(getClient(), HttpMethod.GET, "", null, ApiRootResponse.class));
}
#end_block

#method_before
@Override
public Map<String, String> allocate(Network network, VnicProfile vnicProfile, VmNic nic, VDS host, boolean ignoreSecurityGroupsOnUpdate) {
    try {
        Port port = locatePort(nic);
        List<String> securityGroups = getSecurityGroups(vnicProfile);
        String hostId = getHostId(host);
        if (port == null) {
            com.woorea.openstack.quantum.model.Network externalNetwork = getExternalNetwork(network.getProvidedBy());
            Port portForCreate = createNewPortForAllocate(nic, securityGroups, hostId, externalNetwork);
            port = getClient().ports().create(portForCreate).execute();
        } else {
            boolean securityGroupsChanged = !ignoreSecurityGroupsOnUpdate && securityGroupsChanged(port.getSecurityGroups(), securityGroups);
            boolean hostChanged = hostChanged(port, hostId);
            updatePort(port, securityGroupsChanged, hostChanged, securityGroups, hostId, nic);
        }
        Map<String, String> runtimeProperties = createPortAllocationRuntimeProperties(port);
        return runtimeProperties;
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e, true);
    }
}
#method_after
@Override
public Map<String, String> allocate(Network network, VnicProfile vnicProfile, VmNic nic, VDS host, boolean ignoreSecurityGroupsOnUpdate) {
    Port port = locatePort(nic);
    List<String> securityGroups = getSecurityGroups(vnicProfile);
    String hostId = getHostId(host);
    if (port == null) {
        com.woorea.openstack.quantum.model.Network externalNetwork = getExternalNetwork(network.getProvidedBy());
        Port portForCreate = createNewPortForAllocate(nic, securityGroups, hostId, externalNetwork);
        port = execute(getClient().ports().create(portForCreate));
    } else {
        boolean securityGroupsChanged = !ignoreSecurityGroupsOnUpdate && securityGroupsChanged(port.getSecurityGroups(), securityGroups);
        boolean hostChanged = hostChanged(port, hostId);
        updatePort(port, securityGroupsChanged, hostChanged, securityGroups, hostId, nic);
    }
    Map<String, String> runtimeProperties = createPortAllocationRuntimeProperties(port);
    return runtimeProperties;
}
#end_block

#method_before
private Port updatePort(Port port, boolean securityGroupsChanged, boolean hostChanged, List<String> securityGroups, String hostId, VmNic nic) {
    if (securityGroupsChanged || hostChanged) {
        List<String> modifiedSecurityGroups = securityGroupsChanged ? securityGroups : port.getSecurityGroups();
        Port portForUpdate = modifyPortForAllocate(port, hostId, hostChanged, securityGroupsChanged, modifiedSecurityGroups, nic.getMacAddress());
        return getClient().ports().update(portForUpdate).execute();
    }
    return port;
}
#method_after
private Port updatePort(Port port, boolean securityGroupsChanged, boolean hostChanged, List<String> securityGroups, String hostId, VmNic nic) {
    if (securityGroupsChanged || hostChanged) {
        List<String> modifiedSecurityGroups = securityGroupsChanged ? securityGroups : port.getSecurityGroups();
        Port portForUpdate = modifyPortForAllocate(port, hostId, hostChanged, securityGroupsChanged, modifiedSecurityGroups, nic.getMacAddress());
        return execute(getClient().ports().update(portForUpdate));
    }
    return port;
}
#end_block

#method_before
private com.woorea.openstack.quantum.model.Network getExternalNetwork(ProviderNetwork providerNetwork) {
    return getClient().networks().show(providerNetwork.getExternalId()).execute();
}
#method_after
private com.woorea.openstack.quantum.model.Network getExternalNetwork(ProviderNetwork providerNetwork) {
    return execute(getClient().networks().show(providerNetwork.getExternalId()));
}
#end_block

#method_before
@Override
public void deallocate(VmNic nic) {
    try {
        Port port = locatePort(nic);
        if (port != null) {
            getClient().ports().delete(port.getId()).execute();
        }
    } catch (RuntimeException e) {
        throw new EngineException(EngineError.PROVIDER_FAILURE, e, true);
    }
}
#method_after
@Override
public void deallocate(VmNic nic) {
    Port port = locatePort(nic);
    if (port != null) {
        execute(getClient().ports().delete(port.getId()));
    }
}
#end_block

#method_before
private Port locatePort(VmNic nic) {
    List<Port> ports = getClient().ports().list().execute().getList();
    for (Port port : ports) {
        if (DEVICE_OWNER.equals(port.getDeviceOwner()) && nic.getId().toString().equals(port.getDeviceId())) {
            return port;
        }
    }
    return null;
}
#method_after
private Port locatePort(VmNic nic) {
    List<Port> ports = execute(getClient().ports().list()).getList();
    for (Port port : ports) {
        if (DEVICE_OWNER.equals(port.getDeviceOwner()) && nic.getId().toString().equals(port.getDeviceId())) {
            return port;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getParameters().getRefresh() || getSessionDataContainer().isSsoOvirtAppApiScope(getParameters().getSessionId())) {
        getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    }
    if (validatePermissions()) {
        if (validateInputs()) {
            long start = System.currentTimeMillis();
            try {
                returnValue.setSucceeded(true);
                executeQueryCommand();
            } catch (RuntimeException ex) {
                returnValue.setSucceeded(false);
                Throwable th = ex instanceof EngineException ? ex : ex.getCause();
                if (th instanceof EngineException) {
                    EngineException vdcExc = (EngineException) th;
                    if (vdcExc.getErrorCode() != null && !vdcExc.isUseRootCause()) {
                        returnValue.setExceptionString(vdcExc.getErrorCode().toString());
                    } else {
                        returnValue.setExceptionString(vdcExc.isUseRootCause() ? ExceptionUtils.getRootCauseMessage(vdcExc) : vdcExc.getMessage());
                    }
                    log.error("Query '{}' failed: {}", getClass().getSimpleName(), vdcExc.isUseRootCause() ? ExceptionUtils.getRootCauseMessage(vdcExc) : vdcExc.getMessage());
                    log.error("Exception", vdcExc);
                } else {
                    returnValue.setExceptionString(ex.getMessage());
                    log.error("Query '{}' failed: {}", getClass().getSimpleName(), ex.getMessage());
                    log.error("Exception", ex);
                }
            } finally {
                log.debug("Query {} took {} ms", getCommandName(), System.currentTimeMillis() - start);
            }
        } else {
            log.error("Query execution failed due to invalid inputs: {}", returnValue.getExceptionString());
        }
    } else {
        String errMessage = "Query execution failed due to insufficient permissions.";
        log.error(errMessage);
        returnValue.setExceptionString(errMessage);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getParameters().getRefresh() || getSessionDataContainer().isSsoOvirtAppApiScope(getParameters().getSessionId())) {
        getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    }
    if (validatePermissions()) {
        if (validateInputs()) {
            long start = System.currentTimeMillis();
            try {
                returnValue.setSucceeded(true);
                executeQueryCommand();
            } catch (RuntimeException ex) {
                returnValue.setSucceeded(false);
                Throwable th = ex instanceof EngineException ? ex : ex.getCause();
                if (th instanceof EngineException) {
                    EngineException vdcExc = (EngineException) th;
                    if (vdcExc.getErrorCode() != null && !vdcExc.isUseRootCause()) {
                        returnValue.setExceptionString(vdcExc.getErrorCode().toString());
                    } else {
                        returnValue.setExceptionString(vdcExc.getMessage());
                    }
                    log.error("Query '{}' failed: {}", getClass().getSimpleName(), vdcExc.getMessage());
                    log.error("Exception", vdcExc);
                } else {
                    returnValue.setExceptionString(ex.getMessage());
                    log.error("Query '{}' failed: {}", getClass().getSimpleName(), ex.getMessage());
                    log.error("Exception", ex);
                }
            } finally {
                log.debug("Query {} took {} ms", getCommandName(), System.currentTimeMillis() - start);
            }
        } else {
            log.error("Query execution failed due to invalid inputs: {}", returnValue.getExceptionString());
        }
    } else {
        String errMessage = "Query execution failed due to insufficient permissions.";
        log.error(errMessage);
        returnValue.setExceptionString(errMessage);
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(dbUserDao.getAnyUserById(getParameters().getId()));
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(dbUserDao.get(getParameters().getId(), false));
}
#end_block

#method_before
public ValidationResult isIsoDiskAttachedToAnyNonDownVm() {
    List<String> vmNames = DbFacade.getInstance().getVmStaticDao().getAllRunningNamesWithSpecificIsoAttached(disk.getId());
    if (!vmNames.isEmpty()) {
        return new ValidationResult(EngineMessage.ERROR_ISO_DISK_ATTACHED_TO_RUNNING_VMS, ReplacementUtils.createSetVariableString(DISK_NAME_VARIABLE, disk.getDiskAlias()), ReplacementUtils.createSetVariableString(VM_LIST, vmNames));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isIsoDiskAttachedToAnyNonDownVm() {
    List<String> vmNames = DbFacade.getInstance().getVmDao().getAllRunningNamesWithSpecificIsoAttached(disk.getId());
    if (!vmNames.isEmpty()) {
        return new ValidationResult(EngineMessage.ERROR_ISO_DISK_ATTACHED_TO_RUNNING_VMS, ReplacementUtils.createSetVariableString(DISK_NAME_VARIABLE, disk.getDiskAlias()), ReplacementUtils.createSetVariableString(VM_LIST, vmNames));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected boolean validate() {
    return super.validate() && diskContainsPreExtendSnapshots() && isImageExist() && checkOperationIsCorrect() && checkOperationAllowedOnDiskContentType() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && validateVmSnapshotStatus() && checkCanBeMoveInVm() && checkIfNeedToBeOverride() && setAndValidateDiskProfiles() && setAndValidateQuota() && validatePassDiscardSupportedForDestinationStorageDomain();
}
#method_after
@Override
protected boolean validate() {
    return super.validate() && diskContainsPreExtendSnapshots() && isImageExist() && checkOperationIsCorrect() && checkOperationAllowedOnDiskContentType() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateDiskExistAndValidInDestStorageDomain() && validateSpaceRequirements() && validateVmSnapshotStatus() && checkCanBeMoveInVm() && checkIfNeedToBeOverride() && setAndValidateDiskProfiles() && setAndValidateQuota() && validatePassDiscardSupportedForDestinationStorageDomain();
}
#end_block

#method_before
private boolean diskContainsPreExtendSnapshots() {
    return validate(createDiskValidator(getImage()).diskWasExtendedAfterSnapshotWasTaken(getStorageDomain()));
}
#method_after
private boolean diskContainsPreExtendSnapshots() {
    return validate(createDiskImagesValidator(getImage()).childDiskWasExtended(getStorageDomain()));
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    if (isCopyOperation()) {
        if (!Guid.Empty.equals(getVmTemplateId())) {
            return Collections.singletonMap(getVmTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, getDiskIsBeingMigratedMessage()));
        }
    } else {
        if (getImage().getContentType() == DiskContentType.ISO) {
            List<Guid> vmIds = vmStaticDao.getAllIdsWithSpecificIsoAttached(getImage().getId());
            if (!vmIds.isEmpty()) {
                return vmIds.stream().collect(Collectors.toMap(p -> p.toString(), p -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, getDiskIsBeingMigratedMessage())));
            }
        } else {
            List<Pair<VM, VmDevice>> vmsForDisk = getVmsWithVmDeviceInfoForDiskId();
            if (!vmsForDisk.isEmpty()) {
                return vmsForDisk.stream().collect(Collectors.toMap(p -> p.getFirst().getId().toString(), p -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, getDiskIsBeingMigratedMessage())));
            }
        }
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    if (isCopyOperation()) {
        if (!Guid.Empty.equals(getVmTemplateId())) {
            return Collections.singletonMap(getVmTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, getDiskIsBeingMigratedMessage()));
        }
    } else {
        if (getImage().getContentType() == DiskContentType.ISO) {
            List<Guid> vmIds = vmDynamicDao.getAllIdsWithSpecificIsoAttached(getImage().getId());
            if (!vmIds.isEmpty()) {
                return vmIds.stream().collect(Collectors.toMap(p -> p.toString(), p -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, getDiskIsBeingMigratedMessage())));
            }
        } else {
            List<Pair<VM, VmDevice>> vmsForDisk = getVmsWithVmDeviceInfoForDiskId();
            if (!vmsForDisk.isEmpty()) {
                return vmsForDisk.stream().collect(Collectors.toMap(p -> p.getFirst().getId().toString(), p -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, getDiskIsBeingMigratedMessage())));
            }
        }
    }
    return null;
}
#end_block

#method_before
public void addSecondaryMenu(String label, String historyToken, String contentUrl, String primaryMenuId, TabOptions options) {
    addContentView(label, historyToken, contentUrl, primaryMenuId, options.getIcon(), options.getPriority().intValue(), options.getDefaultPlace().booleanValue());
}
#method_after
public void addSecondaryMenu(String primaryMenuId, String label, String historyToken, String contentUrl, TabOptions options) {
    addContentView(label, historyToken, contentUrl, primaryMenuId, options.getIcon(), options.getPriority().intValue(), options.getDefaultPlace().booleanValue());
}
#end_block

#method_before
public void addContentView(String label, String historyToken, String contentUrl, String primaryMenuId, String iconCssName, int priority, boolean defaultPlace) {
    menuPresenterWidget.addMenuItem(priority, label, historyToken, primaryMenuId, iconCssName);
    // Not interested in the actual proxy, it will register itself.
    dynamicUrlContentProxyFactory.create(historyToken, contentUrl);
    placeManager.setDefaultPlace(historyToken);
}
#method_after
public void addContentView(String label, String historyToken, String contentUrl, String primaryMenuId, String iconCssName, int priority, boolean defaultPlace) {
    menuPresenterWidget.addMenuItemPlace(priority, label, historyToken, primaryMenuId, iconCssName);
    // Not interested in the actual proxy, it will register itself.
    dynamicUrlContentProxyFactory.create(historyToken, contentUrl);
    placeManager.setDefaultPlace(historyToken);
}
#end_block

#method_before
void addTab(Type<RequestTabsHandler> requestTabsEventType, Type<ChangeTabHandler> changeTabEventType, Type<RevealContentHandler<?>> slot, String label, String historyToken, String contentUrl, TabOptions options) {
    // Create and bind tab presenter proxy
    dynamicUrlContentTabProxyFactory.create(requestTabsEventType, changeTabEventType, slot, label, options.getPriority().floatValue(), historyToken, contentUrl, options.getAlignRight() ? Align.RIGHT : Align.LEFT, options.getSearchPrefix());
    // Redraw the corresponding tab container
    RedrawDynamicTabContainerEvent.fire(this, requestTabsEventType);
}
#method_after
void addTab(Type<RequestTabsHandler> requestTabsEventType, Type<ChangeTabHandler> changeTabEventType, Type<RevealContentHandler<?>> slot, String label, String historyToken, String contentUrl, TabOptions options) {
    // Create and bind tab presenter proxy
    dynamicUrlContentTabProxyFactory.create(requestTabsEventType, changeTabEventType, slot, label, options.getPriority().floatValue(), historyToken, contentUrl, options.getSearchPrefix());
    // Redraw the corresponding tab container
    RedrawDynamicTabContainerEvent.fire(this, requestTabsEventType);
}
#end_block

#method_before
private void setTargetAndId() {
    computeSecondaryItem.getElement().setAttribute(Attributes.DATA_TARGET, hashifyString(COMPUTE + SECONDARY_POST_FIX));
    computeSecondaryContainer.getElement().setAttribute(ID, COMPUTE + SECONDARY_POST_FIX);
    computeSecondaryHeader.getElement().setAttribute(Attributes.DATA_TOGGLE, PatternflyStyles.NAV_COLLAPSE_SECONDARY_NAV);
    // $NON-NLS-1$
    String primaryComputeId = "id-" + COMPUTE;
    computePrimaryHeader.getElement().setAttribute(ID, primaryComputeId);
    primaryMenuIds.add(primaryComputeId);
    networkSecondaryItem.getElement().setAttribute(Attributes.DATA_TARGET, hashifyString(NETWORK + SECONDARY_POST_FIX));
    networkSecondaryContainer.getElement().setAttribute(ID, NETWORK + SECONDARY_POST_FIX);
    networkSecondaryHeader.getElement().setAttribute(Attributes.DATA_TOGGLE, PatternflyStyles.NAV_COLLAPSE_SECONDARY_NAV);
    // $NON-NLS-1$
    String primaryNetworkId = "id-" + NETWORK;
    networkPrimaryHeader.getElement().setAttribute(ID, primaryNetworkId);
    primaryMenuIds.add(primaryNetworkId);
    storageSecondaryItem.getElement().setAttribute(Attributes.DATA_TARGET, hashifyString(STORAGE + SECONDARY_POST_FIX));
    storageSecondaryContainer.getElement().setAttribute(ID, STORAGE + SECONDARY_POST_FIX);
    storageSecondaryHeader.getElement().setAttribute(Attributes.DATA_TOGGLE, PatternflyStyles.NAV_COLLAPSE_SECONDARY_NAV);
    // $NON-NLS-1$
    String primaryStorageId = "id-" + STORAGE;
    storagePrimaryHeader.getElement().setAttribute(ID, primaryStorageId);
    primaryMenuIds.add(primaryStorageId);
    administrationSecondaryItem.getElement().setAttribute(Attributes.DATA_TARGET, hashifyString(ADMINISTRATION + SECONDARY_POST_FIX));
    administrationSecondaryContainer.getElement().setAttribute(ID, ADMINISTRATION + SECONDARY_POST_FIX);
    administrationSecondaryHeader.getElement().setAttribute(Attributes.DATA_TOGGLE, PatternflyStyles.NAV_COLLAPSE_SECONDARY_NAV);
    // $NON-NLS-1$
    String primaryAdministrationId = "id-" + ADMINISTRATION;
    administrationPrimaryHeader.getElement().setAttribute(ID, primaryAdministrationId);
    primaryMenuIds.add(primaryAdministrationId);
    // $NON-NLS-1$
    primaryMenuIds.add("id-" + EVENTS);
}
#method_after
private void setTargetAndId() {
    computeSecondaryItem.getElement().setAttribute(Attributes.DATA_TARGET, hashifyString(PrimaryMenuContainerType.COMPUTE.getId() + SECONDARY_POST_FIX));
    computeSecondaryContainer.getElement().setAttribute(ID, PrimaryMenuContainerType.COMPUTE.getId() + SECONDARY_POST_FIX);
    computeSecondaryHeader.getElement().setAttribute(Attributes.DATA_TOGGLE, PatternflyStyles.NAV_COLLAPSE_SECONDARY_NAV);
    computePrimaryHeader.getElement().setAttribute(ID, PrimaryMenuContainerType.COMPUTE.getId());
    networkSecondaryItem.getElement().setAttribute(Attributes.DATA_TARGET, hashifyString(PrimaryMenuContainerType.NETWORK.getId() + SECONDARY_POST_FIX));
    networkSecondaryContainer.getElement().setAttribute(ID, PrimaryMenuContainerType.NETWORK.getId() + SECONDARY_POST_FIX);
    networkSecondaryHeader.getElement().setAttribute(Attributes.DATA_TOGGLE, PatternflyStyles.NAV_COLLAPSE_SECONDARY_NAV);
    storageSecondaryItem.getElement().setAttribute(Attributes.DATA_TARGET, hashifyString(PrimaryMenuContainerType.STORAGE.getId() + SECONDARY_POST_FIX));
    storageSecondaryContainer.getElement().setAttribute(ID, PrimaryMenuContainerType.STORAGE.getId() + SECONDARY_POST_FIX);
    storageSecondaryHeader.getElement().setAttribute(Attributes.DATA_TOGGLE, PatternflyStyles.NAV_COLLAPSE_SECONDARY_NAV);
    administrationSecondaryItem.getElement().setAttribute(Attributes.DATA_TARGET, hashifyString(PrimaryMenuContainerType.ADMINISTRATION.getId() + SECONDARY_POST_FIX));
    administrationSecondaryContainer.getElement().setAttribute(ID, PrimaryMenuContainerType.ADMINISTRATION.getId() + SECONDARY_POST_FIX);
    administrationSecondaryHeader.getElement().setAttribute(Attributes.DATA_TOGGLE, PatternflyStyles.NAV_COLLAPSE_SECONDARY_NAV);
}
#end_block

#method_before
void defineAndLoadPlugin(PluginMetaData pluginMetaData) {
    String pluginName = pluginMetaData.getName();
    String pluginHostPageUrl = pluginMetaData.getHostPageUrl();
    if (pluginName == null || pluginName.trim().isEmpty()) {
        // $NON-NLS-1$
        logger.warning("Plugin name cannot be null or empty");
        return;
    } else if (pluginHostPageUrl == null || pluginHostPageUrl.trim().isEmpty()) {
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.warning("Plugin [" + pluginName + "] has null or empty host page URL");
        return;
    } else if (getPlugin(pluginName) != null) {
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.warning("Plugin [" + pluginName + "] is already defined");
        return;
    }
    // Create an iframe element used to load the plugin host page
    IFrameElement iframe = Document.get().createIFrameElement();
    iframe.setSrc(pluginHostPageUrl);
    iframe.setFrameBorder(0);
    iframe.getStyle().setPosition(Position.ABSOLUTE);
    iframe.getStyle().setWidth(0, Unit.PT);
    iframe.getStyle().setHeight(0, Unit.PT);
    iframe.getStyle().setBorderStyle(BorderStyle.NONE);
    Plugin plugin = new Plugin(pluginMetaData, iframe);
    addPlugin(plugin);
    // $NON-NLS-1$ //$NON-NLS-2$
    logger.info("Plugin [" + pluginName + "] is defined to be loaded from URL " + pluginHostPageUrl);
    // Load the plugin host page
    if (pluginMetaData.isEnabled()) {
        loadPlugin(plugin);
        if (plugin.shouldPreLoad()) {
            pluginsToPreLoad.put(pluginName, false);
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.info("Plugin [" + pluginName + "] will be pre-loaded");
        }
    }
}
#method_after
void defineAndLoadPlugin(PluginMetaData pluginMetaData) {
    String pluginName = pluginMetaData.getName();
    String pluginHostPageUrl = pluginMetaData.getHostPageUrl();
    if (pluginName == null || pluginName.trim().isEmpty()) {
        // $NON-NLS-1$
        logger.warning("Plugin name cannot be null or empty");
        return;
    } else if (pluginHostPageUrl == null || pluginHostPageUrl.trim().isEmpty()) {
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.warning("Plugin [" + pluginName + "] has null or empty host page URL");
        return;
    } else if (getPlugin(pluginName) != null) {
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.warning("Plugin [" + pluginName + "] is already defined");
        return;
    }
    // Create an iframe element used to load the plugin host page
    IFrameElement iframe = Document.get().createIFrameElement();
    iframe.setSrc(pluginHostPageUrl);
    iframe.setFrameBorder(0);
    iframe.getStyle().setPosition(Position.ABSOLUTE);
    iframe.getStyle().setWidth(0, Unit.PT);
    iframe.getStyle().setHeight(0, Unit.PT);
    iframe.getStyle().setBorderStyle(BorderStyle.NONE);
    Plugin plugin = new Plugin(pluginMetaData, iframe);
    addPlugin(plugin);
    // $NON-NLS-1$ //$NON-NLS-2$
    logger.fine("Plugin [" + pluginName + "] is defined to be loaded from URL " + pluginHostPageUrl);
    // Load the plugin host page
    if (pluginMetaData.isEnabled()) {
        loadPlugin(plugin);
        if (plugin.shouldPreLoad()) {
            pluginsToPreLoad.put(pluginName, false);
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.fine("Plugin [" + pluginName + "] will be pre-loaded");
        }
    }
}
#end_block

#method_before
void loadPlugin(Plugin plugin) {
    if (plugin.isInState(PluginState.DEFINED)) {
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.info("Loading plugin [" + plugin.getName() + "]");
        Document.get().getBody().appendChild(plugin.getIFrameElement());
        plugin.markAsLoading();
    }
}
#method_after
void loadPlugin(Plugin plugin) {
    if (plugin.isInState(PluginState.DEFINED)) {
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.fine("Loading plugin [" + plugin.getName() + "]");
        Document.get().getBody().appendChild(plugin.getIFrameElement());
        plugin.markAsLoading();
    }
}
#end_block

#method_before
boolean invokePlugin(final Plugin plugin, final String functionName, JsArray<?> functionArgs) {
    final String pluginName = plugin.getName();
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    logger.info("Invoking event handler function [" + functionName + "] for plugin [" + pluginName + "]");
    return plugin.getEventHandlerFunction(functionName).invoke(functionArgs, message -> {
        logger.severe(// $NON-NLS-1$
        "Exception caught while invoking event handler function [" + functionName + "] for plugin [" + pluginName + "]: " + // $NON-NLS-1$ //$NON-NLS-2$
        message);
        // Remove the given plugin from service
        Document.get().getBody().removeChild(plugin.getIFrameElement());
        plugin.markAsFailed();
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.warning("Plugin [" + pluginName + "] removed from service due to failure");
    });
}
#method_after
boolean invokePlugin(final Plugin plugin, final String functionName, JsArray<?> functionArgs) {
    final String pluginName = plugin.getName();
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    logger.fine("Invoking event handler function [" + functionName + "] for plugin [" + pluginName + "]");
    return plugin.getEventHandlerFunction(functionName).invoke(functionArgs, message -> {
        logger.severe(// $NON-NLS-1$
        "Exception caught while invoking event handler function [" + functionName + "] for plugin [" + pluginName + "]: " + // $NON-NLS-1$ //$NON-NLS-2$
        message);
        // Remove the given plugin from service
        Document.get().getBody().removeChild(plugin.getIFrameElement());
        plugin.markAsFailed();
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.warning("Plugin [" + pluginName + "] removed from service due to failure");
    });
}
#end_block

#method_before
void registerPluginEventHandlerObject(String pluginName, JavaScriptObject eventHandlerObject) {
    Plugin plugin = getPlugin(pluginName);
    if (plugin == null || eventHandlerObject == null) {
        return;
    }
    // Allow plugin event handler object to be set only once
    if (plugin.getEventHandlerObject() == null) {
        plugin.setEventHandlerObject(eventHandlerObject);
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.info("Plugin [" + pluginName + "] has registered the event handler object");
    } else {
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.warning("Plugin [" + pluginName + "] has already registered the event handler object");
    }
}
#method_after
void registerPluginEventHandlerObject(String pluginName, JavaScriptObject eventHandlerObject) {
    Plugin plugin = getPlugin(pluginName);
    if (plugin == null || eventHandlerObject == null) {
        return;
    }
    // Allow plugin event handler object to be set only once
    if (plugin.getEventHandlerObject() == null) {
        plugin.setEventHandlerObject(eventHandlerObject);
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.fine("Plugin [" + pluginName + "] has registered the event handler object");
    } else {
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.warning("Plugin [" + pluginName + "] has already registered the event handler object");
    }
}
#end_block

#method_before
void registerPluginApiOptionsObject(String pluginName, ApiOptions apiOptionsObject) {
    Plugin plugin = getPlugin(pluginName);
    if (plugin == null || apiOptionsObject == null) {
        return;
    }
    plugin.setApiOptionsObject(apiOptionsObject);
    // $NON-NLS-1$ //$NON-NLS-2$
    logger.info("Plugin [" + pluginName + "] has registered custom API options object");
}
#method_after
void registerPluginApiOptionsObject(String pluginName, ApiOptions apiOptionsObject) {
    Plugin plugin = getPlugin(pluginName);
    if (plugin == null || apiOptionsObject == null) {
        return;
    }
    plugin.setApiOptionsObject(apiOptionsObject);
    // $NON-NLS-1$ //$NON-NLS-2$
    logger.fine("Plugin [" + pluginName + "] has registered custom API options object");
}
#end_block

#method_before
void pluginReady(String pluginName) {
    Plugin plugin = getPlugin(pluginName);
    if (plugin != null && plugin.isInState(PluginState.LOADING)) {
        if (plugin.getEventHandlerObject() == null) {
            logger.warning(// $NON-NLS-1$
            "Plugin [" + pluginName + // $NON-NLS-1$
            "] reports in as ready, but has no event handler object assigned");
            return;
        }
        plugin.markAsReady();
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.info("Plugin [" + pluginName + "] reports in as ready");
        // Initialize the plugin once it's ready
        initPlugin(plugin);
        if (plugin.shouldPreLoad()) {
            pluginsToPreLoad.put(pluginName, true);
        }
        maybeInvokePluginsReadyCallback();
    }
}
#method_after
void pluginReady(String pluginName) {
    Plugin plugin = getPlugin(pluginName);
    if (plugin != null && plugin.isInState(PluginState.LOADING)) {
        if (plugin.getEventHandlerObject() == null) {
            logger.warning(// $NON-NLS-1$
            "Plugin [" + pluginName + // $NON-NLS-1$
            "] reports in as ready, but has no event handler object assigned");
            return;
        }
        plugin.markAsReady();
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.fine("Plugin [" + pluginName + "] reports in as ready");
        // Initialize the plugin once it's ready
        initPlugin(plugin);
        if (plugin.shouldPreLoad()) {
            pluginsToPreLoad.put(pluginName, true);
        }
        maybeInvokePluginsReadyCallback();
    }
}
#end_block

#method_before
void initPlugin(Plugin plugin) {
    String pluginName = plugin.getName();
    // Try to invoke UiInit event handler function
    if (plugin.isInState(PluginState.READY)) {
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.info("Initializing plugin [" + pluginName + "]");
        plugin.markAsInitializing();
        if (invokePlugin(plugin, "UiInit", null)) {
            // $NON-NLS-1$
            plugin.markAsInUse();
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.info("Plugin [" + pluginName + "] is initialized and in use now");
        }
    }
    // Try to invoke all event handler functions scheduled for this plugin
    if (plugin.isInState(PluginState.IN_USE)) {
        invokeScheduledFunctionCommands(pluginName);
    }
}
#method_after
void initPlugin(Plugin plugin) {
    String pluginName = plugin.getName();
    // Try to invoke UiInit event handler function
    if (plugin.isInState(PluginState.READY)) {
        // $NON-NLS-1$ //$NON-NLS-2$
        logger.fine("Initializing plugin [" + pluginName + "]");
        plugin.markAsInitializing();
        if (invokePlugin(plugin, "UiInit", null)) {
            // $NON-NLS-1$
            plugin.markAsInUse();
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.fine("Plugin [" + pluginName + "] is initialized and in use now");
        }
    }
    // Try to invoke all event handler functions scheduled for this plugin
    if (plugin.isInState(PluginState.IN_USE)) {
        invokeScheduledFunctionCommands(pluginName);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    return super.validate() && diskContainsPreExtendSnapshots() && isImageExist() && checkOperationIsCorrect() && checkOperationAllowedOnDiskContentType() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && validateVmSnapshotStatus() && checkCanBeMoveInVm() && checkIfNeedToBeOverride() && setAndValidateDiskProfiles() && setAndValidateQuota() && validatePassDiscardSupportedForDestinationStorageDomain();
}
#method_after
@Override
protected boolean validate() {
    return super.validate() && diskContainsPreExtendSnapshots() && isImageExist() && checkOperationIsCorrect() && checkOperationAllowedOnDiskContentType() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateDiskExistAndValidInDestStorageDomain() && validateSpaceRequirements() && validateVmSnapshotStatus() && checkCanBeMoveInVm() && checkIfNeedToBeOverride() && setAndValidateDiskProfiles() && setAndValidateQuota() && validatePassDiscardSupportedForDestinationStorageDomain();
}
#end_block

#method_before
protected boolean checkOperationAllowedOnDiskContentType() {
    return validate(new DiskOperationsValidator(getImage()).isOperationAllowedOnDisk(getActionType()));
}
#method_after
protected boolean checkOperationAllowedOnDiskContentType() {
    if (getImage().getContentType() == DiskContentType.MEMORY_DUMP_VOLUME || getImage().getContentType() == DiskContentType.MEMORY_METADATA_VOLUME) {
        if (!FeatureSupported.isMemoryDisksOnDifferentDomainsSupported(getStoragePool().getCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_CONTENT_TYPE_NOT_SUPPORTED_FOR_OPERATION, String.format("$diskContentType %s", getImage().getContentType()));
        }
    }
    return validate(new DiskOperationsValidator(getImage()).isOperationAllowedOnDisk(getActionType()));
}
#end_block

#method_before
private boolean diskContainsPreExtendSnapshots() {
    return validate(createDiskValidator(getImage()).childDiskWasExtended(getStorageDomain()));
}
#method_after
private boolean diskContainsPreExtendSnapshots() {
    return validate(createDiskImagesValidator(getImage()).childDiskWasExtended(getStorageDomain()));
}
#end_block

#method_before
@Before
public void setUp() {
    disk = createDiskImage();
    disk.setDiskAlias("disk1");
    validator = spy(new DiskValidator(disk));
    doReturn(vmDao).when(validator).getVmDao();
    doReturn(diskImageDao).when(validator).getDiskImageDao();
}
#method_after
@Before
public void setUp() {
    disk = createDiskImage();
    disk.setDiskAlias("disk1");
    validator = spy(new DiskValidator(disk));
    diskImagesValidator = spy(new DiskImagesValidator(disk));
    doReturn(vmDao).when(validator).getVmDao();
    doReturn(diskImageDao).when(validator).getDiskImageDao();
    doReturn(diskImageDao).when(diskImagesValidator).getDiskImageDao();
}
#end_block

#method_before
@Test
public void canCopyDiskFails() {
    StorageDomain domain = createStorageDomainForDisk(StorageType.ISCSI);
    domain.setStorageFormat(StorageFormatType.V3);
    disk.setSize(1000);
    DiskImage child = createDiskImage();
    child.setSize(1000);
    child.setStorageIds(Collections.singletonList(domain.getId()));
    DiskImage parent = createDiskImage();
    parent.setId(Guid.newGuid());
    parent.setSize(500);
    parent.setStorageIds(Collections.singletonList(domain.getId()));
    child.setParentId(parent.getParentId());
    List<DiskImage> diskImages = new ArrayList<>(2);
    diskImages.add(parent);
    diskImages.add(child);
    when(validator.getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId())).thenReturn(diskImages);
    assertThat(validator.childDiskWasExtended(domain), failsWith(EngineMessage.CANNOT_MOVE_DISK_SNAPSHOTS));
}
#method_after
@Test
public void canCopyDiskFails() {
    StorageDomain domain = createStorageDomainForDisk(StorageType.ISCSI);
    domain.setStorageFormat(StorageFormatType.V3);
    disk.setSize(1000);
    DiskImage child = createDiskImage();
    child.setSize(1000);
    child.setStorageIds(Collections.singletonList(domain.getId()));
    DiskImage parent = createDiskImage();
    parent.setId(Guid.newGuid());
    parent.setSize(500);
    parent.setStorageIds(Collections.singletonList(domain.getId()));
    child.setParentId(parent.getParentId());
    List<DiskImage> diskImages = new ArrayList<>(2);
    diskImages.add(parent);
    diskImages.add(child);
    when(validator.getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId())).thenReturn(diskImages);
    assertThat(diskImagesValidator.childDiskWasExtended(domain), failsWith(EngineMessage.CANNOT_MOVE_DISK_SNAPSHOTS));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (!getGlusterVolume().getVolumeType().isReplicatedType()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_NOT_SUPPORTED_FOR_VOLUME_TYPE);
        return false;
    }
    if (!getGlusterVolume().isOnline()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
        return false;
    }
    if (getGlusterVolume().getAsyncTask() != null && (getGlusterVolume().getAsyncTask().getStatus() == JobExecutionStatus.STARTED || (getGlusterVolume().getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK && getGlusterVolume().getAsyncTask().getStatus() == JobExecutionStatus.FINISHED))) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_HAS_RUNNING_TASKS);
        return false;
    }
    if (getParameters().getExistingBrick() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    if (!isValidVolumeBrick(getParameters().getExistingBrick())) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NOT_A_GLUSTER_VOLUME_BRICK);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    // Check whether reset brick supported or not.
    if (!supportedInConfig(ConfigValues.ResetBrickSupported, getCluster().getCompatibilityVersion())) {
        return false;
    }
    if (!getGlusterVolume().getVolumeType().isReplicatedType()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_NOT_SUPPORTED_FOR_VOLUME_TYPE);
        return false;
    }
    if (!getGlusterVolume().isOnline()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
        return false;
    }
    if (getGlusterVolume().getAsyncTask() != null && (getGlusterVolume().getAsyncTask().getStatus() == JobExecutionStatus.STARTED || (getGlusterVolume().getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK && getGlusterVolume().getAsyncTask().getStatus() == JobExecutionStatus.FINISHED))) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_HAS_RUNNING_TASKS);
        return false;
    }
    if (getParameters().getExistingBrick() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    if (!isValidVolumeBrick(getParameters().getExistingBrick())) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NOT_A_GLUSTER_VOLUME_BRICK);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ResetGlusterVolumeBrick, new ResetGlusterVolumeBrickActionVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getExistingBrick().getQualifiedName()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        glusterBrickDao.resetBrick(getParameters().getExistingBrick());
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_RESET_BRICK_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ResetGlusterVolumeBrick, new ResetGlusterVolumeBrickActionVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getExistingBrick().getQualifiedName()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        glusterBrickDao.updateBrickStatus(getParameters().getExistingBrick().getId(), GlusterStatus.UP);
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_RESET_BRICK_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
@Before
public void prepareMocks() {
    doReturn(getVds(VDSStatus.Up)).when(cmd).getUpServer();
    doReturn(getDistributedVolume(volumeId1)).when(volumeDao).getById(volumeId1);
    doReturn(getDistributedVolume(volumeId2)).when(volumeDao).getById(volumeId2);
    doReturn(getReplicatedVolume(volumeId3, 2)).when(volumeDao).getById(volumeId3);
    doReturn(getReplicatedVolume(volumeId4, 4)).when(volumeDao).getById(volumeId4);
    doReturn(getVdsStatic()).when(vdsStaticDao).get(serverId);
    doReturn(getCluster()).when(cmd).getCluster();
}
#method_after
@Before
public void prepareMocks() {
    doReturn(getVds(VDSStatus.Up)).when(cmd).getUpServer();
    doReturn(getVolume(volumeId1, GlusterVolumeType.DISTRIBUTED_REPLICATE, 0)).when(volumeDao).getById(volumeId1);
    doReturn(getVolume(volumeId2, GlusterVolumeType.DISTRIBUTED_REPLICATE, 0)).when(volumeDao).getById(volumeId2);
    doReturn(getVolume(volumeId3, GlusterVolumeType.REPLICATE, 2)).when(volumeDao).getById(volumeId3);
    doReturn(getVolume(volumeId4, GlusterVolumeType.REPLICATE, 4)).when(volumeDao).getById(volumeId4);
    doReturn(getVdsStatic()).when(vdsStaticDao).get(serverId);
    doReturn(getCluster()).when(cmd).getCluster();
    mcr.mockConfigValue(ConfigValues.ResetBrickSupported, getCluster().getCompatibilityVersion(), Boolean.TRUE);
}
#end_block

#method_before
private Cluster getCluster() {
    Cluster cluster = new Cluster();
    cluster.setId(clusterId);
    cluster.setVirtService(false);
    cluster.setGlusterService(true);
    return cluster;
}
#method_after
private Cluster getCluster() {
    Cluster cluster = new Cluster();
    cluster.setId(clusterId);
    cluster.setVirtService(false);
    cluster.setGlusterService(true);
    cluster.setCompatibilityVersion(Version.v4_2);
    return cluster;
}
#end_block

#method_before
private GlusterVolumeEntity getVolume(Guid id) {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.setId(id);
    volumeEntity.setName("test-vol");
    volumeEntity.addAccessProtocol(AccessProtocol.GLUSTER);
    volumeEntity.addTransportType(TransportType.TCP);
    return volumeEntity;
}
#method_after
private GlusterVolumeEntity getVolume(Guid volumeId, GlusterVolumeType volumeType, int brickCount) {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.setId(volumeId);
    volumeEntity.setName("test-vol");
    volumeEntity.addAccessProtocol(AccessProtocol.GLUSTER);
    volumeEntity.addTransportType(TransportType.TCP);
    if (volumeType.equals(GlusterVolumeType.DISTRIBUTED_REPLICATE)) {
        volumeEntity.setStatus((volumeId == volumeId1) ? GlusterStatus.UP : GlusterStatus.DOWN);
        volumeEntity.setBricks(getBricks(volumeId, "distrib", 2));
        volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTED_REPLICATE);
        volumeEntity.setClusterId(clusterId);
        return volumeEntity;
    } else if (volumeType.equals(GlusterVolumeType.REPLICATE)) {
        volumeEntity.setStatus(GlusterStatus.UP);
        volumeEntity.setBricks(getBricks(volumeId, "repl", brickCount));
        volumeEntity.setVolumeType(GlusterVolumeType.REPLICATE);
        volumeEntity.setReplicaCount(brickCount);
        volumeEntity.setClusterId(clusterId);
        return volumeEntity;
    } else {
        return volumeEntity;
    }
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    status = getBroker().glusterVolumeResetBrickStart(getParameters().getVolumeName(), getParameters().getExistingBrickDir());
    status = getBroker().glusterVolumeResetBrickCommitForce(getParameters().getVolumeName(), getParameters().getExistingBrickDir());
    proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    status = getBroker().glusterVolumeResetBrickStart(getParameters().getVolumeName(), getParameters().getExistingBrickDir());
    if (status.status.code == 0) {
        status = getBroker().glusterVolumeResetBrickCommitForce(getParameters().getVolumeName(), getParameters().getExistingBrickDir());
    }
    proceedProxyReturnValue();
}
#end_block

#method_before
@Override
public VDSInfoReturn getCapabilities() {
    JsonRpcRequest request = new RequestBuilder("Host.getCapabilities").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturn(response);
}
#method_after
@Override
public void getCapabilities(BrokerCommandCallback callback) {
    JsonRpcRequest request = new RequestBuilder("Host.getCapabilities").build();
    try {
        client.call(request, callback);
    } catch (ClientConnectionException e) {
        throw new TransportRunTimeException("Connection issues during send request", e);
    }
}
#end_block

#method_before
@Override
public VDSInfoReturn getHardwareInfo() {
    JsonRpcRequest request = new RequestBuilder("Host.getHardwareInfo").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturn(response);
}
#method_after
@Override
public void getHardwareInfo(BrokerCommandCallback callback) {
    JsonRpcRequest request = new RequestBuilder("Host.getHardwareInfo").build();
    try {
        client.call(request, callback);
    } catch (ClientConnectionException e) {
        throw new TransportRunTimeException("Connection issues during send request", e);
    }
}
#end_block

#method_before
@Override
public VDSInfoReturn getVdsStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturn(response);
}
#method_after
@Override
public void getVdsStats(BrokerCommandCallback callback) {
    JsonRpcRequest request = new RequestBuilder("Host.getStats").build();
    try {
        client.call(request, callback);
    } catch (ClientConnectionException e) {
        throw new TransportRunTimeException("Connection issues during send request", e);
    }
}
#end_block

#method_before
@Override
public FutureTask<Map<String, Object>> poll() {
    return timeBoundPoll(2, TimeUnit.SECONDS);
}
#method_after
@Deprecated
@Override
public FutureTask<Map<String, Object>> poll() {
    return timeBoundPoll(2, TimeUnit.SECONDS);
}
#end_block

#method_before
@Override
public FutureTask<Map<String, Object>> timeBoundPoll(final long timeout, final TimeUnit unit) {
    final JsonRpcRequest request = new RequestBuilder("Host.ping").build();
    final FutureCallable callable = new FutureCallable(() -> new FutureMap(client, request, timeout, unit, true));
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            return callable.isDone();
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@Deprecated
@Override
public FutureTask<Map<String, Object>> timeBoundPoll(final long timeout, final TimeUnit unit) {
    return timeBoundPollInternal(timeout, unit, "Host.ping");
}
#end_block

#method_before
private void maintenance() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceStorageDomainsTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingStorageDomainsIntoMaintenanceModeMsg());
    // $NON-NLS-1$
    model.setHashName("maintenance_storage_domain");
    setWindow(model);
    ArrayList<String> items = new ArrayList<>();
    boolean isDataDomain = true;
    for (StorageDomain selected : getSelectedItems()) {
        items.add(selected.getName());
        isDataDomain = selected.getStorageDomainType().isDataDomain();
    }
    model.setItems(items);
    if (isDataDomain) {
        model.getForce().setIsAvailable(true);
    }
    model.getForce().setIsChangeable(true);
    model.getForce().setEntity(false);
    model.setForceLabel(ConstantsManager.getInstance().getConstants().ignoreOVFUpdateFailure());
    // $NON-NLS-1$
    UICommand maintenance = UICommand.createDefaultOkUiCommand("OnMaintenance", this);
    model.getCommands().add(maintenance);
    // $NON-NLS-1$
    UICommand cancel = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancel);
}
#method_after
private void maintenance() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceStorageDomainsTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingStorageDomainsIntoMaintenanceModeMsg());
    // $NON-NLS-1$
    model.setHashName("maintenance_storage_domain");
    setWindow(model);
    ArrayList<String> items = new ArrayList<>();
    boolean isDataDomain = false;
    for (StorageDomain selected : getSelectedItems()) {
        items.add(selected.getName());
        isDataDomain |= selected.getStorageDomainType().isDataDomain();
    }
    model.setItems(items);
    model.getForce().setIsAvailable(isDataDomain);
    model.getForce().setIsChangeable(isDataDomain);
    model.getForce().setEntity(false);
    model.setForceLabel(ConstantsManager.getInstance().getConstants().ignoreOVFUpdateFailure());
    // $NON-NLS-1$
    UICommand maintenance = UICommand.createDefaultOkUiCommand("OnMaintenance", this);
    model.getCommands().add(maintenance);
    // $NON-NLS-1$
    UICommand cancel = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancel);
}
#end_block

#method_before
private void maintenance() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceStorageDomainsTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingStorageDomainsIntoMaintenanceModeMsg());
    // $NON-NLS-1$
    model.setHashName("maintenance_storage_domain");
    setWindow(model);
    boolean isDataDomain = true;
    List<String> items = new ArrayList<>();
    for (Object selected : getSelectedItems()) {
        items.add(((StorageDomain) selected).getName());
        isDataDomain = ((StorageDomain) selected).getStorageDomainType().isDataDomain();
    }
    model.setItems(items);
    if (isDataDomain) {
        model.getForce().setIsAvailable(true);
    }
    model.getForce().setIsChangeable(true);
    model.getForce().setEntity(false);
    model.setForceLabel(ConstantsManager.getInstance().getConstants().ignoreOVFUpdateFailure());
    // $NON-NLS-1$
    UICommand maintenance = UICommand.createDefaultOkUiCommand("OnMaintenance", this);
    model.getCommands().add(maintenance);
    // $NON-NLS-1$
    UICommand cancel = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancel);
}
#method_after
private void maintenance() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceStorageDomainsTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingStorageDomainsIntoMaintenanceModeMsg());
    // $NON-NLS-1$
    model.setHashName("maintenance_storage_domain");
    setWindow(model);
    boolean isDataDomain = false;
    List<String> items = new ArrayList<>(getSelectedItems().size());
    for (StorageDomain selected : getSelectedItems()) {
        items.add(selected.getName());
        isDataDomain |= selected.getStorageDomainType().isDataDomain();
    }
    model.setItems(items);
    model.getForce().setIsAvailable(isDataDomain);
    model.getForce().setIsChangeable(isDataDomain);
    model.getForce().setEntity(false);
    model.setForceLabel(ConstantsManager.getInstance().getConstants().ignoreOVFUpdateFailure());
    // $NON-NLS-1$
    UICommand maintenance = UICommand.createDefaultOkUiCommand("OnMaintenance", this);
    model.getCommands().add(maintenance);
    // $NON-NLS-1$
    UICommand cancel = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancel);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue("ProviderName", getProviderName());
    if (isInternalCommandTriggered() && getSucceeded()) {
        return AuditLogType.PROVIDER_SYNCHRONIZED_PERFORMED;
    }
    if (isInternalCommandTriggered() && !getSucceeded()) {
        return AuditLogType.PROVIDER_SYNCHRONIZED_PERFORMED_FAILED;
    }
    if (!isInternalCommandTriggered() && getSucceeded()) {
        return AuditLogType.PROVIDER_SYNCHRONIZED;
    }
    return AuditLogType.PROVIDER_SYNCHRONIZED_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue("ProviderName", getProviderName());
    if (isInternalCommandTriggered() && getSucceeded()) {
        return AuditLogType.PROVIDER_SYNCHRONIZED_PERFORMED;
    }
    if (isInternalCommandTriggered() && !getSucceeded()) {
        return AuditLogType.PROVIDER_SYNCHRONIZED_PERFORMED_FAILED;
    }
    if (!isInternalCommandTriggered() && getSucceeded()) {
        return AuditLogType.UNASSIGNED;
    }
    return AuditLogType.PROVIDER_SYNCHRONIZED_FAILED;
}
#end_block

#method_before
protected void initGeneralSubTabView() {
    ScrollPanel generalPanel = new ScrollPanel();
    DetailModelProvider<ImportVmModel, VmImportGeneralModel> modelProvider = new DetailModelProvider<ImportVmModel, VmImportGeneralModel>() {

        @Override
        public VmImportGeneralModel getModel() {
            VmImportGeneralModel model = (VmImportGeneralModel) importModel.getDetailModels().get(0);
            model.setSource(ImportSource.VMWARE);
            model.updateNameAndOsListeners();
            return model;
        }

        @Override
        public void onSubTabSelected() {
        }

        @Override
        public void onSubTabDeselected() {
        }

        @Override
        public void activateDetailModel() {
        }

        @Override
        public ImportVmModel getMainModel() {
            // Not used, here to satisfy interface contract.
            return null;
        }
    };
    generalView = new ImportVmGeneralSubTabView(modelProvider);
    generalPanel.add(generalView);
    subTabLayoutPanel.add(generalPanel, constants.importVmGeneralSubTabLabel());
}
#method_after
protected void initGeneralSubTabView() {
    ScrollPanel generalPanel = new ScrollPanel();
    DetailModelProvider<ImportVmModel, VmImportGeneralModel> modelProvider = new DetailModelProvider<ImportVmModel, VmImportGeneralModel>() {

        @Override
        public VmImportGeneralModel getModel() {
            VmImportGeneralModel model = (VmImportGeneralModel) importModel.getDetailModels().get(0);
            model.setSource(ImportSource.VMWARE);
            return model;
        }

        @Override
        public void onSubTabSelected() {
        }

        @Override
        public void onSubTabDeselected() {
        }

        @Override
        public void activateDetailModel() {
        }

        @Override
        public ImportVmModel getMainModel() {
            // Not used, here to satisfy interface contract.
            return null;
        }
    };
    generalView = new ImportVmGeneralSubTabView(modelProvider);
    modelProvider.getModel().clearAndRegisterNameAndOsListeners();
    generalPanel.add(generalView);
    subTabLayoutPanel.add(generalPanel, constants.importVmGeneralSubTabLabel());
}
#end_block

#method_before
protected void initGeneralSubTabView() {
    ScrollPanel generalPanel = new ScrollPanel();
    DetailModelProvider<ImportVmModel, VmImportGeneralModel> modelProvider = new DetailModelProvider<ImportVmModel, VmImportGeneralModel>() {

        @Override
        public VmImportGeneralModel getModel() {
            VmImportGeneralModel model = (VmImportGeneralModel) importModel.getDetailModels().get(0);
            model.setSource(ImportSource.EXPORT_DOMAIN);
            model.updateNameAndOsListeners();
            return model;
        }

        @Override
        public void onSubTabSelected() {
        }

        @Override
        public void onSubTabDeselected() {
        }

        @Override
        public void activateDetailModel() {
        }

        @Override
        public ImportVmModel getMainModel() {
            // Not used, here to satisfy interface contract.
            return null;
        }
    };
    generalView = new ImportVmGeneralSubTabView(modelProvider);
    generalPanel.add(generalView);
    subTabLayoutPanel.add(generalPanel, constants.importVmGeneralSubTabLabel());
}
#method_after
protected void initGeneralSubTabView() {
    ScrollPanel generalPanel = new ScrollPanel();
    DetailModelProvider<ImportVmModel, VmImportGeneralModel> modelProvider = new DetailModelProvider<ImportVmModel, VmImportGeneralModel>() {

        @Override
        public VmImportGeneralModel getModel() {
            VmImportGeneralModel model = (VmImportGeneralModel) importModel.getDetailModels().get(0);
            model.setSource(ImportSource.EXPORT_DOMAIN);
            return model;
        }

        @Override
        public void onSubTabSelected() {
        }

        @Override
        public void onSubTabDeselected() {
        }

        @Override
        public void activateDetailModel() {
        }

        @Override
        public ImportVmModel getMainModel() {
            // Not used, here to satisfy interface contract.
            return null;
        }
    };
    generalView = new ImportVmGeneralSubTabView(modelProvider);
    modelProvider.getModel().clearAndRegisterNameAndOsListeners();
    generalPanel.add(generalView);
    subTabLayoutPanel.add(generalPanel, constants.importVmGeneralSubTabLabel());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    // verify that the destination lease domain ID belongs to one of the VM's snapshots
    if (getParameters().getDstLeaseDomainId() != null) {
        if (!validate(snapshotsValidator.isLeaseDomainIdBelongsToSnapshot(getVmId(), getParameters().getDstLeaseDomainId())) && !getParameters().getDstLeaseDomainId().equals(getVm().getLeaseStorageDomainId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_LEASE_DOMAIN_ID_IS_NOT_VALID);
        }
    }
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.isVmExists()) || !validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId())) || !validate(snapshotsValidator.snapshotVmConfigurationBroken(getDstSnapshot(), getVmName()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    diskImages.addAll(DisksFilter.filterCinderDisks(getVm().getDiskMap().values(), ONLY_PLUGGED));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).existsAndUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        List<DiskImage> images = getImagesToPreview();
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(images);
        if (!validate(diskImagesToPreviewValidator.noDuplicatedIds(images.stream().map(DiskImage::getId))) || !validate(diskImagesToPreviewValidator.noDuplicatedIds(images.stream().map(DiskImage::getImageId))) || !validate(diskImagesToPreviewValidator.diskImagesSnapshotsAttachedToVm(getVmId())) || !validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked())) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        // verify lease storage domain status
        if (getParameters().getDstLeaseDomainId() != null) {
            storageIds.add(getParameters().getDstLeaseDomainId());
        } else if (getDstSnapshot().getVmConfiguration() != null) {
            Guid leaseDomainId = OvfUtils.fetchLeaseDomainId(getDstSnapshot().getVmConfiguration());
            if (leaseDomainId != null) {
                storageIds.add(leaseDomainId);
            }
        }
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(getParameters().getDisks());
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    if (isRestoreMemory() && !validateMemoryTakenInSupportedVersion()) {
        return false;
    }
    if (!canRestoreVmConfigFromSnapshot()) {
        return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    // verify that the destination lease domain ID belongs to one of the VM's snapshots
    if (getParameters().getDstLeaseDomainId() != null) {
        if (!validate(snapshotsValidator.isLeaseDomainIdBelongsToSnapshot(getVmId(), getParameters().getDstLeaseDomainId())) && !getParameters().getDstLeaseDomainId().equals(getVm().getLeaseStorageDomainId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_LEASE_DOMAIN_ID_IS_NOT_VALID);
        }
    }
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.isVmExists()) || !validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId())) || !validate(snapshotsValidator.snapshotVmConfigurationBroken(getDstSnapshot(), getVmName()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    diskImages.addAll(DisksFilter.filterCinderDisks(getVm().getDiskMap().values(), ONLY_PLUGGED));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).existsAndUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        List<DiskImage> images = getImagesToPreview();
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(images);
        if (!validate(diskImagesToPreviewValidator.noDuplicatedIds()) || !validate(diskImagesToPreviewValidator.diskImagesSnapshotsAttachedToVm(getVmId())) || !validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked())) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        // verify lease storage domain status
        if (getParameters().getDstLeaseDomainId() != null) {
            storageIds.add(getParameters().getDstLeaseDomainId());
        } else if (getDstSnapshot().getVmConfiguration() != null) {
            Guid leaseDomainId = OvfUtils.fetchLeaseDomainId(getDstSnapshot().getVmConfiguration());
            if (leaseDomainId != null) {
                storageIds.add(leaseDomainId);
            }
        }
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(getParameters().getDisks());
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    if (isRestoreMemory() && !validateMemoryTakenInSupportedVersion()) {
        return false;
    }
    if (!canRestoreVmConfigFromSnapshot()) {
        return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
    }
    return true;
}
#end_block

#method_before
public ValidationResult noDuplicatedIds(Stream<Guid> ids) {
    String duplicated = ids.collect(Collectors.groupingBy(Function.identity(), Collectors.counting())).entrySet().stream().filter(e -> e.getValue() > 1L).map(e -> e.getKey().toString()).collect(Collectors.joining(", "));
    if (!duplicated.isEmpty()) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DUPLICATED_DISK_OR_IMAGE_IDS, String.format("$ids %s", duplicated));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult noDuplicatedIds() {
    String duplicated = diskImages.stream().map(DiskImage::getId).collect(Collectors.groupingBy(Function.identity(), Collectors.counting())).entrySet().stream().filter(e -> e.getValue() > 1L).map(e -> e.getKey().toString()).collect(Collectors.joining(", "));
    if (!duplicated.isEmpty()) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DUPLICATED_DISK_OR_IMAGE_IDS, String.format("$ids %s", duplicated));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
public Response restore(Action action) {
    action.setAsync(false);
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(parentId, guid);
    if (action.isSetRestoreMemory()) {
        tryBackParams.setRestoreMemory(action.isRestoreMemory());
    }
    if (action.isSetDisks()) {
        // Each disk parameter is being mapped to a DiskImage.
        List<DiskImage> disks = collection.mapDisks(action.getDisks());
        List<DiskImage> disksFromDB = null;
        if (disks != null) {
            // In case a disk hasn't specified its image_id, the imageId value is set to Guid.Empty().
            String noImageId = disks.stream().filter(disk -> disk.getImageId().equals(Guid.Empty)).map(disk -> disk.getId().toString()).collect(Collectors.joining(","));
            if (!noImageId.isEmpty()) {
                badRequest("Missing image ids for disks: " + noImageId);
            }
            disksFromDB = disks.stream().map(disk -> getEntity(org.ovirt.engine.core.common.businessentities.storage.DiskImage.class, QueryType.GetDiskImageByDiskAndImageIds, new GetDiskImageByDiskAndImageIdsParameters(disk.getId(), disk.getImageId()), "disk id=" + disk.getId() + " ,image_id=" + disk.getImageId())).collect(Collectors.toList());
        }
        tryBackParams.setDisks(disksFromDB);
    }
    // TODO: if user supplied, override with user value
    tryBackParams.setCorrelationId(RESTORE_SNAPSHOT_CORRELATION_ID);
    Response response = doAction(ActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action, PollingType.JOB);
    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
        RestoreAllSnapshotsParameters restoreParams = new RestoreAllSnapshotsParameters(parentId, SnapshotActionEnum.COMMIT);
        restoreParams.setCorrelationId(RESTORE_SNAPSHOT_CORRELATION_ID);
        Response response2 = doAction(ActionType.RestoreAllSnapshots, restoreParams, action);
        if (response2.getStatus() != Response.Status.OK.getStatusCode()) {
            return response2;
        }
    }
    return response;
}
#method_after
@Override
public Response restore(Action action) {
    action.setAsync(false);
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(parentId, guid);
    if (action.isSetRestoreMemory()) {
        tryBackParams.setRestoreMemory(action.isRestoreMemory());
    }
    if (action.isSetDisks()) {
        // Each disk parameter is being mapped to a DiskImage.
        List<DiskImage> disks = collection.mapDisks(action.getDisks());
        List<DiskImage> disksFromDB = null;
        if (disks != null) {
            // In case a disk hasn't specified its image_id, the imageId value is set to Guid.Empty().
            disksFromDB = disks.stream().map(disk -> getEntity(org.ovirt.engine.core.common.businessentities.storage.DiskImage.class, QueryType.GetDiskImageByDiskAndImageIds, new GetDiskImageByDiskAndImageIdsParameters(disk.getId(), disk.getImageId()), String.format("GetDiskImageByDiskAndImageIds: disk id=%s, image_id=%s", disk.getId(), disk.getImageId()))).collect(Collectors.toList());
        }
        tryBackParams.setDisks(disksFromDB);
    }
    // TODO: if user supplied, override with user value
    tryBackParams.setCorrelationId(RESTORE_SNAPSHOT_CORRELATION_ID);
    Response response = doAction(ActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action, PollingType.JOB);
    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
        RestoreAllSnapshotsParameters restoreParams = new RestoreAllSnapshotsParameters(parentId, SnapshotActionEnum.COMMIT);
        restoreParams.setCorrelationId(RESTORE_SNAPSHOT_CORRELATION_ID);
        Response response2 = doAction(ActionType.RestoreAllSnapshots, restoreParams, action);
        if (response2.getStatus() != Response.Status.OK.getStatusCode()) {
            return response2;
        }
    }
    return response;
}
#end_block

#method_before
@Override
public Response previewSnapshot(Action action) {
    validateParameters(action, "snapshot.id");
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(guid, asGuid(action.getSnapshot().getId()));
    if (action.isSetRestoreMemory()) {
        tryBackParams.setRestoreMemory(action.isRestoreMemory());
    }
    if (action.isSetDisks()) {
        // Each disk parameter is being mapped to a DiskImage.
        List<DiskImage> disks = getParent().mapDisks(action.getDisks());
        List<DiskImage> disksFromDB = null;
        if (disks != null) {
            // In case a disk hasn't specified its image_id, the imageId value is set to Guid.Empty().
            String noImageId = disks.stream().filter(disk -> disk.getImageId().equals(Guid.Empty)).map(disk -> disk.getId().toString()).collect(Collectors.joining(","));
            if (!noImageId.isEmpty()) {
                badRequest("Missing image ids for disks: " + noImageId);
            }
            disksFromDB = disks.stream().map(disk -> getEntity(org.ovirt.engine.core.common.businessentities.storage.DiskImage.class, QueryType.GetDiskImageByDiskAndImageIds, new GetDiskImageByDiskAndImageIdsParameters(disk.getId(), disk.getImageId()), "disk id=" + disk.getId() + " ,image_id=" + disk.getImageId())).collect(Collectors.toList());
        }
        tryBackParams.setDisks(disksFromDB);
    }
    if (action.isSetLease()) {
        tryBackParams.setRestoreLease(action.getLease().isSetStorageDomain());
        if (action.getLease().isSetStorageDomain()) {
            tryBackParams.setDstLeaseDomainId(asGuid(action.getLease().getStorageDomain().getId()));
        }
    }
    Response response = doAction(ActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action);
    return response;
}
#method_after
@Override
public Response previewSnapshot(Action action) {
    validateParameters(action, "snapshot.id");
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(guid, asGuid(action.getSnapshot().getId()));
    if (action.isSetRestoreMemory()) {
        tryBackParams.setRestoreMemory(action.isRestoreMemory());
    }
    if (action.isSetDisks()) {
        // Each disk parameter is being mapped to a DiskImage.
        List<DiskImage> disks = getParent().mapDisks(action.getDisks());
        List<DiskImage> disksFromDB = null;
        if (disks != null) {
            // In case a disk hasn't specified its image_id, the imageId value is set to Guid.Empty().
            disksFromDB = disks.stream().map(disk -> getEntity(org.ovirt.engine.core.common.businessentities.storage.DiskImage.class, QueryType.GetDiskImageByDiskAndImageIds, new GetDiskImageByDiskAndImageIdsParameters(disk.getId(), disk.getImageId()), String.format("GetDiskImageByDiskAndImageIds: disk id=%s, image_id=%s", disk.getId(), disk.getImageId()))).collect(Collectors.toList());
        }
        tryBackParams.setDisks(disksFromDB);
    }
    if (action.isSetLease()) {
        tryBackParams.setRestoreLease(action.getLease().isSetStorageDomain());
        if (action.getLease().isSetStorageDomain()) {
            tryBackParams.setDstLeaseDomainId(asGuid(action.getLease().getStorageDomain().getId()));
        }
    }
    Response response = doAction(ActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action);
    return response;
}
#end_block

#method_before
private void remove() {
    if (getEntity() != null) {
        if (getWindow() != null) {
            return;
        }
        Snapshot snapshot = getSelectedItem();
        ConfirmationModel model = new ConfirmationModel();
        setWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().deleteSnapshotTitle());
        model.setHelpTag(HelpTag.delete_snapshot);
        // $NON-NLS-1$
        model.setHashName("delete_snapshot");
        model.setMessage(ConstantsManager.getInstance().getMessages().areYouSureYouWantToDeleteSanpshot(DateTimeFormat.getFormat(DATE_FORMAT).format(snapshot.getCreationDate()), snapshot.getDescription()));
        String unpluggedDisksNames = getUnpluggedDisksNames();
        if (unpluggedDisksNames != null) {
            model.setNote(ConstantsManager.getInstance().getMessages().liveMergeUnpluggedDisksNote(unpluggedDisksNames));
        }
        // $NON-NLS-1$
        UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
        model.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
        model.getCommands().add(tempVar2);
    }
}
#method_after
private void remove() {
    if (getEntity() != null) {
        if (getWindow() != null) {
            return;
        }
        Snapshot snapshot = getSelectedItem();
        ConfirmationModel model = new ConfirmationModel();
        setWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().deleteSnapshotTitle());
        model.setHelpTag(HelpTag.delete_snapshot);
        // $NON-NLS-1$
        model.setHashName("delete_snapshot");
        model.setMessage(ConstantsManager.getInstance().getMessages().areYouSureYouWantToDeleteSanpshot(DateTimeFormat.getFormat(DATE_FORMAT).format(snapshot.getCreationDate()), snapshot.getDescription()));
        // $NON-NLS-1$
        UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
        model.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
        model.getCommands().add(tempVar2);
    }
}
#end_block

#method_before
@Test
public void testExecuteQueryCommand() {
    GetDiskImageByDiskAndImageIdsParameters params = getQueryParameters();
    when(params.getDiskId()).thenReturn(diskId);
    when(params.getImageId()).thenReturn(imageId);
    when(diskImageDao.getDiskImageByDiskAndImageIds(diskId, imageId)).thenReturn(diskImage);
    GetDiskImageByDiskAndImageIdsQuery<GetDiskImageByDiskAndImageIdsParameters> query = getQuery();
    query.executeQueryCommand();
    DiskImage returnDiskImage = query.getQueryReturnValue().getReturnValue();
    assertTrue(returnDiskImage.equals(diskImage));
}
#method_after
@Test
public void testExecuteQueryCommand() {
    GetDiskImageByDiskAndImageIdsParameters params = getQueryParameters();
    when(params.getDiskId()).thenReturn(diskId);
    when(params.getImageId()).thenReturn(imageId);
    when(diskImageDao.getDiskImageByDiskAndImageIds(diskId, imageId, getUser().getId(), getQueryParameters().isFiltered())).thenReturn(diskImage);
    GetDiskImageByDiskAndImageIdsQuery<GetDiskImageByDiskAndImageIdsParameters> query = getQuery();
    query.executeQueryCommand();
    DiskImage returnDiskImage = query.getQueryReturnValue().getReturnValue();
    assertEquals(returnDiskImage, diskImage);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(diskImageDao.getDiskImageByDiskAndImageIds(getParameters().getDiskId(), getParameters().getImageId()));
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(diskImageDao.getDiskImageByDiskAndImageIds(getParameters().getDiskId(), getParameters().getImageId(), getUserID(), getParameters().isFiltered()));
}
#end_block

#method_before
@Override
public DiskImage getDiskImageByDiskAndImageIds(Guid diskId, Guid imageId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("disk_id", diskId).addValue("image_id", imageId);
    return getCallsHandler().executeRead("GetDiskImageByDiskAndImageIds", DiskImageRowMapper.instance, parameterSource);
}
#method_after
@Override
public DiskImage getDiskImageByDiskAndImageIds(Guid diskId, Guid imageId) {
    return getDiskImageByDiskAndImageIds(diskId, imageId, null, false);
}
#end_block

#method_before
@Override
public DiskImage getDiskImageByDiskAndImageIds(Guid diskId, Guid imageId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("disk_id", diskId).addValue("image_id", imageId);
    return getCallsHandler().executeRead("GetDiskImageByDiskAndImageIds", DiskImageRowMapper.instance, parameterSource);
}
#method_after
@Override
public DiskImage getDiskImageByDiskAndImageIds(Guid diskId, Guid imageId, Guid userId, boolean isFiltered) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("disk_id", diskId).addValue("image_id", imageId).addValue("user_id", userId).addValue("is_filtered", isFiltered);
    return getCallsHandler().executeRead("GetDiskImageByDiskAndImageIds", DiskImageRowMapper.instance, parameterSource);
}
#end_block

#method_before
private void writeDisks(List<VmDevice> devices) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    int ideIndex = -1;
    int scsiIndex = -1;
    int virtioIndex = -1;
    DiskInterface cdDiskInterface = DiskInterface.forValue(cdInterface);
    int pinnedDriveIndex = 0;
    Map<Disk, VmDevice> vmDisksToDevices = vm.getDiskMap().values().stream().collect(Collectors.toMap(Function.identity(), d -> deviceIdToDevice.get(new VmDeviceId(d.getId(), vm.getId()))));
    for (Disk disk : vmInfoBuildUtils.getSortedDisks(vmDisksToDevices, vm.getId())) {
        VmDevice device = deviceIdToDevice.get(new VmDeviceId(disk.getId(), vm.getId()));
        if (device == null || !device.isManaged()) {
            // This may happen to memory disks that do not have a corresponding device
            continue;
        }
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        DiskInterface diskInterface = dve.getDiskInterface();
        int index = 0;
        int pinTo = 0;
        switch(diskInterface) {
            case IDE:
                ideIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (ideIndex == payloadIndex || ideIndex == cdRomIndex) {
                        ideIndex++;
                    }
                }
                index = ideIndex;
                break;
            case VirtIO:
                pinTo = vmInfoBuildUtils.pinToIoThreads(vm, device, pinnedDriveIndex++);
                virtioIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (virtioIndex == payloadIndex || virtioIndex == cdRomIndex) {
                        virtioIndex++;
                    }
                }
                index = virtioIndex;
                break;
            case SPAPR_VSCSI:
            case VirtIO_SCSI:
                scsiIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (scsiIndex == payloadIndex || scsiIndex == cdRomIndex) {
                        scsiIndex++;
                    }
                }
                index = scsiIndex;
                vmInfoBuildUtils.calculateAddressForScsiDisk(vm, disk, device, vmDeviceSpaprVscsiUnitMap, vmDeviceVirtioScsiUnitMap);
                break;
        }
        String dev = vmInfoBuildUtils.makeDiskName(dve.getDiskInterface().getName(), index);
        writeDisk(device, disk, dve, dev, pinTo);
    }
}
#method_after
private void writeDisks(List<VmDevice> devices) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    int ideIndex = -1;
    int scsiIndex = -1;
    int virtioIndex = -1;
    DiskInterface cdDiskInterface = DiskInterface.forValue(cdInterface);
    int pinnedDriveIndex = 0;
    Map<Disk, VmDevice> vmDisksToDevices = vm.getDiskMap().values().stream().filter(Disk::getPlugged).collect(Collectors.toMap(Function.identity(), d -> deviceIdToDevice.get(new VmDeviceId(d.getId(), vm.getId()))));
    for (Disk disk : vmInfoBuildUtils.getSortedDisks(vmDisksToDevices, vm.getId())) {
        VmDevice device = deviceIdToDevice.get(new VmDeviceId(disk.getId(), vm.getId()));
        if (device == null || !device.isManaged()) {
            // This may happen to memory disks that do not have a corresponding device
            continue;
        }
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        DiskInterface diskInterface = dve.getDiskInterface();
        int index = 0;
        int pinTo = 0;
        switch(diskInterface) {
            case IDE:
                ideIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (ideIndex == payloadIndex || ideIndex == cdRomIndex) {
                        ideIndex++;
                    }
                }
                index = ideIndex;
                break;
            case VirtIO:
                pinTo = vmInfoBuildUtils.pinToIoThreads(vm, device, pinnedDriveIndex++);
                virtioIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (virtioIndex == payloadIndex || virtioIndex == cdRomIndex) {
                        virtioIndex++;
                    }
                }
                index = virtioIndex;
                break;
            case SPAPR_VSCSI:
            case VirtIO_SCSI:
                scsiIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (scsiIndex == payloadIndex || scsiIndex == cdRomIndex) {
                        scsiIndex++;
                    }
                }
                index = scsiIndex;
                vmInfoBuildUtils.calculateAddressForScsiDisk(vm, disk, device, vmDeviceSpaprVscsiUnitMap, vmDeviceVirtioScsiUnitMap);
                break;
        }
        String dev = vmInfoBuildUtils.makeDiskName(dve.getDiskInterface().getName(), index);
        writeDisk(device, disk, dve, dev, pinTo);
    }
}
#end_block

#method_before
private void writeController(VmDevice device) {
    writer.writeStartElement("controller");
    writer.writeAttributeString("type", device.getDevice());
    Object model = device.getSpecParams().get(VdsProperties.Model);
    if (model != null) {
        writer.writeAttributeString("model", model.toString());
    }
    Object index = device.getSpecParams().get(VdsProperties.Index);
    if (index != null) {
        writer.writeAttributeString("index", index.toString());
    }
    Object ports = device.getSpecParams().get("ports");
    if (ports != null) {
        writer.writeAttributeString("ports", ports.toString());
    }
    if (device.getSpecParams().containsKey(VdsProperties.ioThreadId)) {
        writer.writeStartElement("driver");
        writer.writeAttributeString("iothread", device.getSpecParams().get(VdsProperties.ioThreadId).toString());
        writer.writeEndElement();
    }
    if (!VmDeviceType.USB.getName().equals(device.getDevice())) {
        writeAlias(device);
    }
    writeAddress(device);
    writer.writeEndElement();
}
#method_after
private void writeController(VmDevice device) {
    writer.writeStartElement("controller");
    writer.writeAttributeString("type", device.getDevice());
    Object model = device.getSpecParams().get(VdsProperties.Model);
    if (model != null) {
        writer.writeAttributeString("model", model.toString());
    }
    Object index = device.getSpecParams().get(VdsProperties.Index);
    if (index != null) {
        writer.writeAttributeString("index", index.toString());
    }
    Object ports = device.getSpecParams().get("ports");
    if (ports != null) {
        writer.writeAttributeString("ports", ports.toString());
    }
    Object ioThreadId = device.getSpecParams().get(VdsProperties.ioThreadId);
    if (ioThreadId != null) {
        writer.writeStartElement("driver");
        writer.writeAttributeString("iothread", ioThreadId.toString());
        writer.writeEndElement();
    }
    // USB controllers must not be set with user-aliases (bz #1552127)
    if (!VmDeviceType.USB.getName().equals(device.getDevice())) {
        writeAlias(device);
    }
    writeAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDisks(List<VmDevice> devices) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    int ideIndex = -1;
    int scsiIndex = -1;
    int virtioIndex = -1;
    DiskInterface cdDiskInterface = DiskInterface.forValue(cdInterface);
    int pinnedDriveIndex = 0;
    Map<Disk, VmDevice> vmDisksToDevices = vm.getDiskMap().values().stream().filter(d -> d.getPlugged()).collect(Collectors.toMap(Function.identity(), d -> deviceIdToDevice.get(new VmDeviceId(d.getId(), vm.getId()))));
    for (Disk disk : vmInfoBuildUtils.getSortedDisks(vmDisksToDevices, vm.getId())) {
        VmDevice device = deviceIdToDevice.get(new VmDeviceId(disk.getId(), vm.getId()));
        if (device == null || !device.isManaged()) {
            // This may happen to memory disks that do not have a corresponding device
            continue;
        }
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        DiskInterface diskInterface = dve.getDiskInterface();
        int index = 0;
        int pinTo = 0;
        switch(diskInterface) {
            case IDE:
                ideIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (ideIndex == payloadIndex || ideIndex == cdRomIndex) {
                        ideIndex++;
                    }
                }
                index = ideIndex;
                break;
            case VirtIO:
                pinTo = vmInfoBuildUtils.pinToIoThreads(vm, device, pinnedDriveIndex++);
                virtioIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (virtioIndex == payloadIndex || virtioIndex == cdRomIndex) {
                        virtioIndex++;
                    }
                }
                index = virtioIndex;
                break;
            case SPAPR_VSCSI:
            case VirtIO_SCSI:
                scsiIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (scsiIndex == payloadIndex || scsiIndex == cdRomIndex) {
                        scsiIndex++;
                    }
                }
                index = scsiIndex;
                vmInfoBuildUtils.calculateAddressForScsiDisk(vm, disk, device, vmDeviceSpaprVscsiUnitMap, vmDeviceVirtioScsiUnitMap);
                break;
        }
        String dev = vmInfoBuildUtils.makeDiskName(dve.getDiskInterface().getName(), index);
        writeDisk(device, disk, dve, dev, pinTo);
    }
}
#method_after
private void writeDisks(List<VmDevice> devices) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    int ideIndex = -1;
    int scsiIndex = -1;
    int virtioIndex = -1;
    DiskInterface cdDiskInterface = DiskInterface.forValue(cdInterface);
    int pinnedDriveIndex = 0;
    Map<Disk, VmDevice> vmDisksToDevices = vm.getDiskMap().values().stream().filter(Disk::getPlugged).collect(Collectors.toMap(Function.identity(), d -> deviceIdToDevice.get(new VmDeviceId(d.getId(), vm.getId()))));
    for (Disk disk : vmInfoBuildUtils.getSortedDisks(vmDisksToDevices, vm.getId())) {
        VmDevice device = deviceIdToDevice.get(new VmDeviceId(disk.getId(), vm.getId()));
        if (device == null || !device.isManaged()) {
            // This may happen to memory disks that do not have a corresponding device
            continue;
        }
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        DiskInterface diskInterface = dve.getDiskInterface();
        int index = 0;
        int pinTo = 0;
        switch(diskInterface) {
            case IDE:
                ideIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (ideIndex == payloadIndex || ideIndex == cdRomIndex) {
                        ideIndex++;
                    }
                }
                index = ideIndex;
                break;
            case VirtIO:
                pinTo = vmInfoBuildUtils.pinToIoThreads(vm, device, pinnedDriveIndex++);
                virtioIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (virtioIndex == payloadIndex || virtioIndex == cdRomIndex) {
                        virtioIndex++;
                    }
                }
                index = virtioIndex;
                break;
            case SPAPR_VSCSI:
            case VirtIO_SCSI:
                scsiIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (scsiIndex == payloadIndex || scsiIndex == cdRomIndex) {
                        scsiIndex++;
                    }
                }
                index = scsiIndex;
                vmInfoBuildUtils.calculateAddressForScsiDisk(vm, disk, device, vmDeviceSpaprVscsiUnitMap, vmDeviceVirtioScsiUnitMap);
                break;
        }
        String dev = vmInfoBuildUtils.makeDiskName(dve.getDiskInterface().getName(), index);
        writeDisk(device, disk, dve, dev, pinTo);
    }
}
#end_block

#method_before
public ListModel<CacheDevicePathType> getCacheDevicePathTypeList() {
    return cacheDevicePathTypeList;
}
#method_after
public ListModel<StorageDevice> getCacheDevicePathTypeList() {
    return cacheDevicePathTypeList;
}
#end_block

#method_before
public void setCacheDevicePathTypeList(ListModel<CacheDevicePathType> cacheDevicePathTypeList) {
    this.cacheDevicePathTypeList = cacheDevicePathTypeList;
}
#method_after
public void setCacheDevicePathTypeList(ListModel<StorageDevice> cacheDevicePathTypeList) {
    this.cacheDevicePathTypeList = cacheDevicePathTypeList;
}
#end_block

#method_before
public EntityModel<String> getCacheSize() {
    return cacheSize;
}
#method_after
public EntityModel<Integer> getCacheSize() {
    return cacheSize;
}
#end_block

#method_before
public void setCacheSize(EntityModel<String> cacheSize) {
    this.cacheSize = cacheSize;
}
#method_after
public void setCacheSize(EntityModel<Integer> cacheSize) {
    this.cacheSize = cacheSize;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        runAnsibleLvmCachePlaybook();
    } catch (IOException | InterruptedException e) {
        e.printStackTrace();
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        runAnsibleCreateBrickPlaybook();
        setSucceeded(true);
    } catch (IOException | InterruptedException e) {
        setSucceeded(false);
        e.printStackTrace();
    }
}
#end_block

#method_before
public String getCacheSize() {
    return cacheSize;
}
#method_after
public Integer getCacheSize() {
    return cacheSize;
}
#end_block

#method_before
public void setCacheSize(String cacheSize) {
    this.cacheSize = cacheSize;
}
#method_after
public void setCacheSize(Integer cacheSize) {
    this.cacheSize = cacheSize;
}
#end_block

#method_before
private void initListBoxEditors() {
    raidTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<RaidType>());
    cacheDevicePathEditor = new ListModelListBoxEditor<>(new EnumRenderer<CacheDevicePathType>());
    cacheModeEditor = new ListModelListBoxEditor<>(new EnumRenderer<CacheModeType>());
}
#method_after
private void initListBoxEditors() {
    raidTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<RaidType>());
    cacheDevicePathEditor = new ListModelListBoxEditor<>(new NameRenderer<StorageDevice>());
    cacheModeEditor = new ListModelListBoxEditor<>(new EnumRenderer<CacheModeType>());
}
#end_block

#method_before
public void setEntity(VDS value) {
    super.setEntity(value);
    updateActionAvailability();
}
#method_after
@Override
public void setEntity(VDS value) {
    super.setEntity(value);
    updateActionAvailability();
}
#end_block

#method_before
private void createBrick() {
    if (getWindow() != null) {
        return;
    }
    VDS host = getEntity();
    if (host == null) {
        return;
    }
    final CreateBrickModel lvModel = new CreateBrickModel();
    lvModel.setTitle(ConstantsManager.getInstance().getConstants().createBrick());
    lvModel.setHelpTag(HelpTag.create_brick);
    // $NON-NLS-1$
    lvModel.setHashName("create_brick");
    lvModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    setWindow(lvModel);
    lvModel.getRaidTypeList().setSelectedItem(RaidType.RAID6);
    List<StorageDevice> selectedDevices = getSelectedItems();
    lvModel.getStorageDevices().setItems(selectedDevices);
    lvModel.setSelectedDevices(selectedDevices);
    AsyncQuery<String> asyncQueryForDefaultMountPoint = lvModel.asyncQuery(defaultMountPoint -> {
        lvModel.stopProgress();
        lvModel.getDefaultMountFolder().setEntity(defaultMountPoint);
    });
    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigValues.GlusterDefaultBrickMountPoint, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), asyncQueryForDefaultMountPoint);
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onCreateBrick", this);
    lvModel.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("closeWindow", this);
    lvModel.getCommands().add(cancelCommand);
}
#method_after
private void createBrick() {
    if (getWindow() != null) {
        return;
    }
    VDS host = getEntity();
    if (host == null) {
        return;
    }
    final CreateBrickModel lvModel = new CreateBrickModel();
    lvModel.setTitle(ConstantsManager.getInstance().getConstants().createBrick());
    lvModel.setHelpTag(HelpTag.create_brick);
    // $NON-NLS-1$
    lvModel.setHashName("create_brick");
    lvModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    setWindow(lvModel);
    lvModel.getRaidTypeList().setSelectedItem(RaidType.RAID6);
    List<StorageDevice> selectedDevices = getSelectedItems();
    lvModel.getStorageDevices().setItems(selectedDevices);
    lvModel.setSelectedDevices(selectedDevices);
    AsyncQuery<String> asyncQueryForDefaultMountPoint = lvModel.asyncQuery(defaultMountPoint -> {
        lvModel.stopProgress();
        lvModel.getDefaultMountFolder().setEntity(defaultMountPoint);
    });
    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigValues.GlusterDefaultBrickMountPoint, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), asyncQueryForDefaultMountPoint);
    AsyncDataProvider.getInstance().getStorageDevices(new AsyncQuery<>(returnValue -> {
        if (returnValue != null) {
            List<StorageDevice> storageDeviceList = new ArrayList<>();
            // $NON-NLS-1$
            storageDeviceList.add(null);
            for (StorageDevice storagedevice : returnValue) {
                if (storagedevice.getCanCreateBrick() && !selectedDevices.contains(storagedevice)) {
                    storageDeviceList.add(storagedevice);
                }
            }
            lvModel.getCacheDevicePathTypeList().setItems(storageDeviceList);
        }
    }), host.getId());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onCreateBrick", this);
    lvModel.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("closeWindow", this);
    lvModel.getCommands().add(cancelCommand);
}
#end_block

#method_before
@Test
public void validateSucceeds() {
    doReturn(new CreateBrickParameters(HOST_ID, "brick1", "/gluster-bricks/brick1", RaidType.RAID0, null, null, Collections.singletonList(getStorageDevice("sda")), CacheDevicePathType.sda, CacheModeType.writethrough, "10")).when(cmd).getParameters();
    prepareMocks(VDSStatus.Up);
    assertTrue(cmd.validate());
}
#method_after
@Test
public void validateSucceeds() {
    doReturn(new CreateBrickParameters(HOST_ID, "brick1", "/gluster-bricks/brick1", RaidType.RAID0, null, null, Collections.singletonList(getStorageDevice("sda")), getStorageDevice("sdb"), CacheModeType.writethrough, 10)).when(cmd).getParameters();
    prepareMocks(VDSStatus.Up);
    assertTrue(cmd.validate());
}
#end_block

#method_before
@Test
public void validateFailsForNoStorageDevice() {
    doReturn(new CreateBrickParameters(HOST_ID, "brick1", "/gluster-bricks/brick1", RaidType.RAID0, null, null, Collections.emptyList(), CacheDevicePathType.sdd, CacheModeType.writethrough, "10")).when(cmd).getParameters();
    prepareMocks(VDSStatus.Up);
    assertFalse(cmd.validate());
}
#method_after
@Test
public void validateFailsForNoStorageDevice() {
    doReturn(new CreateBrickParameters(HOST_ID, "brick1", "/gluster-bricks/brick1", RaidType.RAID0, null, null, Collections.emptyList(), getStorageDevice("sdd"), CacheModeType.writethrough, 10)).when(cmd).getParameters();
    prepareMocks(VDSStatus.Up);
    assertFalse(cmd.validate());
}
#end_block

#method_before
@Test
public void validateFailsForDeviceAlreadyInUse() {
    StorageDevice storageDevice = getStorageDevice("sda");
    storageDevice.setCanCreateBrick(false);
    doReturn(new CreateBrickParameters(HOST_ID, "brick1", "/gluster-bricks/brick1", RaidType.RAID0, null, null, Collections.singletonList(storageDevice), CacheDevicePathType.sda, CacheModeType.writethrough, "10")).when(cmd).getParameters();
    prepareMocks(VDSStatus.Up);
    assertFalse(cmd.validate());
}
#method_after
@Test
public void validateFailsForDeviceAlreadyInUse() {
    StorageDevice storageDevice = getStorageDevice("sda");
    storageDevice.setCanCreateBrick(false);
    doReturn(new CreateBrickParameters(HOST_ID, "brick1", "/gluster-bricks/brick1", RaidType.RAID0, null, null, Collections.singletonList(storageDevice), getStorageDevice("sda"), CacheModeType.writethrough, 10)).when(cmd).getParameters();
    prepareMocks(VDSStatus.Up);
    assertFalse(cmd.validate());
}
#end_block

#method_before
@Test
public void validateFailsForDifferentStorageDevice() {
    StorageDevice storageDevice1 = getStorageDevice("sda");
    StorageDevice storageDevice2 = getStorageDevice("sdb");
    storageDevice2.setDevType("SDA");
    doReturn(new CreateBrickParameters(HOST_ID, "brick1", "/gluster-bricks/brick1", RaidType.RAID0, null, null, Arrays.asList(storageDevice1, storageDevice2), CacheDevicePathType.sdb, CacheModeType.writethrough, "10")).when(cmd).getParameters();
    prepareMocks(VDSStatus.Up);
    assertFalse(cmd.validate());
}
#method_after
@Test
public void validateFailsForDifferentStorageDevice() {
    StorageDevice storageDevice1 = getStorageDevice("sda");
    StorageDevice storageDevice2 = getStorageDevice("sdb");
    storageDevice2.setDevType("SDA");
    doReturn(new CreateBrickParameters(HOST_ID, "brick1", "/gluster-bricks/brick1", RaidType.RAID0, null, null, Arrays.asList(storageDevice1, storageDevice2), getStorageDevice("sdb"), CacheModeType.writethrough, 10)).when(cmd).getParameters();
    prepareMocks(VDSStatus.Up);
    assertFalse(cmd.validate());
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        dataCenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getCluster()) {
        cluster_SelectedItemChanged();
    } else if (sender == getConsoleAddressEnabled()) {
        consoleAddressChanged();
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition) && (sender == getKernelCmdlineBlacklistNouveau || sender == getKernelCmdlineIommu() || sender == getKernelCmdlineKvmNested() || sender == getKernelCmdlineUnsafeInterrupts() || sender == getKernelCmdlinePciRealloc())) {
        if (isKernelCmdlineParsable()) {
            updateKernelCmdlineAccordingToCheckboxes();
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        dataCenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getCluster()) {
        cluster_SelectedItemChanged();
    } else if (sender == getConsoleAddressEnabled()) {
        consoleAddressChanged();
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition) && (sender == getKernelCmdlineBlacklistNouveau() || sender == getKernelCmdlineIommu() || sender == getKernelCmdlineKvmNested() || sender == getKernelCmdlineUnsafeInterrupts() || sender == getKernelCmdlinePciRealloc())) {
        if (isKernelCmdlineParsable()) {
            updateKernelCmdlineAccordingToCheckboxes();
        }
    }
}
#end_block

#method_before
void localize() {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressLabel.setText(constants.hostPopupHostAddressLabel());
    authSshPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    rootPasswordLabel.setText(constants.hostPopupAuthLabelForExternalHost());
    rbPasswordLabel.setText(constants.hostPopupPasswordLabel());
    rbPublicKeyLabel.setText(constants.hostPopupPublicKeyLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    // Auto PM
    disableAutomaticPowerManagementEditor.setLabel(constants.hostPopupPmDisableAutoPM());
    pmKdumpDetectionEditor.setLabel(constants.hostPopupPmKdumpDetection());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    externalDiscoveredHostsEditor.setLabel(constants.discoveredHostsLabel());
    externalHostGroupsEditor.setLabel(constants.hostGroupsLabel());
    externalComputeResourceEditor.setLabel(constants.computeResourceLabel());
    // Info icons
    kernelCmdlineUnsafeInterruptsInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineUnsafeInterruptsInfoIcon()));
    kernelCmdlineBlacklistNouveau.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineBlacklistNouveauInfoIcon()));
    kernelCmdlineIommuInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineIommuInfoIcon()));
    kernelCmdlineKvmNestedInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineKvmNestedInfoIcon()));
    kernelCmdlinePciReallocInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlinePciReallocInfoIcon()));
    kernelCmdlineInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineInfoIcon()));
    // Affinity Labels Tab
    affinityLabelsTab.setLabel(constants.affinityLabels());
}
#method_after
void localize() {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressLabel.setText(constants.hostPopupHostAddressLabel());
    authSshPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    rootPasswordLabel.setText(constants.hostPopupAuthLabelForExternalHost());
    rbPasswordLabel.setText(constants.hostPopupPasswordLabel());
    rbPublicKeyLabel.setText(constants.hostPopupPublicKeyLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    // Auto PM
    disableAutomaticPowerManagementEditor.setLabel(constants.hostPopupPmDisableAutoPM());
    pmKdumpDetectionEditor.setLabel(constants.hostPopupPmKdumpDetection());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    externalDiscoveredHostsEditor.setLabel(constants.discoveredHostsLabel());
    externalHostGroupsEditor.setLabel(constants.hostGroupsLabel());
    externalComputeResourceEditor.setLabel(constants.computeResourceLabel());
    // Info icons
    kernelCmdlineUnsafeInterruptsInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineUnsafeInterruptsInfoIcon()));
    kernelCmdlineBlacklistNouveauInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineBlacklistNouveauInfoIcon()));
    kernelCmdlineIommuInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineIommuInfoIcon()));
    kernelCmdlineKvmNestedInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineKvmNestedInfoIcon()));
    kernelCmdlinePciReallocInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlinePciReallocInfoIcon()));
    kernelCmdlineInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineInfoIcon()));
    // Affinity Labels Tab
    affinityLabelsTab.setLabel(constants.affinityLabels());
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setClusterId(getClusterId());
    vds.setClusterCpuName(getClusterCpuName());
    vds.setCpuName(getCpuName());
    vds.setClusterDescription(getClusterDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setExternalStatus(getExternalStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setVersion(getVersion());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterfsCliVersion(getGlusterfsCliVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setLibrbdVersion(getLibrbdVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    vds.setClusterCompatibilityVersion(getClusterCompatibilityVersion());
    vds.setUpdateAvailable(isUpdateAvailable());
    vds.setHostDevicePassthroughEnabled(isHostDevicePassthroughEnabled());
    vds.setHostedEngineHost(isHostedEngineHost());
    vds.setCurrentKernelCmdline(getCurrentKernelCmdline());
    vds.setLastStoredKernelCmdline(getLastStoredKernelCmdline());
    vds.setKernelCmdlineBlacklistNouveau(isKernelCmdlineBlacklistNouveau());
    vds.setKernelCmdlineIommu(isKernelCmdlineIommu());
    vds.setKernelCmdlineKvmNested(isKernelCmdlineKvmNested());
    vds.setKernelCmdlineParsable(isKernelCmdlineParsable());
    vds.setKernelCmdlinePciRealloc(isKernelCmdlinePciRealloc());
    vds.setKernelCmdlineUnsafeInterrupts(isKernelCmdlineUnsafeInterrupts());
    vds.setGlusterPeerStatus(getGlusterPeerStatus());
    vds.setKernelFeatures(getKernelFeatures());
    DnsResolverConfiguration originalDnsResolverConfiguration = getReportedDnsResolverConfiguration();
    if (originalDnsResolverConfiguration != null) {
        vds.setReportedDnsResolverConfiguration(new DnsResolverConfiguration(originalDnsResolverConfiguration));
    }
    vds.setInFenceFlow(isInFenceFlow());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setClusterId(getClusterId());
    vds.setClusterCpuName(getClusterCpuName());
    vds.setCpuName(getCpuName());
    vds.setClusterDescription(getClusterDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setExternalStatus(getExternalStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setVersion(getVersion());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterfsCliVersion(getGlusterfsCliVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setLibrbdVersion(getLibrbdVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    vds.setClusterCompatibilityVersion(getClusterCompatibilityVersion());
    vds.setUpdateAvailable(isUpdateAvailable());
    vds.setHostDevicePassthroughEnabled(isHostDevicePassthroughEnabled());
    vds.setHostedEngineHost(isHostedEngineHost());
    vds.setCurrentKernelCmdline(getCurrentKernelCmdline());
    vds.setLastStoredKernelCmdline(getLastStoredKernelCmdline());
    vds.setKernelCmdlineParsable(isKernelCmdlineParsable());
    vds.setKernelCmdlineBlacklistNouveau(isKernelCmdlineBlacklistNouveau());
    vds.setKernelCmdlineIommu(isKernelCmdlineIommu());
    vds.setKernelCmdlineKvmNested(isKernelCmdlineKvmNested());
    vds.setKernelCmdlinePciRealloc(isKernelCmdlinePciRealloc());
    vds.setKernelCmdlineUnsafeInterrupts(isKernelCmdlineUnsafeInterrupts());
    vds.setGlusterPeerStatus(getGlusterPeerStatus());
    vds.setKernelFeatures(getKernelFeatures());
    DnsResolverConfiguration originalDnsResolverConfiguration = getReportedDnsResolverConfiguration();
    if (originalDnsResolverConfiguration != null) {
        vds.setReportedDnsResolverConfiguration(new DnsResolverConfiguration(originalDnsResolverConfiguration));
    }
    vds.setInFenceFlow(isInFenceFlow());
    return vds;
}
#end_block

#method_before
public List<MapVnicContext> getContexts() {
    if (contexts == null) {
        contexts = new LinkedList<>();
    }
    return contexts;
}
#method_after
public List<MapVnicContext> getContexts() {
    return contexts;
}
#end_block

#method_before
public Map<VmNetworkInterface, ExternalVnicProfileMapping> getMatched() {
    if (matched == null) {
        matched = new HashMap<>();
    }
    return matched;
}
#method_after
public Map<VmNetworkInterface, ExternalVnicProfileMapping> getMatched() {
    return matched;
}
#end_block

#method_before
public void addNonAssociableVnic(String vnic) {
    if (nonAssociableVnics == null) {
        nonAssociableVnics = new LinkedList<>();
    }
    nonAssociableVnics.add(vnic);
}
#method_after
public void addNonAssociableVnic(String vnic) {
    nonAssociableVnics.add(vnic);
}
#end_block

#method_before
private static MapVnicFlow getMapVnicFlow() {
    return new MapVnicFlow(new SourceNameExistsOnEngine(mock(VnicProfileViewDao.class)), new TargetIdExistsOnEngine(mock(VnicProfileDao.class)), new TargetNameExistsOnEngine(mock(VnicProfileViewDao.class)), new NetworkAttachedToCluster(mock(NetworkClusterDao.class)), new NetworkAttachedToCluster(mock(NetworkClusterDao.class)), new ApplyProfileById(mock(NetworkDao.class)));
}
#method_after
private static MapVnicFlow getMapVnicFlow() {
    return new MapVnicFlow(new SourceNameExistsOnEngine(mock(VnicProfileViewDao.class)), new TargetIdExistsOnEngine(mock(VnicProfileDao.class)), new TargetNameExistsOnEngine(mock(VnicProfileViewDao.class)), new NetworkAttachedToCluster(mock(NetworkClusterDao.class)), new NetworkAttachedToCluster(mock(NetworkClusterDao.class)), new NetworkAttachedToCluster(mock(NetworkClusterDao.class)), new ApplyProfileById(mock(NetworkDao.class)));
}
#end_block

#method_before
private static MapVnicsCollectionFlow getMapVnicsCollectionFlow() {
    return MapVnicsCollectionFlow.of(mock(VnicProfileViewDao.class), mock(VnicProfileDao.class), mock(NetworkClusterDao.class), mock(NetworkDao.class));
}
#method_after
private static MapVnicsFlow getMapVnicsCollectionFlow() {
    return MapVnicsFlow.of(mock(VnicProfileViewDao.class), mock(VnicProfileDao.class), mock(NetworkClusterDao.class), mock(NetworkDao.class));
}
#end_block

#method_before
public void init() {
    profileMappingSpecified = new ProfileMappingSpecified();
    Handler<MapVnicContext> targetProfileSpecified = new TargetProfileSpecified();
    Handler<MapVnicContext> targetIdSpecified = new TargetIdSpecified();
    Handler<MapVnicContext> targetNamesSpecified = new TargetNamesSpecified();
    Handler<MapVnicContext> targetNamesAreEmptyString = new TargetNamesAreEmptyString();
    Handler<MapVnicContext> applyNoProfile = new ApplyNoProfile();
    // do nothing because during the command#executeAction phase {@link VnicProfileHelper}
    // will try to match a profile to the network appearing in the source vnic
    // see VnicProfileHelper#updateNicWithVnicProfileForUser
    Handler<MapVnicContext> fallBack = new NOP<>();
    profileMappingSpecified.setOnSuccess(targetProfileSpecified);
    profileMappingSpecified.setOnFailure(sourceNameExistsOnEngine);
    targetProfileSpecified.setOnSuccess(targetIdSpecified);
    targetProfileSpecified.setOnFailure(sourceNameExistsOnEngine);
    targetIdSpecified.setOnSuccess(targetIdExistsOnEngine);
    targetIdSpecified.setOnFailure(targetNamesSpecified);
    targetIdExistsOnEngine.setOnSuccess(targetNetworkAttachedToCluster);
    targetIdExistsOnEngine.setOnFailure(targetNamesSpecified);
    targetNamesSpecified.setOnSuccess(targetNamesAreEmptyString);
    targetNamesSpecified.setOnFailure(sourceNameExistsOnEngine);
    targetNetworkAttachedToCluster.setName("targetNetworkAttachedToCluster");
    targetNetworkAttachedToCluster.setOnSuccess(applyProfileById);
    targetNetworkAttachedToCluster.setOnFailure(targetNamesSpecified);
    targetNamesAreEmptyString.setOnSuccess(applyNoProfile);
    targetNamesAreEmptyString.setOnFailure(targetNameExistsOnEngine);
    targetNameExistsOnEngine.setOnSuccess(namedNetworkAttachedToCluster);
    targetNameExistsOnEngine.setOnFailure(sourceNameExistsOnEngine);
    sourceNameExistsOnEngine.setOnSuccess(namedNetworkAttachedToCluster);
    sourceNameExistsOnEngine.setOnFailure(fallBack);
    namedNetworkAttachedToCluster.setName("namedNetworkAttachedToCluster");
    namedNetworkAttachedToCluster.setOnSuccess(applyProfileById);
    namedNetworkAttachedToCluster.setOnFailure(fallBack);
}
#method_after
public void init() {
    profileMappingSpecified = new ProfileMappingSpecified();
    Handler<MapVnicContext> targetProfileSpecified = new TargetProfileSpecified();
    Handler<MapVnicContext> targetIdSpecified = new TargetIdSpecified();
    Handler<MapVnicContext> targetNamesSpecified = new TargetNamesSpecified();
    Handler<MapVnicContext> targetNamesAreEmptyString = new TargetNamesAreEmptyString();
    Handler<MapVnicContext> applyNoProfile = new ApplyNoProfile();
    Handler<MapVnicContext> fallBack = new ApplyNoProfile();
    profileMappingSpecified.setOnSuccess(targetProfileSpecified);
    profileMappingSpecified.setOnFailure(sourceNameExistsOnEngine);
    targetProfileSpecified.setOnSuccess(targetIdSpecified);
    targetProfileSpecified.setOnFailure(sourceNameExistsOnEngine);
    targetIdSpecified.setOnSuccess(targetIdExistsOnEngine);
    targetIdSpecified.setOnFailure(targetNamesSpecified);
    targetIdExistsOnEngine.setOnSuccess(targetIdNetworkAttachedToCluster);
    targetIdExistsOnEngine.setOnFailure(targetNamesSpecified);
    targetNamesSpecified.setOnSuccess(targetNamesAreEmptyString);
    targetNamesSpecified.setOnFailure(sourceNameExistsOnEngine);
    targetIdNetworkAttachedToCluster.setName("Target_IdNetworkAttachedToCluster");
    targetIdNetworkAttachedToCluster.setOnSuccess(applyProfileById);
    targetIdNetworkAttachedToCluster.setOnFailure(targetNamesSpecified);
    targetNamesAreEmptyString.setOnSuccess(applyNoProfile);
    targetNamesAreEmptyString.setOnFailure(targetNameExistsOnEngine);
    targetNameExistsOnEngine.setOnSuccess(targetNameNetworkAttachedToCluster);
    targetNameExistsOnEngine.setOnFailure(sourceNameExistsOnEngine);
    sourceNameExistsOnEngine.setOnSuccess(sourceNetworkAttachedToCluster);
    sourceNameExistsOnEngine.setOnFailure(fallBack);
    targetNameNetworkAttachedToCluster.setName("Target_NameNetworkAttachedToCluster");
    targetNameNetworkAttachedToCluster.setOnSuccess(applyProfileById);
    targetNameNetworkAttachedToCluster.setOnFailure(sourceNameExistsOnEngine);
    sourceNetworkAttachedToCluster.setName("Source_NameNetworkAttachedToCluster");
    sourceNetworkAttachedToCluster.setOnSuccess(applyProfileById);
    sourceNetworkAttachedToCluster.setOnFailure(fallBack);
}
#end_block

#method_before
@Override
public HandlerOutcome handle(MapVnicContext ctx) {
    List<NetworkCluster> clusterNetworks = networkClusterDao.getAllForCluster(ctx.getClusterId());
    if (clusterNetworks != null) {
        Optional<NetworkCluster> found = clusterNetworks.stream().filter(networkCluster -> networkCluster.getNetworkId() != null && networkCluster.getNetworkId().equals(ctx.getVnicProfileFoundByDao().getNetworkId())).findFirst();
        if (found.isPresent()) {
            ctx.trace(SUCCESS, NetworkAttachedToCluster.class);
            return SUCCESS;
        }
    }
    ctx.trace(FAILURE, NetworkAttachedToCluster.class);
    return FAILURE;
}
#method_after
@Override
public HandlerOutcome handle(MapVnicContext ctx) {
    NetworkCluster networkCluster = networkClusterDao.get(new NetworkClusterId(ctx.getClusterId(), ctx.getVnicProfileFoundByDao().getNetworkId()));
    HandlerOutcome outcome = networkCluster != null ? SUCCESS : FAILURE;
    ctx.trace(outcome, NetworkAttachedToCluster.class);
    return outcome;
}
#end_block

#method_before
public ExternalVnicProfileMapping getExternalVnicProfileMapping() {
    if (externalVnicProfileMapping.getTargetProfileId() == null) {
        externalVnicProfileMapping.setTargetNetworkName("");
        externalVnicProfileMapping.setTargetProfileName("");
    }
    return externalVnicProfileMapping;
}
#method_after
public ExternalVnicProfileMapping getExternalVnicProfileMapping() {
    return externalVnicProfileMapping;
}
#end_block

#method_before
public Cluster getMappedCluster(String clusterName, Guid vmId, Map<String, String> clusterMap) {
    Cluster mappedCluster = getRelatedEntity(clusterMap, clusterName, val -> clusterDao.getByName(val));
    log.info("Mapping cluster '{}' to '{}' for vm '{}'.", mappedCluster, clusterName, vmId);
    return mappedCluster;
}
#method_after
public Cluster getMappedCluster(String clusterName, Guid vmId, Map<String, String> clusterMap) {
    Cluster mappedCluster = getRelatedEntity(clusterMap, clusterName, val -> clusterDao.getByName(val));
    log.info("Mapping cluster '{}' to '{}' for vm '{}'.", clusterName, mappedCluster, vmId);
    return mappedCluster;
}
#end_block

#method_before
public List<String> updateVnicsFromMappings(Guid clusterId, String vmName, List<VmNetworkInterface> vnics, Collection<ExternalVnicProfileMapping> mappings) {
    MapVnicsContext ctx = new MapVnicsContext("updateVnicsFromMappings").setClusterId(clusterId).setVmName(vmName).setOvfVnics(vnics).setUserMappings(mappings);
    mapVnicsCollectionFlow.getHead().process(ctx);
    return !CollectionUtils.isEmpty(ctx.getNonAssociableVnics()) ? ctx.getNonAssociableVnics() : Collections.emptyList();
}
#method_after
public List<String> updateVnicsFromMappings(Guid clusterId, String vmName, List<VmNetworkInterface> vnics, Collection<ExternalVnicProfileMapping> mappings) {
    MapVnicsContext ctx = new MapVnicsContext("updateVnicsFromMappings").setClusterId(clusterId).setVmName(vmName).setOvfVnics(vnics).setUserMappings(mappings);
    mapVnicsFlow.getHead().process(ctx);
    return !CollectionUtils.isEmpty(ctx.getNonAssociableVnics()) ? ctx.getNonAssociableVnics() : Collections.emptyList();
}
#end_block

#method_before
@Override
protected boolean validate() {
    initVmTemplate();
    if (!super.validate()) {
        return false;
    }
    ArrayList<DiskImage> disks = new ArrayList(getVmTemplate().getDiskTemplateMap().values());
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), disks);
    getVmTemplate().setImages(disks);
    if (getParameters().isImagesExistOnTargetStorageDomain() && !validateUnregisteredEntity(vmTemplateFromConfiguration, ovfEntityData)) {
        return false;
    }
    removeInvalidUsers(getImportValidator());
    removeInavlidRoles(getImportValidator());
    missingVnicMappings = drMappingHelper.updateVnicsFromMappings(getParameters().getClusterId(), getParameters().getVmTemplate().getName(), vmTemplateFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings());
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    initVmTemplate();
    if (!super.validate()) {
        return false;
    }
    ArrayList<DiskImage> disks = new ArrayList(getVmTemplate().getDiskTemplateMap().values());
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), disks);
    getVmTemplate().setImages(disks);
    if (getParameters().isImagesExistOnTargetStorageDomain() && !validateUnregisteredEntity(vmTemplateFromConfiguration, ovfEntityData)) {
        return false;
    }
    removeInvalidUsers(getImportValidator());
    removeInavlidRoles(getImportValidator());
    return super.validate();
}
#end_block

#method_before
@Override
public void executeCommand() {
    super.executeCommand();
    addAuditLogForPartialVMs();
    if (getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!getImages().isEmpty()) {
            findAndSaveDiskCopies();
            getImages().stream().forEach(diskImage -> {
                initQcowVersionForDisks(diskImage.getId());
            });
        }
        unregisteredOVFDataDao.removeEntity(ovfEntityData.getEntityId(), null);
        unregisteredDisksDao.removeUnregisteredDiskRelatedToVM(ovfEntityData.getEntityId(), null);
    }
    setActionReturnValue(getVmTemplate().getId());
    setSucceeded(true);
}
#method_after
@Override
public void executeCommand() {
    updateVnicsFromMapping();
    super.executeCommand();
    addAuditLogForPartialVMs();
    if (getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!getImages().isEmpty()) {
            findAndSaveDiskCopies();
            getImages().stream().forEach(diskImage -> {
                initQcowVersionForDisks(diskImage.getId());
            });
        }
        unregisteredOVFDataDao.removeEntity(ovfEntityData.getEntityId(), null);
        unregisteredDisksDao.removeUnregisteredDiskRelatedToVM(ovfEntityData.getEntityId(), null);
    }
    setActionReturnValue(getVmTemplate().getId());
    setSucceeded(true);
}
#end_block

#method_before
public void setSourceNetworkName(String name) {
    initSource();
    setNetworkName(source, name);
}
#method_after
public void setSourceNetworkName(String name) {
    sourceNetworkName = name;
}
#end_block

#method_before
public void setTargetNetworkName(String name) {
    initTarget();
    setNetworkName(target, name);
}
#method_after
public void setTargetNetworkName(String name) {
    targetNetworkName = name;
}
#end_block

#method_before
public String getSourceNetworkName() {
    return getNetworkName(source);
}
#method_after
public String getSourceNetworkName() {
    return sourceNetworkName;
}
#end_block

#method_before
public String getTargetNetworkName() {
    return getNetworkName(target);
}
#method_after
public String getTargetNetworkName() {
    return targetNetworkName;
}
#end_block

#method_before
public String getSourceProfileName() {
    return getProfileName(source);
}
#method_after
public String getSourceProfileName() {
    return sourceProfileName;
}
#end_block

#method_before
public String getTargetProfileName() {
    return getProfileName(target);
}
#method_after
public String getTargetProfileName() {
    return targetProfileName;
}
#end_block

#method_before
public void setSourceProfileName(String name) {
    initSource();
    setProfileName(source, name);
}
#method_after
public void setSourceProfileName(String name) {
    sourceProfileName = name;
}
#end_block

#method_before
public void setTargetProfileName(String name) {
    initTarget();
    setProfileName(target, name);
}
#method_after
public void setTargetProfileName(String name) {
    targetProfileName = name;
}
#end_block

#method_before
public Guid getTargetProfileId() {
    return hasTarget() ? target.getId() : null;
}
#method_after
public Guid getTargetProfileId() {
    return targetProfileId;
}
#end_block

#method_before
public void setTargetProfileId(Guid id) {
    initTarget();
    target.setId(id);
}
#method_after
public void setTargetProfileId(Guid id) {
    targetProfileId = id;
}
#end_block

#method_before
public boolean hasTarget() {
    return has(target);
}
#method_after
public boolean hasTarget() {
    return hasTargetId() || hasTargetNames();
}
#end_block

#method_before
public boolean isSameSourceProfile(ExternalVnicProfileMapping other) {
    if (this.source == null && other.source == null) {
        return true;
    }
    if (this.source == null || other.source == null) {
        return false;
    }
    return Objects.equals(getSourceNetworkName(), other.getSourceNetworkName()) && Objects.equals(getSourceProfileName(), other.getSourceProfileName());
}
#method_after
public boolean isSameSourceProfile(ExternalVnicProfileMapping other) {
    return Objects.equals(getSourceNetworkName(), other.getSourceNetworkName()) && Objects.equals(getSourceProfileName(), other.getSourceProfileName());
}
#end_block

#method_before
public boolean equalsEntire(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof ExternalVnicProfileMapping)) {
        return false;
    }
    ExternalVnicProfileMapping that = (ExternalVnicProfileMapping) o;
    return Objects.equals(source, that.source) && Objects.equals(target, that.target);
}
#method_after
public boolean equalsEntire(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof ExternalVnicProfileMapping)) {
        return false;
    }
    ExternalVnicProfileMapping that = (ExternalVnicProfileMapping) o;
    return Objects.equals(getSourceProfileName(), that.getSourceProfileName()) && Objects.equals(getSourceNetworkName(), that.getSourceNetworkName()) && Objects.equals(getTargetProfileName(), that.getTargetProfileName()) && Objects.equals(getTargetNetworkName(), that.getTargetNetworkName()) && Objects.equals(getTargetProfileId(), that.getTargetProfileId());
}
#end_block

#method_before
public int hashCodeEntire() {
    return Objects.hash(source, target);
}
#method_after
public int hashCodeEntire() {
    return Objects.hash(getSourceProfileName(), getSourceNetworkName(), getTargetProfileName(), getTargetNetworkName(), getTargetProfileId());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (isImagesAlreadyOnTarget()) {
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(ovfEntityData))) {
            return false;
        }
        if (!validate(importValidator.validateDiskNotAlreadyExistOnDB(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistForUnregisteredEntity(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistsForMemoryDisks(getVm().getSnapshots(), getParameters().isAllowPartialImport(), failedDisksToImportForAuditLog))) {
            return false;
        }
        removeInvalidAffinityGroups(importValidator);
        removeInvalidAffinityLabels(importValidator);
        removeInavlidUsers(importValidator);
        removeInavlidRoles(importValidator);
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
        missingVnicMappings = drMappingHelper.updateVnicsFromMappings(getParameters().getClusterId(), getParameters().getVm().getName(), getParameters().getVm().getInterfaces(), getParameters().getExternalVnicProfileMappings());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    // be ignored.
    if (!isValidDisks()) {
        return false;
    }
    // We call super validate only after the invalid disks has been removed from imageToDestinationDomainMap.
    if (!super.validate()) {
        return false;
    }
    // Validate all the rest of the properties including affinity groups/labels/vnic_profile/users and roles
    if (!validateEntityPropertiesWhenImagesOnTarget()) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void executeVmCommand() {
    addAuditLogForPartialVMs();
    super.executeVmCommand();
    if (getSucceeded()) {
        if (isImagesAlreadyOnTarget()) {
            getImages().stream().forEach(diskImage -> {
                initQcowVersionForDisks(diskImage.getId());
            });
            unregisteredOVFDataDao.removeEntity(ovfEntityData.getEntityId(), null);
            unregisteredDisksDao.removeUnregisteredDiskRelatedToVM(ovfEntityData.getEntityId(), null);
            auditLogDirector.log(this, AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY);
        } else if (!vmDisksToAttach.isEmpty()) {
            auditLogDirector.log(this, attemptToAttachDisksToImportedVm(vmDisksToAttach));
        }
    }
    setActionReturnValue(getVm().getId());
}
#method_after
@Override
public void executeVmCommand() {
    updateVnicsFromMapping();
    addAuditLogForPartialVMs();
    super.executeVmCommand();
    if (getSucceeded()) {
        if (isImagesAlreadyOnTarget()) {
            getImages().stream().forEach(diskImage -> {
                initQcowVersionForDisks(diskImage.getId());
            });
            unregisteredOVFDataDao.removeEntity(ovfEntityData.getEntityId(), null);
            unregisteredDisksDao.removeUnregisteredDiskRelatedToVM(ovfEntityData.getEntityId(), null);
            auditLogDirector.log(this, AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY);
        } else if (!vmDisksToAttach.isEmpty()) {
            auditLogDirector.log(this, attemptToAttachDisksToImportedVm(vmDisksToAttach));
        }
    }
    setActionReturnValue(getVm().getId());
}
#end_block

#method_before
@Override
public HandlerOutcome handle(MapVnicContext ctx) {
    List<NetworkCluster> clusterNetworks = networkClusterDao.getAllForCluster(ctx.getClusterId());
    if (clusterNetworks != null) {
        Optional<NetworkCluster> found = clusterNetworks.stream().filter(networkCluster -> networkCluster.getNetworkId() != null && networkCluster.getNetworkId().equals(ctx.getVnicProfileFoundByDao().getNetworkId())).findFirst();
        if (found.isPresent()) {
            ctx.trace(SUCCESS, NetworkAttachedToCluster.class);
            return SUCCESS;
        }
    }
    ctx.trace(FAILURE, NetworkAttachedToCluster.class);
    return FAILURE;
}
#method_after
@Override
public HandlerOutcome handle(MapVnicContext ctx) {
    NetworkCluster networkCluster = networkClusterDao.get(new NetworkClusterId(ctx.getClusterId(), ctx.getVnicProfileFoundByDao().getNetworkId()));
    HandlerOutcome outcome = networkCluster != null ? SUCCESS : FAILURE;
    ctx.trace(outcome, NetworkAttachedToCluster.class);
    return outcome;
}
#end_block

#method_before
@Override
public void onResponse(Map<String, Object> response) {
    try {
        processRefreshVdsStatsResponse((VDSReturnValue) response.get("result"));
        if (!isVdsUpOrGoingToMaintenance) {
            vdsManager.setStatus(VDSStatus.Up, vds);
        }
        refreshVdsRunTimeInfo(isVdsUpOrGoingToMaintenance);
    } catch (Throwable t) {
        onFailure(t);
    }
}
#method_after
@Override
public void onResponse(Map<String, Object> response) {
    try {
        processRefreshVdsStatsResponse((VDSReturnValue) response.get("result"));
        if (!vdsUpOrGoingToMaintenance) {
            vdsManager.setStatus(VDSStatus.Up, vds);
        }
        refreshVdsRunTimeInfo(vdsUpOrGoingToMaintenance);
    } catch (Throwable t) {
        onFailure(t);
    }
}
#end_block

#method_before
private boolean validateSnapshotDisksArePlugged() {
    Map<Guid, Disk> vmDisks = diskDao.getAllForVm(getVmId()).stream().collect(Collectors.toMap(Disk::getId, Function.identity()));
    String unpluggedDisks = getSourceImages().stream().map(DiskImage::getId).map(vmDiskId -> vmDisks.getOrDefault(vmDiskId, diskDao.get(vmDiskId))).filter(disk -> !disk.getPlugged()).map(Disk::getDiskAlias).collect(Collectors.joining("\n"));
    if (!unpluggedDisks.isEmpty()) {
        return validate(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_UNPLUGGED_OR_UNATTACHED_DISKS, String.format("$diskAliases %s", unpluggedDisks)));
    }
    return true;
}
#method_after
private boolean validateSnapshotDisksArePlugged() {
    Map<Guid, Disk> vmDisks = diskDao.getAllForVm(getVmId()).stream().collect(Collectors.toMap(Disk::getId, Function.identity()));
    // If there is an unattached disk, it will not be included in vmDisks, hence it is
    // retrieved by the diskDao. This is less likely to happen as it is not possible
    // to unattach disks with snapshots.
    String unpluggedDisks = getSourceImages().stream().map(DiskImage::getId).map(vmDiskId -> vmDisks.getOrDefault(vmDiskId, diskDao.get(vmDiskId))).filter(disk -> !disk.getPlugged()).map(Disk::getDiskAlias).collect(Collectors.joining(System.lineSeparator()));
    if (!unpluggedDisks.isEmpty()) {
        return validate(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_UNPLUGGED_OR_UNATTACHED_DISKS, String.format("$diskAliases %s", unpluggedDisks)));
    }
    return true;
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writeLeases();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeLease() {
    if (vm.getLeaseStorageDomainId() == null) {
        return;
    }
    writer.writeStartElement("lease");
    writer.writeElement("key", vm.getId().toString());
    writer.writeElement("lockspace", vm.getLeaseStorageDomainId().toString());
    writer.writeStartElement("target");
    Map<String, String> leaseInfo = vm.getLeaseInfo();
    writer.writeAttributeString("offset", leaseInfo.get(VdsProperties.VmLeaseOffset));
    writer.writeAttributeString("path", leaseInfo.get(VdsProperties.VmLeasePath));
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeLease(String key, String lockspace, String path, String offset) {
    writer.writeStartElement("lease");
    writer.writeElement("key", key);
    writer.writeElement("lockspace", lockspace);
    writer.writeStartElement("target");
    writer.writeAttributeString("offset", offset);
    writer.writeAttributeString("path", path);
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            // Change parameters for the HE disk
            if (vm.isHostedEngine()) {
                // Hosted engine disk images have to have empty storage pool ID,
                // so they can be mounted even if storage pool is not connected.
                diskImage.setStoragePoolId(Guid.Empty);
                diskImage.setPropagateErrors(PropagateErrors.Off);
                diskImage.setShareable(false);
            }
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    // drop to the 'file' case as a fallback.
                    if (volInfo != null) {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            // Change parameters for the HE disk
            if (vm.isHostedEngine()) {
                // Hosted engine disk images have to have empty storage pool ID,
                // so they can be mounted even if storage pool is not connected.
                diskImage.setStoragePoolId(Guid.Empty);
                diskImage.setPropagateErrors(PropagateErrors.Off);
                // The disk requires a lease
                addVolumeLease(diskImage.getImageId(), diskImage.getStorageIds().get(0));
            }
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    // drop to the 'file' case as a fallback.
                    if (volInfo != null) {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#end_block

#method_before
private Map<String, String> createDiskParams(DiskImage diskImage) {
    Map<String, String> diskParams = createDiskUuidsMap(diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId());
    if (!diskImage.getActive()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Transient);
    }
    return diskParams;
}
#method_after
private Map<String, String> createDiskParams(DiskImage diskImage) {
    Map<String, String> diskParams = createDiskUuidsMap(diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId());
    if (!diskImage.getActive()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Transient);
    } else if (diskImage.isShareable()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Shareable);
    } else if (vm.isHostedEngine()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Exclusive);
    }
    return diskParams;
}
#end_block

#method_before
private Map<String, String> createDiskUuidsMap(Guid poolId, Guid domainId, Guid imageId, Guid volumeId) {
    Map<String, String> diskUuids = new HashMap<>();
    diskUuids.put("poolID", poolId.toString());
    diskUuids.put("domainID", domainId.toString());
    diskUuids.put("imageID", imageId.toString());
    diskUuids.put("volumeID", volumeId.toString());
    return diskUuids;
}
#method_after
private Map<String, String> createDiskUuidsMap(Guid poolId, Guid domainId, Guid imageId, Guid volumeId) {
    return PDIVMapBuilder.create().setPoolId(poolId).setDomainId(domainId).setImageGroupId(imageId).setVolumeId(volumeId).build();
}
#end_block

#method_before
private void writeAlias(VmDevice device) {
    writer.writeStartElement("alias");
    writer.writeAttributeString("name", String.format("ua-%s", device.getId().getDeviceId()));
    writer.writeEndElement();
}
#method_after
private void writeAlias(VmDevice device) {
    if (device.isManaged()) {
        writer.writeStartElement("alias");
        writer.writeAttributeString("name", String.format("ua-%s", device.getId().getDeviceId()));
        writer.writeEndElement();
    }
}
#end_block

#method_before
@Override
public void init() {
    this.contentContainer.setVisible(false);
    if (contentContainer.getWidgetCount() > 0) {
        setIsHtml(true);
    }
    addShowHandler(e -> {
        for (int i = 0; i < contentContainer.getWidgetCount(); i++) {
            contentContainer.getWidget(0).setVisible(true);
        }
    });
    Element element = getWidget().getElement();
    JavaScriptObject baseOptions = createOptions(element, isAnimated(), isHtml(), getSelector(), getTrigger().getCssName(), getShowDelayMs(), getHideDelayMs(), getContainer(), prepareTemplate(), getViewportSelector(), getViewportPadding());
    popover(element, baseOptions, getContent(), HASH + contentId, HASH + contentContainer.getElement().getId());
    bindJavaScriptEvents(element);
    setInitialized(true);
}
#method_after
@Override
public void init() {
    this.contentContainer.setVisible(false);
    if (contentContainer.getWidgetCount() > 0) {
        setIsHtml(true);
    }
    addShowHandler(e -> {
        for (int i = 0; i < contentContainer.getWidgetCount(); i++) {
            contentContainer.getWidget(0).setVisible(true);
        }
    });
    Element element = getWidget().getElement();
    JavaScriptObject baseOptions = createOptions(element, isAnimated(), isHtml(), getSelector(), getTrigger().getCssName(), getShowDelayMs(), getHideDelayMs(), getContainer(), prepareTemplate(), getViewportSelector(), getViewportPadding());
    popover(element, baseOptions, HASH + contentId, HASH + contentContainer.getElement().getId());
    bindJavaScriptEvents(element);
    setInitialized(true);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    importVmLease();
    super.executeVmCommand();
}
#method_after
@Override
protected void executeVmCommand() {
    handleVmLease();
    super.executeVmCommand();
}
#end_block

#method_before
private List<Map<String, Object>> parseChannels(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.CHANNEL);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.CHANNEL)) {
        String address = parseAddress(node);
        // Ignore channel devices without address
        if (address.isEmpty()) {
            continue;
        }
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.CHANNEL.getValue());
        // shouldn't it be VdsProperties.DeviceType?
        dev.put(VdsProperties.Device, parseAttribute(node, TYPE));
        dev.put(VdsProperties.Address, address);
        dev.put(VdsProperties.Alias, parseAlias(node));
        VmDevice dbDev = dbDevices.stream().filter(d -> d.getDevice().equals(dev.get(VdsProperties.Device))).findFirst().orElse(null);
        if (dbDev != null) {
            dbDevices.remove(dbDev);
            dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
            dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        } else {
            dev.put(VdsProperties.DeviceId, Guid.newGuid().toString());
        }
        result.add(dev);
    }
    return result;
}
#method_after
private List<Map<String, Object>> parseChannels(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.CHANNEL);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.CHANNEL)) {
        String address = parseAddress(node);
        // Ignore channel devices without address
        if (address.isEmpty()) {
            continue;
        }
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.CHANNEL.getValue());
        // shouldn't it be VdsProperties.DeviceType?
        dev.put(VdsProperties.Device, parseAttribute(node, TYPE));
        dev.put(VdsProperties.Address, address);
        dev.put(VdsProperties.Alias, parseAlias(node));
        VmDevice dbDev = correlate(dev, dbDevices, device -> dbDevices.stream().filter(d -> d.getDevice().equals(device.get(VdsProperties.Device))).findFirst().orElse(null));
        if (dbDev != null) {
            dbDevices.remove(dbDev);
            dev.put(VdsProperties.DeviceId, dbDev.getDeviceId().toString());
            dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        } else {
            dev.put(VdsProperties.DeviceId, Guid.newGuid().toString());
        }
        result.add(dev);
    }
    return result;
}
#end_block

#method_before
private List<Map<String, Object>> parseControllers(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.CONTROLLER);
    // devices with spec params to appear first
    dbDevices.sort((d1, d2) -> d1.getSpecParams().isEmpty() && !d2.getSpecParams().isEmpty() ? 1 : 0);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.CONTROLLER)) {
        String address = parseAddress(node);
        Integer ioThreadId = parseIoThreadId(node);
        String index = parseAttribute(node, INDEX);
        String model = parseAttribute(node, MODEL);
        String devType = "virtio-scsi".equals(model) ? model : parseAttribute(node, TYPE);
        boolean devWithModelNone = model != null ? model.equals(UsbControllerModel.NONE.libvirtName) : false;
        // which is a special case of a device without address that is still marked as plugged
        if (address.isEmpty() && !devWithModelNone) {
            continue;
        }
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        dev.put(VdsProperties.Device, devType);
        dev.put(VdsProperties.Address, address);
        dev.put(VdsProperties.Alias, parseAlias(node));
        dev.put(VdsProperties.SpecParams, new HashMap<>());
        if (index != null) {
            ((Map<String, Object>) dev.get(VdsProperties.SpecParams)).put(INDEX, index);
        }
        if (model != null) {
            ((Map<String, Object>) dev.get(VdsProperties.SpecParams)).put(MODEL, model);
        }
        if (ioThreadId != null) {
            ((Map<String, Object>) dev.get(VdsProperties.SpecParams)).put(IO_THREAD_ID, ioThreadId);
        }
        VmDevice dbDev = dbDevices.stream().filter(d -> d.getDevice().equals(dev.get(VdsProperties.Device))).filter(d -> d.getSpecParams().isEmpty() || Objects.equals(d.getSpecParams().get(INDEX), index)).filter(d -> d.getSpecParams().isEmpty() || Objects.equals(d.getSpecParams().get(MODEL), model)).findFirst().orElse(dbDevices.stream().filter(d -> d.getDevice().equals(dev.get(VdsProperties.Device))).filter(d -> d.getSpecParams().isEmpty() || Objects.equals(d.getSpecParams().get(IO_THREAD_ID), ioThreadId)).findFirst().orElse(null));
        if (dbDev != null) {
            dbDevices.remove(dbDev);
            dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
        } else {
            dev.put(VdsProperties.DeviceId, Guid.newGuid().toString());
        }
        result.add(dev);
    }
    return result;
}
#method_after
private List<Map<String, Object>> parseControllers(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.CONTROLLER);
    // devices with spec params to appear first
    dbDevices.sort((d1, d2) -> d1.getSpecParams().isEmpty() && !d2.getSpecParams().isEmpty() ? 1 : 0);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.CONTROLLER)) {
        String address = parseAddress(node);
        String index = parseAttribute(node, INDEX);
        String model = parseAttribute(node, MODEL);
        Integer ioThreadId = parseIoThreadId(node);
        String devType = "virtio-scsi".equals(model) ? model : parseAttribute(node, TYPE);
        boolean devWithModelNone = model != null ? model.equals(UsbControllerModel.NONE.libvirtName) : false;
        // which is a special case of a device without address that is still marked as plugged
        if (address.isEmpty() && !devWithModelNone) {
            continue;
        }
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        dev.put(VdsProperties.Device, devType);
        dev.put(VdsProperties.Address, address);
        dev.put(VdsProperties.Alias, parseAlias(node));
        VmDevice dbDev = correlate(dev, dbDevices, device -> dbDevices.stream().filter(d -> d.getDevice().equals(device.get(VdsProperties.Device))).filter(d -> {
            if (d.getSpecParams().isEmpty()) {
                return true;
            }
            if (ioThreadId != null && Objects.equals(d.getSpecParams().get(IO_THREAD_ID), ioThreadId)) {
                return true;
            }
            if (Objects.equals(d.getSpecParams().get(INDEX), index) && Objects.equals(d.getSpecParams().get(MODEL), model)) {
                return true;
            }
            return false;
        }).findFirst().orElse(null));
        if (dbDev != null) {
            dbDevices.remove(dbDev);
            dev.put(VdsProperties.DeviceId, dbDev.getDeviceId().toString());
            dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        } else {
            dev.put(VdsProperties.DeviceId, Guid.newGuid().toString());
            Map<String, Object> specParams = new HashMap<>();
            if (index != null) {
                specParams.put(INDEX, index);
            }
            if (model != null) {
                specParams.put(MODEL, model);
            }
            if (ioThreadId != null) {
                specParams.put(IO_THREAD_ID, ioThreadId);
            }
            dev.put(VdsProperties.SpecParams, specParams);
        }
        result.add(dev);
    }
    return result;
}
#end_block

#method_before
private List<Map<String, Object>> parseMemories(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.MEMORY);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.MEMORY)) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.MEMORY.getValue());
        dev.put(VdsProperties.Device, VmDeviceGeneralType.MEMORY.getValue());
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        XmlNode target = node.selectSingleNode("target");
        if (target == null) {
            continue;
        }
        String devNode = target.selectSingleNode(NODE).innerText;
        String devSize = kiloBytesToMegaBytes(target.selectSingleNode(SIZE).innerText);
        VmDevice dbDev = dbDevices.stream().sorted(// try to match managed devices first
        Comparator.comparing(VmDevice::isManaged).reversed()).filter(d -> d.getDevice().equals(dev.get(VdsProperties.Device))).filter(d -> Objects.equals(d.getSpecParams().get(SPEC_PARAM_NODE).toString(), devNode)).filter(d -> Objects.equals(d.getSpecParams().get(SPEC_PARAM_SIZE).toString(), devSize)).findFirst().orElse(null);
        if (dbDev != null) {
            dbDevices.remove(dbDev);
            dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
            dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        } else {
            dev.put(VdsProperties.DeviceId, Guid.newGuid().toString());
            Map<String, Object> specParams = new HashMap<>();
            specParams.put(SPEC_PARAM_NODE, devNode);
            specParams.put(SPEC_PARAM_SIZE, devSize);
            dev.put(VdsProperties.SpecParams, specParams);
        }
        result.add(dev);
    }
    return result;
}
#method_after
private List<Map<String, Object>> parseMemories(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.MEMORY);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.MEMORY)) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.MEMORY.getValue());
        dev.put(VdsProperties.Device, VmDeviceGeneralType.MEMORY.getValue());
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        XmlNode target = node.selectSingleNode("target");
        if (target == null) {
            continue;
        }
        String devNode = target.selectSingleNode(NODE).innerText;
        String devSize = kiloBytesToMegaBytes(target.selectSingleNode(SIZE).innerText);
        VmDevice dbDev = correlate(dev, dbDevices, device -> dbDevices.stream().sorted(// try to match managed devices first
        Comparator.comparing(VmDevice::isManaged).reversed()).filter(d -> d.getDevice().equals(device.get(VdsProperties.Device))).filter(d -> Objects.equals(d.getSpecParams().get(SPEC_PARAM_NODE).toString(), devNode)).filter(d -> Objects.equals(d.getSpecParams().get(SPEC_PARAM_SIZE).toString(), devSize)).findFirst().orElse(null));
        if (dbDev != null) {
            dbDevices.remove(dbDev);
            dev.put(VdsProperties.DeviceId, dbDev.getDeviceId().toString());
            dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        } else {
            dev.put(VdsProperties.DeviceId, Guid.newGuid().toString());
            Map<String, Object> specParams = new HashMap<>();
            specParams.put(SPEC_PARAM_NODE, devNode);
            specParams.put(SPEC_PARAM_SIZE, devSize);
            dev.put(VdsProperties.SpecParams, specParams);
        }
        result.add(dev);
    }
    return result;
}
#end_block

#method_before
private List<Map<String, Object>> parseUnmanagedHostDevices(XmlDocument document, List<VmDevice> devices, Guid hostId, MemoizingSupplier<Map<Map<String, String>, HostDevice>> addressToHostDeviceSupplier) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.HOSTDEV);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : document.selectNodes("//*/hostdev")) {
        Map<String, String> hostAddress = parseHostAddress(node);
        if (hostAddress == null) {
            continue;
        }
        if (addressToHostDeviceSupplier.get().containsKey(hostAddress)) {
            // managed
            continue;
        }
        String device = parseAttribute(node, TYPE);
        VmDevice dbDev = dbDevices.stream().filter(d -> d.getDevice().equals(device) && Objects.equals(d.getSpecParams(), hostAddress)).findFirst().orElse(null);
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.HOSTDEV.getValue());
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        dev.put(VdsProperties.Device, device);
        dev.put(VdsProperties.SpecParams, hostAddress);
        dev.put(VdsProperties.DeviceId, dbDev != null ? dbDev.getId().getDeviceId().toString() : Guid.newGuid().toString());
        result.add(dev);
    }
    return result;
}
#method_after
private List<Map<String, Object>> parseUnmanagedHostDevices(XmlDocument document, List<VmDevice> devices, Guid hostId, MemoizingSupplier<Map<Map<String, String>, HostDevice>> addressToHostDeviceSupplier) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.HOSTDEV);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : document.selectNodes("//*/hostdev")) {
        Map<String, String> hostAddress = parseHostAddress(node);
        if (hostAddress == null) {
            continue;
        }
        if (addressToHostDeviceSupplier.get().containsKey(hostAddress)) {
            // managed
            continue;
        }
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.HOSTDEV.getValue());
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        String deviceType = parseAttribute(node, TYPE);
        dev.put(VdsProperties.Device, deviceType);
        dev.put(VdsProperties.SpecParams, hostAddress);
        VmDevice dbDev = correlate(dev, dbDevices, device -> dbDevices.stream().filter(d -> d.getDevice().equals(deviceType) && Objects.equals(d.getSpecParams(), hostAddress)).findFirst().orElse(null));
        dev.put(VdsProperties.DeviceId, dbDev != null ? dbDev.getDeviceId().toString() : Guid.newGuid().toString());
        result.add(dev);
    }
    return result;
}
#end_block

#method_before
private List<Map<String, Object>> parseManagedHostDevices(XmlDocument document, List<VmDevice> devices, Guid hostId, MemoizingSupplier<Map<Map<String, String>, HostDevice>> addressToHostDeviceSupplier) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.HOSTDEV);
    if (dbDevices.isEmpty()) {
        return Collections.emptyList();
    }
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : document.selectNodes("//*/hostdev")) {
        Map<String, String> hostAddress = parseHostAddress(node);
        if (hostAddress == null) {
            continue;
        }
        HostDevice hostDevice = addressToHostDeviceSupplier.get().get(hostAddress);
        if (hostDevice == null) {
            // unmanaged
            continue;
        }
        VmDevice dbDev = dbDevices.stream().filter(d -> d.getDevice().equals(hostDevice.getDeviceName())).findFirst().orElse(null);
        if (dbDev == null) {
            log.warn("VM host device '{}' does not exist in the database, thus ignored", hostDevice.getDeviceName());
            continue;
        }
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.HOSTDEV.getValue());
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        dev.put(VdsProperties.Device, hostDevice.getDeviceName());
        dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
        dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        result.add(dev);
    }
    return result;
}
#method_after
private List<Map<String, Object>> parseManagedHostDevices(XmlDocument document, List<VmDevice> devices, Guid hostId, MemoizingSupplier<Map<Map<String, String>, HostDevice>> addressToHostDeviceSupplier) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.HOSTDEV);
    if (dbDevices.isEmpty()) {
        return Collections.emptyList();
    }
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : document.selectNodes("//*/hostdev")) {
        Map<String, String> hostAddress = parseHostAddress(node);
        if (hostAddress == null) {
            continue;
        }
        HostDevice hostDevice = addressToHostDeviceSupplier.get().get(hostAddress);
        if (hostDevice == null) {
            // unmanaged
            continue;
        }
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Type, VmDeviceGeneralType.HOSTDEV.getValue());
        dev.put(VdsProperties.Alias, parseAlias(node));
        dev.put(VdsProperties.Device, hostDevice.getDeviceName());
        VmDevice dbDev = correlate(dev, dbDevices, device -> dbDevices.stream().filter(d -> d.getDevice().equals(hostDevice.getDeviceName())).findFirst().orElse(null));
        if (dbDev == null) {
            log.warn("VM host device '{}' does not exist in the database, thus ignored", hostDevice.getDeviceName());
            continue;
        }
        dev.put(VdsProperties.DeviceId, dbDev.getDeviceId().toString());
        dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        result.add(dev);
    }
    return result;
}
#end_block

#method_before
private List<Map<String, Object>> parseRedirs(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.REDIR);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : document.selectNodes("//*/redirdev")) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.REDIR.getValue());
        dev.put(VdsProperties.Device, parseAttribute(node, TYPE));
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        VmDevice dbDev = dbDevices.stream().filter(d -> d.getDevice().equals(dev.get(VdsProperties.Device))).findFirst().orElse(null);
        if (dbDev != null) {
            dbDevices.remove(dbDev);
            dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
            dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        } else {
            dev.put(VdsProperties.DeviceId, Guid.newGuid().toString());
        }
        result.add(dev);
    }
    return result;
}
#method_after
private List<Map<String, Object>> parseRedirs(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.REDIR);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : document.selectNodes("//*/redirdev")) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.REDIR.getValue());
        dev.put(VdsProperties.Device, parseAttribute(node, TYPE));
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        VmDevice dbDev = correlate(dev, dbDevices, device -> dbDevices.stream().filter(d -> d.getDevice().equals(device.get(VdsProperties.Device))).findFirst().orElse(null));
        if (dbDev != null) {
            dbDevices.remove(dbDev);
            dev.put(VdsProperties.DeviceId, dbDev.getDeviceId().toString());
            dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        } else {
            dev.put(VdsProperties.DeviceId, Guid.newGuid().toString());
        }
        result.add(dev);
    }
    return result;
}
#end_block

#method_before
private List<Map<String, Object>> parseDisks(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.DISK);
    MemoizingSupplier<Map<Guid, String>> diskToLunSupplier = new MemoizingSupplier<>(() -> diskLunMapDao.getAll().stream().collect(Collectors.toMap(DiskLunMap::getDiskId, DiskLunMap::getLunId)));
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.DISK)) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.DISK.getValue());
        String diskType = parseAttribute(node, DEVICE);
        dev.put(VdsProperties.Device, diskType);
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        String path = parseDiskPath(node);
        VmDevice dbDev = findDiskDeviceInDbByPath(dbDevices, diskType, path, diskToLunSupplier);
        if (dbDev == null) {
            log.warn("unmanaged disk with path '{}' is ignored", path);
            continue;
        }
        dbDevices.remove(dbDev);
        dev.put(VdsProperties.ImageId, parseImageIdFromPath(path));
        dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
        dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        List<Map<String, Object>> volumeChain = parseVolumeChain(node);
        if (!volumeChain.isEmpty()) {
            dev.put(VdsProperties.VolumeChain, volumeChain.toArray());
        }
        result.add(dev);
    }
    return result;
}
#method_after
private List<Map<String, Object>> parseDisks(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.DISK);
    MemoizingSupplier<Map<Guid, String>> diskToLunSupplier = new MemoizingSupplier<>(() -> diskLunMapDao.getAll().stream().collect(Collectors.toMap(DiskLunMap::getDiskId, DiskLunMap::getLunId)));
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.DISK)) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.DISK.getValue());
        String diskType = parseAttribute(node, DEVICE);
        dev.put(VdsProperties.Device, diskType);
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        String path = parseDiskPath(node);
        VmDevice dbDev = correlate(dev, dbDevices, device -> findDiskDeviceInDbByPath(dbDevices, diskType, path, diskToLunSupplier));
        if (dbDev == null) {
            log.warn("unmanaged disk with path '{}' is ignored", path);
            continue;
        }
        dbDevices.remove(dbDev);
        dev.put(VdsProperties.ImageId, parseImageIdFromPath(path));
        dev.put(VdsProperties.DeviceId, dbDev.getDeviceId().toString());
        dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        List<Map<String, Object>> volumeChain = parseVolumeChain(node);
        if (!volumeChain.isEmpty()) {
            dev.put(VdsProperties.VolumeChain, volumeChain.toArray());
        }
        result.add(dev);
    }
    return result;
}
#end_block

#method_before
private VmDevice findDiskDeviceInDbByPath(List<VmDevice> dbDevices, String diskType, String path, MemoizingSupplier<Map<Guid, String>> diskToLunSupplier) {
    return dbDevices.stream().filter(d -> {
        switch(diskType) {
            case "cdrom":
                if (!diskType.equals(d.getDevice())) {
                    return false;
                }
                String devicePath = (String) d.getSpecParams().get("path");
                return devicePath == null || path.contains(devicePath);
            case "floppy":
                return diskType.equals(d.getDevice());
            default:
                if (d.getSnapshotId() != null && path.contains(VdsProperties.Transient)) {
                    DiskImage diskImage = diskImageDao.getDiskSnapshotForVmSnapshot(d.getDeviceId(), d.getSnapshotId());
                    return diskImage != null && path.contains(diskImage.getImageId().toString());
                }
                Guid diskId = d.getId().getDeviceId();
                return path.contains(diskId.toString()) || isPathContainsLunIdOfDisk(path, diskId, diskToLunSupplier);
        }
    }).findFirst().orElse(null);
}
#method_after
private VmDevice findDiskDeviceInDbByPath(List<VmDevice> dbDevices, String diskType, String path, MemoizingSupplier<Map<Guid, String>> diskToLunSupplier) {
    return dbDevices.stream().filter(d -> {
        switch(diskType) {
            case "cdrom":
                if (!diskType.equals(d.getDevice())) {
                    return false;
                }
                String devicePath = (String) d.getSpecParams().get("path");
                return devicePath == null || path.contains(devicePath);
            case "floppy":
                return diskType.equals(d.getDevice());
            default:
                if (d.getSnapshotId() != null && path.contains(VdsProperties.Transient)) {
                    DiskImage diskImage = diskImageDao.getDiskSnapshotForVmSnapshot(d.getDeviceId(), d.getSnapshotId());
                    return diskImage != null && path.contains(diskImage.getImageId().toString());
                }
                Guid diskId = d.getDeviceId();
                return path.contains(diskId.toString()) || isPathContainsLunIdOfDisk(path, diskId, diskToLunSupplier);
        }
    }).findFirst().orElse(null);
}
#end_block

#method_before
private List<Map<String, Object>> parseInterfaces(XmlDocument document, List<VmDevice> devices, Guid vmId, MemoizingSupplier<Map<Map<String, String>, HostDevice>> addressToHostDeviceSupplier) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.INTERFACE);
    Map<Guid, VmDevice> devIdToDbDev = dbDevices.stream().collect(Collectors.toMap(device -> device.getId().getDeviceId(), device -> device));
    List<VmNetworkInterface> dbInterfaces = vmNetworkInterfaceDao.getAllForVm(vmId);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.INTERFACE)) {
        String type = parseAttribute(node, TYPE);
        Map<String, Object> dev = new HashMap<>();
        if (VmDeviceType.HOST_DEVICE.getName().equals(type)) {
            dev.put(VdsProperties.HostDev, getHostDeviceName(node, addressToHostDeviceSupplier));
        }
        dev.put(VdsProperties.Type, VmDeviceGeneralType.INTERFACE.getValue());
        dev.put(VdsProperties.Device, type);
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        String macAddress = parseMacAddress(node);
        // MAC address is a unique identifier of network interface devices
        VmNetworkInterface dbInterface = dbInterfaces.stream().filter(iface -> iface.getMacAddress().equalsIgnoreCase(macAddress)).findFirst().orElse(null);
        if (dbInterface == null) {
            log.warn("unmanaged network interface with mac address '{}' is ignored", macAddress);
            continue;
        }
        Guid deviceId = dbInterface.getId();
        dev.put(VdsProperties.DeviceId, deviceId.toString());
        dev.put(VdsProperties.SpecParams, devIdToDbDev.get(deviceId).getSpecParams());
        result.add(dev);
    }
    return result;
}
#method_after
private List<Map<String, Object>> parseInterfaces(XmlDocument document, List<VmDevice> devices, Guid vmId, MemoizingSupplier<Map<Map<String, String>, HostDevice>> addressToHostDeviceSupplier) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.INTERFACE);
    Map<Guid, VmDevice> devIdToDbDev = dbDevices.stream().collect(Collectors.toMap(device -> device.getDeviceId(), device -> device));
    List<VmNetworkInterface> dbInterfaces = vmNetworkInterfaceDao.getAllForVm(vmId);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.INTERFACE)) {
        String type = parseAttribute(node, TYPE);
        Map<String, Object> dev = new HashMap<>();
        if (VmDeviceType.HOST_DEVICE.getName().equals(type)) {
            dev.put(VdsProperties.HostDev, getHostDeviceName(node, addressToHostDeviceSupplier));
        }
        dev.put(VdsProperties.Type, VmDeviceGeneralType.INTERFACE.getValue());
        dev.put(VdsProperties.Device, type);
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        String macAddress = parseMacAddress(node);
        // MAC address is a unique identifier of network interface devices
        VmDevice dbDev = correlate(dev, dbDevices, device -> {
            VmNetworkInterface dbInterface = dbInterfaces.stream().filter(iface -> iface.getMacAddress().equalsIgnoreCase(macAddress)).findFirst().orElse(null);
            return dbInterface != null ? devIdToDbDev.get(dbInterface.getId()) : null;
        });
        if (dbDev == null) {
            log.warn("unmanaged network interface with mac address '{}' is ignored", macAddress);
            continue;
        }
        dev.put(VdsProperties.DeviceId, dbDev.getDeviceId().toString());
        dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        result.add(dev);
    }
    return result;
}
#end_block

#method_before
private List<Map<String, Object>> parseVideos(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.VIDEO);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.VIDEO)) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.VIDEO.getValue());
        dev.put(VdsProperties.Device, parseVideoType(node));
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        // There is supposed to be one video device of each type (spice/vnc/..)
        VmDevice dbDev = dbDevices.stream().filter(d -> d.getDevice().equals(dev.get(VdsProperties.Device))).findFirst().orElse(null);
        if (dbDev == null) {
            log.warn("unmanaged video device with address '{}' is ignored", dev.get(VdsProperties.Address));
            continue;
        }
        dbDevices.remove(dbDev);
        dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
        dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        result.add(dev);
    }
    return result;
}
#method_after
private List<Map<String, Object>> parseVideos(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.VIDEO);
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.VIDEO)) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.VIDEO.getValue());
        dev.put(VdsProperties.Device, parseVideoType(node));
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        // There is supposed to be one video device of each type (spice/vnc/..)
        VmDevice dbDev = correlate(dev, dbDevices, device -> dbDevices.stream().filter(d -> d.getDevice().equals(device.get(VdsProperties.Device))).findFirst().orElse(null));
        if (dbDev == null) {
            log.warn("unmanaged video device with address '{}' is ignored", dev.get(VdsProperties.Address));
            continue;
        }
        dbDevices.remove(dbDev);
        dev.put(VdsProperties.DeviceId, dbDev.getDeviceId().toString());
        dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        result.add(dev);
    }
    return result;
}
#end_block

#method_before
private Map<String, Object> parseDev(VmDeviceGeneralType devType, XmlDocument document, List<VmDevice> devices) {
    VmDevice dbDevice = filterDevice(devices, devType);
    if (dbDevice == null) {
        return Collections.emptyMap();
    }
    XmlNode node = selectSingleNode(document, devType);
    if (node == null) {
        return Collections.emptyMap();
    }
    Map<String, Object> result = new HashMap<>();
    result.put(VdsProperties.Device, devType);
    result.put(VdsProperties.DeviceId, dbDevice.getId().getDeviceId().toString());
    result.put(VdsProperties.Address, parseAddress(node));
    result.put(VdsProperties.Alias, parseAlias(node));
    result.put(VdsProperties.SpecParams, dbDevice.getSpecParams());
    return result;
}
#method_after
private Map<String, Object> parseDev(VmDeviceGeneralType devType, XmlDocument document, List<VmDevice> devices) {
    VmDevice dbDevice = filterDevice(devices, devType);
    if (dbDevice == null) {
        return Collections.emptyMap();
    }
    XmlNode node = selectSingleNode(document, devType);
    if (node == null) {
        return Collections.emptyMap();
    }
    Map<String, Object> result = new HashMap<>();
    result.put(VdsProperties.Device, devType);
    result.put(VdsProperties.DeviceId, dbDevice.getDeviceId().toString());
    result.put(VdsProperties.Address, parseAddress(node));
    result.put(VdsProperties.Alias, parseAlias(node));
    result.put(VdsProperties.SpecParams, dbDevice.getSpecParams());
    return result;
}
#end_block

#method_before
private Map<String, Object> parseBalloon(XmlDocument document, List<VmDevice> devices) {
    VmDevice dbDevice = filterDevice(devices, VmDeviceGeneralType.BALLOON);
    if (dbDevice == null) {
        return Collections.emptyMap();
    }
    XmlNode node = document.selectSingleNode("//*/memballoon");
    if (node == null) {
        return Collections.emptyMap();
    }
    Map<String, Object> result = new HashMap<>();
    result.put(VdsProperties.Device, "memballoon");
    result.put(VdsProperties.DeviceId, dbDevice.getId().getDeviceId().toString());
    result.put(VdsProperties.Address, parseAddress(node));
    result.put(VdsProperties.Alias, parseAlias(node));
    result.put(VdsProperties.SpecParams, dbDevice.getSpecParams());
    return result;
}
#method_after
private Map<String, Object> parseBalloon(XmlDocument document, List<VmDevice> devices) {
    VmDevice dbDevice = filterDevice(devices, VmDeviceGeneralType.BALLOON);
    if (dbDevice == null) {
        return Collections.emptyMap();
    }
    XmlNode node = document.selectSingleNode("//*/memballoon");
    if (node == null) {
        return Collections.emptyMap();
    }
    Map<String, Object> result = new HashMap<>();
    result.put(VdsProperties.Device, "memballoon");
    result.put(VdsProperties.DeviceId, dbDevice.getDeviceId().toString());
    result.put(VdsProperties.Address, parseAddress(node));
    result.put(VdsProperties.Alias, parseAlias(node));
    result.put(VdsProperties.SpecParams, dbDevice.getSpecParams());
    return result;
}
#end_block

#method_before
private Integer parseIoThreadId(XmlNode node) {
    XmlNode addressNode = node.selectSingleNode("driver");
    if (addressNode == null) {
        return null;
    }
    XmlAttribute val = addressNode.attributes.get("iothread");
    return val != null ? Integer.valueOf(val.getValue()) : null;
}
#method_after
private Integer parseIoThreadId(XmlNode node) {
    XmlNode driverNode = node.selectSingleNode("driver");
    if (driverNode == null) {
        return null;
    }
    XmlAttribute val = driverNode.attributes.get("iothread");
    return val != null ? Integer.valueOf(val.getValue()) : null;
}
#end_block

#method_before
protected Map<Integer, Map<VmDevice, Integer>> getVmDeviceUnitMapForScsiDisks(VM vm, DiskInterface scsiInterface, boolean reserveFirstTwoLuns) {
    List<Disk> disks = getSortedDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceUnitMap = new HashMap<>();
    LinkedList<VmDevice> vmDeviceList = new LinkedList<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        if (dve.getDiskInterface() == scsiInterface) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = StringMapUtils.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            String controllerStr = address.get(VdsProperties.Controller);
            // Otherwise, adding to 'vmDeviceList' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr) && StringUtils.isNotEmpty(controllerStr)) {
                Integer controllerInt = Integer.valueOf(controllerStr);
                boolean controllerOutOfRange = controllerInt >= vm.getNumOfIoThreads() + getDefaultVirtioScsiIndex(vm);
                boolean ioThreadsEnabled = vm.getNumOfIoThreads() > 0 && FeatureSupported.virtioScsiIoThread(vm.getCompatibilityVersion());
                if ((ioThreadsEnabled && !controllerOutOfRange) || (controllerInt == getDefaultVirtioScsiIndex(vm))) {
                    if (!vmDeviceUnitMap.containsKey(controllerInt)) {
                        vmDeviceUnitMap.put(controllerInt, new HashMap<>());
                    }
                    vmDeviceUnitMap.get(controllerInt).put(vmDevice, Integer.valueOf(unitStr));
                } else {
                    // controller id not correct, generate the address again later
                    vmDevice.setAddress(null);
                    vmDeviceList.add(vmDevice);
                }
            } else {
                vmDeviceList.add(vmDevice);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address\
    IntStream.range(0, vmDeviceList.size()).forEach(index -> {
        VmDevice vmDevice = vmDeviceList.get(index);
        // Todo: consider changing this so that it will seaching for the next available less
        // used controller instead of always starting from index.
        int controller = getControllerForScsiDisk(vmDevice, vm, index);
        if (!vmDeviceUnitMap.containsKey(controller)) {
            vmDeviceUnitMap.put(controller, new HashMap<>());
        }
        int unit = getAvailableUnitForScsiDisk(vmDeviceUnitMap.get(controller), reserveFirstTwoLuns);
        vmDeviceUnitMap.get(controller).put(vmDevice, unit);
    });
    return vmDeviceUnitMap;
}
#method_after
protected Map<Integer, Map<VmDevice, Integer>> getVmDeviceUnitMapForScsiDisks(VM vm, DiskInterface scsiInterface, boolean reserveFirstTwoLuns) {
    List<Disk> disks = getSortedDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceUnitMap = new HashMap<>();
    LinkedList<VmDevice> vmDeviceList = new LinkedList<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        if (dve.getDiskInterface() == scsiInterface) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = StringMapUtils.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            String controllerStr = address.get(VdsProperties.Controller);
            // Otherwise, adding to 'vmDeviceList' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr) && StringUtils.isNotEmpty(controllerStr)) {
                Integer controllerInt = Integer.valueOf(controllerStr);
                boolean controllerOutOfRange = controllerInt >= vm.getNumOfIoThreads() + getDefaultVirtioScsiIndex(vm);
                boolean ioThreadsEnabled = vm.getNumOfIoThreads() > 0 && FeatureSupported.virtioScsiIoThread(vm.getCompatibilityVersion());
                if ((ioThreadsEnabled && !controllerOutOfRange) || (controllerInt == getDefaultVirtioScsiIndex(vm))) {
                    if (!vmDeviceUnitMap.containsKey(controllerInt)) {
                        vmDeviceUnitMap.put(controllerInt, new HashMap<>());
                    }
                    vmDeviceUnitMap.get(controllerInt).put(vmDevice, Integer.valueOf(unitStr));
                } else {
                    // controller id not correct, generate the address again later
                    vmDevice.setAddress(null);
                    vmDeviceList.add(vmDevice);
                }
            } else {
                vmDeviceList.add(vmDevice);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address\
    IntStream.range(0, vmDeviceList.size()).forEach(index -> {
        VmDevice vmDevice = vmDeviceList.get(index);
        // TODO: consider changing this so that it will search for the next available and
        // less used controller instead of always starting from index.
        int controller = getControllerForScsiDisk(vmDevice, vm, index);
        if (!vmDeviceUnitMap.containsKey(controller)) {
            vmDeviceUnitMap.put(controller, new HashMap<>());
        }
        int unit = getAvailableUnitForScsiDisk(vmDeviceUnitMap.get(controller), reserveFirstTwoLuns);
        vmDeviceUnitMap.get(controller).put(vmDevice, unit);
    });
    return vmDeviceUnitMap;
}
#end_block

#method_before
public List<Disk> getSortedDisks(VM vm) {
    // Order the drives as following:
    // - Boot devices of non-snapshot disks
    // - Boot devices of snapshot disks (i.e., boot disks of other VMs plugged to this one
    // - Then by the disk alias
    List<Disk> disks = new ArrayList<>(vm.getDiskMap().values());
    disks.sort(Comparator.comparing((Disk d) -> !d.getDiskVmElementForVm(vm.getId()).isBoot()).thenComparing(d -> d.getDiskVmElementForVm(vm.getId()).isBoot() && d.isDiskSnapshot()).thenComparing(new LexoNumericNameableComparator<>()));
    return disks;
}
#method_after
public List<Disk> getSortedDisks(Map<Disk, VmDevice> disksToDevices, Guid vmId) {
    // Order the drives as following:
    // - Boot devices of non-snapshot disks
    // - Device address of the disk
    // - Boot devices of snapshot disks (i.e., boot disks of other VMs plugged to this one
    // - Then by the disk alias
    List<Disk> disks = new ArrayList<>(disksToDevices.keySet());
    disks.sort(Comparator.comparing((Disk d) -> !d.getDiskVmElementForVm(vmId).isBoot()).thenComparing(d -> StringUtils.isEmpty(disksToDevices.get(d).getAddress())).thenComparing(d -> d.getDiskVmElementForVm(vmId).isBoot() && d.isDiskSnapshot()).thenComparing(new LexoNumericNameableComparator<>()));
    return disks;
}
#end_block

#method_before
private void writeDiskMetadata() {
    diskMetadata.forEach((dev, data) -> {
        writer.writeStartElement(OVIRT_VM_URI, "device");
        writer.writeAttributeString("devtype", "disk");
        writer.writeAttributeString("name", dev);
        data.forEach((key, value) -> writer.writeElement(OVIRT_VM_URI, key, value.toString()));
        writer.writeEndElement();
    });
}
#method_after
private void writeDiskMetadata() {
    diskMetadata.forEach((dev, data) -> {
        writer.writeStartElement(OVIRT_VM_URI, "device");
        writer.writeAttributeString("devtype", "disk");
        writer.writeAttributeString("name", dev);
        data.forEach((key, value) -> writer.writeElement(OVIRT_VM_URI, key, value));
        writer.writeEndElement();
    });
}
#end_block

#method_before
private void writePayloadMetadata() {
    if (payloadMetadata != null) {
        writer.writeStartElement(OVIRT_VM_URI, "device");
        writer.writeAttributeString("devtype", "disk");
        writer.writeAttributeString("name", payloadMetadata.getFirst());
        writer.writeStartElement(OVIRT_VM_URI, "payload");
        if (payloadMetadata.getSecond().getVolumeId() != null) {
            writer.writeElement(OVIRT_VM_URI, "volId", payloadMetadata.getSecond().getVolumeId());
        }
        payloadMetadata.getSecond().getFiles().forEach((path, data) -> {
            writer.writeStartElement(OVIRT_VM_URI, "file");
            writer.writeAttributeString("path", path);
            writer.writeRaw(data);
            writer.writeEndElement();
        });
        writer.writeEndElement();
        writer.writeEndElement();
    }
}
#method_after
private void writePayloadMetadata() {
    if (payloadMetadata == null) {
        return;
    }
    writer.writeStartElement(OVIRT_VM_URI, "device");
    writer.writeAttributeString("devtype", "disk");
    writer.writeAttributeString("name", payloadMetadata.getFirst());
    writer.writeStartElement(OVIRT_VM_URI, "payload");
    String volumeId = payloadMetadata.getSecond().getVolumeId();
    if (volumeId != null) {
        writer.writeElement(OVIRT_VM_URI, "volId", volumeId);
    }
    Map<String, String> files = payloadMetadata.getSecond().getFiles();
    if (files != null) {
        files.forEach((path, data) -> {
            writer.writeStartElement(OVIRT_VM_URI, "file");
            writer.writeAttributeString("path", path);
            writer.writeRaw(data);
            writer.writeEndElement();
        });
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writeLeases();
    writer.writeEndElement();
}
#end_block

#method_before
private List<VmDevice> overrideDevicesForRunOnce(List<VmDevice> devices) {
    if (!vm.isRunOnce()) {
        return devices;
    }
    // video device handling
    DisplayType displayType = vm.getDefaultDisplayType();
    if (displayType != null) {
        // remove existing video device
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.VIDEO).collect(Collectors.toList());
        // add new video device
        if (displayType != DisplayType.none) {
            devices.add(vmInfoBuildUtils.createVideoDeviceByDisplayType(displayType, vm.getId()));
        }
    }
    // graphics device handling
    if (displayType == DisplayType.none || (vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty())) {
        // remove existing graphics devices
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.GRAPHICS).collect(Collectors.toList());
        if (displayType != DisplayType.none) {
            // add new graphics devices
            Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
            Map<String, Object> specParamsFromVm = new HashMap<>();
            vmInfoBuildUtils.addVmGraphicsOptions(infos, specParamsFromVm, vm);
            devices.addAll(vmInfoBuildUtils.createGraphicsDevices(infos, specParamsFromVm, vm.getId()));
        }
    }
    // the user may specify floppy path while there is no device in the database
    if (!StringUtils.isEmpty(vm.getFloppyPath()) && !devices.stream().anyMatch(dev -> !dev.getDevice().equals(VmDeviceType.FLOPPY.getName()))) {
        devices.add(vmInfoBuildUtils.createFloppyDevice(vm));
    }
    return devices;
}
#method_after
private List<VmDevice> overrideDevicesForRunOnce(List<VmDevice> devices) {
    if (!vm.isRunOnce()) {
        return devices;
    }
    // video device handling
    DisplayType displayType = vm.getDefaultDisplayType();
    if (displayType != null) {
        // remove existing video device
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.VIDEO).collect(Collectors.toList());
        // add new video device
        if (displayType != DisplayType.none) {
            devices.add(vmInfoBuildUtils.createVideoDeviceByDisplayType(displayType, vm.getId()));
        }
    }
    // graphics device handling
    if (displayType == DisplayType.none || (vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty())) {
        // remove existing graphics devices
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.GRAPHICS).collect(Collectors.toList());
        if (displayType != DisplayType.none) {
            // add new graphics devices
            Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
            Map<String, Object> specParamsFromVm = new HashMap<>();
            vmInfoBuildUtils.addVmGraphicsOptions(infos, specParamsFromVm, vm);
            devices.addAll(vmInfoBuildUtils.createGraphicsDevices(infos, specParamsFromVm, vm.getId()));
        }
    }
    // the user may specify floppy path while there is no device in the database
    if (!StringUtils.isEmpty(vm.getFloppyPath()) && !devices.stream().anyMatch(dev -> dev.getDevice().equals(VmDeviceType.FLOPPY.getName()))) {
        devices.add(vmInfoBuildUtils.createFloppyDevice(vm));
    }
    return devices;
}
#end_block

#method_before
private void writeLease() {
    if (vm.getLeaseStorageDomainId() == null) {
        return;
    }
    writer.writeStartElement("lease");
    writer.writeElement("key", vm.getId().toString());
    writer.writeElement("lockspace", vm.getLeaseStorageDomainId().toString());
    writer.writeStartElement("target");
    Map<String, String> leaseInfo = vm.getLeaseInfo();
    writer.writeAttributeString("offset", leaseInfo.get(VdsProperties.VmLeaseOffset));
    writer.writeAttributeString("path", leaseInfo.get(VdsProperties.VmLeasePath));
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeLease(String key, String lockspace, String path, String offset) {
    writer.writeStartElement("lease");
    writer.writeElement("key", key);
    writer.writeElement("lockspace", lockspace);
    writer.writeStartElement("target");
    writer.writeAttributeString("offset", offset);
    writer.writeAttributeString("path", path);
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDisks(List<VmDevice> devices) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    int ideIndex = -1;
    int scsiIndex = -1;
    int virtioIndex = -1;
    DiskInterface cdDiskInterface = DiskInterface.forValue(cdInterface);
    int pinnedDriveIndex = 0;
    for (Disk disk : vmInfoBuildUtils.getSortedDisks(vm)) {
        VmDevice device = deviceIdToDevice.get(new VmDeviceId(disk.getId(), vm.getId()));
        if (device == null || !device.isManaged()) {
            // This may happen to memory disks that do not have a corresponding device
            continue;
        }
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        DiskInterface diskInterface = dve.getDiskInterface();
        int index = 0;
        int pinTo = 0;
        switch(diskInterface) {
            case IDE:
                ideIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (ideIndex == payloadIndex || ideIndex == cdRomIndex) {
                        ideIndex++;
                    }
                }
                index = ideIndex;
                break;
            case VirtIO:
                pinTo = vmInfoBuildUtils.pinToIoThreads(vm, device, pinnedDriveIndex++);
                virtioIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (virtioIndex == payloadIndex || virtioIndex == cdRomIndex) {
                        virtioIndex++;
                    }
                }
                index = virtioIndex;
                break;
            case SPAPR_VSCSI:
            case VirtIO_SCSI:
                scsiIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (scsiIndex == payloadIndex || scsiIndex == cdRomIndex) {
                        scsiIndex++;
                    }
                }
                index = scsiIndex;
                calculateAddressForScsiDisk(disk, device, vmDeviceSpaprVscsiUnitMap, vmDeviceVirtioScsiUnitMap);
                break;
        }
        String dev = vmInfoBuildUtils.makeDiskName(dve.getDiskInterface().getName(), index);
        writeDisk(device, disk, dve, dev, pinTo);
    }
}
#method_after
private void writeDisks(List<VmDevice> devices) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    int ideIndex = -1;
    int scsiIndex = -1;
    int virtioIndex = -1;
    DiskInterface cdDiskInterface = DiskInterface.forValue(cdInterface);
    int pinnedDriveIndex = 0;
    Map<Disk, VmDevice> vmDisksToDevices = vm.getDiskMap().values().stream().collect(Collectors.toMap(Function.identity(), d -> deviceIdToDevice.get(new VmDeviceId(d.getId(), vm.getId()))));
    for (Disk disk : vmInfoBuildUtils.getSortedDisks(vmDisksToDevices, vm.getId())) {
        VmDevice device = deviceIdToDevice.get(new VmDeviceId(disk.getId(), vm.getId()));
        if (device == null || !device.isManaged()) {
            // This may happen to memory disks that do not have a corresponding device
            continue;
        }
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        DiskInterface diskInterface = dve.getDiskInterface();
        int index = 0;
        int pinTo = 0;
        switch(diskInterface) {
            case IDE:
                ideIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (ideIndex == payloadIndex || ideIndex == cdRomIndex) {
                        ideIndex++;
                    }
                }
                index = ideIndex;
                break;
            case VirtIO:
                pinTo = vmInfoBuildUtils.pinToIoThreads(vm, device, pinnedDriveIndex++);
                virtioIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (virtioIndex == payloadIndex || virtioIndex == cdRomIndex) {
                        virtioIndex++;
                    }
                }
                index = virtioIndex;
                break;
            case SPAPR_VSCSI:
            case VirtIO_SCSI:
                scsiIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (scsiIndex == payloadIndex || scsiIndex == cdRomIndex) {
                        scsiIndex++;
                    }
                }
                index = scsiIndex;
                vmInfoBuildUtils.calculateAddressForScsiDisk(vm, disk, device, vmDeviceSpaprVscsiUnitMap, vmDeviceVirtioScsiUnitMap);
                break;
        }
        String dev = vmInfoBuildUtils.makeDiskName(dve.getDiskInterface().getName(), index);
        writeDisk(device, disk, dve, dev, pinTo);
    }
}
#end_block

#method_before
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            // Change parameters for the HE disk
            if (vm.isHostedEngine()) {
                // Hosted engine disk images have to have empty storage pool ID,
                // so they can be mounted even if storage pool is not connected.
                diskImage.setStoragePoolId(Guid.Empty);
                diskImage.setPropagateErrors(PropagateErrors.Off);
                diskImage.setShareable(false);
            }
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    // drop to the 'file' case as a fallback.
                    if (volInfo != null) {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            // Change parameters for the HE disk
            if (vm.isHostedEngine()) {
                // Hosted engine disk images have to have empty storage pool ID,
                // so they can be mounted even if storage pool is not connected.
                diskImage.setStoragePoolId(Guid.Empty);
                diskImage.setPropagateErrors(PropagateErrors.Off);
                // The disk requires a lease
                addVolumeLease(diskImage.getImageId(), diskImage.getStorageIds().get(0));
            }
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    // drop to the 'file' case as a fallback.
                    if (volInfo != null) {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#end_block

#method_before
private Map<String, Object> createDiskParams(DiskImage diskImage) {
    Map<String, Object> diskParams = createDiskUuidsMap(diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId());
    if (!diskImage.getActive()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Transient);
    }
    return diskParams;
}
#method_after
private Map<String, String> createDiskParams(DiskImage diskImage) {
    Map<String, String> diskParams = createDiskUuidsMap(diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId());
    if (!diskImage.getActive()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Transient);
    } else if (diskImage.isShareable()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Shareable);
    } else if (vm.isHostedEngine()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Exclusive);
    }
    return diskParams;
}
#end_block

#method_before
private Map<String, Object> createDiskUuidsMap(Guid poolId, Guid domainId, Guid imageId, Guid volumeId) {
    Map<String, Object> diskUuids = new HashMap<>();
    diskUuids.put("poolID", poolId);
    diskUuids.put("domainID", domainId);
    diskUuids.put("imageID", imageId);
    diskUuids.put("volumeID", volumeId);
    return diskUuids;
}
#method_after
private Map<String, String> createDiskUuidsMap(Guid poolId, Guid domainId, Guid imageId, Guid volumeId) {
    return PDIVMapBuilder.create().setPoolId(poolId).setDomainId(domainId).setImageGroupId(imageId).setVolumeId(volumeId).build();
}
#end_block

#method_before
private void writeFloppy(VmDevice device) {
    if (device == null) {
        return;
    }
    // <disk device="floppy" snapshot="no" type="file">
    // <source file="/var/run/vdsm/payload/8b5fa6b8-9c57-4d7c-80cb-64537eea560f.6e38a5ccb3c6b2b674086e9d07126a03.img" startupPolicy="optional" />
    // <target bus="fdc" dev="fda" />
    // <readonly />
    // </disk>
    writer.writeStartElement("disk");
    writer.writeAttributeString("type", "file");
    writer.writeAttributeString("device", "floppy");
    writer.writeAttributeString("snapshot", "no");
    writer.writeStartElement("source");
    writer.writeAttributeString("file", VmPayload.isPayload(device.getSpecParams()) ? "PAYLOAD:" : vm.getFloppyPath());
    writer.writeAttributeString("startupPolicy", "optional");
    writer.writeEndElement();
    writer.writeStartElement("target");
    // IDE slot 2 is reserved by VDSM to CDROM
    String name = vmInfoBuildUtils.makeDiskName(VdsProperties.Fdc, 0);
    writer.writeAttributeString("dev", name);
    writer.writeAttributeString("bus", VdsProperties.Fdc);
    writer.writeEndElement();
    writer.writeElement("readonly");
    writeAlias(device);
    writeAddress(device);
    payloadMetadata = new Pair<>(name, new VmPayload(device));
    writer.writeEndElement();
}
#method_after
private void writeFloppy(VmDevice device) {
    if (device == null) {
        return;
    }
    // <disk device="floppy" snapshot="no" type="file">
    // <source file="/var/run/vdsm/payload/8b5fa6b8-9c57-4d7c-80cb-64537eea560f.6e38a5ccb3c6b2b674086e9d07126a03.img" startupPolicy="optional" />
    // <target bus="fdc" dev="fda" />
    // <readonly />
    // </disk>
    writer.writeStartElement("disk");
    writer.writeAttributeString("type", "file");
    writer.writeAttributeString("device", "floppy");
    writer.writeAttributeString("snapshot", "no");
    final boolean payload = VmPayload.isPayload(device.getSpecParams());
    writer.writeStartElement("source");
    writer.writeAttributeString("file", payload ? "PAYLOAD:" : vm.getFloppyPath());
    writer.writeAttributeString("startupPolicy", "optional");
    writer.writeEndElement();
    writer.writeStartElement("target");
    // IDE slot 2 is reserved by VDSM to CDROM
    String name = vmInfoBuildUtils.makeDiskName(VdsProperties.Fdc, 0);
    writer.writeAttributeString("dev", name);
    writer.writeAttributeString("bus", VdsProperties.Fdc);
    writer.writeEndElement();
    writer.writeElement("readonly");
    writeAlias(device);
    writeAddress(device);
    if (payload) {
        payloadMetadata = new Pair<>(name, new VmPayload(device));
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeAlias(VmDevice device) {
    writer.writeStartElement("alias");
    writer.writeAttributeString("name", String.format("ua-%s", device.getId().getDeviceId()));
    writer.writeEndElement();
}
#method_after
private void writeAlias(VmDevice device) {
    if (device.isManaged()) {
        writer.writeStartElement("alias");
        writer.writeAttributeString("name", String.format("ua-%s", device.getId().getDeviceId()));
        writer.writeEndElement();
    }
}
#end_block

#method_before
public static long greatestCommonDivisor(long a, long b) {
    while (b != 0) {
        a = b;
        b = a % b;
    }
    return a;
}
#method_after
public static long greatestCommonDivisor(long a, long b) {
    while (b != 0) {
        long c = b;
        b = a % b;
        a = c;
    }
    return a;
}
#end_block

#method_before
private void writeDiskMetadata() {
    diskMetadata.forEach((dev, data) -> {
        writer.writeStartElement(OVIRT_VM_URI, "device");
        writer.writeAttributeString("devtype", "disk");
        writer.writeAttributeString("name", dev);
        data.forEach((key, value) -> writer.writeElement(OVIRT_VM_URI, key, value.toString()));
        writer.writeEndElement();
    });
}
#method_after
private void writeDiskMetadata() {
    diskMetadata.forEach((dev, data) -> {
        writer.writeStartElement(OVIRT_VM_URI, "device");
        writer.writeAttributeString("devtype", "disk");
        writer.writeAttributeString("name", dev);
        data.forEach((key, value) -> writer.writeElement(OVIRT_VM_URI, key, value));
        writer.writeEndElement();
    });
}
#end_block

#method_before
private void writePayloadMetadata() {
    if (payloadMetadata != null) {
        writer.writeStartElement(OVIRT_VM_URI, "device");
        writer.writeAttributeString("devtype", "disk");
        writer.writeAttributeString("name", payloadMetadata.getFirst());
        writer.writeStartElement(OVIRT_VM_URI, "payload");
        if (payloadMetadata.getSecond().getVolumeId() != null) {
            writer.writeElement(OVIRT_VM_URI, "volId", payloadMetadata.getSecond().getVolumeId());
        }
        payloadMetadata.getSecond().getFiles().forEach((path, data) -> {
            writer.writeStartElement(OVIRT_VM_URI, "file");
            writer.writeAttributeString("path", path);
            writer.writeRaw(data);
            writer.writeEndElement();
        });
        writer.writeEndElement();
        writer.writeEndElement();
    }
}
#method_after
private void writePayloadMetadata() {
    if (payloadMetadata == null) {
        return;
    }
    writer.writeStartElement(OVIRT_VM_URI, "device");
    writer.writeAttributeString("devtype", "disk");
    writer.writeAttributeString("name", payloadMetadata.getFirst());
    writer.writeStartElement(OVIRT_VM_URI, "payload");
    String volumeId = payloadMetadata.getSecond().getVolumeId();
    if (volumeId != null) {
        writer.writeElement(OVIRT_VM_URI, "volId", volumeId);
    }
    Map<String, String> files = payloadMetadata.getSecond().getFiles();
    if (files != null) {
        files.forEach((path, data) -> {
            writer.writeStartElement(OVIRT_VM_URI, "file");
            writer.writeAttributeString("path", path);
            writer.writeRaw(data);
            writer.writeEndElement();
        });
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writeLeases();
    writer.writeEndElement();
}
#end_block

#method_before
private List<VmDevice> overrideDevicesForRunOnce(List<VmDevice> devices) {
    if (!vm.isRunOnce()) {
        return devices;
    }
    // video device handling
    DisplayType displayType = vm.getDefaultDisplayType();
    if (displayType != null) {
        // remove existing video device
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.VIDEO).collect(Collectors.toList());
        // add new video device
        if (displayType != DisplayType.none) {
            devices.add(vmInfoBuildUtils.createVideoDeviceByDisplayType(displayType, vm.getId()));
        }
    }
    // graphics device handling
    if (displayType == DisplayType.none || (vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty())) {
        // remove existing graphics devices
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.GRAPHICS).collect(Collectors.toList());
        if (displayType != DisplayType.none) {
            // add new graphics devices
            Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
            Map<String, Object> specParamsFromVm = new HashMap<>();
            vmInfoBuildUtils.addVmGraphicsOptions(infos, specParamsFromVm, vm);
            devices.addAll(vmInfoBuildUtils.createGraphicsDevices(infos, specParamsFromVm, vm.getId()));
        }
    }
    // the user may specify floppy path while there is no device in the database
    if (!StringUtils.isEmpty(vm.getFloppyPath()) && !devices.stream().anyMatch(dev -> !dev.getDevice().equals(VmDeviceType.FLOPPY.getName()))) {
        devices.add(vmInfoBuildUtils.createFloppyDevice(vm));
    }
    return devices;
}
#method_after
private List<VmDevice> overrideDevicesForRunOnce(List<VmDevice> devices) {
    if (!vm.isRunOnce()) {
        return devices;
    }
    // video device handling
    DisplayType displayType = vm.getDefaultDisplayType();
    if (displayType != null) {
        // remove existing video device
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.VIDEO).collect(Collectors.toList());
        // add new video device
        if (displayType != DisplayType.none) {
            devices.add(vmInfoBuildUtils.createVideoDeviceByDisplayType(displayType, vm.getId()));
        }
    }
    // graphics device handling
    if (displayType == DisplayType.none || (vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty())) {
        // remove existing graphics devices
        devices = devices.stream().filter(dev -> dev.getType() != VmDeviceGeneralType.GRAPHICS).collect(Collectors.toList());
        if (displayType != DisplayType.none) {
            // add new graphics devices
            Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
            Map<String, Object> specParamsFromVm = new HashMap<>();
            vmInfoBuildUtils.addVmGraphicsOptions(infos, specParamsFromVm, vm);
            devices.addAll(vmInfoBuildUtils.createGraphicsDevices(infos, specParamsFromVm, vm.getId()));
        }
    }
    // the user may specify floppy path while there is no device in the database
    if (!StringUtils.isEmpty(vm.getFloppyPath()) && !devices.stream().anyMatch(dev -> dev.getDevice().equals(VmDeviceType.FLOPPY.getName()))) {
        devices.add(vmInfoBuildUtils.createFloppyDevice(vm));
    }
    return devices;
}
#end_block

#method_before
private void writeLease() {
    if (vm.getLeaseStorageDomainId() == null) {
        return;
    }
    writer.writeStartElement("lease");
    writer.writeElement("key", vm.getId().toString());
    writer.writeElement("lockspace", vm.getLeaseStorageDomainId().toString());
    writer.writeStartElement("target");
    Map<String, String> leaseInfo = vm.getLeaseInfo();
    writer.writeAttributeString("offset", leaseInfo.get(VdsProperties.VmLeaseOffset));
    writer.writeAttributeString("path", leaseInfo.get(VdsProperties.VmLeasePath));
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeLease(String key, String lockspace, String path, String offset) {
    writer.writeStartElement("lease");
    writer.writeElement("key", key);
    writer.writeElement("lockspace", lockspace);
    writer.writeStartElement("target");
    writer.writeAttributeString("offset", offset);
    writer.writeAttributeString("path", path);
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            // Change parameters for the HE disk
            if (vm.isHostedEngine()) {
                // Hosted engine disk images have to have empty storage pool ID,
                // so they can be mounted even if storage pool is not connected.
                diskImage.setStoragePoolId(Guid.Empty);
                diskImage.setPropagateErrors(PropagateErrors.Off);
            }
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    // drop to the 'file' case as a fallback.
                    if (volInfo != null) {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            // Change parameters for the HE disk
            if (vm.isHostedEngine()) {
                // Hosted engine disk images have to have empty storage pool ID,
                // so they can be mounted even if storage pool is not connected.
                diskImage.setStoragePoolId(Guid.Empty);
                diskImage.setPropagateErrors(PropagateErrors.Off);
                // The disk requires a lease
                addVolumeLease(diskImage.getImageId(), diskImage.getStorageIds().get(0));
            }
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    // drop to the 'file' case as a fallback.
                    if (volInfo != null) {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#end_block

#method_before
private Map<String, Object> createDiskParams(DiskImage diskImage) {
    Map<String, Object> diskParams = createDiskUuidsMap(diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId());
    if (!diskImage.getActive()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Transient);
    } else if (diskImage.isShareable()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Shareable);
    } else if (vm.isHostedEngine()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Exclusive);
    }
    return diskParams;
}
#method_after
private Map<String, String> createDiskParams(DiskImage diskImage) {
    Map<String, String> diskParams = createDiskUuidsMap(diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId());
    if (!diskImage.getActive()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Transient);
    } else if (diskImage.isShareable()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Shareable);
    } else if (vm.isHostedEngine()) {
        diskParams.put(VdsProperties.Shareable, VdsProperties.Exclusive);
    }
    return diskParams;
}
#end_block

#method_before
private Map<String, Object> createDiskUuidsMap(Guid poolId, Guid domainId, Guid imageId, Guid volumeId) {
    Map<String, Object> diskUuids = new HashMap<>();
    diskUuids.put("poolID", poolId);
    diskUuids.put("domainID", domainId);
    diskUuids.put("imageID", imageId);
    diskUuids.put("volumeID", volumeId);
    return diskUuids;
}
#method_after
private Map<String, String> createDiskUuidsMap(Guid poolId, Guid domainId, Guid imageId, Guid volumeId) {
    return PDIVMapBuilder.create().setPoolId(poolId).setDomainId(domainId).setImageGroupId(imageId).setVolumeId(volumeId).build();
}
#end_block

#method_before
private void writeFloppy(VmDevice device) {
    if (device == null) {
        return;
    }
    // <disk device="floppy" snapshot="no" type="file">
    // <source file="/var/run/vdsm/payload/8b5fa6b8-9c57-4d7c-80cb-64537eea560f.6e38a5ccb3c6b2b674086e9d07126a03.img" startupPolicy="optional" />
    // <target bus="fdc" dev="fda" />
    // <readonly />
    // </disk>
    writer.writeStartElement("disk");
    writer.writeAttributeString("type", "file");
    writer.writeAttributeString("device", "floppy");
    writer.writeAttributeString("snapshot", "no");
    writer.writeStartElement("source");
    writer.writeAttributeString("file", VmPayload.isPayload(device.getSpecParams()) ? "PAYLOAD:" : vm.getFloppyPath());
    writer.writeAttributeString("startupPolicy", "optional");
    writer.writeEndElement();
    writer.writeStartElement("target");
    // IDE slot 2 is reserved by VDSM to CDROM
    String name = vmInfoBuildUtils.makeDiskName(VdsProperties.Fdc, 0);
    writer.writeAttributeString("dev", name);
    writer.writeAttributeString("bus", VdsProperties.Fdc);
    writer.writeEndElement();
    writer.writeElement("readonly");
    writeAlias(device);
    writeAddress(device);
    payloadMetadata = new Pair<>(name, new VmPayload(device));
    writer.writeEndElement();
}
#method_after
private void writeFloppy(VmDevice device) {
    if (device == null) {
        return;
    }
    // <disk device="floppy" snapshot="no" type="file">
    // <source file="/var/run/vdsm/payload/8b5fa6b8-9c57-4d7c-80cb-64537eea560f.6e38a5ccb3c6b2b674086e9d07126a03.img" startupPolicy="optional" />
    // <target bus="fdc" dev="fda" />
    // <readonly />
    // </disk>
    writer.writeStartElement("disk");
    writer.writeAttributeString("type", "file");
    writer.writeAttributeString("device", "floppy");
    writer.writeAttributeString("snapshot", "no");
    final boolean payload = VmPayload.isPayload(device.getSpecParams());
    writer.writeStartElement("source");
    writer.writeAttributeString("file", payload ? "PAYLOAD:" : vm.getFloppyPath());
    writer.writeAttributeString("startupPolicy", "optional");
    writer.writeEndElement();
    writer.writeStartElement("target");
    // IDE slot 2 is reserved by VDSM to CDROM
    String name = vmInfoBuildUtils.makeDiskName(VdsProperties.Fdc, 0);
    writer.writeAttributeString("dev", name);
    writer.writeAttributeString("bus", VdsProperties.Fdc);
    writer.writeEndElement();
    writer.writeElement("readonly");
    writeAlias(device);
    writeAddress(device);
    if (payload) {
        payloadMetadata = new Pair<>(name, new VmPayload(device));
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeAlias(VmDevice device) {
    writer.writeStartElement("alias");
    writer.writeAttributeString("name", String.format("ua-%s", device.getId().getDeviceId()));
    writer.writeEndElement();
}
#method_after
private void writeAlias(VmDevice device) {
    if (device.isManaged()) {
        writer.writeStartElement("alias");
        writer.writeAttributeString("name", String.format("ua-%s", device.getId().getDeviceId()));
        writer.writeEndElement();
    }
}
#end_block

#method_before
private Map<String, Object> createInfo() {
    if (FeatureSupported.isDomainXMLSupported(vm.getClusterCompatibilityVersion())) {
        String engineXml = generateDomainXml();
        if (getParameters().getMemoryDumpImage() == null) {
            return Collections.singletonMap(VdsProperties.engineXml, engineXml);
        } else {
            Map<String, Object> createInfo = new HashMap<>();
            createInfo.put(VdsProperties.engineXml, engineXml);
            DiskImage memoryDump = getParameters().getMemoryDumpImage();
            Map<String, String> memoryDumpPDIV = PDIVMapBuilder.create().setPoolId(memoryDump.getStoragePoolId()).setDomainId(memoryDump.getStorageIds().get(0)).setVolumeId(memoryDump.getId()).setVolumeId(memoryDump.getImageId()).build();
            DiskImage memoryConf = getParameters().getMemoryDumpImage();
            Map<String, String> memoryConfPDIV = PDIVMapBuilder.create().setPoolId(memoryConf.getStoragePoolId()).setDomainId(memoryConf.getStorageIds().get(0)).setVolumeId(memoryConf.getId()).setVolumeId(memoryConf.getImageId()).build();
            createInfo.put("memoryDumpVolume", memoryDumpPDIV);
            createInfo.put("memoryConfVolume", memoryConfPDIV);
            return createInfo;
        }
    } else {
        Map<String, Object> createInfo = new HashMap<>();
        VmInfoBuilder builder = createBuilder(createInfo);
        buildVmData(builder);
        log.info("VM {}", createInfo);
        return createInfo;
    }
}
#method_after
private Map<String, Object> createInfo() {
    if (FeatureSupported.isDomainXMLSupported(vm.getClusterCompatibilityVersion())) {
        String engineXml = generateDomainXml();
        if (getParameters().getMemoryDumpImage() == null) {
            return Collections.singletonMap(VdsProperties.engineXml, engineXml);
        } else {
            Map<String, Object> createInfo = new HashMap<>(4);
            createInfo.put(VdsProperties.engineXml, engineXml);
            DiskImage memoryDump = getParameters().getMemoryDumpImage();
            Map<String, String> memoryDumpPDIV = PDIVMapBuilder.create().setPoolId(memoryDump.getStoragePoolId()).setDomainId(memoryDump.getStorageIds().get(0)).setImageGroupId(memoryDump.getId()).setVolumeId(memoryDump.getImageId()).build();
            DiskImage memoryConf = getParameters().getMemoryConfImage();
            Map<String, String> memoryConfPDIV = PDIVMapBuilder.create().setPoolId(memoryConf.getStoragePoolId()).setDomainId(memoryConf.getStorageIds().get(0)).setImageGroupId(memoryConf.getId()).setVolumeId(memoryConf.getImageId()).build();
            createInfo.put("memoryDumpVolume", memoryDumpPDIV);
            createInfo.put("memoryConfVolume", memoryConfPDIV);
            return createInfo;
        }
    } else {
        Map<String, Object> createInfo = new HashMap<>();
        VmInfoBuilder builder = createBuilder(createInfo);
        buildVmData(builder);
        log.info("VM {}", createInfo);
        return createInfo;
    }
}
#end_block

#method_before
public static boolean isMemoryDisksOnDifferentDomainsSupported(Version version) {
    return supportedInConfig(ConfigValues.IsMemorySnapshotSupported, version);
}
#method_after
public static boolean isMemoryDisksOnDifferentDomainsSupported(Version version) {
    return supportedInConfig(ConfigValues.MemoryDisksOnDifferentDomainsSupported, version);
}
#end_block

#method_before
protected boolean shouldRestoreMemory() {
    return !memoryFromSnapshotUsed && (getFlow() == RunVmFlow.RESUME_HIBERNATE || FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getCompatibilityVersion())) && !StringUtils.isEmpty(getActiveSnapshot().getMemoryVolume());
}
#method_after
protected boolean shouldRestoreMemory() {
    // non coherent with the memory, thus we don't want to try to restore the memory again
    return !memoryFromSnapshotUsed && (getFlow() == RunVmFlow.RESUME_HIBERNATE || FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getCompatibilityVersion())) && !StringUtils.isEmpty(getActiveSnapshot().getMemoryVolume());
}
#end_block

#method_before
protected CreateVDSCommandParameters buildCreateVmParameters() {
    CreateVDSCommandParameters parameters = new CreateVDSCommandParameters(getVdsId(), getVm());
    parameters.setRunInUnknownStatus(getParameters().isRunInUnknownStatus());
    parameters.setVmPayload(vmPayload);
    if (shouldRestoreMemory()) {
        if (FeatureSupported.isMemoryDisksOnDifferentDomainsSupported(getVm().getCompatibilityVersion())) {
            parameters.setMemoryDumpImage(diskImageDao.get(getActiveSnapshot().getMemoryDiskId()));
            parameters.setMemoryConfImage(diskImageDao.get(getActiveSnapshot().getMetadataDiskId()));
        } else {
            parameters.setHibernationVolHandle(getActiveSnapshot().getMemoryVolume());
        }
        parameters.setDownSince(getVm().getStatus() == VMStatus.Suspended ? getVm().getLastStopTime() : getActiveSnapshot().getCreationDate());
    }
    parameters.setPassthroughVnicToVfMap(flushPassthroughVnicToVfMap());
    if (initializationType == InitializationType.Sysprep && osRepository.isWindows(getVm().getVmOsId()) && (getVm().getFloppyPath() == null || "".equals(getVm().getFloppyPath()))) {
        parameters.setInitializationType(InitializationType.Sysprep);
    }
    if (initializationType == InitializationType.CloudInit && !osRepository.isWindows(getVm().getVmOsId())) {
        parameters.setInitializationType(InitializationType.CloudInit);
    }
    return parameters;
}
#method_after
protected CreateVDSCommandParameters buildCreateVmParameters() {
    CreateVDSCommandParameters parameters = new CreateVDSCommandParameters(getVdsId(), getVm());
    parameters.setRunInUnknownStatus(getParameters().isRunInUnknownStatus());
    parameters.setVmPayload(vmPayload);
    if (shouldRestoreMemory()) {
        if (FeatureSupported.isMemoryDisksOnDifferentDomainsSupported(getVm().getCompatibilityVersion()) && getActiveSnapshot().getMemoryDiskId() != null) {
            parameters.setMemoryDumpImage((DiskImage) diskDao.get(getActiveSnapshot().getMemoryDiskId()));
            parameters.setMemoryConfImage((DiskImage) diskDao.get(getActiveSnapshot().getMetadataDiskId()));
        } else {
            parameters.setHibernationVolHandle(getActiveSnapshot().getMemoryVolume());
        }
        parameters.setDownSince(getVm().getStatus() == VMStatus.Suspended ? getVm().getLastStopTime() : getActiveSnapshot().getCreationDate());
    }
    parameters.setPassthroughVnicToVfMap(flushPassthroughVnicToVfMap());
    if (initializationType == InitializationType.Sysprep && osRepository.isWindows(getVm().getVmOsId()) && (getVm().getFloppyPath() == null || "".equals(getVm().getFloppyPath()))) {
        parameters.setInitializationType(InitializationType.Sysprep);
    }
    if (initializationType == InitializationType.CloudInit && !osRepository.isWindows(getVm().getVmOsId())) {
        parameters.setInitializationType(InitializationType.CloudInit);
    }
    return parameters;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    endCommandActions();
    if (getSucceeded() && (getDiskImage().getContentType() == DiskContentType.MEMORY_DUMP_VOLUME || getDiskImage().getContentType() == DiskContentType.MEMORY_METADATA_VOLUME)) {
        List<Snapshot> snapshots = snapshotDao.getSnapshotsByMemoryDiskId(getDiskImage().getId());
        snapshots.forEach(s -> s.getMemoryVolume());
    }
    incrementDbGenerationForRelatedEntities();
}
#method_after
@Override
protected void endSuccessfully() {
    endCommandActions();
    incrementDbGenerationForRelatedEntities();
}
#end_block

#method_before
private void init() {
    setTitle(ConstantsManager.getInstance().getConstants().newLogicalNetworkTitle());
    setHelpTag(HelpTag.new_logical_network);
    // $NON-NLS-1$
    setHashName("new_logical_network");
    getConnectedToPhysicalNetwork().setEntity(true);
    initMtu();
}
#method_after
private void init() {
    setTitle(ConstantsManager.getInstance().getConstants().newLogicalNetworkTitle());
    setHelpTag(HelpTag.new_logical_network);
    // $NON-NLS-1$
    setHashName("new_logical_network");
    getConnectedToPhysicalNetwork().setEntity(false);
    initMtu();
}
#end_block

#method_before
@Override
protected void onExportChanged() {
    boolean externalNetwork = getExternal().getEntity();
    getExternalProviders().setIsChangeable(externalNetwork);
    getIsVmNetwork().setIsChangeable(!externalNetwork && isSupportBridgesReportByVDSM() && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    if (externalNetwork) {
        getIsVmNetwork().setEntity(true);
    }
    Iterable<NetworkClusterModel> networkClusters = getNetworkClusterList().getItems();
    if (networkClusters != null) {
        for (NetworkClusterModel networkCluster : networkClusters) {
            networkCluster.setIsChangeable(true);
            networkCluster.setAttached(true);
            networkCluster.setRequired(!externalNetwork);
        }
    }
    super.onExportChanged();
}
#method_after
@Override
protected void onExportChanged() {
    boolean externalNetwork = getExternal().getEntity();
    getIsVmNetwork().setIsChangeable(!externalNetwork && isSupportBridgesReportByVDSM() && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    if (externalNetwork) {
        getIsVmNetwork().setEntity(true);
    }
    Iterable<NetworkClusterModel> networkClusters = getNetworkClusterList().getItems();
    if (networkClusters != null) {
        for (NetworkClusterModel networkCluster : networkClusters) {
            networkCluster.setIsChangeable(true);
            networkCluster.setAttached(true);
            networkCluster.setRequired(!externalNetwork);
        }
    }
    super.onExportChanged();
}
#end_block

#method_before
@Override
protected void executeSave() {
    final AddNetworkWithSubnetParameters parameters = new AddNetworkWithSubnetParameters(getSelectedDc().getId(), getNetwork());
    parameters.setVnicProfileRequired(false);
    parameters.setNetworkClusterList(getNetworkAttachments());
    // New network
    if (getExternal().getEntity()) {
        Provider<?> externalProvider = getExternalProviders().getSelectedItem();
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(externalProvider.getId());
        getNetwork().setProvidedBy(providerNetwork);
        if (hasDefinedSubnet()) {
            getSubnetModel().flush();
            parameters.setExternalSubnet(getSubnetModel().getSubnet());
        }
        if (getConnectedToPhysicalNetwork().getEntity() && getUsePhysicalNetworkFromDatacenter().getEntity()) {
            Network network = getDatacenterPhysicalNetwork().getSelectedItem();
            providerNetwork.setPhysicalNetworkId(network.getId());
        }
        Frontend.getInstance().runAction(hasDefinedSubnet() ? ActionType.AddNetworkWithSubnetOnProvider : ActionType.AddNetworkOnProvider, parameters, addNetworkCallback(), null);
    } else {
        Frontend.getInstance().runAction(ActionType.AddNetwork, parameters, addNetworkCallback(), null);
    }
}
#method_after
@Override
protected void executeSave() {
    final AddNetworkWithSubnetParameters parameters = new AddNetworkWithSubnetParameters(getSelectedDc().getId(), getNetwork());
    parameters.setVnicProfileRequired(false);
    parameters.setNetworkClusterList(createNetworkAttachments());
    // New network
    if (getExternal().getEntity()) {
        Provider<?> externalProvider = getExternalProviders().getSelectedItem();
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(externalProvider.getId());
        getNetwork().setProvidedBy(providerNetwork);
        if (hasDefinedSubnet()) {
            getSubnetModel().flush();
            parameters.setExternalSubnet(getSubnetModel().getSubnet());
        }
        if (getConnectedToPhysicalNetwork().getEntity() && getUsePhysicalNetworkFromDatacenter().getEntity()) {
            Network network = getDatacenterPhysicalNetwork().getSelectedItem();
            providerNetwork.setPhysicalNetworkId(network.getId());
        }
        Frontend.getInstance().runAction(hasDefinedSubnet() ? ActionType.AddNetworkWithSubnetOnProvider : ActionType.AddNetworkOnProvider, parameters, addNetworkCallback(), null);
    } else {
        Frontend.getInstance().runAction(ActionType.AddNetwork, parameters, addNetworkCallback(), null);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getNetwork().setId(Guid.newGuid());
    NetworkUtils.setNetworkVdsmName(getNetwork());
    TransactionSupport.executeInNewTransaction(() -> {
        networkDao.save(getNetwork());
        if (getNetwork().isVmNetwork() && getParameters().isVnicProfileRequired()) {
            vnicProfileDao.save(networkHelper.createVnicProfile(getNetwork()));
        }
        networkHelper.addPermissionsOnNetwork(getUserId(), getNetwork().getId());
        return null;
    });
    postSaveAction();
    getReturnValue().setActionReturnValue(getNetwork().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getNetwork().setId(Guid.newGuid());
    NetworkUtils.setNetworkVdsmName(getNetwork());
    TransactionSupport.executeInNewTransaction(() -> {
        networkDao.save(getNetwork());
        if (getNetwork().isVmNetwork() && getParameters().isVnicProfileRequired()) {
            vnicProfileDao.save(networkHelper.createVnicProfile(getNetwork()));
        }
        networkHelper.addPermissionsOnNetwork(getUserId(), getNetwork().getId());
        return null;
    });
    runClusterAttachment();
    getReturnValue().setActionReturnValue(getNetwork().getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    getView().setPlaceTransitionHandler(this);
    OvirtSelectionModel<?> tableSelectionModel = getTable() != null ? getTable().getSelectionModel() : null;
    if (tableSelectionModel != null) {
        registerHandler(tableSelectionModel.addSelectionChangeHandler(event -> {
            // Update detail model selection
            updateDetailModelSelection();
        }));
    }
    OvirtSelectionModel<T> mainModelSelectionModel = getMainModel().getSelectionModel();
    if (mainModelSelectionModel != null) {
        registerHandler(mainModelSelectionModel.addSelectionChangeHandler(event -> {
            itemChanged(mainModelSelectionModel.getFirstSelectedObject());
        }));
    }
    initializeHandlers();
    registerHandler(getView().addWindowResizeHandler(e -> {
        if (!resizing) {
            Scheduler.get().scheduleDeferred(() -> {
                getView().resizeToFullHeight();
                resizing = false;
            });
            resizing = true;
        }
    }));
    getMainModel().getItemsChangedEvent().addListener((ev, sender, args) -> {
        if (currentPlace != null) {
            prepareFromRequest(currentPlace);
        }
        if (getMainModel().getSelectedItem() == null && isVisible()) {
            placeManager.revealPlace(getMainContentRequest());
        }
    });
    getSelectedMainItems().registerListener(this);
    setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    getView().setPlaceTransitionHandler(this);
    OvirtSelectionModel<?> tableSelectionModel = getTable() != null ? getTable().getSelectionModel() : null;
    if (tableSelectionModel != null) {
        registerHandler(tableSelectionModel.addSelectionChangeHandler(event -> {
            // Update detail model selection
            updateDetailModelSelection();
        }));
    }
    OvirtSelectionModel<T> mainModelSelectionModel = getMainModel().getSelectionModel();
    if (mainModelSelectionModel != null) {
        registerHandler(mainModelSelectionModel.addSelectionChangeHandler(event -> {
            itemChanged(mainModelSelectionModel.getFirstSelectedObject());
        }));
    }
    initializeHandlers();
    registerHandler(getView().addWindowResizeHandler(e -> {
        if (!resizing) {
            Scheduler.get().scheduleDeferred(() -> {
                getView().resizeToFullHeight();
                resizing = false;
            });
            resizing = true;
        }
    }));
    getMainModel().getItemsChangedEvent().addListener((ev, sender, args) -> {
        if (currentPlace != null) {
            prepareFromRequest(currentPlace);
        }
        if (getMainModel().getSelectedItem() == null && isVisible()) {
            // Item has been removed, switch to main view.
            placeManager.revealPlace(getMainContentRequest());
        }
    });
    getSelectedMainItems().registerListener(this);
    setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
}
#end_block

#method_before
public void initProfiles(final Guid clusterId, final Guid dcId, final AsyncQuery<List<VnicProfileView>> profilesQuery) {
    AsyncQuery<QueryReturnValue> networksQuery = new AsyncQuery<>(response -> {
        profilesQuery.converterCallback = returnValue -> {
            ProfileBehavior.this.clusterNetworks = response.getReturnValue();
            List<VnicProfileView> vnicProfiles = new ArrayList<>();
            vnicProfiles.add(VnicProfileView.EMPTY);
            if (returnValue == null) {
                return vnicProfiles;
            }
            for (VnicProfileView vnicProfile : (List<VnicProfileView>) returnValue) {
                Network network = findNetworkById(vnicProfile.getNetworkId());
                if (network != null) {
                    vnicProfiles.add(vnicProfile);
                }
            }
            Collections.sort(vnicProfiles, Linq.VnicProfileViewComparator);
            return vnicProfiles;
        };
        AsyncDataProvider.getInstance().getVnicProfilesByDcId(profilesQuery, dcId);
    });
    Frontend.getInstance().runQuery(QueryType.GetAllVmNetworksByClusterId, new IdQueryParameters(clusterId), networksQuery);
}
#method_after
public void initProfiles(final Guid clusterId, final Guid dcId, final AsyncQuery<List<VnicProfileView>> profilesQuery) {
    AsyncQuery<QueryReturnValue> networksQuery = new AsyncQuery<>(response -> {
        clusterNetworks = response.getReturnValue();
        managementNetworkName = clusterNetworks.stream().filter(n -> n.getCluster().isManagement()).map(Network::getName).findFirst().orElse(null);
        profilesQuery.converterCallback = returnValue -> {
            List<VnicProfileView> vnicProfiles = new ArrayList<>();
            vnicProfiles.add(VnicProfileView.EMPTY);
            if (returnValue == null) {
                return vnicProfiles;
            }
            for (VnicProfileView vnicProfile : (List<VnicProfileView>) returnValue) {
                Network network = findNetworkById(vnicProfile.getNetworkId());
                if (network != null) {
                    vnicProfiles.add(vnicProfile);
                }
            }
            Collections.sort(vnicProfiles, Linq.VnicProfileViewComparator);
            return vnicProfiles;
        };
        AsyncDataProvider.getInstance().getVnicProfilesByDcId(profilesQuery, dcId);
    });
    Frontend.getInstance().runQuery(QueryType.GetAllVmNetworksByClusterId, new IdQueryParameters(clusterId), networksQuery);
}
#end_block

#method_before
@Override
public void initSelectedProfile(ListModel profileList, VmNetworkInterface networkInterface) {
    List<VnicProfileView> profiles = (List<VnicProfileView>) profileList.getItems();
    profiles = profiles == null ? new ArrayList<VnicProfileView>() : profiles;
    profileList.setSelectedItem(profiles.stream().filter(profile -> !Objects.equals(profile, VnicProfileView.EMPTY)).findFirst().orElse(VnicProfileView.EMPTY));
}
#method_after
@Override
public void initSelectedProfile(ListModel<VnicProfileView> profileList, VmNetworkInterface networkInterface) {
    Collection<VnicProfileView> profiles = Optional.ofNullable(profileList.getItems()).orElse(Collections.emptyList());
    Stream<VnicProfileView> profileStream = profiles.stream().filter(profile -> !Objects.equals(profile, VnicProfileView.EMPTY));
    if (StringHelper.isNotNullOrEmpty(getManagementNetworkName())) {
        profileStream = profileStream.filter(profile -> Objects.equals(profile.getNetworkName(), getManagementNetworkName()));
    }
    profileList.setSelectedItem(profileStream.findFirst().orElse(VnicProfileView.EMPTY));
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    NetworkView network = getSelectedItem();
    if (network == null || !network.isExternal()) {
        externalSubnetListModel.setIsAvailable(false);
    } else {
        AsyncDataProvider.getInstance().getProviderById(new AsyncQuery<>(provider -> externalSubnetListModel.setIsAvailable(!provider.getIsUnmanaged())), network.getProvidedBy().getProviderId());
    }
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    NetworkView network = getSelectedItem();
    if (network == null || !network.isExternal()) {
        externalSubnetListModel.setIsAvailable(false);
    } else {
        AsyncDataProvider.getInstance().getProviderById(new AsyncQuery<>(provider -> {
            boolean available = provider != null ? !provider.getIsUnmanaged() : false;
            externalSubnetListModel.setIsAvailable(available);
        }), network.getProvidedBy().getProviderId());
    }
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x) {
        // no mouse or tablet for s390x
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeConsole(VmDevice device) {
    // <console type='pty'>
    // <target type='serial' port='0'/>
    // </console>
    // or:
    // <console type='pty'>
    // <target type='virtio' port='0'/>
    // </console>
    // or:
    // <console type='unix'>
    // <source mode='bind' path='/path/to/${vmid}.sock'>
    // <target type='virtio' port='0'/>
    // </console>
    writer.writeStartElement("console");
    String path = getSerialConsolePath(device);
    if (!path.isEmpty()) {
        writer.writeAttributeString("type", "unix");
        writer.writeStartElement("source");
        writer.writeAttributeString("path", path);
        writer.writeAttributeString("mode", "bind");
        writer.writeEndElement();
    } else {
        writer.writeAttributeString("type", "pty");
    }
    writer.writeStartElement("target");
    Object consoleTypeFromSpecParams = device.getSpecParams().get("consoleType");
    String consoleType = consoleTypeFromSpecParams != null ? consoleTypeFromSpecParams.toString() : "virtio";
    writer.writeAttributeString("type", consoleType);
    writer.writeAttributeString("port", "0");
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeConsole(VmDevice device) {
    // <console type='pty'>
    // <target type='serial' port='0'/>
    // </console>
    // or:
    // <console type='pty'>
    // <target type='virtio' port='0'/>
    // </console>
    // or:
    // <console type='unix'>
    // <source mode='bind' path='/path/to/${vmid}.sock'>
    // <target type='virtio' port='0'/>
    // </console>
    writer.writeStartElement("console");
    String path = getSerialConsolePath(device);
    if (!path.isEmpty()) {
        writer.writeAttributeString("type", "unix");
        writer.writeStartElement("source");
        writer.writeAttributeString("path", path);
        writer.writeAttributeString("mode", "bind");
        writer.writeEndElement();
    } else {
        writer.writeAttributeString("type", "pty");
    }
    writer.writeStartElement("target");
    Object consoleTypeFromSpecParams = device.getSpecParams().get("consoleType");
    String consoleType = consoleTypeFromSpecParams != null ? consoleTypeFromSpecParams.toString() : "virtio";
    writer.writeAttributeString("type", consoleType);
    writer.writeAttributeString("port", "0");
    writer.writeEndElement();
    writeAlias(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeScsiHostDevice(VmHostDevice device, HostDevice hostDevice) {
    // Create domxml for a host device.
    // 
    // <hostdev managed="no" mode="subsystem" rawio="yes" type="scsi">
    // <source>
    // <adapter name="scsi_host4"/>
    // <address bus="0" target="0" unit="0"/>
    // </source>
    // </hostdev>
    writer.writeStartElement("hostdev");
    writer.writeAttributeString("managed", "no");
    writer.writeAttributeString("mode", "subsystem");
    writer.writeAttributeString("rawio", "yes");
    writer.writeAttributeString("type", "scsi");
    writer.writeStartElement("source");
    writer.writeStartElement("adapter");
    writer.writeAttributeString("name", String.format("scsi_host%s", hostDevice.getAddress().get("host")));
    writer.writeEndElement();
    writer.writeStartElement("address");
    writer.writeAttributeString("bus", hostDevice.getAddress().get("bus"));
    writer.writeAttributeString("target", hostDevice.getAddress().get("target"));
    writer.writeAttributeString("unit", hostDevice.getAddress().get("lun"));
    writer.writeEndElement();
    writer.writeEndElement();
    writeAddress(device);
    // TODO: boot
    writer.writeEndElement();
}
#method_after
private void writeScsiHostDevice(VmHostDevice device, HostDevice hostDevice) {
    // Create domxml for a host device.
    // 
    // <hostdev managed="no" mode="subsystem" rawio="yes" type="scsi">
    // <source>
    // <adapter name="scsi_host4"/>
    // <address bus="0" target="0" unit="0"/>
    // </source>
    // </hostdev>
    writer.writeStartElement("hostdev");
    writer.writeAttributeString("managed", "no");
    writer.writeAttributeString("mode", "subsystem");
    writer.writeAttributeString("rawio", "yes");
    writer.writeAttributeString("type", "scsi");
    writer.writeStartElement("source");
    writer.writeStartElement("adapter");
    writer.writeAttributeString("name", String.format("scsi_host%s", hostDevice.getAddress().get("host")));
    writer.writeEndElement();
    writer.writeStartElement("address");
    writer.writeAttributeString("bus", hostDevice.getAddress().get("bus"));
    writer.writeAttributeString("target", hostDevice.getAddress().get("target"));
    writer.writeAttributeString("unit", hostDevice.getAddress().get("lun"));
    writer.writeEndElement();
    writer.writeEndElement();
    writeAlias(device);
    writeAddress(device);
    // TODO: boot
    writer.writeEndElement();
}
#end_block

#method_before
private void writeUsbHostDevice(VmHostDevice device, HostDevice hostDevice) {
    // Create domxml for a host device.
    // 
    // <hostdev managed="no" mode="subsystem" type="usb">
    // <source>
    // <address bus="1" device="2"/>
    // </source>
    // </hostdev>
    writer.writeStartElement("hostdev");
    writer.writeAttributeString("managed", "no");
    writer.writeAttributeString("mode", "subsystem");
    writer.writeAttributeString("type", "usb");
    writer.writeStartElement("source");
    writer.writeStartElement("address");
    writer.writeAttributeString("bus", hostDevice.getAddress().get("bus"));
    writer.writeAttributeString("device", hostDevice.getAddress().get("device"));
    writer.writeEndElement();
    writer.writeEndElement();
    writeAddress(device);
    // TODO: boot
    writer.writeEndElement();
}
#method_after
private void writeUsbHostDevice(VmHostDevice device, HostDevice hostDevice) {
    // Create domxml for a host device.
    // 
    // <hostdev managed="no" mode="subsystem" type="usb">
    // <source>
    // <address bus="1" device="2"/>
    // </source>
    // </hostdev>
    writer.writeStartElement("hostdev");
    writer.writeAttributeString("managed", "no");
    writer.writeAttributeString("mode", "subsystem");
    writer.writeAttributeString("type", "usb");
    writer.writeStartElement("source");
    writer.writeStartElement("address");
    writer.writeAttributeString("bus", hostDevice.getAddress().get("bus"));
    writer.writeAttributeString("device", hostDevice.getAddress().get("device"));
    writer.writeEndElement();
    writer.writeEndElement();
    writeAlias(device);
    writeAddress(device);
    // TODO: boot
    writer.writeEndElement();
}
#end_block

#method_before
private void writePciHostDevice(VmHostDevice device, HostDevice hostDevice) {
    // </hostdev>
    if (device.isIommuPlaceholder()) {
        return;
    }
    writer.writeStartElement("hostdev");
    writer.writeAttributeString("managed", "no");
    writer.writeAttributeString("mode", "subsystem");
    writer.writeAttributeString("type", "pci");
    writer.writeStartElement("source");
    writer.writeStartElement("address");
    writer.writeAttributeString("domain", hostDevice.getAddress().get("domain"));
    writer.writeAttributeString("bus", hostDevice.getAddress().get("bus"));
    writer.writeAttributeString("slot", hostDevice.getAddress().get("slot"));
    writer.writeAttributeString("function", hostDevice.getAddress().get("function"));
    writer.writeEndElement();
    writer.writeEndElement();
    writeAddress(device);
    // TODO: boot
    writer.writeEndElement();
}
#method_after
private void writePciHostDevice(VmHostDevice device, HostDevice hostDevice) {
    // </hostdev>
    if (device.isIommuPlaceholder()) {
        return;
    }
    writer.writeStartElement("hostdev");
    writer.writeAttributeString("managed", "no");
    writer.writeAttributeString("mode", "subsystem");
    writer.writeAttributeString("type", "pci");
    writer.writeStartElement("source");
    writer.writeStartElement("address");
    writer.writeAttributeString("domain", hostDevice.getAddress().get("domain"));
    writer.writeAttributeString("bus", hostDevice.getAddress().get("bus"));
    writer.writeAttributeString("slot", hostDevice.getAddress().get("slot"));
    writer.writeAttributeString("function", hostDevice.getAddress().get("function"));
    writer.writeEndElement();
    writer.writeEndElement();
    writeAlias(device);
    writeAddress(device);
    // TODO: boot
    writer.writeEndElement();
}
#end_block

#method_before
private void writeRedir(VmDevice device) {
    // <redirdev bus='usb' type='spicevmc'>
    // <address type='usb' bus='0' port='1'/>
    // </redirdev>
    writer.writeStartElement("redirdev");
    writer.writeAttributeString("type", "spicevmc");
    writer.writeAttributeString("bus", "usb");
    writeAddress(device);
    writer.writeEndElement();
}
#method_after
private void writeRedir(VmDevice device) {
    // <redirdev bus='usb' type='spicevmc'>
    // <address type='usb' bus='0' port='1'/>
    // </redirdev>
    writer.writeStartElement("redirdev");
    writer.writeAttributeString("type", "spicevmc");
    writer.writeAttributeString("bus", "usb");
    writeAlias(device);
    writeAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeRng(VmDevice device) {
    // <rng model='virtio'>
    // <rate period="2000" bytes="1234"/>
    // <backend model='random'>/dev/random</backend>
    // </rng>
    writer.writeStartElement("rng");
    writer.writeAttributeString("model", "virtio");
    Map<String, Object> specParams = device.getSpecParams();
    if (specParams.containsKey("bytes")) {
        writer.writeStartElement("rate");
        writer.writeAttributeString("bytes", specParams.get("bytes").toString());
        if (specParams.containsKey("period")) {
            writer.writeAttributeString("period", specParams.get("period").toString());
        }
        writer.writeEndElement();
    }
    writer.writeStartElement("backend");
    writer.writeAttributeString("model", "random");
    switch(specParams.get("source").toString()) {
        case "random":
            writer.writeRaw("/dev/random");
            break;
        case "urandom":
            writer.writeRaw("/dev/urandom");
            break;
        case "hwrng":
            writer.writeRaw("/dev/hwrng");
            break;
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeRng(VmDevice device) {
    // <rng model='virtio'>
    // <rate period="2000" bytes="1234"/>
    // <backend model='random'>/dev/random</backend>
    // </rng>
    writer.writeStartElement("rng");
    writer.writeAttributeString("model", "virtio");
    Map<String, Object> specParams = device.getSpecParams();
    if (specParams.containsKey("bytes")) {
        writer.writeStartElement("rate");
        writer.writeAttributeString("bytes", specParams.get("bytes").toString());
        if (specParams.containsKey("period")) {
            writer.writeAttributeString("period", specParams.get("period").toString());
        }
        writer.writeEndElement();
    }
    writer.writeStartElement("backend");
    writer.writeAttributeString("model", "random");
    switch(specParams.get("source").toString()) {
        case "random":
            writer.writeRaw("/dev/random");
            break;
        case "urandom":
            writer.writeRaw("/dev/urandom");
            break;
        case "hwrng":
            writer.writeRaw("/dev/hwrng");
            break;
    }
    writer.writeEndElement();
    writeAlias(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeSound(VmDevice device) {
    writer.writeStartElement("sound");
    writer.writeAttributeString("model", device.getDevice());
    writeAddress(device);
    writer.writeEndElement();
}
#method_after
private void writeSound(VmDevice device) {
    writer.writeStartElement("sound");
    writer.writeAttributeString("model", device.getDevice());
    writeAlias(device);
    writeAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeController(VmDevice device) {
    writer.writeStartElement("controller");
    writer.writeAttributeString("type", device.getDevice());
    if (device.getSpecParams().containsKey(VdsProperties.Model)) {
        writer.writeAttributeString("model", device.getSpecParams().get(VdsProperties.Model).toString());
    }
    if (device.getSpecParams().containsKey(VdsProperties.Index)) {
        writer.writeAttributeString("index", device.getSpecParams().get(VdsProperties.Index).toString());
    }
    if (device.getSpecParams().containsKey("ports")) {
        writer.writeAttributeString("ports", device.getSpecParams().get("ports").toString());
    }
    // TODO: master??
    writeAddress(device);
    writer.writeEndElement();
}
#method_after
private void writeController(VmDevice device) {
    writer.writeStartElement("controller");
    writer.writeAttributeString("type", device.getDevice());
    if (device.getSpecParams().containsKey(VdsProperties.Model)) {
        writer.writeAttributeString("model", device.getSpecParams().get(VdsProperties.Model).toString());
    }
    if (device.getSpecParams().containsKey(VdsProperties.Index)) {
        writer.writeAttributeString("index", device.getSpecParams().get(VdsProperties.Index).toString());
    }
    if (device.getSpecParams().containsKey("ports")) {
        writer.writeAttributeString("ports", device.getSpecParams().get("ports").toString());
    }
    // TODO: master??
    writeAlias(device);
    writeAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDisk(VmDevice device, Disk disk, DiskVmElement dve, String dev, int pinTo) {
    // <disk type='file' device='disk' snapshot='no'>
    // <driver name='qemu' type='qcow2' cache='none'/>
    // <source file='/path/to/image'/>
    // <target dev='hda' bus='ide'/>
    // <serial>54-a672-23e5b495a9ea</serial>
    // </disk>
    writer.writeStartElement("disk");
    writeGeneralDiskAttributes(device, disk, dve);
    writeDiskTarget(dve, dev);
    writeDiskSource(disk, dev);
    writeDiskDriver(device, disk, dve, pinTo);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    if (disk.getDiskStorageType() != DiskStorageType.LUN) {
        writer.writeElement("serial", disk.getId().toString());
    }
    if (device.getReadOnly()) {
        writer.writeElement("readonly");
    }
    if (device.getSnapshotId() == null && disk.isShareable()) {
        writer.writeElement("shareable");
    }
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        writeIoTune((DiskImage) disk);
    }
    if (disk.getDiskStorageType() == DiskStorageType.CINDER) /**
     * && case RBD
     */
    {
        writeNetworkDiskAuth((CinderDisk) disk);
    }
    writer.writeEndElement();
}
#method_after
private void writeDisk(VmDevice device, Disk disk, DiskVmElement dve, String dev, int pinTo) {
    // <disk type='file' device='disk' snapshot='no'>
    // <driver name='qemu' type='qcow2' cache='none'/>
    // <source file='/path/to/image'/>
    // <target dev='hda' bus='ide'/>
    // <serial>54-a672-23e5b495a9ea</serial>
    // </disk>
    writer.writeStartElement("disk");
    writeGeneralDiskAttributes(device, disk, dve);
    writeDiskTarget(dve, dev);
    writeDiskSource(disk, dev);
    writeDiskDriver(device, disk, dve, pinTo);
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    if (disk.getDiskStorageType() != DiskStorageType.LUN) {
        writer.writeElement("serial", disk.getId().toString());
    }
    if (device.getReadOnly()) {
        writer.writeElement("readonly");
    }
    if (device.getSnapshotId() == null && disk.isShareable()) {
        writer.writeElement("shareable");
    }
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        writeIoTune((DiskImage) disk);
    }
    if (disk.getDiskStorageType() == DiskStorageType.CINDER) /**
     * && case RBD
     */
    {
        writeNetworkDiskAuth((CinderDisk) disk);
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeFloppy(VmDevice device) {
    if (device == null) {
        return;
    }
    // <disk device="floppy" snapshot="no" type="file">
    // <source file="/var/run/vdsm/payload/8b5fa6b8-9c57-4d7c-80cb-64537eea560f.6e38a5ccb3c6b2b674086e9d07126a03.img" startupPolicy="optional" />
    // <target bus="fdc" dev="fda" />
    // <readonly />
    // </disk>
    writer.writeStartElement("disk");
    writer.writeAttributeString("type", "file");
    writer.writeAttributeString("device", "floppy");
    writer.writeAttributeString("snapshot", "no");
    writer.writeStartElement("source");
    writer.writeAttributeString("file", VmPayload.isPayload(device.getSpecParams()) ? "PAYLOAD:" : vm.getFloppyPath());
    writer.writeAttributeString("startupPolicy", "optional");
    writer.writeEndElement();
    writer.writeStartElement("target");
    // IDE slot 2 is reserved by VDSM to CDROM
    String name = vmInfoBuildUtils.makeDiskName(VdsProperties.Fdc, 0);
    writer.writeAttributeString("dev", name);
    writer.writeAttributeString("bus", VdsProperties.Fdc);
    writer.writeEndElement();
    writer.writeElement("readonly");
    writeAddress(device);
    payloadMetadata = new Pair<>(name, new VmPayload(device));
    writer.writeEndElement();
}
#method_after
private void writeFloppy(VmDevice device) {
    if (device == null) {
        return;
    }
    // <disk device="floppy" snapshot="no" type="file">
    // <source file="/var/run/vdsm/payload/8b5fa6b8-9c57-4d7c-80cb-64537eea560f.6e38a5ccb3c6b2b674086e9d07126a03.img" startupPolicy="optional" />
    // <target bus="fdc" dev="fda" />
    // <readonly />
    // </disk>
    writer.writeStartElement("disk");
    writer.writeAttributeString("type", "file");
    writer.writeAttributeString("device", "floppy");
    writer.writeAttributeString("snapshot", "no");
    writer.writeStartElement("source");
    writer.writeAttributeString("file", VmPayload.isPayload(device.getSpecParams()) ? "PAYLOAD:" : vm.getFloppyPath());
    writer.writeAttributeString("startupPolicy", "optional");
    writer.writeEndElement();
    writer.writeStartElement("target");
    // IDE slot 2 is reserved by VDSM to CDROM
    String name = vmInfoBuildUtils.makeDiskName(VdsProperties.Fdc, 0);
    writer.writeAttributeString("dev", name);
    writer.writeAttributeString("bus", VdsProperties.Fdc);
    writer.writeEndElement();
    writer.writeElement("readonly");
    writeAlias(device);
    writeAddress(device);
    payloadMetadata = new Pair<>(name, new VmPayload(device));
    writer.writeEndElement();
}
#end_block

#method_before
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw' error_policy='report' />
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        String name = vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex);
        writer.writeAttributeString("dev", name);
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        payloadMetadata = new Pair<>(name, new VmPayload(device));
        writer.writeEndElement();
    });
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath()))) {
        // add a device that points to vm.getCdPath()
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        boolean isoOnBlockDomain = false;
        if (vm.getIsoPath() != null && vm.getIsoPath().matches(ValidationUtils.GUID) && vmInfoBuildUtils.isBlockDomainPath(vm.getCdPath())) {
            isoOnBlockDomain = true;
            String dev = vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex);
            Matcher m = Pattern.compile(ValidationUtils.GUID).matcher(vm.getCdPath());
            m.find();
            Guid domainId = Guid.createGuidFromString(m.group());
            m.find();
            Guid imageId = Guid.createGuidFromString(m.group());
            m.find();
            Guid volumeId = Guid.createGuidFromString(m.group());
            diskMetadata.put(dev, createDiskUuidsMap(vm.getStoragePoolId(), domainId, imageId, volumeId));
        }
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", isoOnBlockDomain ? "block" : "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString(isoOnBlockDomain ? "dev" : "file", vm.getCdPath());
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#method_after
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw' error_policy='report' />
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        String name = vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex);
        writer.writeAttributeString("dev", name);
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        writeAlias(device);
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        payloadMetadata = new Pair<>(name, new VmPayload(device));
        writer.writeEndElement();
    });
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath()))) {
        // add a device that points to vm.getCdPath()
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        boolean isoOnBlockDomain = false;
        if (vm.getIsoPath() != null && vm.getIsoPath().matches(ValidationUtils.GUID) && vmInfoBuildUtils.isBlockDomainPath(vm.getCdPath())) {
            isoOnBlockDomain = true;
            String dev = vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex);
            Matcher m = Pattern.compile(ValidationUtils.GUID).matcher(vm.getCdPath());
            m.find();
            Guid domainId = Guid.createGuidFromString(m.group());
            m.find();
            Guid imageId = Guid.createGuidFromString(m.group());
            m.find();
            Guid volumeId = Guid.createGuidFromString(m.group());
            diskMetadata.put(dev, createDiskUuidsMap(vm.getStoragePoolId(), domainId, imageId, volumeId));
        }
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", isoOnBlockDomain ? "block" : "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString(isoOnBlockDomain ? "dev" : "file", vm.getCdPath());
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAlias(nonPayload);
            writeAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network != null ? network.getVdsmName() : "");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(network != null ? network.getName() : "");
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (network != null && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (properties.containsKey("sndbuf")) {
        writer.writeStartElement("tune");
        writer.writeStartElement("sndbuf");
        writer.writeRaw(properties.get("sndbuf"));
        writer.writeEndElement();
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network != null ? network.getVdsmName() : "");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(network != null ? network.getName() : "");
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (network != null && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeBalloon(VmDevice device) {
    // <memballoon model='virtio'>
    // <stats period='5' />
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/>
    // </memballoon>
    writer.writeStartElement("memballoon");
    writer.writeAttributeString("model", device.getSpecParams().get(VdsProperties.Model).toString());
    writer.writeStartElement("stats");
    writer.writeAttributeString("period", "5");
    writer.writeEndElement();
    writeAddress(device);
    writer.writeEndElement();
}
#method_after
private void writeBalloon(VmDevice device) {
    // <memballoon model='virtio'>
    // <stats period='5' />
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/>
    // </memballoon>
    writer.writeStartElement("memballoon");
    writer.writeAttributeString("model", device.getSpecParams().get(VdsProperties.Model).toString());
    writer.writeStartElement("stats");
    writer.writeAttributeString("period", "5");
    writer.writeEndElement();
    writeAlias(device);
    writeAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeSmartcard(VmDevice device) {
    // <smartcard mode='passthrough' type='spicevmc'>
    // <address/>
    // </smartcard>
    writer.writeStartElement("smartcard");
    writer.writeAttributeString("mode", device.getSpecParams().get("mode").toString());
    writer.writeAttributeString("type", device.getSpecParams().get("type").toString());
    writeAddress(device);
    writer.writeEndElement();
}
#method_after
private void writeSmartcard(VmDevice device) {
    // <smartcard mode='passthrough' type='spicevmc'>
    // <address/>
    // </smartcard>
    writer.writeStartElement("smartcard");
    writer.writeAttributeString("mode", device.getSpecParams().get("mode").toString());
    writer.writeAttributeString("type", device.getSpecParams().get("type").toString());
    writeAlias(device);
    writeAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeWatchdog(VmDevice device) {
    // <watchdog model='i6300esb' action='reset'>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x0'/>
    // </watchdog>
    writer.writeStartElement("watchdog");
    Object model = device.getSpecParams().get(VdsProperties.Model);
    writer.writeAttributeString("model", model != null ? model.toString() : "i6300esb");
    Object action = device.getSpecParams().get(VdsProperties.action);
    writer.writeAttributeString("action", action != null ? action.toString() : "none");
    writeAddress(device);
    writer.writeEndElement();
}
#method_after
private void writeWatchdog(VmDevice device) {
    // <watchdog model='i6300esb' action='reset'>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x0'/>
    // </watchdog>
    writer.writeStartElement("watchdog");
    Object model = device.getSpecParams().get(VdsProperties.Model);
    writer.writeAttributeString("model", model != null ? model.toString() : "i6300esb");
    Object action = device.getSpecParams().get(VdsProperties.action);
    writer.writeAttributeString("action", action != null ? action.toString() : "none");
    writeAlias(device);
    writeAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeVideo(VmDevice device) {
    writer.writeStartElement("video");
    writer.writeStartElement("model");
    writer.writeAttributeString("type", device.getDevice());
    Object vram = device.getSpecParams().get(VdsProperties.VIDEO_VRAM);
    writer.writeAttributeString("vram", vram != null ? vram.toString() : "32768");
    Object heads = device.getSpecParams().get(VdsProperties.VIDEO_HEADS);
    writer.writeAttributeString("heads", heads != null ? heads.toString() : "1");
    if (device.getSpecParams().containsKey(VdsProperties.VIDEO_RAM)) {
        writer.writeAttributeString("ram", device.getSpecParams().get(VdsProperties.VIDEO_RAM).toString());
    }
    if (device.getSpecParams().containsKey(VdsProperties.VIDEO_VGAMEM)) {
        writer.writeAttributeString("vgamem", device.getSpecParams().get(VdsProperties.VIDEO_VGAMEM).toString());
    }
    writer.writeEndElement();
    writeAddress(device);
    writer.writeEndElement();
}
#method_after
private void writeVideo(VmDevice device) {
    writer.writeStartElement("video");
    writer.writeStartElement("model");
    writer.writeAttributeString("type", device.getDevice());
    Object vram = device.getSpecParams().get(VdsProperties.VIDEO_VRAM);
    writer.writeAttributeString("vram", vram != null ? vram.toString() : "32768");
    Object heads = device.getSpecParams().get(VdsProperties.VIDEO_HEADS);
    writer.writeAttributeString("heads", heads != null ? heads.toString() : "1");
    if (device.getSpecParams().containsKey(VdsProperties.VIDEO_RAM)) {
        writer.writeAttributeString("ram", device.getSpecParams().get(VdsProperties.VIDEO_RAM).toString());
    }
    if (device.getSpecParams().containsKey(VdsProperties.VIDEO_VGAMEM)) {
        writer.writeAttributeString("vgamem", device.getSpecParams().get(VdsProperties.VIDEO_VGAMEM).toString());
    }
    writer.writeEndElement();
    writeAlias(device);
    writeAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
/**
 * Parses the page number out of the provided search string and returns it.
 * Page indication appears in the search string in this format: "page 15"
 * If page indication does not exist, null is returned. For example:
 *
 *   GET .../api/vms?search=page%203     will return 3.
 *   GET .../api/vms?search=name%3Dvm_1  will return null
 */
public static Integer parsePageNum(String searchStr) {
    if (searchStr.toLowerCase().indexOf("page ") == -1) {
        return null;
    } else {
        int pos = searchStr.toLowerCase().indexOf("page ") + 5;
        StringBuilder pageNumberStr = new StringBuilder();
        char c = searchStr.charAt(pos);
        while (Character.isDigit(c) && pos < searchStr.length()) {
            pageNumberStr.append(c);
            pos += 1;
            if (pos < searchStr.length()) {
                c = searchStr.charAt(pos);
            }
        }
        // if page number is empty ("page "), return 1 (the first page) by default
        int pageNum = pageNumberStr.length() == 0 ? 1 : Integer.valueOf(pageNumberStr.toString());
        return pageNum;
    }
}
#method_after
/**
 * Parses the page number out of the provided search string and returns it.
 * Page indication appears in the search string in this format: "page 15"
 * If page indication does not exist, null is returned. For example:
 *
 *   GET .../api/vms?search=page%203     will return 3.
 *   GET .../api/vms?search=name%3Dvm_1  will return null
 */
public static Integer parsePageNum(String searchStr) {
    if (searchStr.toLowerCase().indexOf("page ") == -1) {
        return null;
    } else {
        int pos = searchStr.toLowerCase().indexOf("page ") + 5;
        StringBuilder pageNumberStr = new StringBuilder();
        char c = searchStr.charAt(pos);
        while (Character.isDigit(c) && pos < searchStr.length()) {
            pageNumberStr.append(c);
            pos += 1;
            if (pos < searchStr.length()) {
                c = searchStr.charAt(pos);
            }
        }
        // if page number is empty ("page "), return 1 (the first page) by default
        int pageNum = pageNumberStr.length() == 0 ? 1 : Integer.parseInt(pageNumberStr.toString());
        return pageNum;
    }
}
#end_block

#method_before
private Vms getVmsFilteredAndSorted() {
    int max = ParametersHelper.getIntegerParameter(httpHeaders, uriInfo, "max", -1, -1);
    GetFilteredAndSortedParameters params = new GetFilteredAndSortedParameters(max);
    String searchConstraint = QueryHelper.getConstraint(httpHeaders, uriInfo, "", modelType);
    Integer pageNum = QueryHelper.parsePageNum(searchConstraint);
    params.setPageNum(pageNum == null ? 1 : pageNum);
    return mapCollection(getBackendCollection(QueryType.GetAllVmsFilteredAndSorted, params));
}
#method_after
private Vms getVmsFilteredAndSorted() {
    int max = ParametersHelper.getIntegerParameter(httpHeaders, uriInfo, "max", -1, -1);
    String searchConstraint = QueryHelper.getConstraint(httpHeaders, uriInfo, "", modelType);
    Integer pageNum = QueryHelper.parsePageNum(searchConstraint);
    GetFilteredAndSortedParameters params = new GetFilteredAndSortedParameters(max, pageNum == null ? 1 : pageNum);
    return mapCollection(getBackendCollection(QueryType.GetAllVmsFilteredAndSorted, params));
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.forEach(this::replaceNullSpecParams);
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && (vm.getClusterArch().getFamily() != ArchitectureType.ppc || vm.getVmType() != VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDisks(List<VmDevice> devices) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    int ideIndex = -1;
    int scsiIndex = -1;
    int virtioIndex = -1;
    DiskInterface cdDiskInterface = DiskInterface.forValue(cdInterface);
    for (Disk disk : vmInfoBuildUtils.getSortedDisks(vm)) {
        VmDevice device = deviceIdToDevice.get(new VmDeviceId(disk.getId(), vm.getId()));
        if (device == null) {
            // This may happen to memory disks that do not have a corresponding device
            continue;
        }
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        DiskInterface diskInterface = dve.getDiskInterface();
        int index = 0;
        switch(diskInterface) {
            case IDE:
                ideIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (ideIndex == payloadIndex || ideIndex == cdRomIndex) {
                        ideIndex++;
                    }
                }
                index = ideIndex;
                break;
            case VirtIO:
                virtioIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (virtioIndex == payloadIndex || virtioIndex == cdRomIndex) {
                        virtioIndex++;
                    }
                }
                index = virtioIndex;
                break;
            case SPAPR_VSCSI:
            case VirtIO_SCSI:
                scsiIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (scsiIndex == payloadIndex || scsiIndex == cdRomIndex) {
                        scsiIndex++;
                    }
                }
                index = scsiIndex;
                break;
        }
        if (device.isManaged()) {
            String dev = vmInfoBuildUtils.makeDiskName(dve.getDiskInterface().getName(), index);
            writeManagedDisk(device, disk, dve, dev);
        }
    // TODO: else
    }
}
#method_after
private void writeDisks(List<VmDevice> devices) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    int ideIndex = -1;
    int scsiIndex = -1;
    int virtioIndex = -1;
    DiskInterface cdDiskInterface = DiskInterface.forValue(cdInterface);
    int pinnedDriveIndex = 0;
    for (Disk disk : vmInfoBuildUtils.getSortedDisks(vm)) {
        VmDevice device = deviceIdToDevice.get(new VmDeviceId(disk.getId(), vm.getId()));
        if (device == null || !device.isManaged()) {
            // This may happen to memory disks that do not have a corresponding device
            continue;
        }
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        DiskInterface diskInterface = dve.getDiskInterface();
        int index = 0;
        int pinTo = 0;
        switch(diskInterface) {
            case IDE:
                ideIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (ideIndex == payloadIndex || ideIndex == cdRomIndex) {
                        ideIndex++;
                    }
                }
                index = ideIndex;
                break;
            case VirtIO:
                pinTo = vmInfoBuildUtils.pinToIoThreads(vm, device, pinnedDriveIndex++);
                virtioIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (virtioIndex == payloadIndex || virtioIndex == cdRomIndex) {
                        virtioIndex++;
                    }
                }
                index = virtioIndex;
                break;
            case SPAPR_VSCSI:
            case VirtIO_SCSI:
                scsiIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (scsiIndex == payloadIndex || scsiIndex == cdRomIndex) {
                        scsiIndex++;
                    }
                }
                index = scsiIndex;
                break;
        }
        String dev = vmInfoBuildUtils.makeDiskName(dve.getDiskInterface().getName(), index);
        writeDisk(device, disk, dve, dev, pinTo);
    }
}
#end_block

#method_before
private void writeDiskDriver(VmDevice device, Disk disk, DiskVmElement dve) {
    writer.writeStartElement("driver");
    writer.writeAttributeString("name", "qemu");
    if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion()) && dve.isPassDiscard()) {
        writer.writeAttributeString("discard", "unmap");
    }
    if (device.getSpecParams().containsKey("pinToIoThread")) {
        writer.writeAttributeString("iothread", device.getSpecParams().get("pinToIoThread").toString());
    }
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            writer.writeAttributeString("io", "file".equals(diskType) ? "threads" : "native");
            writer.writeAttributeString("type", diskImage.getVolumeFormat() == VolumeFormat.COW ? "qcow2" : "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case LUN:
            writer.writeAttributeString("io", "native");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", "stop");
            writer.writeAttributeString("io", "threads");
            break;
    }
    if (device.getSnapshotId() != null) {
        // transient disk
        /**
         *            Force the cache to be writethrough, which is qemu's default.
         *            This is done to ensure that we don't ever use cache=none for
         *            transient disks, since we create them in /var/run/vdsm which
         *            may end up on tmpfs and don't support O_DIRECT, and qemu uses
         *            O_DIRECT when cache=none and hence hotplug might fail with
         *            error that one can take eternity to debug the reason behind it!
         */
        writer.writeAttributeString("cache", "writethrough");
    } else {
        switch(dve.getDiskInterface()) {
            case VirtIO:
            // TODO: if custom property is set...
            default:
                writer.writeAttributeString("cache", "none");
        }
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskDriver(VmDevice device, Disk disk, DiskVmElement dve, int pinTo) {
    writer.writeStartElement("driver");
    writer.writeAttributeString("name", "qemu");
    if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion()) && dve.isPassDiscard()) {
        writer.writeAttributeString("discard", "unmap");
    }
    if (pinTo > 0) {
        writer.writeAttributeString("iothread", String.valueOf(pinTo));
    }
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            writer.writeAttributeString("io", "file".equals(diskType) ? "threads" : "native");
            writer.writeAttributeString("type", diskImage.getVolumeFormat() == VolumeFormat.COW ? "qcow2" : "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case LUN:
            writer.writeAttributeString("io", "native");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", "stop");
            writer.writeAttributeString("io", "threads");
            break;
    }
    if (device.getSnapshotId() != null) {
        // transient disk
        /**
         *            Force the cache to be writethrough, which is qemu's default.
         *            This is done to ensure that we don't ever use cache=none for
         *            transient disks, since we create them in /var/run/vdsm which
         *            may end up on tmpfs and don't support O_DIRECT, and qemu uses
         *            O_DIRECT when cache=none and hence hotplug might fail with
         *            error that one can take eternity to debug the reason behind it!
         */
        writer.writeAttributeString("cache", "writethrough");
    } else {
        switch(dve.getDiskInterface()) {
            case VirtIO:
            // TODO: if custom property is set...
            default:
                writer.writeAttributeString("cache", "none");
        }
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskTarget(DiskVmElement dve, String dev) {
    writer.writeStartElement("target");
    switch(dve.getDiskInterface()) {
        case IDE:
            writer.writeAttributeString("dev", dev);
            writer.writeAttributeString("bus", "ide");
            break;
        case VirtIO:
            writer.writeAttributeString("dev", dev);
            writer.writeAttributeString("bus", "virtio");
            // TODO: index
            break;
        case VirtIO_SCSI:
            writer.writeAttributeString("dev", dev);
            writer.writeAttributeString("bus", "scsi");
            // TODO address
            break;
        case SPAPR_VSCSI:
            // TODO address, name
            break;
        default:
            log.error("Unsupported interface type, ISCSI interface type is not supported.");
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskTarget(DiskVmElement dve, String dev) {
    writer.writeStartElement("target");
    writer.writeAttributeString("dev", dev);
    writer.writeAttributeString("bus", dve.getDiskInterface().getName());
    writer.writeEndElement();
}
#end_block

#method_before
private void writeGeneralDiskAttributes(VmDevice device, Disk disk, DiskVmElement dve) {
    writer.writeAttributeString("snapshot", "no");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            writer.writeAttributeString("type", this.vmInfoBuildUtils.getDiskType(this.vm, (DiskImage) disk));
            break;
        case LUN:
            writer.writeAttributeString("type", "block");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("type", "network");
            break;
    }
    switch(dve.getDiskInterface()) {
        case VirtIO:
        case IDE:
            writer.writeAttributeString("device", device.getDevice());
            break;
        case VirtIO_SCSI:
            if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                writer.writeAttributeString("device", VmDeviceType.LUN.getName());
                writer.writeAttributeString("sgio", disk.getSgio().toString().toLowerCase());
            } else {
                writer.writeAttributeString("device", device.getDevice());
            }
            // TODO
            break;
        case SPAPR_VSCSI:
            break;
    }
}
#method_after
private void writeGeneralDiskAttributes(VmDevice device, Disk disk, DiskVmElement dve) {
    writer.writeAttributeString("snapshot", "no");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            writer.writeAttributeString("type", this.vmInfoBuildUtils.getDiskType(this.vm, (DiskImage) disk));
            break;
        case LUN:
            writer.writeAttributeString("type", "block");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("type", "network");
            break;
    }
    switch(dve.getDiskInterface()) {
        case VirtIO_SCSI:
            if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                writer.writeAttributeString("device", VmDeviceType.LUN.getName());
                writer.writeAttributeString("sgio", disk.getSgio().toString().toLowerCase());
                break;
            }
        default:
            writer.writeAttributeString("device", device.getDevice());
    }
}
#end_block

#method_before
private AbstractCheckboxColumn<RegisterVmData> createAllowPartialColumn() {
    final AbstractCheckboxColumn<RegisterVmData> allowPartialColumn = new AbstractCheckboxColumn<RegisterVmData>() {

        @Override
        public Boolean getValue(RegisterVmData registerVmData) {
            return registerVmData.getAllowPartialImport().getEntity();
        }

        @Override
        protected boolean canEdit(RegisterVmData registerVmData) {
            return true;
        }

        @Override
        public void render(Context context, RegisterVmData object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
        // sb.append(templates.textForCheckBox(constants.reassignBadMacs()));
        }
    };
    allowPartialColumn.setFieldUpdater((index, object, value) -> object.getAllowPartialImport().setEntity(value));
    return allowPartialColumn;
}
#method_after
private AbstractCheckboxColumn<RegisterVmData> createAllowPartialColumn() {
    final AbstractCheckboxColumn<RegisterVmData> allowPartialColumn = new AbstractCheckboxColumn<RegisterVmData>() {

        @Override
        public Boolean getValue(RegisterVmData registerVmData) {
            return registerVmData.getAllowPartialImport().getEntity();
        }

        @Override
        protected boolean canEdit(RegisterVmData registerVmData) {
            return true;
        }

        @Override
        public void render(Context context, RegisterVmData object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
        }
    };
    allowPartialColumn.setFieldUpdater((index, object, value) -> {
        object.getAllowPartialImport().setEntity(value);
        updateWarnings(value);
    });
    return allowPartialColumn;
}
#end_block

#method_before
private String getUnpluggedDisksNames() {
    ArrayList<Disk> unpluggedDisks = new ArrayList<>();
    for (Disk disk : getVmDisks()) {
        if (!disk.getPlugged()) {
            unpluggedDisks.add(disk);
        }
    }
    return VmModelHelper.getDiskLabelList(unpluggedDisks);
}
#method_after
private String getUnpluggedDisksNames() {
    List<Disk> unpluggedDisks = getVmDisks().stream().filter(disk -> !disk.getPlugged()).collect(Collectors.toList());
    return VmModelHelper.getDiskLabelList(unpluggedDisks);
}
#end_block

#method_before
private void updateVmActiveDisks() {
    VM vm = getEntity();
    if (vm == null) {
        return;
    }
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery<>(disks -> {
        getVmDisks().clear();
        for (Disk disk : disks) {
            if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                continue;
            }
            DiskImage diskImage = (DiskImage) disk;
            getVmDisks().add(diskImage);
        }
    }), vm.getId());
}
#method_after
private void updateVmActiveDisks() {
    VM vm = getEntity();
    if (vm == null) {
        return;
    }
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery<>(disks -> {
        setVmDisks(disks.stream().filter(d -> d.getDiskStorageType() != DiskStorageType.LUN).map(d -> (DiskImage) d).collect(Collectors.toList()));
    }), vm.getId());
}
#end_block

#method_before
private void updatePreviewedDiskSnapshots(final List<Snapshot> snapshots) {
    for (DiskImage diskImage : getVmDisks()) {
        if (diskImage.getSnapshots().size() <= 1) {
            continue;
        }
        Guid snapshotId = diskImage.getSnapshots().get(1).getVmSnapshotId();
        getSnapshotsMap().get(snapshotId).getEntity().getDiskImages().add(diskImage);
    }
    updateItems(snapshots);
}
#method_after
private void updatePreviewedDiskSnapshots(final List<Snapshot> snapshots) {
    getVmDisks().stream().filter(d -> d.getSnapshots().size() > 1).forEach(d -> getSnapshotsMap().get(d.getSnapshots().get(1).getVmSnapshotId()).getEntity().getDiskImages().add(d));
    updateItems(snapshots);
}
#end_block

#method_before
private void onPreview() {
    Snapshot snapshot = getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    VM vm = getEntity();
    SnapshotModel snapshotModel = (SnapshotModel) getWindow();
    boolean memory = false;
    List<DiskImage> disks = null;
    if (snapshotModel.isShowPartialSnapshotWarning()) {
        switch(snapshotModel.getPartialPreviewSnapshotOptions().getSelectedItem()) {
            case preserveActiveDisks:
                // get snapshot disks
                disks = snapshotModel.getDisks();
                // add active disks missed from snapshot
                disks.addAll(imagesSubtract(getVmDisks(), disks));
                break;
            case excludeActiveDisks:
                // nothing to do - default behaviour
                break;
            case openCustomPreviewDialog:
                setWindow(null);
                getCustomPreviewCommand().execute();
                return;
        }
    }
    if (snapshotModel.isShowMemorySnapshotWarning()) {
        memory = snapshotModel.getMemory().getEntity();
    }
    runTryBackToAllSnapshotsOfVm(snapshotModel, vm, snapshot, memory, disks, true, null);
}
#method_after
private void onPreview() {
    Snapshot snapshot = getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    VM vm = getEntity();
    SnapshotModel snapshotModel = (SnapshotModel) getWindow();
    boolean memory = false;
    List<DiskImage> disks;
    Set<Guid> diskImageIds = null;
    if (snapshotModel.isShowPartialSnapshotWarning()) {
        switch(snapshotModel.getPartialPreviewSnapshotOptions().getSelectedItem()) {
            case preserveActiveDisks:
                // get snapshot disks
                disks = snapshotModel.getDisks();
                // add active disks missed from snapshot
                disks.addAll(imagesSubtract(getVmDisks(), disks));
                diskImageIds = disks.stream().map(DiskImage::getImageId).collect(Collectors.toSet());
                break;
            case excludeActiveDisks:
                // nothing to do - default behaviour
                break;
            case openCustomPreviewDialog:
                setWindow(null);
                getCustomPreviewCommand().execute();
                return;
        }
    }
    if (snapshotModel.isShowMemorySnapshotWarning()) {
        memory = snapshotModel.getMemory().getEntity();
    }
    runTryBackToAllSnapshotsOfVm(snapshotModel, vm, snapshot, memory, diskImageIds, true, null);
}
#end_block

#method_before
private void onCustomPreview() {
    VM vm = getEntity();
    PreviewSnapshotModel previewSnapshotModel = (PreviewSnapshotModel) getWindow();
    Snapshot snapshot = previewSnapshotModel.getSnapshotModel().getEntity();
    boolean memory = Boolean.TRUE.equals(previewSnapshotModel.getSnapshotModel().getMemory().getEntity());
    List<DiskImage> disks = previewSnapshotModel.getSelectedDisks();
    Pair<Boolean, Guid> isLeaseShouldRestoreAndLeaseDomainId = previewSnapshotModel.getSelectedLease();
    runTryBackToAllSnapshotsOfVm(previewSnapshotModel, vm, snapshot, memory, disks, isLeaseShouldRestoreAndLeaseDomainId.getFirst(), isLeaseShouldRestoreAndLeaseDomainId.getSecond());
}
#method_after
private void onCustomPreview() {
    VM vm = getEntity();
    PreviewSnapshotModel previewSnapshotModel = (PreviewSnapshotModel) getWindow();
    Snapshot snapshot = previewSnapshotModel.getSnapshotModel().getEntity();
    boolean memory = Boolean.TRUE.equals(previewSnapshotModel.getSnapshotModel().getMemory().getEntity());
    List<DiskImage> disks = previewSnapshotModel.getSelectedDisks();
    boolean isSnapshotsContainsLeases = previewSnapshotModel.isSnapshotsContainsLeases();
    Guid selectedSnapshotLeaseDomainId = previewSnapshotModel.getSelectedLease();
    Set<Guid> diskIds = disks.stream().map(DiskImage::getImageId).collect(Collectors.toSet());
    runTryBackToAllSnapshotsOfVm(previewSnapshotModel, vm, snapshot, memory, diskIds, !(isSnapshotsContainsLeases && selectedSnapshotLeaseDomainId == null), selectedSnapshotLeaseDomainId);
}
#end_block

#method_before
private void runTryBackToAllSnapshotsOfVm(final Model model, VM vm, Snapshot snapshot, boolean memory, List<DiskImage> disks, boolean isRestoreLease, Guid leaseDomainId) {
    if (model != null) {
        model.startProgress();
    }
    TryBackToAllSnapshotsOfVmParameters params = new TryBackToAllSnapshotsOfVmParameters(vm.getId(), snapshot.getId(), memory, disks);
    if (leaseDomainId != null) {
        params.setDstLeaseDomainId(leaseDomainId);
    }
    params.setRestoreLease(isRestoreLease);
    Frontend.getInstance().runAction(ActionType.TryBackToAllSnapshotsOfVm, params, result -> {
        if (model != null) {
            model.stopProgress();
        }
        if (result.getReturnValue().getSucceeded()) {
            cancel();
        }
    });
}
#method_after
private void runTryBackToAllSnapshotsOfVm(final Model model, VM vm, Snapshot snapshot, boolean memory, Set<Guid> diskIds, boolean isRestoreLease, Guid leaseDomainId) {
    if (model != null) {
        model.startProgress();
    }
    TryBackToAllSnapshotsOfVmParameters params = new TryBackToAllSnapshotsOfVmParameters(vm.getId(), snapshot.getId(), memory, diskIds);
    if (leaseDomainId != null) {
        params.setDstLeaseDomainId(leaseDomainId);
    }
    params.setRestoreLease(isRestoreLease);
    Frontend.getInstance().runAction(ActionType.TryBackToAllSnapshotsOfVm, params, result -> {
        if (model != null) {
            model.stopProgress();
        }
        if (result.getReturnValue().getSucceeded()) {
            cancel();
        }
    });
}
#end_block

#method_before
private void onCloneTemplate() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    NewTemplateVmModelBehavior behavior = (NewTemplateVmModelBehavior) model.getBehavior();
    Snapshot snapshot = getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    final VM vm = behavior.getVm();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(vm);
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery<>(isNameUnique -> {
            if (!isNameUnique) {
                model.getInvalidityReasons().clear();
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setIsValid(false);
                model.fireValidationCompleteEvent();
            } else {
                postNameUniqueCheck(vm);
            }
        }), name, model.getSelectedDataCenter().getId());
    }
}
#method_after
private void onCloneTemplate() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    NewTemplateVmModelBehavior behavior = (NewTemplateVmModelBehavior) model.getBehavior();
    Snapshot snapshot = getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    final VM vm = behavior.getVm();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(vm);
    } else {
        String name = model.getName().getEntity();
        // Check name uniqueness.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery<>(isNameUnique -> {
            if (!isNameUnique) {
                model.getInvalidityReasons().clear();
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setIsValid(false);
                model.fireValidationCompleteEvent();
            } else {
                postNameUniqueCheck(vm);
            }
        }), name, model.getSelectedDataCenter().getId());
    }
}
#end_block

#method_before
private void createPreviewTable() {
    previewTable.addColumn(new AbstractFullDateTimeColumn<SnapshotModel>() {

        @Override
        protected Date getRawValue(SnapshotModel snapshotModel) {
            return snapshotModel.getEntity().getCreationDate();
        }
    }, constants.dateSnapshot(), // $NON-NLS-1$
    "140px");
    previewTable.addColumn(new AbstractTextColumn<SnapshotModel>() {

        @Override
        public String getValue(SnapshotModel snapshotModel) {
            return snapshotModel.getEntity().getDescription();
        }
    }, constants.descriptionSnapshot(), // $NON-NLS-1$
    "100px");
    previewTable.setSelectionModel(new NoSelectionModel());
    Column<SnapshotModel, Boolean> vmConfColumn = new Column<SnapshotModel, Boolean>(new RadioboxCell()) {

        @Override
        public Boolean getValue(SnapshotModel model) {
            Snapshot snapshotVmConf = model.getEntity();
            Snapshot toPreviewVmConf = previewSnapshotModel.getSnapshotModel().getEntity();
            if (snapshotVmConf == null && toPreviewVmConf == null) {
                return true;
            }
            return snapshotVmConf != null && snapshotVmConf.equals(toPreviewVmConf);
        }

        @Override
        public void render(Context context, SnapshotModel snapshotModel, SafeHtmlBuilder sb) {
            if (!snapshotModel.getEntity().isVmConfigurationBroken()) {
                super.render(context, snapshotModel, sb);
            } else {
                sb.appendEscaped(constants.notAvailableLabel());
            }
        }
    };
    vmConfColumn.setFieldUpdater((index, snapshotModel, value) -> {
        previewSnapshotModel.setSnapshotModel(snapshotModel);
        previewSnapshotModel.clearMemorySelection();
        updateWarnings();
        refreshTable(previewTable);
        if (snapshotModel.getVm() == null) {
            snapshotModel.updateVmConfiguration(returnValue -> updateInfoPanel());
        } else {
            updateInfoPanel();
        }
    });
    previewTable.addColumn(vmConfColumn, new ImageResourceHeader(resources.vmConfIcon(), SafeHtmlUtils.fromTrustedString(constants.vmConfiguration())), // $NON-NLS-1$
    "30px");
    AbstractCheckboxColumn<SnapshotModel> memoryColumn = new AbstractCheckboxColumn<SnapshotModel>((index, snapshotModel, value) -> {
        previewSnapshotModel.getSnapshotModel().getMemory().setEntity(value);
        refreshTable(previewTable);
        updateWarnings();
    }) {

        @Override
        public Boolean getValue(SnapshotModel snapshotModel) {
            return snapshotModel.getMemory().getEntity();
        }

        @Override
        protected boolean canEdit(SnapshotModel snapshotModel) {
            boolean containsMemory = !snapshotModel.getEntity().getMemoryVolume().isEmpty();
            SnapshotModel selectedSnapshotModel = previewSnapshotModel.getSnapshotModel();
            return containsMemory && snapshotModel == selectedSnapshotModel;
        }

        @Override
        public void render(Context context, SnapshotModel snapshotModel, SafeHtmlBuilder sb) {
            if (!snapshotModel.getEntity().getMemoryVolume().isEmpty()) {
                super.render(context, snapshotModel, sb);
            } else {
                sb.appendEscaped(constants.notAvailableLabel());
            }
        }
    };
    previewTable.addColumn(memoryColumn, templates.iconWithText(imageResourceToSafeHtml(resources.memorySmallIcon()), constants.memorySnapshot()), // $NON-NLS-1$
    "100px");
    AbstractCheckboxColumn<SnapshotModel> vmLeaseColumn = new AbstractCheckboxColumn<SnapshotModel>((index, snapshotModel, value) -> {
        snapshotModel.getLease().setEntity(value);
        refreshTable(previewTable);
        updateWarnings();
    }) {

        @Override
        public Boolean getValue(SnapshotModel model) {
            if (model.getLease() != null) {
                return model.getLease().getEntity();
            }
            return false;
        }

        @Override
        protected boolean canEdit(SnapshotModel snapshotModel) {
            // prevent from selecting both leases in case both snapshot have a lease
            if (snapshotModel.getLease() != null) {
                SnapshotModel result = previewSnapshotModel.getSnapshots().getItems().stream().filter(model -> model.getEntity().getId() != snapshotModel.getEntity().getId()).filter(model -> model.getLease() != null).filter(model -> model.getLease().getEntity()).findFirst().orElse(null);
                return result == null;
            }
            return false;
        }

        @Override
        public void render(Context context, SnapshotModel snapshotModel, SafeHtmlBuilder sb) {
            if (snapshotModel.getLease() != null) {
                super.render(context, snapshotModel, sb);
            } else {
                sb.appendEscaped(constants.notAvailableLabel());
            }
        }
    };
    // $NON-NLS-1$
    previewTable.addColumn(vmLeaseColumn, constants.leaseSnapshot(), "80px");
    List<DiskImage> disks = previewSnapshotModel.getAllDisks();
    Collections.sort(disks, new DiskByDiskAliasComparator());
    for (final DiskImage disk : disks) {
        previewTable.addColumn(new AbstractCheckboxColumn<SnapshotModel>((index, snapshotModel, value) -> {
            ListModel diskListModel = previewSnapshotModel.getDiskSnapshotsMap().get(disk.getId());
            DiskImage image = snapshotModel.getImageByDiskId(disk.getId());
            diskListModel.setSelectedItem(Boolean.TRUE.equals(value) ? image : null);
            refreshTable(previewTable);
            updateWarnings();
            updateInfoPanel();
        }) {

            @Override
            public Boolean getValue(SnapshotModel snapshotModel) {
                ListModel diskListModel = previewSnapshotModel.getDiskSnapshotsMap().get(disk.getId());
                DiskImage image = snapshotModel.getImageByDiskId(disk.getId());
                return image != null ? image.equals(diskListModel.getSelectedItem()) : false;
            }

            @Override
            protected boolean canEdit(SnapshotModel model) {
                return true;
            }

            @Override
            public void render(Context context, SnapshotModel snapshotModel, SafeHtmlBuilder sb) {
                DiskImage image = snapshotModel.getImageByDiskId(disk.getId());
                if (image == null) {
                    sb.appendEscaped(constants.notAvailableLabel());
                } else if (image.getImageStatus() == ImageStatus.ILLEGAL) {
                    sb.append(templates.text(constants.notAvailableLabel()));
                } else {
                    super.render(context, snapshotModel, sb);
                }
            }

            @Override
            public SafeHtml getTooltip(SnapshotModel model) {
                if (disk != null && disk.getId() != null) {
                    DiskImage image = model.getImageByDiskId(disk.getId());
                    if (image != null && image.getImageStatus() == ImageStatus.ILLEGAL) {
                        return SafeHtmlUtils.fromSafeConstant(constants.illegalStatus());
                    }
                }
                return null;
            }
        }, new SafeHtmlHeader(templates.iconWithText(imageResourceToSafeHtml(resources.diskIcon()), disk.getDiskAlias()), SafeHtmlUtils.fromString(disk.getId().toString())), // $NON-NLS-1$
        "120px");
        // Edit preview table
        previewTable.asEditor().edit(previewSnapshotModel.getSnapshots());
    }
    previewTable.addCellPreviewHandler(new CellPreviewEvent.Handler<EntityModel>() {

        long lastClick = -1000;

        @Override
        public void onCellPreview(CellPreviewEvent<EntityModel> event) {
            NativeEvent nativeEvent = event.getNativeEvent();
            long clickAt = System.currentTimeMillis();
            if (BrowserEvents.CLICK.equals(nativeEvent.getType())) {
                if (clickAt - lastClick < 300) {
                    // double click: 2 clicks detected within 300 ms
                    SnapshotModel selectedSnapshotModel = (SnapshotModel) event.getValue();
                    if (!selectedSnapshotModel.getEntity().isVmConfigurationBroken()) {
                        previewSnapshotModel.clearSelection(selectedSnapshotModel.getEntity().getId());
                        previewSnapshotModel.selectSnapshot(selectedSnapshotModel.getEntity().getId());
                        updateWarnings();
                        refreshTable(previewTable);
                    }
                }
                lastClick = System.currentTimeMillis();
            }
        }
    });
}
#method_after
private void createPreviewTable() {
    previewTable.addColumn(new AbstractFullDateTimeColumn<SnapshotModel>() {

        @Override
        protected Date getRawValue(SnapshotModel snapshotModel) {
            return snapshotModel.getEntity().getCreationDate();
        }
    }, constants.dateSnapshot(), // $NON-NLS-1$
    "140px");
    previewTable.addColumn(new AbstractTextColumn<SnapshotModel>() {

        @Override
        public String getValue(SnapshotModel snapshotModel) {
            return snapshotModel.getEntity().getDescription();
        }
    }, constants.descriptionSnapshot(), // $NON-NLS-1$
    "100px");
    previewTable.setSelectionModel(new NoSelectionModel());
    Column<SnapshotModel, Boolean> vmConfColumn = new Column<SnapshotModel, Boolean>(new RadioboxCell()) {

        @Override
        public Boolean getValue(SnapshotModel model) {
            Snapshot snapshotVmConf = model.getEntity();
            Snapshot toPreviewVmConf = previewSnapshotModel.getSnapshotModel().getEntity();
            if (snapshotVmConf == null && toPreviewVmConf == null) {
                return true;
            }
            return snapshotVmConf != null && snapshotVmConf.equals(toPreviewVmConf);
        }

        @Override
        public void render(Context context, SnapshotModel snapshotModel, SafeHtmlBuilder sb) {
            if (!snapshotModel.getEntity().isVmConfigurationBroken()) {
                super.render(context, snapshotModel, sb);
            } else {
                sb.appendEscaped(constants.notAvailableLabel());
            }
        }
    };
    vmConfColumn.setFieldUpdater((index, snapshotModel, value) -> {
        previewSnapshotModel.setSnapshotModel(snapshotModel);
        previewSnapshotModel.clearMemorySelection();
        updateWarnings();
        refreshTable(previewTable);
        if (snapshotModel.getVm() == null) {
            snapshotModel.updateVmConfiguration(returnValue -> updateInfoPanel());
        } else {
            updateInfoPanel();
        }
    });
    previewTable.addColumn(vmConfColumn, new ImageResourceHeader(resources.vmConfIcon(), SafeHtmlUtils.fromTrustedString(constants.vmConfiguration())), // $NON-NLS-1$
    "30px");
    AbstractCheckboxColumn<SnapshotModel> memoryColumn = new AbstractCheckboxColumn<SnapshotModel>((index, snapshotModel, value) -> {
        previewSnapshotModel.getSnapshotModel().getMemory().setEntity(value);
        refreshTable(previewTable);
        updateWarnings();
    }) {

        @Override
        public Boolean getValue(SnapshotModel snapshotModel) {
            return snapshotModel.getMemory().getEntity();
        }

        @Override
        protected boolean canEdit(SnapshotModel snapshotModel) {
            boolean containsMemory = !snapshotModel.getEntity().getMemoryVolume().isEmpty();
            SnapshotModel selectedSnapshotModel = previewSnapshotModel.getSnapshotModel();
            return containsMemory && snapshotModel == selectedSnapshotModel;
        }

        @Override
        public void render(Context context, SnapshotModel snapshotModel, SafeHtmlBuilder sb) {
            if (!snapshotModel.getEntity().getMemoryVolume().isEmpty()) {
                super.render(context, snapshotModel, sb);
            } else {
                sb.appendEscaped(constants.notAvailableLabel());
            }
        }
    };
    previewTable.addColumn(memoryColumn, templates.iconWithText(imageResourceToSafeHtml(resources.memorySmallIcon()), constants.memorySnapshot()), // $NON-NLS-1$
    "100px");
    AbstractCheckboxColumn<SnapshotModel> vmLeaseColumn = new AbstractCheckboxColumn<SnapshotModel>((index, snapshotModel, value) -> {
        snapshotModel.getLeaseExists().setEntity(value);
        refreshTable(previewTable);
        updateWarnings();
    }) {

        @Override
        public Boolean getValue(SnapshotModel model) {
            if (model.getLeaseExists() != null) {
                return model.getLeaseExists().getEntity();
            }
            return false;
        }

        @Override
        protected boolean canEdit(SnapshotModel snapshotModel) {
            // prevent from selecting more then one leases in case many snapshots have leases
            if (snapshotModel.getLeaseExists() != null) {
                SnapshotModel result = previewSnapshotModel.getSnapshots().getItems().stream().filter(model -> model.getEntity().getId() != snapshotModel.getEntity().getId()).filter(model -> model.getLeaseExists().getEntity() != null).filter(model -> model.getLeaseExists().getEntity()).findFirst().orElse(null);
                return result == null;
            }
            return false;
        }

        @Override
        public void render(Context context, SnapshotModel snapshotModel, SafeHtmlBuilder sb) {
            if (snapshotModel.getLeaseExists().getEntity() != null) {
                super.render(context, snapshotModel, sb);
            } else {
                sb.appendEscaped(constants.notAvailableLabel());
            }
        }
    };
    // $NON-NLS-1$
    previewTable.addColumn(vmLeaseColumn, constants.leaseSnapshot(), "80px");
    List<DiskImage> disks = previewSnapshotModel.getAllDisks();
    Collections.sort(disks, new DiskByDiskAliasComparator());
    for (final DiskImage disk : disks) {
        previewTable.addColumn(new AbstractCheckboxColumn<SnapshotModel>((index, snapshotModel, value) -> {
            ListModel diskListModel = previewSnapshotModel.getDiskSnapshotsMap().get(disk.getId());
            DiskImage image = snapshotModel.getImageByDiskId(disk.getId());
            diskListModel.setSelectedItem(Boolean.TRUE.equals(value) ? image : null);
            refreshTable(previewTable);
            updateWarnings();
            updateInfoPanel();
        }) {

            @Override
            public Boolean getValue(SnapshotModel snapshotModel) {
                ListModel diskListModel = previewSnapshotModel.getDiskSnapshotsMap().get(disk.getId());
                DiskImage image = snapshotModel.getImageByDiskId(disk.getId());
                return image != null ? image.equals(diskListModel.getSelectedItem()) : false;
            }

            @Override
            protected boolean canEdit(SnapshotModel model) {
                return true;
            }

            @Override
            public void render(Context context, SnapshotModel snapshotModel, SafeHtmlBuilder sb) {
                DiskImage image = snapshotModel.getImageByDiskId(disk.getId());
                if (image == null) {
                    sb.appendEscaped(constants.notAvailableLabel());
                } else if (image.getImageStatus() == ImageStatus.ILLEGAL) {
                    sb.append(templates.text(constants.notAvailableLabel()));
                } else {
                    super.render(context, snapshotModel, sb);
                }
            }

            @Override
            public SafeHtml getTooltip(SnapshotModel model) {
                if (disk != null && disk.getId() != null) {
                    DiskImage image = model.getImageByDiskId(disk.getId());
                    if (image != null && image.getImageStatus() == ImageStatus.ILLEGAL) {
                        return SafeHtmlUtils.fromSafeConstant(constants.illegalStatus());
                    }
                }
                return null;
            }
        }, new SafeHtmlHeader(templates.iconWithText(imageResourceToSafeHtml(resources.diskIcon()), disk.getDiskAlias()), SafeHtmlUtils.fromString(disk.getId().toString())), // $NON-NLS-1$
        "120px");
        // Edit preview table
        previewTable.asEditor().edit(previewSnapshotModel.getSnapshots());
    }
    previewTable.addCellPreviewHandler(new CellPreviewEvent.Handler<EntityModel>() {

        long lastClick = -1000;

        @Override
        public void onCellPreview(CellPreviewEvent<EntityModel> event) {
            NativeEvent nativeEvent = event.getNativeEvent();
            long clickAt = System.currentTimeMillis();
            if (BrowserEvents.CLICK.equals(nativeEvent.getType())) {
                if (clickAt - lastClick < 300) {
                    // double click: 2 clicks detected within 300 ms
                    SnapshotModel selectedSnapshotModel = (SnapshotModel) event.getValue();
                    if (!selectedSnapshotModel.getEntity().isVmConfigurationBroken()) {
                        previewSnapshotModel.clearSelection(selectedSnapshotModel.getEntity().getId());
                        previewSnapshotModel.selectSnapshot(selectedSnapshotModel.getEntity().getId());
                        updateWarnings();
                        refreshTable(previewTable);
                    }
                }
                lastClick = System.currentTimeMillis();
            }
        }
    });
}
#end_block

#method_before
@Override
public void initialize() {
    List<QueryType> queries = new ArrayList<>();
    List<QueryParametersBase> params = new ArrayList<>();
    queries.add(QueryType.GetAllVmSnapshotsFromConfigurationByVmId);
    params.add(new IdQueryParameters(vmId));
    queries.add(QueryType.GetVmConfigurationBySnapshot);
    params.add(new IdQueryParameters(userSelectedSnapshotId));
    Frontend.getInstance().runMultipleQueries(queries, params, result -> {
        if (result != null) {
            for (int i = 0; i < result.getReturnValues().size(); i++) {
                if (result.getReturnValues().get(i) != null && result.getReturnValues().get(i).getSucceeded() && !(result.getReturnValues().get(i).getReturnValue() instanceof VM)) {
                    ArrayList<SnapshotModel> snapshotModels = new ArrayList<>();
                    ArrayList<Snapshot> snapshots = result.getReturnValues().get(i).getReturnValue();
                    sortSnapshots(snapshots);
                    for (Snapshot snapshot : snapshots) {
                        SnapshotModel snapshotModel = new SnapshotModel();
                        snapshotModel.setEntity(snapshot);
                        snapshotModel.getMemory().setEntity(false);
                        snapshotModel.setDisks((ArrayList<DiskImage>) snapshot.getDiskImages());
                        snapshotModels.add(snapshotModel);
                        if (snapshot.getType() == Snapshot.SnapshotType.ACTIVE) {
                            activeSnapshotId = snapshot.getId();
                            if (vm.getLeaseStorageDomainId() != null) {
                                snapshotModel.getLease().setEntity(false);
                                getSnapshotLeaseDomainsMap().put(activeSnapshotId, vm.getLeaseStorageDomainId());
                            } else {
                                snapshotModel.setLease(null);
                                getSnapshotLeaseDomainsMap().put(activeSnapshotId, null);
                            }
                        }
                    }
                    getSnapshots().setItems(snapshotModels);
                    updateDiskSnapshotsMap();
                    // Update disk-snapshots map
                    updateDiskSnapshotsMap();
                    // First selecting the active snapshot for ensuring default disks selection
                    // (i.e. when some disks are missing from the selected snapshot,
                    // the corresponding disks from the active snapshot should be selected).
                    selectSnapshot(activeSnapshotId);
                    // Selecting the snapshot the was selected by the user
                    selectSnapshot(userSelectedSnapshotId);
                }
            }
            for (int i = 0; i < result.getReturnValues().size(); i++) {
                if (result.getReturnValues().get(i).getReturnValue() instanceof VM) {
                    VM vm = result.getReturnValues().get(i).getReturnValue();
                    SnapshotModel snapshotModel = getSnapshotModelById(userSelectedSnapshotId);
                    if (vm.getLeaseStorageDomainId() != null) {
                        snapshotModel.getLease().setEntity(true);
                        getSnapshotLeaseDomainsMap().put(userSelectedSnapshotId, vm.getLeaseStorageDomainId());
                    } else {
                        snapshotModel.setLease(null);
                        getSnapshotLeaseDomainsMap().put(userSelectedSnapshotId, null);
                    }
                }
            }
        }
    });
}
#method_after
@Override
public void initialize() {
    Frontend.getInstance().runQuery(QueryType.GetAllVmSnapshotsWithLeasesFromConfigurationByVmId, new IdQueryParameters(vmId), new AsyncQuery<QueryReturnValue>(response -> {
        if (response != null && response.getSucceeded()) {
            ArrayList<SnapshotModel> snapshotModels = new ArrayList<>();
            Map<Snapshot, Guid> snapshotLeaseStorageDomaindIdMap = response.getReturnValue();
            List<Snapshot> snapshots = new ArrayList<>(snapshotLeaseStorageDomaindIdMap.keySet());
            sortSnapshots(snapshots);
            Guid userSelectedSnapshotId = getSnapshotModel().getEntity().getId();
            for (Snapshot snapshot : snapshots) {
                Guid leaseStorageDomainId = snapshotLeaseStorageDomaindIdMap.get(snapshot);
                SnapshotModel snapshotModel = new SnapshotModel();
                snapshotModel.setEntity(snapshot);
                snapshotModel.getMemory().setEntity(false);
                snapshotModel.setDisks((ArrayList<DiskImage>) snapshot.getDiskImages());
                snapshotModels.add(snapshotModel);
                if (snapshot.getType() == Snapshot.SnapshotType.ACTIVE) {
                    activeSnapshotId = snapshot.getId();
                }
                if (leaseStorageDomainId != null) {
                    snapshotModel.getLeaseExists().setEntity(snapshot.getId() != activeSnapshotId);
                    getSnapshotLeaseDomainsMap().put(snapshot.getId(), leaseStorageDomainId);
                } else {
                    snapshotModel.getLeaseExists().setEntity(null);
                    getSnapshotLeaseDomainsMap().put(snapshot.getId(), null);
                }
            }
            getSnapshots().setItems(snapshotModels);
            updateDiskSnapshotsMap();
            // Update disk-snapshots map
            updateDiskSnapshotsMap();
            // First selecting the active snapshot for ensuring default disks selection
            // (i.e. when some disks are missing from the selected snapshot,
            // the corresponding disks from the active snapshot should be selected).
            selectSnapshot(activeSnapshotId);
            // Selecting the snapshot the was selected by the user
            selectSnapshot(userSelectedSnapshotId);
        }
    }));
}
#end_block

#method_before
private void sortSnapshots(ArrayList<Snapshot> snapshots) {
    Collections.sort(snapshots, Comparator.comparing((Snapshot s) -> s.getType() == Snapshot.SnapshotType.ACTIVE).reversed().thenComparing(Linq.SnapshotByCreationDateCommparer));
}
#method_after
private void sortSnapshots(List<Snapshot> snapshots) {
    Collections.sort(snapshots, Comparator.comparing((Snapshot s) -> s.getType() == Snapshot.SnapshotType.ACTIVE).reversed().thenComparing(Linq.SnapshotByCreationDateCommparer));
}
#end_block

#method_before
public Pair<Boolean, Guid> getSelectedLease() {
    boolean haveLeases = getSnapshots().getItems().stream().anyMatch(model -> model.getLease() != null);
    SnapshotModel selectedLeaseSnapshotModel = getSnapshots().getItems().stream().filter(model -> model.getLease() != null).filter(model -> model.getLease().getEntity()).findFirst().orElse(null);
    if (selectedLeaseSnapshotModel == null && haveLeases) {
        // one or both of the snapshots have leases but they was ignored
        return new Pair<>(false, null);
    }
    // the snapshots don't contains leases or,one of the leases domain selected
    return selectedLeaseSnapshotModel == null ? new Pair<>(true, null) : new Pair<>(true, getSnapshotLeaseDomainsMap().get(selectedLeaseSnapshotModel.getEntity().getId()));
}
#method_after
public Guid getSelectedLease() {
    SnapshotModel selectedLeaseSnapshotModel = getSnapshots().getItems().stream().filter(model -> model.getLeaseExists().getEntity() != null).filter(model -> model.getLeaseExists().getEntity()).findFirst().orElse(null);
    return selectedLeaseSnapshotModel != null ? getSnapshotLeaseDomainsMap().get(selectedLeaseSnapshotModel.getEntity().getId()) : null;
}
#end_block

#method_before
public void clearLeaseSelection(Guid selectedSnapshotModel) {
    for (SnapshotModel snapshotModel : getSnapshots().getItems()) {
        if (!selectedSnapshotModel.equals(snapshotModel.getEntity().getId()) && snapshotModel.getLease() != null) {
            snapshotModel.getLease().setEntity(false);
        }
    }
}
#method_after
public void clearLeaseSelection(Guid selectedSnapshotModel) {
    for (SnapshotModel snapshotModel : getSnapshots().getItems()) {
        if (!selectedSnapshotModel.equals(snapshotModel.getEntity().getId()) && snapshotModel.getLeaseExists().getEntity() != null) {
            snapshotModel.getLeaseExists().setEntity(false);
        }
    }
}
#end_block

#method_before
public void selectSnapshot(Guid id) {
    SnapshotModel snapshotModel = getSnapshotModelById(id);
    if (snapshotModel == null) {
        return;
    }
    for (SnapshotModel model : getSnapshots().getItems()) {
        if (model.getEntity().getId() == id && model.getLease() != null) {
            model.getLease().setEntity(true);
        } else if (model.getLease() != null) {
            model.getLease().setEntity(false);
        }
    }
    getSnapshots().setSelectedItem(snapshotModel);
    setSnapshotModel(snapshotModel);
    for (DiskImage diskImage : snapshotModel.getDisks()) {
        ListModel diskListModel = diskSnapshotsMap.get(diskImage.getId());
        diskListModel.setSelectedItem(diskImage);
    }
}
#method_after
public void selectSnapshot(Guid id) {
    SnapshotModel snapshotModel = getSnapshotModelById(id);
    if (snapshotModel == null) {
        return;
    }
    for (SnapshotModel model : getSnapshots().getItems()) {
        if (model.getEntity().getId().equals(id) && model.getLeaseExists().getEntity() != null) {
            model.getLeaseExists().setEntity(true);
        } else if (model.getLeaseExists().getEntity() != null) {
            model.getLeaseExists().setEntity(false);
        }
    }
    getSnapshots().setSelectedItem(snapshotModel);
    setSnapshotModel(snapshotModel);
    for (DiskImage diskImage : snapshotModel.getDisks()) {
        ListModel diskListModel = diskSnapshotsMap.get(diskImage.getId());
        diskListModel.setSelectedItem(diskImage);
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    Snapshot previouslyActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED);
    snapshotDao.remove(previouslyActiveSnapshot.getId());
    snapshotDao.remove(snapshotDao.getId(getVmId(), SnapshotType.ACTIVE));
    getSnapshotsManager().addActiveSnapshot(previouslyActiveSnapshot.getId(), getVm(), previouslyActiveSnapshot.getMemoryVolume(), getCompensationContext());
    super.endWithFailure();
}
#method_after
@Override
protected void endWithFailure() {
    Snapshot previouslyActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED);
    snapshotDao.remove(previouslyActiveSnapshot.getId());
    snapshotDao.remove(snapshotDao.getId(getVmId(), SnapshotType.ACTIVE));
    getSnapshotsManager().addActiveSnapshot(previouslyActiveSnapshot.getId(), getVm(), SnapshotStatus.OK, previouslyActiveSnapshot.getMemoryVolume(), getCompensationContext());
    super.endWithFailure();
}
#end_block

#method_before
private void restoreVmConfigFromSnapshot() {
    snapshotDao.updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    snapshotDao.updateStatus(snapshotDao.getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    getSnapshotsManager().attempToRestoreVmConfigurationFromSnapshot(getVm(), getDstSnapshot(), snapshotDao.getId(getVm().getId(), SnapshotType.ACTIVE), getImagesToPreview(), getCompensationContext(), getCurrentUser(), new VmInterfaceManager(getMacPool()), isRestoreMemory(), isLeaseInfoUpdateNeeded());
}
#method_after
private void restoreVmConfigFromSnapshot() {
    snapshotDao.updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    snapshotDao.updateStatus(snapshotDao.getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    Guid activeSnapshotLeaseDomainId = null;
    if (isLeaseDomainIdUpdateNeeded()) {
        activeSnapshotLeaseDomainId = getVm().getStaticData().getLeaseStorageDomainId();
    }
    getSnapshotsManager().attempToRestoreVmConfigurationFromSnapshot(getVm(), getDstSnapshot(), snapshotDao.getId(getVm().getId(), SnapshotType.ACTIVE), getImagesToPreview(), getCompensationContext(), getCurrentUser(), new VmInterfaceManager(getMacPool()), isRestoreMemory());
    // custom preview - without leases
    if (!isRestoreLease()) {
        vmStaticDao.updateVmLeaseStorageDomainId(getVm().getId(), null);
        return;
    }
    Guid dstLeaseStorageDomainId = OvfUtils.fetchLeaseDomainId(getDstSnapshot().getVmConfiguration());
    if (isLeaseDomainIdUpdateNeeded()) {
        // previewed snapshot and active have leases on different domains, use the active snapshot lease
        vmStaticDao.updateVmLeaseStorageDomainId(getVm().getId(), activeSnapshotLeaseDomainId);
    } else if (getParameters().getDstLeaseDomainId() != null && !getParameters().getDstLeaseDomainId().equals(dstLeaseStorageDomainId)) {
        // custom preview - use the other snapshot lease.
        // if the given destination lease domain ID is not equals to the previewed snapshot lease domain ID
        // it means that the preview uses other lease domain ID that should set instead of the previewed snapshot
        // lease domain ID
        vmStaticDao.updateVmLeaseStorageDomainId(getVm().getId(), getParameters().getDstLeaseDomainId());
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = isRestoreMemory();
    final boolean restoreLease = isRestoreLease();
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    if (log.isInfoEnabled()) {
        log.info("Previewing snapshot {} with the disks:\n{}", getSnapshotName(), filteredImages.stream().map(disk -> String.format("%s (%s) to imageId %s", disk.getName(), disk.getId().toString(), disk.getImageId().toString())).collect(Collectors.joining("\n")));
    }
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        snapshotDao.remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, snapshotToBePreviewed.getCreationDate(), images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    if (restoreLease) {
        // in order to use again in endSuccessfully
        if (getDstSnapshot().getVmConfiguration() != null) {
            getParameters().setDstLeaseDomainId(OvfUtils.fetchLeaseDomainId(getDstSnapshot().getVmConfiguration()));
        }
        getParameters().setLeaseAction(determineLeaseAction(getVm().getStaticData().getLeaseStorageDomainId(), getParameters().getDstLeaseDomainId()));
    }
    if (!filteredImages.isEmpty()) {
        vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (actionReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
                    } else if (actionReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(actionReturnValue.getFault().getError(), actionReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (restoreLease && getParameters().getLeaseAction() == LeaseAction.CREATE_NEW_LEASE) {
                    if (!addVmLease(getParameters().getDstLeaseDomainId(), getVm().getId(), false)) {
                        log.error("Failed to create lease for VM '{}' on storage domain '{}'", getVm().getName(), getParameters().getDstLeaseDomainId());
                        throw new EngineException(EngineError.FailedToCreateLease);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(ActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    } else {
        // if there are no disks to restore, no compensation context is saved and the VM Configuration
        // (including clusterCompatibilityVersionOrigin) is already restored at this point. Otherwise,
        // if disks are being restored, the VM Configuration is restored later in endSuccessfully()
        updateClusterCompatibilityVersionToOldCluster(true);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = isRestoreMemory();
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    if (log.isInfoEnabled()) {
        log.info("Previewing snapshot {} with the disks:\n{}", getSnapshotName(), filteredImages.stream().map(disk -> String.format("%s (%s) to imageId %s", disk.getName(), disk.getId().toString(), disk.getImageId().toString())).collect(Collectors.joining("\n")));
    }
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        snapshotDao.remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotStatus.LOCKED, SnapshotType.PREVIEW, getVm(), true, previousActiveSnapshot.getMemoryVolume(), null, null, null, getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), SnapshotStatus.OK, restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, snapshotToBePreviewed.getCreationDate(), images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    initializeSnapshotsLeasesParams();
    if (!filteredImages.isEmpty()) {
        vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (actionReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
                    } else if (actionReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(actionReturnValue.getFault().getError(), actionReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (getParameters().getLeaseAction() == LeaseAction.CREATE_NEW_LEASE) {
                    if (!addVmLease(getParameters().getDstLeaseDomainId(), getVm().getId(), false)) {
                        log.error("Failed to create lease for VM '{}' on storage domain '{}'", getVm().getName(), getParameters().getDstLeaseDomainId());
                        throw new EngineException(EngineError.FailedToCreateLease);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(ActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    } else {
        // if there are no disks to restore, no compensation context is saved and the VM Configuration
        // (including clusterCompatibilityVersionOrigin) is already restored at this point. Otherwise,
        // if disks are being restored, the VM Configuration is restored later in endSuccessfully()
        updateClusterCompatibilityVersionToOldCluster(true);
    }
    setSucceeded(true);
}
#end_block

#method_before
private LeaseAction determineLeaseAction(Guid srcLeaseDomainId, Guid dstLeaseDomainId) {
    // if the current VM snapshot has a lease
    if (srcLeaseDomainId != null && getVm().getLeaseInfo() != null) {
        // both snapshots have leases
        if (dstLeaseDomainId != null) {
            return srcLeaseDomainId.equals(dstLeaseDomainId) ? LeaseAction.UPDATE_LEASE_INFO : LeaseAction.CREATE_NEW_LEASE;
        }
    }
    return dstLeaseDomainId != null ? LeaseAction.CREATE_NEW_LEASE : LeaseAction.DO_NOTHING;
}
#method_after
private LeaseAction determineLeaseAction(Guid srcLeaseDomainId, Guid dstLeaseDomainId) {
    // if the current VM snapshot has a lease
    if (srcLeaseDomainId != null && getVm().getLeaseInfo() != null) {
        // if both snapshots have leases - use the active snapshot lease
        if (dstLeaseDomainId != null) {
            return srcLeaseDomainId.equals(dstLeaseDomainId) ? LeaseAction.UPDATE_LEASE_INFO : LeaseAction.CREATE_NEW_LEASE;
        }
    }
    return dstLeaseDomainId != null ? LeaseAction.CREATE_NEW_LEASE : LeaseAction.DO_NOTHING;
}
#end_block

#method_before
private List<DiskImage> getImagesToPreview() {
    if (imagesToPreview == null) {
        imagesToPreview = getParameters().getDisks() != null ? getParameters().getDisks() : diskImageDao.getAllSnapshotsForVmSnapshot(getDstSnapshot().getId());
        // Filter out shareable/nonsnapable disks
        List<CinderDisk> CinderImagesToPreview = DisksFilter.filterCinderDisks(imagesToPreview);
        imagesToPreview = DisksFilter.filterImageDisks(imagesToPreview, ONLY_NOT_SHAREABLE, ONLY_SNAPABLE);
        imagesToPreview.addAll(CinderImagesToPreview);
    }
    return imagesToPreview;
}
#method_after
private List<DiskImage> getImagesToPreview() {
    if (imagesToPreview == null) {
        if (getParameters().getImageIds() != null) {
            imagesToPreview = getParameters().getImageIds().stream().map(diskImageDao::getSnapshotById).collect(Collectors.toList());
        } else {
            imagesToPreview = diskImageDao.getAllSnapshotsForVmSnapshot(getDstSnapshot().getId());
        }
        // Filter out shareable/nonsnapable disks
        List<CinderDisk> CinderImagesToPreview = DisksFilter.filterCinderDisks(imagesToPreview);
        imagesToPreview = DisksFilter.filterImageDisks(imagesToPreview, ONLY_NOT_SHAREABLE, ONLY_SNAPABLE);
        imagesToPreview.addAll(CinderImagesToPreview);
    }
    return imagesToPreview;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.isVmExists()) || !validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId())) || !validate(snapshotsValidator.snapshotVmConfigurationBroken(getDstSnapshot(), getVmName()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    diskImages.addAll(DisksFilter.filterCinderDisks(getVm().getDiskMap().values(), ONLY_PLUGGED));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).existsAndUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(getImagesToPreview());
        if (!validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked()) || !validate(diskImagesToPreviewValidator.diskImagesSnapshotsAttachedToVm(getVmId()))) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(getParameters().getDisks());
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    if (isRestoreMemory() && !validateMemoryTakenInSupportedVersion()) {
        return false;
    }
    if (!canRestoreVmConfigFromSnapshot()) {
        return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    // verify that the destination lease domain ID belongs to one of the VM's snapshots
    if (getParameters().getDstLeaseDomainId() != null) {
        if (!validate(snapshotsValidator.isLeaseDomainIdBelongsToSnapshot(getVmId(), getParameters().getDstLeaseDomainId())) && !getParameters().getDstLeaseDomainId().equals(getVm().getLeaseStorageDomainId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_LEASE_DOMAIN_ID_IS_NOT_VALID);
        }
    }
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.isVmExists()) || !validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId())) || !validate(snapshotsValidator.snapshotVmConfigurationBroken(getDstSnapshot(), getVmName()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    diskImages.addAll(DisksFilter.filterCinderDisks(getVm().getDiskMap().values(), ONLY_PLUGGED));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).existsAndUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(getImagesToPreview());
        if (!validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked()) || !validate(diskImagesToPreviewValidator.diskImagesSnapshotsAttachedToVm(getVmId()))) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        // verify lease storage domain status
        if (getParameters().getDstLeaseDomainId() != null) {
            storageIds.add(getParameters().getDstLeaseDomainId());
        } else if (getDstSnapshot().getVmConfiguration() != null) {
            Guid leaseDomainId = OvfUtils.fetchLeaseDomainId(getDstSnapshot().getVmConfiguration());
            if (leaseDomainId != null) {
                storageIds.add(leaseDomainId);
            }
        }
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    List<DiskImage> images = null;
    if (getParameters().getImageIds() != null) {
        images = getImagesToPreview();
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(images);
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    if (isRestoreMemory() && !validateMemoryTakenInSupportedVersion()) {
        return false;
    }
    if (!canRestoreVmConfigFromSnapshot()) {
        return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
    }
    return true;
}
#end_block

#method_before
@Override
public Response previewSnapshot(Action action) {
    validateParameters(action, "snapshot.id");
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(guid, asGuid(action.getSnapshot().getId()));
    if (action.isSetRestoreMemory()) {
        tryBackParams.setRestoreMemory(action.isRestoreMemory());
    }
    if (action.isSetDisks()) {
        tryBackParams.setDisks(getParent().mapDisks(action.getDisks()));
    }
    if (action.isSetRestoreLease()) {
        tryBackParams.setRestoreLease(action.isRestoreLease());
    }
    Response response = doAction(ActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action);
    return response;
}
#method_after
@Override
public Response previewSnapshot(Action action) {
    validateParameters(action, "snapshot.id");
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(guid, asGuid(action.getSnapshot().getId()));
    if (action.isSetRestoreMemory()) {
        tryBackParams.setRestoreMemory(action.isRestoreMemory());
    }
    if (action.isSetDisks()) {
        // Each disk parameter is being mapped to a DiskImage.
        List<DiskImage> disks = getParent().mapDisks(action.getDisks());
        if (disks != null) {
            // In case a disk hasn't specified its image_id, the imageId value is set to Guid.Empty().
            String noImageId = disks.stream().filter(disk -> disk.getImageId().equals(Guid.Empty)).map(disk -> disk.getId().toString()).collect(Collectors.joining(","));
            if (!noImageId.isEmpty()) {
                badRequest("Missing image ids for disks: " + noImageId);
            }
        }
        tryBackParams.setImageIds(getDisksGuidSet(disks));
    }
    if (action.isSetLease()) {
        tryBackParams.setRestoreLease(action.getLease().isSetStorageDomain());
        if (action.getLease().isSetStorageDomain()) {
            tryBackParams.setDstLeaseDomainId(asGuid(action.getLease().getStorageDomain().getId()));
        }
    }
    Response response = doAction(ActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action);
    return response;
}
#end_block

#method_before
protected void handleImageIsReadyForTransfer() {
    DiskImage image = getDiskImage();
    Guid domainId = image.getStorageIds().get(0);
    getParameters().setStorageDomainId(domainId);
    getParameters().setDestinationImageId(image.getImageId());
    // ovirt-imageio-daemon must know the boundaries of the target image for writing permissions.
    getParameters().setTransferSize(getTransferSize(image, domainId));
    persistCommand(getParameters().getParentCommand(), true);
    setImage(image);
    setStorageDomainId(domainId);
    log.info("Successfully added {} for image transfer command '{}'", getTransferDescription(), getCommandId());
    // ImageGroup is empty when downloading a disk snapshot
    if (!Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        ImageTransfer updates = new ImageTransfer();
        updates.setDiskId(getParameters().getImageGroupID());
        updateEntity(updates);
    }
    // The image will remain locked until the transfer command has completed.
    lockImage();
    boolean initSessionSuccess = startImageTransferSession();
    updateEntityPhase(initSessionSuccess ? ImageTransferPhase.TRANSFERRING : ImageTransferPhase.PAUSED_SYSTEM);
    log.info("Returning from proceedCommandExecution after starting transfer session" + " for image transfer command '{}'", getCommandId());
    resetPeriodicPauseLogTime(0);
}
#method_after
protected void handleImageIsReadyForTransfer() {
    DiskImage image = getDiskImage();
    Guid domainId = image.getStorageIds().get(0);
    getParameters().setStorageDomainId(domainId);
    getParameters().setDestinationImageId(image.getImageId());
    // ovirt-imageio-daemon must know the boundaries of the target image for writing permissions.
    getParameters().setTransferSize(getTransferSize(image, domainId));
    persistCommand(getParameters().getParentCommand(), true);
    setImage(image);
    setStorageDomainId(domainId);
    log.info("Successfully added {} for image transfer command '{}'", getTransferDescription(), getCommandId());
    // ImageGroup is empty when downloading a disk snapshot
    if (!Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        ImageTransfer updates = new ImageTransfer();
        updates.setDiskId(getParameters().getImageGroupID());
        updateEntity(updates);
    }
    // The image will remain locked until the transfer command has completed.
    lockImage();
    startImageTransferSession();
    log.info("Returning from proceedCommandExecution after starting transfer session" + " for image transfer command '{}'", getCommandId());
    resetPeriodicPauseLogTime(0);
}
#end_block

#method_before
private void extendTicketIfNecessary(final StateContext context) {
    // exponentially, make sure to set it with time to spare.
    if (context.iterationTimestamp >= getParameters().getSessionExpiration() - getHostTicketRefreshAllowance()) {
        log.info("Renewing transfer ticket for {}", getTransferDescription());
        boolean extendSucceeded = extendImageTransferSession(context.entity);
        if (!extendSucceeded) {
            log.warn("Failed to renew transfer ticket for {}", getTransferDescription());
            if (getParameters().isRetryExtendTicket()) {
                // Set 'extendTicketFailed' flag to true for giving a grace period
                // for another extend attempt.
                getParameters().setRetryExtendTicket(false);
            } else {
                updateEntityPhase(ImageTransferPhase.PAUSED_SYSTEM);
                getParameters().setRetryExtendTicket(true);
            }
        }
    } else {
        log.debug("Not yet renewing transfer ticket for {}", getTransferDescription());
    }
}
#method_after
private void extendTicketIfNecessary(final StateContext context) {
    // exponentially, make sure to set it with time to spare.
    if (context.iterationTimestamp >= getParameters().getSessionExpiration() - getHostTicketRefreshAllowance()) {
        log.info("Renewing transfer ticket for {}", getTransferDescription());
        boolean extendSucceeded = extendImageTransferSession(context.entity);
        if (!extendSucceeded) {
            log.warn("Failed to renew transfer ticket for {}", getTransferDescription());
            if (getParameters().isRetryExtendTicket()) {
                // Set 'extendTicketFailed' flag to true for giving a grace period
                // for another extend attempt.
                getParameters().setRetryExtendTicket(false);
            } else {
                updateEntityPhaseToPausedBySystem(AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_TICKET_RENEW_FAILURE);
                getParameters().setRetryExtendTicket(true);
            }
        }
    } else {
        log.debug("Not yet renewing transfer ticket for {}", getTransferDescription());
    }
}
#end_block

#method_before
private void pollTransferStatus(final StateContext context) {
    if (context.entity.getVdsId() == null || context.entity.getImagedTicketId() == null || !FeatureSupported.getImageTicketSupported(vdsDao.get(context.entity.getVdsId()).getClusterCompatibilityVersion())) {
        // Old engines update the transfer status in UploadImageHandler::updateBytesSent.
        return;
    }
    ImageTicketInformation ticketInfo;
    try {
        ticketInfo = (ImageTicketInformation) runVdsCommand(VDSCommandType.GetImageTicket, new GetImageTicketVDSCommandParameters(context.entity.getVdsId(), context.entity.getImagedTicketId())).getReturnValue();
    } catch (EngineException e) {
        log.error("Could not get image ticket '{}' from vdsm", context.entity.getImagedTicketId(), e);
        updateEntityPhase(ImageTransferPhase.PAUSED_SYSTEM);
        return;
    }
    ImageTransfer upToDateImageTransfer = updateTransferStatusWithTicketInformation(context.entity, ticketInfo);
    if (getParameters().getTransferType() == TransferType.Download) {
        finalizeDownloadIfNecessary(context, upToDateImageTransfer);
    }
}
#method_after
private void pollTransferStatus(final StateContext context) {
    if (context.entity.getVdsId() == null || context.entity.getImagedTicketId() == null || !FeatureSupported.getImageTicketSupported(vdsDao.get(context.entity.getVdsId()).getClusterCompatibilityVersion())) {
        // Old engines update the transfer status in UploadImageHandler::updateBytesSent.
        return;
    }
    ImageTicketInformation ticketInfo;
    try {
        ticketInfo = (ImageTicketInformation) runVdsCommand(VDSCommandType.GetImageTicket, new GetImageTicketVDSCommandParameters(context.entity.getVdsId(), context.entity.getImagedTicketId())).getReturnValue();
    } catch (EngineException e) {
        log.error("Could not get image ticket '{}' from vdsm", context.entity.getImagedTicketId(), e);
        updateEntityPhaseToPausedBySystem(AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_MISSING_TICKET);
        return;
    }
    ImageTransfer upToDateImageTransfer = updateTransferStatusWithTicketInformation(context.entity, ticketInfo);
    if (getParameters().getTransferType() == TransferType.Download) {
        finalizeDownloadIfNecessary(context, upToDateImageTransfer);
    }
}
#end_block

#method_before
private void handleFinalizingFailure(final StateContext context) {
    log.error("Finalizing failed transfer. {}", getTransferDescription());
    stopImageTransferSession(context.entity);
    // (only if not disk snapshot)
    if (!Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        setImageStatus(getParameters().getTransferType() == TransferType.Upload ? ImageStatus.ILLEGAL : ImageStatus.OK);
    }
    // Teardown is required for all scenarios as we call prepareImage when
    // starting a new session.
    tearDownImage(context.entity.getVdsId());
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
    setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_FAILURE);
}
#method_after
private void handleFinalizingFailure(final StateContext context) {
    log.error("Finalizing failed transfer. {}", getTransferDescription());
    stopImageTransferSession(context.entity);
    // (only if not disk snapshot)
    if (!Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        setImageStatus(getParameters().getTransferType() == TransferType.Upload ? ImageStatus.ILLEGAL : ImageStatus.OK);
    }
    Guid vdsId = context.entity.getVdsId() != null ? context.entity.getVdsId() : getVdsId();
    // Teardown is required for all scenarios as we call prepareImage when
    // starting a new session.
    tearDownImage(vdsId);
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
    setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_FAILURE);
}
#end_block

#method_before
private boolean stopTransferIfNecessary(ImageTransfer entity, long ts) {
    // within that interval during INITIALIZING and TRANSFERRING states.
    if (getParameters().getKeepaliveInterval() > 0 && (entity.getPhase() == ImageTransferPhase.INITIALIZING || entity.getPhase() == ImageTransferPhase.TRANSFERRING) && (entity.getLastUpdated().getTime() / 1000) + getParameters().getKeepaliveInterval() < ts) {
        String action = "paused";
        ImageTransferPhase phase = ImageTransferPhase.PAUSED_SYSTEM;
        if (getParameters().getTransferType() == TransferType.Download) {
            // In UI download flows, we can assume that if there was no activity for a while, the
            // proxy must have been restarted and there is no way to resume the download anyway.
            action = "canceled";
            phase = ImageTransferPhase.CANCELLED;
        }
        log.warn("Transfer was {} due to no updates in {} seconds. {}", action, ts - (entity.getLastUpdated().getTime() / 1000), getTransferDescription());
        updateEntityPhase(phase);
        return true;
    }
    return false;
}
#method_after
private boolean stopTransferIfNecessary(ImageTransfer entity, long ts) {
    if (getTransferImageClientInactivityTimeoutInSeconds() > 0 && (entity.getPhase() == ImageTransferPhase.INITIALIZING || entity.getPhase() == ImageTransferPhase.TRANSFERRING) && (entity.getLastUpdated().getTime() / 1000) + getTransferImageClientInactivityTimeoutInSeconds() < ts) {
        if (getParameters().getTransferType() == TransferType.Download) {
            // In download flows, we can cancel the transfer if there was no activity
            // for a while, as the download is handled by the client.
            auditLog(this, AuditLogType.DOWNLOAD_IMAGE_CANCELED_TIMEOUT);
            updateEntityPhase(ImageTransferPhase.CANCELLED);
        } else {
            updateEntityPhaseToPausedBySystem(AuditLogType.UPLOAD_IMAGE_PAUSED_BY_SYSTEM_TIMEOUT);
        }
        return true;
    }
    return false;
}
#end_block

#method_before
protected boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    long timeout = getHostTicketLifetime();
    if (!addImageTicketToDaemon(imagedTicketId, timeout)) {
        return false;
    }
    if (!addImageTicketToProxy(imagedTicketId, signedTicket)) {
        return false;
    }
    ImageTransfer updates = new ImageTransfer();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri() + IMAGES_PATH);
    updates.setDaemonUri(getImageDaemonUri(getVds().getHostName()) + IMAGES_PATH);
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#method_after
protected void startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        updateEntityPhaseToPausedBySystem(AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_MISSING_HOST);
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        log.error("Failed to create a signed image ticket");
        updateEntityPhaseToPausedBySystem(AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_FAILED_TO_CREATE_TICKET);
    }
    long timeout = getHostTicketLifetime();
    if (!addImageTicketToDaemon(imagedTicketId, timeout)) {
        log.error("Failed to add image ticket to ovirt-imageio-daemon");
        updateEntityPhaseToPausedBySystem(AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_FAILED_TO_ADD_TICKET_TO_DAEMON);
    }
    if (!addImageTicketToProxy(imagedTicketId, signedTicket)) {
        log.error("Failed to add image ticket to ovirt-imageio-proxy");
        updateEntityPhaseToPausedBySystem(AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_FAILED_TO_ADD_TICKET_TO_PROXY);
    }
    ImageTransfer updates = new ImageTransfer();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri() + IMAGES_PATH);
    updates.setDaemonUri(getImageDaemonUri(getVds().getHostName()) + IMAGES_PATH);
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    updateEntityPhase(ImageTransferPhase.TRANSFERRING);
}
#end_block

#method_before
protected ImageTransfer updateEntityPhase(ImageTransferPhase phase) {
    ImageTransfer updates = new ImageTransfer(getCommandId());
    updates.setPhase(phase);
    return updateEntity(updates);
}
#method_after
protected void updateEntityPhase(ImageTransferPhase phase) {
    ImageTransfer updates = new ImageTransfer(getCommandId());
    updates.setPhase(phase);
    updateEntity(updates);
}
#end_block

#method_before
protected ImageTransfer updateEntity(ImageTransfer updates) {
    return updateEntity(updates, false);
}
#method_after
protected void updateEntity(ImageTransfer updates) {
    updateEntity(updates, false);
}
#end_block

#method_before
protected ImageTransfer updateEntity(ImageTransfer updates, boolean clearResourceId) {
    return imageTransferUpdater.updateEntity(updates, getCommandId(), clearResourceId);
}
#method_after
protected void updateEntity(ImageTransfer updates, boolean clearResourceId) {
    imageTransferUpdater.updateEntity(updates, getCommandId(), clearResourceId);
}
#end_block

#method_before
@Override
public Response previewSnapshot(Action action) {
    validateParameters(action, "snapshot.id");
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(guid, asGuid(action.getSnapshot().getId()));
    if (action.isSetRestoreMemory()) {
        tryBackParams.setRestoreMemory(action.isRestoreMemory());
    }
    if (action.isSetDisks()) {
        List<DiskImage> disks = getParent().mapDisks(action.getDisks());
        if (disks != null) {
            String noImageId = disks.stream().filter(disk -> disk.getImageId().toString().equals("00000000-0000-0000-0000-000000000000")).map(disk -> disk.getId().toString()).collect(Collectors.joining(","));
            if (!noImageId.isEmpty()) {
                badRequest("Missing image ids for disks: " + noImageId);
            }
        }
        tryBackParams.setImageIds(getDisksGuidSet(disks));
    }
    Response response = doAction(ActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action);
    return response;
}
#method_after
@Override
public Response previewSnapshot(Action action) {
    validateParameters(action, "snapshot.id");
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(guid, asGuid(action.getSnapshot().getId()));
    if (action.isSetRestoreMemory()) {
        tryBackParams.setRestoreMemory(action.isRestoreMemory());
    }
    if (action.isSetDisks()) {
        // Each disk parameter is being mapped to a DiskImage.
        List<DiskImage> disks = getParent().mapDisks(action.getDisks());
        if (disks != null) {
            // In case a disk hasn't specified its image_id, the imageId value is set to Guid.Empty().
            String noImageId = disks.stream().filter(disk -> disk.getImageId().equals(Guid.Empty)).map(disk -> disk.getId().toString()).collect(Collectors.joining(","));
            if (!noImageId.isEmpty()) {
                badRequest("Missing image ids for disks: " + noImageId);
            }
        }
        tryBackParams.setImageIds(getDisksGuidSet(disks));
    }
    Response response = doAction(ActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action);
    return response;
}
#end_block

#method_before
protected void handleImageIsReadyForTransfer() {
    DiskImage image = getDiskImage();
    Guid domainId = image.getStorageIds().get(0);
    getParameters().setStorageDomainId(domainId);
    getParameters().setDestinationImageId(image.getImageId());
    // ovirt-imageio-daemon must know the boundaries of the target image for writing permissions.
    getParameters().setTransferSize(getTransferSize(image, domainId));
    persistCommand(getParameters().getParentCommand(), true);
    setImage(image);
    setStorageDomainId(domainId);
    log.info("Successfully added {} for image transfer command '{}'", getTransferDescription(), getCommandId());
    // ImageGroup is empty when downloading a disk snapshot
    if (!Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        ImageTransfer updates = new ImageTransfer();
        updates.setDiskId(getParameters().getImageGroupID());
        updateEntity(updates);
    }
    // The image will remain locked until the transfer command has completed.
    lockImage();
    boolean initSessionSuccess = startImageTransferSession();
    updateEntityPhase(initSessionSuccess ? ImageTransferPhase.TRANSFERRING : ImageTransferPhase.PAUSED_SYSTEM);
    log.info("Returning from proceedCommandExecution after starting transfer session" + " for image transfer command '{}'", getCommandId());
    resetPeriodicPauseLogTime(0);
}
#method_after
protected void handleImageIsReadyForTransfer() {
    DiskImage image = getDiskImage();
    Guid domainId = image.getStorageIds().get(0);
    getParameters().setStorageDomainId(domainId);
    getParameters().setDestinationImageId(image.getImageId());
    // ovirt-imageio-daemon must know the boundaries of the target image for writing permissions.
    getParameters().setTransferSize(getTransferSize(image, domainId));
    persistCommand(getParameters().getParentCommand(), true);
    setImage(image);
    setStorageDomainId(domainId);
    log.info("Successfully added {} for image transfer command '{}'", getTransferDescription(), getCommandId());
    // ImageGroup is empty when downloading a disk snapshot
    if (!Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        ImageTransfer updates = new ImageTransfer();
        updates.setDiskId(getParameters().getImageGroupID());
        updateEntity(updates);
    }
    // The image will remain locked until the transfer command has completed.
    lockImage();
    startImageTransferSession();
    log.info("Returning from proceedCommandExecution after starting transfer session" + " for image transfer command '{}'", getCommandId());
    resetPeriodicPauseLogTime(0);
}
#end_block

#method_before
private void extendTicketIfNecessary(final StateContext context) {
    // exponentially, make sure to set it with time to spare.
    if (context.iterationTimestamp >= getParameters().getSessionExpiration() - getHostTicketRefreshAllowance()) {
        log.info("Renewing transfer ticket for {}", getTransferDescription());
        boolean extendSucceeded = extendImageTransferSession(context.entity);
        if (!extendSucceeded) {
            log.warn("Failed to renew transfer ticket for {}", getTransferDescription());
            if (getParameters().isRetryExtendTicket()) {
                // Set 'extendTicketFailed' flag to true for giving a grace period
                // for another extend attempt.
                getParameters().setRetryExtendTicket(false);
            } else {
                pausedBySystemReason = AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_TICKET_RENEW_FAILURE;
                updateEntityPhase(ImageTransferPhase.PAUSED_SYSTEM);
                getParameters().setRetryExtendTicket(true);
            }
        }
    } else {
        log.debug("Not yet renewing transfer ticket for {}", getTransferDescription());
    }
}
#method_after
private void extendTicketIfNecessary(final StateContext context) {
    // exponentially, make sure to set it with time to spare.
    if (context.iterationTimestamp >= getParameters().getSessionExpiration() - getHostTicketRefreshAllowance()) {
        log.info("Renewing transfer ticket for {}", getTransferDescription());
        boolean extendSucceeded = extendImageTransferSession(context.entity);
        if (!extendSucceeded) {
            log.warn("Failed to renew transfer ticket for {}", getTransferDescription());
            if (getParameters().isRetryExtendTicket()) {
                // Set 'extendTicketFailed' flag to true for giving a grace period
                // for another extend attempt.
                getParameters().setRetryExtendTicket(false);
            } else {
                updateEntityPhaseToPausedBySystem(AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_TICKET_RENEW_FAILURE);
                getParameters().setRetryExtendTicket(true);
            }
        }
    } else {
        log.debug("Not yet renewing transfer ticket for {}", getTransferDescription());
    }
}
#end_block

#method_before
private void pollTransferStatus(final StateContext context) {
    if (context.entity.getVdsId() == null || context.entity.getImagedTicketId() == null || !FeatureSupported.getImageTicketSupported(vdsDao.get(context.entity.getVdsId()).getClusterCompatibilityVersion())) {
        // Old engines update the transfer status in UploadImageHandler::updateBytesSent.
        return;
    }
    ImageTicketInformation ticketInfo;
    try {
        ticketInfo = (ImageTicketInformation) runVdsCommand(VDSCommandType.GetImageTicket, new GetImageTicketVDSCommandParameters(context.entity.getVdsId(), context.entity.getImagedTicketId())).getReturnValue();
    } catch (EngineException e) {
        log.error("Could not get image ticket '{}' from vdsm", context.entity.getImagedTicketId(), e);
        pausedBySystemReason = AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_MISSING_TICKET;
        updateEntityPhase(ImageTransferPhase.PAUSED_SYSTEM);
        return;
    }
    ImageTransfer upToDateImageTransfer = updateTransferStatusWithTicketInformation(context.entity, ticketInfo);
    if (getParameters().getTransferType() == TransferType.Download) {
        finalizeDownloadIfNecessary(context, upToDateImageTransfer);
    }
}
#method_after
private void pollTransferStatus(final StateContext context) {
    if (context.entity.getVdsId() == null || context.entity.getImagedTicketId() == null || !FeatureSupported.getImageTicketSupported(vdsDao.get(context.entity.getVdsId()).getClusterCompatibilityVersion())) {
        // Old engines update the transfer status in UploadImageHandler::updateBytesSent.
        return;
    }
    ImageTicketInformation ticketInfo;
    try {
        ticketInfo = (ImageTicketInformation) runVdsCommand(VDSCommandType.GetImageTicket, new GetImageTicketVDSCommandParameters(context.entity.getVdsId(), context.entity.getImagedTicketId())).getReturnValue();
    } catch (EngineException e) {
        log.error("Could not get image ticket '{}' from vdsm", context.entity.getImagedTicketId(), e);
        updateEntityPhaseToPausedBySystem(AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_MISSING_TICKET);
        return;
    }
    ImageTransfer upToDateImageTransfer = updateTransferStatusWithTicketInformation(context.entity, ticketInfo);
    if (getParameters().getTransferType() == TransferType.Download) {
        finalizeDownloadIfNecessary(context, upToDateImageTransfer);
    }
}
#end_block

#method_before
private boolean pauseTransferIfNecessary(ImageTransfer entity, long ts) {
    // within that interval during INITIALIZING and TRANSFERRING states.
    if (getParameters().getKeepaliveInterval() > 0 && (entity.getPhase() == ImageTransferPhase.INITIALIZING || entity.getPhase() == ImageTransferPhase.TRANSFERRING) && (entity.getLastUpdated().getTime() / 1000) + getParameters().getKeepaliveInterval() < ts) {
        log.warn("Transfer paused due to no updates in {} seconds. {}", ts - (entity.getLastUpdated().getTime() / 1000), getTransferDescription());
        pausedBySystemReason = AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_TIMEOUT;
        updateEntityPhase(ImageTransferPhase.PAUSED_SYSTEM);
        return true;
    }
    return false;
}
#method_after
private boolean pauseTransferIfNecessary(ImageTransfer entity, long ts) {
    // within that interval during INITIALIZING and TRANSFERRING states.
    if (getParameters().getKeepaliveInterval() > 0 && (entity.getPhase() == ImageTransferPhase.INITIALIZING || entity.getPhase() == ImageTransferPhase.TRANSFERRING) && (entity.getLastUpdated().getTime() / 1000) + getParameters().getKeepaliveInterval() < ts) {
        log.warn("Transfer paused due to no updates in {} seconds. {}", ts - (entity.getLastUpdated().getTime() / 1000), getTransferDescription());
        updateEntityPhaseToPausedBySystem(AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_TIMEOUT);
        return true;
    }
    return false;
}
#end_block

#method_before
protected boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        pausedBySystemReason = AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_MISSING_HOST;
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        log.error("Failed to create a signed image ticket");
        pausedBySystemReason = AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_FAILED_TO_CREATE_TICKET;
        return false;
    }
    long timeout = getHostTicketLifetime();
    if (!addImageTicketToDaemon(imagedTicketId, timeout)) {
        log.error("Failed to add image ticket to ovirt-imageio-daemon");
        pausedBySystemReason = AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_FAILED_TO_ADD_TICKET_TO_DAEMON;
        return false;
    }
    if (!addImageTicketToProxy(imagedTicketId, signedTicket)) {
        log.error("Failed to add image ticket to ovirt-imageio-proxy");
        pausedBySystemReason = AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_FAILED_TO_ADD_TICKET_TO_PROXY;
        return false;
    }
    ImageTransfer updates = new ImageTransfer();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri() + IMAGES_PATH);
    updates.setDaemonUri(getImageDaemonUri(getVds().getHostName()) + IMAGES_PATH);
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#method_after
protected void startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        updateEntityPhaseToPausedBySystem(AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_MISSING_HOST);
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        log.error("Failed to create a signed image ticket");
        updateEntityPhaseToPausedBySystem(AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_FAILED_TO_CREATE_TICKET);
    }
    long timeout = getHostTicketLifetime();
    if (!addImageTicketToDaemon(imagedTicketId, timeout)) {
        log.error("Failed to add image ticket to ovirt-imageio-daemon");
        updateEntityPhaseToPausedBySystem(AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_FAILED_TO_ADD_TICKET_TO_DAEMON);
    }
    if (!addImageTicketToProxy(imagedTicketId, signedTicket)) {
        log.error("Failed to add image ticket to ovirt-imageio-proxy");
        updateEntityPhaseToPausedBySystem(AuditLogType.TRANSFER_IMAGE_PAUSED_BY_SYSTEM_FAILED_TO_ADD_TICKET_TO_PROXY);
    }
    ImageTransfer updates = new ImageTransfer();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri() + IMAGES_PATH);
    updates.setDaemonUri(getImageDaemonUri(getVds().getHostName()) + IMAGES_PATH);
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    updateEntityPhase(ImageTransferPhase.TRANSFERRING);
}
#end_block

#method_before
protected ImageTransfer updateEntityPhase(ImageTransferPhase phase) {
    if (phase == ImageTransferPhase.PAUSED_SYSTEM && pausedBySystemReason != null) {
        auditLog(this, pausedBySystemReason);
    }
    ImageTransfer updates = new ImageTransfer(getCommandId());
    updates.setPhase(phase);
    return updateEntity(updates);
}
#method_after
protected ImageTransfer updateEntityPhase(ImageTransferPhase phase) {
    ImageTransfer updates = new ImageTransfer(getCommandId());
    updates.setPhase(phase);
    return updateEntity(updates);
}
#end_block

#method_before
@Override
public ImageTransfer getByDiskId(Guid diskId) {
    return getCallsHandler().executeRead("GetImageUploadsByDiskId", createEntityRowMapper(), createDiskIdParameterMapper(diskId));
}
#method_after
@Override
public ImageTransfer getByDiskId(Guid diskId) {
    return getCallsHandler().executeRead("GetImageUploadsByDiskId", createEntityRowMapper(), createIdParameterMapper(diskId, "disk_id"));
}
#end_block

#method_before
@Override
public List<ImageTransfer> getByVdsId(Guid vdsId) {
    return getCallsHandler().executeReadList("GetImageTransfersByVdsId", createEntityRowMapper(), createVdsIdParameterMapper(vdsId));
}
#method_after
@Override
public List<ImageTransfer> getByVdsId(Guid vdsId) {
    return getCallsHandler().executeReadList("GetImageTransfersByVdsId", createEntityRowMapper(), createIdParameterMapper(vdsId, "vds_id"));
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createIdParameterMapper(Guid id) {
    return getCustomMapSqlParameterSource().addValue("command_id", id);
}
#method_after
@Override
protected MapSqlParameterSource createIdParameterMapper(Guid id) {
    return createIdParameterMapper(id, "command_id");
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createIdParameterMapper(Guid id) {
    return getCustomMapSqlParameterSource().addValue("command_id", id);
}
#method_after
protected MapSqlParameterSource createIdParameterMapper(Guid id, String paramName) {
    return getCustomMapSqlParameterSource().addValue(paramName, id);
}
#end_block

#method_before
private boolean validateNoActiveImageTransfers(VDS vds) {
    List<ImageTransfer> transfers = imageTransferDao.getByVdsId(vds.getId());
    if (!transfers.isEmpty() && !transfers.stream().allMatch(ImageTransfer::isPaused)) {
        List<String> replacements = new ArrayList<>(2);
        replacements.add(ReplacementUtils.createSetVariableString("host", vds.getName()));
        replacements.addAll(ReplacementUtils.replaceWith("disks", transfers.stream().map(ImageTransfer::getDiskId).collect(Collectors.toList())));
        return failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_HOST_WITH_RUNNING_IMAGE_TRANSFERS, replacements);
    }
    return true;
}
#method_after
private boolean validateNoActiveImageTransfers(VDS vds) {
    List<ImageTransfer> transfers = imageTransferDao.getByVdsId(vds.getId());
    if (!transfers.stream().allMatch(ImageTransfer::isPaused)) {
        List<String> replacements = new ArrayList<>(3);
        replacements.add(ReplacementUtils.createSetVariableString("host", vds.getName()));
        replacements.addAll(ReplacementUtils.replaceWith("disks", transfers.stream().filter(imageTransfer -> !imageTransfer.isPaused()).map(ImageTransfer::getDiskId).sorted().collect(Collectors.toList())));
        return failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_HOST_WITH_RUNNING_IMAGE_TRANSFERS, replacements);
    }
    return true;
}
#end_block

#method_before
public double getActualDiskSize() {
    if (cachedActualSize == 0.0) {
        cachedActualSize = getDiskImageMap().values().stream().mapToDouble(DiskImage::getActualSize).sum();
    }
    return cachedActualSize;
}
#method_after
public double getActualDiskSize() {
    if (cachedActualSize < 0.0) {
        cachedActualSize = getDiskImageMap().values().stream().mapToDouble(DiskImage::getActualSize).sum();
    }
    return cachedActualSize;
}
#end_block

#method_before
@Override
public void runningSucceded() {
    try {
        queryDowntime();
        vmDynamicDao.clearMigratingToVds(getVmId());
        updateVmAfterMigrationToDifferentCluster();
        plugPassthroughNics();
        updateExternalNics();
    } finally {
        super.runningSucceded();
    }
}
#method_after
@Override
public void runningSucceded() {
    try {
        queryDowntime();
        vmDynamicDao.clearMigratingToVds(getVmId());
        updateVmAfterMigrationToDifferentCluster();
        plugPassthroughNics();
        initParametersForExternalNetworks(destinationVds, true);
    } finally {
        super.runningSucceded();
    }
}
#end_block

#method_before
private void updateVmAfterMigrationToDifferentCluster() {
    if (getParameters().getTargetClusterId() == null || getVm().getClusterId().equals(getParameters().getTargetClusterId())) {
        return;
    }
    ChangeVMClusterParameters params = new ChangeVMClusterParameters(getParameters().getTargetClusterId(), getVmId(), getVm().getCustomCompatibilityVersion());
    setSucceeded(getBackend().runInternalAction(ActionType.ChangeVMCluster, params).getSucceeded());
}
#method_after
private void updateVmAfterMigrationToDifferentCluster() {
    if (getParameters().getTargetClusterId() == null || getVm().getClusterId().equals(getParameters().getTargetClusterId())) {
        return;
    }
    ChangeVMClusterParameters params = new ChangeVMClusterParameters(getParameters().getTargetClusterId(), getVmId(), getVm().getCustomCompatibilityVersion());
    setSucceeded(backend.runInternalAction(ActionType.ChangeVMCluster, params).getSucceeded());
}
#end_block

#method_before
private String getLiteralMigrationNetworkIp() {
    Network migrationNetwork = null;
    // Find migrationNetworkCluster
    List<Network> allNetworksInCluster = networkDao.getAllForCluster(getVm().getClusterId());
    for (Network tempNetwork : allNetworksInCluster) {
        if (tempNetwork.getCluster().isMigration()) {
            migrationNetwork = tempNetwork;
            break;
        }
    }
    if (migrationNetwork != null) {
        final String migrationDestinationIpv4Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv4Address);
        if (migrationDestinationIpv4Address != null) {
            return migrationDestinationIpv4Address;
        }
        final String migrationDestinationIpv6Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv6Address);
        if (migrationDestinationIpv6Address != null) {
            return formatIpv6AddressForUri(migrationDestinationIpv6Address);
        }
    }
    return null;
}
#method_after
private String getLiteralMigrationNetworkIp() {
    Network migrationNetwork = null;
    // Find migrationNetworkCluster
    List<Network> allNetworksInCluster = networkDao.getAllForCluster(getVm().getClusterId());
    for (Network tempNetwork : allNetworksInCluster) {
        if (tempNetwork.getCluster().isMigration()) {
            migrationNetwork = tempNetwork;
            break;
        }
    }
    if (migrationNetwork != null) {
        final String migrationDestinationIpv4Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv4Address, "v4");
        if (migrationDestinationIpv4Address != null) {
            return migrationDestinationIpv4Address;
        }
        final String migrationDestinationIpv6Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv6Address, "v6");
        if (migrationDestinationIpv6Address != null) {
            return formatIpv6AddressForUri(migrationDestinationIpv6Address);
        }
    }
    return null;
}
#end_block

#method_before
private String findValidMigrationIpAddress(Network migrationNetwork, Function<VdsNetworkInterface, String> ipAddressGetter) {
    // assure migration network is active on source host
    final String migrationSourceIpAddress = getMigrationNetworkAddress(getVds().getId(), migrationNetwork.getName(), ipAddressGetter);
    if (StringUtils.isNotEmpty(migrationSourceIpAddress)) {
        // find migration IP address on destination host
        final String migrationDestinationIpAddress = getMigrationNetworkAddress(getDestinationVds().getId(), migrationNetwork.getName(), ipAddressGetter);
        if (StringUtils.isNotEmpty(migrationDestinationIpAddress)) {
            return migrationDestinationIpAddress;
        }
    }
    return null;
}
#method_after
private String findValidMigrationIpAddress(Network migrationNetwork, Function<VdsNetworkInterface, String> ipAddressGetter, String ipVersion) {
    // assure migration network is active on source host
    final String migrationSourceIpAddress = getMigrationNetworkAddress(getVds().getId(), migrationNetwork.getName(), ipAddressGetter, ipVersion);
    if (StringUtils.isNotEmpty(migrationSourceIpAddress)) {
        // find migration IP address on destination host
        final String migrationDestinationIpAddress = getMigrationNetworkAddress(getDestinationVds().getId(), migrationNetwork.getName(), ipAddressGetter, ipVersion);
        if (StringUtils.isNotEmpty(migrationDestinationIpAddress)) {
            return migrationDestinationIpAddress;
        }
    }
    return null;
}
#end_block

#method_before
private String getMigrationNetworkAddress(Guid hostId, String migrationNetworkName, Function<VdsNetworkInterface, String> ipAddressGetter) {
    final List<VdsNetworkInterface> nics = interfaceDao.getAllInterfacesForVds(hostId);
    for (VdsNetworkInterface nic : nics) {
        if (migrationNetworkName.equals(nic.getNetworkName()) && migrationInterfaceUp(nic, nics)) {
            return ipAddressGetter.apply(nic);
        }
    }
    return null;
}
#method_after
private String getMigrationNetworkAddress(Guid hostId, String migrationNetworkName, Function<VdsNetworkInterface, String> ipAddressGetter, String ipVersion) {
    final List<VdsNetworkInterface> nics = interfaceDao.getAllInterfacesForVds(hostId);
    String errorMsg = String.format("Couldn't find ip %s migration address", ipVersion);
    VdsNetworkInterface migrationNic = nics.stream().filter(nic -> migrationNetworkName.equals(nic.getNetworkName())).findFirst().orElse(null);
    if (migrationNic == null) {
        log.warn("{} : migration network {} doesn't exist on host {}.", errorMsg, migrationNetworkName, hostId);
        return null;
    }
    if (migrationInterfaceUp(migrationNic, nics)) {
        String ip = ipAddressGetter.apply(migrationNic);
        if (StringUtils.isEmpty(ip)) {
            log.warn("{} : the IP address of migration network {} (host {}/nic {}) is empty.", errorMsg, migrationNetworkName, hostId, NetworkCommonUtils.stripVlan(migrationNic));
        }
        return ip;
    } else {
        log.warn("{} : Nic {} with migration network {} is not up on host {}.", errorMsg, NetworkCommonUtils.stripVlan(migrationNic), migrationNetworkName, hostId);
        return null;
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    Set<PermissionSubject> permissionSet = new HashSet<>();
    // Destination domains
    for (Guid storageId : imageToDestinationDomainMap.values()) {
        permissionSet.add(new PermissionSubject(storageId, VdcObjectType.Storage, getActionType().getActionGroup()));
    }
    // Destination cluster
    if (getClusterId() != null) {
        permissionSet.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.CREATE_VM));
    }
    return new ArrayList<>(permissionSet);
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<>();
    // Destination cluster
    permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.CREATE_VM));
    return permissionList;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // Source domain
    permissionList.add(new PermissionSubject(getParameters().getSourceDomainId(), VdcObjectType.Storage, getActionType().getActionGroup()));
    // Destination cluster
    if (getClusterId() != null) {
        permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.CREATE_VM));
    }
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    permissionList.addAll(getStoragePermissionCheckSubjects());
    // Source domain
    permissionList.add(new PermissionSubject(getParameters().getSourceDomainId(), VdcObjectType.Storage, getActionType().getActionGroup()));
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    Set<PermissionSubject> permissionSet = new HashSet<>();
    // Destination domain
    permissionSet.add(new PermissionSubject(getStorageDomainId(), VdcObjectType.Storage, getActionType().getActionGroup()));
    // Destination cluster
    if (getClusterId() != null) {
        permissionSet.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.CREATE_VM));
    }
    return new ArrayList<>(permissionSet);
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // Destination domain
    permissionList.add(new PermissionSubject(getStorageDomainId(), VdcObjectType.Storage, getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
protected boolean validateDestStorage() {
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
        return false;
    }
    // Validate shareable disks moving/copying
    boolean moveOrCopy = isMoveOperation() || isCopyOperation();
    if (moveOrCopy && getImage().isShareable() && getStorageDomain().getStorageType() == StorageType.GLUSTERFS) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANT_MOVE_SHAREABLE_DISK_TO_GLUSTERFS, String.format("$%1$s %2$s", "diskAlias", getImage().getDiskAlias()));
    }
    if (isMoveOperation()) {
        if (getImage().getStorageIds().contains(getStorageDomain().getId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DESTINATION_STORAGE_DOMAIN_IS_NOT_VALID);
        }
    }
    return true;
}
#method_after
protected boolean validateDestStorage() {
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
        return false;
    }
    // Validate shareable disks moving/copying
    boolean moveOrCopy = isMoveOperation() || isCopyOperation();
    if (moveOrCopy && getImage().isShareable() && getStorageDomain().getStorageType() == StorageType.GLUSTERFS) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANT_MOVE_SHAREABLE_DISK_TO_GLUSTERFS, String.format("$%1$s %2$s", "diskAlias", getImage().getDiskAlias()));
    }
    if (isMoveOperation()) {
        if (getImage().getStorageIds().contains(getStorageDomainId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DESTINATION_STORAGE_DOMAIN_ALREADY_CONTAINS_THE_DISK);
        }
    }
    return true;
}
#end_block

#method_before
protected boolean validateSourceStorageDomain() {
    Guid sourceDomainId = getParameters().getSourceDomainId();
    if (sourceDomainId == null || Guid.Empty.equals(sourceDomainId)) {
        sourceDomainId = getImage().getStorageIds().get(0);
        getParameters().setSourceDomainId(sourceDomainId);
    } else {
        if (!getImage().getStorageIds().contains(sourceDomainId)) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_SOURCE_STORAGE_DOMAIN_IS_NOT_VALID);
        }
    }
    StorageDomainValidator validator = new StorageDomainValidator(storageDomainDao.getForStoragePool(sourceDomainId, getImage().getStoragePoolId()));
    return validate(validator.isDomainExistAndActive());
}
#method_after
protected boolean validateSourceStorageDomain() {
    Guid sourceDomainId = getParameters().getSourceDomainId();
    if (sourceDomainId == null || Guid.Empty.equals(sourceDomainId)) {
        sourceDomainId = getImage().getStorageIds().get(0);
        getParameters().setSourceDomainId(sourceDomainId);
    } else {
        if (!getImage().getStorageIds().contains(sourceDomainId)) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_SOURCE_STORAGE_DOMAIN_DOES_CONTAINS_THE_DISK);
        }
    }
    StorageDomainValidator validator = new StorageDomainValidator(storageDomainDao.getForStoragePool(sourceDomainId, getImage().getStoragePoolId()));
    return validate(validator.isDomainExistAndActive());
}
#end_block

#method_before
@Test
public void validateSourceDomainValid() {
    DiskImage disk = new DiskImage();
    initializeCommand(disk, VmEntityType.VM);
    initSrcStorageDomain();
    initDestStorageDomain(StorageType.NFS);
    disk.setStorageIds(new ArrayList<>(Collections.singletonList(Guid.newGuid())));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_SOURCE_STORAGE_DOMAIN_IS_NOT_VALID);
}
#method_after
@Test
public void validateSourceDomainValid() {
    DiskImage disk = new DiskImage();
    initializeCommand(disk, VmEntityType.VM);
    initSrcStorageDomain();
    initDestStorageDomain(StorageType.NFS);
    disk.setStorageIds(new ArrayList<>(Collections.singletonList(Guid.newGuid())));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_SOURCE_STORAGE_DOMAIN_DOES_CONTAINS_THE_DISK);
}
#end_block

#method_before
@Test
public void validateDestinationDomainValid() {
    DiskImage disk = new DiskImage();
    initializeCommand(disk, VmEntityType.VM);
    disk.getStorageIds().add(destStorageId);
    initSrcStorageDomain();
    initDestStorageDomain(StorageType.NFS);
    command.getParameters().setStorageDomainId(destStorageId);
    command.setStorageDomainId(destStorageId);
    command.getStorageDomain().setId(destStorageId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_DESTINATION_STORAGE_DOMAIN_IS_NOT_VALID);
}
#method_after
@Test
public void validateDestinationDomainValid() {
    DiskImage disk = new DiskImage();
    initializeCommand(disk, VmEntityType.VM);
    disk.getStorageIds().add(destStorageId);
    initSrcStorageDomain();
    initDestStorageDomain(StorageType.NFS);
    command.getParameters().setStorageDomainId(destStorageId);
    command.setStorageDomainId(destStorageId);
    command.getStorageDomain().setId(destStorageId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_DESTINATION_STORAGE_DOMAIN_ALREADY_CONTAINS_THE_DISK);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    Guid activeBeforeSnapshotLeaseDomainId = null;
    Guid previewedSnapshotLeaseDomainId = getVm().getLeaseStorageDomainId();
    Snapshot activeBeforeSnapshot = snapshotDao.get(getVmId(), SnapshotType.PREVIEW);
    if (activeBeforeSnapshot.getVmConfiguration() != null) {
        activeBeforeSnapshotLeaseDomainId = OvfUtils.fetchLeaseDomainId(activeBeforeSnapshot.getVmConfiguration());
    }
    restoreSnapshotAndRemoveObsoleteSnapshots(getSnapshot());
    boolean succeeded = true;
    if (isRemoveLeaseNeeded(activeBeforeSnapshotLeaseDomainId, previewedSnapshotLeaseDomainId)) {
        // remove the lease which created for the previewed snapshot or ,in case of commit, the
        // lease of the active before snapshot
        Guid leaseDomainIdToRemove = getParameters().getSnapshotAction() == SnapshotActionEnum.UNDO ? previewedSnapshotLeaseDomainId : activeBeforeSnapshotLeaseDomainId;
        if (!removeVmLease(leaseDomainIdToRemove, getVmId())) {
            succeeded = false;
        }
    }
    List<CinderDisk> cinderDisksToRestore = new ArrayList<>();
    for (DiskImage image : imagesToRestore) {
        if (image.getImageStatus() != ImageStatus.ILLEGAL) {
            if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                cinderDisksToRestore.add((CinderDisk) image);
                continue;
            }
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), getSnapshot(), removedSnapshot.getId());
            ActionReturnValue returnValue = runAsyncTask(ActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    List<CinderDisk> cinderVolumesToRemove = new ArrayList<>();
    List<CinderDisk> cinderDisksToRemove = new ArrayList<>();
    removeUnusedImages(cinderVolumesToRemove);
    if (getSnapshot().getType() == SnapshotType.REGULAR) {
        snapshotsToRemove.addAll(findSnapshotsWithOnlyIllegalDisks());
        setNewerVmConfigurationsAsBroken();
    }
    removeSnapshotsFromDB();
    if (isLeaseInfoUpdateNeeded(activeBeforeSnapshotLeaseDomainId, previewedSnapshotLeaseDomainId)) {
        succeeded = updateLeaseInfo(activeBeforeSnapshotLeaseDomainId) && succeeded;
    }
    if (!getTaskIdList().isEmpty() || !cinderDisksToRestore.isEmpty() || !cinderVolumesToRemove.isEmpty()) {
        deleteOrphanedImages(cinderDisksToRemove);
        if (!restoreCinderDisks(removedSnapshot.getId(), cinderDisksToRestore, cinderDisksToRemove, cinderVolumesToRemove)) {
            log.error("Error to restore Cinder volumes snapshots");
        }
    } else {
        vmStaticDao.incrementDbGeneration(getVm().getId());
        snapshotDao.updateStatus(getSnapshot().getId(), SnapshotStatus.OK);
        unlockVm();
    }
    setSucceeded(succeeded);
}
#method_after
@Override
protected void executeVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    initializeSnapshotsLeasesDomainIds();
    restoreSnapshotAndRemoveObsoleteSnapshots(getSnapshot());
    boolean succeeded = removeLeaseIfNeeded();
    List<CinderDisk> cinderDisksToRestore = new ArrayList<>();
    for (DiskImage image : imagesToRestore) {
        if (image.getImageStatus() != ImageStatus.ILLEGAL) {
            if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                cinderDisksToRestore.add((CinderDisk) image);
                continue;
            }
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), getSnapshot(), removedSnapshot.getId());
            ActionReturnValue returnValue = runAsyncTask(ActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    List<CinderDisk> cinderVolumesToRemove = new ArrayList<>();
    List<CinderDisk> cinderDisksToRemove = new ArrayList<>();
    removeUnusedImages(cinderVolumesToRemove);
    if (getSnapshot().getType() == SnapshotType.REGULAR) {
        snapshotsToRemove.addAll(findSnapshotsWithOnlyIllegalDisks());
        setNewerVmConfigurationsAsBroken();
    }
    removeSnapshotsFromDB();
    succeeded = updateLeaseInfoIfNeeded() && succeeded;
    if (!getTaskIdList().isEmpty() || !cinderDisksToRestore.isEmpty() || !cinderVolumesToRemove.isEmpty()) {
        deleteOrphanedImages(cinderDisksToRemove);
        if (!restoreCinderDisks(removedSnapshot.getId(), cinderDisksToRestore, cinderDisksToRemove, cinderVolumesToRemove)) {
            log.error("Error to restore Cinder volumes snapshots");
        }
    } else {
        vmStaticDao.incrementDbGeneration(getVm().getId());
        snapshotDao.updateStatus(getSnapshot().getId(), SnapshotStatus.OK);
        unlockVm();
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
private boolean isRemoveLeaseNeeded(Guid srcLeaseDomainId, Guid dstLeaseDomainId) {
    if (getParameters().getSnapshotAction() == SnapshotActionEnum.UNDO) {
        return (srcLeaseDomainId != null && dstLeaseDomainId != null && !srcLeaseDomainId.equals(dstLeaseDomainId)) || (srcLeaseDomainId == null && dstLeaseDomainId != null);
    } else if (getParameters().getSnapshotAction() == SnapshotActionEnum.COMMIT) {
        return (srcLeaseDomainId != null && dstLeaseDomainId != null && !srcLeaseDomainId.equals(dstLeaseDomainId)) || (srcLeaseDomainId != null && dstLeaseDomainId == null);
    }
    return false;
}
#method_after
private boolean isRemoveLeaseNeeded(Guid srcLeaseDomainId, Guid dstLeaseDomainId) {
    switch(getParameters().getSnapshotAction()) {
        case UNDO:
            return !Objects.equals(srcLeaseDomainId, dstLeaseDomainId) || (srcLeaseDomainId == null && dstLeaseDomainId != null);
        case COMMIT:
            return !Objects.equals(srcLeaseDomainId, dstLeaseDomainId) || (srcLeaseDomainId != null && dstLeaseDomainId == null);
        default:
            return false;
    }
}
#end_block

#method_before
private boolean isLeaseInfoUpdateNeeded(Guid srcLeaseDomainId, Guid dstLeaseDomainId) {
    return getParameters().getSnapshotAction() == SnapshotActionEnum.UNDO && !(srcLeaseDomainId == null && dstLeaseDomainId == null);
}
#method_after
private boolean isLeaseInfoUpdateNeeded(Guid srcLeaseDomainId, Guid dstLeaseDomainId) {
    return (getParameters().getSnapshotAction() == SnapshotActionEnum.UNDO && !(srcLeaseDomainId == null && dstLeaseDomainId == null)) || (getParameters().getSnapshotAction() == SnapshotActionEnum.COMMIT && (srcLeaseDomainId != null && dstLeaseDomainId == null));
}
#end_block

#method_before
private boolean updateLeaseInfo(Guid snapshotLeaseDomainId) {
    if (snapshotLeaseDomainId == null) {
        // there was no lease for the active snapshot
        vmDynamicDao.updateVmLeaseInfo(getParameters().getVmId(), null);
        return true;
    }
    VDSReturnValue retVal = null;
    try {
        retVal = runVdsCommand(VDSCommandType.GetVmLeaseInfo, new VmLeaseVDSParameters(getStoragePoolId(), snapshotLeaseDomainId, getParameters().getVmId()));
    } catch (EngineException e) {
        log.error("Failure in getting lease info for VM {}, message: {}", getParameters().getVmId(), e.getMessage());
    }
    if (retVal == null || !retVal.getSucceeded()) {
        log.error("Failed to get info on the lease of VM {}", getParameters().getVmId());
        return false;
    }
    vmDynamicDao.updateVmLeaseInfo(getParameters().getVmId(), (Map<String, String>) retVal.getReturnValue());
    return true;
}
#method_after
private boolean updateLeaseInfo(Guid snapshotLeaseDomainId) {
    if (snapshotLeaseDomainId == null) {
        // there was no lease for the snapshot
        vmDynamicDao.updateVmLeaseInfo(getParameters().getVmId(), null);
        return true;
    }
    VDSReturnValue retVal = null;
    try {
        retVal = runVdsCommand(VDSCommandType.GetVmLeaseInfo, new VmLeaseVDSParameters(getStoragePoolId(), snapshotLeaseDomainId, getParameters().getVmId()));
    } catch (EngineException e) {
        log.error("Failure in getting lease info for VM {}, message: {}", getParameters().getVmId(), e.getMessage());
    }
    if (retVal == null || !retVal.getSucceeded()) {
        log.error("Failed to get info on the lease of VM {}", getParameters().getVmId());
        return false;
    }
    vmDynamicDao.updateVmLeaseInfo(getParameters().getVmId(), (Map<String, String>) retVal.getReturnValue());
    return true;
}
#end_block

#method_before
private void restoreConfiguration(Snapshot targetSnapshot) {
    removedSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    snapshotsToRemove.add(removedSnapshot.getId());
    getSnapshotsManager().removeAllIllegalDisks(removedSnapshot.getId(), getVmId());
    getSnapshotsManager().attempToRestoreVmConfigurationFromSnapshot(getVm(), targetSnapshot, targetSnapshot.getId(), null, getCompensationContext(), getCurrentUser(), new VmInterfaceManager(getMacPool()), StringUtils.isNotEmpty(targetSnapshot.getMemoryVolume()), false);
    snapshotDao.remove(targetSnapshot.getId());
    // add active snapshot with status locked, so that other commands that depend on the VM's snapshots won't run in parallel
    getSnapshotsManager().addActiveSnapshot(targetSnapshot.getId(), getVm(), SnapshotStatus.LOCKED, targetSnapshot.getMemoryVolume(), getCompensationContext());
}
#method_after
private void restoreConfiguration(Snapshot targetSnapshot) {
    removedSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    snapshotsToRemove.add(removedSnapshot.getId());
    getSnapshotsManager().removeAllIllegalDisks(removedSnapshot.getId(), getVmId());
    getSnapshotsManager().attempToRestoreVmConfigurationFromSnapshot(getVm(), targetSnapshot, targetSnapshot.getId(), null, getCompensationContext(), getCurrentUser(), new VmInterfaceManager(getMacPool()), StringUtils.isNotEmpty(targetSnapshot.getMemoryVolume()));
    snapshotDao.remove(targetSnapshot.getId());
    // add active snapshot with status locked, so that other commands that depend on the VM's snapshots won't run in parallel
    getSnapshotsManager().addActiveSnapshot(targetSnapshot.getId(), getVm(), SnapshotStatus.LOCKED, targetSnapshot.getMemoryVolume(), getCompensationContext());
}
#end_block

#method_before
private void restoreVmConfigFromSnapshot() {
    snapshotDao.updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    snapshotDao.updateStatus(snapshotDao.getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    getSnapshotsManager().attempToRestoreVmConfigurationFromSnapshot(getVm(), getDstSnapshot(), snapshotDao.getId(getVm().getId(), SnapshotType.ACTIVE), getImagesToPreview(), getCompensationContext(), getCurrentUser(), new VmInterfaceManager(getMacPool()), isRestoreMemory(), isLeaseInfoUpdateNeeded());
}
#method_after
private void restoreVmConfigFromSnapshot() {
    snapshotDao.updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    snapshotDao.updateStatus(snapshotDao.getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    Guid activeSnapshotLeaseDomainId = null;
    if (isLeaseDomainIdUpdateNeeded()) {
        activeSnapshotLeaseDomainId = getVm().getStaticData().getLeaseStorageDomainId();
    }
    getSnapshotsManager().attempToRestoreVmConfigurationFromSnapshot(getVm(), getDstSnapshot(), snapshotDao.getId(getVm().getId(), SnapshotType.ACTIVE), getImagesToPreview(), getCompensationContext(), getCurrentUser(), new VmInterfaceManager(getMacPool()), isRestoreMemory());
    if (isLeaseDomainIdUpdateNeeded()) {
        vmStaticDao.updateVmLeaseStorageDomainId(getVm().getId(), activeSnapshotLeaseDomainId);
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = isRestoreMemory();
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    if (log.isInfoEnabled()) {
        log.info("Previewing snapshot {} with the disks:\n{}", getSnapshotName(), filteredImages.stream().map(disk -> String.format("%s (%s) to imageId %s", disk.getName(), disk.getId().toString(), disk.getImageId().toString())).collect(Collectors.joining("\n")));
    }
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        snapshotDao.remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotStatus.LOCKED, SnapshotType.PREVIEW, getVm(), true, previousActiveSnapshot.getMemoryVolume(), null, null, null, getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), SnapshotStatus.OK, restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, snapshotToBePreviewed.getCreationDate(), images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    // save the destination lease domain id and the required lease action in order to use again in endSuccessfully
    if (getDstSnapshot().getVmConfiguration() != null) {
        getParameters().setDstLeaseDomainId(OvfUtils.fetchLeaseDomainId(getDstSnapshot().getVmConfiguration()));
    }
    getParameters().setLeaseAction(determineLeaseAction(getVm().getStaticData().getLeaseStorageDomainId(), getParameters().getDstLeaseDomainId()));
    if (!filteredImages.isEmpty()) {
        vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (actionReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
                    } else if (actionReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(actionReturnValue.getFault().getError(), actionReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (getParameters().getLeaseAction() == LeaseAction.CREATE_NEW_LEASE) {
                    if (!addVmLease(getParameters().getDstLeaseDomainId(), getVm().getId(), false)) {
                        log.error("Failed to create lease for VM '{}' on storage domain '{}'", getVm().getName(), getParameters().getDstLeaseDomainId());
                        throw new EngineException(EngineError.FailedToCreateLease);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(ActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    } else {
        // if there are no disks to restore, no compensation context is saved and the VM Configuration
        // (including clusterCompatibilityVersionOrigin) is already restored at this point. Otherwise,
        // if disks are being restored, the VM Configuration is restored later in endSuccessfully()
        updateClusterCompatibilityVersionToOldCluster(true);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = isRestoreMemory();
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    if (log.isInfoEnabled()) {
        log.info("Previewing snapshot {} with the disks:\n{}", getSnapshotName(), filteredImages.stream().map(disk -> String.format("%s (%s) to imageId %s", disk.getName(), disk.getId().toString(), disk.getImageId().toString())).collect(Collectors.joining("\n")));
    }
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        snapshotDao.remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotStatus.LOCKED, SnapshotType.PREVIEW, getVm(), true, previousActiveSnapshot.getMemoryVolume(), null, null, null, getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), SnapshotStatus.OK, restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, snapshotToBePreviewed.getCreationDate(), images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    initializeSnapshotsLeasesParams();
    if (!filteredImages.isEmpty()) {
        vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (actionReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
                    } else if (actionReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(actionReturnValue.getFault().getError(), actionReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (getParameters().getLeaseAction() == LeaseAction.CREATE_NEW_LEASE) {
                    if (!addVmLease(getParameters().getDstLeaseDomainId(), getVm().getId(), false)) {
                        log.error("Failed to create lease for VM '{}' on storage domain '{}'", getVm().getName(), getParameters().getDstLeaseDomainId());
                        throw new EngineException(EngineError.FailedToCreateLease);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(ActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    } else {
        // if there are no disks to restore, no compensation context is saved and the VM Configuration
        // (including clusterCompatibilityVersionOrigin) is already restored at this point. Otherwise,
        // if disks are being restored, the VM Configuration is restored later in endSuccessfully()
        updateClusterCompatibilityVersionToOldCluster(true);
    }
    setSucceeded(true);
}
#end_block

#method_before
private LeaseAction determineLeaseAction(Guid srcLeaseDomainId, Guid dstLeaseDomainId) {
    // if the current VM snapshot has a lease
    if (srcLeaseDomainId != null && getVm().getLeaseInfo() != null) {
        // both snapshots have leases
        if (dstLeaseDomainId != null) {
            return srcLeaseDomainId.equals(dstLeaseDomainId) ? LeaseAction.UPDATE_LEASE_INFO : LeaseAction.CREATE_NEW_LEASE;
        }
    }
    return dstLeaseDomainId != null ? LeaseAction.CREATE_NEW_LEASE : LeaseAction.DO_NOTHING;
}
#method_after
private LeaseAction determineLeaseAction(Guid srcLeaseDomainId, Guid dstLeaseDomainId) {
    // if the current VM snapshot has a lease
    if (srcLeaseDomainId != null && getVm().getLeaseInfo() != null) {
        // if both snapshots have leases - use the active snapshot lease
        if (dstLeaseDomainId != null) {
            return srcLeaseDomainId.equals(dstLeaseDomainId) ? LeaseAction.UPDATE_LEASE_INFO : LeaseAction.UPDATE_LEASE_INFO_AND_LEASE_DOMAIN_ID;
        }
    }
    return dstLeaseDomainId != null ? LeaseAction.CREATE_NEW_LEASE : LeaseAction.DO_NOTHING;
}
#end_block

#method_before
private List<DiskImage> getImagesToPreview() {
    if (imagesToPreview == null) {
        imagesToPreview = getParameters().getDisks() != null ? getParameters().getDisks() : diskImageDao.getAllSnapshotsForVmSnapshot(getDstSnapshot().getId());
        // Filter out shareable/nonsnapable disks
        List<CinderDisk> CinderImagesToPreview = DisksFilter.filterCinderDisks(imagesToPreview);
        imagesToPreview = DisksFilter.filterImageDisks(imagesToPreview, ONLY_NOT_SHAREABLE, ONLY_SNAPABLE);
        imagesToPreview.addAll(CinderImagesToPreview);
    }
    return imagesToPreview;
}
#method_after
private List<DiskImage> getImagesToPreview() {
    if (imagesToPreview == null) {
        if (getParameters().getImageIds() != null) {
            imagesToPreview = getParameters().getImageIds().stream().map(diskImageDao::getSnapshotById).collect(Collectors.toList());
        } else {
            imagesToPreview = diskImageDao.getAllSnapshotsForVmSnapshot(getDstSnapshot().getId());
        }
        // Filter out shareable/nonsnapable disks
        List<CinderDisk> CinderImagesToPreview = DisksFilter.filterCinderDisks(imagesToPreview);
        imagesToPreview = DisksFilter.filterImageDisks(imagesToPreview, ONLY_NOT_SHAREABLE, ONLY_SNAPABLE);
        imagesToPreview.addAll(CinderImagesToPreview);
    }
    return imagesToPreview;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.isVmExists()) || !validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId())) || !validate(snapshotsValidator.snapshotVmConfigurationBroken(getDstSnapshot(), getVmName()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    diskImages.addAll(DisksFilter.filterCinderDisks(getVm().getDiskMap().values(), ONLY_PLUGGED));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).existsAndUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(getImagesToPreview());
        if (!validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked()) || !validate(diskImagesToPreviewValidator.diskImagesSnapshotsAttachedToVm(getVmId()))) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        // verify lease storage domain status
        if (getDstSnapshot().getVmConfiguration() != null) {
            storageIds.add(OvfUtils.fetchLeaseDomainId(getDstSnapshot().getVmConfiguration()));
        }
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(getParameters().getDisks());
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    if (isRestoreMemory() && !validateMemoryTakenInSupportedVersion()) {
        return false;
    }
    if (!canRestoreVmConfigFromSnapshot()) {
        return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.isVmExists()) || !validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId())) || !validate(snapshotsValidator.snapshotVmConfigurationBroken(getDstSnapshot(), getVmName()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    diskImages.addAll(DisksFilter.filterCinderDisks(getVm().getDiskMap().values(), ONLY_PLUGGED));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).existsAndUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(getImagesToPreview());
        if (!validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked()) || !validate(diskImagesToPreviewValidator.diskImagesSnapshotsAttachedToVm(getVmId()))) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        // verify lease storage domain status
        if (getDstSnapshot().getVmConfiguration() != null) {
            storageIds.add(OvfUtils.fetchLeaseDomainId(getDstSnapshot().getVmConfiguration()));
        }
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    List<DiskImage> images = null;
    if (getParameters().getImageIds() != null) {
        images = getImagesToPreview();
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(images);
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    if (isRestoreMemory() && !validateMemoryTakenInSupportedVersion()) {
        return false;
    }
    if (!canRestoreVmConfigFromSnapshot()) {
        return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
    }
    return true;
}
#end_block

#method_before
@Override
public Response restore(Action action) {
    action.setAsync(false);
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(parentId, guid);
    if (action.isSetRestoreMemory()) {
        tryBackParams.setRestoreMemory(action.isRestoreMemory());
    }
    if (action.isSetDisks()) {
        Set<Guid> disksGuid = new HashSet<>();
        List<DiskImage> disks = collection.mapDisks(action.getDisks());
        if (disks != null) {
            disksGuid = disks.stream().map(DiskImage::getImageId).collect(Collectors.toSet());
        }
        tryBackParams.setDisks(disksGuid);
    }
    // TODO: if user supplied, override with user value
    tryBackParams.setCorrelationId(RESTORE_SNAPSHOT_CORRELATION_ID);
    Response response = doAction(ActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action, PollingType.JOB);
    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
        RestoreAllSnapshotsParameters restoreParams = new RestoreAllSnapshotsParameters(parentId, SnapshotActionEnum.COMMIT);
        restoreParams.setCorrelationId(RESTORE_SNAPSHOT_CORRELATION_ID);
        Response response2 = doAction(ActionType.RestoreAllSnapshots, restoreParams, action);
        if (response2.getStatus() != Response.Status.OK.getStatusCode()) {
            return response2;
        }
    }
    return response;
}
#method_after
@Override
public Response restore(Action action) {
    action.setAsync(false);
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(parentId, guid);
    if (action.isSetRestoreMemory()) {
        tryBackParams.setRestoreMemory(action.isRestoreMemory());
    }
    if (action.isSetDisks()) {
        List<DiskImage> disks = collection.mapDisks(action.getDisks());
        tryBackParams.setImageIds(getDisksGuidSet(disks));
    }
    // TODO: if user supplied, override with user value
    tryBackParams.setCorrelationId(RESTORE_SNAPSHOT_CORRELATION_ID);
    Response response = doAction(ActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action, PollingType.JOB);
    if (response.getStatus() == Response.Status.OK.getStatusCode()) {
        RestoreAllSnapshotsParameters restoreParams = new RestoreAllSnapshotsParameters(parentId, SnapshotActionEnum.COMMIT);
        restoreParams.setCorrelationId(RESTORE_SNAPSHOT_CORRELATION_ID);
        Response response2 = doAction(ActionType.RestoreAllSnapshots, restoreParams, action);
        if (response2.getStatus() != Response.Status.OK.getStatusCode()) {
            return response2;
        }
    }
    return response;
}
#end_block

#method_before
@Override
public Response previewSnapshot(Action action) {
    validateParameters(action, "snapshot.id");
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(guid, asGuid(action.getSnapshot().getId()));
    if (action.isSetRestoreMemory()) {
        tryBackParams.setRestoreMemory(action.isRestoreMemory());
    }
    if (action.isSetDisks()) {
        Set<Guid> disksGuid = new HashSet<>();
        List<DiskImage> disks = getParent().mapDisks(action.getDisks());
        if (disks != null) {
            disksGuid = disks.stream().map(DiskImage::getImageId).collect(Collectors.toSet());
        }
        tryBackParams.setDisks(disksGuid);
    }
    Response response = doAction(ActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action);
    return response;
}
#method_after
@Override
public Response previewSnapshot(Action action) {
    validateParameters(action, "snapshot.id");
    TryBackToAllSnapshotsOfVmParameters tryBackParams = new TryBackToAllSnapshotsOfVmParameters(guid, asGuid(action.getSnapshot().getId()));
    if (action.isSetRestoreMemory()) {
        tryBackParams.setRestoreMemory(action.isRestoreMemory());
    }
    if (action.isSetDisks()) {
        List<DiskImage> disks = getParent().mapDisks(action.getDisks());
        tryBackParams.setImageIds(getDisksGuidSet(disks));
    }
    Response response = doAction(ActionType.TryBackToAllSnapshotsOfVm, tryBackParams, action);
    return response;
}
#end_block

#method_before
private List<DiskImage> getImagesToPreview() {
    if (imagesToPreview == null) {
        List<DiskImage> imagesByGuid = new ArrayList<>();
        if (getParameters().getDisks() != null) {
            for (Guid guid : getParameters().getDisks()) {
                DiskImage image = diskImageDao.getSnapshotById(guid);
                imagesByGuid.add(image);
            }
            imagesToPreview = imagesByGuid;
        } else {
            imagesToPreview = diskImageDao.getAllSnapshotsForVmSnapshot(getDstSnapshot().getId());
        }
        // Filter out shareable/nonsnapable disks
        List<CinderDisk> CinderImagesToPreview = DisksFilter.filterCinderDisks(imagesToPreview);
        imagesToPreview = DisksFilter.filterImageDisks(imagesToPreview, ONLY_NOT_SHAREABLE, ONLY_SNAPABLE);
        imagesToPreview.addAll(CinderImagesToPreview);
    }
    return imagesToPreview;
}
#method_after
private List<DiskImage> getImagesToPreview() {
    if (imagesToPreview == null) {
        if (getParameters().getImageIds() != null) {
            imagesToPreview = getParameters().getImageIds().stream().map(diskImageDao::getSnapshotById).collect(Collectors.toList());
        } else {
            imagesToPreview = diskImageDao.getAllSnapshotsForVmSnapshot(getDstSnapshot().getId());
        }
        // Filter out shareable/nonsnapable disks
        List<CinderDisk> CinderImagesToPreview = DisksFilter.filterCinderDisks(imagesToPreview);
        imagesToPreview = DisksFilter.filterImageDisks(imagesToPreview, ONLY_NOT_SHAREABLE, ONLY_SNAPABLE);
        imagesToPreview.addAll(CinderImagesToPreview);
    }
    return imagesToPreview;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.isVmExists()) || !validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId())) || !validate(snapshotsValidator.snapshotVmConfigurationBroken(getDstSnapshot(), getVmName()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    diskImages.addAll(DisksFilter.filterCinderDisks(getVm().getDiskMap().values(), ONLY_PLUGGED));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).existsAndUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(getImagesToPreview());
        if (!validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked()) || !validate(diskImagesToPreviewValidator.diskImagesSnapshotsAttachedToVm(getVmId()))) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    List<DiskImage> images = null;
    if (getParameters().getDisks() != null) {
        images = getParameters().getDisks().stream().map(diskImageDao::getSnapshotById).collect(Collectors.toList());
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(images);
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    if (isRestoreMemory() && !validateMemoryTakenInSupportedVersion()) {
        return false;
    }
    if (!canRestoreVmConfigFromSnapshot()) {
        return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.isVmExists()) || !validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId())) || !validate(snapshotsValidator.snapshotVmConfigurationBroken(getDstSnapshot(), getVmName()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    diskImages.addAll(DisksFilter.filterCinderDisks(getVm().getDiskMap().values(), ONLY_PLUGGED));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).existsAndUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(getImagesToPreview());
        if (!validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked()) || !validate(diskImagesToPreviewValidator.diskImagesSnapshotsAttachedToVm(getVmId()))) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    List<DiskImage> images = null;
    if (getParameters().getImageIds() != null) {
        images = getImagesToPreview();
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(images);
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    if (isRestoreMemory() && !validateMemoryTakenInSupportedVersion()) {
        return false;
    }
    if (!canRestoreVmConfigFromSnapshot()) {
        return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
    }
    return true;
}
#end_block

#method_before
private void onPreview() {
    Snapshot snapshot = getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    VM vm = getEntity();
    SnapshotModel snapshotModel = (SnapshotModel) getWindow();
    boolean memory = false;
    List<DiskImage> disks;
    Set<Guid> diskImages = new HashSet<>();
    if (snapshotModel.isShowPartialSnapshotWarning()) {
        switch(snapshotModel.getPartialPreviewSnapshotOptions().getSelectedItem()) {
            case preserveActiveDisks:
                // get snapshot disks
                disks = snapshotModel.getDisks();
                // add active disks missed from snapshot
                disks.addAll(imagesSubtract(getVmDisks(), disks));
                diskImages = disks.stream().map(DiskImage::getImageId).collect(Collectors.toSet());
                break;
            case excludeActiveDisks:
                // nothing to do - default behaviour
                break;
            case openCustomPreviewDialog:
                setWindow(null);
                getCustomPreviewCommand().execute();
                return;
        }
    }
    if (snapshotModel.isShowMemorySnapshotWarning()) {
        memory = snapshotModel.getMemory().getEntity();
    }
    runTryBackToAllSnapshotsOfVm(snapshotModel, vm, snapshot, memory, diskImages);
}
#method_after
private void onPreview() {
    Snapshot snapshot = getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    VM vm = getEntity();
    SnapshotModel snapshotModel = (SnapshotModel) getWindow();
    boolean memory = false;
    List<DiskImage> disks;
    Set<Guid> diskImageIds = null;
    if (snapshotModel.isShowPartialSnapshotWarning()) {
        switch(snapshotModel.getPartialPreviewSnapshotOptions().getSelectedItem()) {
            case preserveActiveDisks:
                // get snapshot disks
                disks = snapshotModel.getDisks();
                // add active disks missed from snapshot
                disks.addAll(imagesSubtract(getVmDisks(), disks));
                diskImageIds = disks.stream().map(DiskImage::getImageId).collect(Collectors.toSet());
                break;
            case excludeActiveDisks:
                // nothing to do - default behaviour
                break;
            case openCustomPreviewDialog:
                setWindow(null);
                getCustomPreviewCommand().execute();
                return;
        }
    }
    if (snapshotModel.isShowMemorySnapshotWarning()) {
        memory = snapshotModel.getMemory().getEntity();
    }
    runTryBackToAllSnapshotsOfVm(snapshotModel, vm, snapshot, memory, diskImageIds);
}
#end_block

#method_before
private void onCustomPreview() {
    VM vm = getEntity();
    PreviewSnapshotModel previewSnapshotModel = (PreviewSnapshotModel) getWindow();
    Snapshot snapshot = previewSnapshotModel.getSnapshotModel().getEntity();
    boolean memory = Boolean.TRUE.equals(previewSnapshotModel.getSnapshotModel().getMemory().getEntity());
    List<DiskImage> disks = previewSnapshotModel.getSelectedDisks();
    Set<Guid> diskImages = disks.stream().map(DiskImage::getImageId).collect(Collectors.toSet());
    runTryBackToAllSnapshotsOfVm(previewSnapshotModel, vm, snapshot, memory, diskImages);
}
#method_after
private void onCustomPreview() {
    VM vm = getEntity();
    PreviewSnapshotModel previewSnapshotModel = (PreviewSnapshotModel) getWindow();
    Snapshot snapshot = previewSnapshotModel.getSnapshotModel().getEntity();
    boolean memory = Boolean.TRUE.equals(previewSnapshotModel.getSnapshotModel().getMemory().getEntity());
    List<DiskImage> disks = previewSnapshotModel.getSelectedDisks();
    Set<Guid> diskIds = disks.stream().map(DiskImage::getImageId).collect(Collectors.toSet());
    runTryBackToAllSnapshotsOfVm(previewSnapshotModel, vm, snapshot, memory, diskIds);
}
#end_block

#method_before
private void runTryBackToAllSnapshotsOfVm(final Model model, VM vm, Snapshot snapshot, boolean memory, Set<Guid> disks) {
    if (model != null) {
        model.startProgress();
    }
    Frontend.getInstance().runAction(ActionType.TryBackToAllSnapshotsOfVm, new TryBackToAllSnapshotsOfVmParameters(vm.getId(), snapshot.getId(), memory, disks), result -> {
        if (model != null) {
            model.stopProgress();
        }
        if (result.getReturnValue().getSucceeded()) {
            cancel();
        }
    });
}
#method_after
private void runTryBackToAllSnapshotsOfVm(final Model model, VM vm, Snapshot snapshot, boolean memory, Set<Guid> diskIds) {
    if (model != null) {
        model.startProgress();
    }
    Frontend.getInstance().runAction(ActionType.TryBackToAllSnapshotsOfVm, new TryBackToAllSnapshotsOfVmParameters(vm.getId(), snapshot.getId(), memory, diskIds), result -> {
        if (model != null) {
            model.stopProgress();
        }
        if (result.getReturnValue().getSucceeded()) {
            cancel();
        }
    });
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    // DEPRECATED
    mandatory(host().rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(host().ssh().authenticationMethod());
    mandatory(host().ssh().user().password());
    mandatory(host().ssh().user().userName());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(ssh().authenticationMethod());
    optional(ssh().fingerprint());
    optional(ssh().port());
    optional(ssh().user().password());
    optional(ssh().user().userName());
}
#end_block

#method_before
public void afterRefreshTreatment(boolean succeeded) {
    try {
        synchronized (this) {
            if (succeeded) {
                unrespondedAttempts.set(0);
                setLastUpdate();
                Guid storagePoolId = null;
                ArrayList<VDSDomainsData> domainsList = null;
                try {
                    hostMonitoring.afterRefreshTreatment();
                    // the storage anymore (so there is no sense in updating the domains list in that case).
                    if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                        storagePoolId = cachedVds.getStoragePoolId();
                        domainsList = cachedVds.getDomains();
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
                // synchronized part of code
                if (domainsList != null) {
                    updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
                }
            }
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#method_after
public void afterRefreshTreatment(boolean succeeded) {
    if (!succeeded) {
        lockManager.releaseLock(monitoringLock);
        return;
    }
    try {
        synchronized (this) {
            unrespondedAttempts.set(0);
            setLastUpdate();
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            try {
                hostMonitoring.afterRefreshTreatment();
                // the storage anymore (so there is no sense in updating the domains list in that case).
                if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                    storagePoolId = cachedVds.getStoragePoolId();
                    domainsList = cachedVds.getDomains();
                }
                hostMonitoring = null;
            } catch (IRSErrorException ex) {
                logAfterRefreshFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logAfterRefreshFailureMessage(ex);
                logException(ex);
            }
            // synchronized part of code
            if (domainsList != null) {
                updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#end_block

#method_before
@Override
public void onResponse(Map<String, Object> response) {
    try {
        VDSReturnValue caps = (VDSReturnValue) response.get("result");
        if (caps.getSucceeded()) {
            getHardwareInfo(vds);
        }
        continueRefreshCapabilities(new AtomicBoolean(), vds, oldVDS, caps);
    } catch (Throwable t) {
        onFailure(t);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            resourceManager.getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#method_after
@Override
public void onResponse(Map<String, Object> response) {
    try {
        VDSReturnValue caps = (VDSReturnValue) response.get("result");
        invokeGetHardwareInfo(vds, caps);
        processRefreshCapabilitiesResponse(new AtomicBoolean(), vds, vds.clone(), caps);
    } catch (Throwable t) {
        onFailure(t);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            resourceManager.getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#end_block

#method_before
public void getHardwareInfo(VDS vds) {
    // Verify version capabilities
    Set<Version> hostVersions = null;
    Version clusterCompatibility = vds.getClusterCompatibilityVersion();
    if (// host and an exception will be raised by VDSM.
    (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
        VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
        if (!ret.getSucceeded()) {
            AuditLogable logable = createAuditLogableForHost(vds);
            logable.updateCallStackFromThrowable(ret.getExceptionObject());
            auditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
        }
    }
}
#method_after
public void getHardwareInfo(VDS vds) {
    // Verify version capabilities
    Set<Version> hostVersions = vds.getSupportedClusterVersionsSet();
    Version clusterCompatibility = vds.getClusterCompatibilityVersion();
    // API won't exist for the host and an exception will be raised by VDSM.
    if (hostVersions != null && hostVersions.contains(clusterCompatibility)) {
        VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
        if (!ret.getSucceeded()) {
            AuditLogable logable = createAuditLogableForHost(vds);
            logable.updateCallStackFromThrowable(ret.getExceptionObject());
            auditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
        }
    }
}
#end_block

#method_before
private void updateIteration() {
    if (refreshIteration.equals(NUMBER_HOST_REFRESHES_BEFORE_SAVE)) {
        refreshIteration.set(1);
    } else {
        refreshIteration.incrementAndGet();
    }
}
#method_after
private void updateIteration() {
    if (isTimeToRefreshStatistics()) {
        refreshIteration.set(1);
    } else {
        refreshIteration.incrementAndGet();
    }
}
#end_block

#method_before
public boolean isTimeToRefreshStatistics() {
    return refreshIteration.equals(NUMBER_HOST_REFRESHES_BEFORE_SAVE);
}
#method_after
public boolean isTimeToRefreshStatistics() {
    return refreshIteration.get() == NUMBER_HOST_REFRESHES_BEFORE_SAVE;
}
#end_block

#method_before
public void postProcessRefresh(boolean succeeded) {
    try {
        try {
            moveVDSToMaintenanceIfNeeded();
            saveDataToDb();
            if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                vdsManager.cancelRecoveryJob();
                log.debug("Host '{}' ({}) firing up event.", vds.getName(), vds.getId());
                vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(vds));
            }
        } finally {
            // save all data to db
            saveDataToDb();
        }
    } catch (Throwable t) {
        logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", t);
        log.debug("Exception", t);
    } finally {
        vdsManager.afterRefreshTreatment(succeeded);
    }
}
#method_after
public void postProcessRefresh(boolean succeeded) {
    try {
        try {
            moveVDSToMaintenanceIfNeeded();
            if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                vdsManager.cancelRecoveryJob();
                log.debug("Host '{}' ({}) firing up event.", vds.getName(), vds.getId());
                vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(vds));
            }
        } finally {
            // save all data to db
            saveDataToDb();
        }
    } catch (Throwable t) {
        logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", t);
        log.debug("Exception", t);
    } finally {
        vdsManager.afterRefreshTreatment(succeeded);
    }
}
#end_block

#method_before
private void refreshCapabilities() {
    // refresh dynamic data
    vdsManager.refreshCapabilities(vds, new RefreshCapabilitiesCallback());
}
#method_after
private void refreshCapabilities() {
    // refresh dynamic data
    vdsManager.refreshCapabilities(vds, new RefreshCapabilitiesCallback(vds));
}
#end_block

#method_before
@Override
public void onResponse(Map<String, Object> response) {
    try {
        final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
        VDSReturnValue caps = (VDSReturnValue) response.get("result");
        if (caps.getSucceeded()) {
            vdsManager.getHardwareInfo(vds);
        }
        VDSStatus refreshReturnStatus = vdsManager.continueRefreshCapabilities(processHardwareNeededAtomic, vds, oldVds, caps);
        continueRefreshCapabilities(refreshReturnStatus, processHardwareNeededAtomic);
        refreshVdsRunTimeInfo(false);
    } catch (Throwable t) {
        onFailure(t);
    }
}
#method_after
@Override
public void onResponse(Map<String, Object> response) {
    try {
        final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
        VDSReturnValue caps = (VDSReturnValue) response.get("result");
        vdsManager.invokeGetHardwareInfo(vds, caps);
        VDSStatus refreshReturnStatus = vdsManager.processRefreshCapabilitiesResponse(processHardwareNeededAtomic, vds, oldVds, caps);
        processRefreshCapabilitiesResponse(refreshReturnStatus, processHardwareNeededAtomic);
        refreshVdsRunTimeInfo(false);
    } catch (Throwable t) {
        onFailure(t);
    }
}
#end_block

#method_before
@Override
public void onResponse(Map<String, Object> response) {
    try {
        continueRefreshVdsStats((VDSReturnValue) response.get("result"));
        refreshVdsRunTimeInfo(true);
    } catch (Throwable t) {
        onFailure(t);
    }
}
#method_after
@Override
public void onResponse(Map<String, Object> response) {
    try {
        processRefreshVdsStatsResponse((VDSReturnValue) response.get("result"));
        refreshVdsRunTimeInfo(true);
    } catch (Throwable t) {
        onFailure(t);
    }
}
#end_block

#method_before
private boolean beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    boolean executingAsyncVdsCommand = false;
    if (vdsManager.getbeforeFirstRefresh()) {
        executingAsyncVdsCommand = true;
        vdsManager.refreshCapabilities(vds, new BeforeFirstRefreshTreatmentCallback());
    } else if (isVdsUpOrGoingToMaintenance || vds.getStatus() == VDSStatus.Error) {
        return false;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (vds.getStatus() != VDSStatus.Up) {
        AuditLogable logable = createAuditLogableForHost();
        logable.addCustomValue("HostStatus", vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
    return executingAsyncVdsCommand;
}
#method_after
private boolean beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    boolean executingAsyncVdsCommand = false;
    if (vdsManager.getbeforeFirstRefresh()) {
        executingAsyncVdsCommand = true;
        vdsManager.refreshCapabilities(vds, new BeforeFirstRefreshTreatmentCallback(vds));
    } else if (isVdsUpOrGoingToMaintenance || vds.getStatus() == VDSStatus.Error) {
        return false;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (vds.getStatus() != VDSStatus.Up) {
        AuditLogable logable = createAuditLogableForHost();
        logable.addCustomValue("HostStatus", vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
    return executingAsyncVdsCommand;
}
#end_block

#method_before
@Override
public void onResponse(Map<String, Object> response) {
    boolean succeeded = true;
    try {
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        VDSReturnValue caps = (VDSReturnValue) response.get("result");
        if (caps.getSucceeded()) {
            vdsManager.getHardwareInfo(vds);
        }
        vdsManager.continueRefreshCapabilities(processHardwareCapsNeededTemp, vds, oldVds, caps);
        continueBeforeFirstRefreshTreatment(processHardwareCapsNeededTemp);
        if (vdsManager.isTimeToRefreshStatistics()) {
            saveVdsDynamic |= refreshCommitedMemory(vds, vdsManager.getLastVmsList(), resourceManager);
        }
    } catch (Throwable t) {
        succeeded = false;
        onFailure(t);
    } finally {
        if (succeeded) {
            postProcessRefresh(true);
        }
    }
}
#method_after
@Override
public void onResponse(Map<String, Object> response) {
    boolean succeeded = true;
    try {
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        VDSReturnValue caps = (VDSReturnValue) response.get("result");
        vdsManager.invokeGetHardwareInfo(vds, caps);
        vdsManager.processRefreshCapabilitiesResponse(processHardwareCapsNeededTemp, vds, oldVds, caps);
        processBeforeFirstRefreshTreatmentResponse(processHardwareCapsNeededTemp);
        if (vdsManager.isTimeToRefreshStatistics()) {
            saveVdsDynamic |= refreshCommitedMemory(vds, vdsManager.getLastVmsList(), resourceManager);
        }
    } catch (Throwable t) {
        succeeded = false;
        onFailure(t);
    } finally {
        if (succeeded) {
            postProcessRefresh(true);
        }
    }
}
#end_block

#method_before
public void refresh() {
    boolean releaseLock = true;
    if (lockManager.acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            synchronized (this) {
                refreshCachedVds();
                if (cachedVds == null) {
                    log.error("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for '{}'", getVdsId());
                    return;
                }
                try {
                    updateIteration();
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        releaseLock = false;
                        hostMonitoring = new HostMonitoring(this, cachedVds, monitoringStrategy, resourceManager, dbFacade, auditLogDirector);
                        hostMonitoring.refresh();
                        unrespondedAttempts.set(0);
                        setLastUpdate();
                        afterRefreshTreatment();
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
            }
        } catch (Throwable e) {
            releaseLock = true;
            log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
            log.debug("Exception:", e);
        } finally {
            if (releaseLock) {
                lockManager.releaseLock(monitoringLock);
            }
        }
    }
}
#method_after
public void refresh() {
    boolean releaseLock = true;
    if (lockManager.acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            synchronized (this) {
                refreshCachedVds();
                if (cachedVds == null) {
                    log.error("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for '{}'", getVdsId());
                    return;
                }
                try {
                    updateIteration();
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        releaseLock = false;
                        hostMonitoring = new HostMonitoring(this, cachedVds, monitoringStrategy, resourceManager, dbFacade, auditLogDirector);
                        hostMonitoring.refresh();
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                    releaseLock = true;
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                    releaseLock = true;
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                    releaseLock = true;
                }
            }
        } catch (Throwable e) {
            releaseLock = true;
            log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
            log.debug("Exception:", e);
        } finally {
            if (releaseLock) {
                lockManager.releaseLock(monitoringLock);
            }
        }
    }
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        synchronized (this) {
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            try {
                hostMonitoring.afterRefreshTreatment();
                // the storage anymore (so there is no sense in updating the domains list in that case).
                if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                    storagePoolId = cachedVds.getStoragePoolId();
                    domainsList = cachedVds.getDomains();
                }
                hostMonitoring = null;
            } catch (IRSErrorException ex) {
                logAfterRefreshFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logAfterRefreshFailureMessage(ex);
                logException(ex);
            }
            // synchronized part of code
            if (domainsList != null) {
                updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#method_after
public void afterRefreshTreatment(boolean succeeded) {
    if (!succeeded) {
        lockManager.releaseLock(monitoringLock);
        return;
    }
    try {
        synchronized (this) {
            unrespondedAttempts.set(0);
            setLastUpdate();
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            try {
                hostMonitoring.afterRefreshTreatment();
                // the storage anymore (so there is no sense in updating the domains list in that case).
                if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                    storagePoolId = cachedVds.getStoragePoolId();
                    domainsList = cachedVds.getDomains();
                }
                hostMonitoring = null;
            } catch (IRSErrorException ex) {
                logAfterRefreshFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logAfterRefreshFailureMessage(ex);
                logException(ex);
            }
            // synchronized part of code
            if (domainsList != null) {
                updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = resourceManager.runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    return continueRefreshCapabilities(processHardwareCapsNeeded, vds, oldVDS, caps);
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = resourceManager.runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    return processRefreshCapabilitiesResponse(processHardwareCapsNeeded, vds, oldVDS, caps);
}
#end_block

#method_before
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        postProcessRefresh();
    }
}
#method_after
public void refresh() {
    refreshVdsRunTimeInfo();
}
#end_block

#method_before
public void postProcessRefresh() {
    try {
        if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
            // use this lock in order to allow only one host updating DB and
            // calling UpEvent in a time
            vdsManager.cancelRecoveryJob();
            log.debug("Host '{}' ({}) firing up event.", vds.getName(), vds.getId());
            vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(vds));
        }
        // save all data to db
        saveDataToDb();
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
        log.debug("Exception", ex);
    } finally {
        vdsManager.afterRefreshTreatment();
    }
}
#method_after
public void postProcessRefresh(boolean succeeded) {
    try {
        if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
            // use this lock in order to allow only one host updating DB and
            // calling UpEvent in a time
            vdsManager.cancelRecoveryJob();
            log.debug("Host '{}' ({}) firing up event.", vds.getName(), vds.getId());
            vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(vds));
        }
        // save all data to db
        saveDataToDb();
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
        log.debug("Exception", ex);
    } finally {
        vdsManager.afterRefreshTreatment(succeeded);
    }
}
#end_block

#method_before
public void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = vds.getStatus() == VDSStatus.Up || vds.getStatus() == VDSStatus.PreparingForMaintenance || vds.getStatus() == VDSStatus.Error || vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (vdsManager.isTimeToRefreshStatistics() || vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
                refreshVdsRunTimeInfo(isVdsUpOrGoingToMaintenance);
            }
        } else {
            refreshCapabilities();
        }
    } catch (VDSRecoveringException e) {
        handleVDSRecoveringException(vds, e);
    } catch (ClassCastException cce) {
        handleClassCastException(cce);
    } catch (Throwable t) {
        log.error("Failure to refresh host '{}' runtime info: {}", vds.getName(), t.getMessage());
        log.debug("Exception", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
public void refreshVdsRunTimeInfo() {
    boolean succeeded = false;
    try {
        boolean isVdsUpOrGoingToMaintenance = vds.getStatus() == VDSStatus.Up || vds.getStatus() == VDSStatus.PreparingForMaintenance || vds.getStatus() == VDSStatus.Error || vds.getStatus() == VDSStatus.NonOperational;
        try {
            if (isVdsUpOrGoingToMaintenance) {
                // check if its time for statistics refresh
                if (vdsManager.isTimeToRefreshStatistics() || vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                    refreshVdsStats();
                }
            } else {
                refreshCapabilities();
            }
            refreshVdsRunTimeInfo(isVdsUpOrGoingToMaintenance);
            succeeded = true;
        } catch (VDSRecoveringException e) {
            handleVDSRecoveringException(vds, e);
        } catch (ClassCastException cce) {
            handleClassCastException(cce);
        } catch (Throwable t) {
            log.error("Failure to refresh host '{}' runtime info: {}", vds.getName(), t.getMessage());
            log.debug("Exception", t);
            throw t;
        }
        moveVDSToMaintenanceIfNeeded();
    } catch (Throwable t) {
        throw t;
    } finally {
        postProcessRefresh(succeeded);
    }
}
#end_block

#method_before
private void refreshCapabilities() {
    // refresh dynamic data
    final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
    VDSStatus refreshReturnStatus = vdsManager.refreshCapabilities(processHardwareNeededAtomic, vds);
    continueRefreshCapabilities(refreshReturnStatus, processHardwareNeededAtomic);
}
#method_after
private void refreshCapabilities() {
    // refresh dynamic data
    final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
    VDSStatus refreshReturnStatus = vdsManager.refreshCapabilities(processHardwareNeededAtomic, vds);
    processRefreshCapabilitiesResponse(refreshReturnStatus, processHardwareNeededAtomic);
}
#end_block

#method_before
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vdsManager::refreshVdsStats entered, host='{}'({})", vds.getName(), vds.getId());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    VDSReturnValue statsReturnValue = resourceManager.runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
    continueRefreshVdsStats(statsReturnValue);
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vdsManager::refreshVdsStats entered, host='{}'({})", vds.getName(), vds.getId());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    VDSReturnValue statsReturnValue = resourceManager.runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
    processRefreshVdsStatsResponse(statsReturnValue);
}
#end_block

#method_before
private void beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    if (vdsManager.getbeforeFirstRefresh()) {
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        vdsManager.refreshCapabilities(processHardwareCapsNeededTemp, vds);
        continueBeforeFirstRefreshTreatment(processHardwareCapsNeededTemp);
    } else if (isVdsUpOrGoingToMaintenance || vds.getStatus() == VDSStatus.Error) {
        return;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (vds.getStatus() != VDSStatus.Up) {
        AuditLogable logable = createAuditLogableForHost();
        logable.addCustomValue("HostStatus", vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
}
#method_after
private void beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    if (vdsManager.getbeforeFirstRefresh()) {
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        vdsManager.refreshCapabilities(processHardwareCapsNeededTemp, vds);
        processBeforeFirstRefreshTreatmentResponse(processHardwareCapsNeededTemp);
    } else if (isVdsUpOrGoingToMaintenance || vds.getStatus() == VDSStatus.Error) {
        return;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (vds.getStatus() != VDSStatus.Up) {
        AuditLogable logable = createAuditLogableForHost();
        logable.addCustomValue("HostStatus", vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
}
#end_block

#method_before
public void afterRefreshTreatment(boolean succeeded) {
    try {
        synchronized (this) {
            if (succeeded) {
                unrespondedAttempts.set(0);
                setLastUpdate();
                Guid storagePoolId = null;
                ArrayList<VDSDomainsData> domainsList = null;
                try {
                    hostMonitoring.afterRefreshTreatment();
                    // the storage anymore (so there is no sense in updating the domains list in that case).
                    if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                        storagePoolId = cachedVds.getStoragePoolId();
                        domainsList = cachedVds.getDomains();
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
                // synchronized part of code
                if (domainsList != null) {
                    updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
                }
            }
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#method_after
public void afterRefreshTreatment(boolean succeeded) {
    if (!succeeded) {
        lockManager.releaseLock(monitoringLock);
        return;
    }
    try {
        synchronized (this) {
            unrespondedAttempts.set(0);
            setLastUpdate();
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            try {
                hostMonitoring.afterRefreshTreatment();
                // the storage anymore (so there is no sense in updating the domains list in that case).
                if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                    storagePoolId = cachedVds.getStoragePoolId();
                    domainsList = cachedVds.getDomains();
                }
                hostMonitoring = null;
            } catch (IRSErrorException ex) {
                logAfterRefreshFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logAfterRefreshFailureMessage(ex);
                logException(ex);
            }
            // synchronized part of code
            if (domainsList != null) {
                updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#end_block

#method_before
@Override
public void onResponse(Map<String, Object> response) {
    try {
        VDSReturnValue caps = (VDSReturnValue) response.get("result");
        if (caps.getSucceeded()) {
            getHardwareInfo(vds);
        }
        continueRefreshCapabilities(new AtomicBoolean(), vds, oldVDS, caps);
    } catch (Throwable t) {
        onFailure(t);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            resourceManager.getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#method_after
@Override
public void onResponse(Map<String, Object> response) {
    try {
        VDSReturnValue caps = (VDSReturnValue) response.get("result");
        invokeGetHardwareInfo(vds, caps);
        processRefreshCapabilitiesResponse(new AtomicBoolean(), vds, vds.clone(), caps);
    } catch (Throwable t) {
        onFailure(t);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            resourceManager.getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#end_block

#method_before
public void getHardwareInfo(VDS vds) {
    // Verify version capabilities
    Set<Version> hostVersions = null;
    Version clusterCompatibility = vds.getClusterCompatibilityVersion();
    if (// host and an exception will be raised by VDSM.
    (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
        resourceManager.runVdsCommand(VDSCommandType.GetHardwareInfoAsync, new VdsIdAndVdsVDSCommandParametersBase(vds).withCallback(new HardwareInfoCallback(vds)));
    }
}
#method_after
public void getHardwareInfo(VDS vds) {
    // Verify version capabilities
    Set<Version> hostVersions = vds.getSupportedClusterVersionsSet();
    Version clusterCompatibility = vds.getClusterCompatibilityVersion();
    // API won't exist for the host and an exception will be raised by VDSM.
    if (hostVersions != null && hostVersions.contains(clusterCompatibility)) {
        resourceManager.runVdsCommand(VDSCommandType.GetHardwareInfoAsync, new VdsIdAndVdsVDSCommandParametersBase(vds).withCallback(new HardwareInfoCallback(vds)));
    }
}
#end_block

#method_before
private void updateIteration() {
    if (refreshIteration.equals(NUMBER_HOST_REFRESHES_BEFORE_SAVE)) {
        refreshIteration.set(1);
    } else {
        refreshIteration.incrementAndGet();
    }
}
#method_after
private void updateIteration() {
    if (isTimeToRefreshStatistics()) {
        refreshIteration.set(1);
    } else {
        refreshIteration.incrementAndGet();
    }
}
#end_block

#method_before
public boolean isTimeToRefreshStatistics() {
    return refreshIteration.equals(NUMBER_HOST_REFRESHES_BEFORE_SAVE);
}
#method_after
public boolean isTimeToRefreshStatistics() {
    return refreshIteration.get() == NUMBER_HOST_REFRESHES_BEFORE_SAVE;
}
#end_block

#method_before
@PostConstruct
private void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    populateVdsAndVmsList();
    // Populate the VDS dictionary
    final List<VDS> allVdsList = hostDao.getAll();
    for (VDS curVds : allVdsList) {
        addVds(curVds, true);
    }
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#method_after
@PostConstruct
private void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    populateVdsAndVmsList();
    // Populate the VDS dictionary
    final List<VDS> allVdsList = hostDao.getAll();
    for (VDS curVds : allVdsList) {
        addVds(curVds, true, false);
    }
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
public void addVds(VDS vds, boolean isInternal) {
    VdsManager vdsManager = vdsManagerFactory.create(vds, this);
    if (isInternal) {
        VDSStatus status = vds.getStatus();
        switch(vds.getStatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Connecting:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getStatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.updateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setPendingVcpusCount(0);
        vdsManager.updateDynamicData(vds.getDynamicData());
    }
    vdsManager.scheduleJobs();
    vdsManagersDict.put(vds.getId(), vdsManager);
    log.info("VDS '{}' was added to the Resource Manager", vds.getId());
}
#method_after
public void addVds(VDS vds, boolean isInternal, boolean scheduleJobs) {
    VdsManager vdsManager = vdsManagerFactory.create(vds, this);
    if (isInternal) {
        VDSStatus status = vds.getStatus();
        switch(vds.getStatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Connecting:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getStatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.updateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setPendingVcpusCount(0);
        vdsManager.updateDynamicData(vds.getDynamicData());
    }
    if (scheduleJobs) {
        vdsManager.scheduleJobs();
    }
    vdsManagersDict.put(vds.getId(), vdsManager);
    log.info("VDS '{}' was added to the Resource Manager", vds.getId());
}
#end_block

#method_before
public void afterRefreshTreatment(boolean succeeded) {
    try {
        synchronized (this) {
            if (succeeded) {
                unrespondedAttempts.set(0);
                setLastUpdate();
                Guid storagePoolId = null;
                ArrayList<VDSDomainsData> domainsList = null;
                try {
                    hostMonitoring.afterRefreshTreatment();
                    // the storage anymore (so there is no sense in updating the domains list in that case).
                    if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                        storagePoolId = cachedVds.getStoragePoolId();
                        domainsList = cachedVds.getDomains();
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
                // synchronized part of code
                if (domainsList != null) {
                    updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
                }
            }
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#method_after
public void afterRefreshTreatment(boolean succeeded) {
    if (!succeeded) {
        lockManager.releaseLock(monitoringLock);
        return;
    }
    try {
        synchronized (this) {
            unrespondedAttempts.set(0);
            setLastUpdate();
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            try {
                hostMonitoring.afterRefreshTreatment();
                // the storage anymore (so there is no sense in updating the domains list in that case).
                if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                    storagePoolId = cachedVds.getStoragePoolId();
                    domainsList = cachedVds.getDomains();
                }
                hostMonitoring = null;
            } catch (IRSErrorException ex) {
                logAfterRefreshFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logAfterRefreshFailureMessage(ex);
                logException(ex);
            }
            // synchronized part of code
            if (domainsList != null) {
                updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = resourceManager.runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    return continueRefreshCapabilities(processHardwareCapsNeeded, vds, oldVDS, caps);
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = resourceManager.runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    return processRefreshCapabilitiesResponse(processHardwareCapsNeeded, vds, oldVDS, caps);
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    getBroker().getCapabilities(new GetCapabilitiesVDSCommandCallback());
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    try {
        getBroker().getCapabilities(new GetCapabilitiesVDSCommandCallback());
    } catch (Throwable t) {
        getParameters().getCallback().onFailure(t);
        throw t;
    }
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    getBroker().getVdsStats(new GetStatsVDSCommandCallback());
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    try {
        getBroker().getVdsStats(new GetStatsVDSCommandCallback());
    } catch (Throwable t) {
        getParameters().getCallback().onFailure(t);
        throw t;
    }
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    getBroker().getHardwareInfo(new GetHardwareInfoVDSCommandCallback());
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    try {
        getBroker().getHardwareInfo(new GetHardwareInfoVDSCommandCallback());
    } catch (Throwable t) {
        getParameters().getCallback().onFailure(t);
        throw t;
    }
}
#end_block

#method_before
@Override
public FutureTask<Map<String, Object>> poll() {
    return timeBoundPoll(2, TimeUnit.SECONDS);
}
#method_after
@Deprecated
@Override
public FutureTask<Map<String, Object>> poll() {
    return timeBoundPoll(2, TimeUnit.SECONDS);
}
#end_block

#method_before
@Override
public FutureTask<Map<String, Object>> timeBoundPoll(final long timeout, final TimeUnit unit) {
    final JsonRpcRequest request = new RequestBuilder("Host.ping").build();
    final FutureCallable callable = new FutureCallable(() -> new FutureMap(client, request, timeout, unit, true));
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            return callable.isDone();
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@Deprecated
@Override
public FutureTask<Map<String, Object>> timeBoundPoll(final long timeout, final TimeUnit unit) {
    return timeBoundPollInternal(timeout, unit, "Host.ping");
}
#end_block

#method_before
public StatusOnlyReturn registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    JsonRpcRequest request = new RequestBuilder("Host.registerSecrets").withParameter("secrets", libvirtSecrets).withParameter("clear", clearUnusedSecrets).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#method_after
@Override
public StatusOnlyReturn registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    JsonRpcRequest request = new RequestBuilder("Host.registerSecrets").withParameter("secrets", libvirtSecrets).withParameter("clear", clearUnusedSecrets).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
private void replicateDiskStart() {
    if (Guid.Empty.equals(getParameters().getVdsId())) {
        throw new EngineException(EngineError.down, "VM " + getParameters().getVmId() + " is not running on any VDS");
    }
    StorageType targetType = this.getStorageDomainById(getParameters().getTargetStorageDomainId(), getParameters().getStoragePoolId()).getStorageStaticData().getStorageType();
    Optional<String> diskType = vmInfoBuildUtils.getNetworkDiskType(getVm(), targetType);
    // Start disk migration
    VmReplicateDiskParameters migrationStartParams = new VmReplicateDiskParameters(getParameters().getVdsId(), getParameters().getVmId(), getParameters().getStoragePoolId(), getParameters().getSourceStorageDomainId(), getParameters().getTargetStorageDomainId(), getParameters().getImageGroupID(), getParameters().getDestinationImageId(), diskType.orElse(null));
    VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.VmReplicateDiskStart, migrationStartParams);
    if (!ret.getSucceeded()) {
        log.error("Failed VmReplicateDiskStart (Disk '{}' , VM '{}')", getParameters().getImageGroupID(), getParameters().getVmId());
        throw new EngineException(ret.getVdsError().getCode(), ret.getVdsError().getMessage());
    }
}
#method_after
private void replicateDiskStart() {
    if (Guid.Empty.equals(getParameters().getVdsId())) {
        throw new EngineException(EngineError.down, "VM " + getParameters().getVmId() + " is not running on any VDS");
    }
    StorageType targetType = getDstStorageDomain().getStorageStaticData().getStorageType();
    Optional<String> diskType = vmInfoBuildUtils.getNetworkDiskType(getVm(), targetType);
    // Start disk migration
    VmReplicateDiskParameters migrationStartParams = new VmReplicateDiskParameters(getParameters().getVdsId(), getParameters().getVmId(), getParameters().getStoragePoolId(), getParameters().getSourceStorageDomainId(), getParameters().getTargetStorageDomainId(), getParameters().getImageGroupID(), getParameters().getDestinationImageId(), diskType.orElse(null));
    VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.VmReplicateDiskStart, migrationStartParams);
    if (!ret.getSucceeded()) {
        log.error("Failed VmReplicateDiskStart (Disk '{}' , VM '{}')", getParameters().getImageGroupID(), getParameters().getVmId());
        throw new EngineException(ret.getVdsError().getCode(), ret.getVdsError().getMessage());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean validate = super.validate() && validate(new StorageDomainValidator(getStorageDomain()).isNotBackupDomain());
    if (!validate) {
        auditLogDirector.log(this, AuditLogType.USER_MOVED_DISK_FINISHED_FAILURE);
        return false;
    }
    if (!getVm().isRunningAndQualifyForDisksMigration()) {
        return failValidation(EngineMessage.CANNOT_LIVE_MIGRATE_VM_SHOULD_BE_IN_PAUSED_OR_UP_STATUS);
    }
    setStoragePoolId(getVm().getStoragePoolId());
    if (!validateDestDomainsSpaceRequirements()) {
        return false;
    }
    getReturnValue().setValid(isDiskNotShareable(getParameters().getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(getParameters().getImageId()));
    if (!getReturnValue().isValid()) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return validateCreateAllSnapshotsFromVmCommand() && validate;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (!getVm().isRunningAndQualifyForDisksMigration()) {
        return failValidation(EngineMessage.CANNOT_LIVE_MIGRATE_VM_SHOULD_BE_IN_PAUSED_OR_UP_STATUS);
    }
    setStoragePoolId(getVm().getStoragePoolId());
    if (!validate(new StorageDomainValidator(getDstStorageDomain()).isNotBackupDomain()) || !validateDestDomainsSpaceRequirements()) {
        return false;
    }
    getReturnValue().setValid(isDiskNotShareable(getParameters().getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(getParameters().getImageId()));
    if (!getReturnValue().isValid()) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return validateCreateAllSnapshotsFromVmCommand();
}
#end_block

#method_before
protected boolean validateDestDomainsSpaceRequirements() {
    Guid destDomainId = getParameters().getTargetStorageDomainId();
    DiskImage diskImage = getDiskImageByImageId(getParameters().getImageId());
    Guid storagePoolId = diskImage.getStoragePoolId();
    StorageDomain destDomain = getStorageDomainById(destDomainId, storagePoolId);
    if (!isStorageDomainWithinThresholds(destDomain)) {
        return false;
    }
    List<DiskImage> allImageSnapshots = diskImageDao.getAllSnapshotsForLeaf(diskImage.getImageId());
    diskImage.getSnapshots().addAll(allImageSnapshots);
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator(destDomain);
    if (!validate(storageDomainValidator.hasSpaceForClonedDisks(Collections.singleton(diskImage)))) {
        return false;
    }
    return true;
}
#method_after
protected boolean validateDestDomainsSpaceRequirements() {
    if (!isStorageDomainWithinThresholds(getDstStorageDomain())) {
        return false;
    }
    DiskImage diskImage = getDiskImageByImageId(getParameters().getImageId());
    List<DiskImage> allImageSnapshots = diskImageDao.getAllSnapshotsForLeaf(diskImage.getImageId());
    diskImage.getSnapshots().addAll(allImageSnapshots);
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator(getDstStorageDomain());
    if (!validate(storageDomainValidator.hasSpaceForClonedDisks(Collections.singleton(diskImage)))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean isLunsAlreadyInUse(Set<String> lunIds) {
    // Get LUNs from DB
    List<LUNs> lunsFromDb = lunDao.getAll();
    StringBuilder lunsUsedBySDs = new StringBuilder();
    StringBuilder lunsUsedByDisks = new StringBuilder();
    // LUN is already part of a storage domain
    // LUN is already used by a disk
    lunsFromDb.stream().filter(lun -> lunIds.contains(lun.getLUNId())).forEach(lun -> {
        // LUN is already part of a storage domain
        if (lun.getStorageDomainId() != null) {
            addFormattedLunId(lunsUsedBySDs, lun, LUNs::getStorageDomainName);
        }
        if (lun.getDiskId() != null) {
            addFormattedLunId(lunsUsedByDisks, lun, LUNs::getDiskAlias);
        }
    });
    if (lunsUsedBySDs.length() != 0) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_LUNS_ALREADY_PART_OF_STORAGE_DOMAINS);
        addValidationMessageVariable("lunIds", lunsUsedBySDs.toString());
    }
    if (lunsUsedByDisks.length() != 0) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_LUNS_ALREADY_USED_BY_DISKS);
        addValidationMessageVariable("lunIds", lunsUsedByDisks.toString());
    }
    return lunsUsedBySDs.length() != 0 || lunsUsedByDisks.length() != 0;
}
#method_after
protected boolean isLunsAlreadyInUse(Set<String> lunIds) {
    // Get LUNs from DB
    List<LUNs> lunsFromDb = lunDao.getAll();
    StringBuilder lunsUsedBySDs = new StringBuilder();
    StringBuilder lunsUsedByDisks = new StringBuilder();
    lunsFromDb.stream().filter(lun -> lunIds.contains(lun.getLUNId())).forEach(lun -> {
        // LUN is already part of a storage domain
        if (lun.getStorageDomainId() != null) {
            addFormattedLunId(lunsUsedBySDs, lun.getLUNId(), lun.getStorageDomainName());
        }
        // LUN is already used by a disk
        if (lun.getDiskId() != null) {
            addFormattedLunId(lunsUsedByDisks, lun.getLUNId(), lun.getDiskAlias());
        }
    });
    if (lunsUsedBySDs.length() != 0) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_LUNS_ALREADY_PART_OF_STORAGE_DOMAINS);
        addValidationMessageVariable("lunIds", lunsUsedBySDs.toString());
    }
    if (lunsUsedByDisks.length() != 0) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_LUNS_ALREADY_USED_BY_DISKS);
        addValidationMessageVariable("lunIds", lunsUsedByDisks.toString());
    }
    return lunsUsedBySDs.length() != 0 || lunsUsedByDisks.length() != 0;
}
#end_block

#method_before
protected void addFormattedLunId(StringBuilder sb, LUNs lun, Function<LUNs, String> nameGetter) {
    if (sb.length() != 0) {
        sb.append(", ");
    }
    sb.append(String.format("%1$s (%2$s)", lun.getLUNId(), nameGetter.apply(lun)));
}
#method_after
protected void addFormattedLunId(StringBuilder sb, String lunId, String entityName) {
    if (sb.length() != 0) {
        sb.append(", ");
    }
    sb.append(String.format("%1$s (%2$s)", lunId, entityName));
}
#end_block

#method_before
private void syncGlusterWebhook(VDS vds) {
    try {
        // check if there's a server that's online other that one being added.
        VDS newUpServer = getNewUpServer(vds, vds);
        if (newUpServer == null) {
            log.debug("No alternate up server to sync webhook for server '{}' ", vds.getHostName());
            return;
        }
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.SyncGlusterWebhook, new VdsIdVDSCommandParametersBase(newUpServer.getId()));
        if (!returnValue.getSucceeded()) {
            log.error("Could not sync webhooks to gluster server '{}': {}", vds.getHostName(), returnValue.getExceptionString());
        }
    } catch (Exception e) {
        log.error("Could not sync webhooks to gluster server '{}': {}", vds.getHostName(), e.getMessage());
        log.debug("Exception", e);
    }
}
#method_after
private void syncGlusterWebhook(VDS vds) {
    try {
        // check if there's a server that's online other than the one being added.
        VDS newUpServer = getNewUpServer(vds, vds);
        if (newUpServer == null) {
            log.debug("No alternate up server to sync webhook for server '{}' ", vds.getHostName());
            return;
        }
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.SyncGlusterWebhook, new VdsIdVDSCommandParametersBase(newUpServer.getId()));
        if (!returnValue.getSucceeded()) {
            log.error("Could not sync webhooks to gluster server '{}': {}", vds.getHostName(), returnValue.getExceptionString());
        }
    } catch (Exception e) {
        log.error("Could not sync webhooks to gluster server '{}': {}", vds.getHostName(), e.getMessage());
        log.debug("Exception", e);
    }
}
#end_block

#method_before
private void logRunningAsyncTasks(List<AsyncTask> asyncTasks) {
    String runningTasks = asyncTasks.stream().map(AsyncTask::toString).collect(Collectors.joining(", "));
    log.warn("There are running tasks: '{}'", runningTasks);
}
#method_after
private void logRunningAsyncTasks(List<AsyncTask> asyncTasks) {
    String runningTasks = asyncTasks.stream().map(AsyncTask::toString).collect(Collectors.joining("\n"));
    log.warn("There are running tasks: '{}'", runningTasks);
}
#end_block

#method_before
private void init(VM vm, VmInfoBuildUtils vmInfoBuildUtils, Guid hostId) {
    this.vm = vm;
    this.vmInfoBuildUtils = vmInfoBuildUtils;
    payloadIndex = -1;
    cdRomIndex = -1;
    vnicMetadata = new HashMap<>();
    diskMetadata = new HashMap<>();
    hypervEnabled = vmInfoBuildUtils.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion());
    cdInterface = vmInfoBuildUtils.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    writer = new XmlTextWriter();
    qosCache = new HashMap<>();
    if (hostId != null) {
        hostDevicesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getHostDevices(hostId));
        hostStatisticsSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVdsStatistics(hostId));
        hostNumaNodesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVdsNumaNodes(hostId));
    } else {
        hostDevicesSupplier = new MemoizingSupplier<>(() -> Collections.emptyMap());
        hostStatisticsSupplier = new MemoizingSupplier<>(() -> null);
        hostNumaNodesSupplier = new MemoizingSupplier<>(() -> Collections.emptyList());
    }
    vmNumaNodesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVmNumaNodes(vm));
    isHostedEngine = vm.isHostedEngine();
}
#method_after
private void init(VM vm, VmInfoBuildUtils vmInfoBuildUtils, Guid hostId) {
    this.vm = vm;
    this.vmInfoBuildUtils = vmInfoBuildUtils;
    payloadIndex = -1;
    cdRomIndex = -1;
    vnicMetadata = new HashMap<>();
    diskMetadata = new HashMap<>();
    hypervEnabled = vmInfoBuildUtils.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion());
    cdInterface = vmInfoBuildUtils.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    writer = new XmlTextWriter();
    qosCache = new HashMap<>();
    if (hostId != null) {
        hostDevicesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getHostDevices(hostId));
        hostStatisticsSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVdsStatistics(hostId));
        hostNumaNodesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVdsNumaNodes(hostId));
    } else {
        hostDevicesSupplier = new MemoizingSupplier<>(() -> Collections.emptyMap());
        hostStatisticsSupplier = new MemoizingSupplier<>(() -> null);
        hostNumaNodesSupplier = new MemoizingSupplier<>(() -> Collections.emptyList());
    }
    vmNumaNodesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVmNumaNodes(vm));
}
#end_block

#method_before
private void writePowerManagement() {
    if (vm.getClusterArch() == ArchitectureType.s390x) {
        // s390x doesn't like the pm elements
        return;
    }
    writer.writeStartElement("pm");
    writer.writeStartElement("suspend-to-disk");
    writer.writeAttributeString("enabled", "no");
    writer.writeEndElement();
    writer.writeStartElement("suspend-to-mem");
    writer.writeAttributeString("enabled", "no");
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writePowerManagement() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        // ACPI PM features relevant only on x86
        return;
    }
    writer.writeStartElement("pm");
    writer.writeStartElement("suspend-to-disk");
    writer.writeAttributeString("enabled", "no");
    writer.writeEndElement();
    writer.writeStartElement("suspend-to-mem");
    writer.writeAttributeString("enabled", "no");
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeLease() {
    if (vm.getLeaseStorageDomainId() == null) {
        return;
    }
    writer.writeStartElement("lease");
    writer.writeElement("key", vm.getId().toString());
    writer.writeElement("lockspace", vm.getLeaseStorageDomainId().toString());
    writer.writeStartElement("target");
    Map<String, String> leaseInfo = vm.getStaticData().getLeaseInfo();
    writer.writeAttributeString("offset", leaseInfo.get(VdsProperties.VmLeaseOffset));
    writer.writeAttributeString("path", leaseInfo.get(VdsProperties.VmLeasePath));
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeLease() {
    if (vm.getLeaseStorageDomainId() == null) {
        return;
    }
    writer.writeStartElement("lease");
    writer.writeElement("key", vm.getId().toString());
    writer.writeElement("lockspace", vm.getLeaseStorageDomainId().toString());
    writer.writeStartElement("target");
    Map<String, String> leaseInfo = vm.getLeaseInfo();
    writer.writeAttributeString("offset", leaseInfo.get(VdsProperties.VmLeaseOffset));
    writer.writeAttributeString("path", leaseInfo.get(VdsProperties.VmLeasePath));
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            // so they can be mounted even if storage pool is not connected
            if (isHostedEngine) {
                diskImage.setStoragePoolId(Guid.Empty);
            }
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    // drop to the 'file' case as a fallback.
                    if (volInfo != null) {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            // so they can be mounted even if storage pool is not connected
            if (vm.isHostedEngine()) {
                diskImage.setStoragePoolId(Guid.Empty);
            }
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    // drop to the 'file' case as a fallback.
                    if (volInfo != null) {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        serviceLoader.load(PmHealthCheckManager.class);
        serviceLoader.load(EngineBackupAwarenessManager.class);
        serviceLoader.load(DataCenterCompatibilityChecker.class);
        serviceLoader.load(ResourceManager.class);
        serviceLoader.load(HostDeviceManager.class);
        serviceLoader.load(IrsProxyManager.class);
        serviceLoader.load(OvfDataUpdater.class);
        StoragePoolStatusHandler.init();
        serviceLoader.load(GlusterJobsManager.class);
        resourceManager.get().scheduleJobsForHosts();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        serviceLoader.load(SchedulingManager.class);
        sessionDataContainer.cleanupEngineSessionsOnStartup();
        serviceLoader.load(HostDeviceManager.class);
        serviceLoader.load(DwhHeartBeat.class);
        if (Config.<Boolean>getValue(ConfigValues.AffinityRulesEnforcementManagerEnabled)) {
            serviceLoader.load(AffinityRulesEnforcementManager.class);
        }
        serviceLoader.load(CertificationValidityChecker.class);
        serviceLoader.load(HostUpdatesCheckerService.class);
        serviceLoader.load(IPTablesDeprecationNotifier.class);
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#method_after
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        serviceLoader.load(PmHealthCheckManager.class);
        serviceLoader.load(EngineBackupAwarenessManager.class);
        serviceLoader.load(DataCenterCompatibilityChecker.class);
        serviceLoader.load(ResourceManager.class);
        serviceLoader.load(HostDeviceManager.class);
        serviceLoader.load(IrsProxyManager.class);
        serviceLoader.load(OvfDataUpdater.class);
        StoragePoolStatusHandler.init();
        serviceLoader.load(GlusterJobsManager.class);
        resourceManager.get().scheduleJobsForHosts();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        serviceLoader.load(SchedulingManager.class);
        sessionDataContainer.cleanupEngineSessionsOnStartup();
        serviceLoader.load(DwhHeartBeat.class);
        serviceLoader.load(AsyncTaskManager.class);
        serviceLoader.load(CommandCoordinatorUtil.class);
        serviceLoader.load(CommandCallbacksPoller.class);
        serviceLoader.load(CommandEntityCleanupManager.class);
        if (Config.<Boolean>getValue(ConfigValues.AffinityRulesEnforcementManagerEnabled)) {
            serviceLoader.load(AffinityRulesEnforcementManager.class);
        }
        serviceLoader.load(CertificationValidityChecker.class);
        serviceLoader.load(HostUpdatesCheckerService.class);
        serviceLoader.load(IPTablesDeprecationNotifier.class);
        serviceLoader.load(ExternalNetworkSyncService.class);
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("poll")
public void poll() {
    if (isMonitoringNeeded(vdsManager.getStatus())) {
        VmsListFetcher fetcher = new VmsStatisticsFetcher(vdsManager);
        long fetchTime = System.nanoTime();
        if (fetcher.fetch()) {
            getVmsMonitoring().perform(fetcher.getChangedVms(), fetchTime, vdsManager, true);
            // we only want to monitor vm devices for vms that already exist in the db
            Stream<VdsmVm> vdsmVmsToMonitor = fetcher.getChangedVms().stream().filter(monitoredVm -> monitoredVm.getFirst() != null && monitoredVm.getSecond() != null).map(Pair::getSecond);
            processDevices(vdsmVmsToMonitor, fetchTime);
        } else {
            log.info("Failed to fetch vms info for host '{}' - skipping VMs monitoring.", vdsManager.getVdsName());
        }
    }
}
#method_after
@OnTimerMethodAnnotation("poll")
public void poll() {
    if (isMonitoringNeeded(vdsManager.getStatus())) {
        VmsListFetcher fetcher = new VmsStatisticsFetcher(vdsManager);
        long fetchTime = System.nanoTime();
        if (fetcher.fetch()) {
            getVmsMonitoring().perform(fetcher.getChangedVms(), fetchTime, vdsManager, true);
            Stream<VdsmVm> vdsmVmsToMonitor = filterVmsToDevicesMonitoring(fetcher.getChangedVms());
            processDevices(vdsmVmsToMonitor, fetchTime);
        } else {
            log.info("Failed to fetch vms info for host '{}' - skipping VMs monitoring.", vdsManager.getVdsName());
        }
    }
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    mandatory(snapshot().id());
    optional(restoreMemory());
    optional(restoreLease());
    optional(disks()[COLLECTION].id());
    optional(disks()[COLLECTION].imageId());
    optional(disks()[COLLECTION].snapshot().id());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(snapshot().id());
    optional(restoreMemory());
    optional(lease());
    optional(disks()[COLLECTION].id());
    optional(disks()[COLLECTION].imageId());
    optional(disks()[COLLECTION].snapshot().id());
}
#end_block

#method_before
@Override
public void onValueChange(ValueChangeEvent<String> event) {
    // WebAdminApplicationPlaces. None of the main views will have that character in its place string.
    if (!event.getValue().contains(WebAdminApplicationPlaces.SUB_TAB_PREFIX)) {
        // This is a switch to a main view, clear existing parameters
        currentEntityParams.clear();
    }
    super.onValueChange(event);
    if (clientAgentType.isFirefox()) {
        Scheduler.get().scheduleDeferred(() -> {
            // $NON-NLS-1$
            Node favicon = DOM.getElementById("id-link-favicon");
            if (favicon != null) {
                Node parent = favicon.getParentNode();
                favicon.removeFromParent();
                parent.appendChild(favicon);
            }
        });
    }
}
#method_after
@Override
public void onValueChange(ValueChangeEvent<String> event) {
    super.onValueChange(event);
    if (clientAgentType.isFirefox()) {
        Scheduler.get().scheduleDeferred(() -> {
            // $NON-NLS-1$
            Node favicon = DOM.getElementById("id-link-favicon");
            if (favicon != null) {
                Node parent = favicon.getParentNode();
                favicon.removeFromParent();
                parent.appendChild(favicon);
            }
        });
    }
}
#end_block

#method_before
public void setFragmentParameters(Map<String, String> params, boolean newItem) {
    currentEntityParams.clear();
    currentEntityParams.putAll(params);
    Set<FragmentParams> paramNames = new HashSet<>();
    paramNames.addAll(FragmentParams.getParams(currentEntityParams.keySet()));
    PlaceRequest request = new PlaceRequest.Builder().nameToken(getCurrentPlaceRequest().getNameToken()).with(currentEntityParams).build();
    if (newItem) {
        History.newItem(buildHistoryToken(request), false);
    } else {
        History.replaceItem(buildHistoryToken(request), false);
    }
}
#method_after
public void setFragmentParameters(Map<String, String> params, boolean newItem) {
    PlaceRequest request = new PlaceRequest.Builder().nameToken(getCurrentPlaceRequest().getNameToken()).with(params).build();
    if (newItem) {
        History.newItem(buildHistoryToken(request), false);
    } else {
        History.replaceItem(buildHistoryToken(request), false);
    }
}
#end_block

#method_before
protected Map<String, String> getFragmentParamsFromEntity(T item) {
    Map<String, String> result = new HashMap<>();
    result.put(FragmentParams.NAME.getName(), ((Nameable) item).getName());
    return result;
}
#method_after
protected Map<String, String> getFragmentParamsFromEntity(T item) {
    Map<String, String> result = new HashMap<>();
    if (item != null) {
        result.put(FragmentParams.NAME.getName(), ((Nameable) item).getName());
    }
    return result;
}
#end_block

#method_before
@Override
protected void onReveal() {
    super.onReveal();
    getView().resizeToFullHeight();
    // Notify model provider that the tab has been revealed
    modelProvider.onSubTabSelected();
    Object entity = modelProvider.getModel().getEntity();
    if (entity != null) {
        onDetailModelEntityChange(entity);
    }
    if (hasActionPanelPresenterWidget() && getTable() != null) {
        getTable().setActionMenus(getActionPanelPresenterWidget().getActionButtons());
    }
}
#method_after
@Override
protected void onReveal() {
    super.onReveal();
    getView().resizeToFullHeight();
    // Notify model provider that the tab has been revealed
    modelProvider.onSubTabSelected();
    T entity = (T) modelProvider.getModel().getEntity();
    if (entity != null) {
        onDetailModelEntityChange(entity);
    }
    if (hasActionPanelPresenterWidget() && getTable() != null) {
        getTable().setActionMenus(getActionPanelPresenterWidget().getActionButtons());
    }
    placeManager.setFragmentParameters(getFragmentParamsFromEntity(entity), false);
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    getView().setPlaceTransitionHandler(this);
    registerHandler(getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        // Update main model selection
        modelProvider.setSelectedItems(getSelectedItems());
        // Let others know that the table selection has changed
        fireTableSelectionChangeEvent();
    }));
    registerHandler(getEventBus().addHandler(ApplySearchStringEvent.getType(), event -> {
        applySearchString(event.getSearchString());
    }));
    modelProvider.getModel().getPropertyChangedEvent().addListener((event, sender, args) -> {
        // Update search string when 'SearchString' property changes
        if ("SearchString".equals(args.propertyName)) {
            // $NON-NLS-1$
            placeManager.setFragmentParameters(getFragmentParams(modelProvider.getModel().getSearchString()));
        }
    });
    registerHandler(getView().addWindowResizeHandler(e -> {
        if (!resizing) {
            Scheduler.get().scheduleDeferred(() -> {
                getView().resizeToFullHeight();
                resizing = false;
            });
            resizing = true;
        }
    }));
    String searchString = searchStringCollector.getSearchStringPrefix(modelProvider.getModel().getSearchString());
    if (searchString != null) {
        // Someone set search string before we were instantiated, update the search string.
        applySearchString(searchString);
    }
    Scheduler.get().scheduleDeferred(() -> addPluginActionButtons(actionButtonPluginHandler.getButtons(getProxy().getNameToken())));
    registerHandler(getEventBus().addHandler(AddActionButtonEvent.getType(), event -> {
        if (getProxy().getNameToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList);
        }
    }));
    if (hasSearchPanelPresenterWidget()) {
        setInSlot(TYPE_SetSearchPanel, searchPanelPresenterWidget);
    }
    if (hasActionPanelPresenterWidget()) {
        setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
    }
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    getView().setPlaceTransitionHandler(this);
    registerHandler(getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        // Update main model selection
        modelProvider.setSelectedItems(getSelectedItems());
        // Let others know that the table selection has changed
        fireTableSelectionChangeEvent();
    }));
    registerHandler(getEventBus().addHandler(ApplySearchStringEvent.getType(), event -> {
        applySearchString(event.getSearchString());
    }));
    modelProvider.getModel().getPropertyChangedEvent().addListener((event, sender, args) -> {
        // Update search string when 'SearchString' property changes
        if ("SearchString".equals(args.propertyName)) {
            // $NON-NLS-1$
            placeManager.setFragmentParameters(getFragmentParameters(modelProvider.getModel().getSearchString()));
        }
    });
    registerHandler(getView().addWindowResizeHandler(e -> {
        if (!resizing) {
            Scheduler.get().scheduleDeferred(() -> {
                getView().resizeToFullHeight();
                resizing = false;
            });
            resizing = true;
        }
    }));
    String searchString = searchStringCollector.getSearchStringPrefix(modelProvider.getModel().getSearchString());
    if (searchString != null) {
        // Someone set search string before we were instantiated, update the search string.
        applySearchString(searchString);
    }
    Scheduler.get().scheduleDeferred(() -> addPluginActionButtons(actionButtonPluginHandler.getButtons(getProxy().getNameToken())));
    registerHandler(getEventBus().addHandler(AddActionButtonEvent.getType(), event -> {
        if (getProxy().getNameToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList);
        }
    }));
    if (hasSearchPanelPresenterWidget()) {
        setInSlot(TYPE_SetSearchPanel, searchPanelPresenterWidget);
    }
    if (hasActionPanelPresenterWidget()) {
        setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
    }
}
#end_block

#method_before
public void applySearchString(String searchString) {
    if (modelProvider.getModel() instanceof SearchableListModel) {
        @SuppressWarnings("unchecked")
        SearchableListModel<?, ? extends EntityModel<?>> listModel = modelProvider.getModel();
        if (StringHelper.isNotNullOrEmpty(searchString) && searchString.startsWith(listModel.getDefaultSearchString())) {
            placeManager.setFragmentParameters(getFragmentParams(searchString), false);
            // search string for this model found.
            listModel.setSearchString(searchString);
            listModel.getSearchCommand().execute();
        }
    }
}
#method_after
public void applySearchString(String searchString) {
    if (modelProvider.getModel() instanceof SearchableListModel) {
        @SuppressWarnings("unchecked")
        SearchableListModel<?, ? extends EntityModel<?>> listModel = modelProvider.getModel();
        if (StringHelper.isNotNullOrEmpty(searchString) && searchString.startsWith(listModel.getDefaultSearchString())) {
            placeManager.setFragmentParameters(getFragmentParameters(searchString), false);
            // search string for this model found.
            listModel.setSearchString(searchString);
            listModel.getSearchCommand().execute();
        }
    }
}
#end_block

#method_before
@Before
public void setUp() {
    Provider provider = new Provider();
    provider.setType(ProviderType.EXTERNAL_NETWORK);
    provider.setId(PROVIDER_ID);
    when(providerDao.get(PROVIDER_ID)).thenReturn(provider);
    when(providerProxyFactory.create(provider)).thenReturn(providerProxy);
    when(providerProxy.getAll()).thenReturn(getProviderNetworks());
    when(networkDao.getAllForProvider(PROVIDER_ID)).thenReturn(getDbNetworks());
    when(clusterDao.getAllClustersByDefaultNetworkProviderId(PROVIDER_ID)).thenReturn(getClusterList());
    when(vnicProfileDao.getAllForNetwork(NETWORK_ID)).thenReturn(Collections.emptyList());
    when(vmDao.getAllForNetwork(OBSOLETE_EXTERNAL_ID)).thenReturn(Collections.emptyList());
    ActionReturnValue returnValue = new ActionReturnValue();
    returnValue.setSucceeded(true);
    when(backend.runInternalAction(eq(ActionType.RemoveNetwork), any(), any())).thenReturn(returnValue);
    when(backend.runInternalAction(eq(ActionType.ImportExternalNetwork), any(), any())).thenReturn(getImportNetworkReturnValue());
    when(networkHelper.attachNetworkToClusters(eq(NETWORK_ID), any())).thenReturn(returnValue);
}
#method_after
@Before
public void setUp() {
    when(providerProxyFactory.create(getProvider())).thenReturn(providerProxy);
    when(providerProxy.getAll()).thenReturn(getProviderNetworks());
    when(networkDao.getAllForProvider(PROVIDER_ID)).thenReturn(getDbNetworks());
    when(clusterDao.getAllClustersByDefaultNetworkProviderId(PROVIDER_ID)).thenReturn(getClusterList());
    when(vnicProfileDao.getAllForNetwork(NETWORK_ID)).thenReturn(Collections.emptyList());
    when(vmDao.getAllForNetwork(OBSOLETE_EXTERNAL_ID)).thenReturn(Collections.emptyList());
    ActionReturnValue returnValue = new ActionReturnValue();
    returnValue.setSucceeded(true);
    when(backend.runInternalAction(eq(ActionType.RemoveNetwork), any(), any())).thenReturn(returnValue);
    when(backend.runInternalAction(eq(ActionType.ImportExternalNetwork), any(), any())).thenReturn(getImportNetworkReturnValue());
    when(networkHelper.attachNetworkToClusters(eq(NETWORK_ID), any())).thenReturn(returnValue);
}
#end_block

#method_before
@Test
public void testSyncSuccess() {
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    command.executeCommand();
    assertTrue(command.getReturnValue().getSucceeded());
    verifyCalls();
}
#method_after
@Test
public void testSyncSuccess() {
    setupProviderDao(getProvider());
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    command.executeCommand();
    assertTrue(command.getReturnValue().getSucceeded());
    verifyCalls();
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (getProviderId() == null) {
        return null;
    }
    Map<String, Pair<String, String>> locks = Collections.singletonMap(getProviderId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.NETWORK, EngineMessage.ACTION_TYPE_FAILED_NETWORK_IS_USED));
    return locks;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return networkLocking.getNetworkProviderLock(getProviderId());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try (EngineLock lock = acquireNetworkProviderLock()) {
        NetworkProviderProxy proxy = providerProxyFactory.create(getProvider());
        List<Network> providedNetworks = proxy.getAll();
        Set<String> providedNetworkIds = externalIds(providedNetworks);
        List<Network> providerNetworksInDb = networkDao.getAllForProvider(getProvider().getId());
        List<Cluster> clusters = clusterDao.getAllClustersByDefaultNetworkProviderId(getProvider().getId());
        Set<Guid> dataCenterIds = clusters.stream().map(Cluster::getStoragePoolId).collect(Collectors.toSet());
        for (Guid dataCenterId : dataCenterIds) {
            List<Network> providerNetworksInDataCenter = providerNetworksInDb.stream().filter(network -> dataCenterId.equals(network.getDataCenterId())).collect(Collectors.toList());
            providerNetworksInDataCenter.stream().filter(network -> !providedNetworkIds.contains(network.getProvidedBy().getExternalId())).forEach(network -> removeNetwork(network.getId()));
            Set<String> networksInDataCenterExternalIds = externalIds(providerNetworksInDataCenter);
            List<Guid> clusterInDataCenterIds = clusters.stream().filter(cluster -> dataCenterId.equals(cluster.getStoragePoolId())).map(Cluster::getId).collect(Collectors.toList());
            for (Network network : providedNetworks) {
                if (!networksInDataCenterExternalIds.contains(network.getProvidedBy().getExternalId())) {
                    ActionReturnValue importReturnValue = importNetwork(dataCenterId, network);
                    if (importReturnValue.getSucceeded()) {
                        network.setId(importReturnValue.getActionReturnValue());
                        propagateReturnValue(networkHelper.attachNetworkToClusters(network.getId(), clusterInDataCenterIds));
                    }
                }
            }
        }
        setSucceeded(!errorOccurred);
    }
}
#method_after
@Override
protected void executeCommand() {
    NetworkProviderProxy proxy = providerProxyFactory.create(getProvider());
    List<Network> providedNetworks = proxy.getAll();
    Set<String> providedNetworkIds = externalIds(providedNetworks);
    List<Network> providerNetworksInDb = networkDao.getAllForProvider(getProvider().getId());
    List<Cluster> clusters = clusterDao.getAllClustersByDefaultNetworkProviderId(getProvider().getId());
    Set<Guid> dataCenterIds = clusters.stream().map(Cluster::getStoragePoolId).collect(Collectors.toSet());
    for (Guid dataCenterId : dataCenterIds) {
        List<Network> providerNetworksInDataCenter = providerNetworksInDb.stream().filter(network -> dataCenterId.equals(network.getDataCenterId())).collect(Collectors.toList());
        providerNetworksInDataCenter.stream().filter(network -> !providedNetworkIds.contains(network.getProvidedBy().getExternalId())).forEach(network -> removeNetwork(network.getId()));
        Set<String> networksInDataCenterExternalIds = externalIds(providerNetworksInDataCenter);
        List<Guid> clusterInDataCenterIds = clusters.stream().filter(cluster -> dataCenterId.equals(cluster.getStoragePoolId())).map(Cluster::getId).collect(Collectors.toList());
        for (Network network : providedNetworks) {
            if (!networksInDataCenterExternalIds.contains(network.getProvidedBy().getExternalId())) {
                ActionReturnValue importReturnValue = importNetwork(dataCenterId, network);
                if (importReturnValue.getSucceeded()) {
                    network.setId(importReturnValue.getActionReturnValue());
                    propagateReturnValue(networkHelper.attachNetworkToClusters(network.getId(), clusterInDataCenterIds));
                }
            }
        }
    }
    setSucceeded(!errorOccurred);
}
#end_block

#method_before
private ActionReturnValue importNetwork(Guid dataCenterId, Network network) {
    ImportExternalNetworkParameters parameters = new ImportExternalNetworkParameters(network.getProvidedBy().getProviderId(), network.getProvidedBy().getExternalId(), dataCenterId, true, false);
    return propagateReturnValue(runInternalAction(ActionType.ImportExternalNetwork, parameters));
}
#method_after
private ActionReturnValue importNetwork(Guid dataCenterId, Network network) {
    ImportExternalNetworkParameters parameters = new ImportExternalNetworkParameters(network.getProvidedBy().getProviderId(), network.getProvidedBy().getExternalId(), dataCenterId, true, false);
    return propagateReturnValue(runInternalAction(ActionType.ImportExternalNetwork, parameters, ExecutionHandler.createInternalJobContext()));
}
#end_block

#method_before
private void removeNetwork(Guid networkId) {
    disconnectVms(networkId);
    propagateReturnValue(runInternalAction(ActionType.RemoveNetwork, new RemoveNetworkParameters(networkId, false)));
}
#method_after
private void removeNetwork(Guid networkId) {
    disconnectVms(networkId);
    propagateReturnValue(runInternalAction(ActionType.RemoveNetwork, new RemoveNetworkParameters(networkId, false), ExecutionHandler.createInternalJobContext()));
}
#end_block

#method_before
private void disconnectVms(Guid networkId) {
    Map<Guid, VnicProfile> profiles = vnicProfileDao.getAllForNetwork(networkId).stream().collect(Collectors.toConcurrentMap(VnicProfile::getId, Function.identity()));
    for (VM vm : vmDao.getAllForNetwork(networkId)) {
        vmHandler.updateNetworkInterfacesFromDb(vm);
        for (VmNetworkInterface iface : vm.getInterfaces()) {
            if (profiles.get(iface.getVnicProfileId()) != null) {
                log.warn("External network '{}' disappeared from provider '{}', disconnecting interface '{}' of VM '{}'.", networkId, getProvider().getName(), iface.getName(), vm.getName());
                iface.setVnicProfileId(null);
                iface.setPlugged(false);
                propagateReturnValue(runInternalAction(ActionType.UpdateVmInterface, new AddVmInterfaceParameters(vm.getId(), iface)));
            }
        }
    }
}
#method_after
private void disconnectVms(Guid networkId) {
    Map<Guid, VnicProfile> profiles = vnicProfileDao.getAllForNetwork(networkId).stream().collect(Collectors.toConcurrentMap(VnicProfile::getId, Function.identity()));
    for (VM vm : vmDao.getAllForNetwork(networkId)) {
        vmHandler.updateNetworkInterfacesFromDb(vm);
        for (VmNetworkInterface iface : vm.getInterfaces()) {
            if (profiles.get(iface.getVnicProfileId()) != null) {
                log.warn("External network '{}' disappeared from provider '{}', disconnecting interface '{}' of VM '{}'.", networkId, getProvider().getName(), iface.getName(), vm.getName());
                iface.setVnicProfileId(null);
                iface.setPlugged(false);
                propagateReturnValue(runInternalAction(ActionType.UpdateVmInterface, new AddVmInterfaceParameters(vm.getId(), iface), ExecutionHandler.createInternalJobContext()));
            }
        }
    }
}
#end_block

#method_before
private boolean externalNetworkValid(AddNetworkValidator validator) {
    ProviderValidator providerValidator = new ProviderValidator(providerDao.get(getNetwork().getProvidedBy().getProviderId()));
    return validate(providerValidator.providerIsSet()) && validate(validator.externalNetworkNewInDataCenter()) && validate(validator.externalNetworkIsVmNetwork()) && validate(validator.externalNetworkVlanValid());
}
#method_after
private boolean externalNetworkValid(AddNetworkValidator validator) {
    ProviderValidator providerValidator = new ProviderValidator(providerDao.get(getNetwork().getProvidedBy().getProviderId()));
    return validate(providerValidator.providerIsSet()) && validate(validator.externalNetworkNewInDataCenter()) && validate(validator.externalNetworkIsVmNetwork()) && validate(validator.externalNetworkVlanValid()) && validate(validator.providerPhysicalNetworkValid());
}
#end_block

#method_before
@Override
protected Network getNetwork() {
    if (network == null) {
        network = networkDao.get(getParameters().getId());
    }
    return network;
}
#method_after
@Override
protected Network getNetwork() {
    if (network == null) {
        network = networkDao.get(getNetworkId());
    }
    return network;
}
#end_block

#method_before
@Override
protected boolean validate() {
    NetworkValidator validator = new NetworkValidator(vmDao, networkDao.get(getNetwork().getId()));
    return validate(validator.networkIsSet(getParameters().getId())) && validate(validator.notRemovingManagementNetwork()) && validate(validator.notIscsiBondNetwork()) && validate(validator.networkNotUsedByVms()) && validate(validator.networkNotUsedByTemplates()) && validate(getRemoveExternalNetworkValidationResult());
}
#method_after
@Override
protected boolean validate() {
    NetworkValidator validator = new NetworkValidator(vmDao, getNetwork());
    return validate(validator.networkIsSet(getNetworkId())) && validate(validator.notRemovingManagementNetwork()) && validate(validator.notIscsiBondNetwork()) && validate(validator.networkNotUsedByVms()) && validate(validator.networkNotUsedByTemplates()) && validate(getRemoveExternalNetworkValidationResult());
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (isInternalExecution()) {
        return null;
    }
    return networkLocking.getNetworkProviderLock(getProviderId());
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (getNetwork().isExternal() && !isInternalExecution()) {
        return networkLocking.getNetworkProviderLock(getProviderId());
    } else {
        return null;
    }
}
#end_block

#method_before
public String generateEngineXml(VM vm, String cpuId, String emulatedMachine) {
    vm.setCpuName(cpuId);
    vm.setEmulatedMachine(emulatedMachine);
    return new LibvirtVmXmlBuilder(vm, vmInfoBuildUtils).buildCreateVm();
}
#method_after
private String generateEngineXml(VM vm, String cpuId, String emulatedMachine) {
    vm.setCpuName(cpuId);
    vm.setEmulatedMachine(emulatedMachine);
    return new LibvirtVmXmlBuilder(vm, vmInfoBuildUtils).buildCreateVm();
}
#end_block

#method_before
private void init(VM vm, VmInfoBuildUtils vmInfoBuildUtils, Guid hostId) {
    this.vm = vm;
    this.vmInfoBuildUtils = vmInfoBuildUtils;
    payloadIndex = -1;
    cdRomIndex = -1;
    vnicMetadata = new HashMap<>();
    diskMetadata = new HashMap<>();
    hypervEnabled = vmInfoBuildUtils.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion());
    cdInterface = vmInfoBuildUtils.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    writer = new XmlTextWriter();
    qosCache = new HashMap<>();
    if (hostId != null) {
        hostDevicesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getHostDevices(hostId));
        hostStatisticsSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVdsStatistics(hostId));
        hostNumaNodesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVdsNumaNodes(hostId));
        vmNumaNodesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVmNumaNodes(vm));
    } else {
        hostDevicesSupplier = new MemoizingSupplier<>(() -> Collections.emptyMap());
        hostStatisticsSupplier = new MemoizingSupplier<>(() -> null);
        hostNumaNodesSupplier = new MemoizingSupplier<>(() -> Collections.emptyList());
        vmNumaNodesSupplier = new MemoizingSupplier<>(() -> Collections.emptyList());
    }
}
#method_after
private void init(VM vm, VmInfoBuildUtils vmInfoBuildUtils, Guid hostId) {
    this.vm = vm;
    this.vmInfoBuildUtils = vmInfoBuildUtils;
    payloadIndex = -1;
    cdRomIndex = -1;
    vnicMetadata = new HashMap<>();
    diskMetadata = new HashMap<>();
    hypervEnabled = vmInfoBuildUtils.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion());
    cdInterface = vmInfoBuildUtils.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    writer = new XmlTextWriter();
    qosCache = new HashMap<>();
    if (hostId != null) {
        hostDevicesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getHostDevices(hostId));
        hostStatisticsSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVdsStatistics(hostId));
        hostNumaNodesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVdsNumaNodes(hostId));
    } else {
        hostDevicesSupplier = new MemoizingSupplier<>(() -> Collections.emptyMap());
        hostStatisticsSupplier = new MemoizingSupplier<>(() -> null);
        hostNumaNodesSupplier = new MemoizingSupplier<>(() -> Collections.emptyList());
    }
    vmNumaNodesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVmNumaNodes(vm));
}
#end_block

#method_before
public String buildCreateVm() {
    writeHeader();
    writeName();
    writeId();
    writeMemory();
    writeIoThreads();
    writeMaxMemory();
    writevCpu();
    writeSystemInfo();
    writeClock();
    writePowerEvents();
    writeFeatures();
    boolean numaEnabled = vmInfoBuildUtils.isNumaEnabled(hostNumaNodesSupplier, vmNumaNodesSupplier, vm);
    if (numaEnabled) {
        writeNumaTune();
    }
    writeCpu(numaEnabled);
    writeCpuTune(numaEnabled);
    writeDevices();
    writePowerManagement();
    // note that this must be called after writeDevices to get the serial console, if exists
    writeOs();
    writeMemoryBacking();
    writeMetadata();
    return writer.getStringXML();
}
#method_after
public String buildCreateVm() {
    writeHeader();
    writeName();
    writeId();
    writeMemory();
    writeIoThreads();
    writeMaxMemory();
    writevCpu();
    writeSystemInfo();
    writeClock();
    writePowerEvents();
    writeFeatures();
    boolean numaEnabled = vmInfoBuildUtils.isNumaEnabled(hostNumaNodesSupplier, vmNumaNodesSupplier, vm);
    if (numaEnabled) {
        writeNumaTune();
    }
    writeCpu(numaEnabled || (vm.isHostedEngine() && !vmNumaNodesSupplier.get().isEmpty()));
    writeCpuTune(numaEnabled);
    writeDevices();
    writePowerManagement();
    // note that this must be called after writeDevices to get the serial console, if exists
    writeOs();
    writeMemoryBacking();
    writeMetadata();
    return writer.getStringXML();
}
#end_block

#method_before
@SuppressWarnings("incomplete-switch")
private void writeCpu(boolean numaEnabled) {
    writer.writeStartElement("cpu");
    String cpuType = vm.getCpuName();
    if (vm.isUseHostCpuFlags()) {
        cpuType = "hostPassthrough";
    }
    switch(vm.getClusterArch().getFamily()) {
        case x86:
            writer.writeAttributeString("match", "exact");
            // is this a list of strings??..
            switch(cpuType) {
                case "hostPassthrough":
                    writer.writeAttributeString("mode", "host-passthrough");
                    break;
                case "hostModel":
                    writer.writeAttributeString("mode", "host-model");
                    break;
                default:
                    writer.writeStartElement("model");
                    writer.writeRaw(cpuType);
                    // TODO: features
                    writer.writeEndElement();
                    break;
            }
            break;
        case ppc:
            writer.writeElement("model", cpuType);
    }
    if ((boolean) Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        writer.writeStartElement("topology");
        writer.writeAttributeString("cores", Integer.toString(vm.getCpuPerSocket()));
        writer.writeAttributeString("threads", Integer.toString(vm.getThreadsPerCpu()));
        int vcpus = FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch()) ? VmCpuCountHelper.calcMaxVCpu(vm, vm.getClusterCompatibilityVersion()) : vm.getNumOfCpus();
        writer.writeAttributeString("sockets", String.valueOf(vcpus / vm.getCpuPerSocket() / vm.getThreadsPerCpu()));
        writer.writeEndElement();
    }
    if (numaEnabled) {
        writer.writeStartElement("numa");
        NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodesSupplier.get()).forEach(vmNumaNode -> {
            writer.writeStartElement("cell");
            writer.writeAttributeString("cpus", vmNumaNode.get(VdsProperties.NUMA_NODE_CPU_LIST).toString());
            writer.writeAttributeString("memory", String.valueOf(Integer.parseInt((String) vmNumaNode.get(VdsProperties.VM_NUMA_NODE_MEM)) * 1024));
            if (HugePageUtils.isHugepagesShared(vm.getStaticData())) {
                writer.writeAttributeString("memAccess", "shared");
            }
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (vm.getVmType() == VmType.HighPerformance) {
        writer.writeStartElement("cache");
        writer.writeAttributeString("level", "3");
        writer.writeAttributeString("mode", "emulate");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
@SuppressWarnings("incomplete-switch")
private void writeCpu(boolean addVmNumaNodes) {
    writer.writeStartElement("cpu");
    String cpuType = vm.getCpuName();
    if (vm.isUseHostCpuFlags()) {
        cpuType = "hostPassthrough";
    }
    switch(vm.getClusterArch().getFamily()) {
        case x86:
            writer.writeAttributeString("match", "exact");
            // is this a list of strings??..
            switch(cpuType) {
                case "hostPassthrough":
                    writer.writeAttributeString("mode", "host-passthrough");
                    break;
                case "hostModel":
                    writer.writeAttributeString("mode", "host-model");
                    break;
                default:
                    writer.writeStartElement("model");
                    writer.writeRaw(cpuType);
                    // TODO: features
                    writer.writeEndElement();
                    break;
            }
            break;
        case ppc:
            writer.writeElement("model", cpuType);
    }
    if ((boolean) Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        writer.writeStartElement("topology");
        writer.writeAttributeString("cores", Integer.toString(vm.getCpuPerSocket()));
        writer.writeAttributeString("threads", Integer.toString(vm.getThreadsPerCpu()));
        int vcpus = FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch()) ? VmCpuCountHelper.calcMaxVCpu(vm, vm.getClusterCompatibilityVersion()) : vm.getNumOfCpus();
        writer.writeAttributeString("sockets", String.valueOf(vcpus / vm.getCpuPerSocket() / vm.getThreadsPerCpu()));
        writer.writeEndElement();
    }
    if (addVmNumaNodes) {
        writer.writeStartElement("numa");
        NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodesSupplier.get()).forEach(vmNumaNode -> {
            writer.writeStartElement("cell");
            writer.writeAttributeString("cpus", vmNumaNode.get(VdsProperties.NUMA_NODE_CPU_LIST).toString());
            writer.writeAttributeString("memory", String.valueOf(Integer.parseInt((String) vmNumaNode.get(VdsProperties.VM_NUMA_NODE_MEM)) * 1024));
            if (HugePageUtils.isHugepagesShared(vm.getStaticData())) {
                writer.writeAttributeString("memAccess", "shared");
            }
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (vm.getVmType() == VmType.HighPerformance) {
        writer.writeStartElement("cache");
        writer.writeAttributeString("level", "3");
        writer.writeAttributeString("mode", "emulate");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private static DiskVmElement buildDiskVmElementWithDiskInterfaceFromExternalProvider(Map<String, Object> map, DiskImage image, Guid vmId) {
    DiskVmElement dve = new DiskVmElement(image.getId(), vmId);
    String diskDevName = (String) map.get(VdsProperties.DISK_TARGET_DEV_NAME);
    diskDevName = (diskDevName == null || diskDevName.length() < 3) ? "" : diskDevName.substring(0, 2);
    switch(diskDevName) {
        case "sd":
            dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
            break;
        case "hd":
            dve.setDiskInterface(DiskInterface.IDE);
            break;
        case "vd":
        default:
            dve.setDiskInterface(DiskInterface.VirtIO);
            break;
    }
    return dve;
}
#method_after
private static DiskVmElement buildDiskVmElementWithDiskInterfaceFromExternalProvider(Map<String, Object> map, DiskImage image, Guid vmId) {
    DiskVmElement dve = new DiskVmElement(image.getId(), vmId);
    String diskDevName = (String) map.get(VdsProperties.DISK_TARGET_DEV_NAME);
    diskDevName = (diskDevName == null || diskDevName.length() < 3) ? "" : diskDevName.substring(0, 2);
    switch(diskDevName) {
        case "sd":
            dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
            break;
        case "hd":
            dve.setDiskInterface(DiskInterface.IDE);
            break;
        case "vd":
        default:
            dve.setDiskInterface(DiskInterface.VirtIO);
    }
    return dve;
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, String> vdsmNameMap, Map<String, Object> struct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(struct, VdsProperties.supported_cluster_levels));
    setDnsResolverConfigurationData(vds, struct);
    updateNetworkData(vds, vdsmNameMap, struct);
    updateNumaNodesData(vds, struct);
    vds.setCpuThreads(assignIntValue(struct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(struct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(struct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(struct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(struct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(struct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(struct, VdsProperties.physical_mem_mb));
    vds.setKernelArgs(assignStringValue(struct, VdsProperties.kernel_args));
    vds.setKvmEnabled(assignBoolValue(struct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(struct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(struct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(struct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, struct);
    vds.setSupportedEngines(assignStringValueFromArray(struct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(struct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(struct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, struct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (struct.containsKey(VdsProperties.hooks)) {
        hooksStr = struct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) struct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(struct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(struct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(struct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) struct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    vds.setHostedEngineConfigured(assignBoolValue(struct, VdsProperties.hosted_engine_configured));
    updateAdditionalFeatures(vds, struct);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, String> vdsmNameMap, Map<String, Object> struct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(struct, VdsProperties.supported_cluster_levels));
    setDnsResolverConfigurationData(vds, struct);
    updateNetworkData(vds, vdsmNameMap, struct);
    updateNumaNodesData(vds, struct);
    vds.setCpuThreads(assignIntValue(struct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(struct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(struct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(struct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(struct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(struct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(struct, VdsProperties.physical_mem_mb));
    vds.setKernelArgs(assignStringValue(struct, VdsProperties.kernel_args));
    vds.setKvmEnabled(assignBoolValue(struct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(struct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(struct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(struct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, struct);
    vds.setSupportedEngines(assignStringValueFromArray(struct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(struct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(struct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, struct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (struct.containsKey(VdsProperties.hooks)) {
        hooksStr = struct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) struct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(struct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(struct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(struct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) struct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    vds.setHostedEngineConfigured(assignBoolValue(struct, VdsProperties.hosted_engine_configured));
    updateAdditionalFeatures(vds, struct);
    vds.setKernelFeatures((Map<String, Object>) struct.get(VdsProperties.kernelFeatures));
}
#end_block

#method_before
protected AddDiskParameters buildAddDiskParameters(DiskImage image, boolean isBoot) {
    image.setDiskAlias(renameDiskAlias(getVm().getOrigin(), image.getDiskAlias()));
    AddDiskParameters diskParameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), image);
    diskParameters.setStorageDomainId(getStorageDomainId());
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setStorageDomainId(getParameters().getDestDomainId());
    DiskVmElement dve = image.getDiskVmElementForVm(getVmId()) != null ? image.getDiskVmElementForVm(getVmId()) : new DiskVmElement(image.getId(), getVmId());
    // set for default value in case of non KVM provider type
    if (dve.getDiskInterface() == null || getVm().getOrigin() != OriginType.KVM) {
        dve.setDiskInterface(DiskInterface.VirtIO);
    }
    dve.setBoot(isBoot);
    diskParameters.setDiskVmElement(dve);
    return diskParameters;
}
#method_after
protected AddDiskParameters buildAddDiskParameters(DiskImage image, boolean isBoot) {
    image.setDiskAlias(renameDiskAlias(getVm().getOrigin(), image.getDiskAlias()));
    AddDiskParameters diskParameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), image);
    diskParameters.setStorageDomainId(getStorageDomainId());
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setStorageDomainId(getParameters().getDestDomainId());
    DiskVmElement dve = image.getDiskVmElementForVm(getVmId());
    dve.setBoot(isBoot);
    diskParameters.setDiskVmElement(dve);
    return diskParameters;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    vmListReturn = getBroker().getExternalVmList(getParameters().getUrl(), getParameters().getUsername(), getParameters().getPassword(), getParameters().getNamesOfVms());
    proceedProxyReturnValue();
    List<VM> vms = new ArrayList<>();
    List<VM> notDownVms = new ArrayList<>();
    for (Map<String, Object> map : vmListReturn.vmList) {
        VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(map);
        if (vm != null) {
            vm.setOrigin(getParameters().getOriginType());
            if (vm.getOrigin() == OriginType.KVM && vm.getStaticData().getImages().stream().anyMatch(i -> i.getDiskVmElementForVm(vm.getId()).getDiskInterface() == DiskInterface.VirtIO_SCSI)) {
                VmDeviceCommonUtils.addVirtIoScsiDevice(vm.getStaticData());
            }
            vms.add(vm);
            // identify vms not in Down status
            if (!vm.isDown()) {
                notDownVms.add(vm);
            }
        }
    }
    logNonDownVms(notDownVms);
    setReturnValue(vms);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    vmListReturn = getBroker().getExternalVmList(getParameters().getUrl(), getParameters().getUsername(), getParameters().getPassword(), getParameters().getNamesOfVms());
    proceedProxyReturnValue();
    List<VM> vms = new ArrayList<>();
    List<VM> notDownVms = new ArrayList<>();
    for (Map<String, Object> map : vmListReturn.vmList) {
        VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(map);
        if (vm != null) {
            vm.setOrigin(getParameters().getOriginType());
            if (vm.getOrigin() == OriginType.KVM) {
                if (VmDeviceCommonUtils.isVirtIoScsiDiskInterfaceExists(vm.getStaticData())) {
                    VmDeviceCommonUtils.addVirtIoScsiDevice(vm.getStaticData());
                }
            } else {
                // set default value in case of non KVM provider type
                // since VirtIO interface doesn't require having an appropriate controller
                // so validation will pass. This will anyway be overridden later by virt-v2v OVF.
                VmDeviceCommonUtils.setDiskInterfaceForVm(vm.getStaticData(), DiskInterface.VirtIO);
            }
            vms.add(vm);
            // identify vms not in Down status
            if (!vm.isDown()) {
                notDownVms.add(vm);
            }
        }
    }
    logNonDownVms(notDownVms);
    setReturnValue(vms);
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    if (getParameters().getPollTechnique().equals(POLL)) {
        httpTask = getBroker().poll();
    } else if (getParameters().getPollTechnique().equals(POLL2)) {
        httpTask = getBroker().timeBoundPoll2(2, TimeUnit.SECONDS);
    } else if (getParameters().getPollTechnique().equals(CONFIRM_CONNECTIVITY)) {
        httpTask = getBroker().timeBoundPollConfirmConnectivity(2, TimeUnit.SECONDS);
    }
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    if (getParameters().getPollTechnique().equals(POLL)) {
        httpTask = getBroker().poll();
    } else if (getParameters().getPollTechnique().equals(POLL2)) {
        httpTask = getBroker().timeBoundPoll2(TIMEOUT, TimeUnit.SECONDS);
    } else if (getParameters().getPollTechnique().equals(CONFIRM_CONNECTIVITY)) {
        httpTask = getBroker().timeBoundPollConfirmConnectivity(TIMEOUT, TimeUnit.SECONDS);
    }
}
#end_block

#method_before
public static String mapToJsonUnchecked(Map<String, Object> input) {
    try {
        return mapToJson(input);
    } catch (IOException e) {
        throw new RuntimeException(String.format("Object \"%s\" cannot be serialized to JSON.", e));
    }
}
#method_after
public static String mapToJsonUnchecked(Map<String, Object> input) {
    try {
        return mapToJson(input);
    } catch (IOException e) {
        throw new RuntimeException(String.format("Object \"%s\" cannot be serialized to JSON.", input), e);
    }
}
#end_block

#method_before
public static Map<String, Object> jsonToMapUnchecked(String jsonString) {
    try {
        return jsonToMap(jsonString);
    } catch (IOException e) {
        throw new RuntimeException(String.format("Json string \"%s\" cannot be parsed to a Map.", e));
    }
}
#method_after
public static Map<String, Object> jsonToMapUnchecked(String jsonString) {
    try {
        return jsonToMap(jsonString);
    } catch (IOException e) {
        throw new RuntimeException(String.format("Json string \"%s\" cannot be parsed to a Map.", jsonString), e);
    }
}
#end_block

#method_before
@Override
public Response register(Action action) {
    ImportVmTemplateFromConfParameters params = new ImportVmTemplateFromConfParameters();
    if (action.isSetRegistrationConfiguration()) {
        BackendVnicProfileHelper.validateRegistrationVnicMappings(this, action);
    }
    if (BackendVnicProfileHelper.foundDeprecatedVnicProfileMapping(action)) {
        // This code block is for backward compatibility with {@link VnicProfileMapping}s that are specified outside the registration_configuration code, which
        // is deprecated since 4.2.1 . When these mappings are removed from the ovirt-engine-api-model, this whole code block can be removed as well.
        // In the meantime, if there are {@link VnicProfileMapping}s outside the registration_configuration block and no {@link RegistrationVnicProfileMapping}s
        // inside it, they will be processed and used.
        BackendVnicProfileHelper.validateVnicMappings(this, action);
        Collection<ExternalVnicProfileMapping> vnicProfileMappings = ExternalVnicProfileMappingMapper.mapFromModel(action.getVnicProfileMappings());
        params.setExternalVnicProfileMappings(vnicProfileMappings);
    }
    ExternalRegistrationConfigurationMapper.mapFromModel(action.getRegistrationConfiguration(), params);
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    if (action.isSetCluster()) {
        params.setClusterId(getClusterId(action));
    }
    params.setImagesExistOnTargetStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getTemplate().isSetName()) {
            params.getVmTemplate().setName(action.getTemplate().getName());
        }
    }
    if (action.isSetAllowPartialImport()) {
        params.setAllowPartialImport(action.isAllowPartialImport());
    }
    return doAction(ActionType.ImportVmTemplateFromConfiguration, params, action);
}
#method_after
@Override
public Response register(Action action) {
    ImportVmTemplateFromConfParameters params = new ImportVmTemplateFromConfParameters();
    if (action.isSetRegistrationConfiguration()) {
        BackendVnicProfileHelper.validateRegistrationVnicMappings(this, action);
    }
    if (BackendVnicProfileHelper.foundDeprecatedVnicProfileMapping(action)) {
        // This code block is for backward compatibility with {@link VnicProfileMapping}s that are specified
        // outside the registration_configuration code, which is deprecated since 4.2.1 . When these mappings
        // are removed from the ovirt-engine-api-model, this whole code block can be removed as well.
        // In the meantime, if there are {@link VnicProfileMapping}s outside the registration_configuration
        // block and no {@link RegistrationVnicProfileMapping}s inside it, they will be processed and used.
        BackendVnicProfileHelper.validateVnicMappings(this, action);
        Collection<ExternalVnicProfileMapping> vnicProfileMappings = ExternalVnicProfileMappingMapper.mapFromModel(action.getVnicProfileMappings());
        params.setExternalVnicProfileMappings(vnicProfileMappings);
    }
    ExternalRegistrationConfigurationMapper.mapFromModel(action.getRegistrationConfiguration(), params);
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    if (action.isSetCluster()) {
        params.setClusterId(getClusterId(action));
    }
    params.setImagesExistOnTargetStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getTemplate().isSetName()) {
            params.getVmTemplate().setName(action.getTemplate().getName());
        }
    }
    if (action.isSetAllowPartialImport()) {
        params.setAllowPartialImport(action.isAllowPartialImport());
    }
    return doAction(ActionType.ImportVmTemplateFromConfiguration, params, action);
}
#end_block

#method_before
private static Guid getTargetVnicProfileId(VnicProfileMapping model) {
    return model.isSetTargetVnicProfile() ? Guid.createGuidFromString(model.getTargetVnicProfile().getId()) : // this will set the target vnic profile to <empty>
    null;
}
#method_after
private static Guid getTargetVnicProfileId(VnicProfileMapping model) {
    return model.isSetTargetVnicProfile() ? Guid.createGuidFromString(model.getTargetVnicProfile().getId()) : // this will set the target vnic profile to <empty> (no profile)
    null;
}
#end_block

#method_before
private static Collection<ExternalVnicProfileMapping> mapVnicProfilesMapping(RegistrationVnicProfileMappings model) {
    Collection<ExternalVnicProfileMapping> result = new ArrayList<>(model.getRegistrationVnicProfileMappings().size());
    model.getRegistrationVnicProfileMappings().forEach(regMapping -> {
        result.add(new ExternalVnicProfileMapping(regMapping.getFrom().getNetwork().getName(), regMapping.getFrom().getName(), regMapping.getTo() != null ? new Guid(regMapping.getTo().getId()) : null));
    });
    return result;
}
#method_after
private static Collection<ExternalVnicProfileMapping> mapVnicProfilesMapping(RegistrationVnicProfileMappings model) {
    return model.getRegistrationVnicProfileMappings().stream().map(regMapping -> new ExternalVnicProfileMapping(regMapping.getFrom().getNetwork().getName(), regMapping.getFrom().getName(), regMapping.getTo() != null ? new Guid(regMapping.getTo().getId()) : null)).collect(Collectors.toList());
}
#end_block

#method_before
private static Map<String, Object> mapExternalRoleMapping(RegistrationRoleMappings model) {
    return model.getRegistrationRoleMappings().stream().collect(Collectors.toMap(registrationMap -> registrationMap.isSetFrom() ? registrationMap.getFrom().getName() : null, registrationMap -> registrationMap.isSetTo() ? RoleMapper.map(registrationMap.getTo(), null) : null));
}
#method_after
private static Map<String, String> mapExternalRoleMapping(RegistrationRoleMappings model) {
    return model.getRegistrationRoleMappings().stream().collect(Collectors.toMap(registrationMap -> registrationMap.isSetFrom() ? registrationMap.getFrom().getName() : null, registrationMap -> registrationMap.isSetTo() ? RoleMapper.map(registrationMap.getTo(), null).getName() : null));
}
#end_block

#method_before
@Deprecated
public static void validateVnicMappings(BackendResource br, Action action) {
    if (action.isSetVnicProfileMappings()) {
        br.validateParameters(action.getVnicProfileMappings(), "vnicProfileMappings");
        for (VnicProfileMapping mapping : action.getVnicProfileMappings().getVnicProfileMappings()) {
            // condition of null which means the entries themselves are missing
            if (mapping.getSourceNetworkName() == null) {
                br.validateParameters(mapping, "sourceNetworkName");
            }
            if (mapping.getSourceNetworkProfileName() == null) {
                br.validateParameters(mapping, "sourceNetworkProfileName");
            }
            // check for "<empty>" profile
            if ("".equalsIgnoreCase(mapping.getSourceNetworkName())) {
                mapping.setSourceNetworkName(null);
            }
            if ("".equalsIgnoreCase(mapping.getSourceNetworkProfileName())) {
                mapping.setSourceNetworkProfileName(null);
            }
            // target is optional
            if (mapping.isSetTargetVnicProfile() && mapping.getTargetVnicProfile().isSetId()) {
                // validate guid
                asGuid(mapping.getTargetVnicProfile().getId());
            }
        }
    }
}
#method_after
@Deprecated
public static void validateVnicMappings(BackendResource bs, Action action) {
    if (action.isSetVnicProfileMappings()) {
        bs.validateParameters(action.getVnicProfileMappings(), "vnicProfileMappings");
        for (VnicProfileMapping mapping : action.getVnicProfileMappings().getVnicProfileMappings()) {
            bs.validateParameters(mapping, "sourceNetworkName");
            bs.validateParameters(mapping, "sourceNetworkProfileName");
            bs.validateParameters(mapping, "targetVnicProfile");
            bs.validateParameters(mapping, "targetVnicProfile.id");
            bs.asGuid(mapping.getTargetVnicProfile().getId());
        }
    }
}
#end_block

#method_before
public static void validateRegistrationVnicMappings(BackendResource bs, Action action) {
    if (!action.isSetRegistrationConfiguration()) {
        return;
    }
    if (!action.getRegistrationConfiguration().isSetVnicProfileMappings()) {
        return;
    }
    RegistrationVnicProfileMappings mappings = action.getRegistrationConfiguration().getVnicProfileMappings();
    bs.validateParameters(mappings, "registrationVnicProfileMappings");
    for (RegistrationVnicProfileMapping mapping : mappings.getRegistrationVnicProfileMappings()) {
        bs.validateParameters(mapping, "from");
        // condition of null which means the entries themselves are missing
        if (mapping.getFrom().getName() == null) {
            bs.validateParameters(mapping, "from.name");
        }
        bs.validateParameters(mapping, "from.network");
        if (mapping.getFrom().getNetwork().getName() == null) {
            bs.validateParameters(mapping, "from.network.name");
        }
        // check for "<empty>" profile
        if ("".equalsIgnoreCase(mapping.getFrom().getName())) {
            mapping.getFrom().setName(null);
        }
        if ("".equalsIgnoreCase(mapping.getFrom().getNetwork().getName())) {
            mapping.getFrom().getNetwork().setName(null);
        }
        // target is optional
        if (mapping.isSetTo() && mapping.getTo().isSetId()) {
            // validate guid
            asGuid(mapping.getTo().getId());
        }
    }
}
#method_after
public static void validateRegistrationVnicMappings(BackendResource br, Action action) {
    if (!action.isSetRegistrationConfiguration()) {
        return;
    }
    if (!action.getRegistrationConfiguration().isSetVnicProfileMappings()) {
        return;
    }
    RegistrationVnicProfileMappings mappings = action.getRegistrationConfiguration().getVnicProfileMappings();
    br.validateParameters(mappings, "registrationVnicProfileMappings");
    for (RegistrationVnicProfileMapping mapping : mappings.getRegistrationVnicProfileMappings()) {
        br.validateParameters(mapping, "from");
        // condition of null which means the entries themselves are missing
        if (mapping.getFrom().getName() == null) {
            br.validateParameters(mapping, "from.name");
        }
        br.validateParameters(mapping, "from.network");
        if (mapping.getFrom().getNetwork().getName() == null) {
            br.validateParameters(mapping, "from.network.name");
        }
        // check for 'no profile'
        if ("".equalsIgnoreCase(mapping.getFrom().getName())) {
            // transform empty string to null because 'null' is the internal
            // representation of the engine for 'no profile'
            mapping.getFrom().setName(null);
        }
        if ("".equalsIgnoreCase(mapping.getFrom().getNetwork().getName())) {
            // transform empty string to null because 'null' is the internal
            // representation of the engine for 'no profile'
            mapping.getFrom().getNetwork().setName(null);
        }
        // target is optional
        if (mapping.isSetTo() && mapping.getTo().isSetId()) {
            // validate guid
            asGuid(mapping.getTo().getId());
        }
    }
}
#end_block

#method_before
@Override
public Response register(Action action) {
    ImportVmFromConfParameters params = new ImportVmFromConfParameters();
    if (action.isSetRegistrationConfiguration()) {
        validateClusterMappings(action);
        validateRoleMappings(action);
        validateDomainMappings(action);
        validateAffinityGroupMappings(action);
        validateAffinityLabelMappings(action);
        validateLunMappings(action);
        BackendVnicProfileHelper.validateRegistrationVnicMappings(this, action);
    }
    if (BackendVnicProfileHelper.foundDeprecatedVnicProfileMapping(action)) {
        // This code block is for backward compatibility with {@link VnicProfileMapping}s that are specified outside the registration_configuration code.
        // This specification is deprecated since 4.2.1 .
        // When these mappings are removed from the ovirt-engine-api-model, this whole code block can be removed as well.
        // In the meantime, if there are {@link VnicProfileMapping}s outside the registration_configuration block and no {@link RegistrationVnicProfileMapping}s
        // inside it, they will be processed and used.
        BackendVnicProfileHelper.validateVnicMappings(this, action);
        Collection<ExternalVnicProfileMapping> vnicProfileMappings = ExternalVnicProfileMappingMapper.mapFromModel(action.getVnicProfileMappings());
        params.setExternalVnicProfileMappings(vnicProfileMappings);
        params.setReassignBadMacs(getReassignBadMacs(action));
    }
    ExternalRegistrationConfigurationMapper.mapFromModel(action.getRegistrationConfiguration(), params);
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    if (action.isSetCluster()) {
        params.setClusterId(getClusterId(action));
    }
    params.setImagesExistOnTargetStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getVm().isSetName()) {
            params.getVm().setName(action.getVm().getName());
        }
    }
    if (action.isSetAllowPartialImport()) {
        params.setAllowPartialImport(action.isAllowPartialImport());
    }
    return doAction(ActionType.ImportVmFromConfiguration, params, action);
}
#method_after
@Override
public Response register(Action action) {
    ImportVmFromConfParameters params = new ImportVmFromConfParameters();
    if (action.isSetRegistrationConfiguration()) {
        validateClusterMappings(action);
        validateRoleMappings(action);
        validateDomainMappings(action);
        validateAffinityGroupMappings(action);
        validateAffinityLabelMappings(action);
        validateLunMappings(action);
        BackendVnicProfileHelper.validateRegistrationVnicMappings(this, action);
    }
    if (BackendVnicProfileHelper.foundDeprecatedVnicProfileMapping(action)) {
        // This code block is for backward compatibility with {@link VnicProfileMapping}s that are specified
        // outside the registration_configuration code. This specification is deprecated since 4.2.1 .
        // When these mappings are removed from the ovirt-engine-api-model, this whole code block can be removed
        // as well. In the meantime, if there are {@link VnicProfileMapping}s outside the registration_configuration
        // block and no {@link RegistrationVnicProfileMapping}s inside it, they will be processed and used.
        BackendVnicProfileHelper.validateVnicMappings(this, action);
        Collection<ExternalVnicProfileMapping> vnicProfileMappings = ExternalVnicProfileMappingMapper.mapFromModel(action.getVnicProfileMappings());
        params.setExternalVnicProfileMappings(vnicProfileMappings);
        params.setReassignBadMacs(getReassignBadMacs(action));
    }
    ExternalRegistrationConfigurationMapper.mapFromModel(action.getRegistrationConfiguration(), params);
    params.setContainerId(guid);
    params.setStorageDomainId(parent.getStorageDomainId());
    if (action.isSetCluster()) {
        params.setClusterId(getClusterId(action));
    }
    params.setImagesExistOnTargetStorageDomain(true);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getVm().isSetName()) {
            params.getVm().setName(action.getVm().getName());
        }
    }
    if (action.isSetAllowPartialImport()) {
        params.setAllowPartialImport(action.isAllowPartialImport());
    }
    return doAction(ActionType.ImportVmFromConfiguration, params, action);
}
#end_block

#method_before
protected Snapshots mapCollection(List<org.ovirt.engine.core.common.businessentities.Snapshot> entities) {
    Snapshots snapshots = new Snapshots();
    for (org.ovirt.engine.core.common.businessentities.Snapshot entity : entities) {
        Snapshot snapshot = map(entity, null);
        snapshot = populate(snapshot, entity);
        snapshot = addLinks(snapshot);
        snapshot = addVmConfiguration(entity, snapshot);
        snapshots.getSnapshots().add(snapshot);
    }
    return snapshots;
}
#method_after
protected Snapshots mapCollection(List<org.ovirt.engine.core.common.businessentities.Snapshot> entities) {
    Snapshots snapshots = new Snapshots();
    for (org.ovirt.engine.core.common.businessentities.Snapshot entity : entities) {
        Snapshot snapshot = map(entity, null);
        snapshot = populate(snapshot, entity);
        snapshot = addLinks(snapshot);
        try {
            snapshot = addVmConfiguration(entity, snapshot);
        } catch (WebFaultException wfe) {
            // right before listing the snapshots. See: https://bugzilla.redhat.com/1530603
            if (Response.Status.NOT_FOUND.getStatusCode() == wfe.getResponse().getStatus()) {
                log.warn("Missing VM configuration for snapshot \"{}\". " + "Excluding the snapshot from response.", snapshot.getDescription());
                continue;
            }
            throw wfe;
        }
        snapshots.getSnapshots().add(snapshot);
    }
    return snapshots;
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VM getVmPreview(Snapshot snapshot) {
    org.ovirt.engine.core.common.businessentities.VM vm = null;
    try {
        vm = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, QueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(asGuid(snapshot.getId())), null);
    } catch (WebFaultException wfe) {
        // Return null if vm configuration doesn't exist
        if (Response.Status.NOT_FOUND.getStatusCode() == wfe.getResponse().getStatus()) {
            return null;
        }
    }
    return vm;
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VM getVmPreview(Snapshot snapshot) {
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, QueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(asGuid(snapshot.getId())), null);
    return vm;
}
#end_block

#method_before
private List<NameServer> getNameServers(DnsResolverConfiguration dnsResolverConfiguration) {
    if (dnsResolverConfiguration == null) {
        return Collections.EMPTY_LIST;
    }
    List<NameServer> nameServers = dnsResolverConfiguration.getNameServers();
    if (nameServers == null || nameServers.isEmpty()) {
        return Collections.EMPTY_LIST;
    }
    return nameServers;
}
#method_after
private List<NameServer> getNameServers(DnsResolverConfiguration dnsResolverConfiguration) {
    if (dnsResolverConfiguration == null) {
        return Collections.emptyList();
    }
    List<NameServer> nameServers = dnsResolverConfiguration.getNameServers();
    if (nameServers == null || nameServers.isEmpty()) {
        return Collections.emptyList();
    }
    return nameServers;
}
#end_block

#method_before
@Override
protected boolean validate() {
    NetworkValidator validator = new NetworkValidator(vmDao, networkDao.get(getNetworkId()));
    return validate(validator.networkIsSet(getNetworkId())) && validate(validator.notRemovingManagementNetwork()) && validate(validator.notIscsiBondNetwork()) && validate(validator.networkNotUsedByVms()) && validate(validator.networkNotUsedByTemplates()) && validate(getRemoveExternalNetworkValidationResult());
}
#method_after
@Override
protected boolean validate() {
    NetworkValidator validator = new NetworkValidator(vmDao, getNetwork());
    return validate(validator.networkIsSet(getNetworkId())) && validate(validator.notRemovingManagementNetwork()) && validate(validator.notIscsiBondNetwork()) && validate(validator.networkNotUsedByVms()) && validate(validator.networkNotUsedByTemplates()) && validate(getRemoveExternalNetworkValidationResult());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (isImagesAlreadyOnTarget()) {
        if (!validateExternalVnicProfileMapping()) {
            return false;
        }
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(vmFromConfiguration, ovfEntityData))) {
            return false;
        }
        if (!validate(importValidator.validateDiskNotAlreadyExistOnDB(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistForUnregisteredEntity(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistsForMemoryDisks(getVm().getSnapshots(), getParameters().isAllowPartialImport(), failedDisksToImportForAuditLog))) {
            return false;
        }
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (isImagesAlreadyOnTarget()) {
        if (!validateExternalVnicProfileMapping()) {
            return false;
        }
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(ovfEntityData))) {
            return false;
        }
        if (!validate(importValidator.validateDiskNotAlreadyExistOnDB(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistForUnregisteredEntity(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistsForMemoryDisks(getVm().getSnapshots(), getParameters().isAllowPartialImport(), failedDisksToImportForAuditLog))) {
            return false;
        }
        removeInvalidAffinityGroups(importValidator);
        removeInvalidAffinityLabels(importValidator);
        removeInavlidUsers(importValidator);
        removeInavlidRoles(importValidator);
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return true;
}
#end_block

#method_before
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmFromConfiguration.getId(), getParameters().getClusterMap());
                if (cluster != null) {
                    getParameters().setClusterId(cluster.getId());
                }
            }
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setAffinityGroups(fullEntityOvfData.getAffinityGroups());
            getParameters().setAffinityLabels(fullEntityOvfData.getAffinityLabels());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            // Note: The VM's OVF does not preserve the username and password for the LUN's connection.
            // Therefore to achieve a simple VM registration the iSCSI storage server should not use
            // credentials, although if the user will use the mapping attribute, one can set the credentials through
            // there.
            drMappingHelper.mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()), getParameters().getExternalLunMap());
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmFromConfiguration.getId(), getParameters().getClusterMap());
                if (cluster != null) {
                    getParameters().setClusterId(cluster.getId());
                }
            }
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            // Note: The VM's OVF does not preserve the username and password for the LUN's connection.
            // Therefore to achieve a simple VM registration the iSCSI storage server should not use
            // credentials, although if the user will use the mapping attribute, one can set the credentials through
            // there.
            drMappingHelper.mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()), getParameters().getExternalLunMap());
            mapEntities(fullEntityOvfData);
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@Override
public void addVmToAffinityGroups() {
    drMappingHelper.addVmToAffinityGroups(getParameters().getClusterId(), getParameters().getVmId(), getParameters().getAffinityGroupMap(), getParameters().getAffinityGroups());
}
#method_after
@Override
public void addVmToAffinityGroups() {
    cachedAffinityGroups.forEach(affinityGroup -> affinityGroupDao.update(affinityGroup));
}
#end_block

#method_before
@Override
public void addVmToAffinityLabels() {
    drMappingHelper.addVmToAffinityLabels(getParameters().getAffinityLabelMap(), getParameters().getVm(), getParameters().getAffinityLabels());
}
#method_after
@Override
public void addVmToAffinityLabels() {
    cachedAffinityLabels.forEach(affinityLabel -> {
        affinityLabel.addVm(getParameters().getVm());
        labelDao.update(affinityLabel);
    });
}
#end_block

#method_before
@Override
public void executeVmCommand() {
    addAuditLogForPartialVMs();
    // vnic profile mapping should be done only after validating the requested vnic profile id against the DAO
    drMappingHelper.mapVnicProfiles(vmFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings());
    super.executeVmCommand();
    if (getSucceeded()) {
        if (isImagesAlreadyOnTarget()) {
            getImages().stream().forEach(diskImage -> {
                initQcowVersionForDisks(diskImage.getId());
            });
            unregisteredOVFDataDao.removeEntity(ovfEntityData.getEntityId(), null);
            unregisteredDisksDao.removeUnregisteredDiskRelatedToVM(ovfEntityData.getEntityId(), null);
            auditLogDirector.log(this, AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY);
        } else if (!vmDisksToAttach.isEmpty()) {
            auditLogDirector.log(this, attemptToAttachDisksToImportedVm(vmDisksToAttach));
        }
    }
    setActionReturnValue(getVm().getId());
}
#method_after
@Override
public void executeVmCommand() {
    addAuditLogForPartialVMs();
    // vnic profile mapping should be done only after all validation (including validating the requested
    // vnic profile id against the DAO) passes and after the vmFromConfiguration object has been initialized
    drMappingHelper.mapVnicProfiles(vmFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings());
    super.executeVmCommand();
    if (getSucceeded()) {
        if (isImagesAlreadyOnTarget()) {
            getImages().stream().forEach(diskImage -> {
                initQcowVersionForDisks(diskImage.getId());
            });
            unregisteredOVFDataDao.removeEntity(ovfEntityData.getEntityId(), null);
            unregisteredDisksDao.removeUnregisteredDiskRelatedToVM(ovfEntityData.getEntityId(), null);
            auditLogDirector.log(this, AuditLogType.VM_IMPORT_FROM_CONFIGURATION_EXECUTED_SUCCESSFULLY);
        } else if (!vmDisksToAttach.isEmpty()) {
            auditLogDirector.log(this, attemptToAttachDisksToImportedVm(vmDisksToAttach));
        }
    }
    setActionReturnValue(getVm().getId());
}
#end_block

#method_before
private void addAuditLogForPartialVMs() {
    if (getParameters().isAllowPartialImport() && !failedDisksToImportForAuditLog.isEmpty()) {
        addCustomValue("DiskAliases", StringUtils.join(failedDisksToImportForAuditLog.values(), ", "));
        auditLogDirector.log(this, AuditLogType.IMPORTEXPORT_PARTIAL_VM_DISKS_NOT_EXISTS);
    }
}
#method_after
private void addAuditLogForPartialVMs() {
    StringBuilder missingEntities = new StringBuilder();
    if (getParameters().isAllowPartialImport() && !failedDisksToImportForAuditLog.isEmpty()) {
        missingEntities.append("Disks: ");
        missingEntities.append(StringUtils.join(failedDisksToImportForAuditLog.values(), ", ") + " ");
    }
    if (!missingAffinityGroups.isEmpty()) {
        missingEntities.append("Affinity groups: ");
        missingEntities.append(StringUtils.join(missingAffinityGroups, ", ") + " ");
    }
    if (!missingAffinityLabels.isEmpty()) {
        missingEntities.append("Affinity labels: ");
        missingEntities.append(StringUtils.join(missingAffinityLabels, ", ") + " ");
    }
    if (!missingUsers.isEmpty()) {
        missingEntities.append("Users: ");
        missingEntities.append(StringUtils.join(missingUsers, ", ") + " ");
    }
    if (!missingRoles.isEmpty()) {
        missingEntities.append("Roles: ");
        missingEntities.append(StringUtils.join(missingRoles, ", ") + " ");
    }
    if (missingEntities.length() > 0) {
        addCustomValue("MissingEntities", missingEntities.toString());
        auditLogDirector.log(this, AuditLogType.IMPORTEXPORT_PARTIAL_VM_MISSING_ENTITIES);
    }
}
#end_block

#method_before
@Override
public Map<String, Object> getRoleMap() {
    return roleMap;
}
#method_after
@Override
public Map<String, String> getRoleMap() {
    return roleMap;
}
#end_block

#method_before
@Override
public void setRoleMap(Map<String, Object> roleMap) {
    this.roleMap = roleMap;
}
#method_after
@Override
public void setRoleMap(Map<String, String> roleMap) {
    this.roleMap = roleMap;
}
#end_block

#method_before
public List<String> getAffinityLabels() {
    return affinityLabels;
}
#method_after
public List<Label> getAffinityLabels() {
    return affinityLabels;
}
#end_block

#method_before
public void setAffinityLabels(List<String> affinityLabels) {
    this.affinityLabels = affinityLabels;
}
#method_after
public void setAffinityLabels(List<Label> affinityLabels) {
    this.affinityLabels = affinityLabels;
}
#end_block

#method_before
@Override
public Map<String, Object> getRoleMap() {
    return roleMap;
}
#method_after
@Override
public Map<String, String> getRoleMap() {
    return roleMap;
}
#end_block

#method_before
@Override
public void setRoleMap(Map<String, Object> roleMap) {
    this.roleMap = roleMap;
}
#method_after
@Override
public void setRoleMap(Map<String, String> roleMap) {
    this.roleMap = roleMap;
}
#end_block

#method_before
public List<AffinityGroup> mapAffinityGroups(Map<String, String> affinityGroupMap, List<AffinityGroup> affinityGroupsFromParam, Guid vmId) {
    if (affinityGroupsFromParam == null) {
        return Collections.emptyList();
    }
    List<AffinityGroup> affinityGroups = new ArrayList<>();
    affinityGroupsFromParam.forEach(affinityGroup -> {
        log.info("Mapping affinity group '{}/{} for vm '{}'.", affinityGroup.getId(), affinityGroup.getName(), vmId);
        AffinityGroup affGroup = getRelatedEntity(affinityGroupMap, affinityGroup.getName(), val -> affinityGroupDao.getByName((String) val));
        if (affGroup != null) {
            Set<Guid> vmIds = new HashSet<>(affGroup.getVmIds());
            vmIds.add(vmId);
            affGroup.setVmIds(new ArrayList<>(vmIds));
            affinityGroups.add(affGroup);
        }
    });
    return affinityGroups;
}
#method_after
public List<AffinityGroup> mapAffinityGroups(Map<String, String> affinityGroupMap, List<AffinityGroup> affinityGroupsFromParam, String vmName) {
    if (affinityGroupsFromParam == null) {
        return Collections.emptyList();
    }
    List<AffinityGroup> affinityGroupsToAdd = new ArrayList<>();
    affinityGroupsFromParam.forEach(affinityGroup -> {
        log.info("Mapping affinity group '{}' for vm '{}'.", affinityGroup.getName(), vmName);
        String mappedAffinityGroupName = affinityGroupMap.get(affinityGroup.getName());
        if (mappedAffinityGroupName == null) {
            log.warn("Mapping for affinity group '{}' not found, will use the affinity group name from OVF", affinityGroup.getName());
            affinityGroupsToAdd.add(affinityGroup);
        } else {
            log.info("Mapping for affinity group '{}' found, attempting to map to '{}'", affinityGroup.getName(), mappedAffinityGroupName);
            AffinityGroup mappedAffinityGroup = affinityGroupDao.getByName(mappedAffinityGroupName);
            AffinityGroup affinityGroupToAdd = Optional.ofNullable(mappedAffinityGroup).orElse(affinityGroup);
            log.info("Will try to add affinity group: {}", affinityGroupToAdd.getName());
            affinityGroupsToAdd.add(affinityGroupToAdd);
        }
    });
    return affinityGroupsToAdd;
}
#end_block

#method_before
public List<Label> mapAffinityLabels(Map<String, String> affinityLabelMap, Guid vmId, List<String> affinityLabelsFromParam, List<String> missingAffinityLabels) {
    if (affinityLabelsFromParam == null) {
        return Collections.emptyList();
    }
    List<Label> affinityLabels = new ArrayList<>();
    affinityLabelsFromParam.forEach(affinityLabel -> {
        log.info("Mapping affinity label '{}' for vm '{}'.", affinityLabel, vmId);
        Label affLabel = getRelatedEntity(affinityLabelMap, affinityLabel, val -> labelDao.getByName((String) val));
        if (affLabel != null) {
            affinityLabels.add(affLabel);
        } else {
            missingAffinityLabels.add(affinityLabel);
        }
    });
    return affinityLabels;
}
#method_after
public List<Label> mapAffinityLabels(Map<String, String> affinityLabelMap, String vmName, List<Label> affinityLabelsFromParam) {
    if (affinityLabelsFromParam == null) {
        return Collections.emptyList();
    }
    List<Label> affinityLabelsToAdd = new ArrayList<>();
    affinityLabelsFromParam.forEach(affinityLabel -> {
        log.info("Mapping affinity label '{}' for vm '{}'.", affinityLabel, vmName);
        String mappedAffinityLabelName = affinityLabelMap.get(affinityLabel.getName());
        if (mappedAffinityLabelName == null) {
            affinityLabelsToAdd.add(affinityLabel);
            log.warn("Mapping for affinity label '{}' not found, will use the affinity label name from OVF", affinityLabel.getName());
        } else {
            if (labelDao.getByName(mappedAffinityLabelName) == null) {
                log.warn("Mapping for affinity label '{}' not found, will use the affinity label name from OVF", affinityLabel.getName());
                affinityLabelsToAdd.add(affinityLabel);
            } else {
                log.info("Mapping for affinity label '{}' found, attempting to map to '{}'", affinityLabel.getName(), mappedAffinityLabelName);
                Label mappedAffinityLabel = labelDao.getByName(mappedAffinityLabelName);
                Label affinityLabelToAdd = Optional.ofNullable(mappedAffinityLabel).orElse(affinityLabel);
                log.info("Will try to add affinity label '{}'", affinityLabelToAdd.getName());
                affinityLabelsToAdd.add(affinityLabelToAdd);
            }
        }
    });
    return affinityLabelsToAdd;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (isImagesAlreadyOnTarget()) {
        if (!validateExternalVnicProfileMapping()) {
            return false;
        }
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(vmFromConfiguration, ovfEntityData))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistForUnregisteredEntity(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistsForMemoryDisks(getVm().getSnapshots(), getParameters().isAllowPartialImport(), failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!drMappingHelper.validateAffinityGroupCluster(getParameters().getAffinityGroups(), getClusterId()) && !getParameters().isAllowPartialImport()) {
            return false;
        }
        if (!AffinityRulesUtils.checkForAffinityGroupHostsConflict(getParameters().getAffinityGroups()).isEmpty() && !getParameters().isAllowPartialImport()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_AFFINITY_RULES_COLLISION);
        }
        if (!missingAffinityLabels.isEmpty() && !getParameters().isAllowPartialImport()) {
            log.warn("Missing affinity labels: {}", missingAffinityLabels.stream().collect(Collectors.joining(",")));
            return failValidation(EngineMessage.AFFINITY_LABEL_NOT_EXISTS);
        }
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (isImagesAlreadyOnTarget()) {
        if (!validateExternalVnicProfileMapping()) {
            return false;
        }
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(ovfEntityData))) {
            return false;
        }
        if (!validate(importValidator.validateDiskNotAlreadyExistOnDB(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistForUnregisteredEntity(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistsForMemoryDisks(getVm().getSnapshots(), getParameters().isAllowPartialImport(), failedDisksToImportForAuditLog))) {
            return false;
        }
        removeInvalidAffinityGroups(importValidator);
        removeInvalidAffinityLabels(importValidator);
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return true;
}
#end_block

#method_before
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmFromConfiguration.getId(), getParameters().getClusterMap());
                if (cluster != null) {
                    getParameters().setClusterId(cluster.getId());
                }
            }
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            // Note: The VM's OVF does not preserve the username and password for the LUN's connection.
            // Therefore to achieve a simple VM registration the iSCSI storage server should not use
            // credentials, although if the user will use the mapping attribute, one can set the credentials through
            // there.
            drMappingHelper.mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()), getParameters().getExternalLunMap());
            getParameters().setAffinityGroups(drMappingHelper.mapAffinityGroups(getParameters().getAffinityGroupMap(), fullEntityOvfData.getAffinityGroups(), getVmId()));
            getParameters().setAffinityLabels(drMappingHelper.mapAffinityLabels(getParameters().getAffinityLabelMap(), getVmId(), fullEntityOvfData.getAffinityLabels(), missingAffinityLabels));
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmFromConfiguration.getId(), getParameters().getClusterMap());
                if (cluster != null) {
                    getParameters().setClusterId(cluster.getId());
                }
            }
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            // Note: The VM's OVF does not preserve the username and password for the LUN's connection.
            // Therefore to achieve a simple VM registration the iSCSI storage server should not use
            // credentials, although if the user will use the mapping attribute, one can set the credentials through
            // there.
            drMappingHelper.mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()), getParameters().getExternalLunMap());
            mapEntities(fullEntityOvfData);
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@Override
public void addVmToAffinityGroups() {
    getParameters().getAffinityGroups().forEach(affinityGroup -> affinityGroupDao.save(affinityGroup));
}
#method_after
@Override
public void addVmToAffinityGroups() {
    cachedAffinityGroups.forEach(affinityGroup -> affinityGroupDao.update(affinityGroup));
}
#end_block

#method_before
@Override
public void addVmToAffinityLabels() {
    getParameters().getAffinityLabels().forEach(affinityLabel -> {
        affinityLabel.addVm(getParameters().getVm());
        labelDao.update(affinityLabel);
    });
}
#method_after
@Override
public void addVmToAffinityLabels() {
    cachedAffinityLabels.forEach(affinityLabel -> {
        affinityLabel.addVm(getParameters().getVm());
        labelDao.update(affinityLabel);
    });
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    boolean lockAcquired = false;
    try {
        if (canVdsBeReached()) {
            lockAcquired = lockManager.acquireLock(retrieveVdsExecutionLock()).getFirst();
            if (!lockAcquired) {
                getVDSReturnValue().setVdsError(new VDSError(EngineError.ENGINE, "Failed to acquire vds execution lock - related operation is under execution"));
                getVDSReturnValue().setSucceeded(false);
                return;
            }
            boolean performSpmStop = true;
            Map<Guid, AsyncTaskStatus> unclearedTasks = null;
            try {
                VDSReturnValue vdsReturnValue = resourceManager.runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(getVds().getId()));
                if (isNotSPM(vdsReturnValue)) {
                    return;
                }
                getVDSReturnValue().setSucceeded(vdsReturnValue.getSucceeded());
                getVDSReturnValue().setVdsError(vdsReturnValue.getVdsError());
                if (vdsReturnValue.getReturnValue() != null) {
                    unclearedTasks = (HashMap<Guid, AsyncTaskStatus>) vdsReturnValue.getReturnValue();
                    performSpmStop = unclearedTasks.isEmpty();
                }
            } catch (Exception e) {
                performSpmStop = false;
                log.info("SpmStopVDSCommand::Could not get tasks on vds '{}': {}", getVds().getName(), e.getMessage());
                log.debug("Exception", e);
            }
            if (performSpmStop) {
                log.info("SpmStopVDSCommand::Stopping SPM on vds '{}', pool id '{}'", getVds().getName(), getParameters().getStoragePoolId());
                status = getBroker().spmStop(getParameters().getStoragePoolId().toString());
                proceedProxyReturnValue();
            } else {
                getVDSReturnValue().setSucceeded(false);
                if (getVDSReturnValue().getVdsError() == null) {
                    Map<Guid, String> asyncTasksInDb = asyncTaskDao.getAsyncTaskIdsByStoragePoolId(getParameters().getStoragePoolId()).stream().collect(Collectors.toMap(AsyncTask::getTaskId, AsyncTask::toString));
                    String asyncTaskNotInDb = "Task '%s', status '%s'";
                    String unclearedTasksDetails = unclearedTasks.entrySet().stream().map(entry -> Optional.ofNullable(asyncTasksInDb.get(entry.getKey())).orElse(String.format(asyncTaskNotInDb, entry.getKey(), entry.getValue().getStatus()))).collect(Collectors.joining(", "));
                    log.error("SpmStopVDSCommand::Not stopping SPM on vds '{}', pool id '{}' as there are uncleared tasks '{}'", getVds().getName(), getParameters().getStoragePoolId(), unclearedTasksDetails);
                    VDSError error = new VDSError(EngineError.TaskInProgress, unclearedTasksDetails);
                    getVDSReturnValue().setVdsError(error);
                } else if (getVDSReturnValue().getVdsError().getCode() == EngineError.VDS_NETWORK_ERROR) {
                    log.info("SpmStopVDSCommand::Could not get tasks on vds '{}' - network exception, not stopping spm! pool id '{}'", getVds().getName(), getParameters().getStoragePoolId());
                }
            }
        } else {
            log.info("SpmStopVDSCommand:: vds '{}' is in '{}' status - not performing spm stop, pool id '{}'", getVds().getName(), getVds().getStatus(), getParameters().getStoragePoolId());
            getVDSReturnValue().setVdsError(new VDSError(EngineError.VDS_NETWORK_ERROR, "Vds is in incorrect status"));
            getVDSReturnValue().setSucceeded(false);
        }
    } catch (RuntimeException exp) {
        log.warn("Could not stop spm of pool '{}' on vds '{}': {}", getParameters().getStoragePoolId(), getParameters().getVdsId(), exp.getMessage());
        log.debug("Exception", exp);
        getVDSReturnValue().setExceptionObject(exp);
        getVDSReturnValue().setSucceeded(false);
    } finally {
        if (lockAcquired) {
            lockManager.releaseLock(retrieveVdsExecutionLock());
        }
    }
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    boolean lockAcquired = false;
    try {
        if (canVdsBeReached()) {
            lockAcquired = lockManager.acquireLock(retrieveVdsExecutionLock()).getFirst();
            if (!lockAcquired) {
                getVDSReturnValue().setVdsError(new VDSError(EngineError.ENGINE, "Failed to acquire vds execution lock - related operation is under execution"));
                getVDSReturnValue().setSucceeded(false);
                return;
            }
            boolean performSpmStop = true;
            Map<Guid, AsyncTaskStatus> unclearedTasks = null;
            try {
                VDSReturnValue vdsReturnValue = resourceManager.runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(getVds().getId()));
                if (isNotSPM(vdsReturnValue)) {
                    return;
                }
                getVDSReturnValue().setSucceeded(vdsReturnValue.getSucceeded());
                getVDSReturnValue().setVdsError(vdsReturnValue.getVdsError());
                if (vdsReturnValue.getReturnValue() != null) {
                    unclearedTasks = (HashMap<Guid, AsyncTaskStatus>) vdsReturnValue.getReturnValue();
                    performSpmStop = unclearedTasks.isEmpty();
                }
            } catch (Exception e) {
                performSpmStop = false;
                log.info("SpmStopVDSCommand::Could not get tasks on vds '{}': {}", getVds().getName(), e.getMessage());
                log.debug("Exception", e);
            }
            if (performSpmStop) {
                log.info("SpmStopVDSCommand::Stopping SPM on vds '{}', pool id '{}'", getVds().getName(), getParameters().getStoragePoolId());
                status = getBroker().spmStop(getParameters().getStoragePoolId().toString());
                proceedProxyReturnValue();
            } else {
                getVDSReturnValue().setSucceeded(false);
                if (getVDSReturnValue().getVdsError() == null) {
                    String unclearedTasksDetails = unclearedTasks.entrySet().stream().map(entry -> String.format("Task '%s', status '%s'", entry.getKey(), entry.getValue().getStatus())).collect(Collectors.joining(", "));
                    log.error("SpmStopVDSCommand::Not stopping SPM on vds '{}', pool id '{}' as there are uncleared tasks '{}'", getVds().getName(), getParameters().getStoragePoolId(), unclearedTasksDetails);
                    VDSError error = new VDSError(EngineError.TaskInProgress, unclearedTasksDetails);
                    getVDSReturnValue().setVdsError(error);
                } else if (getVDSReturnValue().getVdsError().getCode() == EngineError.VDS_NETWORK_ERROR) {
                    log.info("SpmStopVDSCommand::Could not get tasks on vds '{}' - network exception, not stopping spm! pool id '{}'", getVds().getName(), getParameters().getStoragePoolId());
                }
            }
        } else {
            log.info("SpmStopVDSCommand:: vds '{}' is in '{}' status - not performing spm stop, pool id '{}'", getVds().getName(), getVds().getStatus(), getParameters().getStoragePoolId());
            getVDSReturnValue().setVdsError(new VDSError(EngineError.VDS_NETWORK_ERROR, "Vds is in incorrect status"));
            getVDSReturnValue().setSucceeded(false);
        }
    } catch (RuntimeException exp) {
        log.warn("Could not stop spm of pool '{}' on vds '{}': {}", getParameters().getStoragePoolId(), getParameters().getVdsId(), exp.getMessage());
        log.debug("Exception", exp);
        getVDSReturnValue().setExceptionObject(exp);
        getVDSReturnValue().setSucceeded(false);
    } finally {
        if (lockAcquired) {
            lockManager.releaseLock(retrieveVdsExecutionLock());
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    Map<Guid, Cluster> clusters = new HashMap<>();
    Set<Guid> clustersAsSet = new HashSet<>();
    Set<Guid> vdsWithRunningVMs = new HashSet<>();
    List<String> hostNotRespondingList = new ArrayList<>();
    List<String> hostsWithNonMigratableVms = new ArrayList<>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = vdsDao.get(vdsId);
        if (vds == null) {
            log.error("ResourceManager::vdsMaintenance could not find VDS '{}'", vdsId);
            result = failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
            continue;
        }
        // TODO make a more efficient call but normally the command just loads one cluster anyway
        if (!clusters.containsKey(vds.getClusterId())) {
            final Cluster cluster = clusterDao.get(vds.getClusterId());
            clusters.put(cluster.getId(), cluster);
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
        if (getParameters().isStopGlusterService() && !vds.getClusterSupportsGlusterService()) {
            result = failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_SERVICE_MAINTENANCE_NOT_SUPPORTED_FOR_CLUSTER);
            break;
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    List<VM> vms = vmDao.getAllRunningForVds(vdsId);
                    if (!vms.isEmpty()) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getClusterId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<>();
                    for (VM vm : vms) {
                        // And they need safe place for migration
                        if (vm.isHostedEngine()) {
                            List<VDS> clusterVdses = vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up);
                            if (!HostedEngineHelper.haveHostsAvailableforHE(clusterVdses, getParameters().getVdsIdList())) {
                                failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE);
                                return false;
                            }
                        }
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error("VDS '{}' contains non migratable VMs", vdsId);
                        result = false;
                    } else if (!validate(new MultipleVmsValidator(vms).vmNotHavingPluggedDiskSnapshots(EngineMessage.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && asyncTaskDao.getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        String runningTasks = asyncTaskDao.getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).stream().map(AsyncTask::toString).collect(Collectors.joining(", "));
                        log.warn("There are running tasks on the SPM: '{}'", runningTasks);
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                    } else if (!validateNoRunningJobs(vds)) {
                        result = false;
                    } else if (!clusters.get(vds.getClusterId()).isInUpgradeMode()) {
                        result = handlePositiveEnforcingAffinityGroup(vdsId, vms);
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a Validate message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a Validate message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<>();
            List<String> allHostsWithRunningVms = new ArrayList<>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = vdsDao.getAllForCluster(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addValidationMessage(EngineMessage.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
        if (result && !getParameters().isForceMaintenance()) {
            result = validateGlusterParams(clustersAsSet);
        }
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    Map<Guid, Cluster> clusters = new HashMap<>();
    Set<Guid> clustersAsSet = new HashSet<>();
    Set<Guid> vdsWithRunningVMs = new HashSet<>();
    List<String> hostNotRespondingList = new ArrayList<>();
    List<String> hostsWithNonMigratableVms = new ArrayList<>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = vdsDao.get(vdsId);
        if (vds == null) {
            log.error("ResourceManager::vdsMaintenance could not find VDS '{}'", vdsId);
            result = failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
            continue;
        }
        // TODO make a more efficient call but normally the command just loads one cluster anyway
        if (!clusters.containsKey(vds.getClusterId())) {
            final Cluster cluster = clusterDao.get(vds.getClusterId());
            clusters.put(cluster.getId(), cluster);
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
        if (getParameters().isStopGlusterService() && !vds.getClusterSupportsGlusterService()) {
            result = failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_SERVICE_MAINTENANCE_NOT_SUPPORTED_FOR_CLUSTER);
            break;
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    List<VM> vms = vmDao.getAllRunningForVds(vdsId);
                    if (!vms.isEmpty()) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getClusterId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<>();
                    for (VM vm : vms) {
                        // And they need safe place for migration
                        if (vm.isHostedEngine()) {
                            List<VDS> clusterVdses = vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up);
                            if (!HostedEngineHelper.haveHostsAvailableforHE(clusterVdses, getParameters().getVdsIdList())) {
                                failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE);
                                return false;
                            }
                        }
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    List<AsyncTask> asyncTasks = null;
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error("VDS '{}' contains non migratable VMs", vdsId);
                        result = false;
                    } else if (!validate(new MultipleVmsValidator(vms).vmNotHavingPluggedDiskSnapshots(EngineMessage.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && ((asyncTasks = asyncTaskDao.getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()))).size() > 0) {
                        String runningTasks = asyncTasks.stream().map(AsyncTask::toString).collect(Collectors.joining(", "));
                        log.warn("There are running tasks on the SPM: '{}'", runningTasks);
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                    } else if (!validateNoRunningJobs(vds)) {
                        result = false;
                    } else if (!clusters.get(vds.getClusterId()).isInUpgradeMode()) {
                        result = handlePositiveEnforcingAffinityGroup(vdsId, vms);
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a Validate message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a Validate message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<>();
            List<String> allHostsWithRunningVms = new ArrayList<>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = vdsDao.getAllForCluster(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addValidationMessage(EngineMessage.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
        if (result && !getParameters().isForceMaintenance()) {
            result = validateGlusterParams(clustersAsSet);
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (isImagesAlreadyOnTarget()) {
        if (!validateExternalVnicProfileMapping()) {
            return false;
        }
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(ovfEntityData))) {
            return false;
        }
        if (!validate(importValidator.validateDiskNotAlreadyExistOnDB(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistForUnregisteredEntity(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistsForMemoryDisks(getVm().getSnapshots(), getParameters().isAllowPartialImport(), failedDisksToImportForAuditLog))) {
            return false;
        }
        List<String> affinityGroupsToAdd = getParameters().getAffinityGroups().stream().map(AffinityGroup::getName).collect(Collectors.toList());
        missingAffinityGroups = importValidator.findMissingEntities(affinityGroupsToAdd, val -> affinityGroupDao.getByName(val));
        if (!missingAffinityGroups.isEmpty()) {
            if (!getParameters().isAllowPartialImport()) {
                log.error("Missing affinity groups: {}", missingAffinityGroups.stream().collect(Collectors.joining(", ")));
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_MISSING_AFFINITY_GROUPS, "$AffinityGroups", missingAffinityGroups.stream().collect(Collectors.joining(", ")));
            } else {
                log.warn("Could not find affinity groups: {}", missingAffinityGroups.stream().collect(Collectors.joining(", ")));
            }
        }
        if (!importValidator.validateAffinityGroupCluster(getParameters().getAffinityGroups(), getClusterId())) {
            if (!getParameters().isAllowPartialImport()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_CHANGE_CLUSTER_ID);
            } else {
                log.warn("Could not add some of the affinity groups as cluster ID does not match");
            }
        }
        if (!AffinityRulesUtils.checkForAffinityGroupHostsConflict(getParameters().getAffinityGroups()).isEmpty()) {
            if (!getParameters().isAllowPartialImport()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_AFFINITY_RULES_COLLISION);
            } else {
                log.warn("Some of the affinity groups could not be added due to rule collision");
            }
        }
        missingAffinityLabels = importValidator.findMissingEntities(getParameters().getAffinityLabels(), val -> labelDao.getByName(val));
        if (!missingAffinityLabels.isEmpty()) {
            if (!getParameters().isAllowPartialImport()) {
                log.error("Missing affinity labels: {}", missingAffinityLabels.stream().collect(Collectors.joining(",")));
                return failValidation(EngineMessage.AFFINITY_LABEL_NOT_EXISTS);
            } else {
                log.warn("Missing affinity labels: {}", missingAffinityLabels.stream().collect(Collectors.joining(",")));
            }
        }
        missingUsers = importValidator.findMissingUsers(getParameters().getDbUsers());
        if (!missingUsers.isEmpty() && !getParameters().isAllowPartialImport()) {
            log.error("Missing users: {}", missingUsers.stream().collect(Collectors.joining(",")));
            return failValidation(EngineMessage.USER_MUST_EXIST_IN_DB);
        }
        Set<String> roles = getParameters().getRoleMap().values().stream().map(String.class::cast).collect(Collectors.toSet());
        roles.addAll(getParameters().getRoleMap().keySet());
        missingRoles = importValidator.findMissingEntities(roles, val -> roleDao.getByName(val));
        if (!missingRoles.isEmpty() && !getParameters().isAllowPartialImport()) {
            log.error("Missing roles: {}", missingRoles.stream().collect(Collectors.joining(", ")));
            return failValidation(EngineMessage.VALIDATION_ROLE_DOES_NOT_EXIST);
        }
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (isImagesAlreadyOnTarget()) {
        if (!validateExternalVnicProfileMapping()) {
            return false;
        }
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(ovfEntityData))) {
            return false;
        }
        if (!validate(importValidator.validateDiskNotAlreadyExistOnDB(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistForUnregisteredEntity(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistsForMemoryDisks(getVm().getSnapshots(), getParameters().isAllowPartialImport(), failedDisksToImportForAuditLog))) {
            return false;
        }
        removeInvalidAffinityGroups(importValidator);
        removeInvalidAffinityLabels(importValidator);
        removeInavlidUsers(importValidator);
        removeInavlidRoles(importValidator);
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return true;
}
#end_block

#method_before
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmFromConfiguration.getId(), getParameters().getClusterMap());
                if (cluster != null) {
                    getParameters().setClusterId(cluster.getId());
                }
            }
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            // Note: The VM's OVF does not preserve the username and password for the LUN's connection.
            // Therefore to achieve a simple VM registration the iSCSI storage server should not use
            // credentials, although if the user will use the mapping attribute, one can set the credentials through
            // there.
            drMappingHelper.mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()), getParameters().getExternalLunMap());
            if (getParameters().getAffinityGroupMap() != null) {
                getParameters().setAffinityGroups(drMappingHelper.mapAffinityGroups(getParameters().getAffinityGroupMap(), fullEntityOvfData.getAffinityGroups(), getVmId()));
            } else {
                getParameters().setAffinityGroups(fullEntityOvfData.getAffinityGroups());
            }
            if (getParameters().getAffinityLabels() != null) {
                getParameters().setAffinityLabels(drMappingHelper.mapAffinityLabels(getParameters().getAffinityLabelMap(), getVmId(), fullEntityOvfData.getAffinityLabels()));
            } else {
                getParameters().setAffinityLabels(fullEntityOvfData.getAffinityLabels());
            }
            if (getParameters().getDomainMap() != null) {
                getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            } else {
                getParameters().setDbUsers(drMappingHelper.mapDbUsers(fullEntityOvfData.getDbUsers(), getParameters().getDomainMap()));
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmFromConfiguration.getId(), getParameters().getClusterMap());
                if (cluster != null) {
                    getParameters().setClusterId(cluster.getId());
                }
            }
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            // Note: The VM's OVF does not preserve the username and password for the LUN's connection.
            // Therefore to achieve a simple VM registration the iSCSI storage server should not use
            // credentials, although if the user will use the mapping attribute, one can set the credentials through
            // there.
            drMappingHelper.mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()), getParameters().getExternalLunMap());
            mapEntities(fullEntityOvfData);
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
protected void addPermissionsToDB() {
    drMappingHelper.addPermissions(getParameters().getDbUsers(), getParameters().getUserToRoles(), getVmId(), VdcObjectType.VM);
}
#method_after
protected void addPermissionsToDB() {
    drMappingHelper.addPermissions(getParameters().getDbUsers(), getParameters().getUserToRoles(), getVmId(), VdcObjectType.VM, getParameters().getRoleMap());
}
#end_block

#method_before
@Override
public void addVmToAffinityGroups() {
    getParameters().getAffinityGroups().forEach(affinityGroup -> {
        Set<Guid> vmIds = new HashSet<>(affinityGroup.getVmIds());
        vmIds.add(getVmId());
        affinityGroup.setVmIds(new ArrayList<>(vmIds));
        affinityGroupDao.save(affinityGroup);
    });
}
#method_after
@Override
public void addVmToAffinityGroups() {
    cachedAffinityGroups.forEach(affinityGroup -> affinityGroupDao.update(affinityGroup));
}
#end_block

#method_before
@Override
public void addVmToAffinityLabels() {
    getParameters().getAffinityLabels().forEach(affinityLabel -> {
        Label label = labelDao.getByName(affinityLabel);
        label.addVm(getParameters().getVm());
        labelDao.update(label);
    });
}
#method_after
@Override
public void addVmToAffinityLabels() {
    cachedAffinityLabels.forEach(affinityLabel -> {
        affinityLabel.addVm(getParameters().getVm());
        labelDao.update(affinityLabel);
    });
}
#end_block

#method_before
private void addAuditLogForPartialVMs() {
    String missingEntities = "";
    if (getParameters().isAllowPartialImport() && !failedDisksToImportForAuditLog.isEmpty()) {
        missingEntities += StringUtils.join(failedDisksToImportForAuditLog.values(), ", ") + " ";
    }
    if (getParameters().isAllowPartialImport() && !missingAffinityGroups.isEmpty()) {
        missingEntities += StringUtils.join(missingAffinityGroups, ", ") + " ";
    }
    if (getParameters().isAllowPartialImport() && !missingAffinityLabels.isEmpty()) {
        missingEntities += StringUtils.join(missingAffinityLabels, ", ") + " ";
    }
    if (getParameters().isAllowPartialImport() && !missingUsers.isEmpty()) {
        missingEntities += StringUtils.join(missingUsers, ", ") + " ";
    }
    if (getParameters().isAllowPartialImport() && !missingRoles.isEmpty()) {
        missingEntities += StringUtils.join(missingRoles, ", ") + " ";
    }
    addCustomValue("MissingEntities", missingEntities);
    auditLogDirector.log(this, AuditLogType.IMPORTEXPORT_PARTIAL_VM_MISSING_ENTITIES);
}
#method_after
private void addAuditLogForPartialVMs() {
    StringBuilder missingEntities = new StringBuilder();
    if (getParameters().isAllowPartialImport() && !failedDisksToImportForAuditLog.isEmpty()) {
        missingEntities.append("Disks: ");
        missingEntities.append(StringUtils.join(failedDisksToImportForAuditLog.values(), ", ") + " ");
    }
    if (!missingAffinityGroups.isEmpty()) {
        missingEntities.append("Affinity groups: ");
        missingEntities.append(StringUtils.join(missingAffinityGroups, ", ") + " ");
    }
    if (!missingAffinityLabels.isEmpty()) {
        missingEntities.append("Affinity labels: ");
        missingEntities.append(StringUtils.join(missingAffinityLabels, ", ") + " ");
    }
    if (!missingUsers.isEmpty()) {
        missingEntities.append("Users: ");
        missingEntities.append(StringUtils.join(missingUsers, ", ") + " ");
    }
    if (!missingRoles.isEmpty()) {
        missingEntities.append("Roles: ");
        missingEntities.append(StringUtils.join(missingRoles, ", ") + " ");
    }
    if (missingEntities.length() > 0) {
        addCustomValue("MissingEntities", missingEntities.toString());
        auditLogDirector.log(this, AuditLogType.IMPORTEXPORT_PARTIAL_VM_MISSING_ENTITIES);
    }
}
#end_block

#method_before
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(LockProperties.Scope.Execution);
}
#method_after
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Execution);
}
#end_block

#method_before
@Override
protected boolean validate() {
    initVmTemplate();
    if (!super.validate()) {
        return false;
    }
    if (!validateExternalVnicProfileMapping()) {
        return false;
    }
    drMappingHelper.mapVnicProfiles(vmTemplateFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings());
    ArrayList<DiskImage> disks = new ArrayList(getVmTemplate().getDiskTemplateMap().values());
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), disks);
    getVmTemplate().setImages(disks);
    if (getParameters().isImagesExistOnTargetStorageDomain() && !validateUnregisteredEntity(vmTemplateFromConfiguration, ovfEntityData)) {
        return false;
    }
    missingUsers = getImportValidator().findMissingUsers(getParameters().getDbUsers());
    if (!missingUsers.isEmpty() && !getParameters().isAllowPartialImport()) {
        log.error("Missing users: {}", missingUsers.stream().collect(Collectors.joining(",")));
        return failValidation(EngineMessage.USER_MUST_EXIST_IN_DB);
    }
    missingRoles = getImportValidator().findMissingRoles(getParameters().getRoleMap());
    if (!missingRoles.isEmpty() && !getParameters().isAllowPartialImport()) {
        log.error("Missing roles: {}", missingRoles.stream().collect(Collectors.joining(", ")));
        return failValidation(EngineMessage.VALIDATION_ROLE_DOES_NOT_EXIST);
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    initVmTemplate();
    if (!super.validate()) {
        return false;
    }
    if (!validateExternalVnicProfileMapping()) {
        return false;
    }
    drMappingHelper.mapVnicProfiles(vmTemplateFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings());
    ArrayList<DiskImage> disks = new ArrayList(getVmTemplate().getDiskTemplateMap().values());
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), disks);
    getVmTemplate().setImages(disks);
    if (getParameters().isImagesExistOnTargetStorageDomain() && !validateUnregisteredEntity(vmTemplateFromConfiguration, ovfEntityData)) {
        return false;
    }
    log.info("Checking for missing users");
    List<DbUser> dbMissingUsers = getImportValidator().findMissingUsers(getParameters().getDbUsers());
    getParameters().getDbUsers().removeAll(dbMissingUsers);
    missingUsers = dbMissingUsers.stream().map(dbUser -> String.format("%s@%s", dbUser.getLoginName(), dbUser.getDomain())).collect(Collectors.toList());
    Set<String> roles = new HashSet<>(getParameters().getRoleMap().values());
    roles.addAll(getParameters().getRoleMap().keySet());
    log.info("Checking for missing roles");
    missingRoles = getImportValidator().findMissingEntities(roles, val -> roleDao.getByName(val));
    getParameters().getUserToRoles().forEach((k, v) -> v.removeAll(missingRoles));
    return super.validate();
}
#end_block

#method_before
private void initVmTemplate() {
    List<OvfEntityData> ovfEntityList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            vmTemplateFromConfiguration = fullEntityOvfData.getVmTemplate();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                mapCluster(fullEntityOvfData);
            }
            vmTemplateFromConfiguration.setClusterId(getParameters().getClusterId());
            setVmTemplate(vmTemplateFromConfiguration);
            setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getVmTemplate(), this::getCluster));
            vmHandler.updateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion());
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
            if (getParameters().getDomainMap() != null) {
                getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            } else {
                getParameters().setDbUsers(drMappingHelper.mapDbUsers(fullEntityOvfData.getDbUsers(), getParameters().getDomainMap()));
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setClusterId(getParameters().getClusterId());
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
}
#method_after
private void initVmTemplate() {
    List<OvfEntityData> ovfEntityList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            vmTemplateFromConfiguration = fullEntityOvfData.getVmTemplate();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                mapCluster(fullEntityOvfData);
            }
            vmTemplateFromConfiguration.setClusterId(getParameters().getClusterId());
            setVmTemplate(vmTemplateFromConfiguration);
            setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getVmTemplate(), this::getCluster));
            vmHandler.updateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion());
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
            if (getParameters().getDomainMap() != null) {
                getParameters().setDbUsers(drMappingHelper.mapDbUsers(fullEntityOvfData.getDbUsers(), getParameters().getDomainMap()));
            } else {
                getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setClusterId(getParameters().getClusterId());
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
}
#end_block

#method_before
@Override
protected void addPermissionsToDB() {
    drMappingHelper.addPermissions(getParameters().getDbUsers(), getParameters().getUserToRoles(), getVmTemplateId(), VdcObjectType.VmTemplate);
}
#method_after
@Override
protected void addPermissionsToDB() {
    drMappingHelper.addPermissions(getParameters().getDbUsers(), getParameters().getUserToRoles(), getVmTemplateId(), VdcObjectType.VmTemplate, getParameters().getRoleMap());
}
#end_block

#method_before
private void addAuditLogForPartialVMs() {
    String missingEntities = "";
    if (getParameters().isAllowPartialImport() && !failedDisksToImportForAuditLog.isEmpty()) {
        missingEntities += StringUtils.join(failedDisksToImportForAuditLog.values(), ", ") + " ";
    }
    if (getParameters().isAllowPartialImport() && !missingUsers.isEmpty()) {
        missingEntities += StringUtils.join(missingUsers, ", ") + " ";
    }
    if (getParameters().isAllowPartialImport() && !missingRoles.isEmpty()) {
        missingEntities += StringUtils.join(missingRoles, ", ") + " ";
    }
    addCustomValue("MissingEntities", missingEntities);
    auditLogDirector.log(this, AuditLogType.IMPORTEXPORT_PARTIAL_VM_MISSING_ENTITIES);
}
#method_after
private void addAuditLogForPartialVMs() {
    StringBuilder missingEntities = new StringBuilder();
    if (getParameters().isAllowPartialImport() && !failedDisksToImportForAuditLog.isEmpty()) {
        missingEntities.append("Disks: ");
        missingEntities.append(StringUtils.join(failedDisksToImportForAuditLog.values(), ", ") + " ");
    }
    if (!missingUsers.isEmpty()) {
        missingEntities.append("Users: ");
        missingEntities.append(StringUtils.join(missingUsers, ", ") + " ");
    }
    if (!missingRoles.isEmpty()) {
        missingEntities.append("Roles: ");
        missingEntities.append(StringUtils.join(missingRoles, ", ") + " ");
    }
    if (missingEntities.length() > 0) {
        addCustomValue("MissingEntities", missingEntities.toString());
        auditLogDirector.log(this, AuditLogType.IMPORTEXPORT_PARTIAL_TEMPLATE_MISSING_ENTITIES);
    }
}
#end_block

#method_before
public Cluster getMappedCluster(String clusterName, Guid vmId, Map<String, String> clusterMap) {
    log.info("Mapping cluster '{}' for vm '{}'.", clusterName, vmId);
    return getRelatedEntity(clusterMap, clusterName, val -> clusterDao.getByName((String) val));
}
#method_after
public Cluster getMappedCluster(String clusterName, Guid vmId, Map<String, String> clusterMap) {
    Cluster mappedCluster = getRelatedEntity(clusterMap, clusterName, val -> clusterDao.getByName((String) val));
    log.info("Mapping cluster '{}' to '{}' for vm '{}'.", mappedCluster, clusterName, vmId);
    return mappedCluster;
}
#end_block

#method_before
public void mapExternalLunDisks(List<LunDisk> luns, Map<String, Object> externalLunMap) {
    luns.forEach(lunDisk -> {
        if (externalLunMap != null) {
            LunDisk targetLunDisk = (LunDisk) externalLunMap.get(lunDisk.getId().toString());
            if (targetLunDisk != null) {
                lunDisk.setLun(targetLunDisk.getLun());
                lunDisk.getLun().getLunConnections().forEach(conn -> conn.setStorageType(lunDisk.getLun().getLunType()));
            }
        }
    });
}
#method_after
public void mapExternalLunDisks(List<LunDisk> luns, Map<String, Object> externalLunMap) {
    luns.forEach(lunDisk -> {
        if (externalLunMap != null) {
            LunDisk targetLunDisk = (LunDisk) externalLunMap.get(lunDisk.getId().toString());
            if (targetLunDisk != null) {
                log.info("Mapping LUN disk '{}' to '{}'", lunDisk.getLun().getLUNId(), targetLunDisk.getLun().getLUNId());
                lunDisk.setLun(targetLunDisk.getLun());
                lunDisk.getLun().getLunConnections().forEach(conn -> conn.setStorageType(lunDisk.getLun().getLunType()));
            } else {
                log.warn("No LUN disk will be mapped, LUN '{}' was not found", targetLunDisk.getLun().getLUNId());
            }
        }
    });
}
#end_block

#method_before
public List<AffinityGroup> mapAffinityGroups(Map<String, String> affinityGroupMap, List<AffinityGroup> affinityGroupsFromParam, Guid vmId) {
    if (affinityGroupsFromParam == null) {
        return Collections.emptyList();
    }
    List<AffinityGroup> affinityGroups = new ArrayList<>();
    affinityGroupsFromParam.forEach(affinityGroup -> {
        log.info("Mapping affinity group '{}/{} for vm '{}'.", affinityGroup.getId(), affinityGroup.getName(), vmId);
        AffinityGroup affGroup = getRelatedEntity(affinityGroupMap, affinityGroup.getName(), val -> affinityGroupDao.getByName((String) val));
        if (affGroup != null) {
            Set<Guid> vmIds = new HashSet<>(affGroup.getVmIds());
            vmIds.add(vmId);
            affGroup.setVmIds(new ArrayList<>(vmIds));
            affinityGroups.add(affGroup);
        }
    });
    return affinityGroups;
}
#method_after
public List<AffinityGroup> mapAffinityGroups(Map<String, String> affinityGroupMap, List<AffinityGroup> affinityGroupsFromParam, String vmName) {
    if (affinityGroupsFromParam == null) {
        return Collections.emptyList();
    }
    List<AffinityGroup> affinityGroupsToAdd = new ArrayList<>();
    affinityGroupsFromParam.forEach(affinityGroup -> {
        log.info("Mapping affinity group '{}' for vm '{}'.", affinityGroup.getName(), vmName);
        String mappedAffinityGroupName = affinityGroupMap.get(affinityGroup.getName());
        if (mappedAffinityGroupName == null) {
            log.warn("Mapping for affinity group '{}' not found, will use the affinity group name from OVF", affinityGroup.getName());
            affinityGroupsToAdd.add(affinityGroup);
        } else {
            log.info("Mapping for affinity group '{}' found, attempting to map to '{}'", affinityGroup.getName(), mappedAffinityGroupName);
            AffinityGroup mappedAffinityGroup = affinityGroupDao.getByName(mappedAffinityGroupName);
            AffinityGroup affinityGroupToAdd = Optional.ofNullable(mappedAffinityGroup).orElse(affinityGroup);
            log.info("Will try to add affinity group: {}", affinityGroupToAdd.getName());
            affinityGroupsToAdd.add(affinityGroupToAdd);
        }
    });
    return affinityGroupsToAdd;
}
#end_block

#method_before
public List<Label> mapAffinityLabels(Map<String, String> affinityLabelMap, Guid vmId, List<String> affinityLabelsFromParam, List<String> missingAffinityLabels) {
    if (affinityLabelsFromParam == null) {
        return Collections.emptyList();
    }
    List<Label> affinityLabels = new ArrayList<>();
    affinityLabelsFromParam.forEach(affinityLabel -> {
        log.info("Mapping affinity label '{}' for vm '{}'.", affinityLabel, vmId);
        Label affLabel = getRelatedEntity(affinityLabelMap, affinityLabel, val -> labelDao.getByName((String) val));
        if (affLabel != null) {
            affinityLabels.add(affLabel);
        } else {
            missingAffinityLabels.add(affinityLabel);
        }
    });
    return affinityLabels;
}
#method_after
public List<Label> mapAffinityLabels(Map<String, String> affinityLabelMap, String vmName, List<Label> affinityLabelsFromParam) {
    if (affinityLabelsFromParam == null) {
        return Collections.emptyList();
    }
    List<Label> affinityLabelsToAdd = new ArrayList<>();
    affinityLabelsFromParam.forEach(affinityLabel -> {
        log.info("Mapping affinity label '{}' for vm '{}'.", affinityLabel, vmName);
        String mappedAffinityLabelName = affinityLabelMap.get(affinityLabel.getName());
        if (mappedAffinityLabelName == null) {
            affinityLabelsToAdd.add(affinityLabel);
            log.warn("Mapping for affinity label '{}' not found, will use the affinity label name from OVF", affinityLabel.getName());
        } else {
            if (labelDao.getByName(mappedAffinityLabelName) == null) {
                log.warn("Mapping for affinity label '{}' not found, will use the affinity label name from OVF", affinityLabel.getName());
                affinityLabelsToAdd.add(affinityLabel);
            } else {
                log.info("Mapping for affinity label '{}' found, attempting to map to '{}'", affinityLabel.getName(), mappedAffinityLabelName);
                Label mappedAffinityLabel = labelDao.getByName(mappedAffinityLabelName);
                Label affinityLabelToAdd = Optional.ofNullable(mappedAffinityLabel).orElse(affinityLabel);
                log.info("Will try to add affinity label '{}'", affinityLabelToAdd.getName());
                affinityLabelsToAdd.add(affinityLabelToAdd);
            }
        }
    });
    return affinityLabelsToAdd;
}
#end_block

#method_before
public Set<DbUser> mapDbUsers(Map<String, String> userDomainsMap, Set<DbUser> dbUsersFromParams, Map<String, Set<String>> userToRolesFromParams, Guid entityId, VdcObjectType objectType, Map<String, Object> roleMap, List<String> missingUsers, List<String> missingRoles, List<Permission> permissionsToAdd) {
    if (dbUsersFromParams == null || userToRolesFromParams == null) {
        return Collections.emptySet();
    }
    Set<DbUser> dbUsers = new HashSet<>();
    dbUsersFromParams.forEach(dbUser -> {
        DbUser originalDbUser = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), dbUser.getDomain());
        DrUserRolesMap permissionParams = null;
        if (userDomainsMap != null) {
            String destDomain = userDomainsMap.get(dbUser.getDomain());
            log.info("Attempting to map {}@{} to {}@{}", dbUser.getLoginName(), dbUser.getDomain());
            if (destDomain != null) {
                DbUser destDbUser = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), destDomain);
                if (destDbUser != null) {
                    dbUsers.add(destDbUser);
                    permissionParams = new DrUserRolesMap(destDbUser, userToRolesFromParams, entityId, objectType, roleMap);
                }
            } else if (originalDbUser != null) {
                log.info("{}@{} not found, attempting to add user from OVF", dbUser.getLoginName(), destDomain);
                dbUsers.add(originalDbUser);
                permissionParams = new DrUserRolesMap(originalDbUser, userToRolesFromParams, entityId, objectType, roleMap);
            }
        } else if (originalDbUser != null) {
            log.info("No mapped user, attempting to add user from OVF {}@{}", originalDbUser.getLoginName(), originalDbUser.getDomain());
            dbUsers.add(originalDbUser);
            permissionParams = new DrUserRolesMap(originalDbUser, userToRolesFromParams, entityId, objectType, roleMap);
        }
        if (permissionParams != null) {
            addPermissions(permissionParams, missingRoles, permissionsToAdd);
        } else {
            log.info("User {}@{} not found; permissions will not be added", dbUser.getLoginName(), dbUser.getDomain());
            missingUsers.add(dbUser.getLoginName());
        }
    });
    return dbUsers;
}
#method_after
public Set<DbUser> mapDbUsers(Set<DbUser> dbUsers, Map<String, String> userDomainsMap) {
    if (dbUsers == null) {
        return Collections.emptySet();
    }
    Set<DbUser> dbUsersToAdd = new HashSet<>();
    dbUsers.forEach(dbUser -> {
        String destDomain = userDomainsMap.get(dbUser.getLoginName());
        log.info("Attempting to map user '{}@{}' to '{}@{}'", dbUser.getLoginName(), dbUser.getDomain(), dbUser.getLoginName(), destDomain);
        if (destDomain == null) {
            log.warn("Mapping for domain not found, falling back to OVF user '{}@{}'", dbUser.getLoginName(), dbUser.getDomain());
            dbUsersToAdd.add(dbUser);
        } else {
            DbUser destUser = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), destDomain);
            dbUsersToAdd.add(Optional.ofNullable(destUser).orElse(dbUser));
        }
    });
    return dbUsersToAdd;
}
#end_block

#method_before
private void addPermissions(DrUserRolesMap permissionsParams, List<String> missingRoles, List<Permission> permissionsToAdd) {
    Map<String, Set<String>> userToRoles = permissionsParams.userToRoles;
    userToRoles.getOrDefault(permissionsParams.dbUser.getLoginName(), Collections.emptySet()).forEach(roleName -> {
        Permission permission = null;
        Role originalRole = roleDao.getByName(roleName);
        if (permissionsParams.roleMap != null) {
            Role destRoleName = (Role) permissionsParams.roleMap.get(roleName);
            log.info("Attempting to map role {} to {}", roleName, destRoleName);
            if (destRoleName != null) {
                Role destRole = roleDao.getByName(destRoleName.getName());
                permission = new Permission(permissionsParams.dbUser.getId(), destRole.getId(), permissionsParams.entityId, permissionsParams.objectType);
            } else if (originalRole != null) {
                log.info("Mapped role {} was not found, attempting to add role from OVF {}", destRoleName, roleName);
                permission = new Permission(permissionsParams.dbUser.getId(), originalRole.getId(), permissionsParams.entityId, permissionsParams.objectType);
            }
        } else if (originalRole != null) {
            log.info("No mapped role was not found, attempting to add role from OVF {}", roleName);
            permission = new Permission(permissionsParams.dbUser.getId(), originalRole.getId(), permissionsParams.entityId, permissionsParams.objectType);
        }
        if (permission != null) {
            permissionsToAdd.add(permission);
        } else {
            log.info("Could not find role {} or a mapping for it, will not add permissions", roleName);
            missingRoles.add(roleName);
        }
    });
}
#method_after
public void addPermissions(Set<DbUser> dbUsers, Map<String, Set<String>> userToRoles, Guid objectId, VdcObjectType objectType, Map<String, String> roleMap) {
    dbUsers.forEach(dbUser -> userToRoles.getOrDefault(dbUser.getLoginName(), Collections.emptySet()).forEach(roleName -> {
        Role role = getRelatedEntity(roleMap, roleName, val -> roleDao.getByName(val));
        if (role != null) {
            DbUser dbUserFromDB = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), dbUser.getDomain());
            Permission p = new Permission(dbUserFromDB.getId(), role.getId(), objectId, objectType);
            permissionDao.save(p);
        } else {
            log.warn("Role {} was not found", roleName);
        }
    }));
}
#end_block

#method_before
public List<AffinityGroup> mapAffinityGroups(Map<String, String> affinityGroupMap, List<AffinityGroup> affinityGroupsFromParam, Guid vmId) {
    if (affinityGroupsFromParam == null) {
        return Collections.emptyList();
    }
    List<AffinityGroup> affinityGroups = new ArrayList<>();
    affinityGroupsFromParam.forEach(affinityGroup -> {
        log.info("Mapping affinity group '{}/{} for vm '{}'.", affinityGroup.getId(), affinityGroup.getName(), vmId);
        AffinityGroup affGroup = getRelatedEntity(affinityGroupMap, affinityGroup.getName(), val -> affinityGroupDao.getByName((String) val));
        if (affGroup != null) {
            Set<Guid> vmIds = new HashSet<>(affGroup.getVmIds());
            vmIds.add(vmId);
            affGroup.setVmIds(new ArrayList<>(vmIds));
            affinityGroups.add(affGroup);
        }
    });
    return affinityGroups;
}
#method_after
public List<AffinityGroup> mapAffinityGroups(Map<String, String> affinityGroupMap, List<AffinityGroup> affinityGroupsFromParam, String vmName) {
    if (affinityGroupsFromParam == null) {
        return Collections.emptyList();
    }
    List<AffinityGroup> affinityGroupsToAdd = new ArrayList<>();
    affinityGroupsFromParam.forEach(affinityGroup -> {
        log.info("Mapping affinity group '{}' for vm '{}'.", affinityGroup.getName(), vmName);
        String mappedAffinityGroupName = affinityGroupMap.get(affinityGroup.getName());
        if (mappedAffinityGroupName == null) {
            log.warn("Mapping for affinity group '{}' not found, will use the affinity group name from OVF", affinityGroup.getName());
            affinityGroupsToAdd.add(affinityGroup);
        } else {
            log.info("Mapping for affinity group '{}' found, attempting to map to '{}'", affinityGroup.getName(), mappedAffinityGroupName);
            AffinityGroup mappedAffinityGroup = affinityGroupDao.getByName(mappedAffinityGroupName);
            AffinityGroup affinityGroupToAdd = Optional.ofNullable(mappedAffinityGroup).orElse(affinityGroup);
            log.info("Will try to add affinity group: {}", affinityGroupToAdd.getName());
            affinityGroupsToAdd.add(affinityGroupToAdd);
        }
    });
    return affinityGroupsToAdd;
}
#end_block

#method_before
public List<Label> mapAffinityLabels(Map<String, String> affinityLabelMap, Guid vmId, List<String> affinityLabelsFromParam, List<String> missingAffinityLabels) {
    if (affinityLabelsFromParam == null) {
        return Collections.emptyList();
    }
    List<Label> affinityLabels = new ArrayList<>();
    affinityLabelsFromParam.forEach(affinityLabel -> {
        log.info("Mapping affinity label '{}' for vm '{}'.", affinityLabel, vmId);
        Label affLabel = getRelatedEntity(affinityLabelMap, affinityLabel, val -> labelDao.getByName((String) val));
        if (affLabel != null) {
            affinityLabels.add(affLabel);
        } else {
            missingAffinityLabels.add(affinityLabel);
        }
    });
    return affinityLabels;
}
#method_after
public List<Label> mapAffinityLabels(Map<String, String> affinityLabelMap, String vmName, List<Label> affinityLabelsFromParam) {
    if (affinityLabelsFromParam == null) {
        return Collections.emptyList();
    }
    List<Label> affinityLabelsToAdd = new ArrayList<>();
    affinityLabelsFromParam.forEach(affinityLabel -> {
        log.info("Mapping affinity label '{}' for vm '{}'.", affinityLabel, vmName);
        String mappedAffinityLabelName = affinityLabelMap.get(affinityLabel.getName());
        if (mappedAffinityLabelName == null) {
            affinityLabelsToAdd.add(affinityLabel);
            log.warn("Mapping for affinity label '{}' not found, will use the affinity label name from OVF", affinityLabel.getName());
        } else {
            if (labelDao.getByName(mappedAffinityLabelName) == null) {
                log.warn("Mapping for affinity label '{}' not found, will use the affinity label name from OVF", affinityLabel.getName());
                affinityLabelsToAdd.add(affinityLabel);
            } else {
                log.info("Mapping for affinity label '{}' found, attempting to map to '{}'", affinityLabel.getName(), mappedAffinityLabelName);
                Label mappedAffinityLabel = labelDao.getByName(mappedAffinityLabelName);
                Label affinityLabelToAdd = Optional.ofNullable(mappedAffinityLabel).orElse(affinityLabel);
                log.info("Will try to add affinity label '{}'", affinityLabelToAdd.getName());
                affinityLabelsToAdd.add(affinityLabelToAdd);
            }
        }
    });
    return affinityLabelsToAdd;
}
#end_block

#method_before
public Set<DbUser> mapDbUsers(Map<String, String> userDomainsMap, Set<DbUser> dbUsersFromParams, Map<String, Set<String>> userToRolesFromParams, Guid entityId, VdcObjectType objectType, Map<String, Object> roleMap, List<String> missingUsers, List<String> missingRoles, List<Permission> permissionsToAdd) {
    if (dbUsersFromParams == null || userToRolesFromParams == null) {
        Collections.emptySet();
    }
    Set<DbUser> dbUsers = new HashSet<>();
    dbUsersFromParams.forEach(dbUser -> {
        DbUser originalDbUser = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), dbUser.getDomain());
        PermissionsParamObject permissionParams = null;
        if (userDomainsMap != null) {
            String destDomain = userDomainsMap.get(dbUser.getDomain());
            if (destDomain != null) {
                DbUser destDbUser = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), destDomain);
                if (destDbUser != null) {
                    dbUsers.add(destDbUser);
                    permissionParams = new PermissionsParamObject(destDbUser, userToRolesFromParams, entityId, objectType, roleMap);
                }
            } else if (originalDbUser != null) {
                dbUsers.add(originalDbUser);
                permissionParams = new PermissionsParamObject(originalDbUser, userToRolesFromParams, entityId, objectType, roleMap);
            }
        } else if (originalDbUser != null) {
            dbUsers.add(originalDbUser);
            permissionParams = new PermissionsParamObject(originalDbUser, userToRolesFromParams, entityId, objectType, roleMap);
        }
        if (permissionParams != null) {
            addPermissions(permissionParams, missingRoles, permissionsToAdd);
        } else {
            missingUsers.add(dbUser.getLoginName());
        }
    });
    return dbUsers;
}
#method_after
public Set<DbUser> mapDbUsers(Set<DbUser> dbUsers, Map<String, String> userDomainsMap) {
    if (dbUsers == null) {
        return Collections.emptySet();
    }
    Set<DbUser> dbUsersToAdd = new HashSet<>();
    dbUsers.forEach(dbUser -> {
        String destDomain = userDomainsMap.get(dbUser.getLoginName());
        if (destDomain == null) {
            dbUsersToAdd.add(dbUser);
        } else {
            DbUser destUser = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), destDomain);
            dbUsersToAdd.add(Optional.ofNullable(destUser).orElse(dbUser));
        }
    });
    return dbUsersToAdd;
}
#end_block

#method_before
private void addPermissions(PermissionsParamObject permissionsParams, List<String> missingRoles, List<Permission> permissionsToAdd) {
    Map<String, Set<String>> userToRoles = permissionsParams.userToRoles;
    userToRoles.getOrDefault(permissionsParams.dbUser.getLoginName(), Collections.emptySet()).forEach(roleName -> {
        Permission permission = null;
        Role originalRole = roleDao.getByName(roleName);
        if (permissionsParams.roleMap != null) {
            Role destRoleName = (Role) permissionsParams.roleMap.get(roleName);
            if (destRoleName != null) {
                Role destRole = roleDao.getByName(destRoleName.getName());
                permission = new Permission(permissionsParams.dbUser.getId(), destRole.getId(), permissionsParams.entityId, permissionsParams.objectType);
            } else if (originalRole != null) {
                permission = new Permission(permissionsParams.dbUser.getId(), originalRole.getId(), permissionsParams.entityId, permissionsParams.objectType);
            }
        } else if (originalRole != null) {
            permission = new Permission(permissionsParams.dbUser.getId(), originalRole.getId(), permissionsParams.entityId, permissionsParams.objectType);
        }
        if (permission != null) {
            permissionsToAdd.add(permission);
        } else {
            missingRoles.add(roleName);
        }
    });
}
#method_after
public void addPermissions(Set<DbUser> dbUsers, Map<String, Set<String>> userToRoles, Guid objectId, VdcObjectType objectType, Map<String, String> roleMap) {
    dbUsers.forEach(dbUser -> userToRoles.getOrDefault(dbUser.getLoginName(), Collections.emptySet()).forEach(roleName -> {
        Role role = getRelatedEntity(roleMap, roleName, val -> roleDao.getByName(val));
        if (role != null) {
            DbUser dbUserFromDB = dbUserDao.getByUsernameAndDomain(dbUser.getLoginName(), dbUser.getDomain());
            Permission p = new Permission(dbUserFromDB.getId(), role.getId(), objectId, objectType);
            permissionDao.save(p);
        } else {
            log.warn("Role {} was not found", roleName);
        }
    }));
}
#end_block

#method_before
@Override
protected boolean validate() {
    initVmTemplate();
    ArrayList<DiskImage> disks = new ArrayList(getVmTemplate().getDiskTemplateMap().values());
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), disks);
    getVmTemplate().setImages(disks);
    if (getParameters().isImagesExistOnTargetStorageDomain() && !validateUnregisteredEntity(vmTemplateFromConfiguration, ovfEntityData)) {
        return false;
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    initVmTemplate();
    if (!super.validate()) {
        return false;
    }
    if (!validateExternalVnicProfileMapping()) {
        return false;
    }
    drMappingHelper.mapVnicProfiles(vmTemplateFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings());
    ArrayList<DiskImage> disks = new ArrayList(getVmTemplate().getDiskTemplateMap().values());
    setImagesWithStoragePoolId(getStorageDomain().getStoragePoolId(), disks);
    getVmTemplate().setImages(disks);
    if (getParameters().isImagesExistOnTargetStorageDomain() && !validateUnregisteredEntity(vmTemplateFromConfiguration, ovfEntityData)) {
        return false;
    }
    log.info("Checking for missing users");
    List<DbUser> dbMissingUsers = getImportValidator().findMissingUsers(getParameters().getDbUsers());
    getParameters().getDbUsers().removeAll(dbMissingUsers);
    Set<String> roles = new HashSet<>(getParameters().getRoleMap().values());
    roles.addAll(getParameters().getRoleMap().keySet());
    log.info("Checking for missing roles");
    missingRoles = getImportValidator().findMissingEntities(roles, val -> roleDao.getByName(val));
    getParameters().getUserToRoles().forEach((k, v) -> v.removeAll(missingRoles));
    return super.validate();
}
#end_block

#method_before
private boolean validateUnregisteredEntity(VmTemplate entityFromConfiguration, OvfEntityData ovfEntityData) {
    if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
    }
    if (entityFromConfiguration == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
    }
    for (DiskImage image : new ArrayList<>(getImages())) {
        DiskImage fromIrs = null;
        Guid storageDomainId = image.getStorageIds().get(0);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        try {
            fromIrs = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(getStoragePool().getId(), storageDomainId, imageGroupId, image.getImageId())).getReturnValue();
        } catch (Exception e) {
            log.debug("Unable to get image info from storage", e);
        }
        if (fromIrs == null) {
            if (!getParameters().isAllowPartialImport()) {
                return failValidation(EngineMessage.TEMPLATE_IMAGE_NOT_EXIST);
            }
            log.warn("Disk image '{}/{}' doesn't exist on storage domain '{}'. Ignoring since force flag in on", imageGroupId, image.getImageId(), storageDomainId);
            getImages().remove(image);
            failedDisksToImportForAuditLog.putIfAbsent(image.getId(), image.getDiskAlias());
        }
    }
    for (DiskImage image : getImages()) {
        StorageDomain sd = storageDomainDao.getForStoragePool(image.getStorageIds().get(0), getStoragePool().getId());
        if (!validate(new StorageDomainValidator(sd).isDomainExistAndActive())) {
            return false;
        }
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", getParameters().getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
    }
    return true;
}
#method_after
private boolean validateUnregisteredEntity(VmTemplate entityFromConfiguration, OvfEntityData ovfEntityData) {
    if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
    }
    if (entityFromConfiguration == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
    }
    ImportValidator importValidator = new ImportValidator(getParameters());
    if (!validate(importValidator.validateDiskNotAlreadyExistOnDB(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
        return false;
    }
    for (DiskImage image : new ArrayList<>(getImages())) {
        DiskImage fromIrs = null;
        Guid storageDomainId = image.getStorageIds().get(0);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        try {
            fromIrs = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(getStoragePool().getId(), storageDomainId, imageGroupId, image.getImageId())).getReturnValue();
        } catch (Exception e) {
            log.debug("Unable to get image info from storage", e);
        }
        if (fromIrs == null) {
            if (!getParameters().isAllowPartialImport()) {
                return failValidation(EngineMessage.TEMPLATE_IMAGE_NOT_EXIST);
            }
            log.warn("Disk image '{}/{}' doesn't exist on storage domain '{}'. Ignoring since force flag in on", imageGroupId, image.getImageId(), storageDomainId);
            getImages().remove(image);
            failedDisksToImportForAuditLog.putIfAbsent(image.getId(), image.getDiskAlias());
        }
    }
    for (DiskImage image : getImages()) {
        StorageDomain sd = storageDomainDao.getForStoragePool(image.getStorageIds().get(0), getStoragePool().getId());
        if (!validate(new StorageDomainValidator(sd).isDomainExistAndActive())) {
            return false;
        }
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", getParameters().getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
    }
    return true;
}
#end_block

#method_before
private void initVmTemplate() {
    List<OvfEntityData> ovfEntityList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                mapCluster(fullEntityOvfData);
            }
            vmTemplateFromConfiguration.setClusterId(getParameters().getClusterId());
            setVmTemplate(vmTemplateFromConfiguration);
            setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getVmTemplate(), this::getCluster));
            vmHandler.updateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion());
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            getParameters().setDbUsers(drMappingHelper.mapDbUsers(getParameters().getDomainMap(), getParameters().getDbUsers(), getParameters().getUserToRoles(), getVmId(), VdcObjectType.VM, getParameters().getRoleMap(), missingUsers, missingRoles, permissionsToAdd));
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setClusterId(getParameters().getClusterId());
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
}
#method_after
private void initVmTemplate() {
    List<OvfEntityData> ovfEntityList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmTemplateFromOvf(ovfEntityData.getOvfData());
            vmTemplateFromConfiguration = fullEntityOvfData.getVmTemplate();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                mapCluster(fullEntityOvfData);
            }
            vmTemplateFromConfiguration.setClusterId(getParameters().getClusterId());
            setVmTemplate(vmTemplateFromConfiguration);
            setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getVmTemplate(), this::getCluster));
            vmHandler.updateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion());
            getParameters().setVmTemplate(vmTemplateFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskTemplateMap() != null) {
                ArrayList imageList = new ArrayList<>(getParameters().getDiskTemplateMap().values());
                vmTemplateFromConfiguration.setDiskList(imageList);
                ensureDomainMap(imageList, getParameters().getDestDomainId());
            }
            if (getParameters().getDomainMap() != null) {
                getParameters().setDbUsers(drMappingHelper.mapDbUsers(fullEntityOvfData.getDbUsers(), getParameters().getDomainMap()));
            } else {
                getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
    setClusterId(getParameters().getClusterId());
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
}
#end_block

#method_before
private void mapCluster(FullEntityOvfData fullEntityOvfData) {
    vmTemplateFromConfiguration = fullEntityOvfData.getVmTemplate();
    Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmTemplateFromConfiguration.getId(), getParameters().getClusterMap());
    if (cluster != null) {
        getParameters().setClusterId(cluster.getId());
    }
}
#method_after
private void mapCluster(FullEntityOvfData fullEntityOvfData) {
    Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmTemplateFromConfiguration.getId(), getParameters().getClusterMap());
    if (cluster != null) {
        getParameters().setClusterId(cluster.getId());
    }
}
#end_block

#method_before
@Override
protected void addPermissionsToDB() {
    permissionsToAdd.forEach(permission -> permissionDao.save(permission));
}
#method_after
@Override
protected void addPermissionsToDB() {
    drMappingHelper.addPermissions(getParameters().getDbUsers(), getParameters().getUserToRoles(), getVmTemplateId(), VdcObjectType.VmTemplate, getParameters().getRoleMap());
}
#end_block

#method_before
@Override
public void executeCommand() {
    addAuditLogForPartialVMs();
    super.executeCommand();
    if (getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!getImages().isEmpty()) {
            findAndSaveDiskCopies();
            getImages().stream().forEach(diskImage -> {
                initQcowVersionForDisks(diskImage.getId());
            });
        }
        unregisteredOVFDataDao.removeEntity(ovfEntityData.getEntityId(), null);
        unregisteredDisksDao.removeUnregisteredDiskRelatedToVM(ovfEntityData.getEntityId(), null);
    }
    setActionReturnValue(getVmTemplate().getId());
    setSucceeded(true);
}
#method_after
@Override
public void executeCommand() {
    super.executeCommand();
    addAuditLogForPartialVMs();
    if (getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!getImages().isEmpty()) {
            findAndSaveDiskCopies();
            getImages().stream().forEach(diskImage -> {
                initQcowVersionForDisks(diskImage.getId());
            });
        }
        unregisteredOVFDataDao.removeEntity(ovfEntityData.getEntityId(), null);
        unregisteredDisksDao.removeUnregisteredDiskRelatedToVM(ovfEntityData.getEntityId(), null);
    }
    setActionReturnValue(getVmTemplate().getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    List<VmNetworkInterface> nicsUnableToBeImported = getVm().getInterfaces().stream().filter(this::ifaceMacCannotBeAddedToMacPool).collect(Collectors.toList());
    if (!nicsUnableToBeImported.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_ADD_IFACE_DUE_TO_MAC_DUPLICATES;
        Collection<String> replacements = ReplacementUtils.getListVariableAssignmentString(engineMessage, nicsUnableToBeImported);
        return validate(new ValidationResult(engineMessage, replacements));
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getVm().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getParameters().getStoragePoolId() != null && !getParameters().getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
    }
    macPool = getMacPool();
    List<VmNetworkInterface> nicsUnableToBeImported = getVm().getInterfaces().stream().filter(this::ifaceMacCannotBeAddedToMacPool).collect(Collectors.toList());
    if (!nicsUnableToBeImported.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_ADD_IFACE_DUE_TO_MAC_DUPLICATES;
        Collection<String> replacements = ReplacementUtils.getListVariableAssignmentString(engineMessage, nicsUnableToBeImported);
        return validate(new ValidationResult(engineMessage, replacements));
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getVm().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (isImagesAlreadyOnTarget()) {
        if (!validateExternalVnicProfileMapping()) {
            return false;
        }
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(vmFromConfiguration, ovfEntityData))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistForUnregisteredEntity(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistsForMemoryDisks(getVm().getSnapshots(), getParameters().isAllowPartialImport(), failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!drMappingHelper.validateAffinityGroupCluster(getParameters().getAffinityGroups(), getClusterId()) && !getParameters().isAllowPartialImport()) {
            return false;
        }
        if (!AffinityRulesUtils.checkForAffinityGroupHostsConflict(getParameters().getAffinityGroups()).isEmpty() && !getParameters().isAllowPartialImport()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_AFFINITY_RULES_COLLISION);
        }
        if (!missingAffinityLabels.isEmpty() && !getParameters().isAllowPartialImport()) {
            log.error("Missing affinity labels: {}", missingAffinityLabels.stream().collect(Collectors.joining(",")));
            return failValidation(EngineMessage.AFFINITY_LABEL_NOT_EXISTS);
        }
        if (!missingUsers.isEmpty() && !getParameters().isAllowPartialImport()) {
            log.error("Missing users: {}", missingUsers.stream().collect(Collectors.joining(",")));
            return failValidation(EngineMessage.USER_MUST_EXIST_IN_DB);
        }
        if (!missingRoles.isEmpty() && !getParameters().isAllowPartialImport()) {
            log.error("Missing roles: {}", missingRoles.stream().collect(Collectors.joining(", ")));
            return false;
        }
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (isImagesAlreadyOnTarget()) {
        if (!validateExternalVnicProfileMapping()) {
            return false;
        }
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(ovfEntityData))) {
            return false;
        }
        if (!validate(importValidator.validateDiskNotAlreadyExistOnDB(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistForUnregisteredEntity(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistsForMemoryDisks(getVm().getSnapshots(), getParameters().isAllowPartialImport(), failedDisksToImportForAuditLog))) {
            return false;
        }
        removeInvalidAffinityGroups(importValidator);
        removeInvalidAffinityLabels(importValidator);
        removeInavlidUsers(importValidator);
        removeInavlidRoles(importValidator);
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return true;
}
#end_block

#method_before
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmFromConfiguration.getId(), getParameters().getClusterMap());
                if (cluster != null) {
                    getParameters().setClusterId(cluster.getId());
                }
            }
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            // Note: The VM's OVF does not preserve the username and password for the LUN's connection.
            // Therefore to achieve a simple VM registration the iSCSI storage server should not use
            // credentials, although if the user will use the mapping attribute, one can set the credentials through
            // there.
            drMappingHelper.mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()), getParameters().getExternalLunMap());
            getParameters().setAffinityGroups(drMappingHelper.mapAffinityGroups(getParameters().getAffinityGroupMap(), fullEntityOvfData.getAffinityGroups(), getVmId()));
            getParameters().setAffinityLabels(drMappingHelper.mapAffinityLabels(getParameters().getAffinityLabelMap(), getVmId(), fullEntityOvfData.getAffinityLabels(), missingAffinityLabels));
            getParameters().setDbUsers(drMappingHelper.mapDbUsers(getParameters().getDomainMap(), getParameters().getDbUsers(), getParameters().getUserToRoles(), getVmId(), VdcObjectType.VM, getParameters().getRoleMap(), missingUsers, missingRoles, permissionsToAdd));
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmFromConfiguration.getId(), getParameters().getClusterMap());
                if (cluster != null) {
                    getParameters().setClusterId(cluster.getId());
                }
            }
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            // Note: The VM's OVF does not preserve the username and password for the LUN's connection.
            // Therefore to achieve a simple VM registration the iSCSI storage server should not use
            // credentials, although if the user will use the mapping attribute, one can set the credentials through
            // there.
            drMappingHelper.mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()), getParameters().getExternalLunMap());
            mapEntities(fullEntityOvfData);
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
protected void addPermissionsToDB() {
    permissionsToAdd.forEach(permission -> permissionDao.save(permission));
}
#method_after
protected void addPermissionsToDB() {
    drMappingHelper.addPermissions(getParameters().getDbUsers(), getParameters().getUserToRoles(), getVmId(), VdcObjectType.VM, getParameters().getRoleMap());
}
#end_block

#method_before
@Override
public void addVmToAffinityGroups() {
    getParameters().getAffinityGroups().forEach(affinityGroup -> affinityGroupDao.save(affinityGroup));
}
#method_after
@Override
public void addVmToAffinityGroups() {
    cachedAffinityGroups.forEach(affinityGroup -> affinityGroupDao.update(affinityGroup));
}
#end_block

#method_before
@Override
public void addVmToAffinityLabels() {
    getParameters().getAffinityLabels().forEach(affinityLabel -> {
        affinityLabel.addVm(getParameters().getVm());
        labelDao.update(affinityLabel);
    });
}
#method_after
@Override
public void addVmToAffinityLabels() {
    cachedAffinityLabels.forEach(affinityLabel -> {
        affinityLabel.addVm(getParameters().getVm());
        labelDao.update(affinityLabel);
    });
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVmTemplate() == null) {
        return false;
    }
    setDescription(getVmTemplateName());
    // check that the storage pool is valid
    if (!validate(createStoragePoolValidator().exists()) || !validateTemplateArchitecture() || !isClusterCompatible()) {
        return false;
    }
    // set the source domain and check that it is ImportExport type and active
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
    if (!validate(sourceDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    if ((getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !getParameters().isImagesExistOnTargetStorageDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!getParameters().isImagesExistOnTargetStorageDomain()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        QueryReturnValue qretVal = runInternalQuery(QueryType.GetTemplatesFromExportDomain, tempVar);
        if (!qretVal.getSucceeded()) {
            return false;
        }
        Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
        ArrayList<DiskImage> images = new ArrayList<>();
        for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
            if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                images = new ArrayList<>(entry.getValue());
                getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                break;
            }
        }
        getParameters().setImages(images);
        getVmTemplate().setImages(images);
        ensureDomainMap(getImages(), getParameters().getDestDomainId());
        HashMap<Guid, DiskImage> imageMap = new HashMap<>();
        for (DiskImage image : images) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
            changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
            if (!ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getValidationMessages())) {
                return false;
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            image.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
            imageMap.put(image.getImageId(), image);
        }
        getVmTemplate().setDiskImageMap(imageMap);
    }
    sourceTemplateId = getVmTemplateId();
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    VmTemplate duplicateTemplate = vmTemplateDao.get(getParameters().getVmTemplate().getId());
    // check that the template does not exists in the target domain
    if (duplicateTemplate != null) {
        return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS, String.format("$TemplateName %1$s", duplicateTemplate.getName()));
    }
    if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
        return failValidation(EngineMessage.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
    }
    if (!validateNoDuplicateDiskImages(getImages())) {
        return false;
    }
    if (getImages() != null && !getImages().isEmpty() && !getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVmTemplate().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
        return false;
    }
    // if this is a template version, check base template exist
    if (!getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = vmTemplateDao.get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getVmTemplate().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (!getCluster().getStoragePoolId().equals(getStoragePoolId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
    }
    setDescription(getVmTemplateName());
    // check that the storage pool is valid
    if (!validate(createStoragePoolValidator().exists()) || !validateTemplateArchitecture() || !isClusterCompatible()) {
        return false;
    }
    // set the source domain and check that it is ImportExport type and active
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
    if (!validate(sourceDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    if ((getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !getParameters().isImagesExistOnTargetStorageDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!getParameters().isImagesExistOnTargetStorageDomain()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        QueryReturnValue qretVal = runInternalQuery(QueryType.GetTemplatesFromExportDomain, tempVar);
        if (!qretVal.getSucceeded()) {
            return false;
        }
        Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
        ArrayList<DiskImage> images = new ArrayList<>();
        for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
            if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                images = new ArrayList<>(entry.getValue());
                getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                break;
            }
        }
        getParameters().setImages(images);
        getVmTemplate().setImages(images);
        ensureDomainMap(getImages(), getParameters().getDestDomainId());
        HashMap<Guid, DiskImage> imageMap = new HashMap<>();
        for (DiskImage image : images) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
            changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
            if (!ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getValidationMessages())) {
                return false;
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            image.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
            imageMap.put(image.getImageId(), image);
        }
        getVmTemplate().setDiskImageMap(imageMap);
    }
    sourceTemplateId = getVmTemplateId();
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    VmTemplate duplicateTemplate = vmTemplateDao.get(getParameters().getVmTemplate().getId());
    // check that the template does not exists in the target domain
    if (duplicateTemplate != null) {
        return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS, String.format("$TemplateName %1$s", duplicateTemplate.getName()));
    }
    if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
        return failValidation(EngineMessage.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
    }
    if (!validateNoDuplicateDiskImages(getImages())) {
        return false;
    }
    if (getImages() != null && !getImages().isEmpty() && !getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVmTemplate().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
        return false;
    }
    // if this is a template version, check base template exist
    if (!getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = vmTemplateDao.get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getVmTemplate().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        initImportClonedTemplateDisks();
        addVmTemplateToDb();
        addPermissionsToDB();
        updateOriginalTemplateNameOnDerivedVms();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        vmHandler.addVmInitToDB(getVmTemplate().getVmInit());
        return null;
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !getParameters().isImagesExistOnTargetStorageDomain()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    getVmDeviceUtils().addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity(), false);
    if (!doesVmTemplateContainImages || getParameters().isImagesExistOnTargetStorageDomain()) {
        endMoveOrCopyCommand();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmTemplateId());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        initImportClonedTemplateDisks();
        addVmTemplateToDb();
        addPermissionsToDB();
        updateOriginalTemplateNameOnDerivedVms();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        vmHandler.addVmInitToDB(getVmTemplate().getVmInit());
        return null;
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !getParameters().isImagesExistOnTargetStorageDomain()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    getVmDeviceUtils().addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity(), false);
    if (!doesVmTemplateContainImages || getParameters().isImagesExistOnTargetStorageDomain()) {
        endMoveOrCopyCommand();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmTemplateId());
    checkTrustedService();
    incrementDbGeneration();
    setSucceeded(true);
}
#end_block

#method_before
protected void addPermissionsToDB() {
// Left empty to override in ImportVmFromConfiguration
}
#method_after
protected void addPermissionsToDB() {
// Left empty to be overriden in ImportVmTemplateFromConfigurationCommand
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.VmTemplate.name().toLowerCase(), (getVmTemplateName() == null) ? "" : getVmTemplateName());
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.VmTemplate.name().toLowerCase(), (getVmTemplateName() == null) ? "" : getVmTemplateName());
        jobProperties.put(VdcObjectType.Cluster.name().toLowerCase(), getClusterName());
    }
    return jobProperties;
}
#end_block

#method_before
protected boolean isRunningVmsWithIsoAttached() {
    List<String> vmNames = getStorageDomain().getStorageDomainType() == StorageDomainType.ISO ? getVmsWithAttachedISO() : vmStaticDao.getAllRunningNamesWithOsiOnStorageDomain(getStorageDomainId());
    if (!vmNames.isEmpty()) {
        return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_STORAGE_DOMAIN_WITH_ISO_ATTACHED, String.format("$VmNames %1$s", String.join(",", vmNames)));
    }
    return true;
}
#method_after
protected boolean isRunningVmsWithIsoAttached() {
    List<String> vmNames = getStorageDomain().getStorageDomainType() == StorageDomainType.ISO ? getVmsWithAttachedISO() : vmStaticDao.getAllRunningNamesWithIsoOnStorageDomain(getStorageDomainId());
    if (!vmNames.isEmpty()) {
        return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_STORAGE_DOMAIN_WITH_ISO_ATTACHED, String.format("$VmNames %1$s", String.join(",", vmNames)));
    }
    return true;
}
#end_block

#method_before
@Before
public void setUp() {
    disk = createDiskImage();
    disk.setDiskAlias("disk1");
    validator = spy(new DiskValidator(disk));
    doReturn(vmDao).when(validator).getVmDao();
}
#method_after
@Before
public void setUp() {
    disk = createDiskImage();
    disk.setDiskAlias("disk1");
    validator = spy(new DiskValidator(disk));
    doReturn(vmDao).when(validator).getVmDao();
    doReturn(diskImageDao).when(validator).getDiskImageDao();
}
#end_block

#method_before
@Test
public void canCopyDiskFails() {
    StorageDomain domain = createStorageDomainForDisk(StorageType.ISCSI);
    DiskImage child = createDiskImage();
    child.setSize(1000);
    child.setStorageIds(Collections.singletonList(domain.getId()));
    DiskImage parent = createDiskImage();
    parent.setId(Guid.newGuid());
    parent.setSize(500);
    parent.setStorageIds(Collections.singletonList(domain.getId()));
    child.setParentId(parent.getParentId());
    List<DiskImage> diskImages = new ArrayList<>(2);
    diskImages.add(parent);
    diskImages.add(child);
    assertThat(validator.diskCanBeCopied(diskImages, QcowCompat.QCOW2_V2, 1000), failsWith(EngineMessage.CANNOT_MOVE_DISK));
}
#method_after
@Test
public void canCopyDiskFails() {
    StorageDomain domain = createStorageDomainForDisk(StorageType.ISCSI);
    domain.setStorageFormat(StorageFormatType.V3);
    disk.setSize(1000);
    DiskImage child = createDiskImage();
    child.setSize(1000);
    child.setStorageIds(Collections.singletonList(domain.getId()));
    DiskImage parent = createDiskImage();
    parent.setId(Guid.newGuid());
    parent.setSize(500);
    parent.setStorageIds(Collections.singletonList(domain.getId()));
    child.setParentId(parent.getParentId());
    List<DiskImage> diskImages = new ArrayList<>(2);
    diskImages.add(parent);
    diskImages.add(child);
    when(validator.getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId())).thenReturn(diskImages);
    assertThat(validator.diskWasExtendedAfterSnapshotWasTaken(domain), failsWith(EngineMessage.CANNOT_MOVE_DISK));
}
#end_block

#method_before
@Override
protected boolean validate() {
    return super.validate() && canDiskBeMoved() && isImageExist() && checkOperationIsCorrect() && checkOperationAllowedOnDiskContentType() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && validateVmSnapshotStatus() && checkCanBeMoveInVm() && checkIfNeedToBeOverride() && setAndValidateDiskProfiles() && setAndValidateQuota() && validatePassDiscardSupportedForDestinationStorageDomain();
}
#method_after
@Override
protected boolean validate() {
    return super.validate() && diskContainsPreExtendSnapshots() && isImageExist() && checkOperationIsCorrect() && checkOperationAllowedOnDiskContentType() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && validateVmSnapshotStatus() && checkCanBeMoveInVm() && checkIfNeedToBeOverride() && setAndValidateDiskProfiles() && setAndValidateQuota() && validatePassDiscardSupportedForDestinationStorageDomain();
}
#end_block

#method_before
public static void updateNetworkData(VDS vds, Map<String, String> vdsmNameMap, Map<String, Object> struct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, struct);
    addHostVlanDevices(vds, struct);
    addHostBondDevices(vds, struct);
    addHostNetworksAndUpdateInterfaces(vds, vdsmNameMap, struct);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (struct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(assignBoolValue(struct, VdsProperties.netConfigDirty));
    }
}
#method_after
public static void updateNetworkData(VDS vds, Map<String, String> vdsmNameMap, Map<String, Object> struct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, struct);
    addHostVlanDevices(vds, struct);
    addHostBondDevices(vds, struct);
    addHostNetworksAndUpdateInterfaces(vds, vdsmNameMap, struct);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (struct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(assignBoolValue(struct, VdsProperties.netConfigDirty));
    }
    setVlanSpeeds(vds);
}
#end_block

#method_before
@PostConstruct
private void init() {
    // It is sufficient to refresh only the devices of 'UP' hosts since other hosts
    // will have their devices refreshed in InitVdsOnUpCommand.
    // This cannot be run from @PostConstruct method directly, because RefreshHostDevices command injects
    // this bean within itself, which causes recursion loop and prevents engine to startup successfully.
    ThreadPoolUtil.execute(() -> {
        List<ActionParametersBase> parameters = hostDynamicDao.getIdsOfHostsWithStatus(VDSStatus.Up).stream().map(hostId -> new VdsActionParameters(hostId)).collect(Collectors.toList());
        backend.runInternalMultipleActions(ActionType.RefreshHostDevices, parameters);
        hostDeviceDao.cleanDownVms();
    });
}
#method_after
@PostConstruct
private void init() {
    // It is sufficient to refresh only the devices of 'UP' hosts since other hosts
    // will have their devices refreshed in InitVdsOnUpCommand
    List<ActionParametersBase> parameters = hostDynamicDao.getIdsOfHostsWithStatus(VDSStatus.Up).stream().map(hostId -> new VdsActionParameters(hostId)).collect(Collectors.toList());
    backend.runInternalMultipleActions(ActionType.RefreshHostDevices, parameters);
    hostDeviceDao.cleanDownVms();
}
#end_block

#method_before
public void selectProviderById(Guid providerId) {
    if (getNetworkProviders().getItems() != null) {
        Provider provider = getNetworkProviders().getItems().stream().filter(candidate -> Objects.equals(candidate.getId(), providerId)).findFirst().orElse(null);
        getNetworkProviders().setSelectedItem(provider);
    }
}
#method_after
public void selectProviderById(Guid providerId) {
    if (getNetworkProviders().getItems() != null) {
        Provider provider = getNetworkProviders().getItems().stream().filter(candidate -> Objects.equals(candidate.getId(), providerId)).findFirst().orElse(getNoExternalNetworkProvider());
        getNetworkProviders().setSelectedItem(provider);
    }
}
#end_block

#method_before
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // Load the thread pools
    serviceLoader.load(EngineThreadPools.class);
    // Load the thread monitoring service
    serviceLoader.load(ThreadPoolMonitoringService.class);
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        macPoolPerCluster.logFreeMacs();
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensator.compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    serviceLoader.load(AsyncTaskManager.class);
    serviceLoader.load(CommandCoordinatorUtil.class);
    serviceLoader.load(CommandCallbacksPoller.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // Load the thread pools
    serviceLoader.load(EngineThreadPools.class);
    // Load the thread monitoring service
    serviceLoader.load(ThreadPoolMonitoringService.class);
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        macPoolPerCluster.logFreeMacs();
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensator.compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
protected DefaultCompensationContext createDefaultCompensationContext() {
    DefaultCompensationContext defaultContext = new DefaultCompensationContext();
    defaultContext.setCommandId(commandId);
    defaultContext.setCommandType(getActionType());
    defaultContext.setBusinessEntitySnapshotDao(businessEntitySnapshotDao);
    defaultContext.setSnapshotSerializer(SerializationFactory.getSerializer());
    return defaultContext;
}
#method_after
protected DefaultCompensationContext createDefaultCompensationContext() {
    DefaultCompensationContext defaultContext = new DefaultCompensationContext();
    defaultContext.setCommandId(commandId);
    defaultContext.setCommandType(getClass().getName());
    defaultContext.setBusinessEntitySnapshotDao(businessEntitySnapshotDao);
    defaultContext.setSnapshotSerializer(SerializationFactory.getSerializer());
    return defaultContext;
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected void compensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    // If the compensation data is not for the command do not perform compensation.
    if (!commandId.equals(getCompensationContext().getCommandId())) {
        return;
    }
    compensator.compensate(commandId, getActionType(), getCompensationContext());
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected void compensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    // If the compensation data is not for the command do not perform compensation.
    if (!commandId.equals(getCompensationContext().getCommandId())) {
        return;
    }
    compensator.compensate(commandId, getClass().getName(), getCompensationContext());
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
            setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY, false);
        } else {
            internalEndWithFailure();
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE, false);
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        if (TransactionSupport.current() == null) {
            try {
                getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean useCompensation = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
            setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY, false);
        } else {
            internalEndWithFailure();
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE, false);
            if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) {
                useCompensation = true;
            }
        }
    } catch (RuntimeException e) {
        useCompensation = true;
        throw e;
    } finally {
        if (TransactionSupport.current() == null) {
            try {
                getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!useCompensation && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        executeCommand();
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
            if (commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(noAsyncOperations() ? CommandStatus.ENDED_WITH_FAILURE : CommandStatus.EXECUTION_FAILED);
            }
        } else {
            // set the status to ENDED_SUCCESSFULLY if the status is ACTIVE
            if (getReturnValue().getVdsmTaskIdList().isEmpty() && getReturnValue().getInternalVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
            }
            getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        executeCommand();
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
            if (commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(noAsyncOperations() ? CommandStatus.ENDED_WITH_FAILURE : CommandStatus.EXECUTION_FAILED);
            }
        } else {
            // set the status to ENDED_SUCCESSFULLY if the status is ACTIVE
            if (getReturnValue().getVdsmTaskIdList().isEmpty() && getReturnValue().getInternalVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
            }
            if (getCommandCompensationPhase() == CommandCompensationPhase.EXECUTION) {
                getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
            }
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
public void compensate() {
    // get all command snapshot entries
    List<KeyValue> commandSnapshots = businessEntitySnapshotDao.getAllCommands();
    for (KeyValue commandSnapshot : commandSnapshots) {
        // create an instance of the related command by its class name and command id
        try {
            compensate((Guid) commandSnapshot.getKey(), (ActionType) commandSnapshot.getValue(), null);
        } catch (RuntimeException e) {
            log.error("Failed to run compensation on startup for Command '{}', Command Id '{}': {}", commandSnapshot.getValue(), commandSnapshot.getKey(), e.getMessage());
            log.error("Exception", e);
        }
        log.info("Running compensation on startup for Command '{}', Command Id '{}'", commandSnapshot.getValue(), commandSnapshot.getKey());
    }
}
#method_after
public void compensate() {
    // get all command snapshot entries
    List<KeyValue> commandSnapshots = businessEntitySnapshotDao.getAllCommands();
    for (KeyValue commandSnapshot : commandSnapshots) {
        // create an instance of the related command by its class name and command id
        try {
            compensate((Guid) commandSnapshot.getKey(), (String) commandSnapshot.getValue(), null);
        } catch (RuntimeException e) {
            log.error("Failed to run compensation on startup for Command '{}', Command Id '{}': {}", commandSnapshot.getValue(), commandSnapshot.getKey(), e.getMessage());
            log.error("Exception", e);
        }
        log.info("Running compensation on startup for Command '{}', Command Id '{}'", commandSnapshot.getValue(), commandSnapshot.getKey());
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
public void compensate(Guid commandId, ActionType actionType, CompensationContext compensationContext) {
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = businessEntitySnapshotDao.getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == BusinessEntitySnapshot.SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    BusinessEntitySnapshot.EntityStatusSnapshot entityStatusSnapshot = (BusinessEntitySnapshot.EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) getDaoForEntity(entityClass)).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    deletedOrUpdateEntity(entityClass, (BusinessEntity<Serializable>) snapshotData);
                    break;
                case UPDATED_ONLY_ENTITY:
                    getDaoForEntity(entityClass).update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    getDaoForEntity(entityClass).remove(snapshotData);
                    break;
                case TRANSIENT_ENTITY:
                    objectCompensation.compensate(actionType, (TransientCompensationBusinessEntity) snapshotData);
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Unknown %s value, unable to compensate value %s.", BusinessEntitySnapshot.SnapshotType.class.getName(), snapshot.getSnapshotType()));
            }
        }
        if (compensationContext == null) {
            businessEntitySnapshotDao.removeAllForCommandId(commandId);
        } else {
            compensationContext.afterCompensationCleanup();
        }
        return null;
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
public void compensate(Guid commandId, String commandType, CompensationContext compensationContext) {
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = businessEntitySnapshotDao.getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == BusinessEntitySnapshot.SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    BusinessEntitySnapshot.EntityStatusSnapshot entityStatusSnapshot = (BusinessEntitySnapshot.EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) getDaoForEntity(entityClass)).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    deletedOrUpdateEntity(entityClass, (BusinessEntity<Serializable>) snapshotData);
                    break;
                case UPDATED_ONLY_ENTITY:
                    getDaoForEntity(entityClass).update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    getDaoForEntity(entityClass).remove(snapshotData);
                    break;
                case TRANSIENT_ENTITY:
                    objectCompensation.compensate(commandType, (TransientCompensationBusinessEntity) snapshotData);
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Unknown %s value, unable to compensate value %s.", BusinessEntitySnapshot.SnapshotType.class.getName(), snapshot.getSnapshotType()));
            }
        }
        if (compensationContext == null) {
            businessEntitySnapshotDao.removeAllForCommandId(commandId);
        } else {
            compensationContext.afterCompensationCleanup();
        }
        return null;
    });
}
#end_block

#method_before
public void compensate(ActionType command, TransientCompensationBusinessEntity entity) {
    switch(entity.getTransientEntityType()) {
        case RELEASE_MACS:
            handleReleaseMacsCompensation((ReleaseMacsTransientCompensation) entity);
            break;
        default:
            throw new IllegalArgumentException(String.format("Unable to compensate type %s, please handle this compensation in command %s.", BusinessEntitySnapshot.SnapshotType.TRANSIENT_ENTITY, command.name()));
    }
}
#method_after
public void compensate(String commandType, TransientCompensationBusinessEntity entity) {
    switch(entity.getTransientEntityType()) {
        case RELEASE_MACS:
            handleReleaseMacsCompensation((ReleaseMacsTransientCompensation) entity);
            break;
        default:
            throw new IllegalArgumentException(String.format("Unable to compensate type %s, please handle this compensation in command %s.", BusinessEntitySnapshot.SnapshotType.TRANSIENT_ENTITY, commandType));
    }
}
#end_block

#method_before
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    if (volInfo == null) {
                        // Fallback to the file-based connection
                        writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    } else {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
            }
            diskMetadata.put(dev, createDiskUuidsMap(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    // drop to the 'file' case as a fallback.
                    if (volInfo != null) {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#end_block

#method_before
public VmDevice createSysprepPayloadDevice(String sysPrepContent, VM vm) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(osRepository.getSysprepFileName(vm.getOs(), vm.getCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    return new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", vmPayload.getSpecParams(), true, true, true, "", null, null, null);
}
#method_after
public VmDevice createSysprepPayloadDevice(String sysPrepContent, VM vm) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(osRepository.getSysprepFileName(vm.getOs(), vm.getCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), StandardCharsets.UTF_8));
    return new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", vmPayload.getSpecParams(), true, true, true, "", null, null, null);
}
#end_block

#method_before
public VmDevice createCloudInitPayloadDevice(Map<String, byte[]> cloudInitContent, VM vm) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), new String(BASE_64.encode(entry.getValue()), Charset.forName(CharEncoding.UTF_8)));
    }
    return new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", vmPayload.getSpecParams(), true, true, true, "", null, null, null);
}
#method_after
public VmDevice createCloudInitPayloadDevice(Map<String, byte[]> cloudInitContent, VM vm) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), new String(BASE_64.encode(entry.getValue()), StandardCharsets.UTF_8));
    }
    return new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", vmPayload.getSpecParams(), true, true, true, "", null, null, null);
}
#end_block

#method_before
public Map<String, Object> convert(Guid vmId, Guid hostId, String xml) throws Exception {
    addressToHostDeviceSupplier = new MemoizingSupplier<>(() -> hostDeviceDao.getHostDevicesByHostId(hostId).stream().filter(device -> !device.getAddress().isEmpty()).collect(Collectors.toMap(HostDevice::getAddress, device -> device)));
    String devicesXml = xml.substring(xml.indexOf(DEVICES_START_ELEMENT), xml.indexOf(DEVICES_END_ELEMENT) + DEVICES_END_ELEMENT.length());
    XmlDocument document = new XmlDocument(devicesXml);
    Map<String, Object> result = new HashMap<>();
    result.put(VdsProperties.vm_guid, vmId.toString());
    result.put(VdsProperties.Devices, parseDevices(vmId, hostId, document));
    return result;
}
#method_after
public Map<String, Object> convert(Guid vmId, Guid hostId, String xml) throws Exception {
    addressToHostDeviceSupplier = new MemoizingSupplier<>(() -> hostDeviceDao.getHostDevicesByHostId(hostId).stream().filter(device -> !device.getAddress().isEmpty()).collect(Collectors.toMap(HostDevice::getAddress, device -> device)));
    String devicesXml = xml.substring(xml.indexOf(DEVICES_START_ELEMENT), xml.indexOf(DEVICES_END_ELEMENT) + DEVICES_END_ELEMENT.length());
    XmlDocument document = new XmlDocument(devicesXml);
    XmlNode metadata = new XmlDocument(xml).selectSingleNode("domain/metadata");
    Map<String, Object> result = new HashMap<>();
    result.put(VdsProperties.vm_guid, vmId.toString());
    result.put(VdsProperties.Devices, parseDevices(vmId, hostId, document));
    result.put(VdsProperties.GuestDiskMapping, parseDiskMapping(metadata));
    return result;
}
#end_block

#method_before
private List<Map<String, Object>> parseDisks(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.DISK);
    MemoizingSupplier<Map<Guid, String>> diskToLunSupplier = new MemoizingSupplier<>(() -> diskLunMapDao.getAll().stream().collect(Collectors.toMap(DiskLunMap::getDiskId, DiskLunMap::getLunId)));
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.DISK)) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.DISK.getValue());
        String diskType = parseAttribute(node, DEVICE);
        dev.put(VdsProperties.Device, diskType);
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        String path = parseDiskPath(node);
        VmDevice dbDev = dbDevices.stream().filter(d -> {
            switch(diskType) {
                case "cdrom":
                    if (!diskType.equals(d.getDevice())) {
                        return false;
                    }
                    String devicePath = (String) d.getSpecParams().get("path");
                    return devicePath == null || path.contains(devicePath);
                case "floppy":
                    return diskType.equals(d.getDevice());
                default:
                    if (d.getSnapshotId() != null && path.contains(VdsProperties.Transient)) {
                        return path.contains(diskImageDao.getAllSnapshotsForVmSnapshot(d.getSnapshotId()).get(0).getImageId().toString());
                    }
                    Guid diskId = d.getId().getDeviceId();
                    return path.contains(diskId.toString()) || isPathContainsLunIdOfDisk(path, diskId, diskToLunSupplier);
            }
        }).findFirst().orElse(null);
        if (dbDev == null) {
            log.warn("unmanaged disk with path '{}' is ignored", path);
            continue;
        }
        dbDevices.remove(dbDev);
        dev.put(VdsProperties.ImageId, parseImageIdFromPath(path));
        dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
        dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        List<Map<String, Object>> volumeChain = parseVolumeChain(node);
        if (!volumeChain.isEmpty()) {
            dev.put(VdsProperties.VolumeChain, volumeChain.toArray());
        }
        result.add(dev);
    }
    return result;
}
#method_after
private List<Map<String, Object>> parseDisks(XmlDocument document, List<VmDevice> devices) {
    List<VmDevice> dbDevices = filterDevices(devices, VmDeviceGeneralType.DISK);
    MemoizingSupplier<Map<Guid, String>> diskToLunSupplier = new MemoizingSupplier<>(() -> diskLunMapDao.getAll().stream().collect(Collectors.toMap(DiskLunMap::getDiskId, DiskLunMap::getLunId)));
    List<Map<String, Object>> result = new ArrayList<>();
    for (XmlNode node : selectNodes(document, VmDeviceGeneralType.DISK)) {
        Map<String, Object> dev = new HashMap<>();
        dev.put(VdsProperties.Type, VmDeviceGeneralType.DISK.getValue());
        String diskType = parseAttribute(node, DEVICE);
        dev.put(VdsProperties.Device, diskType);
        dev.put(VdsProperties.Address, parseAddress(node));
        dev.put(VdsProperties.Alias, parseAlias(node));
        String path = parseDiskPath(node);
        VmDevice dbDev = dbDevices.stream().filter(d -> {
            switch(diskType) {
                case "cdrom":
                    if (!diskType.equals(d.getDevice())) {
                        return false;
                    }
                    String devicePath = (String) d.getSpecParams().get("path");
                    return devicePath == null || path.contains(devicePath);
                case "floppy":
                    return diskType.equals(d.getDevice());
                default:
                    if (d.getSnapshotId() != null && path.contains(VdsProperties.Transient)) {
                        DiskImage diskImage = diskImageDao.getDiskSnapshotForVmSnapshot(d.getDeviceId(), d.getSnapshotId());
                        return diskImage != null && path.contains(diskImage.getImageId().toString());
                    }
                    Guid diskId = d.getId().getDeviceId();
                    return path.contains(diskId.toString()) || isPathContainsLunIdOfDisk(path, diskId, diskToLunSupplier);
            }
        }).findFirst().orElse(null);
        if (dbDev == null) {
            log.warn("unmanaged disk with path '{}' is ignored", path);
            continue;
        }
        dbDevices.remove(dbDev);
        dev.put(VdsProperties.ImageId, parseImageIdFromPath(path));
        dev.put(VdsProperties.DeviceId, dbDev.getId().getDeviceId().toString());
        dev.put(VdsProperties.SpecParams, dbDev.getSpecParams());
        List<Map<String, Object>> volumeChain = parseVolumeChain(node);
        if (!volumeChain.isEmpty()) {
            dev.put(VdsProperties.VolumeChain, volumeChain.toArray());
        }
        result.add(dev);
    }
    return result;
}
#end_block

#method_before
private void writeManagedDisk(VmDevice device, Disk disk, DiskVmElement dve, int index) {
    // <disk type='file' device='disk' snapshot='no'>
    // <driver name='qemu' type='qcow2' cache='none'/>
    // <source file='/path/to/image'/>
    // <target dev='hda' bus='ide'/>
    // <serial>54-a672-23e5b495a9ea</serial>
    // </disk>
    writer.writeStartElement("disk");
    writeGeneralDiskAttributes(device, disk, dve);
    String dev = writeDiskTarget(dve, index);
    writeDiskSource(disk, dev, device.getSnapshotId());
    writeDiskDriver(device, disk, dve);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    if (disk.getDiskStorageType() != DiskStorageType.LUN) {
        writer.writeElement("serial", disk.getId().toString());
    }
    if (device.getReadOnly()) {
        writer.writeElement("readonly");
    }
    if (device.getSnapshotId() == null && disk.isShareable()) {
        writer.writeElement("shareable");
    }
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        writeIoTune((DiskImage) disk);
    }
    if (disk.getDiskStorageType() == DiskStorageType.CINDER) /**
     * && case RBD
     */
    {
        writeNetworkDiskAuth((CinderDisk) disk);
    }
    writer.writeEndElement();
}
#method_after
private void writeManagedDisk(VmDevice device, Disk disk, DiskVmElement dve, int index) {
    // <disk type='file' device='disk' snapshot='no'>
    // <driver name='qemu' type='qcow2' cache='none'/>
    // <source file='/path/to/image'/>
    // <target dev='hda' bus='ide'/>
    // <serial>54-a672-23e5b495a9ea</serial>
    // </disk>
    writer.writeStartElement("disk");
    writeGeneralDiskAttributes(device, disk, dve);
    String dev = writeDiskTarget(dve, index);
    writeDiskSource(disk, dev);
    writeDiskDriver(device, disk, dve);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    if (disk.getDiskStorageType() != DiskStorageType.LUN) {
        writer.writeElement("serial", disk.getId().toString());
    }
    if (device.getReadOnly()) {
        writer.writeElement("readonly");
    }
    if (device.getSnapshotId() == null && disk.isShareable()) {
        writer.writeElement("shareable");
    }
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        writeIoTune((DiskImage) disk);
    }
    if (disk.getDiskStorageType() == DiskStorageType.CINDER) /**
     * && case RBD
     */
    {
        writeNetworkDiskAuth((CinderDisk) disk);
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskSource(Disk disk, String dev, Guid snapshotId) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", String.format("/rhev/data-center/mnt/blockSD/%s/images/%s/%s", diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                    break;
                case "file":
                    writer.writeAttributeString("file", String.format("/rhev/data-center/%s/%s/images/%s/%s", diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                    break;
                case "network":
                    writer.writeAttributeString("protocol", "gluster");
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                    writer.writeStartElement("host");
                    writer.writeAttributeString("name", volInfo[0]);
                    writer.writeAttributeString("port", "0");
                    writer.writeEndElement();
                    break;
            }
            Map<String, Object> diskParams = new HashMap<>();
            diskParams.put("poolID", diskImage.getStoragePoolId());
            diskParams.put("domainID", diskImage.getStorageIds().get(0));
            diskParams.put("imageID", diskImage.getId());
            diskParams.put("volumeID", diskImage.getImageId());
            if (snapshotId != null) {
                diskParams.put(VdsProperties.Shareable, VdsProperties.Transient);
            }
            diskMetadata.put(dev, diskParams);
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskSource(Disk disk, String dev) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    writer.writeAttributeString("protocol", "gluster");
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                    writer.writeStartElement("host");
                    writer.writeAttributeString("name", volInfo[0]);
                    writer.writeAttributeString("port", "0");
                    writer.writeEndElement();
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw' error_policy='report' />
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        String name = vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex);
        writer.writeAttributeString("dev", name);
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        payloadMetadata = new Pair<>(name, new VmPayload(device));
        writer.writeEndElement();
    });
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath()))) {
        // add a device that points to vm.getCdPath()
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", vm.getCdPath());
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#method_after
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw' error_policy='report' />
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        String name = vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex);
        writer.writeAttributeString("dev", name);
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        payloadMetadata = new Pair<>(name, new VmPayload(device));
        writer.writeEndElement();
    });
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath()))) {
        // add a device that points to vm.getCdPath()
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        boolean isoOnBlockDomain = false;
        if (vm.getIsoPath() != null && vm.getIsoPath().matches(ValidationUtils.GUID) && vmInfoBuildUtils.isBlockDomainPath(vm.getCdPath())) {
            isoOnBlockDomain = true;
            String dev = vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex);
            Matcher m = Pattern.compile(ValidationUtils.GUID).matcher(vm.getCdPath());
            m.find();
            Guid domainId = Guid.createGuidFromString(m.group());
            m.find();
            Guid imageId = Guid.createGuidFromString(m.group());
            m.find();
            Guid volumeId = Guid.createGuidFromString(m.group());
            diskMetadata.put(dev, createDiskUuidsMap(vm.getStoragePoolId(), domainId, imageId, volumeId));
        }
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", isoOnBlockDomain ? "block" : "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString(isoOnBlockDomain ? "dev" : "file", vm.getCdPath());
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    Map<String, String> properties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    VnicProfile vnicProfile = vnicProfileDao.get(nic.getVnicProfileId());
    Network network = vnicProfile != null ? networkDao.get(vnicProfile.getNetworkId()) : null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            writer.writeAttributeString("type", ifaceType == VmInterfaceType.pv ? "virtio" : ifaceType.getInternalName());
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network != null ? network.getVdsmName() : "");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(network != null ? network.getName() : "", properties);
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (network != null && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmNicFilterParameterDao.getAllForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (properties.containsKey("sndbuf")) {
        writer.writeStartElement("tune");
        writer.writeStartElement("sndbuf");
        writer.writeRaw(properties.get("sndbuf"));
        writer.writeEndElement();
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    Map<String, String> properties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    VnicProfile vnicProfile = vnicProfileDao.get(nic.getVnicProfileId());
    Network network = vnicProfile != null ? networkDao.get(vnicProfile.getNetworkId()) : null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network != null ? network.getVdsmName() : "");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(network != null ? network.getName() : "", properties);
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (network != null && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmNicFilterParameterDao.getAllForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (properties.containsKey("sndbuf")) {
        writer.writeStartElement("tune");
        writer.writeStartElement("sndbuf");
        writer.writeRaw(properties.get("sndbuf"));
        writer.writeEndElement();
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
public Collection<ExternalVnicProfileMapping> cloneExternalVnicProfiles(Cluster cluster) {
    if (externalVnicProfilesPerTargetCluster.get(cluster) == null) {
        return new ArrayList<>();
    }
    final Collection<ExternalVnicProfileMapping> result = new ArrayList<>(externalVnicProfilesPerTargetCluster.get(cluster).size());
    externalVnicProfilesPerTargetCluster.get(cluster).stream().forEach(vnicProfileMappingEntity -> result.add(vnicProfileMappingEntity.getExternalVnicProfileMapping()));
    return result;
}
#method_after
public Collection<ExternalVnicProfileMapping> cloneExternalVnicProfiles(Cluster cluster) {
    if (externalVnicProfilesPerTargetCluster.get(cluster) == null) {
        return Collections.emptyList();
    }
    return externalVnicProfilesPerTargetCluster.get(cluster).stream().map(VnicProfileMappingEntity::getExternalVnicProfileMapping).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        onSave();
    }
    if (command == getVnicProfileMappingCommand() && getWindow() == null) {
        updateExternalVnicProfilesPerTargetCluster();
        vnicProfileMappingModel = new VnicProfileMappingModel(this, externalVnicProfilesPerTargetCluster);
        vnicProfileMappingModel.initialize();
        setWindow(vnicProfileMappingModel);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        onSave();
    }
    if (VNIC_PROFILE_MAPPING_COMMAND.equals(command.getName())) {
        onVnicProfileMappingCommand();
    }
}
#end_block

#method_before
protected Map<Cluster, Set<VnicProfileMappingEntity>> updateExternalVnicProfilesPerTargetCluster(List<VmNetworkInterface> interfaces, Cluster cluster, Map<Cluster, Set<VnicProfileMappingEntity>> result) {
    final Set<VnicProfileMappingEntity> clusterVnicProfileMappings;
    if (result.containsKey(cluster)) {
        clusterVnicProfileMappings = result.get(cluster);
    } else {
        clusterVnicProfileMappings = new HashSet<>();
        result.put(cluster, clusterVnicProfileMappings);
    }
    final Set<VnicProfileMappingEntity> previousClusterVnicProfileMappings;
    if (externalVnicProfilesPerTargetCluster.containsKey(cluster)) {
        previousClusterVnicProfileMappings = externalVnicProfilesPerTargetCluster.get(cluster);
    } else {
        previousClusterVnicProfileMappings = new HashSet<>();
    }
    final Set<VnicProfileMappingEntity> vmVnicProfiles = getNewVnicProfileMappings(interfaces, previousClusterVnicProfileMappings);
    clusterVnicProfileMappings.addAll(vmVnicProfiles);
    return result;
}
#method_after
private Map<Cluster, Set<VnicProfileMappingEntity>> updateExternalVnicProfilesPerTargetCluster() {
    Map<Cluster, Set<VnicProfileMappingEntity>> updated = new HashMap<>();
    // the update may be for several VMs or VmTemplates over various clusters
    for (E importEntityData : getEntities().getItems()) {
        Cluster cluster = importEntityData.getCluster().getSelectedItem();
        // get the set of profiles being updated for the cluster or create new
        Set<VnicProfileMappingEntity> clusterVnicProfileMappings;
        if (updated.containsKey(cluster)) {
            clusterVnicProfileMappings = updated.get(cluster);
        } else {
            clusterVnicProfileMappings = new HashSet<>();
            updated.put(cluster, clusterVnicProfileMappings);
        }
        // get the previous set of profiles for the cluster or create new
        Set<VnicProfileMappingEntity> previousClusterVnicProfileMappings;
        if (externalVnicProfilesPerTargetCluster.containsKey(cluster)) {
            previousClusterVnicProfileMappings = externalVnicProfilesPerTargetCluster.get(cluster);
        } else {
            previousClusterVnicProfileMappings = new HashSet<>();
        }
        // create or set mappings according to currently existing interfaces and previous user selections
        Set<VnicProfileMappingEntity> vmVnicProfiles = getNewVnicProfileMappings(getInterfaces(importEntityData), previousClusterVnicProfileMappings);
        clusterVnicProfileMappings.addAll(vmVnicProfiles);
    }
    return updated;
}
#end_block

#method_before
private Set<VnicProfileMappingEntity> getNewVnicProfileMappings(List<VmNetworkInterface> interfaces, Set<VnicProfileMappingEntity> previousClusterVnicProfileMappings) {
    final Set<VnicProfileMappingEntity> result = new HashSet<>();
    for (VmNetworkInterface vnic : interfaces) {
        final VnicProfileMappingEntity newMapping = new VnicProfileMappingEntity(vnic.getNetworkName(), vnic.getVnicProfileName(), null);
        final VnicProfileMappingEntity mapping = previousClusterVnicProfileMappings.stream().filter(x -> x.equals(newMapping)).findFirst().orElse(newMapping);
        result.add(mapping);
    }
    return result;
}
#method_after
private Set<VnicProfileMappingEntity> getNewVnicProfileMappings(List<VmNetworkInterface> interfaces, Set<VnicProfileMappingEntity> previousClusterVnicProfileMappings) {
    Set<VnicProfileMappingEntity> result = new HashSet<>();
    for (VmNetworkInterface vnic : interfaces) {
        VnicProfileMappingEntity newMapping = new VnicProfileMappingEntity(vnic.getNetworkName(), vnic.getVnicProfileName(), null);
        VnicProfileMappingEntity mapping = previousClusterVnicProfileMappings.stream().filter(x -> x.isSameSourceProfile(newMapping)).findFirst().orElse(newMapping);
        // warning: the Set.add() uses the equals of {@link VnicProfileMappingEntity} which only compares the source profile
        result.add(mapping);
    }
    return result;
}
#end_block

#method_before
protected void addVnicProfileMappingCommand() {
    final UICommand vnicProfileMappingCommand = createVnicProfileMappingCommand();
    getCommands().add(vnicProfileMappingCommand);
}
#method_after
protected void addVnicProfileMappingCommand() {
    getCommands().add(createVnicProfileMappingCommand());
}
#end_block

#method_before
@Mapping(from = Disk.class, to = org.ovirt.engine.core.common.businessentities.storage.Disk.class)
public static org.ovirt.engine.core.common.businessentities.storage.Disk map(Disk disk, org.ovirt.engine.core.common.businessentities.storage.Disk template) {
    org.ovirt.engine.core.common.businessentities.storage.Disk engineDisk = template;
    if (engineDisk == null) {
        if (disk.isSetLunStorage()) {
            engineDisk = new LunDisk();
        } else if (disk.getStorageType() != null) {
            DiskStorageType diskStorageType = disk.getStorageType();
            switch(diskStorageType) {
                case CINDER:
                    engineDisk = new CinderDisk();
                    break;
                case IMAGE:
                    engineDisk = new DiskImage();
                    break;
            }
        }
        if (engineDisk == null) {
            engineDisk = new DiskImage();
        }
    }
    // name is depreciated, use alias instead.
    if (disk.isSetName()) {
        engineDisk.setDiskAlias(disk.getName());
    }
    if (disk.isSetAlias()) {
        engineDisk.setDiskAlias(disk.getAlias());
    }
    if (disk.isSetId()) {
        engineDisk.setId(GuidUtils.asGuid(disk.getId()));
    }
    if (disk.isSetPropagateErrors()) {
        engineDisk.setPropagateErrors(disk.isPropagateErrors() ? PropagateErrors.On : PropagateErrors.Off);
    }
    if (disk.isSetWipeAfterDelete()) {
        engineDisk.setWipeAfterDelete(disk.isWipeAfterDelete());
    }
    if (disk.isSetLogicalName()) {
        engineDisk.setLogicalName(disk.getLogicalName());
    }
    if (disk.isSetDescription()) {
        engineDisk.setDiskDescription(disk.getDescription());
    }
    if (disk.isSetShareable()) {
        engineDisk.setShareable(disk.isShareable());
    }
    if (!engineDisk.getDiskStorageType().isInternal()) {
        if (disk.isSetLunStorage()) {
            ((LunDisk) engineDisk).setLun(StorageLogicalUnitMapper.map(disk.getLunStorage(), null));
        }
        if (disk.isSetSgio()) {
            engineDisk.setSgio(map(disk.getSgio(), null));
        }
    } else {
        mapDiskToDiskImageProperties(disk, (DiskImage) engineDisk);
    }
    if (disk.isSetContentType()) {
        engineDisk.setContentType(map(disk.getContentType()));
    }
    return engineDisk;
}
#method_after
@Mapping(from = Disk.class, to = org.ovirt.engine.core.common.businessentities.storage.Disk.class)
public static org.ovirt.engine.core.common.businessentities.storage.Disk map(Disk disk, org.ovirt.engine.core.common.businessentities.storage.Disk template) {
    org.ovirt.engine.core.common.businessentities.storage.Disk engineDisk = template;
    if (engineDisk == null) {
        if (disk.isSetLunStorage()) {
            engineDisk = new LunDisk();
        } else if (disk.getStorageType() != null) {
            DiskStorageType diskStorageType = disk.getStorageType();
            switch(diskStorageType) {
                case CINDER:
                    engineDisk = new CinderDisk();
                    break;
                case IMAGE:
                    engineDisk = new DiskImage();
                    break;
            }
        }
        if (engineDisk == null) {
            engineDisk = new DiskImage();
        }
    }
    // name is depreciated, use alias instead.
    if (disk.isSetName()) {
        engineDisk.setDiskAlias(disk.getName());
    }
    if (disk.isSetAlias()) {
        engineDisk.setDiskAlias(disk.getAlias());
    }
    if (disk.isSetId()) {
        engineDisk.setId(GuidUtils.asGuid(disk.getId()));
    }
    if (disk.isSetPropagateErrors()) {
        engineDisk.setPropagateErrors(disk.isPropagateErrors() ? PropagateErrors.On : PropagateErrors.Off);
    }
    if (disk.isSetWipeAfterDelete()) {
        engineDisk.setWipeAfterDelete(disk.isWipeAfterDelete());
    }
    if (disk.isSetLogicalName()) {
        engineDisk.setLogicalName(disk.getLogicalName());
    }
    if (disk.isSetDescription()) {
        engineDisk.setDiskDescription(disk.getDescription());
    }
    if (disk.isSetShareable()) {
        engineDisk.setShareable(disk.isShareable());
    }
    if (!engineDisk.getDiskStorageType().isInternal()) {
        if (disk.isSetLunStorage()) {
            ((LunDisk) engineDisk).setLun(StorageLogicalUnitMapper.map(disk.getLunStorage(), null));
        }
        if (disk.isSetSgio()) {
            engineDisk.setSgio(map(disk.getSgio(), null));
        }
    } else {
        mapDiskToDiskImageProperties(disk, (DiskImage) engineDisk);
    }
    if (disk.isSetContentType()) {
        engineDisk.setContentType(mapDiskContentType(disk.getContentType()));
    }
    return engineDisk;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.storage.Disk.class, to = Disk.class)
public static Disk map(org.ovirt.engine.core.common.businessentities.storage.Disk entity, Disk template) {
    Disk model = template != null ? template : new Disk();
    // name is depreciated, use alias instead.
    model.setName(entity.getDiskAlias());
    model.setAlias(entity.getDiskAlias());
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    model.setPropagateErrors(PropagateErrors.On == entity.getPropagateErrors());
    model.setWipeAfterDelete(entity.isWipeAfterDelete());
    model.setShareable(entity.isShareable());
    model.setDescription(entity.getDiskDescription());
    model.setLogicalName(entity.getLogicalName());
    model.setStorageType(map(entity.getDiskStorageType()));
    if (entity.getDiskStorageType() == org.ovirt.engine.core.common.businessentities.storage.DiskStorageType.IMAGE || entity.getDiskStorageType() == org.ovirt.engine.core.common.businessentities.storage.DiskStorageType.CINDER) {
        mapDiskImageToDiskFields((DiskImage) entity, model);
    } else {
        model.setLunStorage(StorageLogicalUnitMapper.map(((LunDisk) entity).getLun(), new HostStorage()));
        if (entity.getSgio() != null) {
            model.setSgio(map(entity.getSgio(), null));
        }
    }
    model.setContentType(map(entity.getContentType()));
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.storage.Disk.class, to = Disk.class)
public static Disk map(org.ovirt.engine.core.common.businessentities.storage.Disk entity, Disk template) {
    Disk model = template != null ? template : new Disk();
    // name is depreciated, use alias instead.
    model.setName(entity.getDiskAlias());
    model.setAlias(entity.getDiskAlias());
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    model.setPropagateErrors(PropagateErrors.On == entity.getPropagateErrors());
    model.setWipeAfterDelete(entity.isWipeAfterDelete());
    model.setShareable(entity.isShareable());
    model.setDescription(entity.getDiskDescription());
    model.setLogicalName(entity.getLogicalName());
    model.setStorageType(map(entity.getDiskStorageType()));
    if (entity.getDiskStorageType() == org.ovirt.engine.core.common.businessentities.storage.DiskStorageType.IMAGE || entity.getDiskStorageType() == org.ovirt.engine.core.common.businessentities.storage.DiskStorageType.CINDER) {
        mapDiskImageToDiskFields((DiskImage) entity, model);
    } else {
        model.setLunStorage(StorageLogicalUnitMapper.map(((LunDisk) entity).getLun(), new HostStorage()));
        if (entity.getSgio() != null) {
            model.setSgio(map(entity.getSgio(), null));
        }
    }
    model.setContentType(mapDiskContentType(entity.getContentType()));
    return model;
}
#end_block

#method_before
private void init() {
    setTitle(ConstantsManager.getInstance().getConstants().editLogicalNetworkTitle());
    setHelpTag(HelpTag.edit_logical_network);
    // $NON-NLS-1$
    setHashName("edit_logical_network");
    getName().setEntity(getNetwork().getName());
    getDescription().setEntity(getNetwork().getDescription());
    getComment().setEntity(getNetwork().getComment());
    getIsStpEnabled().setEntity(getNetwork().getStp());
    getHasVLanTag().setEntity(getNetwork().getVlanId() != null);
    getVLanTag().setEntity(getNetwork().getVlanId());
    initMtu();
    initIsVm();
    getExternal().setEntity(getNetwork().isExternal());
    getExternal().setIsChangeable(false);
    getExternalProviders().setIsChangeable(false);
    getPhysicalNetwork().setEntity(isConnectedToPhysicalNetwork());
    getPhysicalNetwork().setIsChangeable(false);
    if (isConnectedToPhysicalNetwork()) {
        getPhysicalNetworkDatacenter().setEntity(getNetwork().getProvidedBy().isSetPhysicalNetworkId());
    }
    getPhysicalNetworkDatacenterRB().setIsChangeable(false);
    getPhysicalNetworkCustomRB().setIsChangeable(false);
    getDatacenterPhysicalNetwork().setIsChangeable(false);
    if (getNetwork().isExternal() && isConnectedToPhysicalNetwork()) {
        getNeutronPhysicalNetwork().setEntity(getNetwork().getLabel());
    } else {
        getNetworkLabel().setSelectedItem(getNetwork().getLabel());
    }
    toggleProfilesAvailability();
}
#method_after
private void init() {
    setTitle(ConstantsManager.getInstance().getConstants().editLogicalNetworkTitle());
    setHelpTag(HelpTag.edit_logical_network);
    // $NON-NLS-1$
    setHashName("edit_logical_network");
    getName().setEntity(getNetwork().getName());
    getDescription().setEntity(getNetwork().getDescription());
    getComment().setEntity(getNetwork().getComment());
    getIsStpEnabled().setEntity(getNetwork().getStp());
    getHasVLanTag().setEntity(getNetwork().getVlanId() != null);
    getVLanTag().setEntity(getNetwork().getVlanId());
    initMtu();
    initIsVm();
    getExternal().setEntity(getNetwork().isExternal());
    getExternal().setIsChangeable(false);
    getExternalProviders().setIsChangeable(false);
    getConnectedToPhysicalNetwork().setEntity(isConnectedToPhysicalNetwork());
    getConnectedToPhysicalNetwork().setIsChangeable(false);
    getUsePhysicalNetworkFromDatacenter().setIsChangeable(false);
    getUsePhysicalNetworkFromCustom().setIsChangeable(false);
    getDatacenterPhysicalNetwork().setIsChangeable(false);
    if (isConnectedToPhysicalNetwork()) {
        if (getNetwork().getProvidedBy().isSetPhysicalNetworkId()) {
            getUsePhysicalNetworkFromDatacenter().setEntity(true);
        } else {
            getUsePhysicalNetworkFromCustom().setEntity(true);
            getCustomPhysicalNetwork().setEntity(getNetwork().getLabel());
        }
    } else {
        getNetworkLabel().setSelectedItem(getNetwork().getLabel());
    }
    toggleProfilesAvailability();
}
#end_block

#method_before
@Override
protected void onExportChanged() {
    super.onExportChanged();
    if (getExternal().getEntity()) {
        getHasVLanTag().setIsChangeable(false);
        getVLanTag().setIsChangeable(false);
        getIsVmNetwork().setIsChangeable(false);
        getNetworkLabel().setIsChangeable(false);
        getNeutronPhysicalNetwork().setIsChangeable(false);
    }
}
#method_after
@Override
protected void onExportChanged() {
    super.onExportChanged();
    if (getExternal().getEntity()) {
        getHasVLanTag().setIsChangeable(false);
        getVLanTag().setIsChangeable(false);
        getIsVmNetwork().setIsChangeable(false);
        getNetworkLabel().setIsChangeable(false);
        getCustomPhysicalNetwork().setIsChangeable(false);
    }
}
#end_block

#method_before
private void init() {
    setTitle(ConstantsManager.getInstance().getConstants().newLogicalNetworkTitle());
    setHelpTag(HelpTag.new_logical_network);
    // $NON-NLS-1$
    setHashName("new_logical_network");
    initMtu();
}
#method_after
private void init() {
    setTitle(ConstantsManager.getInstance().getConstants().newLogicalNetworkTitle());
    setHelpTag(HelpTag.new_logical_network);
    // $NON-NLS-1$
    setHashName("new_logical_network");
    getConnectedToPhysicalNetwork().setEntity(true);
    initMtu();
}
#end_block

#method_before
@Override
protected void executeSave() {
    final AddNetworkStoragePoolParameters parameters = new AddNetworkStoragePoolParameters(getSelectedDc().getId(), getNetwork());
    parameters.setVnicProfileRequired(false);
    // New network
    if (getExternal().getEntity()) {
        Provider<?> externalProvider = getExternalProviders().getSelectedItem();
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(externalProvider.getId());
        getNetwork().setProvidedBy(providerNetwork);
        if (getPhysicalNetworkDatacenter().getEntity()) {
            providerNetwork.setPhysicalNetworkId(getDatacenterPhysicalNetwork().getSelectedItem().getId());
        }
        Frontend.getInstance().runAction(ActionType.AddNetworkOnProvider, parameters, addNetworkCallback(), null);
    } else {
        Frontend.getInstance().runAction(ActionType.AddNetwork, parameters, addNetworkCallback(), null);
    }
}
#method_after
@Override
protected void executeSave() {
    final AddNetworkWithSubnetParameters parameters = new AddNetworkWithSubnetParameters(getSelectedDc().getId(), getNetwork());
    parameters.setVnicProfileRequired(false);
    // New network
    if (getExternal().getEntity()) {
        Provider<?> externalProvider = getExternalProviders().getSelectedItem();
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(externalProvider.getId());
        getNetwork().setProvidedBy(providerNetwork);
        if (hasDefinedSubnet()) {
            getSubnetModel().flush();
            parameters.setExternalSubnet(getSubnetModel().getSubnet());
        }
        Frontend.getInstance().runAction(hasDefinedSubnet() ? ActionType.AddNetworkWithSubnetOnProvider : ActionType.AddNetworkOnProvider, parameters, addNetworkCallback(), null);
    } else {
        Frontend.getInstance().runAction(ActionType.AddNetwork, parameters, addNetworkCallback(), null);
    }
}
#end_block

#method_before
private void postSaveAction(Guid id) {
    super.postSaveAction(id, true);
    attachNetworkToClusters(id);
    if (hasDefinedSubnet()) {
        addNetworkSubnetToProvider();
    }
}
#method_after
private void postSaveAction(Guid id) {
    super.postSaveAction(id, true);
    attachNetworkToClusters(id);
}
#end_block

#method_before
@Override
public void updateVisibility() {
    messageLabel.setVisible(false);
    externalLabel.setVisible(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    onPhysicalNetworkChange();
}
#method_after
@Override
public void updateVisibility() {
    messageLabel.setVisible(false);
    externalLabel.setVisible(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    physicalNetworkLabel.setVisible(false);
}
#end_block

#method_before
private void updateAvailability() {
    if (!ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly)) {
        getExternalProviders().setIsAvailable(false);
        getNeutronPhysicalNetwork().setIsAvailable(false);
        getCreateSubnet().setIsAvailable(false);
        getVLanTag().setIsAvailable(false);
        getHasVLanTag().setIsAvailable(false);
        getExternal().setIsAvailable(false);
    }
}
#method_after
private void updateAvailability() {
    if (!ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly)) {
        getExternalProviders().setIsAvailable(false);
        getCustomPhysicalNetwork().setIsAvailable(false);
        getCreateSubnet().setIsAvailable(false);
        getVLanTag().setIsAvailable(false);
        getHasVLanTag().setIsAvailable(false);
        getExternal().setIsAvailable(false);
    }
}
#end_block

#method_before
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName(getName().getEntity());
    network.setStp(getIsStpEnabled().getEntity());
    network.setDescription(getDescription().getEntity());
    network.setComment(getComment().getEntity());
    network.setVmNetwork(getIsVmNetwork().getEntity());
    String label = getNetworkLabel().getSelectedItem();
    if (getExternal().getEntity() && getPhysicalNetwork().getEntity()) {
        label = !getPhysicalNetworkDatacenter().getEntity() ? getNeutronPhysicalNetwork().getEntity() : null;
    }
    network.setLabel(label == null || !label.isEmpty() ? label : null);
    network.setMtu(0);
    if (getMtu().getIsChangable()) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setDnsResolverConfiguration(getDnsConfigurationModel().flush());
    network.setVlanId(null);
    if (getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
    for (VnicProfileModel profileModel : getProfiles().getItems()) {
        profileModel.flush();
    }
    if (getQos().getIsChangable()) {
        HostNetworkQos qos = getQos().getSelectedItem();
        network.setQosId(qos == EMPTY_HOST_NETWORK_QOS ? null : qos.getId());
    }
}
#method_after
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName(getName().getEntity());
    network.setStp(getIsStpEnabled().getEntity());
    network.setDescription(getDescription().getEntity());
    network.setComment(getComment().getEntity());
    network.setVmNetwork(getIsVmNetwork().getEntity());
    String label = getNetworkLabel().getSelectedItem();
    if (getExternal().getEntity() && getConnectedToPhysicalNetwork().getEntity()) {
        label = !getUsePhysicalNetworkFromDatacenter().getEntity() ? getCustomPhysicalNetwork().getEntity() : null;
    }
    network.setLabel(StringHelper.isNotNullOrEmpty(label) ? label : null);
    network.setMtu(0);
    if (getMtu().getIsChangable()) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setDnsResolverConfiguration(getDnsConfigurationModel().flush());
    network.setVlanId(null);
    if (getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
    for (VnicProfileModel profileModel : getProfiles().getItems()) {
        profileModel.flush();
    }
    if (getQos().getIsChangable()) {
        HostNetworkQos qos = getQos().getSelectedItem();
        network.setQosId(qos == EMPTY_HOST_NETWORK_QOS ? null : qos.getId());
    }
}
#end_block

#method_before
protected void onExportChanged() {
    boolean externalNetwork = getExternal().getEntity();
    getNetworkLabel().setIsChangeable(!externalNetwork);
    getNeutronPhysicalNetwork().setIsChangeable(externalNetwork && !getPhysicalNetworkDatacenter().getEntity());
    getDatacenterPhysicalNetwork().setIsChangeable(externalNetwork && getPhysicalNetworkDatacenter().getEntity());
    getQos().setIsChangeable(!externalNetwork);
    getAddQosCommand().setIsExecutionAllowed(!externalNetwork);
    getPhysicalNetwork().setIsChangeable(externalNetwork);
    getPhysicalNetworkCustomRB().setIsChangeable(externalNetwork);
    getPhysicalNetworkDatacenterRB().setIsChangeable(externalNetwork);
    updateMtuSelectorsChangeability();
}
#method_after
protected void onExportChanged() {
    boolean externalNetwork = getExternal().getEntity();
    getNetworkLabel().setIsChangeable(!externalNetwork);
    getCustomPhysicalNetwork().setIsChangeable(externalNetwork && !getUsePhysicalNetworkFromDatacenter().getEntity());
    getDatacenterPhysicalNetwork().setIsChangeable(externalNetwork && getUsePhysicalNetworkFromDatacenter().getEntity());
    getQos().setIsChangeable(!externalNetwork);
    getAddQosCommand().setIsExecutionAllowed(!externalNetwork);
    getConnectedToPhysicalNetwork().setIsChangeable(externalNetwork);
    getUsePhysicalNetworkFromCustom().setIsChangeable(externalNetwork);
    getUsePhysicalNetworkFromDatacenter().setIsChangeable(externalNetwork);
    updateMtuSelectorsChangeability();
}
#end_block

#method_before
protected void updateOvfStoreContent() {
    if (domainOvfStoresInfoForUpdate.isEmpty()) {
        return;
    }
    updateDate = new Date();
    List<Guid> vmAndTemplatesIds = storageDomainDao.getVmAndTemplatesIdsByStorageDomainId(getParameters().getStorageDomainId(), false, false);
    vmAndTemplatesIds.addAll(vmStaticDao.getVmAndTemplatesIdsWithoutAttachedImageDisks(getParameters().getStoragePoolId(), false));
    byte[] bytes = buildOvfInfoFileByteArray(vmAndTemplatesIds);
    Pair<StorageDomainOvfInfo, DiskImage> lastOvfStoreForUpdate = domainOvfStoresInfoForUpdate.getLast();
    // possibly have some ovf data on storage)
    if (lastOvfStoreForUpdate.getFirst().getLastUpdated() != null) {
        domainOvfStoresInfoForUpdate.removeLast();
    } else {
        lastOvfStoreForUpdate = null;
    }
    boolean shouldUpdateLastOvfStore = false;
    failedOvfDisks = new ArrayList<>();
    for (Pair<StorageDomainOvfInfo, DiskImage> pair : domainOvfStoresInfoForUpdate) {
        shouldUpdateLastOvfStore |= performOvfUpdateForDomain(bytes, pair.getFirst(), pair.getSecond(), vmAndTemplatesIds);
    }
    // backup (if we did)
    if (shouldUpdateLastOvfStore && lastOvfStoreForUpdate != null) {
        performOvfUpdateForDomain(bytes, lastOvfStoreForUpdate.getFirst(), lastOvfStoreForUpdate.getSecond(), vmAndTemplatesIds);
    }
    if (!failedOvfDisks.isEmpty()) {
        addCustomValue("DataCenterName", getStoragePool().getName());
        addCustomValue("StorageDomainName", getStorageDomain().getName());
        addCustomValue("DisksIds", StringUtils.join(failedOvfDisks, ", "));
        auditLogDirector.log(this, AuditLogType.UPDATE_FOR_OVF_STORES_FAILED);
    }
}
#method_after
protected boolean updateOvfStoreContent() {
    if (domainOvfStoresInfoForUpdate.isEmpty()) {
        return true;
    }
    updateDate = new Date();
    List<Guid> vmAndTemplatesIds = storageDomainDao.getVmAndTemplatesIdsByStorageDomainId(getParameters().getStorageDomainId(), false, false);
    vmAndTemplatesIds.addAll(vmStaticDao.getVmAndTemplatesIdsWithoutAttachedImageDisks(getParameters().getStoragePoolId(), false));
    byte[] bytes = buildOvfInfoFileByteArray(vmAndTemplatesIds);
    Pair<StorageDomainOvfInfo, DiskImage> lastOvfStoreForUpdate = domainOvfStoresInfoForUpdate.getLast();
    // possibly have some ovf data on storage)
    if (lastOvfStoreForUpdate.getFirst().getLastUpdated() != null) {
        domainOvfStoresInfoForUpdate.removeLast();
    } else {
        lastOvfStoreForUpdate = null;
    }
    boolean shouldUpdateLastOvfStore = false;
    failedOvfDisks = new ArrayList<>();
    for (Pair<StorageDomainOvfInfo, DiskImage> pair : domainOvfStoresInfoForUpdate) {
        shouldUpdateLastOvfStore |= performOvfUpdateForDomain(bytes, pair.getFirst(), pair.getSecond(), vmAndTemplatesIds);
    }
    // backup (if we did)
    if (shouldUpdateLastOvfStore && lastOvfStoreForUpdate != null) {
        performOvfUpdateForDomain(bytes, lastOvfStoreForUpdate.getFirst(), lastOvfStoreForUpdate.getSecond(), vmAndTemplatesIds);
    }
    if (!failedOvfDisks.isEmpty()) {
        addCustomValue("DataCenterName", getStoragePool().getName());
        addCustomValue("StorageDomainName", getStorageDomain().getName());
        addCustomValue("DisksIds", StringUtils.join(failedOvfDisks, ", "));
        auditLogDirector.log(this, AuditLogType.UPDATE_FOR_OVF_STORES_FAILED);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getOvfUpdateStep() == OvfUpdateStep.OVF_STORES_CREATION) {
        setOvfUpdateStep(OvfUpdateStep.OVF_UPLOAD);
        updateOvfStoreContent();
        return true;
    }
    return false;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getOvfUpdateStep() == OvfUpdateStep.OVF_STORES_CREATION) {
        setOvfUpdateStep(OvfUpdateStep.OVF_UPLOAD);
        if (!updateOvfStoreContent()) {
            setSucceeded(false);
            log.error("Failed to update OVF_STORE content");
            throw new RuntimeException();
        }
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    int missingDiskCount = getMissingDiskCount();
    if (missingDiskCount <= 0) {
        setOvfUpdateStep(OvfUpdateStep.OVF_UPLOAD);
        updateOvfStoreContent();
        setSucceeded(failedOvfDisks.isEmpty());
    } else {
        setOvfUpdateStep(OvfUpdateStep.OVF_STORES_CREATION);
        setSucceeded(createOvfStoreDisks(getMissingDiskCount()));
    }
}
#method_after
@Override
protected void executeCommand() {
    int missingDiskCount = getMissingDiskCount();
    if (missingDiskCount <= 0) {
        setOvfUpdateStep(OvfUpdateStep.OVF_UPLOAD);
        setSucceeded(updateOvfStoreContent());
    } else {
        setOvfUpdateStep(OvfUpdateStep.OVF_STORES_CREATION);
        setSucceeded(createOvfStoreDisks(getMissingDiskCount()));
    }
}
#end_block

#method_before
private boolean validateConnectionSettings() {
    getUsername().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(200) });
    if (getType().getSelectedItem().isTenantRequired()) {
        getTenantName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    }
    getAuthUrl().validateEntity(new IValidation[] { new NotEmptyValidation(), new UrlValidation(Uri.SCHEME_HTTP, Uri.SCHEME_HTTPS) });
    getUrl().validateEntity(new IValidation[] { new NotEmptyValidation(), new UrlValidation(Uri.SCHEME_HTTP, Uri.SCHEME_HTTPS) });
    return getUrl().getIsValid() && getUsername().getIsValid() && getPassword().getIsValid() && getTenantName().getIsValid() && getAuthUrl().getIsValid();
}
#method_after
private boolean validateConnectionSettings() {
    getUsername().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(200) });
    if (getType().getSelectedItem().isTenantRequired()) {
        getTenantName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    }
    getAuthUrl().validateEntity(new IValidation[] { new NotEmptyValidation(), new UrlValidation(Uri.SCHEME_HTTP, Uri.SCHEME_HTTPS) });
    getUrl().validateEntity(new IValidation[] { new NotEmptyValidation(), new UrlValidation(Uri.SCHEME_HTTP, Uri.SCHEME_HTTPS) });
    return (getUrl().getEntity() == null || getUrl().getIsValid() || getUrl().getEntity().isEmpty()) && getUsername().getIsValid() && getPassword().getIsValid() && getTenantName().getIsValid() && getAuthUrl().getIsValid();
}
#end_block

#method_before
private void flush() {
    provider.setName(name.getEntity());
    provider.setType(type.getSelectedItem());
    provider.setDescription(description.getEntity());
    provider.setUrl(url.getEntity());
    if (isTypeNetwork()) {
        getNeutronAgentModel().flush(provider);
        OpenstackNetworkProviderProperties properties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
        properties.setReadOnly(readOnly.getEntity());
    } else if (isTypeOpenStackImage()) {
        provider.setAdditionalProperties(new OpenStackImageProviderProperties());
    } else if (isTypeOpenStackVolume()) {
        provider.setAdditionalProperties(new OpenStackVolumeProviderProperties(getDataCenter().getSelectedItem().getId()));
    } else if (isTypeVmware()) {
        provider.setAdditionalProperties(getVmwarePropertiesModel().getVmwareVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
        provider.setUrl(getVmwarePropertiesModel().getUrl());
    } else if (isTypeKVM()) {
        provider.setUrl(getKvmPropertiesModel().getUrl().getEntity());
        provider.setAdditionalProperties(getKvmPropertiesModel().getKVMVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
    } else if (isTypeXEN()) {
        provider.setUrl(getXenPropertiesModel().getUrl().getEntity());
        provider.setAdditionalProperties(getXenPropertiesModel().getXENVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
    }
    boolean authenticationRequired = requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername(getUsername().getEntity());
        provider.setPassword(getPassword().getEntity());
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties == null) {
                properties = new TenantProviderProperties();
                provider.setAdditionalProperties(properties);
            }
            properties.setTenantName(getTenantName().getEntity());
        }
        provider.setAuthUrl(getAuthUrl().getEntity());
    } else {
        provider.setUsername(null);
        provider.setPassword(null);
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties != null) {
                properties.setTenantName(null);
            }
        }
        provider.setAuthUrl(null);
    }
}
#method_after
private void flush() {
    provider.setName(name.getEntity());
    provider.setType(type.getSelectedItem());
    provider.setDescription(description.getEntity());
    provider.setUrl(url.getEntity());
    provider.setIsUnmanaged(isUnmanaged.getEntity());
    if (isTypeNetwork()) {
        getNeutronAgentModel().flush(provider);
        OpenstackNetworkProviderProperties properties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
        properties.setReadOnly(readOnly.getEntity());
    } else if (isTypeOpenStackImage()) {
        provider.setAdditionalProperties(new OpenStackImageProviderProperties());
    } else if (isTypeOpenStackVolume()) {
        provider.setAdditionalProperties(new OpenStackVolumeProviderProperties(getDataCenter().getSelectedItem().getId()));
    } else if (isTypeVmware()) {
        provider.setAdditionalProperties(getVmwarePropertiesModel().getVmwareVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
        provider.setUrl(getVmwarePropertiesModel().getUrl());
    } else if (isTypeKVM()) {
        provider.setUrl(getKvmPropertiesModel().getUrl().getEntity());
        provider.setAdditionalProperties(getKvmPropertiesModel().getKVMVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
    } else if (isTypeXEN()) {
        provider.setUrl(getXenPropertiesModel().getUrl().getEntity());
        provider.setAdditionalProperties(getXenPropertiesModel().getXENVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
    }
    boolean authenticationRequired = requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername(getUsername().getEntity());
        provider.setPassword(getPassword().getEntity());
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties == null) {
                properties = new TenantProviderProperties();
                provider.setAdditionalProperties(properties);
            }
            properties.setTenantName(getTenantName().getEntity());
        }
        provider.setAuthUrl(getAuthUrl().getEntity());
    } else {
        provider.setUsername(null);
        provider.setPassword(null);
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties != null) {
                properties.setTenantName(null);
            }
        }
        provider.setAuthUrl(null);
    }
}
#end_block

#method_before
private void onTest() {
    if (!validateConnectionSettings()) {
        getTestResult().setEntity(ConstantsManager.getInstance().getConstants().testFailedInsufficientParams());
        return;
    }
    flush();
    startProgress();
    if (provider.getUrl().startsWith(Uri.SCHEME_HTTPS)) {
        AsyncDataProvider.getInstance().getProviderCertificateChain(new AsyncQuery<>(certs -> {
            boolean ok = false;
            certificate = null;
            if (certs != null) {
                if (!certs.isEmpty()) {
                    certificate = certs.get(certs.size() - 1).getPayload();
                    ConfirmationModel confirmationModel = getImportCertificateConfirmationModel(certs.get(certs.size() - 1));
                    sourceListModel.setConfirmWindow(confirmationModel);
                    ok = true;
                }
            }
            if (!ok) {
                stopProgress();
                getTestResult().setEntity(ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg());
            }
        }), provider);
    } else {
        testProviderConnectivity();
    }
}
#method_after
private void onTest() {
    if (isUnmanaged.getEntity()) {
        return;
    }
    if (!validateConnectionSettings()) {
        getTestResult().setEntity(ConstantsManager.getInstance().getConstants().testFailedInsufficientParams());
        return;
    }
    flush();
    startProgress();
    if (provider.getUrl().startsWith(Uri.SCHEME_HTTPS)) {
        AsyncDataProvider.getInstance().getProviderCertificateChain(new AsyncQuery<>(certs -> {
            boolean ok = false;
            certificate = null;
            if (certs != null) {
                if (!certs.isEmpty()) {
                    certificate = certs.get(certs.size() - 1).getPayload();
                    ConfirmationModel confirmationModel = getImportCertificateConfirmationModel(certs.get(certs.size() - 1));
                    sourceListModel.setConfirmWindow(confirmationModel);
                    ok = true;
                }
            }
            if (!ok) {
                stopProgress();
                getTestResult().setEntity(ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg());
            }
        }), provider);
    } else {
        testProviderConnectivity();
    }
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    typeEditor.setTabIndex(nextTabIndex++);
    datacenterEditor.setTabIndex(nextTabIndex++);
    pluginTypeEditor.setTabIndex(nextTabIndex++);
    urlEditor.setTabIndex(nextTabIndex++);
    readOnlyEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vmwarePropertiesWidget.setTabIndexes(nextTabIndex);
    kvmPropertiesWidget.setTabIndexes(nextTabIndex++);
    xenPropertiesWidget.setTabIndexes(nextTabIndex++);
    requiresAuthenticationEditor.setTabIndex(nextTabIndex++);
    usernameEditor.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    tenantNameEditor.setTabIndex(nextTabIndex++);
    authUrlEditor.setTabIndex(nextTabIndex++);
    testButton.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    typeEditor.setTabIndex(nextTabIndex++);
    datacenterEditor.setTabIndex(nextTabIndex++);
    pluginTypeEditor.setTabIndex(nextTabIndex++);
    isUnmanagedEditor.setTabIndex(nextTabIndex++);
    urlEditor.setTabIndex(nextTabIndex++);
    readOnlyEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vmwarePropertiesWidget.setTabIndexes(nextTabIndex);
    kvmPropertiesWidget.setTabIndexes(nextTabIndex++);
    xenPropertiesWidget.setTabIndexes(nextTabIndex++);
    requiresAuthenticationEditor.setTabIndex(nextTabIndex++);
    usernameEditor.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    tenantNameEditor.setTabIndex(nextTabIndex++);
    authUrlEditor.setTabIndex(nextTabIndex++);
    testButton.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(requiringAuthentication, description, id, name, password, type, url, username, customProperties, additionalProperties, authUrl);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(requiringAuthentication, description, id, name, password, type, url, username, customProperties, additionalProperties, authUrl, isUnmanaged);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Provider)) {
        return false;
    }
    Provider<?> other = (Provider<?>) obj;
    return requiringAuthentication == other.requiringAuthentication && Objects.equals(description, other.description) && Objects.equals(id, other.id) && Objects.equals(name, other.name) && Objects.equals(password, other.password) && Objects.equals(type, other.type) && Objects.equals(url, other.url) && Objects.equals(username, other.username) && Objects.equals(customProperties, other.customProperties) && Objects.equals(additionalProperties, other.additionalProperties) && Objects.equals(authUrl, other.authUrl);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Provider)) {
        return false;
    }
    Provider<?> other = (Provider<?>) obj;
    return requiringAuthentication == other.requiringAuthentication && Objects.equals(description, other.description) && Objects.equals(id, other.id) && Objects.equals(name, other.name) && Objects.equals(password, other.password) && Objects.equals(type, other.type) && Objects.equals(url, other.url) && Objects.equals(username, other.username) && Objects.equals(customProperties, other.customProperties) && Objects.equals(additionalProperties, other.additionalProperties) && Objects.equals(authUrl, other.authUrl) && Objects.equals(isUnmanaged, other.isUnmanaged);
}
#end_block

#method_before
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", getId()).append("name", getName()).append("description", getDescription()).append("url", getUrl()).append("type", getType()).append("requiringAuthentication", isRequiringAuthentication()).append("username", getUsername()).appendFiltered("password", getPassword()).append("customProperties", getCustomProperties()).append("additionalProperties", getAdditionalProperties()).append("authUrl", getAuthUrl()).build();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", getId()).append("name", getName()).append("description", getDescription()).append("url", getUrl()).append("type", getType()).append("requiringAuthentication", isRequiringAuthentication()).append("username", getUsername()).appendFiltered("password", getPassword()).append("customProperties", getCustomProperties()).append("additionalProperties", getAdditionalProperties()).append("authUrl", getAuthUrl()).append("isUnmanaged", getIsUnmanaged()).build();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public <P extends ProviderProxy<?>> P create(Provider<?> provider) {
    if (provider.isDummyProvider()) {
        return (P) new DummyNetworkProviderProxy(provider);
    }
    switch(provider.getType()) {
        case EXTERNAL_NETWORK:
            return (P) new ExternalNetworkProviderProxy((Provider<OpenstackNetworkProviderProperties>) provider);
        case FOREMAN:
            return (P) new ForemanHostProviderProxy(provider);
        case OPENSTACK_NETWORK:
            return (P) new OpenstackNetworkProviderProxy((Provider<OpenstackNetworkProviderProperties>) provider);
        case OPENSTACK_IMAGE:
            return (P) new OpenStackImageProviderProxy((Provider<OpenStackImageProviderProperties>) provider);
        case OPENSTACK_VOLUME:
            return (P) new OpenStackVolumeProviderProxy((Provider<OpenStackVolumeProviderProperties>) provider);
        case VMWARE:
            return (P) Injector.injectMembers(new VmwareVmProviderProxy((Provider<VmwareVmProviderProperties>) provider));
        case KVM:
            return (P) Injector.injectMembers(new KVMVmProviderProxy((Provider<KVMVmProviderProperties>) provider));
        case XEN:
            return (P) Injector.injectMembers(new XENVmProviderProxy((Provider<XENVmProviderProperties>) provider));
        default:
            return null;
    }
}
#method_after
@SuppressWarnings("unchecked")
public <P extends ProviderProxy<?>> P create(Provider<?> provider) {
    switch(provider.getType()) {
        case EXTERNAL_NETWORK:
            if (provider.getIsUnmanaged()) {
                return (P) new UnmanagedNetworkProviderProxy((Provider<OpenstackNetworkProviderProperties>) provider);
            }
            return (P) new ExternalNetworkProviderProxy((Provider<OpenstackNetworkProviderProperties>) provider);
        case FOREMAN:
            return (P) new ForemanHostProviderProxy(provider);
        case OPENSTACK_NETWORK:
            return (P) new OpenstackNetworkProviderProxy((Provider<OpenstackNetworkProviderProperties>) provider);
        case OPENSTACK_IMAGE:
            return (P) new OpenStackImageProviderProxy((Provider<OpenStackImageProviderProperties>) provider);
        case OPENSTACK_VOLUME:
            return (P) new OpenStackVolumeProviderProxy((Provider<OpenStackVolumeProviderProperties>) provider);
        case VMWARE:
            return (P) Injector.injectMembers(new VmwareVmProviderProxy((Provider<VmwareVmProviderProperties>) provider));
        case KVM:
            return (P) Injector.injectMembers(new KVMVmProviderProxy((Provider<KVMVmProviderProperties>) provider));
        case XEN:
            return (P) Injector.injectMembers(new XENVmProviderProxy((Provider<XENVmProviderProperties>) provider));
        default:
            return null;
    }
}
#end_block

#method_before
private void flush() {
    provider.setName(name.getEntity());
    provider.setType(type.getSelectedItem());
    provider.setDescription(description.getEntity());
    provider.setUrl(url.getEntity());
    if (isTypeNetwork()) {
        getNeutronAgentModel().flush(provider);
        OpenstackNetworkProviderProperties properties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
        properties.setReadOnly(readOnly.getEntity());
    } else if (isTypeOpenStackImage()) {
        provider.setAdditionalProperties(new OpenStackImageProviderProperties());
    } else if (isTypeOpenStackVolume()) {
        provider.setAdditionalProperties(new OpenStackVolumeProviderProperties(getDataCenter().getSelectedItem().getId()));
    } else if (isTypeVmware()) {
        provider.setAdditionalProperties(getVmwarePropertiesModel().getVmwareVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
        provider.setUrl(getVmwarePropertiesModel().getUrl());
    } else if (isTypeKVM()) {
        provider.setUrl(getKvmPropertiesModel().getUrl().getEntity());
        provider.setAdditionalProperties(getKvmPropertiesModel().getKVMVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
    } else if (isTypeXEN()) {
        provider.setUrl(getXenPropertiesModel().getUrl().getEntity());
        provider.setAdditionalProperties(getXenPropertiesModel().getXENVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
    }
    boolean authenticationRequired = requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername(getUsername().getEntity());
        provider.setPassword(getPassword().getEntity());
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties == null) {
                properties = new TenantProviderProperties();
                provider.setAdditionalProperties(properties);
            }
            properties.setTenantName(getTenantName().getEntity());
        }
        provider.setAuthUrl(getAuthUrl().getEntity());
    } else {
        provider.setUsername(null);
        provider.setPassword(null);
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties != null) {
                properties.setTenantName(null);
            }
        }
        provider.setAuthUrl(null);
    }
}
#method_after
private void flush() {
    provider.setName(name.getEntity());
    provider.setType(type.getSelectedItem());
    provider.setDescription(description.getEntity());
    provider.setUrl(url.getEntity());
    provider.setIsUnmanaged(isUnmanaged.getEntity());
    if (isTypeNetwork()) {
        getNeutronAgentModel().flush(provider);
        OpenstackNetworkProviderProperties properties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
        properties.setReadOnly(readOnly.getEntity());
    } else if (isTypeOpenStackImage()) {
        provider.setAdditionalProperties(new OpenStackImageProviderProperties());
    } else if (isTypeOpenStackVolume()) {
        provider.setAdditionalProperties(new OpenStackVolumeProviderProperties(getDataCenter().getSelectedItem().getId()));
    } else if (isTypeVmware()) {
        provider.setAdditionalProperties(getVmwarePropertiesModel().getVmwareVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
        provider.setUrl(getVmwarePropertiesModel().getUrl());
    } else if (isTypeKVM()) {
        provider.setUrl(getKvmPropertiesModel().getUrl().getEntity());
        provider.setAdditionalProperties(getKvmPropertiesModel().getKVMVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
    } else if (isTypeXEN()) {
        provider.setUrl(getXenPropertiesModel().getUrl().getEntity());
        provider.setAdditionalProperties(getXenPropertiesModel().getXENVmProviderProperties(dataCenter.getSelectedItem() != null ? dataCenter.getSelectedItem().getId() : null));
    }
    boolean authenticationRequired = requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername(getUsername().getEntity());
        provider.setPassword(getPassword().getEntity());
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties == null) {
                properties = new TenantProviderProperties();
                provider.setAdditionalProperties(properties);
            }
            properties.setTenantName(getTenantName().getEntity());
        }
        provider.setAuthUrl(getAuthUrl().getEntity());
    } else {
        provider.setUsername(null);
        provider.setPassword(null);
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties != null) {
                properties.setTenantName(null);
            }
        }
        provider.setAuthUrl(null);
    }
}
#end_block

#method_before
private void onTest() {
    if (!validateConnectionSettings()) {
        getTestResult().setEntity(ConstantsManager.getInstance().getConstants().testFailedInsufficientParams());
        return;
    }
    flush();
    startProgress();
    if (provider.getUrl().startsWith(Uri.SCHEME_HTTPS)) {
        AsyncDataProvider.getInstance().getProviderCertificateChain(new AsyncQuery<>(certs -> {
            boolean ok = false;
            certificate = null;
            if (certs != null) {
                if (!certs.isEmpty()) {
                    certificate = certs.get(certs.size() - 1).getPayload();
                    ConfirmationModel confirmationModel = getImportCertificateConfirmationModel(certs.get(certs.size() - 1));
                    sourceListModel.setConfirmWindow(confirmationModel);
                    ok = true;
                }
            }
            if (!ok) {
                stopProgress();
                getTestResult().setEntity(ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg());
            }
        }), provider);
    } else {
        testProviderConnectivity();
    }
}
#method_after
private void onTest() {
    if (isUnmanaged.getEntity()) {
        return;
    }
    if (!validateConnectionSettings()) {
        getTestResult().setEntity(ConstantsManager.getInstance().getConstants().testFailedInsufficientParams());
        return;
    }
    flush();
    startProgress();
    if (provider.getUrl().startsWith(Uri.SCHEME_HTTPS)) {
        AsyncDataProvider.getInstance().getProviderCertificateChain(new AsyncQuery<>(certs -> {
            boolean ok = false;
            certificate = null;
            if (certs != null) {
                if (!certs.isEmpty()) {
                    certificate = certs.get(certs.size() - 1).getPayload();
                    ConfirmationModel confirmationModel = getImportCertificateConfirmationModel(certs.get(certs.size() - 1));
                    sourceListModel.setConfirmWindow(confirmationModel);
                    ok = true;
                }
            }
            if (!ok) {
                stopProgress();
                getTestResult().setEntity(ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg());
            }
        }), provider);
    } else {
        testProviderConnectivity();
    }
}
#end_block

#method_before
@Ignore
@Test
public void testSaveDetails() {
    GlusterGeoRepSessionDetails sessionDetails = getGlusterGeoRepSessionDetails();
    dao.saveDetails(sessionDetails);
    List<GlusterGeoRepSessionDetails> fetchedSessionDetails = dao.getGeoRepSessionDetails(FixturesTool.GLUSTER_GEOREP_SESSION_ID);
    assertEquals(sessionDetails, fetchedSessionDetails.get(0));
}
#method_after
@Test
public void testSaveDetails() {
    GlusterGeoRepSessionDetails sessionDetails = getGlusterGeoRepSessionDetails();
    dao.saveDetails(sessionDetails);
    List<GlusterGeoRepSessionDetails> fetchedSessionDetails = dao.getGeoRepSessionDetails(FixturesTool.GLUSTER_GEOREP_SESSION_ID);
    assertEquals(sessionDetails, fetchedSessionDetails.get(0));
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshLightWeightData")
public void refreshLightWeightData() {
    log.debug("Refreshing Gluster Data [lightweight]");
    List<Cluster> clusters = getClusterDao().getAll();
    for (Cluster cluster : clusters) {
        if (cluster.supportsGlusterService()) {
            try {
                refreshClusterData(cluster);
            } catch (Exception e) {
                log.error("Error while refreshing Gluster lightweight data of cluster '{}': {}", cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("refreshLightWeightData")
public void refreshLightWeightData() {
    log.debug("Refreshing Gluster Data [lightweight]");
    List<Cluster> clusters = clusterDao.getAll();
    for (Cluster cluster : clusters) {
        if (cluster.supportsGlusterService()) {
            try {
                refreshClusterData(cluster);
            } catch (Exception e) {
                log.error("Error while refreshing Gluster lightweight data of cluster '{}': {}", cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#end_block

#method_before
private void refreshClusterData(Cluster cluster) {
    log.debug("Refreshing Gluster lightweight Data for cluster '{}'", cluster.getName());
    List<VDS> existingServers = getVdsDao().getAllForCluster(cluster.getId());
    VDS upServer = getGlusterUtil().getUpServer(cluster.getId());
    if (upServer == null) {
        log.debug("No server UP in cluster '{}'. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    refreshServerData(cluster, upServer, existingServers);
    refreshVolumeData(cluster, upServer, existingServers);
}
#method_after
private void refreshClusterData(Cluster cluster) {
    log.debug("Refreshing Gluster lightweight Data for cluster '{}'", cluster.getName());
    List<VDS> existingServers = vdsDao.getAllForCluster(cluster.getId());
    VDS upServer = glusterUtil.getUpServer(cluster.getId());
    if (upServer == null) {
        log.debug("No server UP in cluster '{}'. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    refreshServerData(cluster, upServer, existingServers);
    refreshVolumeData(cluster, upServer, existingServers);
}
#end_block

#method_before
private void syncServers(Cluster cluster, List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) {
    log.debug("Existing servers list returned '{}' comparing with fetched servers '{}'", existingServers, fetchedServers);
    boolean serverRemoved = false;
    Network glusterNetwork = findGlusterNetwork(cluster.getId());
    for (VDS server : existingServers) {
        GlusterServerInfo glusterServer = findGlusterServer(server, fetchedServers);
        if (isSyncableStatus(server.getStatus())) {
            if (glusterServer == null) {
                if (cluster.supportsVirtService()) {
                    // If the cluster supports virt service as well, we should not be removing any servers from it, even
                    // if they have been removed from the Gluster cluster using the Gluster cli, as they could
                    // potentially be
                    // used for running VMs. Will mark this server status as DISCONNECTED instead
                    log.debug("As cluster '{}' supports virt service as well, server '{}' detected as removed from glusterfs will not be removed from engine", cluster.getName(), server.getHostName());
                    setNonOperational(server);
                    continue;
                }
                log.info("Server '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", server.getName());
                logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
                try (EngineLock lock = getGlusterUtil().acquireGlusterLockWait(server.getId())) {
                    removeServerFromDb(server);
                    // if last but one server, reset alternate probed address for last server
                    checkAndResetKnownAddress(existingServers, server);
                    // remove the server from resource manager
                    runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
                    serverRemoved = true;
                } catch (Exception e) {
                    log.error("Error while removing server '{}' from database: {}", server.getName(), e.getMessage());
                    log.debug("Exception", e);
                }
            } else if (server.getStatus() == VDSStatus.Up && glusterServer.getStatus() == PeerStatus.DISCONNECTED) {
                // check gluster is running, if down then move the host to Non-Operational
                VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(server.getId()));
                if (!returnValue.getSucceeded()) {
                    setNonOperational(server);
                }
            } else {
                // update correct status and check if all interfaces with gluster network have been peer probed.
                updateStatusAndpeerProbeOtherIface(glusterNetwork, server, glusterServer);
            }
        }
    }
    if (serverRemoved) {
        log.info("Servers detached using gluster CLI is removed from engine after inspecting the Gluster servers" + " list returned '{}' - comparing with db servers '{}'", fetchedServers, existingServers);
    }
}
#method_after
private void syncServers(Cluster cluster, List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) {
    log.debug("Existing servers list returned '{}' comparing with fetched servers '{}'", existingServers, fetchedServers);
    boolean serverRemoved = false;
    Network glusterNetwork = findGlusterNetwork(cluster.getId());
    for (VDS server : existingServers) {
        GlusterServerInfo glusterServer = findGlusterServer(server, fetchedServers);
        if (isSyncableStatus(server.getStatus())) {
            if (glusterServer == null) {
                if (cluster.supportsVirtService()) {
                    // If the cluster supports virt service as well, we should not be removing any servers from it, even
                    // if they have been removed from the Gluster cluster using the Gluster cli, as they could
                    // potentially be
                    // used for running VMs. Will mark this server status as DISCONNECTED instead
                    log.debug("As cluster '{}' supports virt service as well, server '{}' detected as removed from glusterfs will not be removed from engine", cluster.getName(), server.getHostName());
                    setNonOperational(server);
                    continue;
                }
                log.info("Server '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", server.getName());
                logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
                try (EngineLock lock = glusterUtil.acquireGlusterLockWait(server.getId())) {
                    removeServerFromDb(server);
                    // if last but one server, reset alternate probed address for last server
                    checkAndResetKnownAddress(existingServers, server);
                    // remove the server from resource manager
                    runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
                    serverRemoved = true;
                } catch (Exception e) {
                    log.error("Error while removing server '{}' from database: {}", server.getName(), e.getMessage());
                    log.debug("Exception", e);
                }
            } else if (server.getStatus() == VDSStatus.Up && glusterServer.getStatus() == PeerStatus.DISCONNECTED) {
                // check gluster is running, if down then move the host to Non-Operational
                VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(server.getId()));
                if (!returnValue.getSucceeded()) {
                    setNonOperational(server);
                }
            } else {
                // update correct status and check if all interfaces with gluster network have been peer probed.
                updateStatusAndpeerProbeOtherIface(glusterNetwork, server, glusterServer);
            }
        }
    }
    if (serverRemoved) {
        log.info("Servers detached using gluster CLI is removed from engine after inspecting the Gluster servers" + " list returned '{}' - comparing with db servers '{}'", fetchedServers, existingServers);
    }
}
#end_block

#method_before
// Check if only 1 host remaining in cluster, if so reset it's known address so that new host will
private void checkAndResetKnownAddress(List<VDS> servers, VDS removedServer) {
    if (servers.size() == 2) {
        for (VDS server : servers) {
            // set the known address on the remaining server.
            if (!Objects.equals(server.getId(), removedServer.getId())) {
                getGlusterServerDao().updateKnownAddresses(server.getId(), null);
            }
        }
    }
}
#method_after
// Check if only 1 host remaining in cluster, if so reset it's known address so that new host will
private void checkAndResetKnownAddress(List<VDS> servers, VDS removedServer) {
    if (servers.size() == 2) {
        for (VDS server : servers) {
            // set the known address on the remaining server.
            if (!Objects.equals(server.getId(), removedServer.getId())) {
                serverDao.updateKnownAddresses(server.getId(), null);
            }
        }
    }
}
#end_block

#method_before
private void updateStatusAndpeerProbeOtherIface(Network glusterNetwork, VDS host, GlusterServerInfo fetchedServerInfo) {
    GlusterServer glusterServer = getGlusterServerDao().get(host.getId());
    if (glusterServer == null) {
        return;
    }
    if (glusterServer.getPeerStatus() == PeerStatus.DISCONNECTED && fetchedServerInfo.getStatus() == PeerStatus.CONNECTED) {
        // change the status to indicate that host is now part of cluster
        getGlusterServerDao().updatePeerStatus(host.getId(), PeerStatus.CONNECTED);
    }
    if (glusterNetwork == null || host.getStatus() != VDSStatus.Up) {
        return;
    }
    List<VdsNetworkInterface> interfaces = getInterfaceDao().getAllInterfacesForVds(host.getId());
    for (VdsNetworkInterface iface : interfaces) {
        if (glusterNetwork.getName().equals(iface.getNetworkName()) && StringUtils.isNotBlank(iface.getIpv4Address()) && !glusterServer.getKnownAddresses().contains(iface.getIpv4Address())) {
            // get another server in the cluster
            VDS upServer = getAlternateUpServerInCluster(host.getClusterId(), host.getId());
            if (upServer != null) {
                boolean peerProbed = glusterPeerProbeAdditionalInterface(upServer.getId(), iface.getIpv4Address());
                if (peerProbed) {
                    getGlusterServerDao().addKnownAddress(host.getId(), iface.getIpv4Address());
                }
            } else {
                log.warn("probe could not be done for server '{}' as no alternate UP server found", host.getHostName());
            }
        }
    }
}
#method_after
private void updateStatusAndpeerProbeOtherIface(Network glusterNetwork, VDS host, GlusterServerInfo fetchedServerInfo) {
    GlusterServer glusterServer = serverDao.get(host.getId());
    if (glusterServer == null) {
        return;
    }
    if (glusterServer.getPeerStatus() == PeerStatus.DISCONNECTED && fetchedServerInfo.getStatus() == PeerStatus.CONNECTED) {
        // change the status to indicate that host is now part of cluster
        serverDao.updatePeerStatus(host.getId(), PeerStatus.CONNECTED);
    }
    if (glusterNetwork == null || host.getStatus() != VDSStatus.Up) {
        return;
    }
    List<VdsNetworkInterface> interfaces = interfaceDao.getAllInterfacesForVds(host.getId());
    for (VdsNetworkInterface iface : interfaces) {
        if (glusterNetwork.getName().equals(iface.getNetworkName()) && StringUtils.isNotBlank(iface.getIpv4Address()) && !glusterServer.getKnownAddresses().contains(iface.getIpv4Address())) {
            // get another server in the cluster
            VDS upServer = getAlternateUpServerInCluster(host.getClusterId(), host.getId());
            if (upServer != null) {
                boolean peerProbed = glusterPeerProbeAdditionalInterface(upServer, iface.getIpv4Address());
                if (peerProbed) {
                    serverDao.addKnownAddress(host.getId(), iface.getIpv4Address());
                }
            } else {
                log.warn("probe could not be done for server '{}' as no alternate UP server found", host.getHostName());
            }
        }
    }
}
#end_block

#method_before
private Network findGlusterNetwork(Guid clusterId) {
    List<Network> allNetworksInCluster = getNetworkDao().getAllForCluster(clusterId);
    for (Network network : allNetworksInCluster) {
        if (network.getCluster().isGluster()) {
            return network;
        }
    }
    return null;
}
#method_after
private Network findGlusterNetwork(Guid clusterId) {
    List<Network> allNetworksInCluster = networkDao.getAllForCluster(clusterId);
    for (Network network : allNetworksInCluster) {
        if (network.getCluster().isGluster()) {
            return network;
        }
    }
    return null;
}
#end_block

#method_before
private VDS getAlternateUpServerInCluster(Guid clusterId, Guid vdsId) {
    List<VDS> vdsList = getVdsDao().getAllForClusterWithStatusAndPeerStatus(clusterId, VDSStatus.Up, PeerStatus.CONNECTED);
    // If the cluster already having Gluster servers, get an up server
    if (vdsList.isEmpty()) {
        return null;
    }
    for (VDS vds : vdsList) {
        if (!vdsId.equals(vds.getId()) && vds.getExternalStatus() == ExternalStatus.Ok) {
            return vds;
        }
    }
    return null;
}
#method_after
private VDS getAlternateUpServerInCluster(Guid clusterId, Guid vdsId) {
    List<VDS> vdsList = vdsDao.getAllForClusterWithStatusAndPeerStatus(clusterId, VDSStatus.Up, PeerStatus.CONNECTED);
    // If the cluster already having Gluster servers, get an up server
    if (vdsList.isEmpty()) {
        return null;
    }
    for (VDS vds : vdsList) {
        if (!vdsId.equals(vds.getId()) && vds.getExternalStatus() == ExternalStatus.Ok) {
            return vds;
        }
    }
    return null;
}
#end_block

#method_before
private boolean glusterPeerProbeAdditionalInterface(Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(upServerId));
            logable.updateCallStackFromThrowable(returnValue.getExceptionObject());
            auditLogDirector.log(logable, AuditLogType.GLUSTER_SERVER_ADD_FAILED);
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.info("Exception in peer probing alernate name '{}' on host with id '{}'", newServerName, upServerId);
        log.debug("Exception", e);
        return false;
    }
}
#method_after
private boolean glusterPeerProbeAdditionalInterface(VDS upServer, String newServerName) {
    Guid upServerId = upServer.getId();
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            AuditLogable logable = GlusterEventFactory.createEvent(upServer, returnValue);
            auditLogDirector.log(logable, AuditLogType.GLUSTER_SERVER_ADD_FAILED);
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.info("Exception in peer probing alernate name '{}' on host with id '{}'", newServerName, upServerId);
        log.debug("Exception", e);
        return false;
    }
}
#end_block

#method_before
private GlusterServerInfo findGlusterServer(VDS server, List<GlusterServerInfo> fetchedServers) {
    // compare gluster host uuid stored in server with the ones fetched from list
    GlusterServer glusterServer = getGlusterServerDao().getByServerId(server.getId());
    for (GlusterServerInfo fetchedServer : fetchedServers) {
        if (fetchedServer.getUuid().equals(glusterServer.getGlusterServerUuid())) {
            return fetchedServer;
        }
    }
    return null;
}
#method_after
private GlusterServerInfo findGlusterServer(VDS server, List<GlusterServerInfo> fetchedServers) {
    // compare gluster host uuid stored in server with the ones fetched from list
    GlusterServer glusterServer = serverDao.getByServerId(server.getId());
    for (GlusterServerInfo fetchedServer : fetchedServers) {
        if (fetchedServer.getUuid().equals(glusterServer.getGlusterServerUuid())) {
            return fetchedServer;
        }
    }
    return null;
}
#end_block

#method_before
private boolean isSameServer(VDS upServer, GlusterServerInfo server) {
    GlusterServer glusterUpServer = getGlusterServerDao().getByServerId(upServer.getId());
    return glusterUpServer.getGlusterServerUuid().equals(server.getUuid());
}
#method_after
private boolean isSameServer(VDS upServer, GlusterServerInfo server) {
    GlusterServer glusterUpServer = serverDao.getByServerId(upServer.getId());
    return glusterUpServer.getGlusterServerUuid().equals(server.getUuid());
}
#end_block

#method_before
private void setNonOperational(VDS server) {
    Cluster cluster = getClusterDao().get(server.getClusterId());
    if (!cluster.supportsVirtService()) {
        SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED, Collections.singletonMap(GlusterConstants.COMMAND, "gluster peer status"));
        backend.runInternalAction(VdcActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
    }
    getGlusterServerDao().updatePeerStatus(server.getId(), PeerStatus.DISCONNECTED);
    logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_STATUS_DISCONNECTED);
}
#method_after
private void setNonOperational(VDS server) {
    Cluster cluster = clusterDao.get(server.getClusterId());
    if (!cluster.supportsVirtService()) {
        SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED, Collections.singletonMap(GlusterConstants.COMMAND, "gluster peer status"));
        backend.runInternalAction(ActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
    }
    serverDao.updatePeerStatus(server.getId(), PeerStatus.DISCONNECTED);
    logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_STATUS_DISCONNECTED);
}
#end_block

#method_before
private void removeDeletedVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(clusterId)) {
        if (!volumesMap.containsKey(volume.getId())) {
            idsToRemove.add(volume.getId());
            log.debug("Volume '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", volume.getName());
            logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI);
            // Set the gluster cli schedule enabled flag back to true
            if (Config.<String>getValue(ConfigValues.GlusterMetaVolumeName).equalsIgnoreCase(volume.getName())) {
                Cluster cluster = getClusterDao().get(clusterId);
                cluster.setGlusterCliBasedSchedulingOn(true);
                getClusterDao().update(cluster);
            }
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getVolumeDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing volumes from database!", e);
        }
    }
}
#method_after
private void removeDeletedVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (GlusterVolumeEntity volume : volumeDao.getByClusterId(clusterId)) {
        if (!volumesMap.containsKey(volume.getId())) {
            idsToRemove.add(volume.getId());
            log.debug("Volume '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", volume.getName());
            logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI);
            // Set the gluster cli schedule enabled flag back to true
            if (Config.<String>getValue(ConfigValues.GlusterMetaVolumeName).equalsIgnoreCase(volume.getName())) {
                Cluster cluster = clusterDao.get(clusterId);
                cluster.setGlusterCliBasedSchedulingOn(true);
                clusterDao.update(cluster);
            }
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            volumeDao.removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing volumes from database!", e);
        }
    }
}
#end_block

#method_before
private void updateExistingAndNewVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    Cluster cluster = getClusterDao().get(clusterId);
    for (Entry<Guid, GlusterVolumeEntity> entry : volumesMap.entrySet()) {
        GlusterVolumeEntity volume = entry.getValue();
        log.debug("Analyzing volume '{}'", volume.getName());
        GlusterVolumeEntity existingVolume = getVolumeDao().getById(entry.getKey());
        if (existingVolume == null) {
            try {
                createVolume(volume);
            } catch (Exception e) {
                log.error("Could not save volume {} in database: {}", volume.getName(), e.getMessage());
                log.debug("Exception", e);
            }
            // Set the CLI based snapshot scheduling flag accordingly
            disableCliSnapshotSchedulingFlag(cluster, volume);
        } else {
            try {
                log.debug("Volume '{}' exists in engine. Checking if it needs to be updated.", existingVolume.getName());
                updateVolume(existingVolume, volume);
            } catch (Exception e) {
                log.error("Error while updating volume '{}': {}", volume.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#method_after
private void updateExistingAndNewVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    Cluster cluster = clusterDao.get(clusterId);
    for (Entry<Guid, GlusterVolumeEntity> entry : volumesMap.entrySet()) {
        GlusterVolumeEntity volume = entry.getValue();
        log.debug("Analyzing volume '{}'", volume.getName());
        GlusterVolumeEntity existingVolume = volumeDao.getById(entry.getKey());
        if (existingVolume == null) {
            try {
                createVolume(volume);
            } catch (Exception e) {
                log.error("Could not save volume {} in database: {}", volume.getName(), e.getMessage());
                log.debug("Exception", e);
            }
            // Set the CLI based snapshot scheduling flag accordingly
            disableCliSnapshotSchedulingFlag(cluster, volume);
        } else {
            try {
                log.debug("Volume '{}' exists in engine. Checking if it needs to be updated.", existingVolume.getName());
                updateVolume(existingVolume, volume);
            } catch (Exception e) {
                log.error("Error while updating volume '{}': {}", volume.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#end_block

#method_before
private void disableCliSnapshotSchedulingFlag(Cluster cluster, GlusterVolumeEntity volume) {
    if (cluster.isGlusterCliBasedSchedulingOn() && Config.<String>getValue(ConfigValues.GlusterMetaVolumeName).equalsIgnoreCase(volume.getName())) {
        VdcReturnValueBase returnValue = backend.runInternalAction(VdcActionType.DisableGlusterCliSnapshotScheduleInternal, new GlusterVolumeActionParameters(volume.getId(), false), ExecutionHandler.createInternalJobContext());
        if (!returnValue.getSucceeded()) {
            log.warn("Unbale to set volume snapshot scheduling flag to gluster CLI scheduler on cluster {}", cluster.getName());
        } else {
            logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_CLI_SNAPSHOT_SCHEDULE_DISABLED);
        }
    }
}
#method_after
private void disableCliSnapshotSchedulingFlag(Cluster cluster, GlusterVolumeEntity volume) {
    if (cluster.isGlusterCliBasedSchedulingOn() && Config.<String>getValue(ConfigValues.GlusterMetaVolumeName).equalsIgnoreCase(volume.getName())) {
        ActionReturnValue returnValue = backend.runInternalAction(ActionType.DisableGlusterCliSnapshotScheduleInternal, new GlusterVolumeActionParameters(volume.getId(), false), ExecutionHandler.createInternalJobContext());
        if (!returnValue.getSucceeded()) {
            log.warn("Unbale to set volume snapshot scheduling flag to gluster CLI scheduler on cluster {}", cluster.getName());
        } else {
            logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_CLI_SNAPSHOT_SCHEDULE_DISABLED);
        }
    }
}
#end_block

#method_before
private void createVolume(final GlusterVolumeEntity volume) {
    if (volume.getBricks() == null) {
        log.warn("Bricks of volume '{}' were not fetched. " + "Hence will not add it to engine at this point.", volume.getName());
        return;
    }
    for (GlusterBrickEntity brick : volume.getBricks()) {
        if (brick == null) {
            log.warn("Volume '{}' contains a apparently corrupt brick(s). " + "Hence will not add it to engine at this point.", volume.getName());
            return;
        } else if (brick.getServerId() == null) {
            log.warn("Volume '{}' contains brick(s) from unknown hosts. " + "Hence will not add it to engine at this point.", volume.getName());
            return;
        }
        // Set initial brick status as similar to volume status.
        // As actual brick status is updated by another sync job,
        // till it happens, this gives better UI experience
        brick.setStatus(volume.getStatus());
    }
    logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI);
    if (!volume.getVolumeType().isSupported()) {
        logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_VOLUME_TYPE_UNSUPPORTED, new HashMap<String, String>() {

            {
                put(GlusterConstants.VOLUME_TYPE, volume.getVolumeType().toString());
            }
        });
    }
    log.debug("Volume '{}' has been created directly using the gluster CLI. Creating it in engine as well.", volume.getName());
    getVolumeDao().save(volume);
}
#method_after
private void createVolume(final GlusterVolumeEntity volume) {
    if (volume.getBricks() == null) {
        log.warn("Bricks of volume '{}' were not fetched. " + "Hence will not add it to engine at this point.", volume.getName());
        return;
    }
    for (GlusterBrickEntity brick : volume.getBricks()) {
        if (brick == null) {
            log.warn("Volume '{}' contains a apparently corrupt brick(s). " + "Hence will not add it to engine at this point.", volume.getName());
            return;
        } else if (brick.getServerId() == null) {
            log.warn("Volume '{}' contains brick(s) from unknown hosts. " + "Hence will not add it to engine at this point.", volume.getName());
            return;
        }
        // Set initial brick status as similar to volume status.
        // As actual brick status is updated by another sync job,
        // till it happens, this gives better UI experience
        brick.setStatus(volume.getStatus());
    }
    logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI);
    if (!volume.getVolumeType().isSupported()) {
        logUtil.logAuditMessage(volume.getClusterId(), volume.getClusterName(), volume, null, AuditLogType.GLUSTER_VOLUME_TYPE_UNSUPPORTED, Collections.singletonMap(GlusterConstants.VOLUME_TYPE, volume.getVolumeType().toString()));
    }
    log.debug("Volume '{}' has been created directly using the gluster CLI. Creating it in engine as well.", volume.getName());
    volumeDao.save(volume);
}
#end_block

#method_before
private void updateTransportTypes(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    Set<TransportType> existingTransportTypes = existingVolume.getTransportTypes();
    Set<TransportType> fetchedTransportTypes = fetchedVolume.getTransportTypes();
    Collection<TransportType> addedTransportTypes = CollectionUtils.subtract(fetchedTransportTypes, existingTransportTypes);
    if (!addedTransportTypes.isEmpty()) {
        log.info("Adding transport type(s) '{}' to volume '{}'", addedTransportTypes, existingVolume.getName());
        getVolumeDao().addTransportTypes(existingVolume.getId(), addedTransportTypes);
    }
    Collection<TransportType> removedTransportTypes = CollectionUtils.subtract(existingTransportTypes, fetchedTransportTypes);
    if (!removedTransportTypes.isEmpty()) {
        log.info("Removing transport type(s) '{}' from volume '{}'", removedTransportTypes, existingVolume.getName());
        getVolumeDao().removeTransportTypes(existingVolume.getId(), removedTransportTypes);
    }
}
#method_after
private void updateTransportTypes(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    Set<TransportType> existingTransportTypes = existingVolume.getTransportTypes();
    Set<TransportType> fetchedTransportTypes = fetchedVolume.getTransportTypes();
    Collection<TransportType> addedTransportTypes = CollectionUtils.subtract(fetchedTransportTypes, existingTransportTypes);
    if (!addedTransportTypes.isEmpty()) {
        log.info("Adding transport type(s) '{}' to volume '{}'", addedTransportTypes, existingVolume.getName());
        volumeDao.addTransportTypes(existingVolume.getId(), addedTransportTypes);
    }
    Collection<TransportType> removedTransportTypes = CollectionUtils.subtract(existingTransportTypes, fetchedTransportTypes);
    if (!removedTransportTypes.isEmpty()) {
        log.info("Removing transport type(s) '{}' from volume '{}'", removedTransportTypes, existingVolume.getName());
        volumeDao.removeTransportTypes(existingVolume.getId(), removedTransportTypes);
    }
}
#end_block

#method_before
@SuppressWarnings("serial")
private void removeDeletedBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (final GlusterBrickEntity existingBrick : existingVolume.getBricks()) {
        if (!GlusterCoreUtil.containsBrick(fetchedBricks, existingBrick)) {
            idsToRemove.add(existingBrick.getId());
            log.info("Detected brick '{}' removed from volume '{}'. Removing it from engine DB as well.", existingBrick.getQualifiedName(), existingVolume.getName());
            logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, new HashMap<String, String>() {

                {
                    put(GlusterConstants.BRICK, existingBrick.getQualifiedName());
                }
            });
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getBrickDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing bricks from database: {}", e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#method_after
@SuppressWarnings("serial")
private void removeDeletedBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (final GlusterBrickEntity existingBrick : existingVolume.getBricks()) {
        if (!GlusterCoreUtil.containsBrick(fetchedBricks, existingBrick)) {
            idsToRemove.add(existingBrick.getId());
            log.info("Detected brick '{}' removed from volume '{}'. Removing it from engine DB as well.", existingBrick.getQualifiedName(), existingVolume.getName());
            logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume.getClusterName(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, Collections.singletonMap(GlusterConstants.BRICK, existingBrick.getQualifiedName()));
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            brickDao.removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing bricks from database: {}", e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@SuppressWarnings("serial")
private void updateExistingAndNewBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    for (final GlusterBrickEntity fetchedBrick : fetchedBricks) {
        GlusterBrickEntity existingBrick = GlusterCoreUtil.findBrick(existingVolume.getBricks(), fetchedBrick);
        if (existingBrick == null) {
            // adding such servers to engine required manual approval by user, and hence can't be automated.
            if (fetchedBrick.getServerId() != null) {
                log.info("New brick '{}' added to volume '{}' from gluster CLI. Updating engine DB accordingly.", fetchedBrick.getQualifiedName(), existingVolume.getName());
                fetchedBrick.setStatus(existingVolume.isOnline() ? GlusterStatus.UP : GlusterStatus.DOWN);
                getBrickDao().save(fetchedBrick);
                logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, new HashMap<String, String>() {

                    {
                        put(GlusterConstants.BRICK, fetchedBrick.getQualifiedName());
                    }
                });
            }
        } else {
            // brick found. update it if required. Only property that could be different is the brick order
            if (!Objects.equals(existingBrick.getBrickOrder(), fetchedBrick.getBrickOrder())) {
                log.info("Brick order for brick '{}' changed from '{}' to '{}' because of direct CLI operations. Updating engine DB accordingly.", existingBrick.getQualifiedName(), existingBrick.getBrickOrder(), fetchedBrick.getBrickOrder());
                getBrickDao().updateBrickOrder(existingBrick.getId(), fetchedBrick.getBrickOrder());
            }
            // update network id, if different
            if (!Objects.equals(existingBrick.getNetworkId(), fetchedBrick.getNetworkId())) {
                log.info("Network address for brick '{}' detected as  '{}'. Updating engine DB accordingly.", existingBrick.getQualifiedName(), fetchedBrick.getNetworkAddress());
                getBrickDao().updateBrickNetworkId(existingBrick.getId(), fetchedBrick.getNetworkId());
            }
        }
    }
}
#method_after
@SuppressWarnings("serial")
private void updateExistingAndNewBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    for (final GlusterBrickEntity fetchedBrick : fetchedBricks) {
        GlusterBrickEntity existingBrick = GlusterCoreUtil.findBrick(existingVolume.getBricks(), fetchedBrick);
        if (existingBrick == null) {
            // adding such servers to engine required manual approval by user, and hence can't be automated.
            if (fetchedBrick.getServerId() != null) {
                log.info("New brick '{}' added to volume '{}' from gluster CLI. Updating engine DB accordingly.", fetchedBrick.getQualifiedName(), existingVolume.getName());
                fetchedBrick.setStatus(existingVolume.isOnline() ? GlusterStatus.UP : GlusterStatus.DOWN);
                brickDao.save(fetchedBrick);
                logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume.getClusterName(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, Collections.singletonMap(GlusterConstants.BRICK, fetchedBrick.getQualifiedName()));
            }
        } else {
            // brick found. update it if required. Only property that could be different is the brick order
            if (!Objects.equals(existingBrick.getBrickOrder(), fetchedBrick.getBrickOrder())) {
                log.info("Brick order for brick '{}' changed from '{}' to '{}' because of direct CLI operations. Updating engine DB accordingly.", existingBrick.getQualifiedName(), existingBrick.getBrickOrder(), fetchedBrick.getBrickOrder());
                brickDao.updateBrickOrder(existingBrick.getId(), fetchedBrick.getBrickOrder());
            }
            // update network id, if different
            if (!Objects.equals(existingBrick.getNetworkId(), fetchedBrick.getNetworkId())) {
                log.info("Network address for brick '{}' detected as  '{}'. Updating engine DB accordingly.", existingBrick.getQualifiedName(), fetchedBrick.getNetworkAddress());
                brickDao.updateBrickNetworkId(existingBrick.getId(), fetchedBrick.getNetworkId());
            }
        }
    }
}
#end_block

#method_before
@SuppressWarnings("serial")
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (final GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            idsToRemove.add(existingOption.getId());
            log.info("Detected option '{}' reset on volume '{}'. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            // Hence it is not required to log it as a removed option, as that would be misleading.
            if (!GlusterConstants.OPTION_GROUP.equals(existingOption.getKey())) {
                logUtil.logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, new HashMap<String, String>() {

                    {
                        put(GlusterConstants.OPTION_KEY, existingOption.getKey());
                        put(GlusterConstants.OPTION_VALUE, existingOption.getValue());
                    }
                });
            }
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getOptionDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing options of volume '{}' from database: {}", fetchedVolume.getName(), e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#method_after
@SuppressWarnings("serial")
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    List<Guid> idsToRemove = new ArrayList<>();
    for (final GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            idsToRemove.add(existingOption.getId());
            log.info("Detected option '{}' reset on volume '{}'. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            // Hence it is not required to log it as a removed option, as that would be misleading.
            if (!GlusterConstants.OPTION_GROUP.equals(existingOption.getKey())) {
                Map<String, String> customValues = new HashMap<>();
                customValues.put(GlusterConstants.OPTION_KEY, existingOption.getKey());
                customValues.put(GlusterConstants.OPTION_VALUE, existingOption.getValue());
                logUtil.logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume.getClusterName(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, customValues);
            }
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            optionDao.removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing options of volume '{}' from database: {}", fetchedVolume.getName(), e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
private void saveNewOptions(GlusterVolumeEntity volume, Collection<GlusterVolumeOptionEntity> entities) {
    getOptionDao().saveAll(entities);
    for (final GlusterVolumeOptionEntity entity : entities) {
        logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, new HashMap<String, String>() {

            {
                put(GlusterConstants.OPTION_KEY, entity.getKey());
                put(GlusterConstants.OPTION_VALUE, entity.getValue());
            }
        });
        log.info("New option '{}'='{}' set on volume '{}' from gluster CLI. Updating engine DB accordingly.", entity.getKey(), entity.getValue(), volume.getName());
    }
}
#method_after
private void saveNewOptions(GlusterVolumeEntity volume, Collection<GlusterVolumeOptionEntity> entities) {
    optionDao.saveAll(entities);
    for (final GlusterVolumeOptionEntity entity : entities) {
        Map<String, String> customValues = new HashMap<>();
        customValues.put(GlusterConstants.OPTION_KEY, entity.getKey());
        customValues.put(GlusterConstants.OPTION_VALUE, entity.getValue());
        logUtil.logAuditMessage(volume.getClusterId(), volume.getClusterName(), volume, null, AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, customValues);
        log.info("New option '{}'='{}' set on volume '{}' from gluster CLI. Updating engine DB accordingly.", entity.getKey(), entity.getValue(), volume.getName());
    }
}
#end_block

#method_before
private void updateExistingOptions(final GlusterVolumeEntity volume, Collection<GlusterVolumeOptionEntity> entities) {
    getOptionDao().updateAll("UpdateGlusterVolumeOption", entities);
    for (final GlusterVolumeOptionEntity entity : entities) {
        logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_VOLUME_OPTION_CHANGED_FROM_CLI, new HashMap<String, String>() {

            {
                put(GlusterConstants.OPTION_KEY, entity.getKey());
                put(GlusterConstants.OPTION_OLD_VALUE, volume.getOption(entity.getKey()).getValue());
                put(GlusterConstants.OPTION_NEW_VALUE, entity.getValue());
            }
        });
        log.info("Detected change in value of option '{}' of volume '{}' from '{}' to '{}'. Updating engine DB accordingly.", volume.getOption(entity.getKey()), volume.getName(), volume.getOption(entity.getKey()).getValue(), entity.getValue());
    }
}
#method_after
private void updateExistingOptions(final GlusterVolumeEntity volume, Collection<GlusterVolumeOptionEntity> entities) {
    optionDao.updateAll("UpdateGlusterVolumeOption", entities);
    for (final GlusterVolumeOptionEntity entity : entities) {
        Map<String, String> customValues = new HashMap<>();
        customValues.put(GlusterConstants.OPTION_KEY, entity.getKey());
        customValues.put(GlusterConstants.OPTION_OLD_VALUE, volume.getOption(entity.getKey()).getValue());
        customValues.put(GlusterConstants.OPTION_NEW_VALUE, entity.getValue());
        logUtil.logAuditMessage(volume.getClusterId(), volume.getClusterName(), volume, null, AuditLogType.GLUSTER_VOLUME_OPTION_CHANGED_FROM_CLI, customValues);
        log.info("Detected change in value of option '{}' of volume '{}' from '{}' to '{}'. Updating engine DB accordingly.", volume.getOption(entity.getKey()), volume.getName(), volume.getOption(entity.getKey()).getValue(), entity.getValue());
    }
}
#end_block

#method_before
@SuppressWarnings("incomplete-switch")
public void updateVolumeProperties(GlusterVolumeEntity existingVolume, final GlusterVolumeEntity fetchedVolume) {
    boolean changed = false;
    boolean volumeTypeUnSupported = false;
    if (existingVolume.getVolumeType() != fetchedVolume.getVolumeType()) {
        if (existingVolume.getVolumeType().isSupported() && !fetchedVolume.getVolumeType().isSupported()) {
            volumeTypeUnSupported = true;
        }
        existingVolume.setVolumeType(fetchedVolume.getVolumeType());
        changed = true;
    }
    if (existingVolume.getVolumeType().isReplicatedType() && !Objects.equals(existingVolume.getReplicaCount(), fetchedVolume.getReplicaCount())) {
        existingVolume.setReplicaCount(fetchedVolume.getReplicaCount());
        changed = true;
    }
    if (existingVolume.getVolumeType().isStripedType() && !Objects.equals(existingVolume.getStripeCount(), fetchedVolume.getStripeCount())) {
        existingVolume.setStripeCount(fetchedVolume.getStripeCount());
        changed = true;
    }
    if (changed) {
        log.info("Updating volume '{}' with fetched properties.", existingVolume.getName());
        getVolumeDao().updateGlusterVolume(existingVolume);
        logUtil.logVolumeMessage(existingVolume, AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI);
        if (volumeTypeUnSupported) {
            logUtil.logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_TYPE_UNSUPPORTED, new HashMap<String, String>() {

                {
                    put(GlusterConstants.VOLUME_TYPE, fetchedVolume.getVolumeType().toString());
                }
            });
        }
    }
    if (existingVolume.getStatus() != fetchedVolume.getStatus()) {
        existingVolume.setStatus(fetchedVolume.getStatus());
        GlusterDBUtils.getInstance().updateVolumeStatus(existingVolume.getId(), fetchedVolume.getStatus());
        logUtil.logVolumeMessage(existingVolume, fetchedVolume.getStatus() == GlusterStatus.UP ? AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI : AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI);
    }
}
#method_after
@SuppressWarnings("incomplete-switch")
public void updateVolumeProperties(GlusterVolumeEntity existingVolume, final GlusterVolumeEntity fetchedVolume) {
    boolean changed = false;
    boolean volumeTypeUnSupported = false;
    if (existingVolume.getVolumeType() != fetchedVolume.getVolumeType()) {
        if (existingVolume.getVolumeType().isSupported() && !fetchedVolume.getVolumeType().isSupported()) {
            volumeTypeUnSupported = true;
        }
        existingVolume.setVolumeType(fetchedVolume.getVolumeType());
        changed = true;
    }
    if (existingVolume.getVolumeType().isReplicatedType() && !Objects.equals(existingVolume.getReplicaCount(), fetchedVolume.getReplicaCount())) {
        existingVolume.setReplicaCount(fetchedVolume.getReplicaCount());
        changed = true;
    }
    if (existingVolume.getVolumeType().isStripedType() && !Objects.equals(existingVolume.getStripeCount(), fetchedVolume.getStripeCount())) {
        existingVolume.setStripeCount(fetchedVolume.getStripeCount());
        changed = true;
    }
    if (changed) {
        log.info("Updating volume '{}' with fetched properties.", existingVolume.getName());
        volumeDao.updateGlusterVolume(existingVolume);
        logUtil.logVolumeMessage(existingVolume, AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI);
        if (volumeTypeUnSupported) {
            logUtil.logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume.getClusterName(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_TYPE_UNSUPPORTED, Collections.singletonMap(GlusterConstants.VOLUME_TYPE, fetchedVolume.getVolumeType().toString()));
        }
    }
    if (existingVolume.getStatus() != fetchedVolume.getStatus()) {
        existingVolume.setStatus(fetchedVolume.getStatus());
        glusterDBUtils.updateVolumeStatus(existingVolume.getId(), fetchedVolume.getStatus());
        logUtil.logVolumeMessage(existingVolume, fetchedVolume.getStatus() == GlusterStatus.UP ? AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI : AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshHeavyWeightData")
public void refreshHeavyWeightData() {
    log.debug("Refreshing Gluster Data [heavyweight]");
    for (Cluster cluster : getClusterDao().getAll()) {
        if (cluster.supportsGlusterService()) {
            try {
                refreshClusterHeavyWeightData(cluster);
            } catch (Exception e) {
                log.error("Error while refreshing Gluster heavyweight data of cluster '{}': {}", cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("refreshHeavyWeightData")
public void refreshHeavyWeightData() {
    log.debug("Refreshing Gluster Data [heavyweight]");
    for (Cluster cluster : clusterDao.getAll()) {
        if (cluster.supportsGlusterService()) {
            try {
                refreshClusterHeavyWeightData(cluster);
            } catch (Exception e) {
                log.error("Error while refreshing Gluster heavyweight data of cluster '{}': {}", cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#end_block

#method_before
private void refreshClusterHeavyWeightData(Cluster cluster) {
    VDS upServer = getGlusterUtil().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debug("No server UP in cluster '{}'. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debug("Refreshing brick statuses for volume '{}' of cluster '{}'", volume.getName(), cluster.getName());
        // brick statuses can be fetched only for started volumes
        if (volume.isOnline()) {
            acquireLock(cluster.getId());
            try {
                refreshVolumeDetails(upServer, volume);
            } catch (Exception e) {
                log.error("Error while refreshing brick statuses for volume '{}' of cluster '{}': {}", volume.getName(), cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            } finally {
                releaseLock(cluster.getId());
            }
        }
    }
}
#method_after
private void refreshClusterHeavyWeightData(Cluster cluster) {
    VDS upServer = glusterUtil.getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debug("No server UP in cluster '{}'. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : volumeDao.getByClusterId(cluster.getId())) {
        log.debug("Refreshing brick statuses for volume '{}' of cluster '{}'", volume.getName(), cluster.getName());
        // brick statuses can be fetched only for started volumes
        if (volume.isOnline()) {
            acquireLock(cluster.getId());
            try {
                refreshVolumeDetails(upServer, volume);
            } catch (Exception e) {
                log.error("Error while refreshing brick statuses for volume '{}' of cluster '{}': {}", volume.getName(), cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            } finally {
                releaseLock(cluster.getId());
            }
        }
    }
}
#end_block

#method_before
public void refreshVolumeDetails(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<>();
    GlusterVolumeAdvancedDetails volumeAdvancedDetails = getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName());
    if (volumeAdvancedDetails == null) {
        log.error("Error while refreshing brick statuses for volume '{}'. Failed to get volume advanced details ", volume.getName());
        return;
    }
    if (volumeAdvancedDetails.getCapacityInfo() != null) {
        if (volume.getAdvancedDetails().getCapacityInfo() == null) {
            getVolumeDao().addVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        } else {
            getVolumeDao().updateVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        }
    }
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        getBrickDao().addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        getBrickDao().updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        getBrickDao().updateBrickStatuses(bricksToUpdate);
    }
}
#method_after
public void refreshVolumeDetails(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<>();
    GlusterVolumeAdvancedDetails volumeAdvancedDetails = getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName());
    if (volumeAdvancedDetails == null) {
        log.error("Error while refreshing brick statuses for volume '{}'. Failed to get volume advanced details ", volume.getName());
        return;
    }
    if (volumeAdvancedDetails.getCapacityInfo() != null) {
        if (volume.getAdvancedDetails().getCapacityInfo() == null) {
            volumeDao.addVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        } else {
            volumeDao.updateVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        }
    }
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        brickDao.addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        brickDao.updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        brickDao.updateBrickStatuses(bricksToUpdate);
    }
}
#end_block

#method_before
private void logBrickStatusChange(GlusterVolumeEntity volume, final GlusterBrickEntity brick, final GlusterStatus fetchedStatus) {
    log.debug("Detected that status of brick '{}' in volume '{}' changed from '{}' to '{}'", brick.getQualifiedName(), volume.getName(), brick.getStatus(), fetchedStatus);
    logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, new HashMap<String, String>() {

        {
            put(GlusterConstants.BRICK_PATH, brick.getQualifiedName());
            put(GlusterConstants.OPTION_OLD_VALUE, brick.getStatus().toString());
            put(GlusterConstants.OPTION_NEW_VALUE, fetchedStatus.toString());
            put("source", "cli");
        }
    });
    if (fetchedStatus == GlusterStatus.DOWN) {
        logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_BRICK_STATUS_DOWN, brick.getId(), brick.getQualifiedName());
    } else if (fetchedStatus == GlusterStatus.UP) {
        AlertDirector.removeAlertsByBrickIdLogType(brick.getId(), AuditLogType.GLUSTER_BRICK_STATUS_DOWN);
    }
}
#method_after
private void logBrickStatusChange(GlusterVolumeEntity volume, final GlusterBrickEntity brick, final GlusterStatus fetchedStatus) {
    log.debug("Detected that status of brick '{}' in volume '{}' changed from '{}' to '{}'", brick.getQualifiedName(), volume.getName(), brick.getStatus(), fetchedStatus);
    Map<String, String> customValues = new HashMap<>();
    customValues.put(GlusterConstants.BRICK_PATH, brick.getQualifiedName());
    customValues.put(GlusterConstants.OPTION_OLD_VALUE, brick.getStatus().toString());
    customValues.put(GlusterConstants.OPTION_NEW_VALUE, fetchedStatus.toString());
    customValues.put(GlusterConstants.SOURCE, GlusterConstants.SOURCE_CLI);
    logUtil.logAuditMessage(volume.getClusterId(), volume.getClusterName(), volume, null, AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, customValues);
    if (fetchedStatus == GlusterStatus.DOWN) {
        logUtil.logAuditMessage(volume, AuditLogType.GLUSTER_BRICK_STATUS_DOWN, brick.getId(), brick.getQualifiedName());
    } else if (fetchedStatus == GlusterStatus.UP) {
        alertDirector.removeAlertsByBrickIdLogType(brick.getId(), AuditLogType.GLUSTER_BRICK_STATUS_DOWN);
    }
}
#end_block

#method_before
private void removeVdsStatisticsFromDb(VDS server) {
    getVdsStatisticsDao().remove(server.getId());
}
#method_after
private void removeVdsStatisticsFromDb(VDS server) {
    vdsStatisticsDao.remove(server.getId());
}
#end_block

#method_before
private void removeVdsStaticFromDb(VDS server) {
    getVdsStaticDao().remove(server.getId());
}
#method_after
private void removeVdsStaticFromDb(VDS server) {
    vdsStaticDao.remove(server.getId());
}
#end_block

#method_before
private void removeVdsDynamicFromDb(VDS server) {
    getVdsDynamicDao().remove(server.getId());
}
#method_after
private void removeVdsDynamicFromDb(VDS server) {
    vdsDynamicDao.remove(server.getId());
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshSelfHealInfo")
public void refreshSelfHealInfo() {
    log.debug("Refreshing Gluster Self Heal Data");
    for (Cluster cluster : getClusterDao().getAll()) {
        if (supportsGlusterSelfHealMonitoring(cluster)) {
            try {
                refreshSelfHealData(cluster);
            } catch (Exception e) {
                log.error("Error while refreshing Gluster self heal data of cluster '{}': {}", cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
    log.debug("Refreshing Gluster Self Heal data is completed");
}
#method_after
@OnTimerMethodAnnotation("refreshSelfHealInfo")
public void refreshSelfHealInfo() {
    log.debug("Refreshing Gluster Self Heal Data");
    for (Cluster cluster : clusterDao.getAll()) {
        if (supportsGlusterSelfHealMonitoring(cluster)) {
            try {
                refreshSelfHealData(cluster);
            } catch (Exception e) {
                log.error("Error while refreshing Gluster self heal data of cluster '{}': {}", cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
    log.debug("Refreshing Gluster Self Heal data is completed");
}
#end_block

#method_before
public void refreshSelfHealData(Cluster cluster) {
    VDS upServer = getGlusterUtil().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debug("No server UP in cluster '{}'. Can't refresh self heal data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debug("Refreshing self heal status for volume '{}' of cluster '{}'", volume.getName(), cluster.getName());
        // self heal info can be fetched only for started volumes
        if (volume.isOnline()) {
            try {
                refreshSelfHealData(upServer, volume);
            } catch (Exception e) {
                log.error("Error while refreshing brick statuses for volume '{}' of cluster '{}': {}", volume.getName(), cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#method_after
public void refreshSelfHealData(Cluster cluster) {
    VDS upServer = glusterUtil.getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debug("No server UP in cluster '{}'. Can't refresh self heal data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : volumeDao.getByClusterId(cluster.getId())) {
        log.debug("Refreshing self heal status for volume '{}' of cluster '{}'", volume.getName(), cluster.getName());
        // self heal info can be fetched only for started volumes
        if (volume.isOnline()) {
            try {
                refreshSelfHealData(upServer, volume);
            } catch (Exception e) {
                log.error("Error while refreshing brick statuses for volume '{}' of cluster '{}': {}", volume.getName(), cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#end_block

#method_before
private void refreshSelfHealData(VDS upServer, GlusterVolumeEntity volume) {
    Integer usageHistoryLimit = Config.getValue(ConfigValues.GlusterUnSyncedEntriesHistoryLimit);
    Map<Guid, Integer> healInfo = getGlusterVolumeHealInfo(upServer, volume.getName());
    for (GlusterBrickEntity brick : volume.getBricks()) {
        brick.setUnSyncedEntries(healInfo.get(brick.getId()));
        brick.setUnSyncedEntriesTrend(addToHistory(brick.getUnSyncedEntriesTrend(), healInfo.get(brick.getId()), usageHistoryLimit));
    }
    getBrickDao().updateUnSyncedEntries(volume.getBricks());
}
#method_after
private void refreshSelfHealData(VDS upServer, GlusterVolumeEntity volume) {
    Integer usageHistoryLimit = Config.getValue(ConfigValues.GlusterUnSyncedEntriesHistoryLimit);
    Map<Guid, Integer> healInfo = getGlusterVolumeHealInfo(upServer, volume.getName());
    for (GlusterBrickEntity brick : volume.getBricks()) {
        brick.setUnSyncedEntries(healInfo.get(brick.getId()));
        brick.setUnSyncedEntriesTrend(addToHistory(brick.getUnSyncedEntriesTrend(), healInfo.get(brick.getId()), usageHistoryLimit));
    }
    brickDao.updateUnSyncedEntries(volume.getBricks());
}
#end_block

#method_before
private List<Integer> addToHistory(List<Integer> current, Integer newValue, int limit) {
    if (newValue == null) {
        // Store -1 instead of Null so that we can maintain the fixed time interval between each entries.
        newValue = -1;
    }
    if (current == null || current.isEmpty()) {
        return Arrays.asList(newValue);
    }
    if (limit == 0) {
        return Collections.emptyList();
    }
    List<Integer> res = new ArrayList<>(current);
    res.add(newValue);
    if (limit >= res.size()) {
        return res;
    }
    return res.subList(res.size() - limit, res.size());
}
#method_after
private List<Integer> addToHistory(List<Integer> current, Integer newValue, int limit) {
    if (newValue == null) {
        // Store -1 instead of Null so that we can maintain the fixed time interval between each entries.
        newValue = -1;
    }
    if (current == null || current.isEmpty()) {
        return Collections.singletonList(newValue);
    }
    if (limit == 0) {
        return Collections.emptyList();
    }
    List<Integer> res = new ArrayList<>(current);
    res.add(newValue);
    if (limit >= res.size()) {
        return res;
    }
    return res.subList(res.size() - limit, res.size());
}
#end_block

#method_before
@Override
public void processEvent(GlusterEvent event) {
    if (event == null) {
        return;
    }
    if (event.getEvent().equalsIgnoreCase("EVENT_GEOREP_CHECKPOINT_COMPLETED")) {
        log.info("################# Received georep checkpoint completed event");
        log.info("master volume name '{}'", event.getMessage().get("master_volume"));
        log.info("checkpoint completion time '{}'", event.getMessage().get("checkpoint_completion_time"));
    }
}
#method_after
@Override
public void processEvent(GlusterEvent event) {
    if (event == null) {
        log.debug("No event to process!");
        return;
    }
    GlusterServer glusterServer = glusterServerDao.getByGlusterServerUuid(Guid.createGuidFromString(event.getNodeId()));
    if (glusterServer == null) {
        log.debug("Could not determine gluster server from event '{}'", event);
        return;
    }
    VdsStatic host = vdsStaticDao.get(glusterServer.getId());
    if (host == null) {
        log.debug("No host corresponding to gluster server in '{}'", event);
        return;
    }
    if (event.getEvent().equalsIgnoreCase(EVENT_GEOREP_CHECKPOINT_COMPLETED)) {
        GlusterVolumeEntity masterVol = glusterVolumeDao.getByName(host.getClusterId(), (String) event.getMessage().get(MASTER_VOLUME));
        if (masterVol == null) {
            log.debug("Could not determine master volume from event '{}'", event);
            return;
        }
        GlusterGeoRepSession session = geoRepDao.getGeoRepSession(masterVol.getId(), (String) event.getMessage().get(SLAVE_HOST), (String) event.getMessage().get(SLAVE_VOLUME));
        // hence forcing sync for now.
        if (session != null) {
            log.debug("received event for session '{}'", session.getSessionKey());
        }
        geoRepSyncJob.refreshGeoRepDataForVolume(masterVol);
    }
}
#end_block

#method_before
@Override
public GlusterGeoRepSession getGeoRepSession(Guid masterVolumeId, String slaveHostName, String slaveVolumeName) {
    return getCallsHandler().executeRead("GetGlusterGeoRepSessionBySlaveHostAndVolume", georepSessionRowMapper, getCustomMapSqlParameterSource().addValue("master_volume_id", masterVolumeId).addValue("slave_host_name", slaveHostName).addValue("slave_volume_name", slaveVolumeName));
}
#method_after
@Override
public GlusterGeoRepSession getGeoRepSession(Guid masterVolumeId, String slaveHostName, String slaveVolumeName) {
    return getCallsHandler().executeRead("GetGlusterGeoRepSessionBySlaveHostNameAndVolume", georepSessionRowMapper, getCustomMapSqlParameterSource().addValue("master_volume_id", masterVolumeId).addValue("slave_host_name", slaveHostName).addValue("slave_volume_name", slaveVolumeName));
}
#end_block

#method_before
@Override
public void processEvent(GlusterEvent event) {
    if (event == null) {
        return;
    }
    GlusterServer glusterServer = glusterServerDao.getByGlusterServerUuid(Guid.createGuidFromString(event.getNodeId()));
    if (glusterServer == null) {
        return;
    }
    VDS host = vdsDao.get(glusterServer.getId());
    if (host == null) {
        return;
    }
    GlusterVolumeEntity vol = glusterVolumeDao.getByName(host.getClusterId(), (String) event.getMessage().get("volume"));
    if (vol == null) {
        return;
    }
    if (event.getEvent().equalsIgnoreCase("BRICK_DISCONNECTED") || event.getEvent().equalsIgnoreCase("BRICK_CONNECTED")) {
        // get brick
        GlusterStatus status = event.getEvent().equalsIgnoreCase("BRICK_DISCONNECTED") ? GlusterStatus.DOWN : GlusterStatus.UP;
        String path = (String) event.getMessage().get("brick");
        String peer = (String) event.getMessage().get("peer");
        List<VDS> vdsList = vdsDao.getAllForCluster(host.getClusterId());
        VDS vds = vdsList.stream().filter(v -> v.getName().equals(peer) || v.getInterfaces().stream().anyMatch(iface -> iface.getIpv4Address().equals(peer))).findFirst().orElse(null);
        GlusterBrickEntity brick = vds != null ? glusterBrickDao.getBrickByServerIdAndDirectory(vds.getId(), path) : null;
        if (brick != null) {
            glusterBrickDao.updateBrickStatus(brick.getId(), status);
        } else {
            // call sync to force updation
            backend.runInternalAction(VdcActionType.RefreshGlusterVolumeDetails, new GlusterVolumeParameters(vol.getId()));
        }
        logBrickStatusChange(vol, status, brick);
    }
}
#method_after
@Override
public void processEvent(GlusterEvent event) {
    if (event == null) {
        log.debug("No event to process!");
        return;
    }
    GlusterServer glusterServer = glusterServerDao.getByGlusterServerUuid(Guid.createGuidFromString(event.getNodeId()));
    if (glusterServer == null) {
        log.debug("Could not determine gluster server from event '{}'", event);
        return;
    }
    VdsStatic host = vdsStaticDao.get(glusterServer.getId());
    if (host == null) {
        log.debug("No host corresponding to gluster server in '{}'", event);
        return;
    }
    GlusterVolumeEntity vol = glusterVolumeDao.getByName(host.getClusterId(), (String) event.getMessage().get("volume"));
    if (vol == null) {
        return;
    }
    if (event.getEvent().equalsIgnoreCase(EVENT_BRICK_DISCONNECTED) || event.getEvent().equalsIgnoreCase(EVENT_BRICK_CONNECTED)) {
        // get brick
        GlusterStatus status = event.getEvent().equalsIgnoreCase(EVENT_BRICK_DISCONNECTED) ? GlusterStatus.DOWN : GlusterStatus.UP;
        String path = (String) event.getMessage().get(BRICK);
        String peer = (String) event.getMessage().get(PEER);
        List<VdsStatic> vdsList = vdsStaticDao.getAllForCluster(host.getClusterId());
        VdsStatic vds = vdsList.stream().filter(v -> v.getName().equals(peer) || interfaceDao.getAllInterfacesForVds(v.getId()).stream().anyMatch(iface -> iface.getIpv4Address().equals(peer))).findFirst().orElse(null);
        GlusterBrickEntity brick = vds != null ? glusterBrickDao.getBrickByServerIdAndDirectory(vds.getId(), path) : null;
        if (brick != null) {
            glusterBrickDao.updateBrickStatus(brick.getId(), status);
            logBrickStatusChange(vol, status, brick);
        } else {
            // call sync to force updation
            log.debug("Forcing sync as brick event '{}' received that could not be resolved to brick", event);
            backend.runInternalAction(ActionType.RefreshGlusterVolumeDetails, new GlusterVolumeParameters(vol.getId()));
        }
    }
}
#end_block

#method_before
private void logBrickStatusChange(GlusterVolumeEntity vol, GlusterStatus status, GlusterBrickEntity brick) {
    logUtil.logAuditMessage(vol.getClusterId(), vol, null, AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, new HashMap<String, String>() {

        {
            put(GlusterConstants.BRICK_PATH, brick.getQualifiedName());
            put(GlusterConstants.OPTION_OLD_VALUE, brick.getStatus().toString());
            put(GlusterConstants.OPTION_NEW_VALUE, status.toString());
            put("source", "gluster event");
        }
    });
}
#method_after
private void logBrickStatusChange(GlusterVolumeEntity vol, GlusterStatus status, GlusterBrickEntity brick) {
    Map<String, String> customValues = new HashMap<>();
    customValues.put(GlusterConstants.BRICK_PATH, brick.getQualifiedName());
    customValues.put(GlusterConstants.OPTION_OLD_VALUE, brick.getStatus().toString());
    customValues.put(GlusterConstants.OPTION_NEW_VALUE, status.toString());
    customValues.put(GlusterConstants.SOURCE, GlusterConstants.SOURCE_EVENT);
    logUtil.logAuditMessage(vol.getClusterId(), vol.getClusterName(), vol, null, AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, customValues);
}
#end_block

#method_before
public boolean initGlusterHost(VDS vds) {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterHostUUID, new VdsIdVDSCommandParametersBase(vds.getId()));
    if (returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
        Guid addedServerUuid = Guid.createGuidFromString((String) returnValue.getReturnValue());
        if (hostUuidExists(vds, addedServerUuid)) {
            setNonOperational(vds, NonOperationalReason.GLUSTER_HOST_UUID_ALREADY_EXISTS, null);
            return false;
        }
        saveGlusterHostUuid(vds, addedServerUuid);
    } else {
        setNonOperational(vds, NonOperationalReason.GLUSTER_HOST_UUID_NOT_FOUND, null);
        return false;
    }
    refreshGlusterStorageDevices(vds);
    boolean ret = initGlusterPeerProcess(vds);
    glusterServerDao.updatePeerStatus(vds.getId(), ret == true ? PeerStatus.CONNECTED : PeerStatus.DISCONNECTED);
    // add webhook on cluster if eventing is supported
    addGlusterWebhook(vds);
    return ret;
}
#method_after
public boolean initGlusterHost(VDS vds) {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterHostUUID, new VdsIdVDSCommandParametersBase(vds.getId()));
    if (returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
        Guid addedServerUuid = Guid.createGuidFromString((String) returnValue.getReturnValue());
        if (hostUuidExists(vds, addedServerUuid)) {
            setNonOperational(vds, NonOperationalReason.GLUSTER_HOST_UUID_ALREADY_EXISTS, null);
            return false;
        }
        saveGlusterHostUuid(vds, addedServerUuid);
    } else {
        setNonOperational(vds, NonOperationalReason.GLUSTER_HOST_UUID_NOT_FOUND, null);
        return false;
    }
    refreshGlusterStorageDevices(vds);
    boolean ret = initGlusterPeerProcess(vds);
    glusterServerDao.updatePeerStatus(vds.getId(), ret ? PeerStatus.CONNECTED : PeerStatus.DISCONNECTED);
    // add webhook on cluster if eventing is supported
    if (ret) {
        addGlusterWebhook(vds);
    }
    return ret;
}
#end_block

#method_before
private void refreshGlusterStorageDevices(VDS vds) {
    try {
        backend.runInternalAction(VdcActionType.SyncStorageDevices, new SyncGlusterStorageDevicesParameter(vds.getId(), true));
    } catch (EngineException e) {
        log.error("Could not refresh storage devices from gluster host '{}'", vds.getName());
    }
}
#method_after
private void refreshGlusterStorageDevices(VDS vds) {
    try {
        backend.runInternalAction(ActionType.SyncStorageDevices, new SyncGlusterStorageDevicesParameter(vds.getId(), true));
    } catch (EngineException e) {
        log.error("Could not refresh storage devices from gluster host '{}'", vds.getName());
    }
}
#end_block

#method_before
private void addGlusterWebhook(VDS vds) {
    try {
        backend.runInternalAction(VdcActionType.AddGlusterWebhookInternal, new GlusterClusterParameters(vds.getClusterId()));
    } catch (EngineException e) {
        log.error("Could not refresh storage devices from gluster host '{}'", vds.getName());
    }
}
#method_after
private void addGlusterWebhook(VDS vds) {
    try {
        backend.runInternalAction(ActionType.AddGlusterWebhookInternal, new VdsActionParameters(vds.getId()));
    } catch (RuntimeException e) {
        log.error("Could not add gluster webhook for gluster host '{}'", vds.getName());
        log.debug("Exception", e);
    }
}
#end_block

#method_before
private boolean initGlusterPeerProcess(VDS vds) {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(vds.getClusterId())) {
        Map<String, String> customLogValues = new HashMap<>();
        List<VDS> vdsList = vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS existingVds : vdsList) {
                if (!vds.getId().equals(existingVds.getId())) {
                    upServer = existingVds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(vds, NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!getGlusterUtil().isHostExists(glusterServers, vds)) {
                    if (!glusterPeerProbe(vds, upServer.getId(), vds.getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + vds.getHostName());
                        setNonOperational(vds, NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < getMaxRetriesGlusterProbeStatus()) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(vds, upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!getGlusterUtil().isHostExists(newGlusterServers, vds)) {
                            log.info("Failed to find host '{}' in gluster peer list from '{}' on attempt {}", vds, newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == getMaxRetriesGlusterProbeStatus()) {
                                customLogValues.put("Command", "gluster peer status " + vds.getHostName());
                                setNonOperational(vds, NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#method_after
private boolean initGlusterPeerProcess(VDS vds) {
    // condition.
    try (EngineLock lock = glusterUtil.acquireGlusterLockWait(vds.getClusterId())) {
        Map<String, String> customLogValues = new HashMap<>();
        List<VDS> vdsList = vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS existingVds : vdsList) {
                if (!vds.getId().equals(existingVds.getId())) {
                    upServer = existingVds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer);
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(vds, NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!glusterUtil.isHostExists(glusterServers, vds)) {
                    if (!glusterPeerProbe(vds, upServer.getId(), vds.getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + vds.getHostName());
                        setNonOperational(vds, NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < getMaxRetriesGlusterProbeStatus()) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(vds, upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer);
                        if (!glusterUtil.isHostExists(newGlusterServers, vds)) {
                            log.info("Failed to find host '{}' in gluster peer list from '{}' on attempt {}", vds, newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == getMaxRetriesGlusterProbeStatus()) {
                                customLogValues.put("Command", "gluster peer status " + vds.getHostName());
                                setNonOperational(vds, NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#end_block

#method_before
private void saveGlusterHostUuid(VDS vds, Guid addedServerUuid) {
    GlusterServer glusterServer = glusterServerDao.getByServerId(vds.getId());
    if (glusterServer == null) {
        glusterServer = new GlusterServer();
        glusterServer.setId(vds.getId());
        glusterServer.setGlusterServerUuid(addedServerUuid);
        glusterServer.setPeerStatus(PeerStatus.CONNECTED);
        glusterServerDao.save(glusterServer);
    }
}
#method_after
private void saveGlusterHostUuid(VDS vds, Guid addedServerUuid) {
    GlusterServer glusterServer = glusterServerDao.getByServerId(vds.getId());
    if (glusterServer == null) {
        glusterServer = new GlusterServer();
        glusterServer.setId(vds.getId());
        glusterServer.setGlusterServerUuid(addedServerUuid);
        glusterServer.setPeerStatus(PeerStatus.CONNECTED);
        glusterServerDao.save(glusterServer);
    } else if (!glusterServer.getGlusterServerUuid().equals(addedServerUuid)) {
        // it's possible that the server is re-installed and gluster uuid has changed,
        // update this in the database.
        glusterServer.setGlusterServerUuid(addedServerUuid);
        glusterServerDao.update(glusterServer);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private List<GlusterServerInfo> getGlusterPeers(Guid upServerId) {
    List<GlusterServerInfo> glusterServers = new ArrayList<>();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServerId));
    if (!returnValue.getSucceeded()) {
        AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(upServerId));
        logable.addCustomValue("ErrorMessage", returnValue.getVdsError().getMessage());
        logable.updateCallStackFromThrowable(returnValue.getExceptionObject());
        auditLogDirector.log(logable, AuditLogType.GLUSTER_SERVERS_LIST_FAILED);
    } else {
        glusterServers = (List<GlusterServerInfo>) returnValue.getReturnValue();
    }
    return glusterServers;
}
#method_after
@SuppressWarnings("unchecked")
private List<GlusterServerInfo> getGlusterPeers(VDS upServer) {
    List<GlusterServerInfo> glusterServers = new ArrayList<>();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServer.getId()));
    if (!returnValue.getSucceeded()) {
        AuditLogable logable = GlusterEventFactory.createEvent(upServer, returnValue);
        auditLogDirector.log(logable, AuditLogType.GLUSTER_SERVERS_LIST_FAILED);
    } else {
        glusterServers = (List<GlusterServerInfo>) returnValue.getReturnValue();
    }
    return glusterServers;
}
#end_block

#method_before
private boolean glusterPeerProbe(VDS vds, Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vds.getId()));
            logable.addCustomValue("ErrorMessage", returnValue.getVdsError().getMessage());
            logable.updateCallStackFromThrowable(returnValue.getExceptionObject());
            auditLogDirector.log(logable, AuditLogType.GLUSTER_SERVER_ADD_FAILED);
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.error("Could not peer probe the gluster server '{}': {}", vds.getHostName(), e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#method_after
private boolean glusterPeerProbe(VDS vds, Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            AuditLogable logable = GlusterEventFactory.createEvent(vds, returnValue);
            auditLogDirector.log(logable, AuditLogType.GLUSTER_SERVER_ADD_FAILED);
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.error("Could not peer probe the gluster server '{}': {}", vds.getHostName(), e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid vdsId = getParameters().getId();
    VDS vds = vdsDao.get(vdsId);
    if (vds != null && FeatureSupported.isLlldpInformationSupported(vds.getClusterCompatibilityVersion())) {
        String[] names = new String[0];
        GetLldpVDSCommandParameters lldpVDSCommandParameters = new GetLldpVDSCommandParameters(vdsId, names);
        VDSReturnValue command = runVdsCommand(VDSCommandType.GetLldp, lldpVDSCommandParameters);
        getQueryReturnValue().setReturnValue(command.getReturnValue());
    } else {
        getQueryReturnValue().setReturnValue(createEmptyResponse());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    String[] names = new String[0];
    setLldpVDSCommandParameters(new GetLldpVDSCommandParameters(getHostId(), names));
    super.executeQueryCommand();
}
#end_block

#method_before
private void setup(ExpectedError expectedError) {
    Guid validGuid = Guid.newGuid();
    VDS validVds = new VDS();
    validVds.setId(validGuid);
    if (expectedError == ExpectedError.NOT_SUPPORTED) {
        validVds.setClusterCompatibilityVersion(Version.v4_1);
    } else {
        validVds.setClusterCompatibilityVersion(Version.v4_2);
    }
    VdsNetworkInterface eth0 = new VdsNetworkInterface();
    eth0.setName(vdsInterfacesNames[0]);
    VdsNetworkInterface eth1 = new VdsNetworkInterface();
    eth1.setName(vdsInterfacesNames[1]);
    when(getQueryParameters().getId()).thenReturn(validGuid);
    when(vdsDao.get(eq(validGuid))).thenReturn(validVds);
    when(interfaceDao.getAllInterfacesForVds(eq(validGuid))).thenReturn(Arrays.asList(eth0, eth1));
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    returnValue.setReturnValue(creatLldpInfoMap(expectedError != ExpectedError.LLDP_ENABLE));
    when(vdsBrokerFrontendMocked.runVdsCommand(eq(VDSCommandType.GetLldp), any())).thenReturn(returnValue);
}
#method_after
private void setup(ExpectedError expectedError) {
    Guid validGuid = Guid.newGuid();
    VDS validVds = new VDS();
    validVds.setId(validGuid);
    if (expectedError == ExpectedError.NOT_SUPPORTED) {
        validVds.setClusterCompatibilityVersion(Version.v4_1);
    } else {
        validVds.setClusterCompatibilityVersion(Version.v4_2);
    }
    when(getQueryParameters().getId()).thenReturn(validGuid);
    when(vdsDao.get(eq(validGuid))).thenReturn(validVds);
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    returnValue.setReturnValue(creatLldpInfoMap(expectedError != ExpectedError.LLDP_ENABLE));
    when(vdsBrokerFrontendMocked.runVdsCommand(eq(VDSCommandType.GetLldp), any())).thenReturn(returnValue);
}
#end_block

#method_before
@Test
public void testExecuteQueryNotSupported() {
    setup(ExpectedError.NOT_SUPPORTED);
    getQuery().executeQueryCommand();
    Map<String, LldpInfo> returnValue = getQuery().getQueryReturnValue().getReturnValue();
    assertTrue(checkEmptyValuesForIfaces(returnValue));
}
#method_after
@Test
public void testExecuteQueryNotSupported() {
    setup(ExpectedError.NOT_SUPPORTED);
    getQuery().executeQueryCommand();
    Map<String, LldpInfo> returnValue = getQuery().getQueryReturnValue().getReturnValue();
    assertEquals(returnValue, null);
}
#end_block

#method_before
@PostConstruct
private void init() {
    hypervEnabled = osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion());
    cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    writer = new XmlTextWriter();
    qosCache = new HashMap<>();
}
#method_after
@PostConstruct
private void init() {
    payloadIndex = -1;
    cdRomIndex = -1;
    vnicMetadata = new HashMap<>();
    diskMetadata = new HashMap<>();
    hypervEnabled = osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion());
    cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    writer = new XmlTextWriter();
    qosCache = new HashMap<>();
}
#end_block

#method_before
private Map<String, Object> createDiskUuidsMap(DiskImage diskImage) {
    Map<String, Object> diskUuids = new HashMap<>();
    diskUuids.put("poolID", diskImage.getStoragePoolId());
    diskUuids.put("domainID", diskImage.getStorageIds().get(0));
    diskUuids.put("imageID", diskImage.getId());
    diskUuids.put("volumeID", diskImage.getImageId());
    return diskUuids;
}
#method_after
private Map<String, Object> createDiskUuidsMap(DiskImage diskImage) {
    return createDiskUuidsMap(diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId());
}
#end_block

#method_before
private Map<String, Object> createDiskUuidsMap(DiskImage diskImage) {
    Map<String, Object> diskUuids = new HashMap<>();
    diskUuids.put("poolID", diskImage.getStoragePoolId());
    diskUuids.put("domainID", diskImage.getStorageIds().get(0));
    diskUuids.put("imageID", diskImage.getId());
    diskUuids.put("volumeID", diskImage.getImageId());
    return diskUuids;
}
#method_after
private Map<String, Object> createDiskUuidsMap(Guid poolId, Guid domainId, Guid imageId, Guid volumeId) {
    Map<String, Object> diskUuids = new HashMap<>();
    diskUuids.put("poolID", poolId);
    diskUuids.put("domainID", domainId);
    diskUuids.put("imageID", imageId);
    diskUuids.put("volumeID", volumeId);
    return diskUuids;
}
#end_block

#method_before
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw' error_policy='report' />
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        String name = vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex);
        writer.writeAttributeString("dev", name);
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        payloadMetadata = new Pair<>(name, new VmPayload(device));
        writer.writeEndElement();
    });
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath()))) {
        // add a device that points to vm.getCdPath()
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        boolean isIsoOnBlockDomain = false;
        if (vm.getIsoPath() != null && vm.getIsoPath().matches(ValidationUtils.GUID)) {
            BaseDisk disk = diskDao.get(Guid.createGuidFromString(vm.getIsoPath()));
            if (disk != null) {
                DiskImage isoImage = (DiskImage) disk;
                isIsoOnBlockDomain = isoImage.getStorageTypes().get(0).isBlockDomain();
                String dev = vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex);
                diskMetadata.put(dev, createDiskUuidsMap(isoImage));
            }
        }
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", isIsoOnBlockDomain ? "block" : "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString(isIsoOnBlockDomain ? "dev" : "file", vm.getCdPath());
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#method_after
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom' snapshot='no'>
    // <driver name='qemu' type='raw' error_policy='report' />
    // <source file='<path>' startupPolicy='optional'/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        payloadIndex = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        String name = vmInfoBuildUtils.makeDiskName(cdInterface, payloadIndex);
        writer.writeAttributeString("dev", name);
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        payloadMetadata = new Pair<>(name, new VmPayload(device));
        writer.writeEndElement();
    });
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath()))) {
        // add a device that points to vm.getCdPath()
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        boolean isoOnBlockDomain = false;
        if (vm.getIsoPath() != null && vm.getIsoPath().matches(ValidationUtils.GUID) && vmInfoBuildUtils.isBlockDomainPath(vm.getCdPath())) {
            isoOnBlockDomain = true;
            String dev = vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex);
            Matcher m = Pattern.compile(ValidationUtils.GUID).matcher(vm.getCdPath());
            m.find();
            Guid domainId = Guid.createGuidFromString(m.group());
            m.find();
            Guid imageId = Guid.createGuidFromString(m.group());
            m.find();
            Guid volumeId = Guid.createGuidFromString(m.group());
            diskMetadata.put(dev, createDiskUuidsMap(vm.getStoragePoolId(), domainId, imageId, volumeId));
        }
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", isoOnBlockDomain ? "block" : "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("driver");
        writer.writeAttributeString("name", "qemu");
        writer.writeAttributeString("type", "raw");
        writer.writeAttributeString("error_policy", "report");
        writer.writeEndElement();
        writer.writeStartElement("source");
        writer.writeAttributeString(isoOnBlockDomain ? "dev" : "file", vm.getCdPath());
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNetworkInterface nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    Map<String, String> properties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    VnicProfile vnicProfile = vnicProfileDao.get(nic.getVnicProfileId());
    Network network = vnicProfile != null ? networkDao.get(vnicProfile.getNetworkId()) : null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            writer.writeAttributeString("type", ifaceType == VmInterfaceType.pv ? "virtio" : ifaceType.getInternalName());
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network != null ? network.getVdsmName() : "");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(nic.getNetworkName(), properties);
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (network != null && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach((key, value) -> writer.writeAttributeString(key, value));
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmNicFilterParameterDao.getAllForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (properties.containsKey("sndbuf")) {
        writer.writeStartElement("tune");
        writer.writeStartElement("sndbuf");
        writer.writeRaw(properties.get("sndbuf"));
        writer.writeEndElement();
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    Map<String, String> properties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    VnicProfile vnicProfile = vnicProfileDao.get(nic.getVnicProfileId());
    Network network = vnicProfile != null ? networkDao.get(vnicProfile.getNetworkId()) : null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            writer.writeAttributeString("type", ifaceType == VmInterfaceType.pv ? "virtio" : ifaceType.getInternalName());
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", network != null ? network.getVdsmName() : "");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(network != null ? network.getName() : "", properties);
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (network != null && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmNicFilterParameterDao.getAllForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    if (properties.containsKey("sndbuf")) {
        writer.writeStartElement("tune");
        writer.writeStartElement("sndbuf");
        writer.writeRaw(properties.get("sndbuf"));
        writer.writeEndElement();
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeAddress(Map<String, String> addressMap) {
    if (!addressMap.isEmpty()) {
        writer.writeStartElement("address");
        addressMap.forEach((key, value) -> writer.writeAttributeString(key, value));
        writer.writeEndElement();
    }
}
#method_after
private void writeAddress(Map<String, String> addressMap) {
    if (!addressMap.isEmpty()) {
        writer.writeStartElement("address");
        addressMap.forEach(writer::writeAttributeString);
        writer.writeEndElement();
    }
}
#end_block

#method_before
protected void endVmCommand() {
    if (getVm() != null) {
        vmStaticDao.incrementDbGeneration(getVm().getId());
    }
    endActionOnDisks();
    unlockVm();
    setSucceeded(true);
}
#method_after
protected void endVmCommand() {
    endActionOnDisks();
    if (getVm() != null) {
        vmStaticDao.incrementDbGeneration(getVm().getId());
    }
    unlockVm();
    setSucceeded(true);
}
#end_block

#method_before
protected boolean removeVmLease(Guid leaseStorageDomainId, Guid vmId) {
    if (leaseStorageDomainId == null) {
        return true;
    }
    return runInternalActionWithTasksContext(ActionType.RemoveVmLease, new VmLeaseParameters(getStoragePoolId(), leaseStorageDomainId, vmId)).getSucceeded();
}
#method_after
protected boolean removeVmLease(Guid leaseStorageDomainId, Guid vmId) {
    if (leaseStorageDomainId == null) {
        return true;
    }
    VmLeaseParameters params = new VmLeaseParameters(getStoragePoolId(), leaseStorageDomainId, vmId);
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    ActionReturnValue returnValue = runInternalActionWithTasksContext(ActionType.RemoveVmLease, params);
    if (returnValue.getSucceeded()) {
        getTaskIdList().addAll(returnValue.getInternalVdsmTaskIdList());
    }
    return returnValue.getSucceeded();
}
#end_block

#method_before
protected boolean addVmLease(Guid leaseStorageDomainId, Guid vmId) {
    if (leaseStorageDomainId == null) {
        return true;
    }
    return runInternalActionWithTasksContext(ActionType.AddVmLease, new VmLeaseParameters(getStoragePoolId(), leaseStorageDomainId, vmId)).getSucceeded();
}
#method_after
protected boolean addVmLease(Guid leaseStorageDomainId, Guid vmId, boolean hotPlugLease) {
    if (leaseStorageDomainId == null) {
        return true;
    }
    VmLeaseParameters params = new VmLeaseParameters(getStoragePoolId(), leaseStorageDomainId, vmId);
    if (hotPlugLease) {
        params.setVdsId(getVm().getRunOnVds());
        params.setHotPlugLease(true);
    }
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    ActionReturnValue returnValue = runInternalActionWithTasksContext(ActionType.AddVmLease, params);
    if (returnValue.getSucceeded()) {
        getTaskIdList().addAll(returnValue.getInternalVdsmTaskIdList());
    }
    return returnValue.getSucceeded();
}
#end_block

#method_before
public ValidationResult diskImagesSnapshotsAttachedToVm(Guid vmId) {
    LinkedList<String> diskSnapshotInfo = new LinkedList<>();
    VM vm = getVmDao().get(vmId);
    for (DiskImage diskImage : diskImages) {
        List<VmDevice> devices = getVmDeviceDao().getVmDevicesByDeviceId(diskImage.getId(), vmId);
        if (devices.isEmpty()) {
            Snapshot snapshot = getSnapshotDao().get(diskImage.getSnapshotId());
            Disk disk = getDbFacade().getDiskDao().get(diskImage.getId());
            diskSnapshotInfo.add(String.format("%s ,%s", disk.getDiskAlias(), snapshot.getDescription()));
        }
    }
    if (!diskSnapshotInfo.isEmpty()) {
        EngineMessage message = EngineMessage.ACTION_TYPE_FAILED_VM_DISK_SNAPSHOT_NOT_ATTACHED_TO_VM;
        return new ValidationResult(message, String.format("$disksInfo %s", String.format(StringUtils.join(diskSnapshotInfo, "%n"))), String.format("$vmName %s", vm.getName()));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult diskImagesSnapshotsAttachedToVm(Guid vmId) {
    LinkedList<String> diskSnapshotInfo = new LinkedList<>();
    VM vm = getVmDao().get(vmId);
    for (DiskImage diskImage : diskImages) {
        List<VmDevice> devices = getVmDeviceDao().getVmDevicesByDeviceId(diskImage.getId(), vmId);
        if (devices.isEmpty()) {
            // The specified disk image does not belong to the vm
            Snapshot snapshot = getSnapshotDao().get(diskImage.getSnapshotId());
            Disk disk = getDbFacade().getDiskDao().get(diskImage.getId());
            diskSnapshotInfo.add(String.format("%s ,%s", disk.getDiskAlias(), snapshot.getDescription()));
        }
    }
    if (!diskSnapshotInfo.isEmpty()) {
        EngineMessage message = EngineMessage.ACTION_TYPE_FAILED_VM_DISK_SNAPSHOT_NOT_ATTACHED_TO_VM;
        return new ValidationResult(message, String.format("$disksInfo %s", String.format(StringUtils.join(diskSnapshotInfo, "%n"))), String.format("$vmName %s", vm.getName()));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult supportedFirewallTypeForClusterVersion() {
    return ValidationResult.failWith(EngineMessage.UNSUPPORTED_FIREWALL_TYPE_FOR_CLUSTER_VERSION).when(cluster.getCompatibilityVersion().equals(Version.v3_6) && (cluster.getFirewallType() != null && cluster.getFirewallType() == FirewallType.FIREWALLD));
}
#method_after
public ValidationResult supportedFirewallTypeForClusterVersion() {
    return ValidationResult.failWith(EngineMessage.UNSUPPORTED_FIREWALL_TYPE_FOR_CLUSTER_VERSION, ReplacementUtils.createSetVariableString("clusterVersion", cluster.getCompatibilityVersion()), ReplacementUtils.createSetVariableString("firewallType", cluster.getFirewallType())).when(cluster.getCompatibilityVersion().lessOrEquals(Version.v3_6) && FirewallType.FIREWALLD.equals(cluster.getFirewallType()));
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
            setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY, false);
        } else {
            internalEndWithFailure();
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE, false);
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        if (TransactionSupport.current() == null) {
            try {
                getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean useCompensation = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
            setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY, false);
        } else {
            internalEndWithFailure();
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE, false);
            if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) {
                useCompensation = true;
            }
        }
    } catch (RuntimeException e) {
        useCompensation = true;
        throw e;
    } finally {
        if (TransactionSupport.current() == null) {
            try {
                getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!useCompensation && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
private void internalEndSuccessfully() {
    log.info("Ending command '{}' successfully.", getClass().getName());
    endSuccessfully();
    if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) {
        getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
    }
}
#method_after
private void internalEndSuccessfully() {
    log.info("Ending command '{}' successfully.", getClass().getName());
    endSuccessfully();
}
#end_block

#method_before
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogable logable = new AuditLogableImpl();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            renameable.setEntityId(logable);
            auditLog(logable, AuditLogType.ENTITY_RENAMED);
        }
    }
}
#method_after
void logRenamedEntity() {
    if (this instanceof RenamedEntityInfoProvider) {
        RenamedEntityInfoProvider renameable = (RenamedEntityInfoProvider) this;
        String oldEntityName = renameable.getEntityOldName();
        String newEntityName = renameable.getEntityNewName();
        if (!StringUtils.equals(oldEntityName, newEntityName)) {
            // log entity rename details
            AuditLogable logable = new AuditLogableImpl();
            String entityType = renameable.getEntityType();
            logable.addCustomValue("EntityType", entityType);
            logable.addCustomValue("OldEntityName", oldEntityName);
            logable.addCustomValue("NewEntityName", newEntityName);
            if (getCurrentUser() != null) {
                logable.addCustomValue("UserName", getCurrentUser().getLoginName());
            }
            renameable.setEntityId(logable);
            auditLog(logable, getCurrentUser() != null ? AuditLogType.ENTITY_RENAMED : AuditLogType.ENTITY_RENAMED_INTERNALLY);
        }
    }
}
#end_block

#method_before
private void internalEndWithFailure() {
    log.error("Ending command '{}' with failure.", getClass().getName());
    endWithFailure();
    rollbackQuota();
    if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) {
        compensate();
    }
}
#method_after
private void internalEndWithFailure() {
    log.error("Ending command '{}' with failure.", getClass().getName());
    endWithFailure();
    rollbackQuota();
}
#end_block

#method_before
protected void endVmCommand() {
    if (getVm() != null) {
        vmStaticDao.incrementDbGeneration(getVm().getId());
    }
    endActionOnDisks();
    unlockVm();
    setSucceeded(true);
}
#method_after
protected void endVmCommand() {
    endActionOnDisks();
    if (getVm() != null) {
        vmStaticDao.incrementDbGeneration(getVm().getId());
    }
    unlockVm();
    setSucceeded(true);
}
#end_block

#method_before
protected boolean removeVmLease(Guid leaseStorageDomainId, Guid vmId, String vmName) {
    if (leaseStorageDomainId == null) {
        return true;
    }
    ActionReturnValue returnValue = runInternalActionWithTasksContext(ActionType.RemoveVmLease, new VmLeaseParameters(getStoragePoolId(), leaseStorageDomainId, vmId, vmName), getLock());
    if (returnValue.getSucceeded()) {
        getTaskIdList().addAll(returnValue.getVdsmTaskIdList());
    }
    return returnValue.getSucceeded();
}
#method_after
protected boolean removeVmLease(Guid leaseStorageDomainId, Guid vmId) {
    if (leaseStorageDomainId == null) {
        return true;
    }
    VmLeaseParameters params = new VmLeaseParameters(getStoragePoolId(), leaseStorageDomainId, vmId);
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    ActionReturnValue returnValue = runInternalActionWithTasksContext(ActionType.RemoveVmLease, params);
    if (returnValue.getSucceeded()) {
        getTaskIdList().addAll(returnValue.getInternalVdsmTaskIdList());
    }
    return returnValue.getSucceeded();
}
#end_block

#method_before
protected boolean addVmLease(Guid leaseStorageDomainId, Guid vmId, String vmName) {
    if (leaseStorageDomainId == null) {
        return true;
    }
    ActionReturnValue returnValue = runInternalActionWithTasksContext(ActionType.AddVmLease, new VmLeaseParameters(getStoragePoolId(), leaseStorageDomainId, vmId, vmName), getLock());
    if (returnValue.getSucceeded()) {
        getTaskIdList().addAll(returnValue.getVdsmTaskIdList());
    }
    return returnValue.getSucceeded();
}
#method_after
protected boolean addVmLease(Guid leaseStorageDomainId, Guid vmId, boolean hotPlugLease) {
    if (leaseStorageDomainId == null) {
        return true;
    }
    VmLeaseParameters params = new VmLeaseParameters(getStoragePoolId(), leaseStorageDomainId, vmId);
    if (hotPlugLease) {
        params.setVdsId(getVm().getRunOnVds());
        params.setHotPlugLease(true);
    }
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    ActionReturnValue returnValue = runInternalActionWithTasksContext(ActionType.AddVmLease, params);
    if (returnValue.getSucceeded()) {
        getTaskIdList().addAll(returnValue.getInternalVdsmTaskIdList());
    }
    return returnValue.getSucceeded();
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    } else if (!updateVmLease()) {
        return;
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new TransactionCompletionListener() {

            @Override
            public void onSuccess() {
                ovfDataUpdater.triggerNow();
            }

            @Override
            public void onRollback() {
            // No notification is needed
            }
        });
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    iconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    newVmStatic.setLeaseInfo(oldVm.getStaticData().getLeaseInfo());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new TransactionCompletionListener() {

            @Override
            public void onSuccess() {
                ovfDataUpdater.triggerNow();
            }

            @Override
            public void onRollback() {
            // No notification is needed
            }
        });
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), oldVm.getStatus(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (!updateVmLease()) {
        return;
    }
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    iconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#end_block

#method_before
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    getVm().getStaticData().setLeaseInfo(null);
    if (getVm().isNotRunning()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), newVmStatic.getName())) {
            return false;
        }
    } else {
        if (oldVm.getLeaseStorageDomainId() == null) {
            VmLeaseParameters params = new VmLeaseParameters(getStoragePoolId(), newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId());
            params.setVdsId(getVm().getRunOnVds());
            params.setHotPlugLease(true);
            return runInternalAction(ActionType.AddVmLease, params).getSucceeded();
        }
        boolean hotUnplugSucceeded = false;
        try {
            hotUnplugSucceeded = runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot unplugging a lease to VM {}, message: {}", oldVm.getId(), e.getMessage());
        }
        if (!hotUnplugSucceeded) {
            auditLog(this, AuditLogType.HOT_UNPLUG_LEASE_FAILED);
        }
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId(), oldVm.getName());
    return true;
}
#method_after
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    getVm().getStaticData().setLeaseInfo(null);
    if (getVm().isNotRunning()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), false)) {
            return false;
        }
    } else if (isHotSetEnabled()) {
        if (oldVm.getLeaseStorageDomainId() == null) {
            return addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), true);
        }
        boolean hotUnplugSucceeded = false;
        try {
            hotUnplugSucceeded = runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot unplugging a lease to VM {}, message: {}", oldVm.getId(), e.getMessage());
        }
        if (!hotUnplugSucceeded) {
            auditLog(this, AuditLogType.HOT_UNPLUG_LEASE_FAILED);
        }
    }
    // In case of remove lease only, VM lease info should set to null
    if (oldVm.getLeaseStorageDomainId() != null && newVmStatic.getLeaseStorageDomainId() == null) {
        newVmStatic.setLeaseInfo(null);
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration()) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration()) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (vmFromDB.getMemSizeMb() != vmFromParams.getMemSizeMb() && vmFromDB.isRunning() && isHotSetEnabled() && HugePageUtils.isBackedByHugepages(vmFromDB.getStaticData()) && (vmFromDB.getMemSizeMb() < vmFromParams.getMemSizeMb() || (vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && getParameters().isMemoryHotUnplugEnabled()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_SET_NOT_SUPPORTED_FOR_HUGE_PAGES);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    if (!canAddVm(destStorages.values())) {
        log.error("Failed to add VM. The reasons are: {}", String.join(",", getReturnValue().getValidationMessages()));
        return;
    }
    if (!addVmLease(getParameters().getVm().getLeaseStorageDomainId(), getVmId(), getParameters().getVm().getName())) {
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmNetwork();
        addVmNumaNodes();
        addVmStatistics();
        addActiveSnapshot();
        addVmPermission();
        addVmInit();
        addVmRngDevice();
        addAffinityLabels();
        getCompensationContext().stateChanged();
        return null;
    });
    if (addVmImages()) {
        TransactionSupport.executeInNewTransaction(() -> {
            copyDiskVmElements();
            copyVmDevices();
            addDiskPermissions();
            addVmPayload();
            updateSmartCardDevices();
            addVmWatchdog();
            addGraphicsDevice();
            getVmDeviceUtils().updateVirtioScsiController(getVm().getStaticData(), getParameters().isVirtioScsiEnabled());
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
            return null;
        });
    }
    if (getParameters().getPoolId() != null) {
        addVmToPool();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmId());
}
#method_after
@Override
protected void executeVmCommand() {
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    if (!canAddVm(destStorages.values())) {
        log.error("Failed to add VM. The reasons are: {}", String.join(",", getReturnValue().getValidationMessages()));
        return;
    }
    if (!addVmLease(getParameters().getVm().getLeaseStorageDomainId(), getVmId(), false)) {
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmNetwork();
        addVmNumaNodes();
        addVmStatistics();
        addActiveSnapshot();
        addVmPermission();
        addVmInit();
        addVmRngDevice();
        addAffinityLabels();
        getCompensationContext().stateChanged();
        return null;
    });
    if (addVmImages()) {
        TransactionSupport.executeInNewTransaction(() -> {
            copyDiskVmElements();
            copyVmDevices();
            addDiskPermissions();
            addVmPayload();
            updateSmartCardDevices();
            addVmWatchdog();
            addGraphicsDevice();
            getVmDeviceUtils().updateVirtioScsiController(getVm().getStaticData(), getParameters().isVirtioScsiEnabled());
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
            return null;
        });
    }
    if (getParameters().getPoolId() != null) {
        addVmToPool();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmId());
}
#end_block

#method_before
private void addVmInit() {
    final VmInit vmInit = getParameters().getVmStaticData().getVmInit();
    if (vmInit == null) {
        return;
    }
    if (vmInit.isPasswordAlreadyStored()) {
        final VmInit templateVmInit = vmInitDao.get(getVmTemplateId());
        vmInit.setPasswordAlreadyStored(false);
        vmInit.setRootPassword(templateVmInit.getRootPassword());
    }
    vmHandler.addVmInitToDB(vmInit);
}
#method_after
private void addVmInit() {
    final VmInit vmInit = getParameters().getVmStaticData().getVmInit();
    if (vmInit == null) {
        return;
    }
    if (vmInit.isPasswordAlreadyStored()) {
        final VmInit originalVmInit = loadOriginalVmInitWithRootPassword();
        if (originalVmInit != null) {
            vmInit.setPasswordAlreadyStored(false);
            vmInit.setRootPassword(originalVmInit.getRootPassword());
        }
    }
    vmHandler.addVmInitToDB(vmInit);
}
#end_block

#method_before
private List<EngineMessage> validateLunDisk(LunDisk lunDisk) {
    DiskValidator diskValidator = getDiskValidator(lunDisk);
    LUNs lun = lunDisk.getLun();
    StorageType storageType = StorageType.UNKNOWN;
    if (lun.getLunConnections() != null && !lun.getLunConnections().isEmpty()) {
        // We set the storage type based on the first connection since connections should be with the same
        // storage type
        storageType = lun.getLunConnections().get(0).getStorageType();
    }
    ValidationResult connectionsInLunResult = diskValidator.validateConnectionsInLun(storageType);
    if (!connectionsInLunResult.isValid()) {
        return connectionsInLunResult.getMessages();
    }
    ValidationResult lunAlreadyInUseResult = diskValidator.validateLunAlreadyInUse();
    if (!lunAlreadyInUseResult.isValid()) {
        return lunAlreadyInUseResult.getMessages();
    }
    DiskVmElementValidator diskVmElementValidator = new DiskVmElementValidator(lunDisk, lunDisk.getDiskVmElementForVm(getVmId()));
    ValidationResult virtIoScsiResult = isVirtIoScsiValid(getVm(), diskVmElementValidator);
    if (!virtIoScsiResult.isValid()) {
        return virtIoScsiResult.getMessages();
    }
    ValidationResult diskInterfaceResult = diskVmElementValidator.isDiskInterfaceSupported(getVm());
    if (!diskInterfaceResult.isValid()) {
        return diskInterfaceResult.getMessages();
    }
    Guid vdsId = vdsCommandsHelper.getHostForExecution(getStoragePoolId());
    GetDeviceListVDSCommandParameters parameters = new GetDeviceListVDSCommandParameters(vdsId, lun.getLunType(), false, Collections.singleton(lun.getLUNId()));
    if (validateLunExistsAndInitDeviceData(lun, parameters)) {
        return Arrays.asList(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
    }
    ValidationResult usingScsiReservationResult = diskValidator.isUsingScsiReservationValid(getVm(), lunDisk.getDiskVmElementForVm(getVmId()), lunDisk);
    if (!usingScsiReservationResult.isValid()) {
        return usingScsiReservationResult.getMessages();
    }
    return Collections.emptyList();
}
#method_after
private List<EngineMessage> validateLunDisk(LunDisk lunDisk) {
    DiskValidator diskValidator = getDiskValidator(lunDisk);
    LUNs lun = lunDisk.getLun();
    StorageType storageType;
    if (lun.getLunConnections() != null && !lun.getLunConnections().isEmpty()) {
        // We set the storage type based on the first connection since connections should be with the same
        // storage type
        storageType = lun.getLunConnections().get(0).getStorageType();
    } else {
        storageType = StorageType.FCP;
    }
    if (storageType == StorageType.ISCSI) {
        ValidationResult connectionsInLunResult = diskValidator.validateConnectionsInLun(storageType);
        if (!connectionsInLunResult.isValid()) {
            return connectionsInLunResult.getMessages();
        }
    }
    ValidationResult lunAlreadyInUseResult = diskValidator.validateLunAlreadyInUse();
    if (!lunAlreadyInUseResult.isValid()) {
        return lunAlreadyInUseResult.getMessages();
    }
    DiskVmElementValidator diskVmElementValidator = new DiskVmElementValidator(lunDisk, lunDisk.getDiskVmElementForVm(getVmId()));
    ValidationResult virtIoScsiResult = isVirtIoScsiValid(getVm(), diskVmElementValidator);
    if (!virtIoScsiResult.isValid()) {
        return virtIoScsiResult.getMessages();
    }
    ValidationResult diskInterfaceResult = diskVmElementValidator.isDiskInterfaceSupported(getVm());
    if (!diskInterfaceResult.isValid()) {
        return diskInterfaceResult.getMessages();
    }
    Guid vdsId = vdsCommandsHelper.getHostForExecution(getStoragePoolId());
    if (!validateLunExistsAndInitDeviceData(lun, storageType, vdsId)) {
        return Arrays.asList(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
    }
    ValidationResult usingScsiReservationResult = diskValidator.isUsingScsiReservationValid(getVm(), lunDisk.getDiskVmElementForVm(getVmId()), lunDisk);
    if (!usingScsiReservationResult.isValid()) {
        return usingScsiReservationResult.getMessages();
    }
    return Collections.emptyList();
}
#end_block

#method_before
private boolean validateLunExistsAndInitDeviceData(LUNs lun, GetDeviceListVDSCommandParameters parameters) {
    List<LUNs> lunFromStorage = (List<LUNs>) runVdsCommand(VDSCommandType.GetDeviceList, parameters).getReturnValue();
    if (lunFromStorage == null || lunFromStorage.isEmpty()) {
        return true;
    } else {
        LUNs luns = lunFromStorage.get(0);
        lun.setSerial(luns.getSerial());
        lun.setLunMapping(luns.getLunMapping());
        lun.setVendorId(luns.getVendorId());
        lun.setProductId(luns.getProductId());
        lun.setProductId(luns.getProductId());
        lun.setDiscardMaxSize(luns.getDiscardMaxSize());
        lun.setDiscardZeroesData(luns.getDiscardZeroesData());
        lun.setPvSize(luns.getPvSize());
    }
    return false;
}
#method_after
private boolean validateLunExistsAndInitDeviceData(LUNs lun, StorageType storageType, Guid vdsId) {
    List<LUNs> lunFromStorage = null;
    try {
        StorageServerConnectionManagementVDSParameters connectParams = new StorageServerConnectionManagementVDSParameters(vdsId, Guid.Empty, storageType, lun.getLunConnections());
        runVdsCommand(VDSCommandType.ConnectStorageServer, connectParams);
        GetDeviceListVDSCommandParameters parameters = new GetDeviceListVDSCommandParameters(vdsId, storageType, false, Collections.singleton(lun.getLUNId()));
        lunFromStorage = (List<LUNs>) runVdsCommand(VDSCommandType.GetDeviceList, parameters).getReturnValue();
    } catch (EngineException e) {
        log.debug("Exception while validating LUN disk: '{}'", e);
        return false;
    }
    if (lunFromStorage == null || lunFromStorage.isEmpty()) {
        return false;
    } else {
        LUNs luns = lunFromStorage.get(0);
        lun.setSerial(luns.getSerial());
        lun.setLunMapping(luns.getLunMapping());
        lun.setVendorId(luns.getVendorId());
        lun.setProductId(luns.getProductId());
        lun.setProductId(luns.getProductId());
        lun.setDiscardMaxSize(luns.getDiscardMaxSize());
        lun.setPvSize(luns.getPvSize());
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (getVm().isAutoStartup() && shouldAddLease(getVm().getStaticData())) {
        if (FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            if (validateLeaseStorageDomain(getVm().getLeaseStorageDomainId())) {
                if (!addVmLease(getVm().getLeaseStorageDomainId(), getVm().getId(), getVm().getName())) {
                    getVm().setLeaseStorageDomainId(null);
                }
            } else {
                getVm().setLeaseStorageDomainId(null);
                auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_STORAGE_DOMAIN);
            }
        } else {
            getVm().setLeaseStorageDomainId(null);
            auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_COMPAT_VERSION);
        }
    } else {
        getVm().setLeaseStorageDomainId(null);
    }
    super.executeVmCommand();
}
#method_after
@Override
protected void executeVmCommand() {
    if (getVm().isAutoStartup() && shouldAddLease(getVm().getStaticData())) {
        if (FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            if (validateLeaseStorageDomain(getVm().getLeaseStorageDomainId())) {
                if (!addVmLease(getVm().getLeaseStorageDomainId(), getVm().getId(), false)) {
                    getVm().setLeaseStorageDomainId(null);
                }
            } else {
                getVm().setLeaseStorageDomainId(null);
                auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_STORAGE_DOMAIN);
            }
        } else {
            getVm().setLeaseStorageDomainId(null);
            auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_COMPAT_VERSION);
        }
    } else {
        getVm().setLeaseStorageDomainId(null);
    }
    super.executeVmCommand();
}
#end_block

#method_before
private void processImages(final boolean useCopyImages) {
    TransactionSupport.executeInNewTransaction(() -> {
        addVmImagesAndSnapshots();
        addVmExternalLuns();
        addMemoryImages();
        updateSnapshotsFromExport();
        if (useCopyImages) {
            moveOrCopyAllImageGroups();
        }
        getVmDeviceUtils().addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity(), false);
        if (getParameters().isImportAsNewEntity()) {
            getParameters().setVm(getVm());
            setVmId(getVm().getId());
        }
        return null;
    });
}
#method_after
private void processImages(final boolean useCopyImages) {
    TransactionSupport.executeInNewTransaction(() -> {
        addVmImagesAndSnapshots();
        addVmExternalLuns();
        addMemoryImages();
        updateSnapshotsFromExport();
        if (useCopyImages) {
            moveOrCopyAllImageGroups();
        }
        getVmDeviceUtils().addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity(), false);
        if (getParameters().isImportAsNewEntity()) {
            getParameters().setVm(getVm());
            setVmId(getVm().getId());
        }
        vmStaticDao.incrementDbGeneration(getVmId());
        return null;
    });
}
#end_block

#method_before
protected void endActionOnAllImageGroups() {
    for (ActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(ActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#method_after
protected void endActionOnAllImageGroups() {
    for (ActionParametersBase p : getParameters().getImagesParameters()) {
        if (p instanceof MoveOrCopyImageGroupParameters) {
            p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
            getBackend().endAction(ActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VmLeaseVDSParameters params = new VmLeaseVDSParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getVmId());
    VDSReturnValue returnValue = runVdsCommand(getLeaseAction(), params);
    if (returnValue.getSucceeded()) {
        getTaskIdList().add(createTask(taskId, returnValue.getCreationInfo(), getActionType(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
    }
    setSucceeded(returnValue.getSucceeded());
}
#method_after
@Override
protected void executeCommand() {
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VmLeaseVDSParameters params = new VmLeaseVDSParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getVmId());
    VDSReturnValue returnValue = runVdsCommand(getLeaseAction(), params);
    if (returnValue.getSucceeded()) {
        getTaskIdList().add(createTask(taskId, returnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
    }
    setSucceeded(returnValue.getSucceeded());
}
#end_block

#method_before
@Override
public void edit(final IscsiStorageModel object) {
    driver.edit(object);
    initLists(object);
    // Add event handlers
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        String propName = args.propertyName;
        if (propName.equals("IsValid")) {
            // $NON-NLS-1$
            onIsValidPropertyChange(object);
        } else if (propName.equals("IsGrouppedByTarget")) {
            // $NON-NLS-1$
            updateListByGropping(object);
        }
    });
    // Edit sub-views
    iscsiTargetToLunView.edit(object);
    iscsiLunToTargetView.edit(object);
    // Add click handlers
    targetsToLunTab.addClickHandler(event -> {
        iscsiLunToTargetView.disableItemsUpdate();
        object.setIsGrouppedByTarget(true);
    });
    lunToTargetsTab.addClickHandler(event -> {
        iscsiTargetToLunView.disableItemsUpdate();
        object.setIsGrouppedByTarget(false);
    });
    // Update selected tab and list
    dialogTabPanel.switchTab(object.getIsGrouppedByTarget() ? targetsToLunTab : lunToTargetsTab);
    updateListByGropping(object);
    // Set labels above table
    if (!object.getContainer().isNewStorage()) {
        if (object.getContainer().getStorage().getStatus() == StorageDomainStatus.Maintenance) {
            mainLabel.setText(constants.storageIscsiRemoveLUNsLabel());
            subLabel.setText(constants.storageIscsiYouCanPerformActionsLabel());
        } else if (object.getContainer().getStorage().getStatus() == StorageDomainStatus.Active) {
            mainLabel.setText(constants.storageIscsiActionsLabel());
            subLabel.setText(constants.storageIscsiYouCanRemoveLUNsLabel());
        }
    }
}
#method_after
@Override
public void edit(final IscsiStorageModel object) {
    driver.edit(object);
    initLists(object);
    // Add event handlers
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        String propName = args.propertyName;
        if (propName.equals("IsValid")) {
            // $NON-NLS-1$
            onIsValidPropertyChange(object);
        } else if (propName.equals("IsGrouppedByTarget")) {
            // $NON-NLS-1$
            updateListByGropping(object);
        }
    });
    // Edit sub-views
    iscsiTargetToLunView.edit(object);
    iscsiLunToTargetView.edit(object);
    // Add click handlers
    targetsToLunTab.addClickHandler(event -> {
        iscsiLunToTargetView.disableItemsUpdate();
        object.setIsGrouppedByTarget(true);
    });
    lunToTargetsTab.addClickHandler(event -> {
        iscsiTargetToLunView.disableItemsUpdate();
        object.setIsGrouppedByTarget(false);
    });
    // Update selected tab and list
    dialogTabPanel.switchTab(object.getIsGrouppedByTarget() ? targetsToLunTab : lunToTargetsTab);
    updateListByGropping(object);
    // Set labels above table
    if (!object.getContainer().isNewStorage()) {
        switch(object.getContainer().getStorage().getStatus()) {
            case Maintenance:
                mainLabel.setText(constants.storageIscsiRemoveLUNsLabel());
                subLabel.setText(constants.storageIscsiAvailableActionsOnMaintenanceLabel());
                break;
            case Active:
                mainLabel.setText(constants.storageIscsiActionsLabel());
                subLabel.setText(constants.storageIscsiAvailableActionsForActiveDomainsLabel());
                break;
        }
    }
}
#end_block

#method_before
private void connectTargets() {
    VDS host = getContainer().getHost().getSelectedItem();
    if (host == null) {
        return;
    }
    ArrayList<ActionType> actionTypes = new ArrayList<>();
    ArrayList<ActionParametersBase> parameters = new ArrayList<>();
    ArrayList<IFrontendActionAsyncCallback> callbacks = new ArrayList<>();
    final SanStorageModelBase sanStorageModel = this;
    IFrontendActionAsyncCallback loginCallback = result -> sanStorageModel.postLogin(result.getReturnValue(), sanStorageModel);
    for (int i = 0; i < targetsToConnect.size(); i++) {
        SanTargetModel model = targetsToConnect.get(i);
        StorageServerConnections connection = new StorageServerConnections();
        connection.setStorageType(StorageType.ISCSI);
        // $NON-NLS-1$
        connection.setUserName(getUseUserAuth().getEntity() ? getUserName().getEntity() : "");
        // $NON-NLS-1$
        connection.setPassword(getUseUserAuth().getEntity() ? getPassword().getEntity() : "");
        connection.setIqn(model.getName());
        connection.setConnection(model.getAddress());
        connection.setPort(String.valueOf(model.getPort()));
        actionTypes.add(ActionType.ConnectStorageToVds);
        parameters.add(new StorageServerConnectionParametersBase(connection, host.getId(), false));
        callbacks.add(loginCallback);
    }
    Object target = getWidgetModel() != null ? getWidgetModel() : getContainer();
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, callbacks, null, target);
}
#method_after
private void connectTargets() {
    VDS host = getContainer().getHost().getSelectedItem();
    if (host == null) {
        return;
    }
    ArrayList<ActionType> actionTypes = new ArrayList<>();
    ArrayList<ActionParametersBase> parameters = new ArrayList<>();
    ArrayList<IFrontendActionAsyncCallback> callbacks = new ArrayList<>();
    final SanStorageModelBase sanStorageModel = this;
    IFrontendActionAsyncCallback loginCallback = result -> sanStorageModel.postLogin(result.getReturnValue(), sanStorageModel);
    for (int i = 0; i < targetsToConnect.size(); i++) {
        SanTargetModel model = targetsToConnect.get(i);
        StorageServerConnections connection = new StorageServerConnections();
        connection.setStorageType(StorageType.ISCSI);
        // $NON-NLS-1$
        connection.setUserName(getUseUserAuth().getEntity() ? getUserName().getEntity() : "");
        // $NON-NLS-1$
        connection.setPassword(getUseUserAuth().getEntity() ? getPassword().getEntity() : "");
        connection.setIqn(model.getName());
        connection.setConnection(model.getAddress());
        connection.setPort(String.valueOf(model.getPort()));
        connection.setPortal(model.getPortal());
        actionTypes.add(ActionType.ConnectStorageToVds);
        parameters.add(new StorageServerConnectionParametersBase(connection, host.getId(), false));
        callbacks.add(loginCallback);
    }
    Object target = getWidgetModel() != null ? getWidgetModel() : getContainer();
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, callbacks, null, target);
}
#end_block

#method_before
protected void postDiscoverTargetsInternal(ArrayList<StorageServerConnections> items) {
    ArrayList<SanTargetModel> newItems = new ArrayList<>();
    for (StorageServerConnections a : items) {
        SanTargetModel model = new SanTargetModel();
        model.setAddress(a.getConnection());
        model.setPort(a.getPort());
        model.setName(a.getIqn());
        model.setLuns(new ObservableCollection<>());
        model.getLoggedInEvent().addListener(this);
        newItems.add(model);
    }
    if (items.isEmpty()) {
        setMessage(ConstantsManager.getInstance().getConstants().noNewDevicesWereFoundMsg());
    }
    postDiscoverTargets(newItems);
}
#method_after
protected void postDiscoverTargetsInternal(ArrayList<StorageServerConnections> items) {
    ArrayList<SanTargetModel> newItems = new ArrayList<>();
    for (StorageServerConnections a : items) {
        SanTargetModel model = new SanTargetModel();
        model.setAddress(a.getConnection());
        model.setPort(a.getPort());
        model.setPortal(a.getPortal());
        model.setName(a.getIqn());
        model.setLuns(new ObservableCollection<>());
        model.getLoggedInEvent().addListener(this);
        newItems.add(model);
    }
    if (items.isEmpty()) {
        setMessage(ConstantsManager.getInstance().getConstants().noNewDevicesWereFoundMsg());
    }
    postDiscoverTargets(newItems);
}
#end_block

#method_before
private ArrayList<SanTargetModel> createTargetModelList(LUNs a) {
    ArrayList<SanTargetModel> targetModelList = new ArrayList<>();
    if (a.getLunConnections() != null) {
        for (StorageServerConnections b : a.getLunConnections()) {
            SanTargetModel model = new SanTargetModel();
            model.setAddress(b.getConnection());
            model.setPort(b.getPort());
            model.setName(b.getIqn());
            model.setIsSelected(true);
            model.setIsLoggedIn(true);
            model.setLuns(new ObservableCollection<>());
            model.getLoginCommand().setIsExecutionAllowed(false);
            targetModelList.add(model);
        }
    }
    return targetModelList;
}
#method_after
private ArrayList<SanTargetModel> createTargetModelList(LUNs a) {
    ArrayList<SanTargetModel> targetModelList = new ArrayList<>();
    if (a.getLunConnections() != null) {
        for (StorageServerConnections b : a.getLunConnections()) {
            SanTargetModel model = new SanTargetModel();
            model.setAddress(b.getConnection());
            model.setPort(b.getPort());
            model.setPortal(b.getPortal());
            model.setName(b.getIqn());
            model.setIsSelected(true);
            model.setIsLoggedIn(true);
            model.setLuns(new ObservableCollection<>());
            model.getLoginCommand().setIsExecutionAllowed(false);
            targetModelList.add(model);
        }
    }
    return targetModelList;
}
#end_block

#method_before
@Override
public final SafeHtml getValue(LunModel object) {
    // TODO this should use a cell to render, not return HTML itself
    ScrollableTextCell.CellTemplate template = GWT.create(ScrollableTextCell.CellTemplate.class);
    // $NON-NLS-1$
    String color = "";
    if (object != null) {
        if (!object.getIsIncluded() && (!object.getIsSelected() || object.getIsGrayedOut())) {
            // $NON-NLS-1$
            color = "gray";
        } else if (object.getIsSelected()) {
            // $NON-NLS-1$
            color = "midnightblue";
        } else if (!object.getIsAccessible() && !object.getIsGrayedOut()) {
            // $NON-NLS-1$
            color = "orange";
        } else {
            // $NON-NLS-1$
            color = "black";
        }
    }
    // $NON-NLS-1$
    return template.input(getRawValue(object), "color:" + color, DOM.createUniqueId());
}
#method_after
@Override
public final SafeHtml getValue(LunModel object) {
    // TODO this should use a cell to render, not return HTML itself
    ScrollableTextCell.CellTemplate template = GWT.create(ScrollableTextCell.CellTemplate.class);
    // $NON-NLS-1$
    String color = "";
    if (object != null) {
        if (!object.getIsIncluded() && (!object.getIsSelected() || object.getIsGrayedOut()) || object.isRemoveLunSelected()) {
            // $NON-NLS-1$
            color = "gray";
        } else if (object.getIsSelected()) {
            // $NON-NLS-1$
            color = "midnightblue";
        } else if (!object.getIsAccessible() && !object.getIsGrayedOut()) {
            // $NON-NLS-1$
            color = "orange";
        } else {
            // $NON-NLS-1$
            color = "black";
        }
    }
    // $NON-NLS-1$
    return template.input(getRawValue(object), "color:" + color, DOM.createUniqueId());
}
#end_block

#method_before
private boolean validateStoragePropertiesUpdate() {
    StorageDomainValidator storageDomainValidator = getStorageDomainValidator();
    if (!checkStorageDomainStatusNotEqual(StorageDomainStatus.Locked) || !validateStorageNameUpdate() || !validateDiscardAfterDeleteLegal(storageDomainValidator) || !validateDiskOnBackupDomain()) {
        return false;
    }
    // Collect changed fields to update in a list.
    List<String> props = ObjectIdentityChecker.getChangedFields(oldDomain, getStorageDomain().getStorageStaticData());
    // Allow changes to the following fields only:
    props.remove("storageName");
    props.remove("description");
    props.remove("comment");
    props.remove("wipeAfterDelete");
    props.remove("discardAfterDelete");
    props.remove("warningLowSpaceIndicator");
    props.remove("criticalSpaceActionBlocker");
    props.remove("backup");
    if (!props.isEmpty()) {
        log.warn("There was an attempt to update the following fields although they are not allowed to be updated: {}", StringUtils.join(props, ","));
        return failValidation(EngineMessage.ERROR_CANNOT_CHANGE_STORAGE_DOMAIN_FIELDS);
    }
    return true;
}
#method_after
private boolean validateStoragePropertiesUpdate() {
    StorageDomainValidator storageDomainValidator = getStorageDomainValidator();
    if (!checkStorageDomainStatusNotEqual(StorageDomainStatus.Locked) || !validateStorageNameUpdate() || !validateDiscardAfterDeleteLegal(storageDomainValidator) || !validateDiskOnBackupDomain(storageDomainValidator)) {
        return false;
    }
    // Collect changed fields to update in a list.
    List<String> props = ObjectIdentityChecker.getChangedFields(oldDomain, getStorageDomain().getStorageStaticData());
    // Allow changes to the following fields only:
    props.remove("storageName");
    props.remove("description");
    props.remove("comment");
    props.remove("wipeAfterDelete");
    props.remove("discardAfterDelete");
    props.remove("warningLowSpaceIndicator");
    props.remove("criticalSpaceActionBlocker");
    props.remove("backup");
    if (!props.isEmpty()) {
        log.warn("There was an attempt to update the following fields although they are not allowed to be updated: {}", StringUtils.join(props, ","));
        return failValidation(EngineMessage.ERROR_CANNOT_CHANGE_STORAGE_DOMAIN_FIELDS);
    }
    return true;
}
#end_block

#method_before
private boolean validateDiskOnBackupDomain() {
    return validate(new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), Stream.concat(getVm().getDiskMap().values().stream().filter(DisksFilter.ONLY_IMAGES).map(DiskImage.class::cast).flatMap(vmDisk -> vmDisk.getStorageIds().stream()), Stream.of(getVm().getLeaseStorageDomainId()).filter(Objects::nonNull)).collect(Collectors.toSet())).allDomainsNotBackupDomains());
}
#method_after
private boolean validateDiskOnBackupDomain(StorageDomainValidator storageDomainValidator) {
    boolean storageDomainBackupChanged = !oldDomain.isBackup() && getStorageDomain().isBackup();
    if (storageDomainBackupChanged) {
        return validate(storageDomainValidator.isRunningVmsOrVmLeasesForBackupDomain(vmHandler));
    }
    return true;
}
#end_block

#method_before
private boolean isPoolUp() {
    // order to change description in spm
    return validate(new StoragePoolValidator(getStoragePool()).isUp());
}
#method_after
private boolean isPoolUp() {
    // order to change description in spm
    return validate(new StoragePoolValidator(getStoragePool()).existsAndUp());
}
#end_block

#method_before
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Command);
}
#method_after
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Execution);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    boolean runningConfigurationNeeded = isRunningConfigurationNeeded();
    if (runningConfigurationNeeded) {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    } else if (!updateVmLease()) {
        return;
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new TransactionCompletionListener() {

            @Override
            public void onSuccess() {
                ovfDataUpdater.triggerNow();
            }

            @Override
            public void onRollback() {
            // No notification is needed
            }
        });
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), oldVm.getStatus(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
        hotSetLease(userVm, runningConfigurationNeeded);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    iconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    newVmStatic.setLeaseInfo(oldVm.getStaticData().getLeaseInfo());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new TransactionCompletionListener() {

            @Override
            public void onSuccess() {
                ovfDataUpdater.triggerNow();
            }

            @Override
            public void onRollback() {
            // No notification is needed
            }
        });
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), oldVm.getStatus(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (!updateVmLease()) {
        return;
    }
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    iconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#end_block

#method_before
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    getVm().getStaticData().setLeaseInfo(null);
    if (getVm().isNotRunning()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), newVmStatic.getName(), false)) {
            return false;
        }
    } else {
        if (oldVm.getLeaseStorageDomainId() == null) {
            return addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), newVmStatic.getName(), true);
        }
        boolean hotUnplugSucceeded = false;
        try {
            hotUnplugSucceeded = runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot unplugging a lease to VM {}, message: {}", oldVm.getId(), e.getMessage());
        }
        if (!hotUnplugSucceeded) {
            auditLog(this, AuditLogType.HOT_UNPLUG_LEASE_FAILED);
        }
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId(), oldVm.getName());
    return true;
}
#method_after
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    getVm().getStaticData().setLeaseInfo(null);
    if (getVm().isNotRunning()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId())) {
            return false;
        }
    } else if (isHotSetEnabled()) {
        if (oldVm.getLeaseStorageDomainId() == null) {
            VmLeaseParameters params = new VmLeaseParameters(getStoragePoolId(), newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId());
            params.setVdsId(getVm().getRunOnVds());
            params.setHotPlugLease(true);
            return runInternalAction(ActionType.AddVmLease, params).getSucceeded();
        }
        boolean hotUnplugSucceeded = false;
        try {
            hotUnplugSucceeded = runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot unplugging a lease to VM {}, message: {}", oldVm.getId(), e.getMessage());
        }
        if (!hotUnplugSucceeded) {
            auditLog(this, AuditLogType.HOT_UNPLUG_LEASE_FAILED);
        }
    }
    // In case of remove lease only, VM lease info should set to null
    if (oldVm.getLeaseStorageDomainId() != null && newVmStatic.getLeaseStorageDomainId() == null) {
        newVmStatic.setLeaseInfo(null);
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration()) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration()) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (vmFromDB.getMemSizeMb() != vmFromParams.getMemSizeMb() && vmFromDB.isRunning() && isHotSetEnabled() && HugePageUtils.isBackedByHugepages(vmFromDB.getStaticData()) && (vmFromDB.getMemSizeMb() < vmFromParams.getMemSizeMb() || (vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && getParameters().isMemoryHotUnplugEnabled()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_SET_NOT_SUPPORTED_FOR_HUGE_PAGES);
    }
    return true;
}
#end_block

#method_before
public void onAddCluster() {
    ClusterModel model = (ClusterModel) getWindow();
    Cluster cluster = new Cluster();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(model.getEnableOvirtService().getEntity())) {
        // cluster is virt enabled
        return;
    }
    // Save changes.
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setTransparentHugepages(true);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    if (model.getClusterPolicy().getSelectedItem() != null) {
        ClusterPolicy selectedPolicy = model.getClusterPolicy().getSelectedItem();
        cluster.setClusterPolicyId(selectedPolicy.getId());
        cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    }
    if (version.less(AsyncDataProvider.getInstance().multiFirewallSupportSince())) {
        cluster.setFirewallType(FirewallType.IPTABLES);
    }
    model.startProgress();
    Frontend.getInstance().runAction(ActionType.AddCluster, new ManagementNetworkOnClusterOperationParameters(cluster), result -> {
        DataCenterGuideModel localModel = (DataCenterGuideModel) result.getState();
        localModel.postOnAddCluster(result.getReturnValue());
    }, this);
}
#method_after
public void onAddCluster() {
    ClusterModel model = (ClusterModel) getWindow();
    Cluster cluster = new Cluster();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(model.getEnableOvirtService().getEntity())) {
        // cluster is virt enabled
        return;
    }
    // Save changes.
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setTransparentHugepages(true);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setFirewallType(model.getFirewallType().getSelectedItem());
    if (model.getClusterPolicy().getSelectedItem() != null) {
        ClusterPolicy selectedPolicy = model.getClusterPolicy().getSelectedItem();
        cluster.setClusterPolicyId(selectedPolicy.getId());
        cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    }
    model.startProgress();
    Frontend.getInstance().runAction(ActionType.AddCluster, new ManagementNetworkOnClusterOperationParameters(cluster), result -> {
        DataCenterGuideModel localModel = (DataCenterGuideModel) result.getState();
        localModel.postOnAddCluster(result.getReturnValue());
    }, this);
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageDomain.class, to = StorageDomain.class)
public static StorageDomain map(org.ovirt.engine.core.common.businessentities.StorageDomain entity, StorageDomain template) {
    StorageDomain model = template != null ? template : new StorageDomain();
    model.setId(entity.getId().toString());
    model.setName(entity.getStorageName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    model.setType(map(entity.getStorageDomainType(), null));
    model.setWarningLowSpaceIndicator(entity.getWarningLowSpaceIndicator());
    model.setCriticalSpaceActionBlocker(entity.getCriticalSpaceActionBlocker());
    model.setMaster(entity.getStorageDomainType() == org.ovirt.engine.core.common.businessentities.StorageDomainType.Master);
    if (entity.getStatus() != null) {
        model.setStatus(mapStorageDomainStatus(entity.getStatus()));
    }
    if (entity.getExternalStatus() != null) {
        model.setExternalStatus(ExternalStatusMapper.map(entity.getExternalStatus()));
    }
    model.setStorage(new HostStorage());
    model.getStorage().setType(map(entity.getStorageType(), null));
    if (entity.getStorageType() == org.ovirt.engine.core.common.businessentities.storage.StorageType.ISCSI || entity.getStorageType() == org.ovirt.engine.core.common.businessentities.storage.StorageType.FCP) {
        model.getStorage().setVolumeGroup(new VolumeGroup());
        model.getStorage().getVolumeGroup().setId(entity.getStorage());
    }
    if (entity.getAvailableDiskSize() != null) {
        model.setAvailable(SizeConverter.convert(entity.getAvailableDiskSize().longValue(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    }
    if (entity.getUsedDiskSize() != null) {
        model.setUsed(SizeConverter.convert(entity.getUsedDiskSize().longValue(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    }
    model.setCommitted(SizeConverter.convert(entity.getCommittedDiskSize(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    if (entity.getStorageFormat() != null) {
        model.setStorageFormat(StorageFormatMapper.map(entity.getStorageFormat(), null));
    }
    model.setWipeAfterDelete(entity.getWipeAfterDelete());
    model.setDiscardAfterDelete(entity.getDiscardAfterDelete());
    model.setSupportsDiscard(entity.getSupportsDiscard());
    model.setBackup(entity.isBackup());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageDomain.class, to = StorageDomain.class)
public static StorageDomain map(org.ovirt.engine.core.common.businessentities.StorageDomain entity, StorageDomain template) {
    StorageDomain model = template != null ? template : new StorageDomain();
    model.setId(entity.getId().toString());
    model.setName(entity.getStorageName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    model.setType(map(entity.getStorageDomainType(), null));
    model.setWarningLowSpaceIndicator(entity.getWarningLowSpaceIndicator());
    model.setCriticalSpaceActionBlocker(entity.getCriticalSpaceActionBlocker());
    model.setMaster(entity.getStorageDomainType() == org.ovirt.engine.core.common.businessentities.StorageDomainType.Master);
    if (entity.getStatus() != null) {
        model.setStatus(mapStorageDomainStatus(entity.getStatus()));
    }
    if (entity.getExternalStatus() != null) {
        model.setExternalStatus(ExternalStatusMapper.map(entity.getExternalStatus()));
    }
    model.setStorage(new HostStorage());
    model.getStorage().setType(map(entity.getStorageType(), null));
    if (entity.getStorageType() == org.ovirt.engine.core.common.businessentities.storage.StorageType.ISCSI || entity.getStorageType() == org.ovirt.engine.core.common.businessentities.storage.StorageType.FCP) {
        model.getStorage().setVolumeGroup(new VolumeGroup());
        model.getStorage().getVolumeGroup().setId(entity.getStorage());
    }
    if (entity.getAvailableDiskSize() != null) {
        model.setAvailable(SizeConverter.convert(entity.getAvailableDiskSize().longValue(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    }
    if (entity.getUsedDiskSize() != null) {
        model.setUsed(SizeConverter.convert(entity.getUsedDiskSize().longValue(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    }
    model.setCommitted(SizeConverter.convert(entity.getCommittedDiskSize(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    if (entity.getStorageFormat() != null) {
        model.setStorageFormat(StorageFormatMapper.map(entity.getStorageFormat(), null));
    }
    model.setWipeAfterDelete(entity.getWipeAfterDelete());
    model.setDiscardAfterDelete(entity.getDiscardAfterDelete());
    model.setSupportsDiscard(entity.getSupportsDiscard());
    // Not supported by sysfs since kernel version 4.12, and thus deprecated.
    model.setSupportsDiscardZeroesData(false);
    model.setBackup(entity.isBackup());
    return model;
}
#end_block

#method_before
@Test
public void discardMaxBytesFieldIsNotParsed() {
    // Discard support is not available in versions < 4.1.
    testDiscardFieldParsing(Version.v4_0, null);
}
#method_after
@Test
public void discardMaxBytesFieldIsNotParsed() {
    testDiscardFieldParsing(Version.v4_0, null);
}
#end_block

#method_before
@Mapping(from = LUNs.class, to = LogicalUnit.class)
public static LogicalUnit map(LUNs entity, LogicalUnit template) {
    LogicalUnit model = template != null ? template : new LogicalUnit();
    model.setId(entity.getLUNId());
    if (entity.getVendorId() != null && !entity.getVendorId().isEmpty()) {
        model.setVendorId(entity.getVendorId());
    }
    if (entity.getProductId() != null && !entity.getProductId().isEmpty()) {
        model.setProductId(entity.getProductId());
    }
    if (entity.getSerial() != null && !entity.getSerial().isEmpty()) {
        model.setSerial(entity.getSerial());
    }
    if (entity.getLunMapping() != null) {
        model.setLunMapping(entity.getLunMapping());
    }
    if (entity.getVolumeGroupId() != null && !entity.getVolumeGroupId().isEmpty()) {
        model.setVolumeGroupId(entity.getVolumeGroupId());
    }
    if (entity.getStorageDomainId() != null) {
        model.setStorageDomainId(entity.getStorageDomainId().toString());
    }
    if (entity.getDiskId() != null) {
        model.setDiskId(entity.getDiskId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(map(entity.getStatus(), null));
    }
    if (entity.getDiscardMaxSize() != null) {
        model.setDiscardMaxSize(entity.getDiscardMaxSize());
    }
    model.setSize(SizeConverter.convert((long) entity.getDeviceSize(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    model.setPaths(entity.getPathCount());
    return model;
}
#method_after
@Mapping(from = LUNs.class, to = LogicalUnit.class)
public static LogicalUnit map(LUNs entity, LogicalUnit template) {
    LogicalUnit model = template != null ? template : new LogicalUnit();
    model.setId(entity.getLUNId());
    if (entity.getVendorId() != null && !entity.getVendorId().isEmpty()) {
        model.setVendorId(entity.getVendorId());
    }
    if (entity.getProductId() != null && !entity.getProductId().isEmpty()) {
        model.setProductId(entity.getProductId());
    }
    if (entity.getSerial() != null && !entity.getSerial().isEmpty()) {
        model.setSerial(entity.getSerial());
    }
    if (entity.getLunMapping() != null) {
        model.setLunMapping(entity.getLunMapping());
    }
    if (entity.getVolumeGroupId() != null && !entity.getVolumeGroupId().isEmpty()) {
        model.setVolumeGroupId(entity.getVolumeGroupId());
    }
    if (entity.getStorageDomainId() != null) {
        model.setStorageDomainId(entity.getStorageDomainId().toString());
    }
    if (entity.getDiskId() != null) {
        model.setDiskId(entity.getDiskId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(map(entity.getStatus(), null));
    }
    if (entity.getDiscardMaxSize() != null) {
        model.setDiscardMaxSize(entity.getDiscardMaxSize());
    }
    // Not supported by sysfs since kernel version 4.12, and thus deprecated.
    model.setDiscardZeroesData(false);
    model.setSize(SizeConverter.convert((long) entity.getDeviceSize(), SizeConverter.SizeUnit.GiB, SizeConverter.SizeUnit.BYTES).longValue());
    model.setPaths(entity.getPathCount());
    return model;
}
#end_block

#method_before
private boolean externalNetworkValid(AddNetworkValidator validator) {
    ProviderValidator providerValidator = new ProviderValidator(providerDao.get(getNetwork().getProvidedBy().getProviderId()));
    return validate(providerValidator.providerIsSet()) && validate(validator.externalNetworkNewInDataCenter()) && validate(validator.externalNetworkIsVmNetwork()) && validate(validator.externalNetworkVlanValid()) && (!getNetwork().isSetProviderPhysicalNetworkId() || validate(validator.providerPhysicalNetworkInDataCenter()));
}
#method_after
private boolean externalNetworkValid(AddNetworkValidator validator) {
    ProviderValidator providerValidator = new ProviderValidator(providerDao.get(getNetwork().getProvidedBy().getProviderId()));
    return validate(providerValidator.providerIsSet()) && validate(validator.externalNetworkNewInDataCenter()) && validate(validator.externalNetworkIsVmNetwork()) && validate(validator.externalNetworkVlanValid()) && validate(validator.providerPhysicalNetworkValid());
}
#end_block

#method_before
public ValidationResult providerPhysicalNetworkInDataCenter() {
    for (Network otherNetwork : getNetworks()) {
        if (network.getProviderPhysicalNetworkId().equals(otherNetwork.getId())) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_PHYSICAL_NETWORK_DOES_NOT_EXIST_ON_DC);
}
#method_after
private boolean providerPhysicalNetworkInDataCenter() {
    return getNetworks().stream().anyMatch(otherNetwork -> network.getProvidedBy().getPhysicalNetworkId().equals(otherNetwork.getId()));
}
#end_block

#method_before
public static void handleCellEvent(NativeEvent event, Element e, SafeHtml tooltip) {
    String eventType = event.getType();
    if (BrowserEvents.MOUSEOVER.equals(eventType)) {
        Element parentTableCellElement = findParentTableCellElement(e);
        // Assign unique ID to the parent TD/TH element.
        String parentTableCellElementId = parentTableCellElement.getId();
        if (StringHelper.isNullOrEmpty(parentTableCellElementId)) {
            parentTableCellElementId = DOM.createUniqueId();
            parentTableCellElement.setId(parentTableCellElementId);
        }
        // Make sure the tooltip is set only once on the parent TD/TH element.
        if (!hasTooltip(parentTableCellElement)) {
            setTooltipOnElement(parentTableCellElement, tooltip, new TooltipConfig().setForceShow().markAsCellWidgetTooltip());
        } else if (!sameTooltipOnElement(parentTableCellElement, tooltip)) {
            replaceTooltipContent(parentTableCellElement, getTooltipHtmlString(tooltip));
        }
        // Prevent other cell widget tooltips from hanging open.
        hideAllCellWidgetTooltipsExcept(parentTableCellElementId);
    } else if (BrowserEvents.MOUSEDOWN.equals(eventType)) {
        hideAllTooltips();
    }
}
#method_after
public static void handleCellEvent(NativeEvent event, Element e, SafeHtml tooltip) {
    String eventType = event.getType();
    if (BrowserEvents.MOUSEOVER.equals(eventType)) {
        Element parentTableCellElement = findParentTableCellElement(e);
        // Assign unique ID to the parent TD/TH element.
        String parentTableCellElementId = parentTableCellElement.getId();
        if (StringHelper.isNullOrEmpty(parentTableCellElementId)) {
            parentTableCellElementId = DOM.createUniqueId();
            parentTableCellElement.setId(parentTableCellElementId);
        }
        // Make sure the tooltip is set only once on the parent TD/TH element.
        if (!hasTooltip(parentTableCellElement)) {
            setTooltipOnElement(parentTableCellElement, tooltip, new TooltipConfig().setForceShow().markAsCellWidgetTooltip());
        } else if (!sameTooltipOnElement(parentTableCellElement, tooltip)) {
            replaceTooltipContent(parentTableCellElement.getId(), getTooltipHtmlString(tooltip));
        }
        // Prevent other cell widget tooltips from hanging open.
        hideAllCellWidgetTooltipsExcept(parentTableCellElementId);
    } else if (BrowserEvents.MOUSEDOWN.equals(eventType)) {
        hideAllTooltips();
    }
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(Network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getAddr()).addValue("description", network.getDescription()).addValue("free_text_comment", network.getComment()).addValue("id", network.getId()).addValue("name", network.getName()).addValue("vdsm_name", network.getVdsmName()).addValue("subnet", network.getSubnet()).addValue("gateway", network.getGateway()).addValue("type", network.getType()).addValue("vlan_id", network.getVlanId()).addValue("stp", network.getStp()).addValue("storage_pool_id", network.getDataCenterId()).addValue("mtu", network.getMtu()).addValue("vm_network", network.isVmNetwork()).addValue("provider_network_provider_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getProviderId()).addValue("provider_network_external_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getExternalId()).addValue("provider_physical_network_id", network.getProviderPhysicalNetworkId()).addValue("qos_id", network.getQosId()).addValue("label", network.getLabel()).addValue("dns_resolver_configuration_id", getDnsResolverConfigurationId(network));
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(Network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getAddr()).addValue("description", network.getDescription()).addValue("free_text_comment", network.getComment()).addValue("id", network.getId()).addValue("name", network.getName()).addValue("vdsm_name", network.getVdsmName()).addValue("subnet", network.getSubnet()).addValue("gateway", network.getGateway()).addValue("type", network.getType()).addValue("vlan_id", network.getVlanId()).addValue("stp", network.getStp()).addValue("storage_pool_id", network.getDataCenterId()).addValue("mtu", network.getMtu()).addValue("vm_network", network.isVmNetwork()).addValue("provider_network_provider_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getProviderId()).addValue("provider_network_external_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getExternalId()).addValue("provider_physical_network_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getPhysicalNetworkId()).addValue("qos_id", network.getQosId()).addValue("label", network.getLabel()).addValue("dns_resolver_configuration_id", getDnsResolverConfigurationId(network));
}
#end_block

#method_before
@Override
public T mapRow(ResultSet rs, int rowNum) throws SQLException {
    T entity = createNetworkEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setName(rs.getString("name"));
    entity.setVdsmName(rs.getString("vdsm_name"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setType((Integer) rs.getObject("type"));
    entity.setAddr(rs.getString("addr"));
    entity.setSubnet(rs.getString("subnet"));
    entity.setGateway(rs.getString("gateway"));
    entity.setVlanId((Integer) rs.getObject("vlan_id"));
    entity.setStp(rs.getBoolean("stp"));
    entity.setDataCenterId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setMtu(rs.getInt("mtu"));
    entity.setVmNetwork(rs.getBoolean("vm_network"));
    Guid providerId = getGuid(rs, "provider_network_provider_id");
    if (providerId != null) {
        entity.setProvidedBy(new ProviderNetwork(providerId, rs.getString("provider_network_external_id")));
    }
    Guid providerPhysicalNetworkId = getGuid(rs, "provider_physical_network_id");
    if (providerPhysicalNetworkId != null) {
        entity.setProviderPhysicalNetworkId(providerPhysicalNetworkId);
    }
    entity.setQosId(getGuid(rs, "qos_id"));
    entity.setLabel(rs.getString("label"));
    Guid dnsResolverConfigurationId = getGuid(rs, "dns_resolver_configuration_id");
    entity.setDnsResolverConfiguration(dnsResolverConfigurationDao.get(dnsResolverConfigurationId));
    return entity;
}
#method_after
@Override
public T mapRow(ResultSet rs, int rowNum) throws SQLException {
    T entity = createNetworkEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setName(rs.getString("name"));
    entity.setVdsmName(rs.getString("vdsm_name"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setType((Integer) rs.getObject("type"));
    entity.setAddr(rs.getString("addr"));
    entity.setSubnet(rs.getString("subnet"));
    entity.setGateway(rs.getString("gateway"));
    entity.setVlanId((Integer) rs.getObject("vlan_id"));
    entity.setStp(rs.getBoolean("stp"));
    entity.setDataCenterId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setMtu(rs.getInt("mtu"));
    entity.setVmNetwork(rs.getBoolean("vm_network"));
    Guid providerId = getGuid(rs, "provider_network_provider_id");
    if (providerId != null) {
        entity.setProvidedBy(new ProviderNetwork(providerId, rs.getString("provider_network_external_id"), getGuid(rs, "provider_physical_network_id")));
    }
    entity.setQosId(getGuid(rs, "qos_id"));
    entity.setLabel(rs.getString("label"));
    Guid dnsResolverConfigurationId = getGuid(rs, "dns_resolver_configuration_id");
    entity.setDnsResolverConfiguration(dnsResolverConfigurationDao.get(dnsResolverConfigurationId));
    return entity;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getNetwork().isSetProviderPhysicalNetworkId()) {
        loadPhysicalNetworkProviderParameters(getNetwork());
    }
    NetworkProviderProxy proxy = providerProxyFactory.create(getProvider());
    getNetwork().getProvidedBy().setExternalId(proxy.add(getNetwork()));
    getNetwork().setVlanId(null);
    getNetwork().setLabel(null);
    TransactionSupport.executeInNewTransaction(() -> {
        super.executeCommand();
        getReturnValue().setActionReturnValue(getNetwork().getId());
        return null;
    });
}
#method_after
@Override
protected void executeCommand() {
    if (getNetwork().getProvidedBy().isSetPhysicalNetworkId()) {
        loadPhysicalNetworkProviderParameters();
    }
    NetworkProviderProxy proxy = providerProxyFactory.create(getProvider());
    getNetwork().getProvidedBy().setExternalId(proxy.add(getNetwork()));
    getNetwork().setVlanId(null);
    getNetwork().setLabel(null);
    TransactionSupport.executeInNewTransaction(() -> {
        super.executeCommand();
        getReturnValue().setActionReturnValue(getNetwork().getId());
        return null;
    });
    postAddNetwork(getProvider().getId(), getNetwork().getProvidedBy().getExternalId());
}
#end_block

#method_before
private void loadPhysicalNetworkProviderParameters(Network network) {
    Network physicalProviderNetwork = networkDao.get(network.getProviderPhysicalNetworkId());
    network.setVlanId(physicalProviderNetwork.getVlanId());
    network.setLabel(physicalProviderNetwork.getVdsmName());
}
#method_after
private void loadPhysicalNetworkProviderParameters() {
    Network physicalProviderNetwork = networkDao.get(getNetwork().getProvidedBy().getPhysicalNetworkId());
    getNetwork().setVlanId(physicalProviderNetwork.getVlanId());
    getNetwork().setLabel(physicalProviderNetwork.getVdsmName());
}
#end_block

#method_before
@Mapping(from = Network.class, to = org.ovirt.engine.core.common.businessentities.network.Network.class)
public static org.ovirt.engine.core.common.businessentities.network.Network map(Network model, org.ovirt.engine.core.common.businessentities.network.Network template) {
    org.ovirt.engine.core.common.businessentities.network.Network entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.network.Network();
    entity.setCluster(template != null && template.getCluster() != null ? template.getCluster() : new NetworkCluster());
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setDataCenterId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setAddr(model.getIp().getAddress());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setSubnet(model.getIp().getNetmask());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
    }
    if (model.isSetVlan()) {
        entity.setVlanId(model.getVlan().getId());
    }
    if (model.isSetStp()) {
        entity.setStp(model.isStp());
    }
    if (model.isSetDisplay()) {
        // for backward compatibility use display tag or usage tag
        entity.getCluster().setDisplay(model.isDisplay());
    }
    if (model.isSetUsages()) {
        List<NetworkUsage> networkUsages = new ArrayList<>();
        for (NetworkUsage usage : model.getUsages().getUsages()) {
            networkUsages.add(usage);
        }
        entity.getCluster().setDisplay(networkUsages.contains(NetworkUsage.DISPLAY));
        entity.getCluster().setMigration(networkUsages.contains(NetworkUsage.MIGRATION));
        entity.getCluster().setManagement(networkUsages.contains(NetworkUsage.MANAGEMENT));
        entity.getCluster().setGluster(networkUsages.contains(NetworkUsage.GLUSTER));
        entity.getCluster().setDefaultRoute(networkUsages.contains(NetworkUsage.DEFAULT_ROUTE));
        entity.setVmNetwork(networkUsages.contains(NetworkUsage.VM));
    }
    if (model.isSetMtu()) {
        entity.setMtu(model.getMtu());
    }
    if (model.isSetRequired()) {
        entity.getCluster().setRequired(model.isRequired());
    }
    if (model.isSetQos()) {
        entity.setQosId(Guid.createGuidFromString(model.getQos().getId()));
    }
    if (model.isSetDnsResolverConfiguration()) {
        entity.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(entity.getDnsResolverConfiguration(), model.getDnsResolverConfiguration()));
    }
    if (model.isSetExternalProvider()) {
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(GuidUtils.asGuid(model.getExternalProvider().getId()));
        entity.setProvidedBy(providerNetwork);
        if (model.isSetExternalProviderPhysicalNetwork()) {
            entity.setProviderPhysicalNetworkId(GuidUtils.asGuid(model.getExternalProviderPhysicalNetwork().getId()));
        }
    }
    return entity;
}
#method_after
@Mapping(from = Network.class, to = org.ovirt.engine.core.common.businessentities.network.Network.class)
public static org.ovirt.engine.core.common.businessentities.network.Network map(Network model, org.ovirt.engine.core.common.businessentities.network.Network template) {
    org.ovirt.engine.core.common.businessentities.network.Network entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.network.Network();
    entity.setCluster(template != null && template.getCluster() != null ? template.getCluster() : new NetworkCluster());
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setDataCenterId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setAddr(model.getIp().getAddress());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setSubnet(model.getIp().getNetmask());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
    }
    if (model.isSetVlan()) {
        entity.setVlanId(model.getVlan().getId());
    }
    if (model.isSetStp()) {
        entity.setStp(model.isStp());
    }
    if (model.isSetDisplay()) {
        // for backward compatibility use display tag or usage tag
        entity.getCluster().setDisplay(model.isDisplay());
    }
    if (model.isSetUsages()) {
        List<NetworkUsage> networkUsages = new ArrayList<>();
        for (NetworkUsage usage : model.getUsages().getUsages()) {
            networkUsages.add(usage);
        }
        entity.getCluster().setDisplay(networkUsages.contains(NetworkUsage.DISPLAY));
        entity.getCluster().setMigration(networkUsages.contains(NetworkUsage.MIGRATION));
        entity.getCluster().setManagement(networkUsages.contains(NetworkUsage.MANAGEMENT));
        entity.getCluster().setGluster(networkUsages.contains(NetworkUsage.GLUSTER));
        entity.getCluster().setDefaultRoute(networkUsages.contains(NetworkUsage.DEFAULT_ROUTE));
        entity.setVmNetwork(networkUsages.contains(NetworkUsage.VM));
    }
    if (model.isSetMtu()) {
        entity.setMtu(model.getMtu());
    }
    if (model.isSetRequired()) {
        entity.getCluster().setRequired(model.isRequired());
    }
    if (model.isSetQos()) {
        entity.setQosId(Guid.createGuidFromString(model.getQos().getId()));
    }
    if (model.isSetDnsResolverConfiguration()) {
        entity.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(entity.getDnsResolverConfiguration(), model.getDnsResolverConfiguration()));
    }
    if (model.isSetExternalProvider() && model.getExternalProvider().isSetId()) {
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(GuidUtils.asGuid(model.getExternalProvider().getId()));
        if (model.isSetExternalProviderPhysicalNetwork() && model.getExternalProviderPhysicalNetwork().isSetId()) {
            providerNetwork.setPhysicalNetworkId(GuidUtils.asGuid(model.getExternalProviderPhysicalNetwork().getId()));
        }
        entity.setProvidedBy(providerNetwork);
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.Network.class, to = Network.class)
public static Network map(org.ovirt.engine.core.common.businessentities.network.Network entity, Network template) {
    Network model = template != null ? template : new Network();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    if (entity.getDataCenterId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getDataCenterId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getAddr() != null || entity.getSubnet() != null || entity.getGateway() != null) {
        model.setIp(new Ip());
        model.getIp().setAddress(entity.getAddr());
        model.getIp().setNetmask(entity.getSubnet());
        model.getIp().setGateway(entity.getGateway());
    }
    if (entity.getVlanId() != null) {
        model.setVlan(new Vlan());
        model.getVlan().setId(entity.getVlanId());
    }
    model.setStp(entity.getStp());
    model.setMtu(entity.getMtu());
    model.setUsages(new Network.UsagesList());
    if (entity.isVmNetwork()) {
        model.getUsages().getUsages().add(NetworkUsage.VM);
    }
    if (entity.getCluster() != null) {
        if (entity.getCluster().isDisplay()) {
            model.getUsages().getUsages().add(NetworkUsage.DISPLAY);
        }
        if (entity.getCluster().isMigration()) {
            model.getUsages().getUsages().add(NetworkUsage.MIGRATION);
        }
        if (entity.getCluster().isManagement()) {
            model.getUsages().getUsages().add(NetworkUsage.MANAGEMENT);
        }
        if (entity.getCluster().isDefaultRoute()) {
            model.getUsages().getUsages().add(NetworkUsage.DEFAULT_ROUTE);
        }
        if (entity.getCluster().isGluster()) {
            model.getUsages().getUsages().add(NetworkUsage.GLUSTER);
        }
        if (entity.getCluster().getStatus() != null) {
            model.setStatus(mapNetworkStatus(entity.getCluster().getStatus()));
        }
        model.setDisplay(entity.getCluster().isDisplay());
        model.setRequired(entity.getCluster().isRequired());
    }
    Guid entityQosId = entity.getQosId();
    if (entityQosId != null) {
        Qos qos = new Qos();
        qos.setId(entityQosId.toString());
        model.setQos(qos);
    }
    if (entity.getDnsResolverConfiguration() != null) {
        model.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(entity.getDnsResolverConfiguration()));
    }
    if (entity.isExternal()) {
        OpenStackNetworkProvider externalProvider = new OpenStackNetworkProvider();
        externalProvider.setId(entity.getProvidedBy().getExternalId());
        model.setExternalProvider(externalProvider);
        if (entity.isSetProviderPhysicalNetworkId()) {
            Network providerPhysicalNetwork = new Network();
            providerPhysicalNetwork.setId(entity.getProviderPhysicalNetworkId().toString());
            model.setExternalProviderPhysicalNetwork(providerPhysicalNetwork);
        }
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.Network.class, to = Network.class)
public static Network map(org.ovirt.engine.core.common.businessentities.network.Network entity, Network template) {
    Network model = template != null ? template : new Network();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    if (entity.getDataCenterId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getDataCenterId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getAddr() != null || entity.getSubnet() != null || entity.getGateway() != null) {
        model.setIp(new Ip());
        model.getIp().setAddress(entity.getAddr());
        model.getIp().setNetmask(entity.getSubnet());
        model.getIp().setGateway(entity.getGateway());
    }
    if (entity.getVlanId() != null) {
        model.setVlan(new Vlan());
        model.getVlan().setId(entity.getVlanId());
    }
    model.setStp(entity.getStp());
    model.setMtu(entity.getMtu());
    model.setUsages(new Network.UsagesList());
    if (entity.isVmNetwork()) {
        model.getUsages().getUsages().add(NetworkUsage.VM);
    }
    if (entity.getCluster() != null) {
        if (entity.getCluster().isDisplay()) {
            model.getUsages().getUsages().add(NetworkUsage.DISPLAY);
        }
        if (entity.getCluster().isMigration()) {
            model.getUsages().getUsages().add(NetworkUsage.MIGRATION);
        }
        if (entity.getCluster().isManagement()) {
            model.getUsages().getUsages().add(NetworkUsage.MANAGEMENT);
        }
        if (entity.getCluster().isDefaultRoute()) {
            model.getUsages().getUsages().add(NetworkUsage.DEFAULT_ROUTE);
        }
        if (entity.getCluster().isGluster()) {
            model.getUsages().getUsages().add(NetworkUsage.GLUSTER);
        }
        if (entity.getCluster().getStatus() != null) {
            model.setStatus(mapNetworkStatus(entity.getCluster().getStatus()));
        }
        model.setDisplay(entity.getCluster().isDisplay());
        model.setRequired(entity.getCluster().isRequired());
    }
    Guid entityQosId = entity.getQosId();
    if (entityQosId != null) {
        Qos qos = new Qos();
        qos.setId(entityQosId.toString());
        model.setQos(qos);
    }
    if (entity.getDnsResolverConfiguration() != null) {
        model.setDnsResolverConfiguration(DnsResolverConfigurationMapper.map(entity.getDnsResolverConfiguration()));
    }
    if (entity.isExternal()) {
        OpenStackNetworkProvider externalProvider = new OpenStackNetworkProvider();
        externalProvider.setId(entity.getProvidedBy().getExternalId());
        model.setExternalProvider(externalProvider);
        if (entity.getProvidedBy().isSetPhysicalNetworkId()) {
            Network providerPhysicalNetwork = new Network();
            providerPhysicalNetwork.setId(entity.getProvidedBy().getPhysicalNetworkId().toString());
            model.setExternalProviderPhysicalNetwork(providerPhysicalNetwork);
        }
    }
    return model;
}
#end_block

#method_before
void proceedDownVm() {
    // destroy the VM as soon as possible
    destroyVm();
    // VM is running on another host - must be during migration
    if (!isVmRunningInDatabaseOnMonitoredHost()) {
        auditVmMigrationAbort();
        return;
    }
    logVmStatusTransition();
    switch(dbVm.getStatus()) {
        case SavingState:
            resourceManager.internalSetVmStatus(dbVm, VMStatus.Suspended);
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
            resourceManager.removeAsyncRunningVm(dbVm.getId());
            auditVmSuspended();
            break;
        case MigratingFrom:
            if (vdsmVm.getVmDynamic().getExitStatus() == VmExitStatus.Normal && vdsmVm.getVmDynamic().getExitReason() == VmExitReason.MigrationSucceeded) {
                handOverVm();
                break;
            }
            abortVmMigration(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
            if (vdsmVm.getVmDynamic().getExitStatus() == VmExitStatus.Error && getVmManager().isAutoStart()) {
                setAutoRunFlag();
            }
            break;
        default:
            switch(vdsmVm.getVmDynamic().getExitStatus()) {
                case Error:
                    auditVmOnDownError();
                    clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
                    if (resourceManager.isVmInAsyncRunningList(vdsmVm.getVmDynamic().getId())) {
                        setRerunFlag();
                        break;
                    }
                    if (getVmManager().isAutoStart()) {
                        setAutoRunFlag();
                        break;
                    }
                    break;
                case Normal:
                    boolean powerOff = System.nanoTime() - getVmManager().getPowerOffTimeout() < 0;
                    auditVmOnDownNormal(powerOff);
                    clearVm(vdsmVm.getVmDynamic().getExitStatus(), powerOff ? getPowerOffExitMessage() : vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
                    resourceManager.removeAsyncRunningVm(vdsmVm.getVmDynamic().getId());
                    if (getVmManager().isColdReboot() || vdsmVm.getVmDynamic().getExitReason() == VmExitReason.DestroyedOnReboot) {
                        setColdRebootFlag();
                    }
            }
    }
}
#method_after
void proceedDownVm() {
    // destroy the VM as soon as possible
    destroyVm();
    // VM is running on another host - must be during migration
    if (!isVmRunningInDatabaseOnMonitoredHost()) {
        if (dbVm.getStatus() == VMStatus.MigratingFrom) {
            log.error("Migration of VM '{}' to host '{}' failed: {}.", getVmManager().getName(), vdsManager.getVdsName(), vdsmVm.getVmDynamic().getExitMessage());
        }
        return;
    }
    logVmStatusTransition();
    switch(dbVm.getStatus()) {
        case SavingState:
            resourceManager.internalSetVmStatus(dbVm, VMStatus.Suspended);
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
            resourceManager.removeAsyncRunningVm(dbVm.getId());
            auditVmSuspended();
            break;
        case MigratingFrom:
            if (vdsmVm.getVmDynamic().getExitStatus() == VmExitStatus.Normal && vdsmVm.getVmDynamic().getExitReason() == VmExitReason.MigrationSucceeded) {
                handOverVm();
                break;
            }
            abortVmMigration(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
            if (vdsmVm.getVmDynamic().getExitStatus() == VmExitStatus.Error && getVmManager().isAutoStart()) {
                setAutoRunFlag();
            }
            break;
        default:
            switch(vdsmVm.getVmDynamic().getExitStatus()) {
                case Error:
                    auditVmOnDownError();
                    clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
                    if (resourceManager.isVmInAsyncRunningList(vdsmVm.getVmDynamic().getId())) {
                        setRerunFlag();
                        break;
                    }
                    if (getVmManager().isAutoStart()) {
                        setAutoRunFlag();
                        break;
                    }
                    break;
                case Normal:
                    boolean powerOff = System.nanoTime() - getVmManager().getPowerOffTimeout() < 0;
                    auditVmOnDownNormal(powerOff);
                    clearVm(vdsmVm.getVmDynamic().getExitStatus(), powerOff ? getPowerOffExitMessage() : vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
                    resourceManager.removeAsyncRunningVm(vdsmVm.getVmDynamic().getId());
                    if (getVmManager().isColdReboot() || vdsmVm.getVmDynamic().getExitReason() == VmExitReason.DestroyedOnReboot) {
                        setColdRebootFlag();
                    }
            }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration()) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (vmFromDB.getMemSizeMb() != vmFromParams.getMemSizeMb() && vmFromDB.isRunning() && HugePageUtils.isBackedByHugepages(vmFromDB.getStaticData())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_SET_NOT_SUPPORTED_FOR_HUGE_PAGES);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration()) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (vmFromDB.getMemSizeMb() != vmFromParams.getMemSizeMb() && vmFromDB.isRunning() && isHotSetEnabled() && HugePageUtils.isBackedByHugepages(vmFromDB.getStaticData()) && (vmFromDB.getMemSizeMb() < vmFromParams.getMemSizeMb() || (vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && getParameters().isMemoryHotUnplugEnabled()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_SET_NOT_SUPPORTED_FOR_HUGE_PAGES);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (isImagesAlreadyOnTarget()) {
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(vmFromConfiguration, ovfEntityData))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistForUnregisteredEntity(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistsForMemoryDisks(getVm().getSnapshots(), getParameters().isAllowPartialImport(), failedDisksToImportForAuditLog))) {
            return false;
        }
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    if (!validateExternalVnicProfileMapping()) {
        return false;
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (isImagesAlreadyOnTarget()) {
        if (!validateExternalVnicProfileMapping()) {
            return false;
        }
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(ovfEntityData))) {
            return false;
        }
        if (!validate(importValidator.validateDiskNotAlreadyExistOnDB(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistForUnregisteredEntity(getImages(), getParameters().isAllowPartialImport(), imageToDestinationDomainMap, failedDisksToImportForAuditLog))) {
            return false;
        }
        if (!validate(importValidator.validateStorageExistsForMemoryDisks(getVm().getSnapshots(), getParameters().isAllowPartialImport(), failedDisksToImportForAuditLog))) {
            return false;
        }
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return true;
}
#end_block

#method_before
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmFromConfiguration.getId(), getParameters().getClusterMap());
            if (cluster != null) {
                getParameters().setClusterId(cluster.getId());
            }
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setAffinityGroups(fullEntityOvfData.getAffinityGroups());
            getParameters().setAffinityLabels(fullEntityOvfData.getAffinityLabels());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            // Note: The VM's OVF does not preserve the username and password for the LUN's connection.
            // Therefore to achieve a simple VM registration the iSCSI storage server should not use
            // credentials, although if the user will use the mapping attribute, one can set the credentials through
            // there.
            drMappingHelper.mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()), getParameters().getExternalLunMap());
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            FullEntityOvfData fullEntityOvfData = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration = fullEntityOvfData.getVm();
            if (Guid.isNullOrEmpty(getParameters().getClusterId())) {
                Cluster cluster = drMappingHelper.getMappedCluster(fullEntityOvfData.getClusterName(), vmFromConfiguration.getId(), getParameters().getClusterMap());
                if (cluster != null) {
                    getParameters().setClusterId(cluster.getId());
                }
            }
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setAffinityGroups(fullEntityOvfData.getAffinityGroups());
            getParameters().setAffinityLabels(fullEntityOvfData.getAffinityLabels());
            getParameters().setDbUsers(fullEntityOvfData.getDbUsers());
            getParameters().setUserToRoles(fullEntityOvfData.getUserToRoles());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
            // Note: The VM's OVF does not preserve the username and password for the LUN's connection.
            // Therefore to achieve a simple VM registration the iSCSI storage server should not use
            // credentials, although if the user will use the mapping attribute, one can set the credentials through
            // there.
            drMappingHelper.mapExternalLunDisks(DisksFilter.filterLunDisks(vmFromConfiguration.getDiskMap().values()), getParameters().getExternalLunMap());
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
private void handleFinalizingFailure(final StateContext context) {
    log.error("Finalizing failed transfer. {}", getTransferDescription());
    stopImageTransferSession(context.entity);
    // (only if not disk snapshot)
    if (!Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        setImageStatus(getParameters().getTransferType() == TransferType.Upload ? ImageStatus.ILLEGAL : ImageStatus.OK);
    }
    // For download, we should teardown the image.
    if (getParameters().getTransferType() == TransferType.Download) {
        tearDownImage(context.entity.getVdsId());
    }
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
    setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_FAILURE);
}
#method_after
private void handleFinalizingFailure(final StateContext context) {
    log.error("Finalizing failed transfer. {}", getTransferDescription());
    stopImageTransferSession(context.entity);
    // (only if not disk snapshot)
    if (!Guid.isNullOrEmpty(getParameters().getImageGroupID())) {
        setImageStatus(getParameters().getTransferType() == TransferType.Upload ? ImageStatus.ILLEGAL : ImageStatus.OK);
    }
    // Teardown is required for all scenarios as we call prepareImage when
    // starting a new session.
    tearDownImage(context.entity.getVdsId());
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
    setAuditLogTypeFromPhase(ImageTransferPhase.FINISHED_FAILURE);
}
#end_block

#method_before
@Override
protected void postAddNetwork(Guid providerId, String externalId) {
    ExternalSubnet externalSubnet = getParameters().getExternalSubnet();
    if (externalSubnet != null) {
        AddExternalSubnetParameters subnetParameters = new AddExternalSubnetParameters(externalSubnet, providerId, externalId);
        getBackend().runInternalAction(ActionType.AddSubnetToProvider, subnetParameters);
    }
}
#method_after
@Override
protected void postAddNetwork(Guid providerId, String externalId) {
    ExternalSubnet externalSubnet = getParameters().getExternalSubnet();
    if (externalSubnet != null) {
        AddExternalSubnetParameters subnetParameters = new AddExternalSubnetParameters(externalSubnet, providerId, externalId);
        getBackend().runInternalMultipleActions(ActionType.AddSubnetToProvider, Arrays.asList(subnetParameters));
    }
}
#end_block

