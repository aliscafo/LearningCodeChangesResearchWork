447
#method_before
public void setCoresPerSocket(String value) {
    if (coresPerSocket == null && value == null) {
        return;
    }
    if (coresPerSocket == null || !coresPerSocket.equals(value)) {
        coresPerSocket = "" + value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("CoresPerSocket"));
    }
}
#method_after
public void setCoresPerSocket(String value) {
    if (coresPerSocket == null && value == null) {
        return;
    }
    if (coresPerSocket == null || !coresPerSocket.equals(value)) {
        coresPerSocket = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("CoresPerSocket"));
    }
}
#end_block

#method_before
private void updateProperties() {
    VDS vds = getEntity();
    setHardwareManufacturer(vds.getHardwareManufacturer());
    setHardwareVersion(vds.getHardwareVersion());
    setHardwareProductName(vds.getHardwareProductName());
    setHardwareUUID(vds.getHardwareUUID());
    setHardwareSerialNumber(vds.getHardwareSerialNumber());
    setHardwareFamily(vds.getHardwareFamily());
    setCpuType(vds.getCpuName() != null ? vds.getCpuName().getCpuName() : null);
    setCpuModel(vds.getCpuModel());
    setNumberOfSockets(vds.getCpuSockets());
    if (vds.getCpuCores() != null && vds.getCpuSockets() != null && vds.getCpuSockets() != 0) {
        StringBuffer coresPerSocketBuff = new StringBuffer();
        int coresPerSocket = vds.getCpuCores() / vds.getCpuSockets();
        coresPerSocketBuff.append(coresPerSocket);
        if (vds.getCountThreadsAsCores()) {
            // $NON-NLS-1$
            coresPerSocketBuff.append(" (");
            coresPerSocketBuff.append(vds.getCpuThreads());
            // $NON-NLS-1$
            coresPerSocketBuff.append(")");
        }
        setCoresPerSocket(coresPerSocketBuff.toString());
    } else {
        setCoresPerSocket(null);
    }
    if (vds.getVdsGroupCompatibilityVersion() != null && Version.v3_2.compareTo(vds.getVdsGroupCompatibilityVersion()) > 0) {
        // Members of pre-3.2 clusters don't support SMT; here we act like a 3.1 engine
        setThreadsPerCore(constants.unsupported());
    } else if (vds.getCpuThreads() == null || vds.getCpuCores() == null || vds.getCpuCores() == 0) {
        setThreadsPerCore(constants.unknown());
    } else {
        Integer threads = vds.getCpuThreads() / vds.getCpuCores();
        setThreadsPerCore(messages.commonMessageWithBrackets(threads.toString(), threads > 1 ? constants.smtEnabled() : constants.smtDisabled()));
    }
    /* Go through the list of HBA devices and transfer the necessary info
           to the GWT host hardware model */
    List<EnumMap<HbaDeviceKeys, String>> hbaDevices = new ArrayList<EnumMap<HbaDeviceKeys, String>>();
    // $NON-NLS-1$
    List<Map<String, String>> fcDevices = vds.getHBAs().get("FC");
    if (fcDevices != null) {
        for (Map<String, String> device : fcDevices) {
            EnumMap<HbaDeviceKeys, String> deviceModel = new EnumMap<HbaDeviceKeys, String>(HbaDeviceKeys.class);
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.MODEL_NAME, device.get("model"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.WWNN, device.get("wwnn"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.WWNPS, device.get("wwpn"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.TYPE, "FC");
            hbaDevices.add(deviceModel);
        }
    }
    setHbaDevices(hbaDevices);
}
#method_after
private void updateProperties() {
    VDS vds = getEntity();
    setHardwareManufacturer(vds.getHardwareManufacturer());
    setHardwareVersion(vds.getHardwareVersion());
    setHardwareProductName(vds.getHardwareProductName());
    setHardwareUUID(vds.getHardwareUUID());
    setHardwareSerialNumber(vds.getHardwareSerialNumber());
    setHardwareFamily(vds.getHardwareFamily());
    setCpuType(vds.getCpuName() != null ? vds.getCpuName().getCpuName() : null);
    setCpuModel(vds.getCpuModel());
    setNumberOfSockets(vds.getCpuSockets());
    if (vds.getCpuCores() != null && vds.getCpuSockets() != null && vds.getCpuThreads() != null && vds.getCpuSockets() != 0) {
        int coresPerSocket = vds.getCpuCores() / vds.getCpuSockets();
        String fieldValue = String.valueOf(coresPerSocket);
        if (vds.getCountThreadsAsCores()) {
            fieldValue = ConstantsManager.getInstance().getMessages().threadsAsCoresPerSocket(coresPerSocket, vds.getCpuThreads());
        }
        setCoresPerSocket(fieldValue);
    } else {
        setCoresPerSocket(null);
    }
    if (vds.getVdsGroupCompatibilityVersion() != null && Version.v3_2.compareTo(vds.getVdsGroupCompatibilityVersion()) > 0) {
        // Members of pre-3.2 clusters don't support SMT; here we act like a 3.1 engine
        setThreadsPerCore(constants.unsupported());
    } else if (vds.getCpuThreads() == null || vds.getCpuCores() == null || vds.getCpuCores() == 0) {
        setThreadsPerCore(constants.unknown());
    } else {
        Integer threads = vds.getCpuThreads() / vds.getCpuCores();
        setThreadsPerCore(messages.commonMessageWithBrackets(threads.toString(), threads > 1 ? constants.smtEnabled() : constants.smtDisabled()));
    }
    /* Go through the list of HBA devices and transfer the necessary info
           to the GWT host hardware model */
    List<EnumMap<HbaDeviceKeys, String>> hbaDevices = new ArrayList<EnumMap<HbaDeviceKeys, String>>();
    // $NON-NLS-1$
    List<Map<String, String>> fcDevices = vds.getHBAs().get("FC");
    if (fcDevices != null) {
        for (Map<String, String> device : fcDevices) {
            EnumMap<HbaDeviceKeys, String> deviceModel = new EnumMap<HbaDeviceKeys, String>(HbaDeviceKeys.class);
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.MODEL_NAME, device.get("model"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.WWNN, device.get("wwnn"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.WWNPS, device.get("wwpn"));
            // $NON-NLS-1$
            deviceModel.put(HbaDeviceKeys.TYPE, "FC");
            hbaDevices.add(deviceModel);
        }
    }
    setHbaDevices(hbaDevices);
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    entity.setBalloonEnabled(rs.getBoolean("enable_balloon"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setOnlineCpus(rs.getString("online_cpus"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    entity.setLiveMergeSupport(rs.getBoolean("is_live_merge_supported"));
    entity.setBalloonEnabled(rs.getBoolean("enable_balloon"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    return entity;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mVdsStatic == null) ? 0 : mVdsStatic.hashCode());
    result = prime * result + ((cpuName == null) ? 0 : cpuName.hashCode());
    result = prime * result + ((_spm_status == null) ? 0 : _spm_status.hashCode());
    result = prime * result + ((mImagesLastCheck == null) ? 0 : mImagesLastCheck.hashCode());
    result = prime * result + ((mImagesLastDelay == null) ? 0 : mImagesLastDelay.hashCode());
    result = prime * result + ((mInterfaceList == null) ? 0 : mInterfaceList.hashCode());
    result = prime * result + ((mNetworkList == null) ? 0 : mNetworkList.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + ((privateDomains == null) ? 0 : privateDomains.hashCode());
    result = prime * result + ((vdsSpmId == null) ? 0 : vdsSpmId.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vdsGroupVirtService == null) ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + ((vdsGroupGlusterService == null) ? 0 : vdsGroupGlusterService.hashCode());
    result = prime * result + (balloonEnabled ? 0 : 1);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mVdsStatic == null) ? 0 : mVdsStatic.hashCode());
    result = prime * result + ((cpuName == null) ? 0 : cpuName.hashCode());
    result = prime * result + ((_spm_status == null) ? 0 : _spm_status.hashCode());
    result = prime * result + ((mImagesLastCheck == null) ? 0 : mImagesLastCheck.hashCode());
    result = prime * result + ((mImagesLastDelay == null) ? 0 : mImagesLastDelay.hashCode());
    result = prime * result + ((mInterfaceList == null) ? 0 : mInterfaceList.hashCode());
    result = prime * result + ((mNetworkList == null) ? 0 : mNetworkList.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + ((privateDomains == null) ? 0 : privateDomains.hashCode());
    result = prime * result + ((vdsSpmId == null) ? 0 : vdsSpmId.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vdsGroupVirtService == null) ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + ((vdsGroupGlusterService == null) ? 0 : vdsGroupGlusterService.hashCode());
    result = prime * result + (balloonEnabled ? 0 : 1);
    result = prime * result + (countThreadsAsCores ? 0 : 1);
    return result;
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setManagementIp(getManagementIp());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmPassword(getPmPassword());
    vds.setPmPort(getPort());
    vds.setPmOptions(getPmOptions());
    vds.setPmType(getPmType());
    vds.setPmUser(getPmUser());
    vds.setPmSecondaryIp(getPmSecondaryIp());
    vds.setPmSecondaryType(getPmSecondaryType());
    vds.setPmSecondaryPort(getPmSecondaryPort());
    vds.setPmSecondaryOptions(getPmSecondaryOptions());
    vds.setPmSecondaryUser(getPmSecondaryUser());
    vds.setPmSecondaryPassword(getPmSecondaryPassword());
    vds.setPmSecondaryConcurrent(isPmSecondaryConcurrent());
    vds.setPmPort(getPmPort());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setManagementIp(getManagementIp());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmPassword(getPmPassword());
    vds.setPmPort(getPort());
    vds.setPmOptions(getPmOptions());
    vds.setPmType(getPmType());
    vds.setPmUser(getPmUser());
    vds.setPmSecondaryIp(getPmSecondaryIp());
    vds.setPmSecondaryType(getPmSecondaryType());
    vds.setPmSecondaryPort(getPmSecondaryPort());
    vds.setPmSecondaryOptions(getPmSecondaryOptions());
    vds.setPmSecondaryUser(getPmSecondaryUser());
    vds.setPmSecondaryPassword(getPmSecondaryPassword());
    vds.setPmSecondaryConcurrent(isPmSecondaryConcurrent());
    vds.setPmPort(getPmPort());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    return vds;
}
#end_block

#method_before
public Double getCpuIdle() {
    return this.mVdsStatistics.getcpu_idle();
}
#method_after
public Double getCpuIdle() {
    return this.mVdsStatistics.getCpuIdle();
}
#end_block

#method_before
public void setCpuIdle(Double value) {
    this.mVdsStatistics.setcpu_idle(value);
}
#method_after
public void setCpuIdle(Double value) {
    this.mVdsStatistics.setCpuIdle(value);
}
#end_block

#method_before
public Double getCpuLoad() {
    return this.mVdsStatistics.getcpu_load();
}
#method_after
public Double getCpuLoad() {
    return this.mVdsStatistics.getCpuLoad();
}
#end_block

#method_before
public void setCpuLoad(Double value) {
    this.mVdsStatistics.setcpu_load(value);
}
#method_after
public void setCpuLoad(Double value) {
    this.mVdsStatistics.setCpuLoad(value);
}
#end_block

#method_before
public Double getCpuSys() {
    return this.mVdsStatistics.getcpu_sys();
}
#method_after
public Double getCpuSys() {
    return this.mVdsStatistics.getCpuSys();
}
#end_block

#method_before
public void setCpuSys(Double value) {
    this.mVdsStatistics.setcpu_sys(value);
}
#method_after
public void setCpuSys(Double value) {
    this.mVdsStatistics.setCpuSys(value);
}
#end_block

#method_before
public Double getCpuUser() {
    return this.mVdsStatistics.getcpu_user();
}
#method_after
public Double getCpuUser() {
    return this.mVdsStatistics.getCpuUser();
}
#end_block

#method_before
public void setCpuUser(Double value) {
    this.mVdsStatistics.setcpu_user(value);
}
#method_after
public void setCpuUser(Double value) {
    this.mVdsStatistics.setCpuUser(value);
}
#end_block

#method_before
public Integer getUsageMemPercent() {
    return this.mVdsStatistics.getusage_mem_percent();
}
#method_after
public Integer getUsageMemPercent() {
    return this.mVdsStatistics.getUsageMemPercent();
}
#end_block

#method_before
public void setUsageMemPercent(Integer value) {
    this.mVdsStatistics.setusage_mem_percent(value);
}
#method_after
public void setUsageMemPercent(Integer value) {
    this.mVdsStatistics.setUsageMemPercent(value);
}
#end_block

#method_before
public Integer getUsageCpuPercent() {
    return this.mVdsStatistics.getusage_cpu_percent();
}
#method_after
public Integer getUsageCpuPercent() {
    return this.mVdsStatistics.getUsageCpuPercent();
}
#end_block

#method_before
public void setUsageCpuPercent(Integer value) {
    this.mVdsStatistics.setusage_cpu_percent(value);
}
#method_after
public void setUsageCpuPercent(Integer value) {
    this.mVdsStatistics.setUsageCpuPercent(value);
}
#end_block

#method_before
public Integer getUsageNetworkPercent() {
    return this.mVdsStatistics.getusage_network_percent();
}
#method_after
public Integer getUsageNetworkPercent() {
    return this.mVdsStatistics.getUsageNetworkPercent();
}
#end_block

#method_before
public void setUsageNetworkPercent(Integer value) {
    this.mVdsStatistics.setusage_network_percent(value);
}
#method_after
public void setUsageNetworkPercent(Integer value) {
    this.mVdsStatistics.setUsageNetworkPercent(value);
}
#end_block

#method_before
public Long getBootTime() {
    return this.mVdsStatistics.getboot_time();
}
#method_after
public Long getBootTime() {
    return this.mVdsStatistics.getBootTime();
}
#end_block

#method_before
public void setBootTime(Long value) {
    this.mVdsStatistics.setboot_time(value);
}
#method_after
public void setBootTime(Long value) {
    this.mVdsStatistics.setBootTime(value);
}
#end_block

#method_before
public Long getMemAvailable() {
    return this.mVdsStatistics.getmem_available();
}
#method_after
public Long getMemAvailable() {
    return this.mVdsStatistics.getMemAvailable();
}
#end_block

#method_before
public void setMemAvailable(Long value) {
    this.mVdsStatistics.setmem_available(value);
}
#method_after
public void setMemAvailable(Long value) {
    this.mVdsStatistics.setMemAvailable(value);
}
#end_block

#method_before
public Long getMemShared() {
    return this.mVdsStatistics.getmem_shared();
}
#method_after
public Long getMemShared() {
    return this.mVdsStatistics.getMemShared();
}
#end_block

#method_before
public void setMemShared(Long value) {
    this.mVdsStatistics.setmem_shared(value);
}
#method_after
public void setMemShared(Long value) {
    this.mVdsStatistics.setMemShared(value);
}
#end_block

#method_before
public Integer getMemSharedPercent() {
    Long shared = mVdsStatistics.getmem_shared();
    Integer physical = mVdsDynamic.getphysical_mem_mb();
    if (shared == null || physical == null || physical == 0) {
        return 0;
    }
    return (int) ((shared * 100) / physical);
}
#method_after
public Integer getMemSharedPercent() {
    Long shared = mVdsStatistics.getMemShared();
    Integer physical = mVdsDynamic.getphysical_mem_mb();
    if (shared == null || physical == null || physical == 0) {
        return 0;
    }
    return (int) ((shared * 100) / physical);
}
#end_block

#method_before
public Long getSwapFree() {
    return this.mVdsStatistics.getswap_free();
}
#method_after
public Long getSwapFree() {
    return this.mVdsStatistics.getSwapFree();
}
#end_block

#method_before
public void setSwapFree(Long value) {
    this.mVdsStatistics.setswap_free(value);
}
#method_after
public void setSwapFree(Long value) {
    this.mVdsStatistics.setSwapFree(value);
}
#end_block

#method_before
public Long getSwapTotal() {
    return this.mVdsStatistics.getswap_total();
}
#method_after
public Long getSwapTotal() {
    return this.mVdsStatistics.getSwapTotal();
}
#end_block

#method_before
public void setSwapTotal(Long value) {
    this.mVdsStatistics.setswap_total(value);
}
#method_after
public void setSwapTotal(Long value) {
    this.mVdsStatistics.setSwapTotal(value);
}
#end_block

#method_before
public Integer getKsmCpuPercent() {
    return this.mVdsStatistics.getksm_cpu_percent();
}
#method_after
public Integer getKsmCpuPercent() {
    return this.mVdsStatistics.getKsmCpuPercent();
}
#end_block

#method_before
public void setKsmCpuPercent(Integer value) {
    this.mVdsStatistics.setksm_cpu_percent(value);
}
#method_after
public void setKsmCpuPercent(Integer value) {
    this.mVdsStatistics.setKsmCpuPercent(value);
}
#end_block

#method_before
public Long getKsmPages() {
    return this.mVdsStatistics.getksm_pages();
}
#method_after
public Long getKsmPages() {
    return this.mVdsStatistics.getKsmPages();
}
#end_block

#method_before
public void setKsmPages(Long value) {
    this.mVdsStatistics.setksm_pages(value);
}
#method_after
public void setKsmPages(Long value) {
    this.mVdsStatistics.setKsmPages(value);
}
#end_block

#method_before
public Boolean getKsmState() {
    return this.mVdsStatistics.getksm_state();
}
#method_after
public Boolean getKsmState() {
    return this.mVdsStatistics.getKsmState();
}
#end_block

#method_before
public void setKsmState(Boolean value) {
    this.mVdsStatistics.setksm_state(value);
}
#method_after
public void setKsmState(Boolean value) {
    this.mVdsStatistics.setKsmState(value);
}
#end_block

#method_before
public Date getCpuOverCommitTimestamp() {
    return mVdsDynamic.getcpu_over_commit_time_stamp();
}
#method_after
public Date getCpuOverCommitTimestamp() {
    return mVdsStatistics.getCpuOverCommitTimeStamp();
}
#end_block

#method_before
public void setCpuOverCommitTimestamp(Date value) {
    mVdsDynamic.setcpu_over_commit_time_stamp(value);
}
#method_after
public void setCpuOverCommitTimestamp(Date value) {
    mVdsStatistics.setCpuOverCommitTimeStamp(value);
}
#end_block

#method_before
private void addStyles() {
    overrideIpTablesEditor.addContentWidgetStyleName(style.overrideIpStyle());
    protocolEditor.addContentWidgetStyleName(style.protocolStyle());
    externalHostProviderEnabledEditor.addContentWidgetStyleName(style.externalHostProviderEnabledEditor());
    providerSearchFilterEditor.addContentWidgetStyleName(style.searchFilter());
    providerSearchFilterEditor.setStyleName(style.searchFilterLabel());
    providerSearchFilterEditor.setLabelStyleName(style.emptyEditor());
    providerSearchFilterLabel.addContentWidgetStyleName(style.emptyEditor());
    providerSearchFilterLabel.setStyleName(style.searchFilterLabel());
    fetchSshFingerprint.addContentWidgetStyleName(style.fingerprintEditor());
    expanderContent.setStyleName(style.expanderContent());
    publicKeyEditor.setCustomStyle(style.pkStyle());
    tabPanel.addBarStyle(style.bar());
}
#method_after
private void addStyles() {
    overrideIpTablesEditor.addContentWidgetStyleName(style.overrideIpStyle());
    protocolEditor.addContentWidgetStyleName(style.protocolStyle());
    externalHostProviderEnabledEditor.addContentWidgetStyleName(style.externalHostProviderEnabledEditorContent());
    providerSearchFilterEditor.addContentWidgetStyleName(style.searchFilter());
    providerSearchFilterEditor.setStyleName(style.searchFilterLabel());
    providerSearchFilterEditor.setLabelStyleName(style.emptyEditor());
    providerSearchFilterLabel.addContentWidgetStyleName(style.emptyEditor());
    providerSearchFilterLabel.setStyleName(style.searchFilterLabel());
    fetchSshFingerprint.addContentWidgetStyleName(style.fingerprintEditor());
    expanderContent.setStyleName(style.expanderContent());
    publicKeyEditor.setCustomStyle(style.pkStyle());
    tabPanel.addBarStyle(style.bar());
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getStorageDomainId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (getParameters().getStorageDomainId() != null) {
        return Collections.singletonMap(getParameters().getStorageDomainId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return null;
}
#end_block

#method_before
protected void fillMacAddressIfMissing(VmNic iface) {
    if (StringUtils.isEmpty(iface.getMacAddress()) && getMacPool().getAvailableMacsCount() > 0) {
        iface.setMacAddress(getMacPool().allocateNewMac());
    }
}
#method_after
private void fillMacAddressIfMissing(VmNic iface) {
    if (StringUtils.isEmpty(iface.getMacAddress()) && getMacPool().getAvailableMacsCount() > 0) {
        iface.setMacAddress(getMacPool().allocateNewMac());
    }
}
#end_block

#method_before
private Map<String, Object> initDriveData() {
    Map<String, Object> drive = new HashMap<String, Object>();
    Disk disk = getParameters().getDisk();
    VmDevice vmDevice = getParameters().getVmDevice();
    drive.put(VdsProperties.Type, VmDeviceType.DISK.getName());
    addAddress(drive, getParameters().getVmDevice().getAddress());
    drive.put(VdsProperties.INTERFACE, disk.getDiskInterface().getName());
    drive.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(getParameters().getVm().getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
    drive.put(VdsProperties.Optional, Boolean.FALSE.toString());
    drive.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
    drive.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) disk;
        drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
        drive.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
        drive.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
        drive.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
        drive.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
        drive.put(VdsProperties.ImageId, diskImage.getId().toString());
        drive.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
        // maps to avoid fetching qos object for same disk profile id
        Map<Guid, Guid> diskProfileStorageQosMap = new HashMap<>();
        Map<Guid, Map<String, Integer>> storageQosIoTuneMap = new HashMap<>();
        Map<String, Integer> ioTune = VmInfoBuilder.buildIoTune(diskImage, diskProfileStorageQosMap, storageQosIoTuneMap);
        if (ioTune != null) {
            if (vmDevice.getSpecParams() == null) {
                vmDevice.setSpecParams(new HashMap<String, Object>());
            }
            vmDevice.getSpecParams().put(VdsProperties.Iotune, ioTune);
            drive.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        }
    } else {
        LunDisk lunDisk = (LunDisk) disk;
        // If SCSI pass-through is enabled (VirtIO-SCSI/DirectLUN disk and SGIO is defined),
        // set device type as 'lun' (instead of 'disk') and set the specified SGIO
        boolean isVirtioScsi = getParameters().getDisk().getDiskInterface() == DiskInterface.VirtIO_SCSI;
        boolean isScsiPassthrough = getParameters().getDisk().isScsiPassthrough();
        if (isVirtioScsi) {
            if (isScsiPassthrough) {
                drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                drive.put(VdsProperties.Sgio, getParameters().getDisk().getSgio().toString().toLowerCase());
            } else {
                drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            }
        } else {
            drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
        }
        drive.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
        drive.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
        drive.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
    }
    return drive;
}
#method_after
private Map<String, Object> initDriveData() {
    Map<String, Object> drive = new HashMap<String, Object>();
    Disk disk = getParameters().getDisk();
    VmDevice vmDevice = getParameters().getVmDevice();
    drive.put(VdsProperties.Type, VmDeviceType.DISK.getName());
    addAddress(drive, getParameters().getVmDevice().getAddress());
    drive.put(VdsProperties.INTERFACE, disk.getDiskInterface().getName());
    drive.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(getParameters().getVm().getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
    drive.put(VdsProperties.Optional, Boolean.FALSE.toString());
    drive.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
    drive.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) disk;
        drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
        drive.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
        drive.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
        drive.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
        drive.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
        drive.put(VdsProperties.ImageId, diskImage.getId().toString());
        drive.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
        VmInfoBuilder.handleIoTune(getParameters().getVm(), vmDevice, diskImage, new HashMap<Guid, Guid>(), new HashMap<Guid, Map<String, Long>>());
        if (vmDevice.getSpecParams() != null) {
            drive.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        }
    } else {
        LunDisk lunDisk = (LunDisk) disk;
        // If SCSI pass-through is enabled (VirtIO-SCSI/DirectLUN disk and SGIO is defined),
        // set device type as 'lun' (instead of 'disk') and set the specified SGIO
        boolean isVirtioScsi = getParameters().getDisk().getDiskInterface() == DiskInterface.VirtIO_SCSI;
        boolean isScsiPassthrough = getParameters().getDisk().isScsiPassthrough();
        if (isVirtioScsi) {
            if (isScsiPassthrough) {
                drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                drive.put(VdsProperties.Sgio, getParameters().getDisk().getSgio().toString().toLowerCase());
            } else {
                drive.put(VdsProperties.Device, VmDeviceType.DISK.getName());
            }
        } else {
            drive.put(VdsProperties.Device, VmDeviceType.LUN.getName());
        }
        drive.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
        drive.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
        drive.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
    }
    return drive;
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    // map to avoid fetching qos object for same disk profile id
    Map<Guid, Guid> diskProfileStorageQosMap = new HashMap<>();
    Map<Guid, Map<String, Integer>> storageQosIoTuneMap = new HashMap<>();
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                if (FeatureSupported.storageQoS(vm.getVdsGroupCompatibilityVersion())) {
                    Map<String, Integer> ioTune = buildIoTune(diskImage, diskProfileStorageQosMap, storageQosIoTuneMap);
                    if (ioTune != null) {
                        if (vmDevice.getSpecParams() == null) {
                            vmDevice.setSpecParams(new HashMap<String, Object>());
                        }
                        vmDevice.getSpecParams().put(VdsProperties.Iotune, ioTune);
                    }
                }
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    // map to avoid fetching qos object for same disk profile id
    Map<Guid, Guid> diskProfileStorageQosMap = new HashMap<>();
    Map<Guid, Map<String, Long>> storageQosIoTuneMap = new HashMap<>();
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                handleIoTune(vm, vmDevice, diskImage, diskProfileStorageQosMap, storageQosIoTuneMap);
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
static Map<String, Integer> buildIoTune(DiskImage diskImage, Map<Guid, Guid> diskProfileStorageQosMap, Map<Guid, Map<String, Integer>> storageQosIoTuneMap) {
    Guid diskProfileId = diskImage.getDiskProfileId();
    if (diskProfileId == null) {
        return null;
    }
    Guid storageQosId = diskProfileStorageQosMap.get(diskProfileId);
    if (storageQosId == null) {
        StorageQos storageQos = DbFacade.getInstance().getStorageQosDao().getQosByDiskProfileId(diskProfileId);
        if (storageQos == null) {
            return null;
        }
        storageQosId = storageQos.getId();
        diskProfileStorageQosMap.put(diskProfileId, storageQosId);
        storageQosIoTuneMap.put(storageQosId, buildIoTuneMap(storageQos));
    }
    Map<String, Integer> ioTuneMap = storageQosIoTuneMap.get(storageQosId);
    // return map with values
    if (!ioTuneMap.isEmpty()) {
        return ioTuneMap;
    }
    return null;
}
#method_after
private static Map<String, Long> buildIoTune(DiskImage diskImage, Map<Guid, Guid> diskProfileStorageQosMap, Map<Guid, Map<String, Long>> storageQosIoTuneMap) {
    Guid diskProfileId = diskImage.getDiskProfileId();
    if (diskProfileId == null) {
        return null;
    }
    Guid storageQosId = diskProfileStorageQosMap.get(diskProfileId);
    if (storageQosId == null) {
        StorageQos storageQos = DbFacade.getInstance().getStorageQosDao().getQosByDiskProfileId(diskProfileId);
        if (storageQos == null) {
            return null;
        }
        storageQosId = storageQos.getId();
        diskProfileStorageQosMap.put(diskProfileId, storageQosId);
        storageQosIoTuneMap.put(storageQosId, buildIoTuneMap(storageQos));
    }
    Map<String, Long> ioTuneMap = storageQosIoTuneMap.get(storageQosId);
    // return map with values
    if (!ioTuneMap.isEmpty()) {
        return ioTuneMap;
    }
    return null;
}
#end_block

#method_before
private static Map<String, Integer> buildIoTuneMap(StorageQos storageQos) {
    // build map
    Map<String, Integer> ioTuneMap = new HashMap<>();
    if (storageQos.getMaxThroughput() != null) {
        // Convert MiB/s to B/s vdsm is expecting
        ioTuneMap.put(VdsProperties.TotalBytesSec, storageQos.getMaxThroughput() * 1024 * 1024);
    }
    if (storageQos.getMaxReadThroughput() != null) {
        // Convert MiB/s to B/s vdsm is expecting
        ioTuneMap.put(VdsProperties.ReadBytesSec, storageQos.getMaxReadThroughput() * 1024 * 1024);
    }
    if (storageQos.getMaxWriteThroughput() != null) {
        // Convert MiB/s to B/s vdsm is expecting
        ioTuneMap.put(VdsProperties.WriteBytesSec, storageQos.getMaxWriteThroughput() * 1024 * 1024);
    }
    if (storageQos.getMaxIops() != null) {
        ioTuneMap.put(VdsProperties.TotalIopsSec, storageQos.getMaxIops());
    }
    if (storageQos.getMaxReadIops() != null) {
        ioTuneMap.put(VdsProperties.ReadIopsSec, storageQos.getMaxReadIops());
    }
    if (storageQos.getMaxWriteIops() != null) {
        ioTuneMap.put(VdsProperties.WriteIopsSec, storageQos.getMaxWriteIops());
    }
    return ioTuneMap;
}
#method_after
private static Map<String, Long> buildIoTuneMap(StorageQos storageQos) {
    // build map
    Map<String, Long> ioTuneMap = new HashMap<>();
    if (storageQos.getMaxThroughput() != null) {
        // Convert MiB/s to B/s vdsm is expecting
        ioTuneMap.put(VdsProperties.TotalBytesSec, storageQos.getMaxThroughput() * 1024 * 1024L);
    }
    if (storageQos.getMaxReadThroughput() != null) {
        // Convert MiB/s to B/s vdsm is expecting
        ioTuneMap.put(VdsProperties.ReadBytesSec, storageQos.getMaxReadThroughput() * 1024 * 1024L);
    }
    if (storageQos.getMaxWriteThroughput() != null) {
        // Convert MiB/s to B/s vdsm is expecting
        ioTuneMap.put(VdsProperties.WriteBytesSec, storageQos.getMaxWriteThroughput() * 1024 * 1024L);
    }
    if (storageQos.getMaxIops() != null) {
        ioTuneMap.put(VdsProperties.TotalIopsSec, storageQos.getMaxIops().longValue());
    }
    if (storageQos.getMaxReadIops() != null) {
        ioTuneMap.put(VdsProperties.ReadIopsSec, storageQos.getMaxReadIops().longValue());
    }
    if (storageQos.getMaxWriteIops() != null) {
        ioTuneMap.put(VdsProperties.WriteIopsSec, storageQos.getMaxWriteIops().longValue());
    }
    return ioTuneMap;
}
#end_block

#method_before
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(SYSPREP_FILE_NAME, Base64.encodeBase64String(sysPrepContent.getBytes()));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#method_after
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(getOsRepository().getSysprepFileName(vm.getOs(), vm.getVdsGroupCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#end_block

#method_before
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), Base64.encodeBase64String(entry.getValue()));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#method_after
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), new String(BASE_64.encode(entry.getValue()), Charset.forName(CharEncoding.UTF_8)));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#end_block

#method_before
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VNIC_PROFILE_PROPERTIES> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debugFormat("VNIC {0} is using profile {1} on network {2}", nic.getName(), vnicProfile, networkName);
            if (!addQosForDevice(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion())) {
                unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.NETWORK_QOS);
            }
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    if (!addPortMirroringToVmInterface(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion(), network)) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.PORT_MIRRORING);
    }
    if (!addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile))) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.CUSTOM_PROPERTIES);
    }
    reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
}
#method_after
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VNIC_PROFILE_PROPERTIES> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debug("VNIC '{}' is using profile '{}' on network '{}'", nic.getName(), vnicProfile, networkName);
            if (!addQosForDevice(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion())) {
                unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.NETWORK_QOS);
            }
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    if (!addPortMirroringToVmInterface(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion(), network)) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.PORT_MIRRORING);
    }
    if (!addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile))) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.CUSTOM_PROPERTIES);
    }
    reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
}
#end_block

#method_before
private void adjustDisksImageConfiguration(Collection<DiskImage> diskImages) {
    for (DiskImage diskImage : diskImages) {
        // Adjust disk image configuration if needed.
        if (destStorages.get(diskInfoDestinationMap.get(diskImage.getId()).getStorageIds().get(0)).getStorageStaticData().getStorageType().isBlockDomain() && diskImage.getVolumeFormat().equals(VolumeFormat.RAW)) {
            diskImage.setvolumeFormat(VolumeFormat.COW);
        }
    }
}
#method_after
private void adjustDisksImageConfiguration(Collection<DiskImage> diskImages) {
    for (DiskImage diskImage : diskImages) {
        // Adjust disk image configuration if needed.
        if (diskImage.getVolumeType().equals(VolumeType.Sparse) && diskImage.getVolumeFormat().equals(VolumeFormat.RAW) && getDestintationDomainTypeFromDisk(diskImage).isBlockDomain()) {
            diskImage.setvolumeFormat(VolumeFormat.COW);
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    SnapshotsValidator snapshotsValidator = createSnapshotsValidator();
    // If snapshot does not exist, there is not point in checking any of the VM related checks
    if (!validate(snapshotsValidator.snapshotExists(getSnapshot())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getSnapshot().getVmId()))) {
        return false;
    }
    vmFromConfiguration = getVmFromConfiguration();
    if (vmFromConfiguration == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION);
        addCanDoActionMessageVariable("VmName", getVmName());
        addCanDoActionMessageVariable("SnapshotName", getSnapshotName());
        return false;
    }
    VmValidator vmValidator = createVmValidator(vmFromConfiguration);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(getDiskImagesFromConfiguration()))) {
        return false;
    }
    if (!super.canDoAction()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    SnapshotsValidator snapshotsValidator = createSnapshotsValidator();
    // If snapshot does not exist, there is not point in checking any of the VM related checks
    if (!validate(snapshotsValidator.snapshotExists(getSnapshot())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getSnapshot().getVmId()))) {
        return false;
    }
    vmFromConfiguration = getVmFromConfiguration();
    if (vmFromConfiguration == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION);
        addCanDoActionMessageVariable("VmName", getVmName());
        addCanDoActionMessageVariable("SnapshotName", getSnapshotName());
        return false;
    }
    VmValidator vmValidator = createVmValidator(vmFromConfiguration);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(getAdjustedDiskImagesFromConfiguration()))) {
        return false;
    }
    if (!super.canDoAction()) {
        return false;
    }
    return true;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static <P extends VdcActionParametersBase> CommandBase<P> createCommand(VdcActionType action, P parameters, CommandContext commandContext) {
    try {
        CommandBase<P> result;
        if (commandContext == null) {
            result = (CommandBase<P>) findCommandConstructor(getCommandClass(action.name(), CommandSuffix), parameters.getClass()).newInstance(parameters);
        } else {
            result = (CommandBase<P>) findCommandConstructor(getCommandClass(action.name(), CommandSuffix), parameters.getClass(), commandContext.getClass()).newInstance(parameters, commandContext);
        }
        Injector.injectMembers(result);
        return result;
    } catch (InvocationTargetException ex) {
        log.error("Error in invocating CTOR of command " + action.name() + ". Exception is ", ex);
        return null;
    } catch (Exception ex) {
        log.error("An exception has occured while trying to create a command object for command " + action.name(), ex);
        return null;
    }
}
#method_after
public static <P extends VdcActionParametersBase> CommandBase<P> createCommand(VdcActionType action, P parameters, CommandContext commandContext) {
    try {
        return Injector.injectMembers(instantiateCommand(action, parameters, commandContext));
    } catch (InvocationTargetException ex) {
        log.error("Error in invocating CTOR of command '{}': {}", action.name(), ex.getMessage());
        log.debug("Exception", ex);
        return null;
    } catch (Exception ex) {
        log.error("An exception has occured while trying to create a command object for command '{}': {}", action.name(), ex.getMessage());
        log.debug("Exception", ex);
        return null;
    }
}
#end_block

#method_before
public static CommandBase<?> createCommand(String className, Guid commandId) {
    Constructor<?> constructor = null;
    Boolean isAcessible = null;
    try {
        constructor = Class.forName(className).getDeclaredConstructor(Guid.class);
        // since this constructor is defined as protected, we must modify accessability and restore it afterwards
        if (!constructor.isAccessible()) {
            isAcessible = constructor.isAccessible();
            constructor.setAccessible(true);
        }
        CommandBase<?> cmd = (CommandBase<?>) constructor.newInstance(commandId);
        Injector.injectMembers(cmd);
        return cmd;
    } catch (Exception e) {
        log.error("CommandsFactory : Failed to get type information using " + "reflection for Class : " + className + ", Command Id:" + commandId, e);
        return null;
    } finally {
        if (isAcessible != null) {
            constructor.setAccessible(isAcessible);
        }
    }
}
#method_after
public static CommandBase<?> createCommand(String className, Guid commandId) {
    Constructor<?> constructor = null;
    Boolean isAcessible = null;
    try {
        constructor = Class.forName(className).getDeclaredConstructor(Guid.class);
        // since this constructor is defined as protected, we must modify accessability and restore it afterwards
        if (!constructor.isAccessible()) {
            isAcessible = constructor.isAccessible();
            constructor.setAccessible(true);
        }
        CommandBase<?> cmd = (CommandBase<?>) constructor.newInstance(commandId);
        return Injector.injectMembers(cmd);
    } catch (Exception e) {
        log.error("CommandsFactory : Failed to get type information using reflection for Class  '{}', Command Id '{}': {}", className, commandId, e.getMessage());
        log.error("Exception", e);
        return null;
    } finally {
        if (isAcessible != null) {
            constructor.setAccessible(isAcessible);
        }
    }
}
#end_block

#method_before
public static QueriesCommandBase<?> createQueryCommand(VdcQueryType query, VdcQueryParametersBase parameters, EngineContext engineContext) {
    Class<?> type = null;
    try {
        type = getCommandClass(query.name(), QueryPrefix);
        QueriesCommandBase<?> result;
        if (engineContext == null) {
            result = (QueriesCommandBase<?>) findCommandConstructor(type, parameters.getClass()).newInstance(parameters);
        } else {
            result = (QueriesCommandBase<?>) findCommandConstructor(type, parameters.getClass(), EngineContext.class).newInstance(parameters, engineContext);
        }
        return result;
    } catch (Exception e) {
        log.errorFormat("Command Factory: Failed to create command {0} using reflection\n. {1}", type, e);
        throw new RuntimeException(e);
    }
}
#method_after
public static QueriesCommandBase<?> createQueryCommand(VdcQueryType query, VdcQueryParametersBase parameters, EngineContext engineContext) {
    Class<?> type = null;
    try {
        type = getCommandClass(query.name(), QueryPrefix);
        QueriesCommandBase<?> result;
        if (engineContext == null) {
            result = (QueriesCommandBase<?>) findCommandConstructor(type, parameters.getClass()).newInstance(parameters);
        } else {
            result = (QueriesCommandBase<?>) findCommandConstructor(type, parameters.getClass(), EngineContext.class).newInstance(parameters, engineContext);
        }
        return result;
    } catch (Exception e) {
        log.error("Command Factory: Failed to create command '{}' using reflection: {}", type, e.getMessage());
        log.error("Exception", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private static Class<CommandBase<? extends VdcActionParametersBase>> getCommandClass(String name, String suffix) {
    // try the cache first
    String key = name + suffix;
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = commandsCache.get(key);
    if (clazz != null) {
        return clazz;
    }
    for (String commandPackage : COMMAND_PACKAGES) {
        String className = String.format(CLASS_NAME_FORMAT, commandPackage, name, suffix);
        Class<CommandBase<? extends VdcActionParametersBase>> type = loadClass(className);
        if (type != null) {
            // update cache
            Class<CommandBase<? extends VdcActionParametersBase>> cachedType = commandsCache.putIfAbsent(key, type);
            return cachedType == null ? type : cachedType;
        }
    }
    // nothing found
    log.warn("Unable to find class for action: " + key);
    return null;
}
#method_after
private static Class<CommandBase<? extends VdcActionParametersBase>> getCommandClass(String name, String suffix) {
    // try the cache first
    String key = name + suffix;
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = commandsCache.get(key);
    if (clazz != null) {
        return clazz;
    }
    for (String commandPackage : COMMAND_PACKAGES) {
        String className = String.format(CLASS_NAME_FORMAT, commandPackage, name, suffix);
        Class<CommandBase<? extends VdcActionParametersBase>> type = loadClass(className);
        if (type != null) {
            // update cache
            Class<CommandBase<? extends VdcActionParametersBase>> cachedType = commandsCache.putIfAbsent(key, type);
            return cachedType == null ? type : cachedType;
        }
    }
    // nothing found
    log.warn("Unable to find class for action '{}'", key);
    return null;
}
#end_block

#method_before
private static <T> Constructor<T> findCommandConstructor(Class<T> type, Class<?>... expectedParams) {
    Constructor<T> constructor = ReflectionUtils.findConstructor(type, expectedParams);
    if (constructor == null) {
        log.errorFormat(CTOR_NOT_FOUND_FOR_PARAMETERS, type.getName(), Arrays.toString(expectedParams));
        throw new RuntimeException(MessageFormat.format(CTOR_MISMATCH, type));
    }
    return constructor;
}
#method_after
private static <T> Constructor<T> findCommandConstructor(Class<T> type, Class<?>... expectedParams) {
    Constructor<T> constructor = ReflectionUtils.findConstructor(type, expectedParams);
    if (constructor == null) {
        log.error(CTOR_NOT_FOUND_FOR_PARAMETERS, type.getName(), Arrays.toString(expectedParams));
        throw new RuntimeException(MessageFormat.format(CTOR_MISMATCH, type));
    }
    return constructor;
}
#end_block

#method_before
@Override
protected StorageDomain addParents(StorageDomain storageDomain) {
    // This is for backwards compatibility and will be removed in the future:
    storageDomain.setDataCenter(new DataCenter());
    storageDomain.getDataCenter().setId(dataCenterId.toString());
    // Find all the data centers that this storage domain is attached to and add references to them:
    List<Guid> dataCenterIds = StorageDomainHelper.getAttachedDataCenters(this, guid);
    if (!CollectionUtils.isEmpty(dataCenterIds)) {
        DataCenters dataCenters = new DataCenters();
        for (Guid dataCenterId : dataCenterIds) {
            DataCenter dataCenter = new DataCenter();
            dataCenter.setId(dataCenterId.toString());
            dataCenters.getDataCenters().add(dataCenter);
        }
        storageDomain.setDataCenters(dataCenters);
    }
    return storageDomain;
}
#method_after
@Override
protected StorageDomain addParents(StorageDomain storageDomain) {
    // This is for backwards compatibility and will be removed in the future:
    storageDomain.setDataCenter(new DataCenter());
    storageDomain.getDataCenter().setId(dataCenterId.toString());
    // Find all the data centers that this storage domain is attached to and add references to them:
    StorageDomainHelper.addAttachedDataCenterReferences(this, storageDomain);
    return storageDomain;
}
#end_block

#method_before
@Override
protected StorageDomain addParents(StorageDomain model) {
    // Find all the data centers that this storage domain is attached to and add references to them:
    List<Guid> dataCenterIds = StorageDomainHelper.getAttachedDataCenters(this, guid);
    if (!CollectionUtils.isEmpty(dataCenterIds)) {
        DataCenters dataCenters = new DataCenters();
        for (Guid dataCenterId : dataCenterIds) {
            DataCenter dataCenter = new DataCenter();
            dataCenter.setId(dataCenterId.toString());
            dataCenters.getDataCenters().add(dataCenter);
        }
        model.setDataCenters(dataCenters);
    }
    return model;
}
#method_after
@Override
protected StorageDomain addParents(StorageDomain model) {
    StorageDomainHelper.addAttachedDataCenterReferences(this, model);
    return model;
}
#end_block

#method_before
@Override
protected StorageDomain addParents(StorageDomain model) {
    // Find all the data centers that this storage domain is attached to and add references to them:
    Guid storageDomainId = Guid.createGuidFromString(model.getId());
    List<Guid> dataCenterIds = StorageDomainHelper.getAttachedDataCenters(this, storageDomainId);
    if (!CollectionUtils.isEmpty(dataCenterIds)) {
        DataCenters dataCenters = new DataCenters();
        for (Guid dataCenterId : dataCenterIds) {
            DataCenter dataCenter = new DataCenter();
            dataCenter.setId(dataCenterId.toString());
            dataCenters.getDataCenters().add(dataCenter);
        }
        model.setDataCenters(dataCenters);
    }
    return model;
}
#method_after
@Override
protected StorageDomain addParents(StorageDomain model) {
    StorageDomainHelper.addAttachedDataCenterReferences(this, model);
    return model;
}
#end_block

#method_before
@Override
protected StorageDomain addParents(StorageDomain storageDomain) {
    // This is for backwards compatibility and will be removed in the future:
    storageDomain.setDataCenter(new DataCenter());
    storageDomain.getDataCenter().setId(dataCenterId.toString());
    // Find all the data centers that this storage domain is attached to and add references to them:
    Guid storageDomainId = Guid.createGuidFromString(storageDomain.getId());
    List<Guid> dataCenterIds = StorageDomainHelper.getAttachedDataCenters(this, storageDomainId);
    if (!CollectionUtils.isEmpty(dataCenterIds)) {
        DataCenters dataCenters = new DataCenters();
        for (Guid dataCenterId : dataCenterIds) {
            DataCenter dataCenter = new DataCenter();
            dataCenter.setId(dataCenterId.toString());
            dataCenters.getDataCenters().add(dataCenter);
        }
        storageDomain.setDataCenters(dataCenters);
    }
    return storageDomain;
}
#method_after
@Override
protected StorageDomain addParents(StorageDomain storageDomain) {
    // This is for backwards compatibility and will be removed in the future:
    storageDomain.setDataCenter(new DataCenter());
    storageDomain.getDataCenter().setId(dataCenterId.toString());
    // Find all the data centers that this storage domain is attached to and add references to them:
    StorageDomainHelper.addAttachedDataCenterReferences(this, storageDomain);
    return storageDomain;
}
#end_block

#method_before
public void setQos(HostNetworkQos qos) {
    this.qos = qos;
}
#method_after
public void setQos(HostNetworkQos qos) {
    if (qos != null) {
        assert qos.getName() == null : "Overriding QoS entity must not be named!";
        assert qos.getStoragePoolId() == null : "Overriding QoS entity must not be linked to a specific DC!";
    }
    this.qos = qos;
}
#end_block

#method_before
@Override
public int compare(AuditLog x, AuditLog y) {
    long xid = x.getaudit_log_id();
    long yid = y.getaudit_log_id();
    return Long.valueOf(xid).compareTo(yid);
}
#method_after
@Override
public int compare(AuditLog x, AuditLog y) {
    long xid = x.getAuditLogId();
    long yid = y.getAuditLogId();
    return Long.valueOf(xid).compareTo(yid);
}
#end_block

#method_before
@Override
public boolean match(DbGroup source) {
    String groupName = source.getName().toLowerCase();
    String targetName = target.getName();
    if (!StringHelper.isNullOrEmpty(targetName)) {
        targetName = targetName.toLowerCase();
    }
    // $NON-NLS-1$
    int lastIndex = groupName.lastIndexOf("/");
    if (lastIndex != -1) {
        groupName = groupName.substring(lastIndex + 1);
    }
    return ObjectUtils.objectsEqual(source.getDomain(), target.getDomain()) && (StringHelper.isNullOrEmpty(target.getName()) || // $NON-NLS-1$
    "*".equals(target.getName()) || groupName.startsWith(targetName)) || source.getName().toLowerCase().startsWith(targetName);
}
#method_after
@Override
public boolean match(DbGroup source) {
    String groupName = source.getName().toLowerCase();
    String targetName = target.getName();
    if (!StringHelper.isNullOrEmpty(targetName)) {
        targetName = targetName.toLowerCase();
    } else if (targetName == null) {
        targetName = "";
    }
    // $NON-NLS-1$
    int lastIndex = groupName.lastIndexOf("/");
    if (lastIndex != -1) {
        groupName = groupName.substring(lastIndex + 1);
    }
    return ObjectUtils.objectsEqual(source.getDomain(), target.getDomain()) && (StringHelper.isNullOrEmpty(target.getName()) || // $NON-NLS-1$
    "*".equals(target.getName()) || groupName.startsWith(targetName)) || source.getName().toLowerCase().startsWith(targetName);
}
#end_block

#method_before
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#method_after
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChainText, new ProviderQueryParameters(provider), aQuery);
}
#end_block

#method_before
private ArrayList<VDSGroup> getClusterByServiceList(ArrayList<VDSGroup> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<VDSGroup> filteredList = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#method_after
public ArrayList<VDSGroup> getClusterByServiceList(List<VDSGroup> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<VDSGroup> filteredList = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#end_block

#method_before
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        // currently on VDSM side reboot is supported only when the guest agent is present and responsive so we need to check for that
        if (!isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion) || StringHelper.isNullOrEmpty(vm.getVmIp())) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        boolean compatibleCluster = isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion);
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getVmIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(compatibleCluster && (guestAgentPresent || acpiEnabled))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Test
public void qosValuesModified() {
    Network network = createNetwork(MANAGEMENT_NETWORK_NAME);
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    iface.setQosOverridden(true);
    mockExistingIfaces(iface);
    iface.setQos(createQos());
    SetupNetworksHelper helper = createHelper(createParametersForNics(iface), Version.v3_4);
    validateAndAssertNetworkModified(helper, network);
}
#method_after
@Test
public void qosValuesModified() {
    Network network = createNetwork(MANAGEMENT_NETWORK_NAME);
    SetupNetworksHelper helper = qosValuesTest(network, createQos());
    validateAndAssertNetworkModified(helper, network);
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    HostNetworkQosDao qosDao = getDbFacade().getHostNetworkQosDao();
    VDS host = getDbFacade().getVdsDao().get(getParameters().getVdsId());
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(host.getVdsGroupCompatibilityVersion());
    Set<Version> supportedClusterVersionsSet = host.getSupportedClusterVersionsSet();
    boolean supportedClusterVersionsAvailable = supportedClusterVersionsSet != null && supportedClusterVersionsSet.isEmpty();
    if (!supportedClusterVersionsAvailable) {
        log.warnFormat("Host {0} ({1}) doesn't contain Supported Cluster Versions, therefore 'defaultRoute'" + " will not be sent via the SetupNetworks", host.getName(), host.getId());
    }
    boolean defaultRouteSupported = supportedClusterVersionsAvailable && FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet));
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", NetworkUtils.getDefaultMtu().toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (hostNetworkQosSupported && qosConfiguredOnInterface(iface, network)) {
            HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(opts);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        if (defaultRouteSupported && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.hasCustomProperties()) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    HostNetworkQosDao qosDao = getDbFacade().getHostNetworkQosDao();
    VDS host = getParameters().getVds();
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(host.getVdsGroupCompatibilityVersion());
    Set<Version> supportedClusterVersionsSet = host.getSupportedClusterVersionsSet();
    boolean supportedClusterVersionsAvailable = supportedClusterVersionsSet != null && supportedClusterVersionsSet.isEmpty();
    if (!supportedClusterVersionsAvailable) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, therefore 'defaultRoute'" + " will not be sent via the SetupNetworks", host.getName(), host.getId());
    }
    boolean defaultRouteSupported = supportedClusterVersionsAvailable && FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet));
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", NetworkUtils.getDefaultMtu().toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (hostNetworkQosSupported && qosConfiguredOnInterface(iface, network)) {
            HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(opts);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        if (defaultRouteSupported && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.hasCustomProperties()) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
private static boolean isQosInSync(VdsNetworkInterface iface, HostNetworkQos networkQos) {
    HostNetworkQos ifaceQos = iface.getQos();
    if (ifaceQos == networkQos) {
        return true;
    } else if (ifaceQos == null || networkQos == null) {
        return false;
    } else {
        return ifaceQos.equalValues(networkQos);
    }
}
#method_after
private static boolean isQosInSync(VdsNetworkInterface iface, HostNetworkQos networkQos) {
    HostNetworkQos ifaceQos = iface.getQos();
    return qosParametersEqual(ifaceQos, networkQos);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getNetwork()) {
        network_SelectedItemChanged(null);
    } else if (sender == getQosOverridden()) {
        getQosModel().setIsChangable(getQosOverridden().getEntity());
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getNetwork()) {
        network_SelectedItemChanged(null);
    } else if (sender == getQosOverridden()) {
        updateQosChangeability();
    }
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<NetworkView, NetworkListModel> getNetworkListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<NewNetworkPopupPresenterWidget> newNetworkPopupProvider, final Provider<ImportNetworksPopupPresenterWidget> importNetworkPopupProvider, final Provider<EditNetworkPopupPresenterWidget> editNetworkPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<HostNetworkQosPopupPresenterWidget> addQosPopupProvider) {
    return new MainTabModelProvider<NetworkView, NetworkListModel>(eventBus, defaultConfirmPopupProvider, NetworkListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(NetworkListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (windowModel instanceof NewHostNetworkQosModel) {
                return addQosPopupProvider.get();
            }
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return newNetworkPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getImportCommand()) {
                return importNetworkPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return editNetworkPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(NetworkListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<NetworkView, NetworkListModel> getNetworkListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<NewNetworkPopupPresenterWidget> newNetworkPopupProvider, final Provider<ImportNetworksPopupPresenterWidget> importNetworkPopupProvider, final Provider<EditNetworkPopupPresenterWidget> editNetworkPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<HostNetworkQosPopupPresenterWidget> addQosPopupProvider, final Provider<NetworkListModel> modelProvider, final Provider<CommonModel> commonModelProvider) {
    MainTabModelProvider<NetworkView, NetworkListModel> result = new MainTabModelProvider<NetworkView, NetworkListModel>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(NetworkListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (windowModel instanceof NewHostNetworkQosModel) {
                return addQosPopupProvider.get();
            }
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return newNetworkPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getImportCommand()) {
                return importNetworkPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return editNetworkPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(NetworkListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
// Form Detail Models
@Provides
@Singleton
public DetailModelProvider<NetworkListModel, NetworkGeneralModel> getNetworkGeneralProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider) {
    return new DetailTabModelProvider<NetworkListModel, NetworkGeneralModel>(eventBus, defaultConfirmPopupProvider, NetworkListModel.class, NetworkGeneralModel.class);
}
#method_after
// Form Detail Models
@Provides
@Singleton
public DetailModelProvider<NetworkListModel, NetworkGeneralModel> getNetworkGeneralProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<NetworkListModel> mainModelProvider, final Provider<NetworkGeneralModel> modelProvider) {
    DetailTabModelProvider<NetworkListModel, NetworkGeneralModel> result = new DetailTabModelProvider<NetworkListModel, NetworkGeneralModel>(eventBus, defaultConfirmPopupProvider);
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
// Searchable Detail Models
@Provides
@Singleton
public SearchableDetailModelProvider<VnicProfileView, NetworkListModel, NetworkProfileListModel> getNetworkProfileListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VnicProfilePopupPresenterWidget> newProfilePopupProvider, final Provider<VnicProfilePopupPresenterWidget> editProfilePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<VnicProfileView, NetworkListModel, NetworkProfileListModel>(eventBus, defaultConfirmPopupProvider, NetworkListModel.class, NetworkProfileListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(NetworkProfileListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return newProfilePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return editProfilePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(NetworkProfileListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                // $NON-NLS-1$
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
// Searchable Detail Models
@Provides
@Singleton
public SearchableDetailModelProvider<VnicProfileView, NetworkListModel, NetworkProfileListModel> getNetworkProfileListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VnicProfilePopupPresenterWidget> newProfilePopupProvider, final Provider<VnicProfilePopupPresenterWidget> editProfilePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<NetworkListModel> mainModelProvider, final Provider<NetworkProfileListModel> modelProvider) {
    SearchableDetailTabModelProvider<VnicProfileView, NetworkListModel, NetworkProfileListModel> result = new SearchableDetailTabModelProvider<VnicProfileView, NetworkListModel, NetworkProfileListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(NetworkProfileListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return newProfilePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return editProfilePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(NetworkProfileListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                // $NON-NLS-1$
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<ExternalSubnet, NetworkListModel, NetworkExternalSubnetListModel> getExternalSubnetListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<ExternalSubnetPopupPresenterWidget> newExternalSubnetPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<ExternalSubnet, NetworkListModel, NetworkExternalSubnetListModel>(eventBus, defaultConfirmPopupProvider, NetworkListModel.class, NetworkExternalSubnetListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(NetworkExternalSubnetListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return newExternalSubnetPopupProvider.get();
            }
            return super.getModelPopup(source, lastExecutedCommand, windowModel);
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(NetworkExternalSubnetListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                // $NON-NLS-1$
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<ExternalSubnet, NetworkListModel, NetworkExternalSubnetListModel> getExternalSubnetListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<ExternalSubnetPopupPresenterWidget> newExternalSubnetPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<NetworkListModel> mainModelProvider, final Provider<NetworkExternalSubnetListModel> modelProvider) {
    SearchableDetailTabModelProvider<ExternalSubnet, NetworkListModel, NetworkExternalSubnetListModel> result = new SearchableDetailTabModelProvider<ExternalSubnet, NetworkListModel, NetworkExternalSubnetListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(NetworkExternalSubnetListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return newExternalSubnetPopupProvider.get();
            }
            return super.getModelPopup(source, lastExecutedCommand, windowModel);
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(NetworkExternalSubnetListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                // $NON-NLS-1$
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<PairQueryable<VDSGroup, NetworkCluster>, NetworkListModel, NetworkClusterListModel> getNetworkClusterListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<ClusterManageNetworkPopupPresenterWidget> managePopupProvider) {
    return new SearchableDetailTabModelProvider<PairQueryable<VDSGroup, NetworkCluster>, NetworkListModel, NetworkClusterListModel>(eventBus, defaultConfirmPopupProvider, NetworkListModel.class, NetworkClusterListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(NetworkClusterListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getManageCommand()) {
                return managePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<PairQueryable<VDSGroup, NetworkCluster>, NetworkListModel, NetworkClusterListModel> getNetworkClusterListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<ClusterManageNetworkPopupPresenterWidget> managePopupProvider, final Provider<NetworkListModel> mainModelProvider, final Provider<NetworkClusterListModel> modelProvider) {
    SearchableDetailTabModelProvider<PairQueryable<VDSGroup, NetworkCluster>, NetworkListModel, NetworkClusterListModel> result = new SearchableDetailTabModelProvider<PairQueryable<VDSGroup, NetworkCluster>, NetworkListModel, NetworkClusterListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(NetworkClusterListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getManageCommand()) {
                return managePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<PairQueryable<VdsNetworkInterface, VDS>, NetworkListModel, NetworkHostListModel> getNetworkHostListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<SetupNetworksBondPopupPresenterWidget> setupNetworksBondPopupProvider, final Provider<SetupNetworksInterfacePopupPresenterWidget> setupNetworksInterfacePopupProvider, final Provider<SetupNetworksManagementPopupPresenterWidget> setupNetworksManagementPopupProvider, final Provider<HostNicPopupPresenterWidget> hostNicPopupProvider, final Provider<HostSetupNetworksPopupPresenterWidget> hostSetupNetworksPopupProvider) {
    return new SearchableDetailTabModelProvider<PairQueryable<VdsNetworkInterface, VDS>, NetworkListModel, NetworkHostListModel>(eventBus, defaultConfirmPopupProvider, NetworkListModel.class, NetworkHostListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(NetworkHostListModel source, UICommand lastExecutedCommand, Model windowModel) {
            // Resolve by dialog model
            if (windowModel instanceof HostBondInterfaceModel) {
                return setupNetworksBondPopupProvider.get();
            } else if (windowModel instanceof HostManagementNetworkModel) {
                return setupNetworksManagementPopupProvider.get();
            } else if (windowModel instanceof HostInterfaceModel) {
                return setupNetworksInterfacePopupProvider.get();
            } else if (windowModel instanceof HostNicModel) {
                return hostNicPopupProvider.get();
            }
            // Resolve by last executed command
            if (lastExecutedCommand == getModel().getSetupNetworksCommand()) {
                return hostSetupNetworksPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<PairQueryable<VdsNetworkInterface, VDS>, NetworkListModel, NetworkHostListModel> getNetworkHostListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<SetupNetworksBondPopupPresenterWidget> setupNetworksBondPopupProvider, final Provider<SetupNetworksInterfacePopupPresenterWidget> setupNetworksInterfacePopupProvider, final Provider<SetupNetworksManagementPopupPresenterWidget> setupNetworksManagementPopupProvider, final Provider<HostNicPopupPresenterWidget> hostNicPopupProvider, final Provider<HostSetupNetworksPopupPresenterWidget> hostSetupNetworksPopupProvider, final Provider<NetworkListModel> mainModelProvider, final Provider<NetworkHostListModel> modelProvider) {
    SearchableDetailTabModelProvider<PairQueryable<VdsNetworkInterface, VDS>, NetworkListModel, NetworkHostListModel> result = new SearchableDetailTabModelProvider<PairQueryable<VdsNetworkInterface, VDS>, NetworkListModel, NetworkHostListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(NetworkHostListModel source, UICommand lastExecutedCommand, Model windowModel) {
            // Resolve by dialog model
            if (windowModel instanceof HostBondInterfaceModel) {
                return setupNetworksBondPopupProvider.get();
            } else if (windowModel instanceof HostManagementNetworkModel) {
                return setupNetworksManagementPopupProvider.get();
            } else if (windowModel instanceof HostInterfaceModel) {
                return setupNetworksInterfacePopupProvider.get();
            } else if (windowModel instanceof HostNicModel) {
                return hostNicPopupProvider.get();
            }
            // Resolve by last executed command
            if (lastExecutedCommand == getModel().getSetupNetworksCommand()) {
                return hostSetupNetworksPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<PairQueryable<VmNetworkInterface, VM>, NetworkListModel, NetworkVmListModel> getNetworkVmModelProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<PairQueryable<VmNetworkInterface, VM>, NetworkListModel, NetworkVmListModel>(eventBus, defaultConfirmPopupProvider, NetworkListModel.class, NetworkVmListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(NetworkVmListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<PairQueryable<VmNetworkInterface, VM>, NetworkListModel, NetworkVmListModel> getNetworkVmModelProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<NetworkListModel> mainModelProvider, final Provider<NetworkVmListModel> modelProvider) {
    SearchableDetailTabModelProvider<PairQueryable<VmNetworkInterface, VM>, NetworkListModel, NetworkVmListModel> result = new SearchableDetailTabModelProvider<PairQueryable<VmNetworkInterface, VM>, NetworkListModel, NetworkVmListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(NetworkVmListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<PairQueryable<VmNetworkInterface, VmTemplate>, NetworkListModel, NetworkTemplateListModel> geNetworkTemplateModelProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<PairQueryable<VmNetworkInterface, VmTemplate>, NetworkListModel, NetworkTemplateListModel>(eventBus, defaultConfirmPopupProvider, NetworkListModel.class, NetworkTemplateListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(NetworkTemplateListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<PairQueryable<VmNetworkInterface, VmTemplate>, NetworkListModel, NetworkTemplateListModel> geNetworkTemplateModelProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<NetworkListModel> mainModelProvider, final Provider<NetworkTemplateListModel> modelProvider) {
    SearchableDetailTabModelProvider<PairQueryable<VmNetworkInterface, VmTemplate>, NetworkListModel, NetworkTemplateListModel> result = new SearchableDetailTabModelProvider<PairQueryable<VmNetworkInterface, VmTemplate>, NetworkListModel, NetworkTemplateListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(NetworkTemplateListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
}
#method_after
@Override
protected void configure() {
    bind(NetworkListModel.class).in(Singleton.class);
    bind(NetworkGeneralModel.class).in(Singleton.class);
    bind(NetworkProfileListModel.class).in(Singleton.class);
    bind(NetworkExternalSubnetListModel.class).in(Singleton.class);
    bind(NetworkClusterListModel.class).in(Singleton.class);
    bind(NetworkHostListModel.class).in(Singleton.class);
    bind(NetworkVmListModel.class).in(Singleton.class);
    bind(NetworkTemplateListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<NetworkListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permissions, NetworkListModel, PermissionListModel<NetworkListModel>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<NetworkListModel>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
@Before
public void mockConfig() {
    HashSet<Version> supportedClusters = new HashSet<>();
    supportedClusters.add(version);
    when(host.getSupportedClusterVersionsSet()).thenReturn(supportedClusters);
    when(host.getVdsGroupCompatibilityVersion()).thenReturn(version);
    configRule.mockConfigValue(ConfigValues.DefaultRouteSupported, version, Boolean.FALSE);
    configRule.mockConfigValue(ConfigValues.DefaultMTU, 1500);
}
#method_after
@Before
public void mockConfig() {
    HashSet<Version> supportedClusters = new HashSet<>();
    supportedClusters.add(version);
    when(host.getSupportedClusterVersionsSet()).thenReturn(supportedClusters);
    when(host.getVdsGroupCompatibilityVersion()).thenReturn(version);
    configRule.mockConfigValue(ConfigValues.DefaultRouteSupported, version, Boolean.FALSE);
    configRule.mockConfigValue(ConfigValues.DefaultMTU, 1500);
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, false);
}
#end_block

#method_before
@Test
public void vlanOverNic() {
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.DHCP, null);
    VdsNetworkInterface vlan = createVlan(nic, net);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(nic), Collections.<String>emptySet(), Arrays.asList(nic, vlan));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
}
#method_after
@Test
public void vlanOverNic() {
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.DHCP, null);
    VdsNetworkInterface vlan = createVlan(nic, net);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(nic), Collections.<String>emptySet(), Arrays.asList(nic, vlan));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
}
#end_block

#method_before
@Test
public void vlanOverBond() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface vlan = createVlan(bond, net);
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(slaves);
    ifaces.add(bond);
    ifaces.add(vlan);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces);
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    assertBondWasSent(bond, slaves);
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(bond.getName(), networkStruct.get("bonding"));
}
#method_after
@Test
public void vlanOverBond() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface vlan = createVlan(bond, net);
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(slaves);
    ifaces.add(bond);
    ifaces.add(vlan);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces);
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    assertBondWasSent(bond, slaves);
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(bond.getName(), networkStruct.get("bonding"));
}
#end_block

#method_before
@Test
public void networkWithDhcp() {
    Network net = createNetwork(null);
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.DHCP, net.getName());
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(net), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Arrays.asList(nic));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
    assertEquals(SetupNetworksVDSCommand.DHCP_BOOT_PROTOCOL, networkStruct.get(SetupNetworksVDSCommand.BOOT_PROTOCOL));
}
#method_after
@Test
public void networkWithDhcp() {
    Network net = createNetwork(null);
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.DHCP, net.getName());
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(net), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Arrays.asList(nic));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
    assertEquals(SetupNetworksVDSCommand.DHCP_BOOT_PROTOCOL, networkStruct.get(SetupNetworksVDSCommand.BOOT_PROTOCOL));
}
#end_block

#method_before
@Test
public void bondModified() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(slaves);
    ifaces.add(bond);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.<Network>emptyList(), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces);
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> bondMap = assertBondWasSent(bond, slaves);
    assertEquals(bond.getBondOptions(), bondMap.get(SetupNetworksVDSCommand.BONDING_OPTIONS));
}
#method_after
@Test
public void bondModified() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(slaves);
    ifaces.add(bond);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.<Network>emptyList(), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces);
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> bondMap = assertBondWasSent(bond, slaves);
    assertEquals(bond.getBondOptions(), bondMap.get(SetupNetworksVDSCommand.BONDING_OPTIONS));
}
#end_block

#method_before
private void qos(Network network, VdsNetworkInterface iface, HostNetworkQos expectedQos, boolean hostNetworkQosSupported) {
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, hostNetworkQosSupported);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(networkStruct);
    assertTrue((Objects.equals(expectedQos, qosMapper.deserialize())));
}
#method_after
private void qos(Network network, VdsNetworkInterface iface, HostNetworkQos expectedQos, boolean hostNetworkQosSupported) {
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, hostNetworkQosSupported);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    HostNetworkQos result = new HostNetworkQosMapper(networkStruct).deserialize();
    assertTrue(NetworkUtils.qosParametersEqual(expectedQos, result));
}
#end_block

#method_before
private void qos(Network network, VdsNetworkInterface iface, HostNetworkQos expectedQos, boolean hostNetworkQosSupported) {
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, hostNetworkQosSupported);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(networkStruct);
    assertTrue((Objects.equals(expectedQos, qosMapper.deserialize())));
}
#method_after
private void qos(Network network, VdsNetworkInterface iface, HostNetworkQos expectedQos) {
    qos(network, iface, expectedQos, false);
}
#end_block

#method_before
@Test
public void qosNotSupported() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    when(qosDao.get(any(Guid.class))).thenReturn(createQos());
    qos(network, iface, null, false);
}
#method_after
@Test
public void qosNotSupported() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    when(qosDao.get(any(Guid.class))).thenReturn(createQos());
    qos(network, iface, null);
}
#end_block

#method_before
private HostNetworkQos createQos() {
    HostNetworkQos qos = new HostNetworkQos();
    qos.setOutAverageLinkshare(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutAverageUpperlimit(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutAverageRealtime(RandomUtils.instance().nextInt(0, 1000000));
    return qos;
}
#method_after
private HostNetworkQos createQos() {
    HostNetworkQos qos = new HostNetworkQos();
    qos.setOutAverageLinkshare(RandomUtils.instance().nextInt(0, 100));
    qos.setOutAverageUpperlimit(RandomUtils.instance().nextInt(0, 2000));
    qos.setOutAverageRealtime(RandomUtils.instance().nextInt(0, 2000));
    return qos;
}
#end_block

#method_before
@Override
public NonOperationalReason persistAndEnforceNetworkCompliance(VDS host) {
    return persistAndEnforceNetworkCompliance(host, false, null);
}
#method_after
@Override
public NonOperationalReason persistAndEnforceNetworkCompliance(VDS host, boolean skipManagementNetwork, List<VdsNetworkInterface> userConfiguredNics) {
    List<VdsNetworkInterface> dbIfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(host.getId());
    List<Network> clusterNetworks = DbFacade.getInstance().getNetworkDao().getAllForCluster(host.getVdsGroupId());
    persistTopology(host.getInterfaces(), dbIfaces, userConfiguredNics);
    NonOperationalReason nonOperationalReason = enforceNetworkCompliance(host, skipManagementNetwork, clusterNetworks);
    auditNetworkCompliance(host, dbIfaces, clusterNetworks);
    return nonOperationalReason;
}
#end_block

#method_before
private NonOperationalReason enforceNetworkCompliance(VDS host, boolean skipManagementNetwork, List<VdsNetworkInterface> dbIfaces) {
    if (host.getStatus() != VDSStatus.Maintenance) {
        List<Network> clusterNetworks = DbFacade.getInstance().getNetworkDao().getAllForCluster(host.getVdsGroupId());
        if (skipManagementNetwork) {
            skipManagementNetworkCheck(host.getInterfaces(), clusterNetworks);
        }
        Map<String, String> customLogValues;
        // here we check if the host networks match it's cluster networks
        String networks = getMissingOperationalClusterNetworks(host, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperational(host, NonOperationalReason.NETWORK_UNREACHABLE, customLogValues);
            return NonOperationalReason.NETWORK_UNREACHABLE;
        }
        // Check that VM networks are implemented above a bridge.
        networks = getVmNetworksImplementedAsBridgeless(host, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperational(host, NonOperationalReason.VM_NETWORK_IS_BRIDGELESS, customLogValues);
            return NonOperationalReason.VM_NETWORK_IS_BRIDGELESS;
        }
        final Map<String, Network> clusterNetworksByName = Entities.entitiesByName(clusterNetworks);
        final Collection<Network> dbHostNetworks = findNetworksOnInterfaces(dbIfaces, clusterNetworksByName);
        logChangedDisplayNetwork(host, dbHostNetworks, dbIfaces);
        logUnsynchronizedNetworks(host, clusterNetworksByName);
    }
    return NonOperationalReason.NONE;
}
#method_after
private NonOperationalReason enforceNetworkCompliance(VDS host, boolean skipManagementNetwork, List<Network> clusterNetworks) {
    if (host.getStatus() != VDSStatus.Maintenance) {
        if (skipManagementNetwork) {
            skipManagementNetworkCheck(host.getInterfaces(), clusterNetworks);
        }
        Map<String, String> customLogValues;
        // here we check if the host networks match it's cluster networks
        String networks = getMissingOperationalClusterNetworks(host, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperational(host, NonOperationalReason.NETWORK_UNREACHABLE, customLogValues);
            return NonOperationalReason.NETWORK_UNREACHABLE;
        }
        // Check that VM networks are implemented above a bridge.
        networks = getVmNetworksImplementedAsBridgeless(host, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperational(host, NonOperationalReason.VM_NETWORK_IS_BRIDGELESS, customLogValues);
            return NonOperationalReason.VM_NETWORK_IS_BRIDGELESS;
        }
    }
    return NonOperationalReason.NONE;
}
#end_block

#method_before
@Override
public NonOperationalReason persistAndEnforceNetworkCompliance(VDS host) {
    return persistAndEnforceNetworkCompliance(host, false, null);
}
#method_after
@Override
public NonOperationalReason persistAndEnforceNetworkCompliance(VDS host) {
    return persistAndEnforceNetworkCompliance(host, false, Collections.<VdsNetworkInterface>emptyList());
}
#end_block

#method_before
private void persistTopology(List<VdsNetworkInterface> reportedNics, List<VdsNetworkInterface> dbNics, Map<String, VdsNetworkInterface> nicsByName) {
    InterfaceDao interfaceDAO = DbFacade.getInstance().getInterfaceDao();
    List<String> updatedIfaces = new ArrayList<>();
    List<VdsNetworkInterface> dbIfacesToBatch = new ArrayList<>();
    Map<String, VdsNetworkInterface> hostNicsByNames = Entities.entitiesByName(reportedNics);
    // First we check what interfaces need to update/delete
    for (VdsNetworkInterface dbIface : dbNics) {
        if (hostNicsByNames.containsKey(dbIface.getName())) {
            VdsNetworkInterface vdsIface = hostNicsByNames.get(dbIface.getName());
            // we preserve only the ID and the labels from the Database
            // everything else is what we got from getVdsCapabilities
            vdsIface.setId(dbIface.getId());
            vdsIface.setLabels(dbIface.getLabels());
            vdsIface.setQosOverridden(dbIface.isQosOverridden());
            vdsIface.setCustomProperties(dbIface.getCustomProperties());
            dbIfacesToBatch.add(vdsIface);
            updatedIfaces.add(vdsIface.getName());
        } else {
            interfaceDAO.removeInterfaceFromVds(dbIface.getId());
            interfaceDAO.removeStatisticsForVds(dbIface.getId());
        }
    }
    if (nicsByName != null) {
        updateInterfacesWithUserConfiguration(dbIfacesToBatch, nicsByName);
        updateInterfacesWithUserConfiguration(reportedNics, nicsByName);
    }
    if (!dbIfacesToBatch.isEmpty()) {
        interfaceDAO.massUpdateInterfacesForVds(dbIfacesToBatch);
    }
    // now all that left is add the interfaces that not exists in the Database
    for (VdsNetworkInterface vdsIface : reportedNics) {
        if (!updatedIfaces.contains(vdsIface.getName())) {
            interfaceDAO.saveInterfaceForVds(vdsIface);
            interfaceDAO.saveStatisticsForVds(vdsIface.getStatistics());
        }
    }
}
#method_after
private void persistTopology(List<VdsNetworkInterface> reportedNics, List<VdsNetworkInterface> dbNics, List<VdsNetworkInterface> userConfiguredNics) {
    final HostNetworkInterfacesPersister networkInterfacesPersister = new HostNetworkInterfacesPersisterImpl(DbFacade.getInstance().getInterfaceDao(), reportedNics, dbNics, userConfiguredNics);
    networkInterfacesPersister.persistTopology();
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.error("Illegal vm display_port '{}'.", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.error("Illegal vm display '{}'.", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.error("Illegal vm display_secure_port '{}'.", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.error("Illegal vm display type '{}'.", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(AssignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(AssignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(AssignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(AssignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(AssignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    } else {
        // for backward compatibility's sake
        vds.setLiveSnapshotSupport(true);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
}
#end_block

#method_before
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#method_after
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#end_block

#method_before
private static Integer AssignIntValue(Map input, String name) {
    if (input.containsKey(name)) {
        if (input.get(name) instanceof Integer) {
            return (Integer) input.get(name);
        }
        String stringValue = (String) input.get(name);
        if (!StringUtils.isEmpty(stringValue)) {
            // in case the input
            // is decimal and we
            // need int.
            stringValue = stringValue.split("[.]", -1)[0];
        }
        try {
            int intValue = Integer.parseInt(stringValue);
            return intValue;
        } catch (NumberFormatException nfe) {
            String errMsg = String.format("Failed to parse %1$s value %2$s to integer", name, stringValue);
            log.error(errMsg, nfe);
        }
    }
    return null;
}
#method_after
private static Integer AssignIntValue(Map input, String name) {
    if (input.containsKey(name)) {
        if (input.get(name) instanceof Integer) {
            return (Integer) input.get(name);
        }
        String stringValue = (String) input.get(name);
        if (!StringUtils.isEmpty(stringValue)) {
            // in case the input
            // is decimal and we
            // need int.
            stringValue = stringValue.split("[.]", -1)[0];
        }
        try {
            int intValue = Integer.parseInt(stringValue);
            return intValue;
        } catch (NumberFormatException nfe) {
            log.error("Failed to parse '{}' value '{}' to integer: {}", name, stringValue, nfe.getMessage());
        }
    }
    return null;
}
#end_block

#method_before
private static Long AssignLongValue(Map<String, Object> input, String name) {
    if (input.containsKey(name)) {
        if (input.get(name) instanceof Long || input.get(name) instanceof Integer) {
            return Long.parseLong(input.get(name).toString());
        }
        String stringValue = (String) ((input.get(name) instanceof String) ? input.get(name) : null);
        if (!StringUtils.isEmpty(stringValue)) {
            // in case the input
            // is decimal and we
            // need int.
            stringValue = stringValue.split("[.]", -1)[0];
        }
        try {
            return Long.parseLong(stringValue);
        } catch (NumberFormatException e) {
            log.errorFormat("Failed to parse {0} value {1} to long", name, stringValue);
        }
    }
    return null;
}
#method_after
private static Long AssignLongValue(Map<String, Object> input, String name) {
    if (input.containsKey(name)) {
        if (input.get(name) instanceof Long || input.get(name) instanceof Integer) {
            return Long.parseLong(input.get(name).toString());
        }
        String stringValue = (String) ((input.get(name) instanceof String) ? input.get(name) : null);
        if (!StringUtils.isEmpty(stringValue)) {
            // in case the input
            // is decimal and we
            // need int.
            stringValue = stringValue.split("[.]", -1)[0];
        }
        try {
            return Long.parseLong(stringValue);
        } catch (NumberFormatException e) {
            log.error("Failed to parse '{}' value '{}' to long: {}", name, stringValue, e.getMessage());
        }
    }
    return null;
}
#end_block

#method_before
private static Date AssignDateTImeFromEpoch(Map<String, Object> input, String name) {
    Date retval = null;
    try {
        if (input.containsKey(name)) {
            Double secsSinceEpoch = (Double) input.get(name);
            Calendar calendar = Calendar.getInstance();
            calendar.setTimeInMillis(secsSinceEpoch.longValue());
            retval = calendar.getTime();
        }
    } catch (RuntimeException ex) {
        String msg = String.format("VdsBroker::AssignDateTImeFromEpoch - failed to convert field %1$s to dateTime", name);
        log.warn(msg, ex);
        retval = null;
    }
    return retval;
}
#method_after
private static Date AssignDateTImeFromEpoch(Map<String, Object> input, String name) {
    Date retval = null;
    try {
        if (input.containsKey(name)) {
            Double secsSinceEpoch = (Double) input.get(name);
            Calendar calendar = Calendar.getInstance();
            calendar.setTimeInMillis(secsSinceEpoch.longValue());
            retval = calendar.getTime();
        }
    } catch (RuntimeException ex) {
        log.warn("VdsBroker::AssignDateTImeFromEpoch - failed to convert field '{}' to dateTime: {}", name, ex.getMessage());
        log.debug("Exception", ex);
        retval = null;
    }
    return retval;
}
#end_block

#method_before
private static VMStatus convertToVmStatus(String statusName) {
    VMStatus status = VMStatus.Unassigned;
    // EnumUtils as other states below.
    if ("Running".equals(statusName) || "Unknown".equals(statusName)) {
        status = VMStatus.Up;
    } else if ("Migration Source".equals(statusName)) {
        status = VMStatus.MigratingFrom;
    } else if ("Migration Destination".equals(statusName)) {
        status = VMStatus.MigratingTo;
    } else {
        try {
            statusName = statusName.replace(" ", "");
            status = EnumUtils.valueOf(VMStatus.class, statusName, true);
        } catch (Exception e) {
            log.errorFormat("Vm status: {0} illegal", statusName);
        }
    }
    return status;
}
#method_after
private static VMStatus convertToVmStatus(String statusName) {
    VMStatus status = VMStatus.Unassigned;
    // EnumUtils as other states below.
    if ("Running".equals(statusName) || "Unknown".equals(statusName)) {
        status = VMStatus.Up;
    } else if ("Migration Source".equals(statusName)) {
        status = VMStatus.MigratingFrom;
    } else if ("Migration Destination".equals(statusName)) {
        status = VMStatus.MigratingTo;
    } else {
        try {
            statusName = statusName.replace(" ", "");
            status = EnumUtils.valueOf(VMStatus.class, statusName, true);
        } catch (Exception e) {
            log.error("Illegal Vm status: '{}'.", statusName);
        }
    }
    return status;
}
#end_block

#method_before
private static boolean isQosInSync(VdsNetworkInterface iface, HostNetworkQos networkQos) {
    HostNetworkQos ifaceQos = iface.getQos();
    if (ifaceQos == networkQos) {
        return true;
    } else if (ifaceQos == null || networkQos == null) {
        return false;
    } else {
        return ifaceQos.equalValues(networkQos);
    }
}
#method_after
private static boolean isQosInSync(VdsNetworkInterface iface, HostNetworkQos networkQos) {
    HostNetworkQos ifaceQos = iface.getQos();
    return qosParametersEqual(ifaceQos, networkQos);
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    HostNetworkQosDao qosDao = getDbFacade().getHostNetworkQosDao();
    VDS host = getDbFacade().getVdsDao().get(getParameters().getVdsId());
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(host.getVdsGroupCompatibilityVersion());
    Set<Version> supportedClusterVersionsSet = host.getSupportedClusterVersionsSet();
    boolean supportedClusterVersionsAvailable = supportedClusterVersionsSet != null && supportedClusterVersionsSet.isEmpty();
    if (!supportedClusterVersionsAvailable) {
        log.warnFormat("Host {0} ({1}) doesn't contain Supported Cluster Versions, therefore 'defaultRoute'" + " will not be sent via the SetupNetworks", host.getName(), host.getId());
    }
    boolean defaultRouteSupported = supportedClusterVersionsAvailable && FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet));
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", NetworkUtils.getDefaultMtu().toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (hostNetworkQosSupported && NetworkUtils.qosConfiguredOnInterface(iface, network)) {
            HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(opts);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        if (defaultRouteSupported && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.hasCustomProperties()) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    HostNetworkQosDao qosDao = getDbFacade().getHostNetworkQosDao();
    VDS host = getParameters().getVds();
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(host.getVdsGroupCompatibilityVersion());
    Set<Version> supportedClusterVersionsSet = host.getSupportedClusterVersionsSet();
    boolean supportedClusterVersionsAvailable = supportedClusterVersionsSet != null && supportedClusterVersionsSet.isEmpty();
    if (!supportedClusterVersionsAvailable) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, therefore 'defaultRoute'" + " will not be sent via the SetupNetworks", host.getName(), host.getId());
    }
    boolean defaultRouteSupported = supportedClusterVersionsAvailable && FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet));
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", NetworkUtils.getDefaultMtu().toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (hostNetworkQosSupported && NetworkUtils.qosConfiguredOnInterface(iface, network)) {
            HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(opts);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        if (defaultRouteSupported && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.hasCustomProperties()) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
private void validateNetworkQos() {
    Set<String> someSubInterfacesHaveQos = new HashSet<>();
    Set<String> notAllSubInterfacesHaveQos = new HashSet<>();
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        if (networkName == null) {
            continue;
        }
        Network network = existingClusterNetworks.get(networkName);
        String baseIfaceName = NetworkUtils.stripVlan(iface);
        if (NetworkUtils.qosConfiguredOnInterface(iface, network)) {
            someSubInterfacesHaveQos.add(baseIfaceName);
            if (iface.isQosOverridden()) {
                if (!hostNetworkQosSupported) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, networkName);
                }
                HostNetworkQosValidator qosValidator = new HostNetworkQosValidator(iface.getQos());
                if (qosValidator.requiredValuesPresent() != ValidationResult.VALID) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES, networkName);
                }
                if (qosValidator.valuesConsistent() != ValidationResult.VALID) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_INCONSISTENT_VALUES, networkName);
                }
            }
        } else {
            notAllSubInterfacesHaveQos.add(baseIfaceName);
        }
    }
    for (String ifaceName : someSubInterfacesHaveQos) {
        if (notAllSubInterfacesHaveQos.contains(ifaceName)) {
            addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INTERFACES_WITHOUT_QOS, ifaceName);
        }
    }
}
#method_after
private void validateNetworkQos() {
    validateQosOverriddenInterfaces();
    validateQosNotPartiallyConfigured();
}
#end_block

#method_before
@Test
public void qosValuesModified() {
    Network network = createNetwork(MANAGEMENT_NETWORK_NAME);
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    iface.setQosOverridden(true);
    mockExistingIfaces(iface);
    iface.setQos(createQos());
    SetupNetworksHelper helper = createHelper(createParametersForNics(iface), Version.v3_4);
    validateAndAssertNetworkModified(helper, network);
}
#method_after
@Test
public void qosValuesModified() {
    Network network = createNetwork(MANAGEMENT_NETWORK_NAME);
    SetupNetworksHelper helper = qosValuesTest(network, createQos());
    validateAndAssertNetworkModified(helper, network);
}
#end_block

#method_before
private SetupNetworksHelper setupCompositeQosConfiguration(String nicName, boolean qosOnAll) {
    Network net1 = createNetwork("net1");
    net1.setVlanId(100);
    Network net2 = createNetwork("net2");
    net2.setVlanId(200);
    Network net3 = createNetwork("net3");
    net3.setVmNetwork(false);
    Guid qosId = Guid.newGuid();
    when(qosDao.get(qosId)).thenReturn(createQos());
    net1.setQosId(qosId);
    net2.setQosId(qosId);
    net3.setQosId(qosOnAll ? qosId : null);
    VdsNetworkInterface nic = createNic(nicName, "net3");
    VdsNetworkInterface vlan1 = createVlan(nic.getName(), net1.getVlanId(), net1.getName());
    VdsNetworkInterface vlan2 = createVlan(nic.getName(), net2.getVlanId(), net2.getName());
    mockExistingNetworks(net1, net2, net3);
    mockExistingIfaces(nic);
    return createHelper(createParametersForNics(nic, vlan1, vlan2), Version.v3_4);
}
#method_after
private SetupNetworksHelper setupCompositeQosConfiguration(String nicName, boolean qosOnAll) {
    Network net1 = createNetwork("net1");
    net1.setVlanId(100);
    Network net2 = createNetwork("net2");
    net2.setVlanId(200);
    Network net3 = createNetwork("net3");
    net3.setVmNetwork(false);
    Guid qosId = Guid.newGuid();
    when(qosDao.get(qosId)).thenReturn(createQos());
    net1.setQosId(qosId);
    net2.setQosId(qosId);
    net3.setQosId(qosOnAll ? qosId : null);
    VdsNetworkInterface nic = createNic(nicName, net3.getName());
    VdsNetworkInterface vlan1 = createVlan(nic.getName(), net1.getVlanId(), net1.getName());
    VdsNetworkInterface vlan2 = createVlan(nic.getName(), net2.getVlanId(), net2.getName());
    mockExistingNetworks(net1, net2, net3);
    mockExistingIfaces(nic);
    return createHelper(createParametersForNics(nic, vlan1, vlan2), Version.v3_4);
}
#end_block

#method_before
private void setMessage() {
    ArrayList<VdcQueryParametersBase> parameters = new ArrayList<VdcQueryParametersBase>();
    ArrayList<VdcQueryType> queryTypes = new ArrayList<VdcQueryType>();
    for (T qos : sourceListModel.getSelectedItems()) {
        VdcQueryParametersBase parameter = new IdQueryParameters(qos.getId());
        parameters.add(parameter);
        queryTypes.add(getProfilesByQosIdQueryType());
    }
    Frontend.getInstance().runMultipleQueries(queryTypes, parameters, new IFrontendMultipleQueryAsyncCallback() {

        @Override
        public void executed(FrontendMultipleQueryAsyncResult result) {
            Map<String, String> profilesAndQos = new HashMap<String, String>();
            setHelpTag(getRemoveQosHelpTag());
            setHashName(getRemoveQosHashName());
            int index = 0;
            for (VdcQueryReturnValue returnValue : result.getReturnValues()) {
                for (Nameable profileBase : (List<Nameable>) returnValue.getReturnValue()) {
                    profilesAndQos.put(profileBase.getName(), sourceListModel.getSelectedItems().get(index).getName());
                }
                index++;
            }
            if (profilesAndQos.isEmpty()) {
                ArrayList<String> list = new ArrayList<String>();
                for (T item : sourceListModel.getSelectedItems()) {
                    list.add(item.getName());
                }
                setItems(list);
            } else {
                setMessage(getRemoveQosMessage(profilesAndQos.size()));
                ArrayList<String> list = new ArrayList<String>();
                for (Entry<String, String> item : profilesAndQos.entrySet()) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    list.add(item.getKey() + " (" + item.getValue() + ")");
                }
                setItems(list);
            }
        }
    });
}
#method_after
private void setMessage() {
    ArrayList<VdcQueryParametersBase> parameters = new ArrayList<VdcQueryParametersBase>();
    ArrayList<VdcQueryType> queryTypes = new ArrayList<VdcQueryType>();
    for (T qos : sourceListModel.getSelectedItems()) {
        VdcQueryParametersBase parameter = new IdQueryParameters(qos.getId());
        parameters.add(parameter);
        queryTypes.add(getUsingEntitiesByQosIdQueryType());
    }
    Frontend.getInstance().runMultipleQueries(queryTypes, parameters, new IFrontendMultipleQueryAsyncCallback() {

        @Override
        public void executed(FrontendMultipleQueryAsyncResult result) {
            Map<String, String> entitiesAndQos = new HashMap<String, String>();
            setHelpTag(getRemoveQosHelpTag());
            setHashName(getRemoveQosHashName());
            int index = 0;
            for (VdcQueryReturnValue returnValue : result.getReturnValues()) {
                for (Nameable entity : (List<Nameable>) returnValue.getReturnValue()) {
                    entitiesAndQos.put(entity.getName(), sourceListModel.getSelectedItems().get(index).getName());
                }
                index++;
            }
            if (entitiesAndQos.isEmpty()) {
                ArrayList<String> list = new ArrayList<String>();
                for (T item : sourceListModel.getSelectedItems()) {
                    list.add(item.getName());
                }
                setItems(list);
            } else {
                setMessage(getRemoveQosMessage(entitiesAndQos.size()));
                ArrayList<String> list = new ArrayList<String>();
                for (Entry<String, String> item : entitiesAndQos.entrySet()) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    list.add(item.getKey() + " (" + item.getValue() + ")");
                }
                setItems(list);
            }
        }
    });
}
#end_block

#method_before
public void onSaveInternal() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    StoragePool dataCenter = model.getIsNew() ? new StoragePool() : (StoragePool) Cloner.clone(getSelectedItem());
    // cancel confirm window if there is
    cancelConfirmation();
    // Save changes.
    dataCenter.setName(model.getName().getEntity());
    dataCenter.setdescription(model.getDescription().getEntity());
    dataCenter.setComment(model.getComment().getEntity());
    dataCenter.setIsLocal(model.getStoragePoolType().getSelectedItem());
    dataCenter.setcompatibility_version(model.getVersion().getSelectedItem());
    dataCenter.setQuotaEnforcementType(model.getQuotaEnforceTypeListModel().getSelectedItem());
    dataCenter.setMacPoolId(model.getMacPoolListModel().getSelectedItem().getId());
    model.startProgress(null);
    if (model.getIsNew()) {
        // When adding a data center use sync action to be able present a Guide Me dialog afterwards.
        Frontend.getInstance().runAction(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(dataCenter), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }, this);
    } else {
        // Update the Quota at the corresponding DC object at the system tree.
        // The DC Quota value from the tree is used at MainTabDiskView.
        SystemTreeItemModel itemModel = CommonModel.getInstance().getSystemTree().getItemById(dataCenter.getId());
        itemModel.setEntity(dataCenter);
        // Otherwise use async action in order to close dialog immediately.
        Frontend.getInstance().runMultipleAction(VdcActionType.UpdateStoragePool, new ArrayList<VdcActionParametersBase>(Arrays.asList(new StoragePoolManagementParameter(dataCenter))), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue().get(0));
            }
        }, this);
    }
}
#method_after
public void onSaveInternal() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    StoragePool dataCenter = model.getIsNew() ? new StoragePool() : (StoragePool) Cloner.clone(getSelectedItem());
    // cancel confirm window if there is
    cancelConfirmation();
    // Save changes.
    dataCenter.setName(model.getName().getEntity());
    dataCenter.setdescription(model.getDescription().getEntity());
    dataCenter.setComment(model.getComment().getEntity());
    dataCenter.setIsLocal(model.getStoragePoolType().getSelectedItem());
    dataCenter.setcompatibility_version(model.getVersion().getSelectedItem());
    dataCenter.setQuotaEnforcementType(model.getQuotaEnforceTypeListModel().getSelectedItem());
    dataCenter.setMacPoolId(model.getMacPoolListModel().getSelectedItem().getId());
    model.startProgress(null);
    if (model.getIsNew()) {
        // When adding a data center use sync action to be able present a Guide Me dialog afterwards.
        Frontend.getInstance().runAction(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(dataCenter), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }, this);
    } else {
        // Update the Quota at the corresponding DC object at the system tree.
        // The DC Quota value from the tree is used at MainTabDiskView.
        SystemTreeItemModel itemModel = commonModelProvider.get().getSystemTree().getItemById(dataCenter.getId());
        itemModel.setEntity(dataCenter);
        // Otherwise use async action in order to close dialog immediately.
        Frontend.getInstance().runMultipleAction(VdcActionType.UpdateStoragePool, new ArrayList<VdcActionParametersBase>(Arrays.asList(new StoragePoolManagementParameter(dataCenter))), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue().get(0));
            }
        }, this);
    }
}
#end_block

#method_before
@Override
protected RemoveQosModel<HostNetworkQos> getRemoveQosModel() {
    return new RemoveHostNetworkQos(this);
}
#method_after
@Override
protected RemoveQosModel<HostNetworkQos> getRemoveQosModel() {
    return new RemoveHostNetworkQosModel(this);
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<StoragePool, DataCenterListModel> getDataCenterListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<DataCenterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<RecoveryStoragePopupPresenterWidget> recoveryStorageConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<DataCenterForceRemovePopupPresenterWidget> forceRemovePopupProvider, final Provider<SharedMacPoolPopupPresenterWidget> macPoolPopupProvider) {
    return new MainTabModelProvider<StoragePool, DataCenterListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAddMacPoolCommand()) {
                return macPoolPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getForceRemoveCommand()) {
                return forceRemovePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRecoveryStorageCommand()) {
                return recoveryStorageConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<StoragePool, DataCenterListModel> getDataCenterListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<DataCenterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<RecoveryStoragePopupPresenterWidget> recoveryStorageConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<DataCenterForceRemovePopupPresenterWidget> forceRemovePopupProvider, final Provider<SharedMacPoolPopupPresenterWidget> macPoolPopupProvider, final Provider<DataCenterListModel> modelProvider, final Provider<CommonModel> commonModelProvider) {
    MainTabModelProvider<StoragePool, DataCenterListModel> result = new MainTabModelProvider<StoragePool, DataCenterListModel>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAddMacPoolCommand()) {
                return macPoolPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getForceRemoveCommand()) {
                return forceRemovePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRecoveryStorageCommand()) {
                return recoveryStorageConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<Network, DataCenterListModel, DataCenterNetworkListModel> getDataCenterNetworkListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<NewDataCenterNetworkPopupPresenterWidget> newNetworkPopupProvider, final Provider<EditDataCenterNetworkPopupPresenterWidget> editNetworkPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<Network, DataCenterListModel, DataCenterNetworkListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class, DataCenterNetworkListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterNetworkListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return newNetworkPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return editNetworkPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterNetworkListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand() || lastExecutedCommand.getName().equals("Apply")) {
                // $NON-NLS-1$
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
// Form Detail Models
@Provides
@Singleton
public SearchableDetailModelProvider<Network, DataCenterListModel, DataCenterNetworkListModel> getDataCenterNetworkListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<NewDataCenterNetworkPopupPresenterWidget> newNetworkPopupProvider, final Provider<EditDataCenterNetworkPopupPresenterWidget> editNetworkPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<DataCenterListModel> mainModelProvider, final Provider<DataCenterNetworkListModel> modelProvider) {
    SearchableDetailTabModelProvider<Network, DataCenterListModel, DataCenterNetworkListModel> result = new SearchableDetailTabModelProvider<Network, DataCenterListModel, DataCenterNetworkListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterNetworkListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return newNetworkPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return editNetworkPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterNetworkListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand() || lastExecutedCommand.getName().equals("Apply")) {
                // $NON-NLS-1$
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<StorageDomain, DataCenterListModel, DataCenterStorageListModel> getDataCenterStorageListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<FindSingleStoragePopupPresenterWidget> singlePopupProvider, final Provider<FindMultiStoragePopupPresenterWidget> multiPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<StorageDomain, DataCenterListModel, DataCenterStorageListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class, DataCenterStorageListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterStorageListModel source, UICommand lastExecutedCommand, Model windowModel) {
            DataCenterStorageListModel model = getModel();
            if (lastExecutedCommand == model.getAttachStorageCommand()) {
                return multiPopupProvider.get();
            } else if (lastExecutedCommand == model.getAttachISOCommand() || lastExecutedCommand == model.getAttachBackupCommand()) {
                return singlePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterStorageListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getDetachCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
// Search-able Detail Models
@Provides
@Singleton
public SearchableDetailModelProvider<StorageDomain, DataCenterListModel, DataCenterStorageListModel> getDataCenterStorageListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<FindSingleStoragePopupPresenterWidget> singlePopupProvider, final Provider<FindMultiStoragePopupPresenterWidget> multiPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<DataCenterListModel> mainModelProvider, final Provider<DataCenterStorageListModel> modelProvider) {
    SearchableDetailTabModelProvider<StorageDomain, DataCenterListModel, DataCenterStorageListModel> result = new SearchableDetailTabModelProvider<StorageDomain, DataCenterListModel, DataCenterStorageListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterStorageListModel source, UICommand lastExecutedCommand, Model windowModel) {
            DataCenterStorageListModel model = getModel();
            if (lastExecutedCommand == model.getAttachStorageCommand()) {
                return multiPopupProvider.get();
            } else if (lastExecutedCommand == model.getAttachISOCommand() || lastExecutedCommand == model.getAttachBackupCommand()) {
                return singlePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterStorageListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getDetachCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<Quota, DataCenterListModel, DataCenterQuotaListModel> getDataCenterQuotaListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<QuotaPopupPresenterWidget> quotaPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<Quota, DataCenterListModel, DataCenterQuotaListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class, DataCenterQuotaListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterQuotaListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getCreateCommand()) || lastExecutedCommand.equals(getModel().getEditCommand()) || lastExecutedCommand.equals(getModel().getCloneCommand())) {
                return quotaPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterQuotaListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand.equals(getModel().getRemoveCommand())) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<Quota, DataCenterListModel, DataCenterQuotaListModel> getDataCenterQuotaListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<QuotaPopupPresenterWidget> quotaPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<DataCenterListModel> mainModelProvider, final Provider<DataCenterQuotaListModel> modelProvider) {
    SearchableDetailTabModelProvider<Quota, DataCenterListModel, DataCenterQuotaListModel> result = new SearchableDetailTabModelProvider<Quota, DataCenterListModel, DataCenterQuotaListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterQuotaListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getCreateCommand()) || lastExecutedCommand.equals(getModel().getEditCommand()) || lastExecutedCommand.equals(getModel().getCloneCommand())) {
                return quotaPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterQuotaListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand.equals(getModel().getRemoveCommand())) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<NetworkQoS, DataCenterListModel, DataCenterNetworkQoSListModel> getDataCenterNetworkQoSListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<NetworkQoSPopupPresenterWidget> networkQoSPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<NetworkQoS, DataCenterListModel, DataCenterNetworkQoSListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class, DataCenterNetworkQoSListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterNetworkQoSListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getNewCommand()) || lastExecutedCommand.equals(getModel().getEditCommand())) {
                return networkQoSPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterNetworkQoSListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand.equals(getModel().getRemoveCommand())) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<NetworkQoS, DataCenterListModel, DataCenterNetworkQoSListModel> getDataCenterNetworkQoSListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<NetworkQoSPopupPresenterWidget> networkQoSPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<DataCenterListModel> mainModelProvider, final Provider<DataCenterNetworkQoSListModel> modelProvider) {
    SearchableDetailTabModelProvider<NetworkQoS, DataCenterListModel, DataCenterNetworkQoSListModel> result = new SearchableDetailTabModelProvider<NetworkQoS, DataCenterListModel, DataCenterNetworkQoSListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterNetworkQoSListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getNewCommand()) || lastExecutedCommand.equals(getModel().getEditCommand())) {
                return networkQoSPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterNetworkQoSListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand.equals(getModel().getRemoveCommand())) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<HostNetworkQos, DataCenterListModel, DataCenterHostNetworkQosListModel> getDataCenterHostNetworkQosListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<HostNetworkQosPopupPresenterWidget> hostNetworkQosPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<HostNetworkQos, DataCenterListModel, DataCenterHostNetworkQosListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class, DataCenterHostNetworkQosListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterHostNetworkQosListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getNewCommand()) || lastExecutedCommand.equals(getModel().getEditCommand())) {
                return hostNetworkQosPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterHostNetworkQosListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand.equals(getModel().getRemoveCommand())) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<HostNetworkQos, DataCenterListModel, DataCenterHostNetworkQosListModel> getDataCenterHostNetworkQosListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<HostNetworkQosPopupPresenterWidget> hostNetworkQosPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<DataCenterListModel> mainModelProvider, final Provider<DataCenterHostNetworkQosListModel> modelProvider) {
    SearchableDetailTabModelProvider<HostNetworkQos, DataCenterListModel, DataCenterHostNetworkQosListModel> result = new SearchableDetailTabModelProvider<HostNetworkQos, DataCenterListModel, DataCenterHostNetworkQosListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterHostNetworkQosListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getNewCommand()) || lastExecutedCommand.equals(getModel().getEditCommand())) {
                return hostNetworkQosPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterHostNetworkQosListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand.equals(getModel().getRemoveCommand())) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<StorageQos, DataCenterListModel, DataCenterStorageQosListModel> getDataCenterStorageQosListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<StorageQosPopupPresenterWidget> storageQosPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<StorageQos, DataCenterListModel, DataCenterStorageQosListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class, DataCenterStorageQosListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterStorageQosListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getNewCommand()) || lastExecutedCommand.equals(getModel().getEditCommand())) {
                return storageQosPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterStorageQosListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand.equals(getModel().getRemoveCommand())) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<StorageQos, DataCenterListModel, DataCenterStorageQosListModel> getDataCenterStorageQosListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<StorageQosPopupPresenterWidget> storageQosPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<DataCenterListModel> mainModelProvider, final Provider<DataCenterStorageQosListModel> modelProvider) {
    SearchableDetailTabModelProvider<StorageQos, DataCenterListModel, DataCenterStorageQosListModel> result = new SearchableDetailTabModelProvider<StorageQos, DataCenterListModel, DataCenterStorageQosListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterStorageQosListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getNewCommand()) || lastExecutedCommand.equals(getModel().getEditCommand())) {
                return storageQosPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterStorageQosListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand.equals(getModel().getRemoveCommand())) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<CpuQos, DataCenterListModel, DataCenterCpuQosListModel> getDataCenterCpuQosListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<CpuQosPopupPresenterWidget> cpuQosPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<CpuQos, DataCenterListModel, DataCenterCpuQosListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class, DataCenterCpuQosListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterCpuQosListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getNewCommand()) || lastExecutedCommand.equals(getModel().getEditCommand())) {
                return cpuQosPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterCpuQosListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand.equals(getModel().getRemoveCommand())) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<CpuQos, DataCenterListModel, DataCenterCpuQosListModel> getDataCenterCpuQosListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<CpuQosPopupPresenterWidget> cpuQosPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<DataCenterListModel> mainModelProvider, final Provider<DataCenterCpuQosListModel> modelProvider) {
    SearchableDetailTabModelProvider<CpuQos, DataCenterListModel, DataCenterCpuQosListModel> result = new SearchableDetailTabModelProvider<CpuQos, DataCenterListModel, DataCenterCpuQosListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterCpuQosListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getNewCommand()) || lastExecutedCommand.equals(getModel().getEditCommand())) {
                return cpuQosPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterCpuQosListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand.equals(getModel().getRemoveCommand())) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<AuditLog, DataCenterListModel, DataCenterEventListModel> getDataCenterEventListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<EventPopupPresenterWidget> eventPopupProvider) {
    return new SearchableDetailTabModelProvider<AuditLog, DataCenterListModel, DataCenterEventListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class, DataCenterEventListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterEventListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getDetailsCommand())) {
                return eventPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<AuditLog, DataCenterListModel, DataCenterEventListModel> getDataCenterEventListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<EventPopupPresenterWidget> eventPopupProvider, final Provider<DataCenterListModel> mainModelProvider, final Provider<DataCenterEventListModel> modelProvider) {
    SearchableDetailTabModelProvider<AuditLog, DataCenterListModel, DataCenterEventListModel> result = new SearchableDetailTabModelProvider<AuditLog, DataCenterListModel, DataCenterEventListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterEventListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getDetailsCommand())) {
                return eventPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<IscsiBond, DataCenterListModel, DataCenterIscsiBondListModel> getDataCenterIscsiBondListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<IscsiBondPopupPresenterWidget> iscsiBondPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<IscsiBond, DataCenterListModel, DataCenterIscsiBondListModel>(eventBus, defaultConfirmPopupProvider, DataCenterListModel.class, DataCenterIscsiBondListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterIscsiBondListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAddCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return iscsiBondPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterIscsiBondListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<IscsiBond, DataCenterListModel, DataCenterIscsiBondListModel> getDataCenterIscsiBondListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<IscsiBondPopupPresenterWidget> iscsiBondPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<DataCenterListModel> mainModelProvider, final Provider<DataCenterIscsiBondListModel> modelProvider) {
    SearchableDetailTabModelProvider<IscsiBond, DataCenterListModel, DataCenterIscsiBondListModel> result = new SearchableDetailTabModelProvider<IscsiBond, DataCenterListModel, DataCenterIscsiBondListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterIscsiBondListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAddCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return iscsiBondPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterIscsiBondListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
}
#method_after
@Override
protected void configure() {
    bind(DataCenterListModel.class).in(Singleton.class);
    bind(DataCenterClusterListModel.class).in(Singleton.class);
    bind(DataCenterNetworkListModel.class).in(Singleton.class);
    bind(DataCenterStorageListModel.class).in(Singleton.class);
    bind(DataCenterQuotaListModel.class).in(Singleton.class);
    bind(DataCenterNetworkQoSListModel.class).in(Singleton.class);
    bind(DataCenterHostNetworkQosListModel.class).in(Singleton.class);
    bind(DataCenterEventListModel.class).in(Singleton.class);
    bind(DataCenterIscsiBondListModel.class).in(Singleton.class);
    bind(DataCenterStorageQosListModel.class).in(Singleton.class);
    bind(DataCenterCpuQosListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<DataCenterListModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<VDSGroup, DataCenterListModel, DataCenterClusterListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VDSGroup, DataCenterListModel, DataCenterClusterListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permissions, DataCenterListModel, PermissionListModel<DataCenterListModel>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<DataCenterListModel>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<HostNetworkQos> nameColumn = new TextColumnWithTooltip<HostNetworkQos>() {

        @Override
        public String getValue(HostNetworkQos object) {
            // $NON-NLS-1$
            return object.getName() == null ? "" : object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.storageQosName(), "200px");
    TextColumnWithTooltip<HostNetworkQos> descColumn = new TextColumnWithTooltip<HostNetworkQos>() {

        @Override
        public String getValue(HostNetworkQos object) {
            // $NON-NLS-1$
            return object.getDescription() == null ? "" : object.getDescription();
        }
    };
    descColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.storageQosDescription(), "150px");
    TextColumnWithTooltip<HostNetworkQos> outAverageLinkshareColumn = new TextColumnWithTooltip<HostNetworkQos>() {

        @Override
        public String getValue(HostNetworkQos object) {
            return object.getOutAverageLinkshare() == null ? constants.unlimitedQos() : object.getOutAverageLinkshare().toString();
        }
    };
    outAverageLinkshareColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(outAverageLinkshareColumn, constants.hostNetworkQosTabOutAverageLinkshare(), "105px");
    TextColumnWithTooltip<HostNetworkQos> outAverageUpperlimitColumn = new TextColumnWithTooltip<HostNetworkQos>() {

        @Override
        public String getValue(HostNetworkQos object) {
            return object.getOutAverageUpperlimit() == null ? constants.unlimitedQos() : object.getOutAverageUpperlimit().toString();
        }
    };
    outAverageUpperlimitColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(outAverageUpperlimitColumn, constants.hostNetworkQosTabOutAverageUpperlimit(), "105px");
    TextColumnWithTooltip<HostNetworkQos> outAverageRealtimeColumn = new TextColumnWithTooltip<HostNetworkQos>() {

        @Override
        public String getValue(HostNetworkQos object) {
            return object.getOutAverageRealtime() == null ? constants.unlimitedQos() : object.getOutAverageRealtime().toString();
        }
    };
    outAverageRealtimeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(outAverageRealtimeColumn, constants.hostNetworkQosTabOutAverageRealtime(), "105px");
    getTable().addActionButton(new WebAdminButtonDefinition<HostNetworkQos>(constants.newStorageQos()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<HostNetworkQos>(constants.editStorageQos()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<HostNetworkQos>(constants.removeStorageQos()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#method_after
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<HostNetworkQos> nameColumn = new TextColumnWithTooltip<HostNetworkQos>() {

        @Override
        public String getValue(HostNetworkQos object) {
            // $NON-NLS-1$
            assert object.getName() != null : "QoS entitites in a DC context must be named!";
            // $NON-NLS-1$
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.qosName(), "200px");
    TextColumnWithTooltip<HostNetworkQos> descColumn = new TextColumnWithTooltip<HostNetworkQos>() {

        @Override
        public String getValue(HostNetworkQos object) {
            // $NON-NLS-1$
            return object.getDescription() == null ? "" : object.getDescription();
        }
    };
    descColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.qosDescription(), "150px");
    TextColumnWithTooltip<HostNetworkQos> outAverageLinkshareColumn = new TextColumnWithTooltip<HostNetworkQos>() {

        @Override
        public String getValue(HostNetworkQos object) {
            return object.getOutAverageLinkshare() == null ? constants.unlimitedQos() : object.getOutAverageLinkshare().toString();
        }
    };
    outAverageLinkshareColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(outAverageLinkshareColumn, constants.hostNetworkQosTabOutAverageLinkshare(), "105px");
    TextColumnWithTooltip<HostNetworkQos> outAverageUpperlimitColumn = new TextColumnWithTooltip<HostNetworkQos>() {

        @Override
        public String getValue(HostNetworkQos object) {
            return object.getOutAverageUpperlimit() == null ? constants.unlimitedQos() : object.getOutAverageUpperlimit().toString();
        }
    };
    outAverageUpperlimitColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(outAverageUpperlimitColumn, constants.hostNetworkQosTabOutAverageUpperlimit(), "105px");
    TextColumnWithTooltip<HostNetworkQos> outAverageRealtimeColumn = new TextColumnWithTooltip<HostNetworkQos>() {

        @Override
        public String getValue(HostNetworkQos object) {
            return object.getOutAverageRealtime() == null ? constants.unlimitedQos() : object.getOutAverageRealtime().toString();
        }
    };
    outAverageRealtimeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(outAverageRealtimeColumn, constants.hostNetworkQosTabOutAverageRealtime(), "105px");
    getTable().addActionButton(new WebAdminButtonDefinition<HostNetworkQos>(constants.newQos()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<HostNetworkQos>(constants.editQos()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<HostNetworkQos>(constants.removeQos()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
@Before
public void setup() {
    qos = mock(HostNetworkQos.class);
    validator = new HostNetworkQosValidator(qos);
    nullValidator = new HostNetworkQosValidator(null);
}
#method_after
@Before
public void setup() {
    validator = new HostNetworkQosValidator(qos);
    nullValidator = new HostNetworkQosValidator(null);
}
#end_block

#method_before
public boolean entityStateEqualTo(UserPortalItemModel other) {
    // Compare pools
    if (getEntity() instanceof VmPool && other.getEntity() instanceof VmPool) {
        return getEntity().equals(other.getEntity());
    } else // Compare VMs
    if (getEntity() instanceof VM && other.getEntity() instanceof VM) {
        VM thisVm = (VM) getEntity();
        VM otherVm = (VM) other.getEntity();
        boolean consoleUsersEqual = (thisVm.getConsoleCurentUserName() != null && thisVm.getConsoleCurentUserName().equals(otherVm.getConsoleCurentUserName())) || (thisVm.getConsoleCurentUserName() == null && otherVm.getConsoleCurentUserName() == null);
        return thisVm.getDynamicData().getStatus().equals(otherVm.getDynamicData().getStatus()) && consoleUsersEqual && thisVm.getStaticData().equals(otherVm.getStaticData());
    }
    return false;
}
#method_after
public boolean entityStateEqualTo(UserPortalItemModel other) {
    // Compare pools
    if (getEntity() instanceof VmPool && other.getEntity() instanceof VmPool) {
        return getEntity().equals(other.getEntity());
    } else // Compare VMs
    if (getEntity() instanceof VM && other.getEntity() instanceof VM) {
        VM thisVm = (VM) getEntity();
        VM otherVm = (VM) other.getEntity();
        boolean consoleUsersEqual = Objects.equals(thisVm.getConsoleCurentUserName(), otherVm.getConsoleCurentUserName());
        return thisVm.getDynamicData().getStatus().equals(otherVm.getDynamicData().getStatus()) && consoleUsersEqual && thisVm.getStaticData().equals(otherVm.getStaticData());
    }
    return false;
}
#end_block

#method_before
public void clearCurrentItems() {
    clearReferences();
    currentItems = null;
}
#method_after
@Override
public void clearCurrentItems() {
    clearReferences();
    currentItems = null;
}
#end_block

#method_before
protected QosDao<?> getQosDao() {
    QosType qosType = getParameters().getQosType();
    if (qosType == null) {
        return getDbFacade().getQosBaseDao();
    }
    switch(qosType) {
        case STORAGE:
            qosDao = getDbFacade().getStorageQosDao();
            break;
        case CPU:
            qosDao = getDbFacade().getCpuQosDao();
            break;
        case NETWORK:
            qosDao = getDbFacade().getNetworkQosDao();
            break;
        case HOSTNETWORK:
            qosDao = getDbFacade().getHostNetworkQosDao();
            break;
        default:
            log.debugFormat("Not handled QoS type: {0}", qosType);
            break;
    }
    return qosDao;
}
#method_after
protected QosDao<?> getQosDao() {
    QosType qosType = getParameters().getQosType();
    if (qosType == null) {
        return getDbFacade().getQosBaseDao();
    }
    switch(qosType) {
        case STORAGE:
            qosDao = getDbFacade().getStorageQosDao();
            break;
        case CPU:
            qosDao = getDbFacade().getCpuQosDao();
            break;
        case NETWORK:
            qosDao = getDbFacade().getNetworkQosDao();
            break;
        case HOSTNETWORK:
            qosDao = getDbFacade().getHostNetworkQosDao();
            break;
        default:
            log.debug("Not handled QoS type: '{}'", qosType);
            break;
    }
    return qosDao;
}
#end_block

#method_before
@Override
protected QosBase createQosEntity(ResultSet rs) throws SQLException {
    QosType qosType = QosType.forValue(rs.getInt("qos_type"));
    switch(qosType) {
        case STORAGE:
            return StorageQosDaoDbFacadeImpl.StorageDaoDbFacadaeImplMapper.MAPPER.createQosEntity(rs);
        case CPU:
            return CpuQosDaoDbFacadeImpl.CpuDaoDbFacadaeImplMapper.MAPPER.createQosEntity(rs);
        case NETWORK:
            return NetworkQoSDaoFacadeImpl.NetworkQosDaoDbFacadaeImplMapper.MAPPER.createQosEntity(rs);
        case HOSTNETWORK:
            return HostNetworkQosDaoDbFacadeImpl.HostNetworkQosDaoDbFacadaeImplMapper.MAPPER.createQosEntity(rs);
        default:
            log.debugFormat("not handled/missing qos_type", qosType);
            break;
    }
    return null;
}
#method_after
@Override
protected QosBase createQosEntity(ResultSet rs) throws SQLException {
    QosType qosType = QosType.forValue(rs.getInt("qos_type"));
    switch(qosType) {
        case STORAGE:
            return StorageQosDaoDbFacadeImpl.StorageDaoDbFacadaeImplMapper.MAPPER.createQosEntity(rs);
        case CPU:
            return CpuQosDaoDbFacadeImpl.CpuDaoDbFacadaeImplMapper.MAPPER.createQosEntity(rs);
        case NETWORK:
            return NetworkQoSDaoFacadeImpl.NetworkQosDaoDbFacadaeImplMapper.MAPPER.createQosEntity(rs);
        case HOSTNETWORK:
            return HostNetworkQosDaoDbFacadeImpl.HostNetworkQosDaoDbFacadaeImplMapper.MAPPER.createQosEntity(rs);
        default:
            log.debug("not handled/missing qos_type '{}'", qosType);
            break;
    }
    return null;
}
#end_block

#method_before
private void serializeValue(Map<String, Object> entry, String curveKey, Integer value, int conversionRate) {
    if (value != null) {
        Map<String, Double> parameters = new HashMap<>();
        parameters.put(VdsProperties.HOST_QOS_AVERAGE, (double) value * conversionRate);
        entry.put(curveKey, parameters);
    }
}
#method_after
private void serializeValue(Map<String, Object> entry, String curveKey, Integer value, int conversionRate) {
    if (value != null) {
        Map<String, Integer> parameters = new HashMap<>();
        parameters.put(VdsProperties.HOST_QOS_AVERAGE, value * conversionRate);
        entry.put(curveKey, parameters);
    }
}
#end_block

#method_before
public HostNetworkQos deserialize() {
    Map<String, Object> qosEntry = (Map<String, Object>) rootEntry.get(VdsProperties.HOST_QOS);
    if (qosEntry == null) {
        return null;
    }
    Map<String, Object> outboundEntry = (Map<String, Object>) qosEntry.get(VdsProperties.HOST_QOS_OUTBOUND);
    if (outboundEntry == null) {
        return null;
    }
    HostNetworkQos qos = new HostNetworkQos();
    qos.setOutAverageLinkshare(deserializeValue(outboundEntry, VdsProperties.HOST_QOS_LINKSHARE));
    qos.setOutAverageUpperlimit(deserializeValue(outboundEntry, VdsProperties.HOST_QOS_UPPERLIMIT, MBITS_TO_BITS));
    qos.setOutAverageRealtime(deserializeValue(outboundEntry, VdsProperties.HOST_QOS_REALTIME, MBITS_TO_BITS));
    return qos;
}
#method_after
public HostNetworkQos deserialize() {
    Map<String, Object> qosEntry = (Map<String, Object>) rootEntry.get(VdsProperties.HOST_QOS);
    if (qosEntry == null) {
        return null;
    }
    Map<String, Object> outboundEntry = (Map<String, Object>) qosEntry.get(VdsProperties.HOST_QOS_OUTBOUND);
    if (outboundEntry == null) {
        return null;
    }
    // name and DC ID are not set on purpose - anonymous QoS shouldn't have any!
    HostNetworkQos qos = new HostNetworkQos();
    qos.setOutAverageLinkshare(deserializeValue(outboundEntry, VdsProperties.HOST_QOS_LINKSHARE));
    qos.setOutAverageUpperlimit(deserializeValue(outboundEntry, VdsProperties.HOST_QOS_UPPERLIMIT, MBITS_TO_BITS));
    qos.setOutAverageRealtime(deserializeValue(outboundEntry, VdsProperties.HOST_QOS_REALTIME, MBITS_TO_BITS));
    return qos;
}
#end_block

#method_before
private Integer deserializeValue(Map<String, Object> entry, String curveKey, int conversionRate) {
    Map<String, Double> parameters = (Map<String, Double>) entry.get(curveKey);
    if (parameters == null) {
        return null;
    }
    Double average = parameters.get(VdsProperties.HOST_QOS_AVERAGE);
    return (average == null) ? null : (int) (average / conversionRate);
}
#method_after
private Integer deserializeValue(Map<String, Object> entry, String curveKey, int conversionRate) {
    Map<String, Integer> parameters = (Map<String, Integer>) entry.get(curveKey);
    if (parameters == null) {
        return null;
    }
    Integer average = parameters.get(VdsProperties.HOST_QOS_AVERAGE);
    return (average == null) ? null : (average / conversionRate);
}
#end_block

#method_before
private Object[] normalizeLongs(XmlRpcRequest request) {
    List<Object> result = new ArrayList<>();
    for (int i = 0; i < request.getParameterCount(); i++) {
        Object object = request.getParameter(i);
        if (Long.class.isInstance(object)) {
            result.add(object.toString());
            continue;
        }
        result.add(object);
    }
    return result.toArray();
}
#method_after
private Object[] normalizeLongs(XmlRpcRequest request) {
    List<Object> result = new ArrayList<>();
    for (int i = 0; i < request.getParameterCount(); i++) {
        Object object = request.getParameter(i);
        result.add(longToString(object));
    }
    return result.toArray();
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    boolean isVdsKnown = getVds() != null;
                    if (isStateless && isVdsKnown) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (isStateless && !isVdsKnown) {
                        return AuditLogType.UNASSIGNED;
                    } else if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : (isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM) : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : (isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM) : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateTemplatesMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    List<VmTemplate> templates = getVmTemplateDao().getVmTemplatesByIds(idsToProcess);
    for (VmTemplate template : templates) {
        if (VmTemplateStatus.Locked != template.getStatus()) {
            setManagedVideoDevices(template);
            updateTemplateDisksFromDb(template);
            boolean verifyDisksNotLocked = verifyImagesStatus(template.getDiskList());
            if (verifyDisksNotLocked) {
                loadTemplateData(template);
                Long currentDbGeneration = getVmStaticDao().getDbGeneration(template.getId());
                // currentDbGeneration can be null in case that the template was deleted during the run of OvfDataUpdater.
                if (currentDbGeneration != null && template.getDbGeneration() == currentDbGeneration) {
                    proccessedOvfConfigurationsInfo.add(buildMetadataDictionaryForTemplate(template, vmsAndTemplateMetadata));
                    proccessedIdsInfo.add(template.getId());
                    proccessedOvfGenerationsInfo.add(template.getDbGeneration());
                    proccessDisksDomains(template.getDiskList());
                }
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#method_after
protected Map<Guid, KeyValuePairCompat<String, List<Guid>>> populateTemplatesMetadataForOvfUpdate(List<Guid> idsToProcess) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndTemplateMetadata = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    List<VmTemplate> templates = getVmTemplateDao().getVmTemplatesByIds(idsToProcess);
    for (VmTemplate template : templates) {
        if (VmTemplateStatus.Locked != template.getStatus()) {
            updateTemplateDisksFromDb(template);
            boolean verifyDisksNotLocked = verifyImagesStatus(template.getDiskList());
            if (verifyDisksNotLocked) {
                loadTemplateData(template);
                Long currentDbGeneration = getVmStaticDao().getDbGeneration(template.getId());
                // currentDbGeneration can be null in case that the template was deleted during the run of OvfDataUpdater.
                if (currentDbGeneration != null && template.getDbGeneration() == currentDbGeneration) {
                    proccessedOvfConfigurationsInfo.add(buildMetadataDictionaryForTemplate(template, vmsAndTemplateMetadata));
                    proccessedIdsInfo.add(template.getId());
                    proccessedOvfGenerationsInfo.add(template.getDbGeneration());
                    proccessDisksDomains(template.getDiskList());
                }
            }
        }
    }
    return vmsAndTemplateMetadata;
}
#end_block

#method_before
protected void loadTemplateData(VmTemplate template) {
    if (template.getInterfaces() == null || template.getInterfaces().isEmpty()) {
        template.setInterfaces(getVmNetworkInterfaceDao().getAllForTemplate(template.getId()));
    }
}
#method_after
protected void loadTemplateData(VmTemplate template) {
    setManagedVideoDevices(template);
    if (template.getInterfaces() == null || template.getInterfaces().isEmpty()) {
        template.setInterfaces(getVmNetworkInterfaceDao().getAllForTemplate(template.getId()));
    }
}
#end_block

#method_before
private void setManagedVideoDevices(VmBase vm) {
    Map<Guid, VmDevice> managedDeviceMap = vm.getManagedDeviceMap();
    if (managedDeviceMap == null) {
        managedDeviceMap = new HashMap<Guid, VmDevice>();
    }
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmId(vm.getId());
    for (VmDevice device : devices) {
        if (device.getType() == VmDeviceGeneralType.VIDEO) {
            managedDeviceMap.put(device.getDeviceId(), device);
        }
    }
    vm.setManagedDeviceMap(managedDeviceMap);
}
#method_after
private void setManagedVideoDevices(VmBase vmBase) {
    Map<Guid, VmDevice> managedDeviceMap = vmBase.getManagedDeviceMap();
    if (managedDeviceMap == null) {
        managedDeviceMap = new HashMap<Guid, VmDevice>();
    }
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vmBase.getId(), VmDeviceGeneralType.VIDEO);
    for (VmDevice device : devices) {
        managedDeviceMap.put(device.getDeviceId(), device);
    }
}
#end_block

#method_before
private ValidationResult validateRequiredNetworksAvailable(VDS vds, VM vm, List<VmNetworkInterface> vmNICs, Network displayNetwork, Map<String, Network> networksByName, List<String> hostNetworks, VdsNetworkInterface displayNic) {
    List<String> missingIfs = new ArrayList<>();
    boolean onlyRequiredNetworks = Config.<Boolean>getValue(ConfigValues.OnlyRequiredNetworksMandatoryForVdsSelection);
    for (final VmNetworkInterface vmIf : vmNICs) {
        boolean found = false;
        if (vmIf.getNetworkName() == null) {
            found = true;
        } else {
            for (String networkName : hostNetworks) {
                if (!networkRequiredOnVds(vmIf, networksByName, onlyRequiredNetworks) || StringUtils.equals(vmIf.getNetworkName(), networkName)) {
                    found = true;
                    break;
                }
            }
        }
        if (!found) {
            missingIfs.add(vmIf.getNetworkName());
        }
    }
    if (!missingIfs.isEmpty()) {
        String nics = StringUtils.join(missingIfs, ", ");
        log.debugFormat("host {0} is missing networks required by VM nics {1}", vds.getName(), nics);
        return new ValidationResult(VdcBllMessages.VAR__DETAIL__NETWORK_MISSING, String.format("$networkNames %1$s", nics));
    }
    return validateDisplayNetworkAvailability(vds, onlyRequiredNetworks, displayNic, displayNetwork);
}
#method_after
private ValidationResult validateRequiredNetworksAvailable(VDS vds, VM vm, List<VmNetworkInterface> vmNICs, Network displayNetwork, Map<String, Network> networksByName, List<String> hostNetworks, VdsNetworkInterface displayNic) {
    List<String> missingIfs = new ArrayList<>();
    boolean onlyRequiredNetworks = Config.<Boolean>getValue(ConfigValues.OnlyRequiredNetworksMandatoryForVdsSelection);
    for (final VmNetworkInterface vmIf : vmNICs) {
        boolean found = false;
        if (vmIf.getNetworkName() == null) {
            found = true;
        } else {
            for (String networkName : hostNetworks) {
                if (!networkRequiredOnVds(vmIf, networksByName, onlyRequiredNetworks) || StringUtils.equals(vmIf.getNetworkName(), networkName)) {
                    found = true;
                    break;
                }
            }
        }
        if (!found) {
            missingIfs.add(vmIf.getNetworkName());
        }
    }
    if (!missingIfs.isEmpty()) {
        String nics = StringUtils.join(missingIfs, ", ");
        log.warn("host {} is missing networks required by VM nics {}", vds.getName(), nics);
        return new ValidationResult(VdcBllMessages.VAR__DETAIL__NETWORK_MISSING, String.format("$networkNames %1$s", nics));
    }
    return validateDisplayNetworkAvailability(vds, onlyRequiredNetworks, displayNic, displayNetwork);
}
#end_block

#method_before
private ValidationResult validateDisplayNetworkAvailability(VDS host, boolean onlyRequiredNetworks, VdsNetworkInterface displayNic, Network displayNetwork) {
    if (onlyRequiredNetworks) {
        return ValidationResult.VALID;
    }
    if (displayNetwork == null) {
        return ValidationResult.VALID;
    }
    // Check if display network attached to host and has a proper boot protocol
    if (displayNic == null) {
        log.debugFormat("host {0} is missing the cluster's display network", host.getName());
        return new ValidationResult(VdcBllMessages.VAR__DETAIL__DISPLAY_NETWORK_MISSING);
    }
    if (displayNic.getBootProtocol() == NetworkBootProtocol.NONE) {
        log.debugFormat("Host {0} has the display network {1} configured with improper boot protocol on interface {2}.", host.getName(), displayNetwork.getName(), displayNic.getName());
        return new ValidationResult(VdcBllMessages.VAR__DETAIL__DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL, String.format("$DisplayNetwork %1$s", displayNetwork.getName()));
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateDisplayNetworkAvailability(VDS host, boolean onlyRequiredNetworks, VdsNetworkInterface displayNic, Network displayNetwork) {
    if (onlyRequiredNetworks) {
        return ValidationResult.VALID;
    }
    if (displayNetwork == null) {
        return ValidationResult.VALID;
    }
    // Check if display network attached to host and has a proper boot protocol
    if (displayNic == null) {
        log.warn("host {} is missing the cluster's display network {}", host.getName(), displayNetwork.getName());
        return new ValidationResult(VdcBllMessages.VAR__DETAIL__DISPLAY_NETWORK_MISSING, String.format("$DisplayNetwork %1$s", displayNetwork.getName()));
    }
    if (displayNic.getBootProtocol() == NetworkBootProtocol.NONE) {
        log.warn("Host {} has the display network {} configured with improper boot protocol on interface {}.", host.getName(), displayNetwork.getName(), displayNic.getName());
        return new ValidationResult(VdcBllMessages.VAR__DETAIL__DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL, String.format("$DisplayNetwork %1$s", displayNetwork.getName()));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private void discoverHostName_SelectedItemChanged() {
    ExternalDiscoveredHost dhost = (ExternalDiscoveredHost) getExternalDiscoveredHosts().getSelectedItem();
    ExternalHostGroup dhg = (ExternalHostGroup) getExternalHostGroups().getSelectedItem();
    VDS vds = new VDS();
    if (dhost != null && dhg != null) {
        // $NON-NLS-1$
        vds.setVdsName(dhost.getName() + "." + dhg.getDomainName());
        vds.setHostName(dhost.getIp());
    }
    updateModelFromVds(vds, null, false, null);
}
#method_after
private void discoverHostName_SelectedItemChanged() {
    ExternalDiscoveredHost dhost = (ExternalDiscoveredHost) getExternalDiscoveredHosts().getSelectedItem();
    ExternalHostGroup dhg = (ExternalHostGroup) getExternalHostGroups().getSelectedItem();
    VDS vds = new VDS();
    if (dhost != null && dhg != null) {
        vds.setVdsName(dhost.getName());
        // $NON-NLS-1$
        vds.setHostName(dhost.getName() + "." + dhg.getDomainName());
    }
    updateModelFromVds(vds, null, false, null);
}
#end_block

#method_before
private void updateHostList() {
    Provider provider = getProviders().getSelectedItem();
    if (provider == null) {
        return;
    }
    AsyncQuery getHostGroupsQuery = new AsyncQuery();
    getHostGroupsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalHostGroup> hostGroups = (ArrayList<ExternalHostGroup>) result;
            ListModel externalHostGroupsListModel = getExternalHostGroups();
            externalHostGroupsListModel.setItems(hostGroups);
            externalHostGroupsListModel.setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderHostGroupList(getHostGroupsQuery, provider);
    AsyncQuery getComputeResourceQuery = new AsyncQuery();
    getComputeResourceQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalComputeResource> computeResources = (ArrayList<ExternalComputeResource>) result;
            ListModel externalComputeResourceListModel = getExternalComputeResource();
            externalComputeResourceListModel.setItems(computeResources);
            externalComputeResourceListModel.setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderComputeResourceList(getComputeResourceQuery, provider);
    AsyncQuery getHostsQuery = new AsyncQuery();
    getHostsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<VDS> hosts = (ArrayList<VDS>) result;
            ListModel<VDS> hostNameListModel = getExternalHostName();
            hostNameListModel.setItems(hosts);
            hostNameListModel.setIsChangable(true);
            setEnableSearchHost(true);
            getProviders().setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderHostList(getHostsQuery, provider.getId(), true, getProviderSearchFilter().getEntity());
    AsyncQuery getDiscoveredHostsQuery = new AsyncQuery();
    getDiscoveredHostsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalDiscoveredHost> hosts = (ArrayList<ExternalDiscoveredHost>) result;
            ListModel externalDiscoveredHostsListModel = getExternalDiscoveredHosts();
            externalDiscoveredHostsListModel.setItems(hosts);
            externalDiscoveredHostsListModel.setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderDiscoveredHostList(getDiscoveredHostsQuery, provider);
}
#method_after
private void updateHostList() {
    Provider provider = getProviders().getSelectedItem();
    if (provider == null) {
        return;
    }
    AsyncQuery getHostsQuery = new AsyncQuery();
    getHostsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<VDS> hosts = (ArrayList<VDS>) result;
            ListModel<VDS> hostNameListModel = getExternalHostName();
            hostNameListModel.setItems(hosts);
            hostNameListModel.setIsChangable(true);
            setEnableSearchHost(true);
            getProviders().setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderHostList(getHostsQuery, provider.getId(), true, getProviderSearchFilter().getEntity());
    AsyncQuery getHostGroupsQuery = new AsyncQuery();
    getHostGroupsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalHostGroup> hostGroups = (ArrayList<ExternalHostGroup>) result;
            ListModel externalHostGroupsListModel = getExternalHostGroups();
            externalHostGroupsListModel.setItems(hostGroups);
            externalHostGroupsListModel.setIsChangable(true);
            AsyncQuery getDiscoveredHostsQuery = new AsyncQuery();
            getDiscoveredHostsQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    ArrayList<ExternalDiscoveredHost> hosts = (ArrayList<ExternalDiscoveredHost>) result;
                    ListModel externalDiscoveredHostsListModel = getExternalDiscoveredHosts();
                    externalDiscoveredHostsListModel.setItems(hosts);
                    externalDiscoveredHostsListModel.setIsChangable(true);
                }
            };
            AsyncDataProvider.getInstance().getExternalProviderDiscoveredHostList(getDiscoveredHostsQuery, getProviders().getSelectedItem());
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderHostGroupList(getHostGroupsQuery, provider);
    AsyncQuery getComputeResourceQuery = new AsyncQuery();
    getComputeResourceQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalComputeResource> computeResources = (ArrayList<ExternalComputeResource>) result;
            ListModel externalComputeResourceListModel = getExternalComputeResource();
            externalComputeResourceListModel.setItems(computeResources);
            externalComputeResourceListModel.setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderComputeResourceList(getComputeResourceQuery, provider);
}
#end_block

#method_before
private void initState() {
    reportsEnabled = false;
    xmlInitialized = false;
    reportsWebappDeployed = false;
    scheduledStatusCheckInProgress = false;
    initEventRaised = false;
    // $NON-NLS-1$
    reportBaseUrl = "";
    // $NON-NLS-1$
    reportRightClickUrl = "";
    isCommunityEdition = false;
    resourceMap = new HashMap<String, Resource>();
    dashboardMap = new HashMap<String, Dashboard>();
    // $NON-NLS-1$
    reportsInitEvent = new Event("ReportsInitialize", ReportInit.class);
    retryCount = 0;
}
#method_after
private void initState() {
    reportsEnabled = false;
    xmlInitialized = false;
    reportsWebappDeployed = false;
    scheduledStatusCheckInProgress = false;
    initEventRaised = false;
    // $NON-NLS-1$
    reportBaseUrl = "";
    // $NON-NLS-1$
    reportRightClickUrl = "";
    isCommunityEdition = false;
    resourceMap = new HashMap<String, Resource>();
    dashboardMap = new HashMap<String, Dashboard>();
    // $NON-NLS-1$
    reportsInitEvent = new Event<EventArgs>("ReportsInitialize", ReportInit.class);
    retryCount = 0;
}
#end_block

#method_before
public Event getReportsInitEvent() {
    return reportsInitEvent;
}
#method_after
public Event<EventArgs> getReportsInitEvent() {
    return reportsInitEvent;
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for applicationMode object
    Integer applicationMode = getApplicationMode(getEngineSessionId(request));
    request.setAttribute(ATTR_APPLICATION_MODE, getApplicationModeObject(applicationMode));
    // Set attribute for pluginDefinitions array
    List<PluginData> pluginData = getPluginData();
    request.setAttribute(ATTR_PLUGIN_DEFS, getPluginDefinitionsArray(pluginData));
    // Set attribute for engineSessionTimeout object
    Integer engineSessionTimeout = getEngineSessionTimeout(getEngineSessionId(request));
    request.setAttribute(ATTR_ENGINE_SESSION_TIMEOUT, getEngineSessionTimeoutObject(engineSessionTimeout));
    request.setAttribute(ATTR_ENGINE_REPORTS_BASE_URL, getReportInit(reportRedirectUrl.substring(reportBaseUrl.length()), reportRightClickRedirectUrl.substring(reportBaseUrl.length())));
    super.doGet(request, response);
}
#method_after
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for applicationMode object
    Integer applicationMode = getApplicationMode(getEngineSessionId(request));
    request.setAttribute(ATTR_APPLICATION_MODE, getApplicationModeObject(applicationMode));
    // Set attribute for pluginDefinitions array
    List<PluginData> pluginData = getPluginData();
    request.setAttribute(ATTR_PLUGIN_DEFS, getPluginDefinitionsArray(pluginData));
    // Set attribute for engineSessionTimeout object
    Integer engineSessionTimeout = getEngineSessionTimeout(getEngineSessionId(request));
    request.setAttribute(ATTR_ENGINE_SESSION_TIMEOUT, getEngineSessionTimeoutObject(engineSessionTimeout));
    // Set attribute for engineReportsUrl object
    request.setAttribute(ATTR_ENGINE_REPORTS_BASE_URL, getReportInit(reportRedirectUrl.substring(reportBaseUrl.length()), reportRightClickRedirectUrl.substring(reportBaseUrl.length())));
    super.doGet(request, response);
}
#end_block

#method_before
public void ensureColumnPresent(Column<T, ?> column, String headerText, boolean present, String width) {
    Integer index = getColumnIndex(column);
    boolean columnPresent = index != -1;
    if (!columnPresent) {
        // Add the column
        if (width == null) {
            addColumnWithHtmlHeader(column, headerText);
        } else {
            addColumnWithHtmlHeader(column, headerText, width);
        }
        index = getColumnIndex(column);
    }
    columnVisibleMap.put(index, present);
    setColumnWidth(column, width);
}
#method_after
public void ensureColumnPresent(Column<T, ?> column, String headerText, boolean present, String width) {
    Integer index = getColumnIndex(column);
    boolean columnPresent = index != -1;
    if (!columnPresent) {
        // Add the column
        if (width == null) {
            addColumnWithHtmlHeader(column, headerText);
        } else {
            addColumnWithHtmlHeader(column, headerText, width);
        }
        index = getColumnIndex(column);
    }
    columnVisibleMap.put(index, present);
    if (columnResizePersistenceEnabled) {
        String persistedWidth = readColumnWidth(column);
        if (persistedWidth != null) {
            width = persistedWidth;
        }
    }
    setColumnWidth(column, width);
}
#end_block

#method_before
@Override
public void setColumnWidth(Column<T, ?> column, String width) {
    if (columnResizePersistenceEnabled && !initializedColumns.contains(column)) {
        String persistedWidth = readColumnWidth(column);
        if (persistedWidth != null) {
            width = persistedWidth;
        }
        initializedColumns.add(column);
    }
    Integer index = getColumnIndex(column);
    if (columnVisibleMap.get(index) != null && !columnVisibleMap.get(index)) {
        width = HIDDEN_WIDTH;
    }
    super.setColumnWidth(column, width);
}
#method_after
@Override
public void setColumnWidth(Column<T, ?> column, String width) {
    Integer index = getColumnIndex(column);
    if (columnVisibleMap.get(index) != null && !columnVisibleMap.get(index)) {
        width = HIDDEN_WIDTH;
    }
    super.setColumnWidth(column, width);
}
#end_block

#method_before
protected static void mapVmBaseModelToEntity(org.ovirt.engine.core.common.businessentities.VmBase entity, VmBase model) {
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetBios()) {
        if (model.getBios().isSetBootMenu()) {
            entity.setBootMenuEnabled(model.getBios().getBootMenu().isEnabled());
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
        if (model.getDisplay().isSetFileTransferEnabled()) {
            entity.setSpiceFileTransferEnabled(model.getDisplay().isFileTransferEnabled());
        }
        if (model.getDisplay().isSetCopyPasteEnabled()) {
            entity.setSpiceCopyPasteEnabled(model.getDisplay().isCopyPasteEnabled());
        }
    }
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        entity.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetStartPaused()) {
        entity.setRunAndPause(model.isStartPaused());
    }
    if (model.isSetCpuProfile() && model.getCpuProfile().isSetId()) {
        entity.setCpuProfileId(GuidUtils.asGuid(model.getCpuProfile().getId()));
    }
    if (model.isSetCustomProperties()) {
        entity.setCustomProperties(CustomPropertiesParser.parse(model.getCustomProperties().getCustomProperty()));
    }
}
#method_after
protected static void mapVmBaseModelToEntity(org.ovirt.engine.core.common.businessentities.VmBase entity, VmBase model) {
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetBios()) {
        if (model.getBios().isSetBootMenu()) {
            entity.setBootMenuEnabled(model.getBios().getBootMenu().isEnabled());
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
        if (model.getDisplay().isSetFileTransferEnabled()) {
            entity.setSpiceFileTransferEnabled(model.getDisplay().isFileTransferEnabled());
        }
        if (model.getDisplay().isSetCopyPasteEnabled()) {
            entity.setSpiceCopyPasteEnabled(model.getDisplay().isCopyPasteEnabled());
        }
    }
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        entity.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetStartPaused()) {
        entity.setRunAndPause(model.isStartPaused());
    }
    if (model.isSetCpuProfile() && model.getCpuProfile().isSetId()) {
        entity.setCpuProfileId(GuidUtils.asGuid(model.getCpuProfile().getId()));
    }
    if (model.isSetMigration()) {
        MigrationOptionsMapper.copyMigrationOptions(model.getMigration(), entity);
    }
    if (model.isSetCustomProperties()) {
        entity.setCustomProperties(CustomPropertiesParser.parse(model.getCustomProperties().getCustomProperty()));
    }
}
#end_block

#method_before
protected static void mapVmBaseEntityToModel(VmBase model, org.ovirt.engine.core.common.businessentities.VmBase entity) {
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    if (entity.getVmType() != null) {
        model.setType(map(entity.getVmType(), null));
    }
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setBios(new Bios());
    model.getBios().setBootMenu(new BootMenu());
    model.getBios().getBootMenu().setEnabled(entity.isBootMenuEnabled());
    model.setTimezone(entity.getTimeZone());
    if (entity.getCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getVmInit() != null && entity.getVmInit().getDomain() != null && StringUtils.isNotBlank(entity.getVmInit().getDomain())) {
        Domain domain = new Domain();
        domain.setName(entity.getVmInit().getDomain());
        model.setDomain(domain);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    model.setStartPaused(entity.isRunAndPause());
    if (entity.getCpuProfileId() != null) {
        CpuProfile cpuProfile = new CpuProfile();
        cpuProfile.setId(entity.getCpuProfileId().toString());
        model.setCpuProfile(cpuProfile);
    }
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
}
#method_after
protected static void mapVmBaseEntityToModel(VmBase model, org.ovirt.engine.core.common.businessentities.VmBase entity) {
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    if (entity.getVmType() != null) {
        model.setType(map(entity.getVmType(), null));
    }
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setBios(new Bios());
    model.getBios().setBootMenu(new BootMenu());
    model.getBios().getBootMenu().setEnabled(entity.isBootMenuEnabled());
    model.setTimezone(entity.getTimeZone());
    if (entity.getCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getVmInit() != null && entity.getVmInit().getDomain() != null && StringUtils.isNotBlank(entity.getVmInit().getDomain())) {
        Domain domain = new Domain();
        domain.setName(entity.getVmInit().getDomain());
        model.setDomain(domain);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    model.setStartPaused(entity.isRunAndPause());
    if (entity.getCpuProfileId() != null) {
        CpuProfile cpuProfile = new CpuProfile();
        cpuProfile.setId(entity.getCpuProfileId().toString());
        model.setCpuProfile(cpuProfile);
    }
    model.setMigration(MigrationOptionsMapper.map(entity, null));
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    staticVm.setSerialNumberPolicy(entity.getSerialNumberPolicy());
    staticVm.setCustomSerialNumber(entity.getCustomSerialNumber());
    staticVm.setSpiceFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    staticVm.setSpiceCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    staticVm.setRunAndPause(entity.isRunAndPause());
    staticVm.setCpuProfileId(entity.getCpuProfileId());
    staticVm.setCustomProperties(entity.getCustomProperties());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    staticVm.setSerialNumberPolicy(entity.getSerialNumberPolicy());
    staticVm.setCustomSerialNumber(entity.getCustomSerialNumber());
    staticVm.setSpiceFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    staticVm.setSpiceCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    staticVm.setRunAndPause(entity.isRunAndPause());
    staticVm.setCpuProfileId(entity.getCpuProfileId());
    staticVm.setAutoConverge(entity.getAutoConverge());
    staticVm.setMigrateCompressed(entity.getMigrateCompressed());
    staticVm.setCustomProperties(entity.getCustomProperties());
    return staticVm;
}
#end_block

#method_before
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template, boolean showDynamicInfo) {
    VM model = template != null ? template : new VM();
    mapVmBaseEntityToModel(model, entity.getStaticData());
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.isUseHostCpuFlags()) {
        model.getCpu().setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    model.getCpu().setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    // and dynamic value (current/last run value, that can be different in case of run-once or edit while running)
    if (showDynamicInfo && entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    // fill dynamic data
    if (entity.getDynamicData() != null && !entity.getStatus().isNotRunning()) {
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
        model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
        model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
        model.getDisplay().setProxy(getEffectiveSpiceProxy(entity));
    }
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    return model;
}
#method_after
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template, boolean showDynamicInfo) {
    VM model = template != null ? template : new VM();
    mapVmBaseEntityToModel(model, entity.getStaticData());
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.isUseHostCpuFlags()) {
        model.getCpu().setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    model.getCpu().setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    // and dynamic value (current/last run value, that can be different in case of run-once or edit while running)
    if (showDynamicInfo && entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    // fill dynamic data
    if (entity.getDynamicData() != null && !entity.getStatus().isNotRunning()) {
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setRunOnce(entity.isRunOnce());
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
        model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
        model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
        model.getDisplay().setProxy(getEffectiveSpiceProxy(entity));
    }
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    return model;
}
#end_block

#method_before
private AuditLogType getExecuteAuditLogTypeValue(boolean successful) {
    if (isInternalExecution() && successful) {
        return AuditLogType.ADD_DISK_INTERNAL;
    }
    boolean isVmNameExist = StringUtils.isNotEmpty(getVmName());
    if (successful) {
        if (isVmNameExist) {
            return AuditLogType.USER_ADD_DISK_TO_VM;
        } else {
            return AuditLogType.USER_ADD_DISK;
        }
    } else {
        if (isVmNameExist) {
            return AuditLogType.USER_FAILED_ADD_DISK_TO_VM;
        } else {
            return AuditLogType.USER_FAILED_ADD_DISK;
        }
    }
}
#method_after
private AuditLogType getExecuteAuditLogTypeValue(boolean successful) {
    boolean isVmNameExist = StringUtils.isNotEmpty(getVmName());
    if (successful) {
        if (isInternalExecution()) {
            return AuditLogType.ADD_DISK_INTERNAL;
        }
        if (isVmNameExist) {
            return AuditLogType.USER_ADD_DISK_TO_VM;
        } else {
            return AuditLogType.USER_ADD_DISK;
        }
    } else {
        if (isInternalExecution()) {
            return AuditLogType.ADD_DISK_INTERNAL_FAILURE;
        }
        if (isVmNameExist) {
            return AuditLogType.USER_FAILED_ADD_DISK_TO_VM;
        } else {
            return AuditLogType.USER_FAILED_ADD_DISK;
        }
    }
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            String fetchResultText = object.getFetchResult().getEntity();
            if (ConstantsManager.getInstance().getConstants().errorLoadingFingerprint().equals(fetchResultText)) {
                fetchResult.addStyleName(style.fetchResultErrorLabel());
            } else {
                fetchResult.removeStyleName(style.fetchResultErrorLabel());
            }
            fetchResult.setText(fetchResultText);
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    object.getProviders().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            object.updateHosts();
        }
    });
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
            providersEditor.setVisible(showForemanProviders);
            // showing or hiding radio buttons
            provisionedHostSection.setVisible(showForemanProviders);
            discoveredHostSection.setVisible(showForemanProviders);
            // disabling ip and name textbox when using provisioned hosts
            nameEditor.setEnabled(!showForemanProviders);
            hostAddressEditor.setEnabled(!showForemanProviders);
            if (showForemanProviders) {
                object.updateHosts();
            } else {
                object.cleanHostParametersFields();
                hideProviderWidgets(object);
            }
        }
    });
    object.getIsDiscoveredHosts().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (Boolean.TRUE.equals(object.getIsDiscoveredHosts().getEntity())) {
                rbDiscoveredHost.setValue(true);
                showDiscoveredHostsWidgets(true);
                object.cleanHostParametersFields();
            } else if (Boolean.FALSE.equals(object.getIsDiscoveredHosts().getEntity())) {
                rbProvisionedHost.setValue(true);
                showProvisionedHostsWidgets(true);
                object.cleanHostParametersFields();
            }
        }
    });
    rbPassword.setValue(true);
    rbPassword.setFocus(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List<String> items = (List<String>) object.getPmProxyPreferencesList().getItems();
            String selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener<EventArgs> spmListener = new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#method_after
@Override
@SuppressWarnings("unchecked")
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            String fetchResultText = object.getFetchResult().getEntity();
            if (ConstantsManager.getInstance().getConstants().errorLoadingFingerprint().equals(fetchResultText)) {
                fetchResult.addStyleName(style.fetchResultErrorLabel());
            } else {
                fetchResult.removeStyleName(style.fetchResultErrorLabel());
            }
            fetchResult.setText(fetchResultText);
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    object.getProviders().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            object.updateHosts();
        }
    });
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
            providersEditor.setVisible(showForemanProviders);
            // showing or hiding radio buttons
            provisionedHostSection.setVisible(showForemanProviders);
            discoveredHostSection.setVisible(showForemanProviders);
            // disabling ip and name textbox when using provisioned hosts
            hostAddressEditor.setEnabled(!showForemanProviders);
            if (showForemanProviders) {
                object.updateHosts();
            } else {
                object.cleanHostParametersFields();
                hideProviderWidgets(object);
            }
        }
    });
    object.getIsDiscoveredHosts().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (Boolean.TRUE.equals(object.getIsDiscoveredHosts().getEntity())) {
                rbDiscoveredHost.setValue(true);
                showDiscoveredHostsWidgets(true);
                object.cleanHostParametersFields();
            } else if (Boolean.FALSE.equals(object.getIsDiscoveredHosts().getEntity())) {
                rbProvisionedHost.setValue(true);
                showProvisionedHostsWidgets(true);
                object.cleanHostParametersFields();
            }
        }
    });
    rbPassword.setValue(true);
    rbPassword.setFocus(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List<String> items = (List<String>) object.getPmProxyPreferencesList().getItems();
            String selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener<EventArgs> spmListener = new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    getProtocol().setEntity(VdsProtocol.STOMP == vds.getProtocol());
    getProtocol().setIsAvailable(showTransportProperties(vds));
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    getProtocol().setEntity(VdsProtocol.STOMP == vds.getProtocol());
    getProtocol().setIsChangable(editTransportProperties(vds));
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
private void discoverHostName_SelectedItemChanged() {
    ExternalDiscoveredHost dhost = (ExternalDiscoveredHost) getExternalDiscoveredHosts().getSelectedItem();
    ExternalHostGroup dhg = (ExternalHostGroup) getExternalHostGroups().getSelectedItem();
    VDS vds = new VDS();
    if (dhost != null && dhg != null) {
        // $NON-NLS-1$
        vds.setVdsName(dhost.getName() + "." + dhg.getDomainName());
        vds.setHostName(dhost.getIp());
    }
    updateModelFromVds(vds, null, false, null);
}
#method_after
private void discoverHostName_SelectedItemChanged() {
    ExternalDiscoveredHost dhost = (ExternalDiscoveredHost) getExternalDiscoveredHosts().getSelectedItem();
    VDS vds = new VDS();
    if (dhost != null) {
        vds.setVdsName(dhost.getName());
        vds.setHostName(dhost.getIp());
    }
    updateModelFromVds(vds, null, false, null);
}
#end_block

#method_before
private void updateHostList() {
    Provider provider = getProviders().getSelectedItem();
    if (provider == null) {
        return;
    }
    AsyncQuery getHostGroupsQuery = new AsyncQuery();
    getHostGroupsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalHostGroup> hostGroups = (ArrayList<ExternalHostGroup>) result;
            ListModel externalHostGroupsListModel = getExternalHostGroups();
            externalHostGroupsListModel.setItems(hostGroups);
            externalHostGroupsListModel.setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderHostGroupList(getHostGroupsQuery, provider);
    AsyncQuery getComputeResourceQuery = new AsyncQuery();
    getComputeResourceQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalComputeResource> computeResources = (ArrayList<ExternalComputeResource>) result;
            ListModel externalComputeResourceListModel = getExternalComputeResource();
            externalComputeResourceListModel.setItems(computeResources);
            externalComputeResourceListModel.setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderComputeResourceList(getComputeResourceQuery, provider);
    AsyncQuery getHostsQuery = new AsyncQuery();
    getHostsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<VDS> hosts = (ArrayList<VDS>) result;
            ListModel<VDS> hostNameListModel = getExternalHostName();
            hostNameListModel.setItems(hosts);
            hostNameListModel.setIsChangable(true);
            setEnableSearchHost(true);
            getProviders().setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderHostList(getHostsQuery, provider.getId(), true, getProviderSearchFilter().getEntity());
    AsyncQuery getDiscoveredHostsQuery = new AsyncQuery();
    getDiscoveredHostsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalDiscoveredHost> hosts = (ArrayList<ExternalDiscoveredHost>) result;
            ListModel externalDiscoveredHostsListModel = getExternalDiscoveredHosts();
            externalDiscoveredHostsListModel.setItems(hosts);
            externalDiscoveredHostsListModel.setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderDiscoveredHostList(getDiscoveredHostsQuery, provider);
}
#method_after
private void updateHostList() {
    Provider provider = getProviders().getSelectedItem();
    if (provider == null) {
        return;
    }
    AsyncQuery getHostsQuery = new AsyncQuery();
    getHostsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<VDS> hosts = (ArrayList<VDS>) result;
            ListModel<VDS> hostNameListModel = getExternalHostName();
            hostNameListModel.setItems(hosts);
            hostNameListModel.setIsChangable(true);
            setEnableSearchHost(true);
            getProviders().setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderHostList(getHostsQuery, provider.getId(), true, getProviderSearchFilter().getEntity());
    AsyncQuery getDiscoveredHostsQuery = new AsyncQuery();
    getDiscoveredHostsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalDiscoveredHost> hosts = (ArrayList<ExternalDiscoveredHost>) result;
            ListModel externalDiscoveredHostsListModel = getExternalDiscoveredHosts();
            externalDiscoveredHostsListModel.setItems(hosts);
            externalDiscoveredHostsListModel.setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderDiscoveredHostList(getDiscoveredHostsQuery, provider);
    AsyncQuery getHostGroupsQuery = new AsyncQuery();
    getHostGroupsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalHostGroup> hostGroups = (ArrayList<ExternalHostGroup>) result;
            ListModel externalHostGroupsListModel = getExternalHostGroups();
            externalHostGroupsListModel.setItems(hostGroups);
            externalHostGroupsListModel.setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderHostGroupList(getHostGroupsQuery, provider);
    AsyncQuery getComputeResourceQuery = new AsyncQuery();
    getComputeResourceQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalComputeResource> computeResources = (ArrayList<ExternalComputeResource>) result;
            ListModel externalComputeResourceListModel = getExternalComputeResource();
            externalComputeResourceListModel.setItems(computeResources);
            externalComputeResourceListModel.setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderComputeResourceList(getComputeResourceQuery, provider);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (!super.equals(obj))
        return false;
    return equalValues((HostNetworkQos) obj);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (!super.equals(obj))
        return false;
    HostNetworkQos other = (HostNetworkQos) obj;
    return ObjectUtils.objectsEqual(getOutAverageLinkshare(), other.getOutAverageLinkshare()) && ObjectUtils.objectsEqual(getOutAverageUpperlimit(), other.getOutAverageUpperlimit()) && ObjectUtils.objectsEqual(getOutAverageRealtime(), other.getOutAverageRealtime());
}
#end_block

#method_before
private Throwable handleException(Exception e) {
    if (e instanceof RuntimeException) {
        throw (RuntimeException) e;
    } else {
        throw new RuntimeException(e);
    }
}
#method_after
private void handleException(Exception e) {
    if (e instanceof RuntimeException) {
        throw (RuntimeException) e;
    } else {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
@Override
protected void build(UnitVmModel model, VmBase vm) {
    super.build(model, vm);
    vm.setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    vm.setVmType(model.getVmType().getSelectedItem());
    vm.setVdsGroupId(model.getSelectedCluster().getId());
    vm.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? model.getTimeZone().getSelectedItem().getTimeZoneKey() : // $NON-NLS-1$
    "");
    // $NON-NLS-1$
    vm.setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : "");
    vm.setDeleteProtected(model.getIsDeleteProtected().getEntity());
    vm.setOsId(model.getOSType().getSelectedItem());
    vm.setVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    vm.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    vm.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    vm.setBootMenuEnabled(model.getBootMenuEnabled().getEntity());
    vm.setSpiceFileTransferEnabled(model.getSpiceFileTransferEnabled().getEntity());
    vm.setSpiceCopyPasteEnabled(model.getSpiceCopyPasteEnabled().getEntity());
    vm.setCustomProperties(model.getCustomPropertySheet().serialize());
}
#method_after
@Override
protected void build(UnitVmModel model, VmBase vm) {
    super.build(model, vm);
    vm.setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    vm.setVmType(model.getVmType().getSelectedItem());
    vm.setVdsGroupId(model.getSelectedCluster().getId());
    vm.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? model.getTimeZone().getSelectedItem().getTimeZoneKey() : // $NON-NLS-1$
    "");
    // $NON-NLS-1$
    vm.setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : "");
    vm.setDeleteProtected(model.getIsDeleteProtected().getEntity());
    vm.setOsId(model.getOSType().getSelectedItem());
    vm.setVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    vm.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    vm.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    vm.setBootMenuEnabled(model.getBootMenuEnabled().getEntity());
    vm.setSpiceFileTransferEnabled(model.getSpiceFileTransferEnabled().getEntity());
    vm.setSpiceCopyPasteEnabled(model.getSpiceCopyPasteEnabled().getEntity());
    vm.setAutoConverge(model.getAutoConverge().getSelectedItem());
    vm.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    vm.setCustomProperties(model.getCustomPropertySheet().serialize());
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getBaseTemplate().setIsChangable(false);
    getModel().getProvisioning().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    getModel().getTemplateVersionName().setIsChangable(!template.isBaseTemplate());
    getModel().getName().setIsChangable(template.isBaseTemplate());
    if (template.getStoragePoolId() != null && !template.getStoragePoolId().equals(Guid.Empty)) {
        AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                final StoragePool dataCenter = (StoragePool) returnValue;
                AsyncDataProvider.getInstance().getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
                        ArrayList<VDSGroup> clustersSupportingVirt = new ArrayList<VDSGroup>();
                        // filter clusters supporting virt service only
                        for (VDSGroup cluster : clusters) {
                            if (cluster.supportsVirtService()) {
                                clustersSupportingVirt.add(cluster);
                            }
                        }
                        List<VDSGroup> filteredClusters = AsyncDataProvider.getInstance().filterByArchitecture(clustersSupportingVirt, template.getClusterArch());
                        model.setDataCentersAndClusters(model, new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCenter })), filteredClusters, template.getVdsGroupId());
                        AsyncDataProvider.getInstance().isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                                initTemplate();
                                initCdImage();
                            }
                        }), template.getId());
                    }
                }, getModel().getHash()), true, false);
            }
        }, getModel().getHash()), template.getStoragePoolId());
    }
    AsyncDataProvider.getInstance().getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel());
            }
        }
    }), template.getId());
    updateRngDevice(template.getId());
    getModel().getMigrationMode().setSelectedItem(template.getMigrationSupport());
    getModel().getCustomPropertySheet().deserialize(template.getCustomProperties());
    setupBaseTemplate(template.getBaseTemplateId());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getBaseTemplate().setIsChangable(false);
    getModel().getProvisioning().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    getModel().getTemplateVersionName().setIsChangable(!template.isBaseTemplate());
    getModel().getName().setIsChangable(template.isBaseTemplate());
    if (template.getStoragePoolId() != null && !template.getStoragePoolId().equals(Guid.Empty)) {
        AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                final StoragePool dataCenter = (StoragePool) returnValue;
                AsyncDataProvider.getInstance().getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
                        ArrayList<VDSGroup> clustersSupportingVirt = new ArrayList<VDSGroup>();
                        // filter clusters supporting virt service only
                        for (VDSGroup cluster : clusters) {
                            if (cluster.supportsVirtService()) {
                                clustersSupportingVirt.add(cluster);
                            }
                        }
                        List<VDSGroup> filteredClusters = AsyncDataProvider.getInstance().filterByArchitecture(clustersSupportingVirt, template.getClusterArch());
                        model.setDataCentersAndClusters(model, new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCenter })), filteredClusters, template.getVdsGroupId());
                        AsyncDataProvider.getInstance().isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                                initTemplate();
                                initCdImage();
                            }
                        }), template.getId());
                    }
                }, getModel().getHash()), true, false);
            }
        }, getModel().getHash()), template.getStoragePoolId());
    }
    AsyncDataProvider.getInstance().getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel());
            }
        }
    }), template.getId());
    updateRngDevice(template.getId());
    getModel().getMigrationMode().setSelectedItem(template.getMigrationSupport());
    setupBaseTemplate(template.getBaseTemplateId());
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateNumOfSockets();
    updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateMigrationForLocalSD();
    updateOSValues();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), getClusterCompatibilityVersion(), template.getCpuProfileId());
    }
    updateCustomPropertySheet();
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateNumOfSockets();
    updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateMigrationForLocalSD();
    updateOSValues();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), getClusterCompatibilityVersion(), template.getCpuProfileId());
    }
    updateCustomPropertySheet();
    getModel().getCustomPropertySheet().deserialize(template.getCustomProperties());
}
#end_block

#method_before
protected void addCustomModelsDetailModelList(ObservableCollection<EntityModel> list) {
    TemplateDiskListModel diskListModel = new TemplateDiskListModel();
    diskListModel.setSystemTreeContext(this);
    list.add(3, diskListModel);
    list.add(new TemplateEventListModel());
    list.add(new PermissionListModel());
}
#method_after
protected void addCustomModelsDetailModelList(final List<EntityModel> list, int customPosition, final TemplateDiskListModel templateDiskListModel, final TemplateEventListModel templateEventListModel, final PermissionListModel permissionListModel) {
    templateDiskListModel.setSystemTreeContext(this);
    list.add(customPosition, templateDiskListModel);
    list.add(templateEventListModel);
    list.add(permissionListModel);
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(vm.getVmInit() != null);
    getModel().getVmInitModel().init(vm.getStaticData());
    getModel().getTemplate().setIsChangable(false);
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
    getModel().getVmType().setIsChangable(true);
    getModel().getCopyPermissions().setIsAvailable(true);
    DisksAllocationModel disksAllocationModel = getModel().getDisksAllocationModel();
    disksAllocationModel.setIsAliasChangable(true);
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final StoragePool dataCenter = (StoragePool) returnValue;
            if (dataCenter == null) {
                disableNewTemplateModel(ConstantsManager.getInstance().getConstants().dataCenterIsNotAccessibleMsg());
            } else {
                AsyncDataProvider.getInstance().getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
                        List<VDSGroup> filteredClusters = AsyncDataProvider.getInstance().filterByArchitecture(clusters, vm.getClusterArch());
                        model.setDataCentersAndClusters(model, Arrays.asList(dataCenter), filteredClusters, vm.getVdsGroupId());
                        initTemplate();
                    }
                }, getModel().getHash()), true, false);
                AsyncDataProvider.getInstance().isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                    }
                }, getModel().getHash()), vm.getId());
            }
        }
    }, getModel().getHash()), vm.getStoragePoolId());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(vm.getVmInit() != null);
    getModel().getVmInitModel().init(vm.getStaticData());
    getModel().getTemplate().setIsChangable(false);
    getModel().getVmType().setIsChangable(true);
    getModel().getCopyPermissions().setIsAvailable(true);
    DisksAllocationModel disksAllocationModel = getModel().getDisksAllocationModel();
    disksAllocationModel.setIsAliasChangable(true);
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final StoragePool dataCenter = (StoragePool) returnValue;
            if (dataCenter == null) {
                disableNewTemplateModel(ConstantsManager.getInstance().getConstants().dataCenterIsNotAccessibleMsg());
            } else {
                AsyncDataProvider.getInstance().getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
                        List<VDSGroup> filteredClusters = AsyncDataProvider.getInstance().filterByArchitecture(clusters, vm.getClusterArch());
                        model.setDataCentersAndClusters(model, Arrays.asList(dataCenter), filteredClusters, vm.getVdsGroupId());
                        initTemplate();
                    }
                }, getModel().getHash()), true, false);
                AsyncDataProvider.getInstance().isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                    }
                }, getModel().getHash()), vm.getId());
            }
        }
    }, getModel().getHash()), vm.getStoragePoolId());
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateQuotaByCluster(null, null);
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateOSValues();
    updateTemplate();
    updateNumOfSockets();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), getModel().getSelectedCluster().getcompatibility_version(), vm.getCpuProfileId());
    }
    updateCustomPropertySheet();
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateQuotaByCluster(null, null);
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateOSValues();
    updateTemplate();
    updateNumOfSockets();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), getModel().getSelectedCluster().getcompatibility_version(), vm.getCpuProfileId());
    }
    updateCustomPropertySheet();
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
}
#end_block

#method_before
public VDS getRandomUpServer(Guid clusterId) {
    List<VDS> servers = getAllUpServers(clusterId);
    if (servers == null || servers.isEmpty()) {
        return null;
    }
    try {
        return servers.get(SecureRandom.getInstance("SHA1PRNG").nextInt(servers.size()));
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public VDS getRandomUpServer(Guid clusterId) {
    List<VDS> servers = getAllUpServers(clusterId);
    if (servers == null || servers.isEmpty()) {
        return null;
    }
    return servers.get(new Random().nextInt(servers.size()));
}
#end_block

#method_before
protected VDS checkForActiveVds() {
    List<VDS> hosts = getVdsDAO().getAllForStoragePoolAndStatus(getStoragePool().getId(), VDSStatus.Up);
    if (!hosts.isEmpty()) {
        try {
            return hosts.get(SecureRandom.getInstance("SHA1PRNG").nextInt(hosts.size()));
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    return null;
}
#method_after
protected VDS checkForActiveVds() {
    List<VDS> hosts = getVdsDAO().getAllForStoragePoolAndStatus(getStoragePool().getId(), VDSStatus.Up);
    if (!hosts.isEmpty()) {
        return hosts.get(new Random().nextInt(hosts.size()));
    }
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    return null;
}
#end_block

#method_before
@Before
public void setup() throws IOException, URISyntaxException {
    String mimeTypesFile = this.getClass().getResource("mime.types").toURI().toASCIIString().replaceAll("file:", "");
    MimetypesFileTypeMap mimeMap = new MimetypesFileTypeMap(mimeTypesFile);
    ServletUtils.setMimeMap(mimeMap);
    canReadFileName = this.getClass().getResource("small_file.txt").toURI().toASCIIString().replaceAll("file:", "");
}
#method_after
@Before
public void setup() throws IOException, URISyntaxException {
    canReadFileName = this.getClass().getResource("small_file.txt").toURI().toASCIIString().replaceAll("file:", "");
}
#end_block

#method_before
@SuppressWarnings("synthetic-access")
public void InitDictionaries(Version ver) {
    // init dictionaries
    _intelCpuByNameDictionary.clear();
    _amdCpuByNameDictionary.clear();
    _ibmCpuByNameDictionary.clear();
    _allCpuList.clear();
    String[] cpus = Config.<String>getValue(ConfigValues.ServerCPUList, ver.toString()).split("[;]", -1);
    for (String cpu : cpus) {
        if (!StringUtils.isEmpty(cpu)) {
            // [0]-level, [1]-name, [2]-flags, [3]-verb, [4]-arch
            final String[] info = cpu.split("[:]", -1);
            if (info.length == 5) {
                // if no flags at all create new list instead of split
                HashSet<String> flgs = (StringUtils.isEmpty(info[2])) ? new HashSet<String>() : new HashSet<String>(Arrays.asList(info[2].split("[,]", -1)));
                String arch = info[4].trim();
                ArchitectureType archType = ArchitectureType.valueOf(arch);
                String levelString = info[0].trim();
                int level = 0;
                if (StringUtils.isNotEmpty(levelString)) {
                    level = Integer.parseInt(levelString);
                }
                ServerCpu sc = new ServerCpu(info[1], level, flgs, info[3], archType);
                if (sc.getFlags().contains(_intelFlag)) {
                    _intelCpuByNameDictionary.put(sc.getCpuName(), sc);
                    _intelCpuByVdsNameDictionary.put(sc.getVdsVerbData(), sc);
                } else if (sc.getFlags().contains(_amdFlag)) {
                    _amdCpuByNameDictionary.put(sc.getCpuName(), sc);
                    _amdCpuByVdsNameDictionary.put(sc.getVdsVerbData(), sc);
                } else if (sc.getFlags().contains(_ibmFlag)) {
                    _ibmCpuByNameDictionary.put(sc.getCpuName(), sc);
                    _ibmCpuByVdsNameDictionary.put(sc.getVdsVerbData(), sc);
                }
                _allCpuList.add(sc);
            } else {
                log.errorFormat("Error getting info for CPU: {0}, not in expected format.", cpu);
            }
        }
    }
    _intelCpuList = new ArrayList<ServerCpu>(_intelCpuByNameDictionary.values());
    _amdCpuList = new ArrayList<ServerCpu>(_amdCpuByNameDictionary.values());
    _ibmCpuList = new ArrayList<ServerCpu>(_ibmCpuByNameDictionary.values());
    Comparator<ServerCpu> cpuComparator = new Comparator<ServerCpu>() {

        @Override
        public int compare(ServerCpu o1, ServerCpu o2) {
            return Integer.valueOf(o1.getLevel()).compareTo(o2.getLevel());
        }
    };
    // Sort by the highest cpu level so the highest cpu match will be
    // selected first
    Collections.sort(_intelCpuList, cpuComparator);
    Collections.sort(_amdCpuList, cpuComparator);
    Collections.sort(_ibmCpuList, cpuComparator);
}
#method_after
@SuppressWarnings("synthetic-access")
public void InitDictionaries(Version ver) {
    // init dictionaries
    _intelCpuByNameDictionary.clear();
    _amdCpuByNameDictionary.clear();
    _ibmCpuByNameDictionary.clear();
    _allCpuList.clear();
    String[] cpus = Config.<String>getValue(ConfigValues.ServerCPUList, ver.toString()).split("[;]", -1);
    for (String cpu : cpus) {
        if (!StringUtils.isEmpty(cpu)) {
            // [0]-level, [1]-name, [2]-flags, [3]-verb, [4]-arch
            final String[] info = cpu.split("[:]", -1);
            if (info.length == 5) {
                // if no flags at all create new list instead of split
                HashSet<String> flgs = (StringUtils.isEmpty(info[2])) ? new HashSet<String>() : new HashSet<String>(Arrays.asList(info[2].split("[,]", -1)));
                String arch = info[4].trim();
                ArchitectureType archType = ArchitectureType.valueOf(arch);
                String levelString = info[0].trim();
                int level = 0;
                if (StringUtils.isNotEmpty(levelString)) {
                    level = Integer.parseInt(levelString);
                }
                ServerCpu sc = new ServerCpu(info[1], level, flgs, info[3], archType);
                if (sc.getFlags().contains(_intelFlag)) {
                    _intelCpuByNameDictionary.put(sc.getCpuName(), sc);
                    _intelCpuByVdsNameDictionary.put(sc.getVdsVerbData(), sc);
                } else if (sc.getFlags().contains(_amdFlag)) {
                    _amdCpuByNameDictionary.put(sc.getCpuName(), sc);
                    _amdCpuByVdsNameDictionary.put(sc.getVdsVerbData(), sc);
                } else if (sc.getFlags().contains(_ibmFlag)) {
                    _ibmCpuByNameDictionary.put(sc.getCpuName(), sc);
                    _ibmCpuByVdsNameDictionary.put(sc.getVdsVerbData(), sc);
                }
                _allCpuList.add(sc);
            } else {
                log.error("Error getting info for CPU '{}', not in expected format.", cpu);
            }
        }
    }
    _intelCpuList = new ArrayList<ServerCpu>(_intelCpuByNameDictionary.values());
    _amdCpuList = new ArrayList<ServerCpu>(_amdCpuByNameDictionary.values());
    _ibmCpuList = new ArrayList<ServerCpu>(_ibmCpuByNameDictionary.values());
    Comparator<ServerCpu> cpuComparator = new Comparator<ServerCpu>() {

        @Override
        public int compare(ServerCpu o1, ServerCpu o2) {
            return Integer.valueOf(o1.getLevel()).compareTo(o2.getLevel());
        }
    };
    // Sort by the highest cpu level so the highest cpu match will be
    // selected first
    Collections.sort(_intelCpuList, cpuComparator);
    Collections.sort(_amdCpuList, cpuComparator);
    Collections.sort(_ibmCpuList, cpuComparator);
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    List<VDS> hostsToRunOn = new ArrayList<VDS>();
    // full name of the vm cpu
    String customCpu;
    Version latestVer = CpuFlagsManagerHandler.getLatestDictionaryVersion();
    /* get required cpu name */
    if (StringUtils.isNotEmpty(vm.getCpuName())) {
        // dynamic check - used for 1.migrating vms 2.run-once 3.after dynamic field is updated with current static-field\cluster
        customCpu = vm.getCpuName();
    } else if (StringUtils.isNotEmpty(vm.getCustomCpuName())) {
        // static check - used only for cases where the dynamic value hasn't been updated yet(canDo validation)
        customCpu = vm.getCustomCpuName();
    } else {
        // use cluster default - all hosts are valid
        return hosts;
    }
    // translate vdsVerb to full cpu name
    customCpu = CpuFlagsManagerHandler.GetCpuNameByVDSVerbData(customCpu, latestVer);
    if (StringUtils.isNotEmpty(customCpu)) {
        /* find compatible hosts */
        for (VDS host : hosts) {
            ServerCpu cpu = CpuFlagsManagerHandler.FindMaxServerCpuByFlags(host.getCpuFlags(), latestVer);
            String hostCpuName = cpu == null ? null : cpu.getCpuName();
            if (StringUtils.isNotEmpty(hostCpuName)) {
                if (CpuFlagsManagerHandler.CheckIfCpusSameManufacture(customCpu, hostCpuName, latestVer)) {
                    // verify comparison uses only one cpu-level scale
                    int compareResult = CpuFlagsManagerHandler.compareCpuLevels(customCpu, hostCpuName, latestVer);
                    if (compareResult <= 0) {
                        hostsToRunOn.add(host);
                        log.debugFormat("Host {0} wasn't filtered out as it has a CPU level ({1}) which is higher or equal than the CPU level the VM was run with ({2})", host.getName(), hostCpuName, customCpu);
                    } else {
                        log.debugFormat("Host {0} was filtered out as it has a CPU level ({1}) which is lower than the CPU level the VM was run with ({2})", host.getName(), hostCpuName, customCpu);
                        messages.addMessage(host.getId(), String.format("$hostCPULevel %1$s", hostCpuName));
                        messages.addMessage(host.getId(), String.format("$vmCPULevel %1$s", customCpu));
                        messages.addMessage(host.getId(), VdcBllMessages.VAR__DETAIL__LOW_CPU_LEVEL.toString());
                    }
                }
            }
        }
    }
    return hostsToRunOn;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    List<VDS> hostsToRunOn = new ArrayList<VDS>();
    // full name of the vm cpu
    String customCpu;
    Version latestVer = CpuFlagsManagerHandler.getLatestDictionaryVersion();
    /* get required cpu name */
    if (StringUtils.isNotEmpty(vm.getCpuName())) {
        // dynamic check - used for 1.migrating vms 2.run-once 3.after dynamic field is updated with current static-field\cluster
        customCpu = vm.getCpuName();
    } else if (StringUtils.isNotEmpty(vm.getCustomCpuName())) {
        // static check - used only for cases where the dynamic value hasn't been updated yet(canDo validation)
        customCpu = vm.getCustomCpuName();
    } else {
        // use cluster default - all hosts are valid
        return hosts;
    }
    // translate vdsVerb to full cpu name
    customCpu = CpuFlagsManagerHandler.getCpuNameByCpuId(customCpu, latestVer);
    if (StringUtils.isNotEmpty(customCpu)) {
        /* find compatible hosts */
        for (VDS host : hosts) {
            ServerCpu cpu = CpuFlagsManagerHandler.findMaxServerCpuByFlags(host.getCpuFlags(), latestVer);
            String hostCpuName = cpu == null ? null : cpu.getCpuName();
            if (StringUtils.isNotEmpty(hostCpuName)) {
                if (CpuFlagsManagerHandler.checkIfCpusSameManufacture(customCpu, hostCpuName, latestVer)) {
                    // verify comparison uses only one cpu-level scale
                    int compareResult = CpuFlagsManagerHandler.compareCpuLevels(customCpu, hostCpuName, latestVer);
                    if (compareResult <= 0) {
                        hostsToRunOn.add(host);
                        log.debug("Host '{}' wasn't filtered out as it has a CPU level ({}) which is higher or equal than the CPU level the VM was run with ({})", host.getName(), hostCpuName, customCpu);
                    } else {
                        log.debug("Host '{}' was filtered out as it has a CPU level ({}) which is lower than the CPU level the VM was run with ({})", host.getName(), hostCpuName, customCpu);
                        messages.addMessage(host.getId(), String.format("$hostCPULevel %1$s", hostCpuName));
                        messages.addMessage(host.getId(), String.format("$vmCPULevel %1$s", customCpu));
                        messages.addMessage(host.getId(), VdcBllMessages.VAR__DETAIL__LOW_CPU_LEVEL.toString());
                    }
                }
            }
        }
    }
    return hostsToRunOn;
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    throw e;
                default:
                    log.warnFormat("Failed to run VM {0}: {1}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.infoFormat("Trying to rerun VM {0}", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    throw e;
                default:
                    log.warn("Failed to run VM '{}': {}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.info("Trying to rerun VM '{}'", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#end_block

#method_before
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.errorFormat("VM {0} ({1}) already contains stateless snapshot, removing it", getVm().getName(), getVm().getId());
        removeVmStatlessImages();
    } else {
        log.infoFormat("Creating stateless snapshot for VM {0} ({1})", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("Failed to create stateless snapshot for VM {0} ({1})", getVm().getName(), getVm().getId());
        }
    }
}
#method_after
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.error("VM '{}' ({}) already contains stateless snapshot, removing it", getVm().getName(), getVm().getId());
        removeVmStatlessImages();
    } else {
        log.info("Creating stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, createContextForStatelessSnapshotCreation());
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.error("Failed to create stateless snapshot for VM '{}' ({})", getVm().getName(), getVm().getId());
        }
    }
}
#end_block

#method_before
protected VMStatus createVm() {
    final String cdPath = chooseCd();
    if (StringUtils.isNotEmpty(cdPath)) {
        log.infoFormat("Running VM with attached cd {0}", cdPath);
    }
    updateCurrentCd(cdPath);
    getVm().setCdPath(cdPathWindowsToLinux(cdPath));
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    initParametersForExternalNetworks();
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, buildCreateVmParameters(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotUsed = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#method_after
protected VMStatus createVm() {
    final String cdPath = chooseCd();
    if (StringUtils.isNotEmpty(cdPath)) {
        log.info("Running VM with attached cd '{}'", cdPath);
    }
    updateCurrentCd(cdPath);
    getVm().setCdPath(cdPathWindowsToLinux(cdPath));
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    initParametersForExternalNetworks();
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, buildCreateVmParameters(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotUsed = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#end_block

#method_before
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
    (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                getVm().setInitializationType(InitializationType.Sysprep);
            } else if (getVm().getVmInit() != null) {
                getVm().setInitializationType(InitializationType.CloudInit);
            } else {
                getVm().setInitializationType(InitializationType.None);
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
    }
    // get what cpu flags should be passed to vdsm according to cluster
    // cpu name
    getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
    VmHandler.updateVmGuestAgentVersion(getVm());
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        getVm().setCpuName((getVm().getCustomCpuName() != null ? getVm().getCustomCpuName() : getVm().getVdsGroupCpuFlagsData()));
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine((getVm().getCustomEmulatedMachine() != null ? getVm().getCustomEmulatedMachine() : getVdsGroup().getEmulatedMachine()));
    }
    if (getFlow() != RunVmFlow.RESUME_HIBERNATE) {
        getVm().setHibernationVolHandle(getMemoryFromSnapshot());
    }
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
    (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPayloadExists(VmDeviceType.FLOPPY)) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPayloadExists(VmDeviceType.CDROM)) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
        // the payload since we can only have one media (Floppy/CDROM) per payload.
        if (getParameters().getInitializationType() == InitializationType.Sysprep && isPayloadExists(VmDeviceType.FLOPPY)) {
            getVm().setVmPayload(null);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && isPayloadExists(VmDeviceType.CDROM)) {
            getVm().setVmPayload(null);
        }
    }
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        getVm().setVmPayload(null);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(CpuFlagsManagerHandler.getCpuId(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine((getVm().getCustomEmulatedMachine() != null ? getVm().getCustomEmulatedMachine() : getVdsGroup().getEmulatedMachine()));
    }
    if (getFlow() != RunVmFlow.RESUME_HIBERNATE) {
        getVm().setHibernationVolHandle(getMemoryFromSnapshot());
    }
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    if (isRunAsStateless()) {
        return validateSpaceRequirements();
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    // Currently we cannot use two payloads in the same media (cdrom/floppy)
    if (getParameters().getInitializationType() != null) {
        if (getParameters().getInitializationType() == InitializationType.Sysprep && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_WITH_SYSPREP);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_CDROM_WITH_CLOUD_INIT);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (isStatelessSnapshotExistsForVm()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.errorFormat("Could not run VM {0} ({1}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#method_after
@Override
protected void endSuccessfully() {
    if (isStatelessSnapshotExistsForVm()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.error("Could not run VM '{}' ({}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#end_block

#method_before
public void setCustomEmulatedMachine(String customEmulatedMachine) {
    this.customEmulatedMachine = ((customEmulatedMachine == null || customEmulatedMachine.length() == 0) ? null : customEmulatedMachine);
}
#method_after
public void setCustomEmulatedMachine(String customEmulatedMachine) {
    this.customEmulatedMachine = ((customEmulatedMachine == null || customEmulatedMachine.trim().isEmpty()) ? null : customEmulatedMachine);
}
#end_block

#method_before
public void setCustomCpuName(String customCpuName) {
    this.customCpuName = ((customCpuName == null || customCpuName.length() == 0) ? null : customCpuName);
}
#method_after
public void setCustomCpuName(String customCpuName) {
    this.customCpuName = ((customCpuName == null || customCpuName.trim().isEmpty()) ? null : customCpuName);
}
#end_block

#method_before
public void init() {
    log.info("Start initializing " + getClass().getSimpleName());
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getStatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Is there any VM that is not fully Up or fully Down?
    boolean runningVmsInTransition = false;
    // Cleanup all vms dynamic data. This is defensive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.isNotRunning()) {
            if (vm.getRunOnVds() != null) {
                MultiValueMapUtils.addToMap(vm.getRunOnVds(), vm.getId(), vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
            }
            if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                SetVmUnknown(vm);
            }
        }
        if (!runningVmsInTransition && vm.isRunning() && vm.getStatus() != VMStatus.Up) {
            runningVmsInTransition = true;
        }
    }
    // Clean pending memory and CPUs if there is no VM in transition on a given Host
    // (meaning we tried to start a VM and the engine crashed before telling VDSM about it)
    List<VdsDynamic> updatedEntities = new ArrayList<>();
    for (VDS _vds : allVdsList) {
        boolean _saveVdsDynamic = false;
        if (_vds.getPendingVcpusCount() != 0 && !runningVmsInTransition) {
            _vds.setPendingVcpusCount(0);
            _saveVdsDynamic = true;
        }
        if (_vds.getPendingVmemSize() != 0 && !runningVmsInTransition) {
            _vds.setPendingVmemSize(0);
            _saveVdsDynamic = true;
        }
        if (_saveVdsDynamic) {
            updatedEntities.add(_vds.getDynamicData());
        }
    }
    DbFacade.getInstance().getVdsDynamicDao().updateAllInBatch(updatedEntities);
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.init();
    log.info("Finished initializing " + getClass().getSimpleName());
}
#method_after
public void init() {
    log.info("Start initializing {}", getClass().getSimpleName());
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getStatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Is there any VM that is not fully Up or fully Down?
    boolean runningVmsInTransition = false;
    // Cleanup all vms dynamic data. This is defensive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.isNotRunning()) {
            if (vm.getRunOnVds() != null) {
                MultiValueMapUtils.addToMap(vm.getRunOnVds(), vm.getId(), vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
            }
            if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                SetVmUnknown(vm);
            }
        }
        if (!runningVmsInTransition && vm.isRunning() && vm.getStatus() != VMStatus.Up) {
            runningVmsInTransition = true;
        }
    }
    // Clean pending memory and CPUs if there is no VM in transition on a given Host
    // (meaning we tried to start a VM and the engine crashed before telling VDSM about it)
    List<VdsDynamic> updatedEntities = new ArrayList<>();
    for (VDS _vds : allVdsList) {
        boolean _saveVdsDynamic = false;
        if (_vds.getPendingVcpusCount() != 0 && !runningVmsInTransition) {
            _vds.setPendingVcpusCount(0);
            _saveVdsDynamic = true;
        }
        if (_vds.getPendingVmemSize() != 0 && !runningVmsInTransition) {
            _vds.setPendingVmemSize(0);
            _saveVdsDynamic = true;
        }
        if (_saveVdsDynamic) {
            updatedEntities.add(_vds.getDynamicData());
        }
    }
    DbFacade.getInstance().getVdsDynamicDao().updateAllInBatch(updatedEntities);
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.init();
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
public void AddVds(VDS vds, boolean isInternal) {
    VdsManager vdsManager = VdsManager.buildVdsManager(vds);
    if (isInternal) {
        VDSStatus status = vds.getStatus();
        switch(vds.getStatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Connecting:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getStatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.updateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setPendingVcpusCount(0);
        vdsManager.updateDynamicData(vds.getDynamicData());
    }
    vdsManager.schedulJobs();
    vdsManagersDict.put(vds.getId(), vdsManager);
    log.infoFormat("VDS {0} was added to the Resource Manager", vds.getId());
}
#method_after
public void AddVds(VDS vds, boolean isInternal) {
    VdsManager vdsManager = VdsManager.buildVdsManager(vds);
    if (isInternal) {
        VDSStatus status = vds.getStatus();
        switch(vds.getStatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Connecting:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getStatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.updateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setPendingVcpusCount(0);
        vdsManager.updateDynamicData(vds.getDynamicData());
    }
    vdsManager.schedulJobs();
    vdsManagersDict.put(vds.getId(), vdsManager);
    log.info("VDS '{}' was added to the Resource Manager", vds.getId());
}
#end_block

#method_before
public VdsManager GetVdsManager(Guid vdsId, boolean newHost) {
    VdsManager vdsManger = vdsManagersDict.get(vdsId);
    if (vdsManger == null) {
        if (!newHost) {
            log.errorFormat("Cannot get vdsManager for vdsid={0}", vdsId);
        }
    }
    return vdsManger;
}
#method_after
public VdsManager GetVdsManager(Guid vdsId, boolean newHost) {
    VdsManager vdsManger = vdsManagersDict.get(vdsId);
    if (vdsManger == null) {
        if (!newHost) {
            log.error("Cannot get vdsManager for vdsid='{}'.", vdsId);
        }
    }
    return vdsManger;
}
#end_block

#method_before
private void resetVmAttributes(VM vm) {
    vm.setUsageNetworkPercent(0);
    vm.setElapsedTime(0D);
    vm.setCpuSys(0D);
    vm.setCpuUser(0D);
    vm.setUsageCpuPercent(0);
    vm.setUsageMemPercent(0);
    vm.setMemoryUsageHistory(null);
    vm.setCpuUsageHistory(null);
    vm.setNetworkUsageHistory(null);
    vm.setMigratingToVds(null);
    vm.setRunOnVdsName("");
    vm.setGuestCurrentUserName(null);
    vm.setConsoleCurrentUserName(null);
    vm.setConsoleUserId(null);
    vm.setGuestOs(null);
    vm.setVmIp(null);
    vm.setVmFQDN(null);
    vm.setCpuName(null);
    vm.setEmulatedMachine(null);
    vm.setMigrationProgressPercent(0);
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    for (VmNetworkInterface ifc : interfaces) {
        NetworkStatistics statistics = ifc.getStatistics();
        statistics.setTransmitDropRate(0D);
        statistics.setTransmitRate(0D);
        statistics.setReceiveRate(0D);
        statistics.setReceiveDropRate(0D);
    }
}
#method_after
private void resetVmAttributes(VM vm) {
    vm.setUsageNetworkPercent(0);
    vm.setElapsedTime(0D);
    vm.setCpuSys(0D);
    vm.setCpuUser(0D);
    vm.setUsageCpuPercent(0);
    vm.setUsageMemPercent(0);
    vm.setMemoryUsageHistory(null);
    vm.setCpuUsageHistory(null);
    vm.setNetworkUsageHistory(null);
    vm.setMigratingToVds(null);
    vm.setRunOnVdsName("");
    vm.setGuestCurrentUserName(null);
    vm.setConsoleCurrentUserName(null);
    vm.setConsoleUserId(null);
    vm.setGuestOs(null);
    vm.setVmIp(null);
    vm.setVmFQDN(null);
    vm.setCpuName(null);
    vm.setEmulatedMachine(null);
    vm.setMigrationProgressPercent(0);
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    for (VmNetworkInterface ifc : interfaces) {
        NetworkStatistics statistics = ifc.getStatistics();
        statistics.setTransmitDropRate(0D);
        statistics.setTransmitRate(0D);
        statistics.setReceiveRate(0D);
        statistics.setReceiveDropRate(0D);
    }
    List<VmNumaNode> vmNumaNodes = vm.getvNumaNodeList();
    for (VmNumaNode node : vmNumaNodes) {
        node.getVdsNumaNodeList().clear();
    }
}
#end_block

#method_before
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(GetCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(GetCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateCommand failed: {}", e.getCause().getMessage());
            log.error("Exception", e);
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateCommand failed: {}", e.getMessage());
        log.debug("Exception", e);
    }
    return null;
}
#end_block

#method_before
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateFutureCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateFutureCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateFutureCommand failed: {}", e.getCause().getMessage());
            log.debug("Exception", e);
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateFutureCommand failed: {}", e.getMessage());
        log.debug("Exception", e);
    }
    return null;
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    addNumaSetting(compatibilityVersion);
    if (vm.getDisplayType() == DisplayType.qxl) {
        createInfo.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        createInfo.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
    }
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getVdsGroupCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#method_after
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    if (vm.getDisplayType() == DisplayType.qxl) {
        createInfo.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        createInfo.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
    }
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getVdsGroupCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#end_block

#method_before
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    log.error("policy unit:" + getPolicyUnit().getName() + "filter is not implemented");
    return hosts;
}
#method_after
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    log.error("Policy unit '{}' filter is not implemented", getPolicyUnit().getName());
    return hosts;
}
#end_block

#method_before
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    log.error("policy unit:" + getPolicyUnit().getName() + "function is not implemented");
    List<Pair<Guid, Integer>> pairs = new ArrayList<Pair<Guid, Integer>>();
    for (VDS vds : hosts) {
        pairs.add(new Pair<Guid, Integer>(vds.getId(), 1));
    }
    return pairs;
}
#method_after
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    log.error("Policy unit '{}' function is not implemented", getPolicyUnit().getName());
    List<Pair<Guid, Integer>> pairs = new ArrayList<Pair<Guid, Integer>>();
    for (VDS vds : hosts) {
        pairs.add(new Pair<Guid, Integer>(vds.getId(), 1));
    }
    return pairs;
}
#end_block

#method_before
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    log.error("policy unit:" + getPolicyUnit().getName() + "balance is not implemented");
    return null;
}
#method_after
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    log.error("Policy unit '{}' balance is not implemented", getPolicyUnit().getName());
    return null;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    /* if run-once was used then the dynamic vm fields must be updated before running the scheduler filters (which are called via super.CanDoAction->runVmValidator) */
    earlyUpdateVmDynamicRunOnce();
    if (!super.canDoAction()) {
        return false;
    }
    // set (null), the action will fail if only one of those parameters is null.
    if (getParameters().getSysPrepUserName() == null ^ getParameters().getSysPrepPassword() == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_ONCE_WITH_ILLEGAL_SYSPREP_PARAM);
    }
    if (getParameters().getVmInit() != null) {
        if (!OsRepositoryImpl.INSTANCE.isWindows(getVm().getOs()) && !FeatureSupported.cloudInit(getVm().getVdsGroupCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLOUD_INIT_IS_NOT_SUPPORTED);
        }
        if (getParameters().getVmInit().isPasswordAlreadyStored()) {
            VmBase temp = new VmBase();
            temp.setId(getParameters().getVmId());
            VmHandler.updateVmInitFromDB(temp, false);
            getParameters().getVmInit().setRootPassword(temp.getVmInit().getRootPassword());
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    // set (null), the action will fail if only one of those parameters is null.
    if (getParameters().getSysPrepUserName() == null ^ getParameters().getSysPrepPassword() == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_ONCE_WITH_ILLEGAL_SYSPREP_PARAM);
    }
    if (getParameters().getVmInit() != null) {
        if (!OsRepositoryImpl.INSTANCE.isWindows(getVm().getOs()) && !FeatureSupported.cloudInit(getVm().getVdsGroupCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLOUD_INIT_IS_NOT_SUPPORTED);
        }
        if (getParameters().getVmInit().isPasswordAlreadyStored()) {
            VmBase temp = new VmBase();
            temp.setId(getParameters().getVmId());
            VmHandler.updateVmInitFromDB(temp, false);
            getParameters().getVmInit().setRootPassword(temp.getVmInit().getRootPassword());
        }
    }
    return true;
}
#end_block

#method_before
private void loadPayload() {
    VmDeviceDAO dao = getDbFacade().getVmDeviceDao();
    List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getParameters().getVmId(), VmDeviceGeneralType.DISK);
    for (VmDevice disk : disks) {
        if (VmPayload.isPayload(disk.getSpecParams())) {
            VmPayload payload = new VmPayload(VmDeviceType.valueOf(disk.getType().name()), disk.getSpecParams());
            payload.setType(VmDeviceType.valueOf(disk.getDevice().toUpperCase()));
            getVm().setVmPayload(payload);
            break;
        }
    }
}
#method_after
private void loadPayload() {
    VmDeviceDAO dao = getDbFacade().getVmDeviceDao();
    List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getParameters().getVmId(), VmDeviceGeneralType.DISK);
    for (VmDevice disk : disks) {
        if (VmPayload.isPayload(disk.getSpecParams())) {
            VmPayload payload = new VmPayload(disk);
            getVm().setVmPayload(payload);
            break;
        }
    }
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    String requiredEmulatedMachine;
    List<VDS> hostsToRunOn = new ArrayList<VDS>();
    /* get required emulated machine */
    if (StringUtils.isNotEmpty(vm.getEmulatedMachine())) {
        // dynamic check - used for 1.migrating vms 2.run-once 3.after dynamic field is updated with current static-field\cluster
        requiredEmulatedMachine = vm.getEmulatedMachine();
    } else if (StringUtils.isNotEmpty(vm.getCustomEmulatedMachine())) {
        // static check - used only for cases where the dynamic value hasn't been updated yet(canDo validation)
        requiredEmulatedMachine = vm.getCustomEmulatedMachine();
    } else {
        // use cluster default - all hosts are valid
        return hosts;
    }
    /* find compatible hosts */
    for (VDS host : hosts) {
        String supportedEmulatedMachines = host.getSupportedEmulatedMachines();
        if (StringUtils.isNotEmpty(supportedEmulatedMachines)) {
            if (Arrays.asList(supportedEmulatedMachines.split(",")).contains(requiredEmulatedMachine)) {
                hostsToRunOn.add(host);
                log.debugFormat("Host {0} wasn't filtered out as it supports the VM required emulated machine ({1})", host.getName(), requiredEmulatedMachine);
            } else {
                log.debugFormat("Host {0} was filtered out as it doesn't support the VM required emulated machine ({1})", host.getName(), requiredEmulatedMachine);
                messages.addMessage(host.getId(), String.format("$vmEmulatedMachine %1$s", requiredEmulatedMachine));
                messages.addMessage(host.getId(), VdcBllMessages.VAR__DETAIL__UNSUPPORTED_EMULATED_MACHINE.toString());
            }
        }
    }
    return hostsToRunOn;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    String requiredEmulatedMachine;
    List<VDS> hostsToRunOn = new ArrayList<VDS>();
    /* get required emulated machine */
    if (StringUtils.isNotEmpty(vm.getEmulatedMachine())) {
        // dynamic check - used for 1.migrating vms 2.run-once 3.after dynamic field is updated with current static-field\cluster
        requiredEmulatedMachine = vm.getEmulatedMachine();
    } else if (StringUtils.isNotEmpty(vm.getCustomEmulatedMachine())) {
        // static check - used only for cases where the dynamic value hasn't been updated yet(canDo validation)
        requiredEmulatedMachine = vm.getCustomEmulatedMachine();
    } else {
        // use cluster default - all hosts are valid
        return hosts;
    }
    /* find compatible hosts */
    for (VDS host : hosts) {
        String supportedEmulatedMachines = host.getSupportedEmulatedMachines();
        if (StringUtils.isNotEmpty(supportedEmulatedMachines)) {
            if (Arrays.asList(supportedEmulatedMachines.split(",")).contains(requiredEmulatedMachine)) {
                hostsToRunOn.add(host);
                log.debug("Host {} wasn't filtered out as it supports the VM required emulated machine ({})", host.getName(), requiredEmulatedMachine);
            } else {
                log.debug("Host {} was filtered out as it doesn't support the VM required emulated machine ({}). Host supported emulated machines are: {}.", host.getName(), requiredEmulatedMachine, supportedEmulatedMachines);
                messages.addMessage(host.getId(), String.format("$vmEmulatedMachine %1$s", requiredEmulatedMachine));
                messages.addMessage(host.getId(), String.format("$hostEmulatedMachines %1$s", supportedEmulatedMachines));
                messages.addMessage(host.getId(), VdcBllMessages.VAR__DETAIL__UNSUPPORTED_EMULATED_MACHINE.toString());
            }
        }
    }
    return hostsToRunOn;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    result = prime * result + ((serialNumberPolicy == null) ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + ((customSerialNumber == null) ? 0 : customSerialNumber.hashCode());
    result = prime * result + (bootMenuEnabled ? 1231 : 1237);
    result = prime * result + (spiceFileTransferEnabled ? 1231 : 1237);
    result = prime * result + (spiceCopyPasteEnabled ? 1231 : 1237);
    result = prime * result + ((cpuProfileId == null) ? 0 : cpuProfileId.hashCode());
    result = prime * result + ((customEmulatedMachine == null) ? 0 : customEmulatedMachine.hashCode());
    result = prime * result + ((customCpuName == null) ? 0 : customCpuName.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    result = prime * result + ((serialNumberPolicy == null) ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + ((customSerialNumber == null) ? 0 : customSerialNumber.hashCode());
    result = prime * result + (bootMenuEnabled ? 1231 : 1237);
    result = prime * result + (spiceFileTransferEnabled ? 1231 : 1237);
    result = prime * result + (spiceCopyPasteEnabled ? 1231 : 1237);
    result = prime * result + ((cpuProfileId == null) ? 0 : cpuProfileId.hashCode());
    result = prime * result + ((numaTuneMode == null) ? 0 : numaTuneMode.getValue().hashCode());
    result = prime * result + ((vNumaNodeList == null) ? 0 : vNumaNodeList.hashCode());
    result = prime * result + (autoConverge == null ? 0 : autoConverge.hashCode());
    result = prime * result + (migrateCompressed == null ? 0 : migrateCompressed.hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    result = prime * result + ((customEmulatedMachine == null) ? 0 : customEmulatedMachine.hashCode());
    result = prime * result + ((customCpuName == null) ? 0 : customCpuName.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime)) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && ObjectUtils.objectsEqual(cpuProfileId, other.cpuProfileId) && ObjectUtils.objectsEqual(customEmulatedMachine, other.customEmulatedMachine) && ObjectUtils.objectsEqual(customCpuName, other.customCpuName);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && ObjectUtils.objectsEqual(cpuProfileId, other.cpuProfileId) && ObjectUtils.objectsEqual(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && ObjectUtils.objectsEqual(vNumaNodeList, other.vNumaNodeList)) && ObjectUtils.objectsEqual(autoConverge, other.autoConverge) && ObjectUtils.objectsEqual(migrateCompressed, other.migrateCompressed) && ObjectUtils.objectsEqual(predefinedProperties, other.predefinedProperties) && ObjectUtils.objectsEqual(userDefinedProperties, other.userDefinedProperties) && ObjectUtils.objectsEqual(customEmulatedMachine, other.customEmulatedMachine) && ObjectUtils.objectsEqual(customCpuName, other.customCpuName);
}
#end_block

#method_before
public void setCustomEmulatedMachine(String customEmulatedMachine) {
    this.customEmulatedMachine = ((customEmulatedMachine == null || customEmulatedMachine.length() == 0) ? null : customEmulatedMachine);
}
#method_after
public void setCustomEmulatedMachine(String customEmulatedMachine) {
    this.customEmulatedMachine = ((customEmulatedMachine == null || customEmulatedMachine.trim().isEmpty()) ? null : customEmulatedMachine);
}
#end_block

#method_before
public void setCustomCpuName(String customCpuName) {
    this.customCpuName = ((customCpuName == null || customCpuName.length() == 0) ? null : customCpuName);
}
#method_after
public void setCustomCpuName(String customCpuName) {
    this.customCpuName = ((customCpuName == null || customCpuName.trim().isEmpty()) ? null : customCpuName);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.infoFormat("Cancelling current running update for vms for base template id {0}", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warnFormat("Failed deleting job {0} at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVdsGroup().getcompatibility_version(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#end_block

#method_before
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false, true), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        removeNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(VdcActionType.CreateImageTemplate, p, cloneContextAndDetachFromParent());
    }
    if (CommandCoordinatorUtil.getCommandExecutionStatus(getParameters().getCommandId()) == CommandExecutionStatus.EXECUTED) {
        // if template exist in db remove it
        if (getVmTemplate() != null) {
            DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
            removeNetwork();
        }
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
protected MapSqlParameterSource createBaseParametersMapper(T entity) {
    return createIdParameterMapper(entity.getId()).addValue("description", entity.getDescription()).addValue("free_text_comment", entity.getComment()).addValue("creation_date", entity.getCreationDate()).addValue("mem_size_mb", entity.getMemSizeMb()).addValue("vnc_keyboard_layout", entity.getVncKeyboardLayout()).addValue("tunnel_migration", entity.getTunnelMigration()).addValue("vds_group_id", entity.getVdsGroupId()).addValue("num_of_sockets", entity.getNumOfSockets()).addValue("cpu_per_socket", entity.getCpuPerSocket()).addValue("os", entity.getOsId()).addValue("num_of_monitors", entity.getNumOfMonitors()).addValue("single_qxl_pci", entity.getSingleQxlPci()).addValue("allow_console_reconnect", entity.isAllowConsoleReconnect()).addValue("vm_type", entity.getVmType()).addValue("priority", entity.getPriority()).addValue("auto_startup", entity.isAutoStartup()).addValue("is_stateless", entity.isStateless()).addValue("is_smartcard_enabled", entity.isSmartcardEnabled()).addValue("is_delete_protected", entity.isDeleteProtected()).addValue("sso_method", entity.getSsoMethod().toString()).addValue("iso_path", entity.getIsoPath()).addValue("usb_policy", entity.getUsbPolicy()).addValue("time_zone", entity.getTimeZone()).addValue("fail_back", entity.isFailBack()).addValue("nice_level", entity.getNiceLevel()).addValue("cpu_shares", entity.getCpuShares()).addValue("default_boot_sequence", entity.getDefaultBootSequence()).addValue("default_display_type", entity.getDefaultDisplayType()).addValue("origin", entity.getOrigin()).addValue("initrd_url", entity.getInitrdUrl()).addValue("kernel_url", entity.getKernelUrl()).addValue("kernel_params", entity.getKernelParams()).addValue("quota_id", entity.getQuotaId()).addValue("migration_support", entity.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", entity.getDedicatedVmForVds()).addValue("min_allocated_mem", entity.getMinAllocatedMem()).addValue("is_run_and_pause", entity.isRunAndPause()).addValue("created_by_user_id", entity.getCreatedByUserId()).addValue("migration_downtime", entity.getMigrationDowntime()).addValue("serial_number_policy", entity.getSerialNumberPolicy() == null ? null : entity.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", entity.getCustomSerialNumber()).addValue("is_boot_menu_enabled", entity.isBootMenuEnabled()).addValue("is_spice_file_transfer_enabled", entity.isSpiceFileTransferEnabled()).addValue("is_spice_copy_paste_enabled", entity.isSpiceCopyPasteEnabled()).addValue("cpu_profile_id", entity.getCpuProfileId()).addValue("custom_emulated_machine", entity.getCustomEmulatedMachine()).addValue("custom_cpu_name", entity.getCustomCpuName());
}
#method_after
protected MapSqlParameterSource createBaseParametersMapper(T entity) {
    return createIdParameterMapper(entity.getId()).addValue("description", entity.getDescription()).addValue("free_text_comment", entity.getComment()).addValue("creation_date", entity.getCreationDate()).addValue("mem_size_mb", entity.getMemSizeMb()).addValue("vnc_keyboard_layout", entity.getVncKeyboardLayout()).addValue("tunnel_migration", entity.getTunnelMigration()).addValue("vds_group_id", entity.getVdsGroupId()).addValue("num_of_sockets", entity.getNumOfSockets()).addValue("cpu_per_socket", entity.getCpuPerSocket()).addValue("os", entity.getOsId()).addValue("num_of_monitors", entity.getNumOfMonitors()).addValue("single_qxl_pci", entity.getSingleQxlPci()).addValue("allow_console_reconnect", entity.isAllowConsoleReconnect()).addValue("vm_type", entity.getVmType()).addValue("priority", entity.getPriority()).addValue("auto_startup", entity.isAutoStartup()).addValue("is_stateless", entity.isStateless()).addValue("is_smartcard_enabled", entity.isSmartcardEnabled()).addValue("is_delete_protected", entity.isDeleteProtected()).addValue("sso_method", entity.getSsoMethod().toString()).addValue("iso_path", entity.getIsoPath()).addValue("usb_policy", entity.getUsbPolicy()).addValue("time_zone", entity.getTimeZone()).addValue("fail_back", entity.isFailBack()).addValue("nice_level", entity.getNiceLevel()).addValue("cpu_shares", entity.getCpuShares()).addValue("default_boot_sequence", entity.getDefaultBootSequence()).addValue("default_display_type", entity.getDefaultDisplayType()).addValue("origin", entity.getOrigin()).addValue("initrd_url", entity.getInitrdUrl()).addValue("kernel_url", entity.getKernelUrl()).addValue("kernel_params", entity.getKernelParams()).addValue("quota_id", entity.getQuotaId()).addValue("migration_support", entity.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", entity.getDedicatedVmForVds()).addValue("min_allocated_mem", entity.getMinAllocatedMem()).addValue("is_run_and_pause", entity.isRunAndPause()).addValue("created_by_user_id", entity.getCreatedByUserId()).addValue("migration_downtime", entity.getMigrationDowntime()).addValue("serial_number_policy", entity.getSerialNumberPolicy() == null ? null : entity.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", entity.getCustomSerialNumber()).addValue("is_boot_menu_enabled", entity.isBootMenuEnabled()).addValue("is_spice_file_transfer_enabled", entity.isSpiceFileTransferEnabled()).addValue("is_spice_copy_paste_enabled", entity.isSpiceCopyPasteEnabled()).addValue("cpu_profile_id", entity.getCpuProfileId()).addValue("numatune_mode", entity.getNumaTuneMode().getValue()).addValue("is_auto_converge", entity.getAutoConverge()).addValue("is_migrate_compressed", entity.getMigrateCompressed()).addValue("predefined_properties", entity.getPredefinedProperties()).addValue("userdefined_properties", entity.getUserDefinedProperties()).addValue("custom_emulated_machine", entity.getCustomEmulatedMachine()).addValue("custom_cpu_name", entity.getCustomCpuName());
}
#end_block

#method_before
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setOsId(rs.getInt("os"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.setBootMenuEnabled(rs.getBoolean("is_boot_menu_enabled"));
    entity.setSpiceFileTransferEnabled(rs.getBoolean("is_spice_file_transfer_enabled"));
    entity.setSpiceCopyPasteEnabled(rs.getBoolean("is_spice_copy_paste_enabled"));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuProfileId(getGuid(rs, "cpu_profile_id"));
    entity.setCustomEmulatedMachine(rs.getString("custom_emulated_machine"));
    entity.setCustomCpuName(rs.getString("custom_cpu_name"));
}
#method_after
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setOsId(rs.getInt("os"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.setBootMenuEnabled(rs.getBoolean("is_boot_menu_enabled"));
    entity.setSpiceFileTransferEnabled(rs.getBoolean("is_spice_file_transfer_enabled"));
    entity.setSpiceCopyPasteEnabled(rs.getBoolean("is_spice_copy_paste_enabled"));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuProfileId(getGuid(rs, "cpu_profile_id"));
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setCustomEmulatedMachine(rs.getString("custom_emulated_machine"));
    entity.setCustomCpuName(rs.getString("custom_cpu_name"));
}
#end_block

#method_before
@Override
public int compareTo(VmDynamic o) {
    return BusinessEntityGuidComparator.<VmDynamic>newInstance().compare(this, o);
}
#method_after
@Override
public int compareTo(VmDynamic o) {
    return BusinessEntityComparator.<VmDynamic, Guid>newInstance().compare(this, o);
}
#end_block

#method_before
public static String getMessage(AuditLogType logType) {
    final String result = getMessageOrNull(logType);
    return result == null ? "" : result;
}
#method_after
public static String getMessage(AuditLogType logType) {
    String value = "";
    if (messages.containsKey(logType)) {
        value = messages.get(logType);
    }
    return value;
}
#end_block

#method_before
public void log(AuditLogableBase auditLogable) {
    AuditLogType logType = auditLogable.getAuditLogTypeValue();
    log(auditLogable, logType);
}
#method_after
public static void log(AuditLogableBase auditLogable) {
    AuditLogType logType = auditLogable.getAuditLogTypeValue();
    log(auditLogable, logType);
}
#end_block

#method_before
public void log(AuditLogableBase auditLogable, AuditLogType logType) {
    log(auditLogable, logType, "");
}
#method_after
public static void log(AuditLogableBase auditLogable, AuditLogType logType) {
    log(auditLogable, logType, "");
}
#end_block

#method_before
public void log(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    if (!logType.shouldBeLogged()) {
        return;
    }
    updateTimeoutLogableObject(auditLogable, logType);
    if (auditLogable.getLegal()) {
        saveToDb(auditLogable, logType, loggerString);
    }
}
#method_after
public static void log(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    updateTimeoutLogableObject(auditLogable, logType);
    if (auditLogable.getLegal()) {
        saveToDb(auditLogable, logType, loggerString);
    }
}
#end_block

#method_before
private void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    AuditLogSeverity severity = logType.getSeverity();
    AuditLog auditLog = createAuditLog(auditLogable, logType, loggerString, severity);
    if (auditLog == null) {
        log.warn("Unable to create AuditLog");
    } else {
        setPropertiesFromAuditLogableBase(auditLogable, auditLog);
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        logMessage(severity, getMessageToLog(loggerString, auditLog));
    }
}
#method_after
private static void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    String message = null;
    String resolvedMessage = null;
    AuditLogSeverity severity = logType.getSeverity();
    AuditLog auditLog = null;
    // handle external log messages invoked by plugins via the API
    if (auditLogable.isExternal()) {
        // message is sent as an argument, no need to resolve.
        resolvedMessage = message = loggerString;
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserId() != null ? getDbFacadeInstance().getDbUserDao().get(auditLogable.getUserId()).getLoginName() : null, auditLogable.getVmIdRef(), auditLogable.getVmIdRef() != null ? getDbFacadeInstance().getVmDao().get(auditLogable.getVmIdRef()).getName() : null, auditLogable.getVdsIdRef(), auditLogable.getVdsIdRef() != null ? getDbFacadeInstance().getVdsDao().get(auditLogable.getVdsIdRef()).getName() : null, auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateIdRef() != null ? getDbFacadeInstance().getVmTemplateDao().get(auditLogable.getVmTemplateIdRef()).getName() : null, auditLogable.getOrigin(), auditLogable.getCustomEventId(), auditLogable.getEventFloodInSec(), auditLogable.getCustomData());
    } else if ((message = messages.get(logType)) != null) {
        // Application log message from AuditLogMessages
        resolvedMessage = resolveMessage(message, auditLogable);
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
    }
    if (auditLog != null) {
        auditLog.setStorageDomainId(auditLogable.getStorageDomainId());
        auditLog.setStorageDomainName(auditLogable.getStorageDomainName());
        auditLog.setStoragePoolId(auditLogable.getStoragePoolId());
        auditLog.setStoragePoolName(auditLogable.getStoragePoolName());
        auditLog.setVdsGroupId(auditLogable.getVdsGroupId());
        auditLog.setVdsGroupName(auditLogable.getVdsGroupName());
        auditLog.setCorrelationId(auditLogable.getCorrelationId());
        auditLog.setJobId(auditLogable.getJobId());
        auditLog.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
        auditLog.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
        auditLog.setExternal(auditLogable.isExternal());
        auditLog.setQuotaId(auditLogable.getQuotaIdForLog());
        auditLog.setQuotaName(auditLogable.getQuotaNameForLog());
        auditLog.setCallStack(auditLogable.getCallStack());
        auditLog.setRepeatable(auditLogable.isRepeatable());
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        String logMessage;
        if (!"".equals(loggerString)) {
            logMessage = MessageFormat.format(loggerString.replaceAll("'", ""), resolvedMessage);
        } else {
            logMessage = auditLog.toStringForLogging();
        }
        switch(severity) {
            case NORMAL:
                log.info(logMessage);
                break;
            case ERROR:
                log.error(logMessage);
                break;
            case ALERT:
            case WARNING:
                log.warn(logMessage);
                break;
        }
    }
}
#end_block

#method_before
private void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int eventFloodRate = (auditLogable.isExternal() && auditLogable.getEventFloodInSec() == 0) ? // Minimal default duration for External Events is 30 seconds.
    30 : logType.getEventFloodRate();
    if (eventFloodRate > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(eventFloodRate));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#method_after
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int eventFloodRate = (auditLogable.isExternal() && auditLogable.getEventFloodInSec() == 0) ? // Minimal default duration for External Events is 30 seconds.
    30 : logType.getEventFloodRate();
    if (eventFloodRate > 0) {
        auditLogable.setEndTime(TimeUnit.SECONDS.toMillis(eventFloodRate));
        auditLogable.setTimeoutObjectId(composeObjectId(auditLogable, logType));
    }
}
#end_block

#method_before
private String composeObjectId(AuditLogableBase logable, AuditLogType logType) {
    final StringBuilder builder = new StringBuilder();
    compose(builder, "type", logType.toString());
    compose(builder, "sd", nullToEmptyString(logable.getStorageDomainId()));
    compose(builder, "dc", nullToEmptyString(logable.getStoragePoolId()));
    compose(builder, "user", nullToEmptyString(logable.getUserId()));
    compose(builder, "cluster", logable.getVdsGroupId().toString());
    compose(builder, "vds", logable.getVdsId().toString());
    compose(builder, "vm", emptyGuidToEmptyString(logable.getVmId()));
    compose(builder, "template", emptyGuidToEmptyString(logable.getVmTemplateId()));
    compose(builder, "customId", StringUtils.defaultString(logable.getCustomId()));
    return builder.toString();
}
#method_after
private static String composeObjectId(AuditLogableBase logable, AuditLogType logType) {
    final char DELIMITER = ',';
    StringBuilder sb = new StringBuilder();
    sb.append("type=");
    sb.append(logType);
    sb.append(DELIMITER);
    sb.append("sd=");
    sb.append(logable.getStorageDomainId() == null ? "" : logable.getStorageDomainId().toString());
    sb.append(DELIMITER);
    sb.append("dc=");
    sb.append(logable.getStoragePoolId() == null ? "" : logable.getStoragePoolId().toString());
    sb.append(DELIMITER);
    sb.append("user=");
    sb.append(logable.getUserId() == null ? "" : logable.getUserId().toString());
    sb.append(DELIMITER);
    sb.append("cluster=");
    sb.append(logable.getVdsGroupId().toString());
    sb.append(DELIMITER);
    sb.append("vds=");
    sb.append(logable.getVdsId().toString());
    sb.append(DELIMITER);
    sb.append("vm=");
    sb.append(logable.getVmId().equals(Guid.Empty) ? "" : logable.getVmId().toString());
    sb.append(DELIMITER);
    sb.append("template=");
    sb.append(logable.getVmTemplateId().equals(Guid.Empty) ? "" : logable.getVmTemplateId().toString());
    sb.append(DELIMITER);
    sb.append("customId=");
    sb.append(StringUtils.defaultString(logable.getCustomId()));
    sb.append(DELIMITER);
    return sb.toString();
}
#end_block

#method_before
String resolveMessage(String message, AuditLogableBase logable) {
    String returnValue = message;
    if (logable != null) {
        Map<String, String> map = getAvailableValues(message, logable);
        returnValue = resolveMessage(message, map);
    }
    return returnValue;
}
#method_after
static String resolveMessage(String message, AuditLogableBase logable) {
    String returnValue = message;
    if (logable != null) {
        Map<String, String> map = getAvailableValues(message, logable);
        returnValue = resolveMessage(message, map);
    }
    return returnValue;
}
#end_block

#method_before
public String resolveMessage(String message, Map<String, String> values) {
    Matcher matcher = pattern.matcher(message);
    StringBuffer buffer = new StringBuffer();
    String value;
    String token;
    while (matcher.find()) {
        token = matcher.group();
        // remove leading ${ and trailing }
        token = token.substring(2, token.length() - 1);
        // get value from value map
        value = values.get(token.toLowerCase());
        if (value == null || value.isEmpty()) {
            // replace value with UNKNOWN_VARIABLE_VALUE if value not defined
            switch(token.toLowerCase()) {
                case REASON_TOKEN:
                    value = UNKNOWN_REASON_VALUE;
                    break;
                default:
                    value = UNKNOWN_VARIABLE_VALUE;
            }
        }
        // put the value into message
        matcher.appendReplacement(buffer, Matcher.quoteReplacement(value));
    }
    // append the rest of the message
    matcher.appendTail(buffer);
    return buffer.toString();
}
#method_after
public static String resolveMessage(String message, Map<String, String> values) {
    Matcher matcher = pattern.matcher(message);
    StringBuffer buffer = new StringBuffer();
    String value;
    String token;
    while (matcher.find()) {
        token = matcher.group();
        // remove leading ${ and trailing }
        token = token.substring(2, token.length() - 1);
        // get value from value map
        value = values.get(token.toLowerCase());
        if (value == null || value.isEmpty()) {
            // replace value with UNKNOWN_VARIABLE_VALUE if value not defined
            switch(token.toLowerCase()) {
                case REASON_TOKEN:
                    value = UNKNOWN_REASON_VALUE;
                    break;
                default:
                    value = UNKNOWN_VARIABLE_VALUE;
            }
        }
        // put the value into message
        matcher.appendReplacement(buffer, Matcher.quoteReplacement(value));
    }
    // append the rest of the message
    matcher.appendTail(buffer);
    return buffer.toString();
}
#end_block

#method_before
private Set<String> resolvePlaceHolders(String message) {
    Set<String> result = new HashSet<String>();
    Matcher matcher = pattern.matcher(message);
    String token;
    while (matcher.find()) {
        token = matcher.group();
        // remove leading ${ and trailing }
        token = token.substring(2, token.length() - 1);
        result.add(token.toLowerCase());
    }
    return result;
}
#method_after
private static Set<String> resolvePlaceHolders(String message) {
    Set<String> result = new HashSet<String>();
    Matcher matcher = pattern.matcher(message);
    String token;
    while (matcher.find()) {
        token = matcher.group();
        // remove leading ${ and trailing }
        token = token.substring(2, token.length() - 1);
        result.add(token.toLowerCase());
    }
    return result;
}
#end_block

#method_before
private Map<String, String> getAvailableValues(String message, AuditLogableBase logable) {
    Map<String, String> returnValue = new HashMap<String, String>(logable.getCustomValues());
    Set<String> attributes = resolvePlaceHolders(message);
    if (attributes != null && attributes.size() > 0) {
        TypeCompat.getPropertyValues(logable, attributes, returnValue);
    }
    return returnValue;
}
#method_after
private static Map<String, String> getAvailableValues(String message, AuditLogableBase logable) {
    Map<String, String> returnValue = new HashMap<String, String>(logable.getCustomValues());
    Set<String> attributes = resolvePlaceHolders(message);
    if (attributes != null && attributes.size() > 0) {
        TypeCompat.getPropertyValues(logable, attributes, returnValue);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    // map to avoid fetching qos object for same disk profile id
    Map<Guid, Guid> diskProfileStorageQosMap = new HashMap<>();
    Map<Guid, Map<String, Integer>> storageQosIoTuneMap = new HashMap<>();
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                if (FeatureSupported.storageQoS(vm.getVdsGroupCompatibilityVersion())) {
                    Map<String, Integer> ioTune = buildIoTune(diskImage, diskProfileStorageQosMap, storageQosIoTuneMap);
                    if (ioTune != null) {
                        if (vmDevice.getSpecParams() == null) {
                            vmDevice.setSpecParams(new HashMap<String, Object>());
                        }
                        vmDevice.getSpecParams().put(VdsProperties.Iotune, ioTune);
                    }
                }
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    // map to avoid fetching qos object for same disk profile id
    Map<Guid, Guid> diskProfileStorageQosMap = new HashMap<>();
    Map<Guid, Map<String, Long>> storageQosIoTuneMap = new HashMap<>();
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                if (FeatureSupported.storageQoS(vm.getVdsGroupCompatibilityVersion())) {
                    Map<String, Long> ioTune = buildIoTune(diskImage, diskProfileStorageQosMap, storageQosIoTuneMap);
                    if (ioTune != null) {
                        if (vmDevice.getSpecParams() == null) {
                            vmDevice.setSpecParams(new HashMap<String, Object>());
                        }
                        vmDevice.getSpecParams().put(VdsProperties.Iotune, ioTune);
                    }
                }
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
private Map<String, Integer> buildIoTune(DiskImage diskImage, Map<Guid, Guid> diskProfileStorageQosMap, Map<Guid, Map<String, Integer>> storageQosIoTuneMap) {
    Guid diskProfileId = diskImage.getDiskProfileId();
    if (diskProfileId == null) {
        return null;
    }
    Guid storageQosId = diskProfileStorageQosMap.get(diskProfileId);
    if (storageQosId == null) {
        StorageQos storageQos = DbFacade.getInstance().getStorageQosDao().getQosByDiskProfileId(diskProfileId);
        if (storageQos == null) {
            return null;
        }
        storageQosId = storageQos.getId();
        diskProfileStorageQosMap.put(diskProfileId, storageQosId);
        storageQosIoTuneMap.put(storageQosId, buildIoTuneMap(storageQos));
    }
    Map<String, Integer> ioTuneMap = storageQosIoTuneMap.get(storageQosId);
    // return map with values
    if (!ioTuneMap.isEmpty()) {
        return ioTuneMap;
    }
    return null;
}
#method_after
private Map<String, Long> buildIoTune(DiskImage diskImage, Map<Guid, Guid> diskProfileStorageQosMap, Map<Guid, Map<String, Long>> storageQosIoTuneMap) {
    Guid diskProfileId = diskImage.getDiskProfileId();
    if (diskProfileId == null) {
        return null;
    }
    Guid storageQosId = diskProfileStorageQosMap.get(diskProfileId);
    if (storageQosId == null) {
        StorageQos storageQos = DbFacade.getInstance().getStorageQosDao().getQosByDiskProfileId(diskProfileId);
        if (storageQos == null) {
            return null;
        }
        storageQosId = storageQos.getId();
        diskProfileStorageQosMap.put(diskProfileId, storageQosId);
        storageQosIoTuneMap.put(storageQosId, buildIoTuneMap(storageQos));
    }
    Map<String, Long> ioTuneMap = storageQosIoTuneMap.get(storageQosId);
    // return map with values
    if (!ioTuneMap.isEmpty()) {
        return ioTuneMap;
    }
    return null;
}
#end_block

#method_before
private Map<String, Integer> buildIoTuneMap(StorageQos storageQos) {
    // build map
    Map<String, Integer> ioTuneMap = new HashMap<>();
    if (storageQos.getMaxThroughput() != null) {
        // Convert MiB/s to B/s vdsm is expecting
        ioTuneMap.put(VdsProperties.TotalBytesSec, storageQos.getMaxThroughput() * 1024 * 1024);
    }
    if (storageQos.getMaxReadThroughput() != null) {
        // Convert MiB/s to B/s vdsm is expecting
        ioTuneMap.put(VdsProperties.ReadBytesSec, storageQos.getMaxReadThroughput() * 1024 * 1024);
    }
    if (storageQos.getMaxWriteThroughput() != null) {
        // Convert MiB/s to B/s vdsm is expecting
        ioTuneMap.put(VdsProperties.WriteBytesSec, storageQos.getMaxWriteThroughput() * 1024 * 1024);
    }
    if (storageQos.getMaxIops() != null) {
        ioTuneMap.put(VdsProperties.TotalIopsSec, storageQos.getMaxIops());
    }
    if (storageQos.getMaxReadIops() != null) {
        ioTuneMap.put(VdsProperties.ReadIopsSec, storageQos.getMaxReadIops());
    }
    if (storageQos.getMaxWriteIops() != null) {
        ioTuneMap.put(VdsProperties.WriteIopsSec, storageQos.getMaxWriteIops());
    }
    return ioTuneMap;
}
#method_after
private Map<String, Long> buildIoTuneMap(StorageQos storageQos) {
    // build map
    Map<String, Long> ioTuneMap = new HashMap<>();
    if (storageQos.getMaxThroughput() != null) {
        // Convert MiB/s to B/s vdsm is expecting
        ioTuneMap.put(VdsProperties.TotalBytesSec, storageQos.getMaxThroughput() * 1024 * 1024L);
    }
    if (storageQos.getMaxReadThroughput() != null) {
        // Convert MiB/s to B/s vdsm is expecting
        ioTuneMap.put(VdsProperties.ReadBytesSec, storageQos.getMaxReadThroughput() * 1024 * 1024L);
    }
    if (storageQos.getMaxWriteThroughput() != null) {
        // Convert MiB/s to B/s vdsm is expecting
        ioTuneMap.put(VdsProperties.WriteBytesSec, storageQos.getMaxWriteThroughput() * 1024 * 1024L);
    }
    if (storageQos.getMaxIops() != null) {
        ioTuneMap.put(VdsProperties.TotalIopsSec, storageQos.getMaxIops().longValue());
    }
    if (storageQos.getMaxReadIops() != null) {
        ioTuneMap.put(VdsProperties.ReadIopsSec, storageQos.getMaxReadIops().longValue());
    }
    if (storageQos.getMaxWriteIops() != null) {
        ioTuneMap.put(VdsProperties.WriteIopsSec, storageQos.getMaxWriteIops().longValue());
    }
    return ioTuneMap;
}
#end_block

#method_before
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(SYSPREP_FILE_NAME, Base64.encodeBase64String(sysPrepContent.getBytes()));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#method_after
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(getOsRepository().getSysprepFileName(vm.getOs(), vm.getVdsGroupCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#end_block

#method_before
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), Base64.encodeBase64String(entry.getValue()));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#method_after
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), new String(BASE_64.encode(entry.getValue()), Charset.forName(CharEncoding.UTF_8)));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#end_block

#method_before
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VNIC_PROFILE_PROPERTIES> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debugFormat("VNIC {0} is using profile {1} on network {2}", nic.getName(), vnicProfile, networkName);
            if (!addQosForDevice(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion())) {
                unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.NETWORK_QOS);
            }
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    if (!addPortMirroringToVmInterface(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion(), network)) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.PORT_MIRRORING);
    }
    if (!addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile))) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.CUSTOM_PROPERTIES);
    }
    reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
}
#method_after
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VNIC_PROFILE_PROPERTIES> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debug("VNIC '{}' is using profile '{}' on network '{}'", nic.getName(), vnicProfile, networkName);
            if (!addQosForDevice(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion())) {
                unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.NETWORK_QOS);
            }
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    if (!addPortMirroringToVmInterface(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion(), network)) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.PORT_MIRRORING);
    }
    if (!addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile))) {
        unsupportedFeatures.add(VNIC_PROFILE_PROPERTIES.CUSTOM_PROPERTIES);
    }
    reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
}
#end_block

#method_before
public static String getTokenInstance(String content) {
    return String.format("0|%s|%s", content, hmacString(content));
}
#method_after
public static String getTokenInstance(String content) {
    return String.format("0|%s", content);
}
#end_block

#method_before
public static String getTokenContent(String token) {
    String[] s = token.split("\\|", 3);
    if (s.length != 3) {
        throw new IllegalArgumentException("Invalid session token format");
    }
    if (!"0".equals(s[0])) {
        throw new IllegalArgumentException("Invalid session token version");
    }
    if (s[1].isEmpty() || s[2].isEmpty()) {
        throw new IllegalArgumentException("Invalid session token format");
    }
    if (!s[2].equals(hmacString(s[1]))) {
        throw new IllegalArgumentException("Invalid session token instance");
    }
    return s[1];
}
#method_after
public static String getTokenContent(String token) {
    String[] s = token.split("\\|", 2);
    if (s.length != 2) {
        throw new IllegalArgumentException("Invalid session token format");
    }
    if (!"0".equals(s[0])) {
        throw new IllegalArgumentException("Invalid session token version");
    }
    if (s[1].isEmpty()) {
        throw new IllegalArgumentException("Invalid session token format");
    }
    return s[1];
}
#end_block

#method_before
@Test
public void testGetVdsCapabilities() throws InterruptedException, ExecutionException, ClientConnectionException {
    JsonRpcClient client = JsonRpcUtils.createStompClient(HOST_ADDRESS, PORT, TIMEOUT, 0, TIMEOUT, TIMEOUT, true, "TLS");
    final JsonRpcRequest request = new RequestBuilder("Host.getCapabilities").build();
    Map<String, Object> map = new FutureMap(client, request);
    assertTrue(map.isEmpty());
}
#method_after
@Test
public void testGetVdsCapabilities() throws InterruptedException, ExecutionException, ClientConnectionException {
    JsonRpcClient client = JsonRpcUtils.createStompClient(HOST_ADDRESS, PORT, TIMEOUT, 0, TIMEOUT, TIMEOUT, true, "TLSv1");
    final JsonRpcRequest request = new RequestBuilder("Host.getCapabilities").build();
    Map<String, Object> map = new FutureMap(client, request);
    assertTrue(map.isEmpty());
}
#end_block

#method_before
protected boolean checkExistingStorageDomain() {
    if (DbFacade.getInstance().getStorageDomainStaticDao().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getStorageDomain().getId())).getReturnValue();
    if (domainFromIrs == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    return concreteCheckExistingStorageDomain(domainFromIrs);
}
#method_after
protected boolean checkExistingStorageDomain() {
    if (DbFacade.getInstance().getStorageDomainStaticDao().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    Pair<StorageDomainStatic, Guid> domainFromIrs = executeHSMGetStorageDomainInfo(new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getStorageDomain().getId()));
    if (domainFromIrs == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    return concreteCheckExistingStorageDomain(domainFromIrs);
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            setCommandStatus(CommandStatus.SUCCEEDED);
            internalEndSuccessfully();
        } else {
            setCommandStatus(CommandStatus.FAILED);
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            if (getCallBack() == null) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            internalEndSuccessfully();
        } else {
            if (getCallBack() == null) {
                setCommandStatus(CommandStatus.FAILED);
            }
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
protected boolean validateVmProperties(VM vm, String runOnceCustomProperties, List<String> messages) {
    String customProperties = runOnceCustomProperties != null ? runOnceCustomProperties : vm.getCustomProperties();
    List<ValidationError> validationErrors = getVmPropertiesUtils().validateVmProperties(vm.getVdsGroupCompatibilityVersion(), customProperties);
    if (!validationErrors.isEmpty()) {
        getVmPropertiesUtils().handleCustomPropertiesError(validationErrors, messages);
        return false;
    }
    return true;
}
#method_after
protected boolean validateVmProperties(VM vm, String runOnceCustomProperties, List<String> messages) {
    String customProperties = runOnceCustomProperties != null ? runOnceCustomProperties : vm.getCustomProperties();
    return getVmPropertiesUtils().validateVmProperties(vm.getVdsGroupCompatibilityVersion(), customProperties, messages);
}
#end_block

#method_before
public static ValidationResultBuilder failWith(VdcBllMessages expectedError, String... variableReplacements) {
    return new ValidationResultBuilder(expectedError, variableReplacements);
}
#method_after
public static ValidationResultBuilder failWith(VdcBllMessages expectedError, String... replacements) {
    return new ValidationResultBuilder(expectedError, replacements);
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    vm.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    vm.setCustomSerialNumber(instance.getCustomSerialNumber());
    vm.setBootMenuEnabled(instance.isBootMenuEnabled());
    vm.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    vm.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    vm.setCpuProfileId(instance.getCpuProfileId());
    vm.setPredefinedProperties(instance.getPredefinedProperties());
    vm.setUserDefinedProperties(instance.getUserDefinedProperties());
    vm.setCustomProperties(instance.getCustomProperties());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    vm.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    vm.setCustomSerialNumber(instance.getCustomSerialNumber());
    vm.setBootMenuEnabled(instance.isBootMenuEnabled());
    vm.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    vm.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    vm.setCpuProfileId(instance.getCpuProfileId());
    vm.setAutoConverge(instance.getAutoConverge());
    vm.setMigrateCompressed(instance.getMigrateCompressed());
    vm.setPredefinedProperties(instance.getPredefinedProperties());
    vm.setUserDefinedProperties(instance.getUserDefinedProperties());
    vm.setCustomProperties(instance.getCustomProperties());
    return vm;
}
#end_block

#method_before
private static VDSGroup cloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setcpu_name(instance.getcpu_name());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    obj.setEmulatedMachine(instance.getEmulatedMachine());
    obj.setDetectEmulatedMachine(instance.isDetectEmulatedMachine());
    obj.setArchitecture(instance.getArchitecture());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setFencingPolicy(new FencingPolicy(instance.getFencingPolicy()));
    return obj;
}
#method_after
private static VDSGroup cloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setcpu_name(instance.getcpu_name());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    obj.setEmulatedMachine(instance.getEmulatedMachine());
    obj.setDetectEmulatedMachine(instance.isDetectEmulatedMachine());
    obj.setArchitecture(instance.getArchitecture());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setFencingPolicy(new FencingPolicy(instance.getFencingPolicy()));
    obj.setAutoConverge(instance.getAutoConverge());
    obj.setMigrateCompressed(instance.getMigrateCompressed());
    return obj;
}
#end_block

#method_before
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setBootMenuEnabled(instance.isBootMenuEnabled());
    obj.setCreatedByUserId(instance.getCreatedByUserId());
    obj.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    obj.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    obj.setCpuProfileId(instance.getCpuProfileId());
    obj.setPredefinedProperties(instance.getPredefinedProperties());
    obj.setUserDefinedProperties(instance.getUserDefinedProperties());
    obj.setCustomProperties(instance.getCustomProperties());
    return obj;
}
#method_after
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setBootMenuEnabled(instance.isBootMenuEnabled());
    obj.setCreatedByUserId(instance.getCreatedByUserId());
    obj.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    obj.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    obj.setCpuProfileId(instance.getCpuProfileId());
    obj.setAutoConverge(instance.getAutoConverge());
    obj.setMigrateCompressed(instance.getMigrateCompressed());
    obj.setPredefinedProperties(instance.getPredefinedProperties());
    obj.setUserDefinedProperties(instance.getUserDefinedProperties());
    obj.setCustomProperties(instance.getCustomProperties());
    return obj;
}
#end_block

#method_before
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setUseLatestVersion(instance.isUseLatestVersion());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setBootMenuEnabled(instance.isBootMenuEnabled());
    obj.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    obj.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    obj.setCpuProfileId(instance.getCpuProfileId());
    obj.setPredefinedProperties(instance.getPredefinedProperties());
    obj.setUserDefinedProperties(instance.getUserDefinedProperties());
    obj.setCustomProperties(instance.getCustomProperties());
    return obj;
}
#method_after
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setUseLatestVersion(instance.isUseLatestVersion());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setBootMenuEnabled(instance.isBootMenuEnabled());
    obj.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    obj.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    obj.setCpuProfileId(instance.getCpuProfileId());
    obj.setAutoConverge(instance.getAutoConverge());
    obj.setMigrateCompressed(instance.getMigrateCompressed());
    obj.setPredefinedProperties(instance.getPredefinedProperties());
    obj.setUserDefinedProperties(instance.getUserDefinedProperties());
    obj.setCustomProperties(instance.getCustomProperties());
    return obj;
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    if (mOldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate((new VmWatchdogValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isDisplayTypeSupported(getParameters().getVmTemplateData().getOsId(), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getcompatibility_version(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.isVirtioScsiControllerAttached(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.isBalloonEnabled(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVdsGroup().getcompatibility_version(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return returnValue;
}
#method_after
private boolean doClusterRelatedChecks() {
    if (mOldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate((new VmWatchdogValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isDisplayTypeSupported(getParameters().getVmTemplateData().getOsId(), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getcompatibility_version(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.isVirtioScsiControllerAttached(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.isBalloonEnabled(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVdsGroup().getcompatibility_version(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return returnValue;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    result = prime * result + ((serialNumberPolicy == null) ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + ((customSerialNumber == null) ? 0 : customSerialNumber.hashCode());
    result = prime * result + (bootMenuEnabled ? 1231 : 1237);
    result = prime * result + (spiceFileTransferEnabled ? 1231 : 1237);
    result = prime * result + (spiceCopyPasteEnabled ? 1231 : 1237);
    result = prime * result + ((cpuProfileId == null) ? 0 : cpuProfileId.hashCode());
    result = prime * result + ((numaTuneMode == null) ? 0 : numaTuneMode.getValue().hashCode());
    result = prime * result + ((vNumaNodeList == null) ? 0 : vNumaNodeList.hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    result = prime * result + ((serialNumberPolicy == null) ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + ((customSerialNumber == null) ? 0 : customSerialNumber.hashCode());
    result = prime * result + (bootMenuEnabled ? 1231 : 1237);
    result = prime * result + (spiceFileTransferEnabled ? 1231 : 1237);
    result = prime * result + (spiceCopyPasteEnabled ? 1231 : 1237);
    result = prime * result + ((cpuProfileId == null) ? 0 : cpuProfileId.hashCode());
    result = prime * result + ((numaTuneMode == null) ? 0 : numaTuneMode.getValue().hashCode());
    result = prime * result + ((vNumaNodeList == null) ? 0 : vNumaNodeList.hashCode());
    result = prime * result + (autoConverge == null ? 0 : autoConverge.hashCode());
    result = prime * result + (migrateCompressed == null ? 0 : migrateCompressed.hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && ObjectUtils.objectsEqual(cpuProfileId, other.cpuProfileId) && ObjectUtils.objectsEqual(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && ObjectUtils.objectsEqual(vNumaNodeList, other.vNumaNodeList)) && ObjectUtils.objectsEqual(predefinedProperties, other.predefinedProperties) && ObjectUtils.objectsEqual(userDefinedProperties, other.userDefinedProperties);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && ObjectUtils.objectsEqual(cpuProfileId, other.cpuProfileId) && ObjectUtils.objectsEqual(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && ObjectUtils.objectsEqual(vNumaNodeList, other.vNumaNodeList)) && ObjectUtils.objectsEqual(autoConverge, other.autoConverge) && ObjectUtils.objectsEqual(migrateCompressed, other.migrateCompressed) && ObjectUtils.objectsEqual(predefinedProperties, other.predefinedProperties) && ObjectUtils.objectsEqual(userDefinedProperties, other.userDefinedProperties);
}
#end_block

#method_before
protected MapSqlParameterSource createBaseParametersMapper(T entity) {
    return createIdParameterMapper(entity.getId()).addValue("description", entity.getDescription()).addValue("free_text_comment", entity.getComment()).addValue("creation_date", entity.getCreationDate()).addValue("mem_size_mb", entity.getMemSizeMb()).addValue("vnc_keyboard_layout", entity.getVncKeyboardLayout()).addValue("tunnel_migration", entity.getTunnelMigration()).addValue("vds_group_id", entity.getVdsGroupId()).addValue("num_of_sockets", entity.getNumOfSockets()).addValue("cpu_per_socket", entity.getCpuPerSocket()).addValue("os", entity.getOsId()).addValue("num_of_monitors", entity.getNumOfMonitors()).addValue("single_qxl_pci", entity.getSingleQxlPci()).addValue("allow_console_reconnect", entity.isAllowConsoleReconnect()).addValue("vm_type", entity.getVmType()).addValue("priority", entity.getPriority()).addValue("auto_startup", entity.isAutoStartup()).addValue("is_stateless", entity.isStateless()).addValue("is_smartcard_enabled", entity.isSmartcardEnabled()).addValue("is_delete_protected", entity.isDeleteProtected()).addValue("sso_method", entity.getSsoMethod().toString()).addValue("iso_path", entity.getIsoPath()).addValue("usb_policy", entity.getUsbPolicy()).addValue("time_zone", entity.getTimeZone()).addValue("fail_back", entity.isFailBack()).addValue("nice_level", entity.getNiceLevel()).addValue("cpu_shares", entity.getCpuShares()).addValue("default_boot_sequence", entity.getDefaultBootSequence()).addValue("default_display_type", entity.getDefaultDisplayType()).addValue("origin", entity.getOrigin()).addValue("initrd_url", entity.getInitrdUrl()).addValue("kernel_url", entity.getKernelUrl()).addValue("kernel_params", entity.getKernelParams()).addValue("quota_id", entity.getQuotaId()).addValue("migration_support", entity.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", entity.getDedicatedVmForVds()).addValue("min_allocated_mem", entity.getMinAllocatedMem()).addValue("is_run_and_pause", entity.isRunAndPause()).addValue("created_by_user_id", entity.getCreatedByUserId()).addValue("migration_downtime", entity.getMigrationDowntime()).addValue("serial_number_policy", entity.getSerialNumberPolicy() == null ? null : entity.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", entity.getCustomSerialNumber()).addValue("is_boot_menu_enabled", entity.isBootMenuEnabled()).addValue("is_spice_file_transfer_enabled", entity.isSpiceFileTransferEnabled()).addValue("is_spice_copy_paste_enabled", entity.isSpiceCopyPasteEnabled()).addValue("cpu_profile_id", entity.getCpuProfileId()).addValue("numatune_mode", entity.getNumaTuneMode().getValue()).addValue("predefined_properties", entity.getPredefinedProperties()).addValue("userdefined_properties", entity.getUserDefinedProperties());
}
#method_after
protected MapSqlParameterSource createBaseParametersMapper(T entity) {
    return createIdParameterMapper(entity.getId()).addValue("description", entity.getDescription()).addValue("free_text_comment", entity.getComment()).addValue("creation_date", entity.getCreationDate()).addValue("mem_size_mb", entity.getMemSizeMb()).addValue("vnc_keyboard_layout", entity.getVncKeyboardLayout()).addValue("tunnel_migration", entity.getTunnelMigration()).addValue("vds_group_id", entity.getVdsGroupId()).addValue("num_of_sockets", entity.getNumOfSockets()).addValue("cpu_per_socket", entity.getCpuPerSocket()).addValue("os", entity.getOsId()).addValue("num_of_monitors", entity.getNumOfMonitors()).addValue("single_qxl_pci", entity.getSingleQxlPci()).addValue("allow_console_reconnect", entity.isAllowConsoleReconnect()).addValue("vm_type", entity.getVmType()).addValue("priority", entity.getPriority()).addValue("auto_startup", entity.isAutoStartup()).addValue("is_stateless", entity.isStateless()).addValue("is_smartcard_enabled", entity.isSmartcardEnabled()).addValue("is_delete_protected", entity.isDeleteProtected()).addValue("sso_method", entity.getSsoMethod().toString()).addValue("iso_path", entity.getIsoPath()).addValue("usb_policy", entity.getUsbPolicy()).addValue("time_zone", entity.getTimeZone()).addValue("fail_back", entity.isFailBack()).addValue("nice_level", entity.getNiceLevel()).addValue("cpu_shares", entity.getCpuShares()).addValue("default_boot_sequence", entity.getDefaultBootSequence()).addValue("default_display_type", entity.getDefaultDisplayType()).addValue("origin", entity.getOrigin()).addValue("initrd_url", entity.getInitrdUrl()).addValue("kernel_url", entity.getKernelUrl()).addValue("kernel_params", entity.getKernelParams()).addValue("quota_id", entity.getQuotaId()).addValue("migration_support", entity.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", entity.getDedicatedVmForVds()).addValue("min_allocated_mem", entity.getMinAllocatedMem()).addValue("is_run_and_pause", entity.isRunAndPause()).addValue("created_by_user_id", entity.getCreatedByUserId()).addValue("migration_downtime", entity.getMigrationDowntime()).addValue("serial_number_policy", entity.getSerialNumberPolicy() == null ? null : entity.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", entity.getCustomSerialNumber()).addValue("is_boot_menu_enabled", entity.isBootMenuEnabled()).addValue("is_spice_file_transfer_enabled", entity.isSpiceFileTransferEnabled()).addValue("is_spice_copy_paste_enabled", entity.isSpiceCopyPasteEnabled()).addValue("cpu_profile_id", entity.getCpuProfileId()).addValue("numatune_mode", entity.getNumaTuneMode().getValue()).addValue("is_auto_converge", entity.getAutoConverge()).addValue("is_migrate_compressed", entity.getMigrateCompressed()).addValue("predefined_properties", entity.getPredefinedProperties()).addValue("userdefined_properties", entity.getUserDefinedProperties());
}
#end_block

#method_before
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setOsId(rs.getInt("os"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.setBootMenuEnabled(rs.getBoolean("is_boot_menu_enabled"));
    entity.setSpiceFileTransferEnabled(rs.getBoolean("is_spice_file_transfer_enabled"));
    entity.setSpiceCopyPasteEnabled(rs.getBoolean("is_spice_copy_paste_enabled"));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuProfileId(getGuid(rs, "cpu_profile_id"));
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
}
#method_after
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setOsId(rs.getInt("os"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.setBootMenuEnabled(rs.getBoolean("is_boot_menu_enabled"));
    entity.setSpiceFileTransferEnabled(rs.getBoolean("is_spice_file_transfer_enabled"));
    entity.setSpiceCopyPasteEnabled(rs.getBoolean("is_spice_copy_paste_enabled"));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuProfileId(getGuid(rs, "cpu_profile_id"));
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
}
#end_block

#method_before
public static boolean isAdminUser(DbUser user) {
    List<Role> userRoles = getRoleDAO().getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ","));
    if (userRoles.size() > 0) {
        log.debug("LoginAdminUser: User logged to admin using role '{}'", userRoles.get(0).getname());
        return true;
    }
    return false;
}
#method_after
public static boolean isAdminUser(DbUser user) {
    List<Role> userRoles = getRoleDAO().getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ","));
    if (!userRoles.isEmpty()) {
        log.debug("LoginAdminUser: User logged to admin using role '{}'", userRoles.get(0).getname());
        return true;
    }
    return false;
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    instanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Rng device tab
    rngDeviceTab.setLabel(constants.rngDeviceTab());
    isRngEnabledEditor.setLabel(constants.rngDevEnabled());
    rngPeriodEditor.setLabel(constants.rngPeriod());
    rngBytesEditor.setLabel(constants.rngBytes());
    rngSourceRandom.setLabel(constants.rngSourceRandom());
    rngSourceHwrng.setLabel(constants.rngSourceHwrng());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    spiceFileTransferEnabledEditor.setLabel(constants.spiceFileTransferEnabled());
    spiceCopyPasteEnabledEditor.setLabel(constants.spiceCopyPasteEnabled());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // numa
    numaTuneMode.setLabel(constants.numaTunaModeLabel());
    numaNodeCount.setLabel(constants.numaNodeCountLabel());
    numaSupportButton.setLabel(constants.numaSupportButtonLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    cpuProfilesEditor.setLabel(constants.cpuProfileLabel());
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
}
#method_after
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    instanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Rng device tab
    rngDeviceTab.setLabel(constants.rngDeviceTab());
    isRngEnabledEditor.setLabel(constants.rngDevEnabled());
    rngPeriodEditor.setLabel(constants.rngPeriod());
    rngBytesEditor.setLabel(constants.rngBytes());
    rngSourceRandom.setLabel(constants.rngSourceRandom());
    rngSourceHwrng.setLabel(constants.rngSourceHwrng());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    spiceFileTransferEnabledEditor.setLabel(constants.spiceFileTransferEnabled());
    spiceCopyPasteEnabledEditor.setLabel(constants.spiceCopyPasteEnabled());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.passThroughHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // numa
    numaTuneMode.setLabel(constants.numaTunaModeLabel());
    numaNodeCount.setLabel(constants.numaNodeCountLabel());
    numaSupportButton.setLabel(constants.numaSupportButtonLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    cpuProfilesEditor.setLabel(constants.cpuProfileLabel());
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
}
#end_block

#method_before
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, isHighlyAvailableEditorWithDetachable, priorityLabelWithDetachable, migrationModeEditorWithDetachable, memAllocationLabel, detachableMemSizeEditor, overrideMigrationDowntimeEditorWithDetachable, isRngEnabledCheckboxWithInfoIcon);
}
#method_after
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, isHighlyAvailableEditorWithDetachable, priorityLabelWithDetachable, migrationModeEditorWithDetachable, memAllocationLabel, detachableMemSizeEditor, overrideMigrationDowntimeEditorWithDetachable);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!getVm().isRunningOrPaused()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    if ((IsoDomainListSyncronizer.getInstance().findActiveISODomain(getVm().getStoragePoolId()) == null) && !StringUtils.isEmpty(cdImagePath)) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    if (StringUtils.isNotEmpty(cdImagePath) && !cdImagePath.toLowerCase().endsWith(ValidationUtils.ISO_SUFFIX)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_CDROM_DISK_FORMAT);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!getVm().isRunningOrPaused()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    if ((IsoDomainListSyncronizer.getInstance().findActiveISODomain(getVm().getStoragePoolId()) == null) && !StringUtils.isEmpty(cdImagePath)) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    if (!StringUtils.endsWithIgnoreCase(cdImagePath, ValidationUtils.ISO_SUFFIX)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_CDROM_DISK_FORMAT);
    }
    return true;
}
#end_block

#method_before
private int getAlertCount(AuditLog entry, List<AuditLog> results) {
    int count = 0;
    log.info("Founding alerts");
    if (results != null) {
        for (AuditLog al : results) {
            log.info("Testing: {id='{}', severity='{}', type='{}', hostId='{}', hostName='{}', date='{}'}", al.getAuditLogId(), al.getSeverity(), al.getLogType(), al.getVdsId(), al.getVdsName(), al.getLogTime());
            if (al.getSeverity() == entry.getSeverity() && al.getVdsId().equals(entry.getVdsId()) && al.getLogType() == entry.getLogType()) {
                count++;
            }
            log.info("Count: {}", count);
        }
    }
    log.info("Found alerts: {}", count);
    return count;
}
#method_after
private int getAlertCount(AuditLog entry, List<AuditLog> results) {
    int count = 0;
    if (results != null) {
        for (AuditLog al : results) {
            if (al.getSeverity() == entry.getSeverity() && al.getVdsId().equals(entry.getVdsId()) && al.getLogType() == entry.getLogType()) {
                count++;
            }
        }
    }
    return count;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warnFormat("Detaching Storage Domain {0} from it's previous storage pool {1} has failed. " + "The meta data of the Storage Domain might still indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        registerAllOvfDisks(getAllOVFDisks());
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.infoFormat("Adding OVF data of entity id {0} and entity name {1}", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getcompatibility_version())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getVds().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warn("Detaching Storage Domain '{}' from it's previous storage pool '{}'" + " has failed. The meta data of the Storage Domain might still" + " indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new VdcBLLException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : VdcBllErrors.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                    createDefaultDiskProfile();
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            updateStorageDomainFormat(getStorageDomain());
                        }
                        registerAllOvfDisks(getAllOVFDisks());
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList(getAllOVFDisks());
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    if (vdcReturnValue.getSucceeded()) {
                        return OvfUtils.getOvfEntities((byte[]) vdcReturnValue.getActionReturnValue(), getParameters().getStorageDomainId());
                    } else {
                        log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}", ovfDisk.getId(), getParameters().getStorageDomainId());
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}. Error: {2}", ovfDisk.getId(), getParameters().getStorageDomainId(), e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            }
        }
        AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warnFormat("There are no OVF_STORE disks on storage domain id {0}", getParameters().getStorageDomainId());
    }
    return Collections.emptyList();
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList(getAllOVFDisks());
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    if (vdcReturnValue.getSucceeded()) {
                        return OvfUtils.getOvfEntities((byte[]) vdcReturnValue.getActionReturnValue(), getParameters().getStorageDomainId());
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), getParameters().getStorageDomainId());
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), getParameters().getStorageDomainId(), e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            }
        }
        AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", getParameters().getStorageDomainId());
    }
    return Collections.emptyList();
}
#end_block

#method_before
private void registerAllOvfDisks(List<DiskImage> ovfStoreDiskImages) {
    for (DiskImage ovfStoreDiskImage : ovfStoreDiskImages) {
        ovfStoreDiskImage.setDiskAlias(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setDiskDescription(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setShareable(true);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(ovfStoreDiskImage, getParameters().getStorageDomainId());
        boolean registerDiskResult = runInternalAction(VdcActionType.RegisterDisk, registerDiskParams, cloneContext()).getSucceeded();
        log.infoFormat("Register new floating OVF_STORE disk with disk id {0} for storage domain {1} has {2}", ovfStoreDiskImage.getId(), getParameters().getStorageDomainId(), registerDiskResult ? "succeeded" : "failed");
        if (registerDiskResult) {
            log.infoFormat("Adding OVF_STORE disk with disk id {0} to storage domain {1}", ovfStoreDiskImage.getId(), getParameters().getStorageDomainId());
            addOvfStoreDiskToDomain(ovfStoreDiskImage);
        }
    }
}
#method_after
private void registerAllOvfDisks(List<DiskImage> ovfStoreDiskImages) {
    for (DiskImage ovfStoreDiskImage : ovfStoreDiskImages) {
        ovfStoreDiskImage.setDiskAlias(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setDiskDescription(OvfInfoFileConstants.OvfStoreDescriptionLabel);
        ovfStoreDiskImage.setShareable(true);
        RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(ovfStoreDiskImage, getParameters().getStorageDomainId());
        boolean registerDiskResult = runInternalAction(VdcActionType.RegisterDisk, registerDiskParams, cloneContext()).getSucceeded();
        log.info("Register new floating OVF_STORE disk with disk id '{}' for storage domain '{}' has {}", ovfStoreDiskImage.getId(), getParameters().getStorageDomainId(), registerDiskResult ? "succeeded" : "failed");
        if (registerDiskResult) {
            addOvfStoreDiskToDomain(ovfStoreDiskImage);
        }
    }
}
#end_block

#method_before
protected List<DiskImage> getAllOVFDisks() {
    if (ovfDisks == null) {
        ovfDisks = new ArrayList<>();
        // Get all unregistered disks.
        List<Disk> unregisteredDisks = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(getParameters().getStorageDomainId(), getVds().getStoragePoolId())).getReturnValue();
        for (Disk disk : unregisteredDisks) {
            DiskImage ovfStoreDisk = (DiskImage) disk;
            String diskDecription = ovfStoreDisk.getDescription();
            if (diskDecription.contains(OvfInfoFileConstants.OvfStoreDescriptionLabel)) {
                Map<String, Object> diskDescriptionMap;
                try {
                    diskDescriptionMap = JsonHelper.jsonToMap(diskDecription);
                } catch (IOException e) {
                    log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
                    continue;
                }
                // Domain.
                if (!isDomainExistsInDiskDescription(diskDescriptionMap, getParameters().getStorageDomainId())) {
                    log.warnFormat("The disk description does not contain the storage domain id {0}", getParameters().getStorageDomainId());
                    continue;
                }
                ovfDisks.add(ovfStoreDisk);
            }
        }
    }
    return ovfDisks;
}
#method_after
protected List<DiskImage> getAllOVFDisks() {
    if (ovfDisks == null) {
        ovfDisks = new ArrayList<>();
        // Get all unregistered disks.
        List<Disk> unregisteredDisks = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(getParameters().getStorageDomainId(), getVds().getStoragePoolId())).getReturnValue();
        for (Disk disk : unregisteredDisks) {
            DiskImage ovfStoreDisk = (DiskImage) disk;
            String diskDecription = ovfStoreDisk.getDescription();
            if (diskDecription.contains(OvfInfoFileConstants.OvfStoreDescriptionLabel)) {
                Map<String, Object> diskDescriptionMap;
                try {
                    diskDescriptionMap = JsonHelper.jsonToMap(diskDecription);
                } catch (IOException e) {
                    log.warn("Exception while generating json containing ovf store info: {}", e.getMessage());
                    log.debug("Exception", e);
                    continue;
                }
                // Domain.
                if (!isDomainExistsInDiskDescription(diskDescriptionMap, getParameters().getStorageDomainId())) {
                    log.warn("The disk description does not contain the storage domain id '{}'", getParameters().getStorageDomainId());
                    continue;
                }
                ovfDisks.add(ovfStoreDisk);
            }
        }
    }
    return ovfDisks;
}
#end_block

#method_before
private Pair<DiskImage, Long> getLatestOVFDisk(List<DiskImage> ovfStoreDiskImages) {
    Date foundOvfDiskUpdateDate = new Date();
    boolean isFoundOvfDiskUpdated = false;
    Long size = 0L;
    Disk ovfDisk = null;
    for (DiskImage ovfStoreDisk : ovfStoreDiskImages) {
        boolean isBetterOvfDiskFound = false;
        Map<String, Object> diskDescriptionMap;
        try {
            diskDescriptionMap = JsonHelper.jsonToMap(ovfStoreDisk.getDescription());
        } catch (IOException e) {
            log.warnFormat("Exception while generating json containing ovf store info. Exception: {0}", e);
            continue;
        }
        boolean isUpdated = Boolean.valueOf(diskDescriptionMap.get(OvfInfoFileConstants.IsUpdated).toString());
        Date date = getDateFromDiskDescription(diskDescriptionMap);
        if (date == null) {
            continue;
        }
        if (isFoundOvfDiskUpdated && !isUpdated) {
            continue;
        }
        if ((isUpdated && !isFoundOvfDiskUpdated) || date.after(foundOvfDiskUpdateDate)) {
            isBetterOvfDiskFound = true;
        }
        if (isBetterOvfDiskFound) {
            isFoundOvfDiskUpdated = isUpdated;
            foundOvfDiskUpdateDate = date;
            ovfDisk = ovfStoreDisk;
            size = new Long(diskDescriptionMap.get(OvfInfoFileConstants.Size).toString());
        }
    }
    return new Pair<>((DiskImage) ovfDisk, size);
}
#method_after
private Pair<DiskImage, Long> getLatestOVFDisk(List<DiskImage> ovfStoreDiskImages) {
    Date foundOvfDiskUpdateDate = new Date();
    boolean isFoundOvfDiskUpdated = false;
    Long size = 0L;
    Disk ovfDisk = null;
    for (DiskImage ovfStoreDisk : ovfStoreDiskImages) {
        boolean isBetterOvfDiskFound = false;
        Map<String, Object> diskDescriptionMap;
        try {
            diskDescriptionMap = JsonHelper.jsonToMap(ovfStoreDisk.getDescription());
        } catch (IOException e) {
            log.warn("Exception while generating json containing ovf store info: {}", e.getMessage());
            log.debug("Exception", e);
            continue;
        }
        boolean isUpdated = Boolean.valueOf(diskDescriptionMap.get(OvfInfoFileConstants.IsUpdated).toString());
        Date date = getDateFromDiskDescription(diskDescriptionMap);
        if (date == null) {
            continue;
        }
        if (isFoundOvfDiskUpdated && !isUpdated) {
            continue;
        }
        if ((isUpdated && !isFoundOvfDiskUpdated) || date.after(foundOvfDiskUpdateDate)) {
            isBetterOvfDiskFound = true;
        }
        if (isBetterOvfDiskFound) {
            isFoundOvfDiskUpdated = isUpdated;
            foundOvfDiskUpdateDate = date;
            ovfDisk = ovfStoreDisk;
            size = new Long(diskDescriptionMap.get(OvfInfoFileConstants.Size).toString());
        }
    }
    return new Pair<>((DiskImage) ovfDisk, size);
}
#end_block

#method_before
private Date getDateFromDiskDescription(Map<String, Object> map) {
    try {
        Object lastUpdate = map.get(OvfInfoFileConstants.LastUpdated);
        if (lastUpdate != null) {
            return new SimpleDateFormat(OvfParser.formatStrFromDiskDescription).parse(lastUpdate.toString());
        } else {
            log.info("LastUpdate Date is not initialized in the OVF_STORE disk.");
        }
    } catch (java.text.ParseException e) {
        log.errorFormat("LastUpdate Date could not be parsed from disk desscription. Exception: {0}", e);
    }
    return null;
}
#method_after
private Date getDateFromDiskDescription(Map<String, Object> map) {
    try {
        Object lastUpdate = map.get(OvfInfoFileConstants.LastUpdated);
        if (lastUpdate != null) {
            return new SimpleDateFormat(OvfParser.formatStrFromDiskDescription).parse(lastUpdate.toString());
        } else {
            log.info("LastUpdate Date is not initialized in the OVF_STORE disk.");
        }
    } catch (java.text.ParseException e) {
        log.error("LastUpdate Date could not be parsed from disk description: {}", e.getMessage());
        log.debug("Exception", e);
    }
    return null;
}
#end_block

#method_before
protected void attemptToActivateDomain() {
    StorageDomainPoolParametersBase activateParameters = new StorageDomainPoolParametersBase(getStorageDomain().getId(), getStoragePool().getId());
    getBackend().runInternalAction(VdcActionType.ActivateStorageDomain, activateParameters);
}
#method_after
protected void attemptToActivateDomain() {
    StorageDomainPoolParametersBase activateParameters = new StorageDomainPoolParametersBase(getStorageDomain().getId(), getStoragePool().getId());
    getBackend().runInternalAction(VdcActionType.ActivateStorageDomain, activateParameters, cloneContext().withoutCompensationContext().withoutExecutionContext());
}
#end_block

#method_before
@Override
protected void onReveal() {
    super.onReveal();
    // Notify model provider that the tab has been revealed
    modelProvider.onSubTabSelected();
    if (getTable() != null) {
        getTable().setLoadingState(LoadingState.LOADING);
    }
}
#method_after
@Override
protected void onReveal() {
    super.onReveal();
    // Notify model provider that the tab has been revealed
    modelProvider.onSubTabSelected();
}
#end_block

#method_before
public void initializeHandlers() {
    // Notify view when the entity of the detail model changes
    modelProvider.getModel().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Object entity = modelProvider.getModel().getEntity();
            if (entity != null) {
                onDetailModelEntityChange(entity);
            }
        }
    });
    // Notify view when the detail model indicates progress
    modelProvider.getModel().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (PropertyChangedEventArgs.PROGRESS.equals(args.propertyName)) {
                if (modelProvider.getModel().getProgress() != null) {
                    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                        @Override
                        public void execute() {
                            if (getTable() != null) {
                                getTable().setLoadingState(LoadingState.LOADING);
                            }
                        }
                    });
                }
            }
        }
    });
}
#method_after
public void initializeHandlers() {
    // Notify view when the entity of the detail model changes
    modelProvider.getModel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Object entity = modelProvider.getModel().getEntity();
            if (entity != null) {
                onDetailModelEntityChange(entity);
            }
        }
    });
    // Notify view when the detail model indicates progress
    modelProvider.getModel().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (PropertyChangedEventArgs.PROGRESS.equals(args.propertyName)) {
                if (modelProvider.getModel().getProgress() != null) {
                    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                        @Override
                        public void execute() {
                            if (getTable() != null) {
                                getTable().setLoadingState(LoadingState.LOADING);
                            }
                        }
                    });
                }
            }
        }
    });
}
#end_block

#method_before
protected void bindCommonInfrastructure(Class<? extends PlaceManager> placeManager) {
    bindEventBus();
    bindFrontendInfrastructure();
    bind(TokenFormatter.class).to(ParameterTokenFormatter.class).in(Singleton.class);
    bind(RootPresenter.class).asEagerSingleton();
    bindTypeAndImplAsSingleton(PlaceManager.class, placeManager);
    bind(CurrentUser.class).in(Singleton.class);
    bind(LoggedInGatekeeper.class).in(Singleton.class);
    bind(ErrorPopupManager.class).to(ErrorPopupManagerImpl.class).in(Singleton.class);
    bind(AsyncCallFailureHandler.class).asEagerSingleton();
    bind(ClientAgentType.class).in(Singleton.class);
    bind(ClientStorage.class).to(ClientStorageImpl.class).in(Singleton.class);
    bind(ApplicationFocusManager.class).asEagerSingleton();
    bind(LockInteractionManager.class).asEagerSingleton();
}
#method_after
protected void bindCommonInfrastructure(Class<? extends PlaceManager> placeManager) {
    install(new CommonGinModule());
    bindEventBus();
    bindFrontendInfrastructure();
    bind(TokenFormatter.class).to(ParameterTokenFormatter.class).in(Singleton.class);
    bind(RootPresenter.class).asEagerSingleton();
    bindTypeAndImplAsSingleton(PlaceManager.class, placeManager);
    bind(CurrentUser.class).in(Singleton.class);
    bind(LoggedInGatekeeper.class).in(Singleton.class);
    bind(ErrorPopupManager.class).to(ErrorPopupManagerImpl.class).in(Singleton.class);
    bind(AsyncCallFailureHandler.class).asEagerSingleton();
    bind(ClientAgentType.class).in(Singleton.class);
    bind(ClientStorage.class).to(ClientStorageImpl.class).in(Singleton.class);
    bind(ApplicationFocusManager.class).asEagerSingleton();
    bind(LockInteractionManager.class).asEagerSingleton();
}
#end_block

#method_before
@ProxyEvent
public void onMainModelSelectionChange(MainModelSelectionChangeEvent event) {
    if (event.getMainModel() == getModel()) {
        if (event.getMainModel().getIsAvailable()) {
            // Reveal main tab place when the corresponding model is selected
            placeManager.revealPlace(getMainTabRequest());
        } else {
            revealActiveMainModelPresenter();
        }
    }
}
#method_after
@Override
public void onMainModelSelectionChange(MainModelSelectionChangeEvent event) {
    if (event.getMainModel() == getModel()) {
        if (event.getMainModel().getIsAvailable()) {
            // Reveal main tab place when the corresponding model is selected
            placeManager.revealPlace(getMainTabRequest());
        } else {
            revealActiveMainModelPresenter();
        }
    }
}
#end_block

#method_before
@Override
public void initializeHandlers() {
    super.initializeHandlers();
    // Initialize the list of alerts:
    final HostGeneralModel model = getModelProvider().getModel();
    updateAlerts(getView(), model);
    // Listen for changes in the properties of the model in order
    // to update the alerts panel:
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (args instanceof PropertyChangedEventArgs) {
                PropertyChangedEventArgs changedArgs = (PropertyChangedEventArgs) args;
                if (changedArgs.propertyName.contains("Alert")) {
                    // $NON-NLS-1$
                    updateAlerts(getView(), model);
                }
            }
        }
    });
}
#method_after
@Override
public void initializeHandlers() {
    super.initializeHandlers();
    // Initialize the list of alerts:
    final HostGeneralModel model = getModelProvider().getModel();
    updateAlerts(getView(), model);
    // Listen for changes in the properties of the model in order
    // to update the alerts panel:
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName.contains("Alert")) {
                // $NON-NLS-1$
                updateAlerts(getView(), model);
            }
        }
    });
}
#end_block

#method_before
@Override
public void initializeHandlers() {
    super.initializeHandlers();
    // Initialize the list of alerts:
    final VmGeneralModel model = getModelProvider().getModel();
    updateAlerts(getView(), model);
    // Listen for changes in the properties of the model in order
    // to update the alerts panel:
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (args instanceof PropertyChangedEventArgs) {
                PropertyChangedEventArgs changedArgs = (PropertyChangedEventArgs) args;
                if (changedArgs.propertyName.contains("Alert")) {
                    // $NON-NLS-1$
                    updateAlerts(getView(), model);
                }
            }
        }
    });
}
#method_after
@Override
public void initializeHandlers() {
    super.initializeHandlers();
    // Initialize the list of alerts:
    final VmGeneralModel model = getModelProvider().getModel();
    updateAlerts(getView(), model);
    // Listen for changes in the properties of the model in order
    // to update the alerts panel:
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName.contains("Alert")) {
                // $NON-NLS-1$
                updateAlerts(getView(), model);
            }
        }
    });
}
#end_block

#method_before
@Override
public void initializeHandlers() {
    super.initializeHandlers();
    // Initialize the list of alerts:
    final ClusterGeneralModel model = getModelProvider().getModel();
    updateAlerts(getView(), model);
    // Listen for changes in the properties of the model in order
    // to update the alerts panel:
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (args instanceof PropertyChangedEventArgs) {
                PropertyChangedEventArgs changedArgs = (PropertyChangedEventArgs) args;
                if (changedArgs.propertyName.contains("Alert")) {
                    // $NON-NLS-1$
                    updateAlerts(getView(), model);
                } else if (changedArgs.propertyName.contains("consoleAddressPartiallyOverridden")) {
                    // $NON-NLS-1$
                    updateAlerts(getView(), model);
                }
            }
        }
    });
}
#method_after
@Override
public void initializeHandlers() {
    super.initializeHandlers();
    // Initialize the list of alerts:
    final ClusterGeneralModel model = getModelProvider().getModel();
    updateAlerts(getView(), model);
    // Listen for changes in the properties of the model in order
    // to update the alerts panel:
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName.contains("Alert")) {
                // $NON-NLS-1$
                updateAlerts(getView(), model);
            } else if (args.propertyName.contains("consoleAddressPartiallyOverridden")) {
                // $NON-NLS-1$
                updateAlerts(getView(), model);
            }
        }
    });
}
#end_block

#method_before
@Override
protected void onReset() {
    super.onReset();
    if (!hasReportsModelRefreshEvent()) {
        reportsWebappDeployed = false;
        getModel().getReportModelRefreshEvent().addListener(new ReportsModelRefreshEvent());
    }
    setSubTabPanelVisible(false);
    getModel().refreshReportModel();
}
#method_after
@Override
protected void onReset() {
    super.onReset();
    if (!hasReportsModelRefreshEvent()) {
        getModel().getReportsAvailabilityEvent().addListener(new ReportsModelRefreshEvent());
    }
    setSubTabPanelVisible(false);
    getModel().refreshReportModel();
}
#end_block

#method_before
private boolean hasReportsModelRefreshEvent() {
    for (IEventListener<EventArgs> listnr : getModel().getReportModelRefreshEvent().getListeners()) {
        if (listnr instanceof ReportsModelRefreshEvent) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean hasReportsModelRefreshEvent() {
    for (IEventListener<? extends EventArgs> listnr : (List<IEventListener<? extends EventArgs>>) getModel().getReportsAvailabilityEvent().getListeners()) {
        if (listnr instanceof ReportsModelRefreshEvent) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void eventRaised(Event<EventArgs> ev, Object sender, EventArgs args) {
    if (reportsWebappDeployed) {
        getView().updateReportsPanel(getModel().getUrl(), getModel().getParams());
    } else {
        checkUpdateReportsPanel(getModel().getUrl(), getModel().getParams());
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    if (reportsWebappDeployed && getModel().getUri() != null) {
        getView().updateReportsPanel(getModel().getUrl(), getModel().getParams());
    }
}
#end_block

#method_before
@Override
protected void onReveal() {
    Event entityChangedEvent = getModel().getDiskViewType().getEntityChangedEvent();
    if (!entityChangedEvent.getListeners().contains(getView().getDiskTypeChangedEventListener())) {
        entityChangedEvent.addListener(getView().getDiskTypeChangedEventListener());
    }
    Event systemTreeSelectedItemChangedEvent = CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent();
    systemTreeSelectedItemChangedEvent.addListener(systemTreeListener);
    super.onReveal();
    getView().handleQuotaColumnVisibility();
}
#method_after
@Override
protected void onReveal() {
    Event<EventArgs> entityChangedEvent = getModel().getDiskViewType().getEntityChangedEvent();
    if (!entityChangedEvent.getListeners().contains(getView().getDiskTypeChangedEventListener())) {
        entityChangedEvent.addListener(getView().getDiskTypeChangedEventListener());
    }
    Event<EventArgs> systemTreeSelectedItemChangedEvent = CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent();
    systemTreeSelectedItemChangedEvent.addListener(systemTreeListener);
    super.onReveal();
    getView().handleQuotaColumnVisibility();
}
#end_block

#method_before
@Override
protected void onHide() {
    super.onHide();
    Event systemTreeSelectedItemChangedEvent = CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent();
    systemTreeSelectedItemChangedEvent.removeListener(systemTreeListener);
}
#method_after
@Override
protected void onHide() {
    super.onHide();
    Event<EventArgs> systemTreeSelectedItemChangedEvent = CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent();
    systemTreeSelectedItemChangedEvent.removeListener(systemTreeListener);
}
#end_block

#method_before
@Override
protected ReqWriter newReqWriter(XmlRpcRequest pRequest) throws XmlRpcException, IOException, SAXException {
    if (METHOD_LIST.contains(pRequest.getMethodName())) {
        pRequest = new XmlRpcClientRequestImpl(pRequest.getConfig(), pRequest.getMethodName(), normalizeDoubles(pRequest));
    }
    return super.newReqWriter(pRequest);
}
#method_after
@Override
protected ReqWriter newReqWriter(XmlRpcRequest pRequest) throws XmlRpcException, IOException, SAXException {
    if (SUPPORTED_METHODS_FOR_LONG_CONVERSION.contains(pRequest.getMethodName())) {
        pRequest = new XmlRpcClientRequestImpl(pRequest.getConfig(), pRequest.getMethodName(), normalizeLongs(pRequest));
    }
    return super.newReqWriter(pRequest);
}
#end_block

#method_before
public void filterItems(Filter<T> filter) {
    if (filter == null) {
        if (ObjectUtils.objectsEqual(this.allItems, getItems())) {
            return;
        } else {
            setItemsSelectionAware(this.allItems);
        }
    }
    final Collection<T> itemsToShow = new ArrayList<T>();
    for (T item : this.allItems) {
        if (filter.filter(item)) {
            itemsToShow.add(item);
        }
    }
    setItemsSelectionAware(itemsToShow);
}
#method_after
public void filterItems(Filter<T> filter) {
    if (filter == null) {
        if (ObjectUtils.objectsEqual(this.allItems, getItems())) {
            return;
        }
        setItemsSelectionAware(this.allItems);
    }
    final Collection<T> itemsToShow = new ArrayList<T>();
    for (T item : this.allItems) {
        if (filter.filter(item)) {
            itemsToShow.add(item);
        }
    }
    setItemsSelectionAware(itemsToShow);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    if (getParameters().getAddProvisioned()) {
        if (getParameters().getComputeResource() == null) {
            log.error("Failed to provision: Compute resource cannot be empty");
            throw new VdcBLLException(VdcBllErrors.PROVIDER_PROVISION_MISSING_COMPUTERESOURCE);
        }
        if (getParameters().getHostGroup() == null) {
            log.error("Failed to provision: Host group cannot be empty");
            throw new VdcBLLException(VdcBllErrors.PROVIDER_PROVISION_MISSING_HOSTGROUP);
        }
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                // Adding vdsStatic first to have vdsId before calling to provision
                AddVdsStaticToDb();
                HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
                getParameters().getvds().getStaticData().setHostProviderId(getParameters().getProviderId());
                proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword());
                AddVdsDynamicToDb();
                AddVdsStatisticsToDb();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        AuditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    } else {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                AddVdsStaticToDb();
                AddVdsDynamicToDb();
                AddVdsStatisticsToDb();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending() && !getParameters().getAddProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().getAddProvisioned()) {
        if (getParameters().getComputeResource() == null) {
            log.error("Failed to provision: Compute resource cannot be empty");
            throw new VdcBLLException(VdcBllErrors.PROVIDER_PROVISION_MISSING_COMPUTERESOURCE);
        }
        if (getParameters().getHostGroup() == null) {
            log.error("Failed to provision: Host group cannot be empty");
            throw new VdcBLLException(VdcBllErrors.PROVIDER_PROVISION_MISSING_HOSTGROUP);
        }
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        getParameters().getvds().getStaticData().setHostProviderId(getParameters().getProviderId());
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        AuditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending() && !getParameters().getAddProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(getOsRepository().getSysprepDestName(vm.getOs(), vm.getVdsGroupCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#method_after
@Override
protected void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(getOsRepository().getSysprepFileName(vm.getOs(), vm.getVdsGroupCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#end_block

#method_before
public ExtMap queryGroups(ExtMap input, ExtMap output) {
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setLdapQueryType(LdapQueryType.searchGroups);
    queryData.setDomain(getDirectoryName());
    queryData.setFilterParameters(new Object[] { generateQueryString(input) });
    // Find the users using the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.SearchGroupsByQuery, new LdapSearchByQueryParameters(configuration, null, getDirectoryName(), queryData, false, false));
    checkForErrors(ldapResult, output);
    List<LdapGroup> ldapGroups = (List<LdapGroup>) ldapResult.getReturnValue();
    List<ExtMap> results = new ArrayList<>();
    for (LdapGroup ldapGroup : ldapGroups) {
        results.add(mapLdapGroup(ldapGroup));
    }
    return output.mput(Authz.InvokeKeys.QUERY_RESULT, results);
}
#method_after
public ExtMap queryGroups(ExtMap input, ExtMap output) throws Exception {
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setLdapQueryType(LdapQueryType.searchGroups);
    queryData.setDomain(getDirectoryName());
    queryData.setFilterParameters(new Object[] { generateQueryString(input) });
    // Find the users using the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.SearchGroupsByQuery, new LdapSearchByQueryParameters(configuration, null, getDirectoryName(), queryData, false, false));
    if (!ldapResult.getSucceeded()) {
        throw new Exception(ldapResult.getExceptionString());
    }
    List<LdapGroup> ldapGroups = (List<LdapGroup>) ldapResult.getReturnValue();
    List<ExtMap> results = new ArrayList<>();
    for (LdapGroup ldapGroup : ldapGroups) {
        results.add(mapLdapGroup(ldapGroup));
    }
    return output.mput(Authz.InvokeKeys.QUERY_RESULT, results);
}
#end_block

#method_before
public ExtMap queryUsers(ExtMap input, ExtMap output) {
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setLdapQueryType(LdapQueryType.searchUsers);
    queryData.setDomain(getDirectoryName());
    queryData.setFilterParameters(new Object[] { generateQueryString(input) });
    // Find the users using the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(configuration, null, getDirectoryName(), queryData, (input.<Integer>get(Authz.InvokeKeys.QUERY_FLAGS, 0) & Authz.QueryFlags.RESOLVE_GROUPS) != 0, (input.<Integer>get(Authz.InvokeKeys.QUERY_FLAGS, 0) & Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE) != 0));
    checkForErrors(ldapResult, output);
    List<LdapUser> ldapUsers = (List<LdapUser>) ldapResult.getReturnValue();
    List<ExtMap> results = new ArrayList<>();
    for (LdapUser ldapUser : ldapUsers) {
        results.add(mapLdapUser(ldapUser));
    }
    return output.mput(Authz.InvokeKeys.QUERY_RESULT, results);
}
#method_after
public ExtMap queryUsers(ExtMap input, ExtMap output) throws Exception {
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setLdapQueryType(LdapQueryType.searchUsers);
    queryData.setDomain(getDirectoryName());
    queryData.setFilterParameters(new Object[] { generateQueryString(input) });
    // Find the users using the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(configuration, null, getDirectoryName(), queryData, (input.<Integer>get(Authz.InvokeKeys.QUERY_FLAGS, 0) & Authz.QueryFlags.RESOLVE_GROUPS) != 0, (input.<Integer>get(Authz.InvokeKeys.QUERY_FLAGS, 0) & Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE) != 0));
    if (!ldapResult.getSucceeded()) {
        throw new Exception(ldapResult.getExceptionString());
    }
    List<LdapUser> ldapUsers = (List<LdapUser>) ldapResult.getReturnValue();
    List<ExtMap> results = new ArrayList<>();
    for (LdapUser ldapUser : ldapUsers) {
        results.add(mapLdapUser(ldapUser));
    }
    return output.mput(Authz.InvokeKeys.QUERY_RESULT, results);
}
#end_block

#method_before
private void doQueryExecute(ExtMap input, ExtMap output) {
    Opaque opaque = input.<Opaque>get(Authz.InvokeKeys.QUERY_OPAQUE);
    if (opaque.getQueryInfo() == null) {
        output.mput(Authz.InvokeKeys.QUERY_RESULT, null);
    } else {
        if (opaque.getQueryInfo().<ExtUUID>get(Authz.InvokeKeys.QUERY_ENTITY).equals(Authz.QueryEntity.GROUP)) {
            queryGroups(opaque.getQueryInfo(), output);
        } else if (opaque.getQueryInfo().<ExtUUID>get(Authz.InvokeKeys.QUERY_ENTITY).equals(Authz.QueryEntity.PRINCIPAL)) {
            queryUsers(opaque.getQueryInfo(), output);
        }
        opaque.resetQueryInfo();
    }
    output.mput(Authz.InvokeKeys.QUERY_OPAQUE, opaque);
}
#method_after
private void doQueryExecute(ExtMap input, ExtMap output) throws Exception {
    Opaque opaque = input.<Opaque>get(Authz.InvokeKeys.QUERY_OPAQUE);
    if (opaque.getQueryInfo() == null) {
        output.mput(Authz.InvokeKeys.QUERY_RESULT, null);
    } else {
        if (opaque.getQueryInfo().<ExtUUID>get(Authz.InvokeKeys.QUERY_ENTITY).equals(Authz.QueryEntity.GROUP)) {
            queryGroups(opaque.getQueryInfo(), output);
        } else if (opaque.getQueryInfo().<ExtUUID>get(Authz.InvokeKeys.QUERY_ENTITY).equals(Authz.QueryEntity.PRINCIPAL)) {
            queryUsers(opaque.getQueryInfo(), output);
        }
        opaque.resetQueryInfo();
    }
    output.mput(Authz.InvokeKeys.QUERY_OPAQUE, opaque);
}
#end_block

#method_before
@Override
public Guid getMasterStorageDomainIdForPool(Guid pool) {
    return getStorageDomainId(pool, StorageDomainType.Master);
}
#method_after
@Override
public Guid getMasterStorageDomainIdForPool(Guid poolId) {
    return getStorageDomainId(poolId, StorageDomainType.Master);
}
#end_block

#method_before
@Override
public StorageDomain getStorageDomain(Guid pool, StorageDomainType type) {
    return getStorageDomain(pool, type, null);
}
#method_after
@Override
public StorageDomain getStorageDomain(Guid poolId, StorageDomainType type) {
    return getStorageDomain(poolId, type, null);
}
#end_block

#method_before
public StorageDomain getStorageDomain(Guid pool, StorageDomainType type, StorageDomainStatus status) {
    Integer statusNum = status == null ? null : status.getValue();
    return getCallsHandler().executeRead("Getstorage_domain_by_type_storagePoolId_and_status", StorageDomainRowMapper.instance, getCustomMapSqlParameterSource().addValue("storage_pool_id", pool).addValue("storage_domain_type", type.getValue()).addValue("status", statusNum));
}
#method_after
public StorageDomain getStorageDomain(Guid poolId, StorageDomainType type, StorageDomainStatus status) {
    Integer statusNum = status == null ? null : status.getValue();
    return getCallsHandler().executeRead("Getstorage_domain_by_type_storagePoolId_and_status", StorageDomainRowMapper.instance, getCustomMapSqlParameterSource().addValue("storage_pool_id", poolId).addValue("storage_domain_type", type.getValue()).addValue("status", statusNum));
}
#end_block

#method_before
@Override
public Guid getIsoStorageDomainIdForPool(Guid pool) {
    return getStorageDomainId(pool, StorageDomainType.ISO, StorageDomainStatus.Active);
}
#method_after
@Override
public Guid getIsoStorageDomainIdForPool(Guid poolId, StorageDomainStatus status) {
    return getStorageDomainId(poolId, StorageDomainType.ISO, status);
}
#end_block

#method_before
private String getManagementOptions(FenceAgentOrder order) {
    String managementOptions = "";
    ArchitectureType architectureType = null;
    VDSGroup cluster = DbFacade.getInstance().getVdsGroupDao().get(_vds.getVdsGroupId());
    VdsDynamic vdsDynamic = DbFacade.getInstance().getVdsDynamicDao().get(_vds.getId());
    architectureType = _vds.getArchitecture(CpuFlagsManagerHandler.FindMaxServerCpuByFlags(vdsDynamic.getcpu_flags(), cluster.getcompatibility_version()), cluster);
    if (order == FenceAgentOrder.Primary) {
        managementOptions = VdsFenceOptions.getDefaultAgentOptions(_vds.getPmType(), _vds.getPmOptions(), architectureType);
    } else if (order == FenceAgentOrder.Secondary) {
        managementOptions = VdsFenceOptions.getDefaultAgentOptions(_vds.getPmSecondaryType(), _vds.getPmSecondaryOptions(), architectureType);
    }
    return managementOptions;
}
#method_after
private String getManagementOptions(FenceAgentOrder order) {
    String managementOptions = "";
    ArchitectureType architectureType = VdsArchitectureHelper.getArchitecture(_vds.getStaticData());
    if (order == FenceAgentOrder.Primary) {
        managementOptions = VdsFenceOptions.getDefaultAgentOptions(_vds.getPmType(), _vds.getPmOptions(), architectureType);
    } else if (order == FenceAgentOrder.Secondary) {
        managementOptions = VdsFenceOptions.getDefaultAgentOptions(_vds.getPmSecondaryType(), _vds.getPmSecondaryOptions(), architectureType);
    }
    return managementOptions;
}
#end_block

#method_before
private int getSleep(FenceActionType actionType, FenceAgentOrder order) {
    if (actionType != FenceActionType.Stop) {
        return SLEEP_BEFORE_FIRST_ATTEMPT;
    }
    // We have to find out if power off delay was used and add this to the wait time
    // since otherwise the command will return immediately with 'off' status and
    // subsequent 'on' command issued during this delay will be overridden by the actual shutdown
    String agent = (order == FenceAgentOrder.Primary) ? getVds().getPmType() : getVds().getPmSecondaryType();
    String options = (order == FenceAgentOrder.Primary) ? getVds().getPmOptions() : getVds().getPmSecondaryOptions();
    VdsDynamic vdsDynamic = DbFacade.getInstance().getVdsDynamicDao().get(getVds().getId());
    ArchitectureType architectureType = getVds().getArchitecture(CpuFlagsManagerHandler.FindMaxServerCpuByFlags(vdsDynamic.getcpu_flags(), getVdsGroup().getcompatibility_version()), getVdsGroup());
    options = VdsFenceOptions.getDefaultAgentOptions(agent, options, architectureType);
    HashMap<String, String> optionsMap = VdsStatic.pmOptionsStringToMap(options);
    String powerWaitParamSettings = FenceConfigHelper.getFenceConfigurationValue(ConfigValues.FencePowerWaitParam.name(), ConfigCommon.defaultConfigurationVersion);
    String powerWaitParam = VdsFenceOptions.getAgentPowerWaitParam(agent, powerWaitParamSettings);
    if (powerWaitParam == null) {
        // no power wait for this agent
        return SLEEP_BEFORE_FIRST_ATTEMPT;
    }
    if (optionsMap.containsKey(powerWaitParam)) {
        try {
            Integer powerWaitValueInSec = Integer.parseInt(optionsMap.get(powerWaitParam));
            return SLEEP_BEFORE_FIRST_ATTEMPT + (int) TimeUnit.SECONDS.toMillis(powerWaitValueInSec);
        } catch (NumberFormatException nfe) {
            // illegal value
            return SLEEP_BEFORE_FIRST_ATTEMPT;
        }
    }
    return SLEEP_BEFORE_FIRST_ATTEMPT;
}
#method_after
private int getSleep(FenceActionType actionType, FenceAgentOrder order) {
    if (actionType != FenceActionType.Stop) {
        return SLEEP_BEFORE_FIRST_ATTEMPT;
    }
    // We have to find out if power off delay was used and add this to the wait time
    // since otherwise the command will return immediately with 'off' status and
    // subsequent 'on' command issued during this delay will be overridden by the actual shutdown
    String agent = (order == FenceAgentOrder.Primary) ? getVds().getPmType() : getVds().getPmSecondaryType();
    String options = (order == FenceAgentOrder.Primary) ? getVds().getPmOptions() : getVds().getPmSecondaryOptions();
    ArchitectureType architectureType = VdsArchitectureHelper.getArchitecture(getVds().getStaticData());
    options = VdsFenceOptions.getDefaultAgentOptions(agent, options, architectureType);
    HashMap<String, String> optionsMap = VdsStatic.pmOptionsStringToMap(options);
    String powerWaitParamSettings = FenceConfigHelper.getFenceConfigurationValue(ConfigValues.FencePowerWaitParam.name(), ConfigCommon.defaultConfigurationVersion);
    String powerWaitParam = VdsFenceOptions.getAgentPowerWaitParam(agent, powerWaitParamSettings);
    if (powerWaitParam == null) {
        // no power wait for this agent
        return SLEEP_BEFORE_FIRST_ATTEMPT;
    }
    if (optionsMap.containsKey(powerWaitParam)) {
        try {
            Integer powerWaitValueInSec = Integer.parseInt(optionsMap.get(powerWaitParam));
            return SLEEP_BEFORE_FIRST_ATTEMPT + (int) TimeUnit.SECONDS.toMillis(powerWaitValueInSec);
        } catch (NumberFormatException nfe) {
            // illegal value
            return SLEEP_BEFORE_FIRST_ATTEMPT;
        }
    }
    return SLEEP_BEFORE_FIRST_ATTEMPT;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getParameters().getId(), getUserID(), getParameters().isFiltered());
    List<Disk> disks = new ArrayList<Disk>(allDisks);
    for (Disk disk : allDisks) {
        if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
            DiskImage diskImage = (DiskImage) disk;
            diskImage.getSnapshots().addAll(getAllImageSnapshots(diskImage));
        }
    }
    getQueryReturnValue().setReturnValue(disks);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getParameters().getId(), getUserID(), getParameters().isFiltered());
    List<Disk> disks = new ArrayList<Disk>();
    for (Disk disk : allDisks) {
        if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
            DiskImage diskImage = (DiskImage) disk;
            diskImage.getSnapshots().addAll(getAllImageSnapshots(diskImage));
        }
        disks.add(disk);
    }
    getQueryReturnValue().setReturnValue(disks);
}
#end_block

#method_before
protected List<DiskImage> getAllImageSnapshots(DiskImage diskImage) {
    return ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), diskImage.getImageTemplateId());
}
#method_after
protected List<DiskImage> getAllImageSnapshots(DiskImage diskImage) {
    return ImagesHandler.getAllImageSnapshots(diskImage.getImageId());
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("boot_order", entity.getBootOrder()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties())).addValue("snapshot_id", entity.getSnapshotId());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("boot_order", entity.getBootOrder()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties())).addValue("snapshot_id", entity.getSnapshotId()).addValue("logical_name", entity.getLogicalName());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public VmDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(getGuidDefaultEmpty(rs, "device_id"), getGuidDefaultEmpty(rs, "vm_id")));
    vmDevice.setDevice(rs.getString("device"));
    vmDevice.setType(VmDeviceGeneralType.forValue(rs.getString("type")));
    vmDevice.setAddress(rs.getString("address"));
    vmDevice.setBootOrder(rs.getInt("boot_order"));
    vmDevice.setSpecParams(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("spec_params"), HashMap.class));
    vmDevice.setIsManaged(rs.getBoolean("is_managed"));
    // note - those columns are being used also in DiskRowMapper, therefore any related
    // change should be done there as well.
    vmDevice.setIsPlugged(rs.getBoolean("is_plugged"));
    vmDevice.setIsReadOnly(rs.getBoolean("is_readonly"));
    vmDevice.setAlias(rs.getString("alias"));
    vmDevice.setCustomProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    vmDevice.setSnapshotId(getGuid(rs, "snapshot_id"));
    return vmDevice;
}
#method_after
@SuppressWarnings("unchecked")
@Override
public VmDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(getGuidDefaultEmpty(rs, "device_id"), getGuidDefaultEmpty(rs, "vm_id")));
    vmDevice.setDevice(rs.getString("device"));
    vmDevice.setType(VmDeviceGeneralType.forValue(rs.getString("type")));
    vmDevice.setAddress(rs.getString("address"));
    vmDevice.setBootOrder(rs.getInt("boot_order"));
    vmDevice.setSpecParams(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("spec_params"), HashMap.class));
    vmDevice.setIsManaged(rs.getBoolean("is_managed"));
    // note - those columns are being used also in DiskVmRowMapper, therefore any related
    // change should be done there as well.
    vmDevice.setIsPlugged(rs.getBoolean("is_plugged"));
    vmDevice.setIsReadOnly(rs.getBoolean("is_readonly"));
    vmDevice.setAlias(rs.getString("alias"));
    vmDevice.setCustomProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    vmDevice.setSnapshotId(getGuid(rs, "snapshot_id"));
    vmDevice.setLogicalName(rs.getString("logical_name"));
    return vmDevice;
}
#end_block

#method_before
@Override
public Disk mapRow(ResultSet rs, int rowNum) throws SQLException {
    Disk disk = DiskRowMapper.instance.mapRow(rs, rowNum);
    disk.setPlugged(rs.getBoolean("is_plugged"));
    disk.setReadOnly(rs.getBoolean("is_readonly"));
    return disk;
}
#method_after
@Override
public Disk mapRow(ResultSet rs, int rowNum) throws SQLException {
    Disk disk = DiskRowMapper.instance.mapRow(rs, rowNum);
    disk.setPlugged(rs.getBoolean("is_plugged"));
    disk.setReadOnly(rs.getBoolean("is_readonly"));
    disk.setLogicalName(rs.getString("logical_name"));
    return disk;
}
#end_block

#method_before
@Override
public void onPowerringUp() {
// nothing to dog
}
#method_after
@Override
public void onPowerringUp() {
// nothing to do
}
#end_block

#method_before
protected boolean validateVM(VmValidator vmValidator) {
    return canDoSnapshot(getVm()) && validate(vmValidator.vmNotSavingRestoring()) && validate(vmValidator.vmNotSuspended());
}
#method_after
protected boolean validateVM(VmValidator vmValidator) {
    return canDoSnapshot(getVm()) && validate(vmValidator.vmNotSavingRestoring()) && validate(vmValidator.validateVmStatusUsingMatrix(VdcActionType.CreateAllSnapshotsFromVm));
}
#end_block

#method_before
private void handleVdsLiveSnapshotFailure(VdcBLLException e) {
    log.warn("Could not perform live snapshot due to error, VM will still be configured to the new created snapshot", e);
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    updateCallStackFromThrowable(e);
    AuditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE);
}
#method_after
private void handleVdsLiveSnapshotFailure(VdcBLLException e) {
    log.warn("Could not perform live snapshot due to error, VM will still be configured to the new created" + " snapshot: {}", e.getMessage());
    log.debug("Exception", e);
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    updateCallStackFromThrowable(e);
    AuditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE);
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            List<ActionButtonDefinition<?>> pluginActionButtonList = actionButtonPluginHandler.getButtons(getProxy().getTargetHistoryToken());
            if (getTable() != null && pluginActionButtonList != null) {
                for (ActionButtonDefinition<?> buttonDef : pluginActionButtonList) {
                    getTable().addActionButton((ActionButtonDefinition) buttonDef);
                }
            }
        }
    });
    // Register this handler for whichever tab opens first, it is bound before the plugin fires its events and
    // before the actionButtonPluginHandler is instantiated and listening to events.
    registerHandler(getEventBus().addHandler(AddTabActionButtonEvent.getType(), new AddTabActionButtonEvent.AddTabActionButtonHandler() {

        @Override
        public void onAddTabActionButton(AddTabActionButtonEvent event) {
            if (getProxy().getTargetHistoryToken().equals(event.getHistoryToken())) {
                if (getTable() != null) {
                    getTable().addActionButton((ActionButtonDefinition) event.getButtonDefinition());
                }
            }
        }
    }));
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            addPluginActionButtons(actionButtonPluginHandler.getButtons(getProxy().getTargetHistoryToken()));
        }
    });
    // Register this handler for whichever tab opens first, it is bound before the plugin fires its events and
    // before the actionButtonPluginHandler is instantiated and listening to events.
    registerHandler(getEventBus().addHandler(AddTabActionButtonEvent.getType(), new AddTabActionButtonEvent.AddTabActionButtonHandler() {

        @Override
        public void onAddTabActionButton(AddTabActionButtonEvent event) {
            if (getProxy().getTargetHistoryToken().equals(event.getHistoryToken())) {
                List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<ActionButtonDefinition<?>>();
                pluginActionButtonList.add(event.getButtonDefinition());
                addPluginActionButtons(pluginActionButtonList);
            }
        }
    }));
}
#end_block

#method_before
@Inject
public void setActionButtonPluginHandler(ActionButtonPluginHandler actionButtonPluginHandler) {
    this.actionButtonPluginHandler = actionButtonPluginHandler;
}
#method_after
@Inject
public void setActionButtonPluginHandler(PluginActionButtonHandler actionButtonPluginHandler) {
    this.actionButtonPluginHandler = actionButtonPluginHandler;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ConsoleOptionsFrontendPersister.class).to(ConsoleOptionsFrontendPersisterImpl.class).in(Singleton.class);
    bind(ConsoleUtils.class).to(ConsoleUtilsImpl.class).in(Singleton.class);
    bind(ActionButtonPluginHandler.class).in(Singleton.class);
}
#method_after
@Override
protected void configure() {
    bind(ConsoleOptionsFrontendPersister.class).to(ConsoleOptionsFrontendPersisterImpl.class).in(Singleton.class);
    bind(ConsoleUtils.class).to(ConsoleUtilsImpl.class).in(Singleton.class);
    bind(PluginActionButtonHandler.class).in(Singleton.class);
}
#end_block

#method_before
@Test
public void doTest() throws URISyntaxException, IOException {
    for (File localeFile : getMessagesPropertiesFiles(".")) {
        Properties properties = loadProperties(localeFile);
        compareMethodsToProperties(messagesMethods, properties, localeFile);
    }
    assertTrue(format(errors), errors.isEmpty());
}
#method_after
@Test
public void doTest() throws URISyntaxException, IOException {
    List<String> errors = GwtMessagesValidator.validateClass(CommonApplicationMessages.class);
    assertTrue(GwtMessagesValidator.format(errors), errors.isEmpty());
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getNetworkQosDao();
    VDS host = getDbFacade().getVdsDao().get(getParameters().getVdsId());
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(host.getVdsGroupCompatibilityVersion());
    Set<Version> supportedClusterVersionsSet = host.getSupportedClusterVersionsSet();
    boolean supportedClusterVersionsAvailable = supportedClusterVersionsSet != null && supportedClusterVersionsSet.isEmpty();
    if (!supportedClusterVersionsAvailable) {
        log.warnFormat("Host {0} ({1}) doesn't contain Supported Cluster Versions, therefore 'defaultRoute'" + " will not be sent via the SetupNetworks", host.getName(), host.getId());
    }
    boolean defaultRouteSupported = supportedClusterVersionsAvailable && FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet));
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", NetworkUtils.getDefaultMtu().toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (hostNetworkQosSupported && qosConfiguredOnInterface(iface, network)) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        if (defaultRouteSupported && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.hasCustomProperties()) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getNetworkQosDao();
    VDS host = getParameters().getVds();
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(host.getVdsGroupCompatibilityVersion());
    Set<Version> supportedClusterVersionsSet = host.getSupportedClusterVersionsSet();
    boolean supportedClusterVersionsAvailable = supportedClusterVersionsSet != null && supportedClusterVersionsSet.isEmpty();
    if (!supportedClusterVersionsAvailable) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, therefore 'defaultRoute'" + " will not be sent via the SetupNetworks", host.getName(), host.getId());
    }
    boolean defaultRouteSupported = supportedClusterVersionsAvailable && FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet));
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", NetworkUtils.getDefaultMtu().toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (hostNetworkQosSupported && qosConfiguredOnInterface(iface, network)) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        if (defaultRouteSupported && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.hasCustomProperties()) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
@Test
public void vlanOverNic() {
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.DHCP, null);
    VdsNetworkInterface vlan = createVlan(nic, net);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(nic), Collections.<String>emptySet(), Arrays.asList(nic, vlan));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
}
#method_after
@Test
public void vlanOverNic() {
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.DHCP, null);
    VdsNetworkInterface vlan = createVlan(nic, net);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(nic), Collections.<String>emptySet(), Arrays.asList(nic, vlan));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
}
#end_block

#method_before
@Test
public void vlanOverBond() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface vlan = createVlan(bond, net);
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(slaves);
    ifaces.add(bond);
    ifaces.add(vlan);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces);
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    assertBondWasSent(bond, slaves);
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(bond.getName(), networkStruct.get("bonding"));
}
#method_after
@Test
public void vlanOverBond() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface vlan = createVlan(bond, net);
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(slaves);
    ifaces.add(bond);
    ifaces.add(vlan);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces);
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    assertBondWasSent(bond, slaves);
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(bond.getName(), networkStruct.get("bonding"));
}
#end_block

#method_before
@Test
public void networkWithDhcp() {
    Network net = createNetwork(null);
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.DHCP, net.getName());
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(net), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Arrays.asList(nic));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
    assertEquals(SetupNetworksVDSCommand.DHCP_BOOT_PROTOCOL, networkStruct.get(SetupNetworksVDSCommand.BOOT_PROTOCOL));
}
#method_after
@Test
public void networkWithDhcp() {
    Network net = createNetwork(null);
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.DHCP, net.getName());
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(net), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Arrays.asList(nic));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
    assertEquals(SetupNetworksVDSCommand.DHCP_BOOT_PROTOCOL, networkStruct.get(SetupNetworksVDSCommand.BOOT_PROTOCOL));
}
#end_block

#method_before
@Test
public void bondModified() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(slaves);
    ifaces.add(bond);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.<Network>emptyList(), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces);
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> bondMap = assertBondWasSent(bond, slaves);
    assertEquals(bond.getBondOptions(), bondMap.get(SetupNetworksVDSCommand.BONDING_OPTIONS));
}
#method_after
@Test
public void bondModified() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(slaves);
    ifaces.add(bond);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.<Network>emptyList(), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces);
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> bondMap = assertBondWasSent(bond, slaves);
    assertEquals(bond.getBondOptions(), bondMap.get(SetupNetworksVDSCommand.BONDING_OPTIONS));
}
#end_block

#method_before
private void qos(Network network, VdsNetworkInterface iface, NetworkQoS expectedQos, boolean hostNetworkQosSupported) {
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, hostNetworkQosSupported);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    NetworkQosMapper qosMapper = new NetworkQosMapper(networkStruct, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
    NetworkQoS deserialize = qosMapper.deserialize();
    assertTrue((expectedQos == null && deserialize == null) || (expectedQos != null && expectedQos.equalValues(deserialize)));
}
#method_after
private void qos(Network network, VdsNetworkInterface iface, NetworkQoS expectedQos, boolean hostNetworkQosSupported) {
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, hostNetworkQosSupported);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(host, Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    NetworkQosMapper qosMapper = new NetworkQosMapper(networkStruct, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
    NetworkQoS deserialize = qosMapper.deserialize();
    assertTrue((expectedQos == null && deserialize == null) || (expectedQos != null && expectedQos.equalValues(deserialize)));
}
#end_block

#method_before
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#method_after
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChainText, new ProviderQueryParameters(provider), aQuery);
}
#end_block

#method_before
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        // currently on VDSM side reboot is supported only when the guest agent is present and responsive so we need to check for that
        if (!isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion) || StringHelper.isNullOrEmpty(vm.getVmIp())) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        boolean compatibleCluster = isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion);
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getVmIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(compatibleCluster && (guestAgentPresent || acpiEnabled))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void postMigrateGetUpHosts(List<VM> selectedVms, ArrayList<VDS> hosts) {
    setVmsOnSameCluster(true);
    setIsSameVdsMessageVisible(false);
    setNoSelAvailable(false);
    Guid run_on_vds = null;
    boolean allRunOnSameVds = true;
    for (Object item : selectedVms) {
        VM a = (VM) item;
        if (!a.getVdsGroupId().equals((selectedVms.get(0)).getVdsGroupId())) {
            setVmsOnSameCluster(false);
        }
        if (run_on_vds == null) {
            run_on_vds = a.getRunOnVds();
        } else if (allRunOnSameVds && !run_on_vds.equals(a.getRunOnVds())) {
            allRunOnSameVds = false;
        }
    }
    setIsHostSelAvailable(getVmsOnSameCluster() && hosts.size() > 0);
    if (getVmsOnSameCluster() && allRunOnSameVds) {
        VDS runOnSameVDS = null;
        for (VDS host : hosts) {
            if (host.getId().equals(run_on_vds)) {
                runOnSameVDS = host;
            }
        }
        hosts.remove(runOnSameVDS);
    }
    getCommands().clear();
    if (hosts.isEmpty()) {
        setIsHostSelAvailable(false);
        getHosts().setItems(new ArrayList<VDS>());
        if (allRunOnSameVds) {
            setNoSelAvailable(true);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", parentModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            getCommands().add(tempVar);
        }
    } else {
        getHosts().setItems(hosts, Linq.firstOrDefault(hosts));
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("OnMigrate", parentModel);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar2.setIsDefault(true);
        getCommands().add(tempVar2);
        // $NON-NLS-1$
        UICommand tempVar3 = new UICommand("Cancel", parentModel);
        tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar3.setIsCancel(true);
        getCommands().add(tempVar3);
    }
}
#method_after
private void postMigrateGetUpHosts(List<VM> selectedVms, ArrayList<VDS> hosts) {
    setVmsOnSameCluster(true);
    setIsSameVdsMessageVisible(false);
    setNoSelAvailable(false);
    Guid run_on_vds = null;
    boolean allRunOnSameVds = true;
    for (VM item : selectedVms) {
        if (!item.getVdsGroupId().equals((selectedVms.get(0)).getVdsGroupId())) {
            setVmsOnSameCluster(false);
        }
        if (run_on_vds == null) {
            run_on_vds = item.getRunOnVds();
        } else if (allRunOnSameVds && !run_on_vds.equals(item.getRunOnVds())) {
            allRunOnSameVds = false;
        }
    }
    setIsHostSelAvailable(getVmsOnSameCluster() && hosts.size() > 0);
    removeUnselectableHosts(hosts, run_on_vds, allRunOnSameVds);
    getCommands().clear();
    if (hosts.isEmpty()) {
        setIsHostSelAvailable(false);
        getHosts().setItems(new ArrayList<VDS>());
        if (allRunOnSameVds) {
            setNoSelAvailable(true);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", parentModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            getCommands().add(tempVar);
        }
    } else {
        getHosts().setItems(hosts, Linq.firstOrDefault(hosts));
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("OnMigrate", parentModel);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar2.setIsDefault(true);
        getCommands().add(tempVar2);
        // $NON-NLS-1$
        UICommand tempVar3 = new UICommand("Cancel", parentModel);
        tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar3.setIsCancel(true);
        getCommands().add(tempVar3);
    }
}
#end_block

#method_before
void initEditors() {
    // $NON-NLS-1$
    selectHostAutomaticallyEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    selectDestinationHostEditor = new EntityModelRadioButtonEditor("1");
    hostsListEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS vds) {
            return vds.getName();
        }
    });
    clusters = new ListModelListBoxEditor<VDSGroup>(new NullSafeRenderer<VDSGroup>() {

        @Override
        protected String renderNullSafe(VDSGroup cluster) {
            return cluster.getName();
        }
    });
}
#method_after
void initEditors() {
    // $NON-NLS-1$
    selectHostAutomaticallyEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    selectDestinationHostEditor = new EntityModelRadioButtonEditor("1");
    hostsListEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS vds) {
            return vds.getName();
        }
    });
    clustersEditor = new ListModelListBoxEditor<VDSGroup>(new NullSafeRenderer<VDSGroup>() {

        @Override
        protected String renderNullSafe(VDSGroup cluster) {
            return cluster.getName();
        }
    });
}
#end_block

#method_before
void localize(ApplicationConstants constants, ApplicationMessages messages) {
    selectHostAutomaticallyEditor.setLabel(constants.vmMigratePopupSelectHostAutomaticallyLabel());
    selectDestinationHostEditor.setLabel(constants.vmMigratePopupSelectDestinationHostLabel());
    hostsListEditor.setLabel(constants.vmMigratePopupHostsListLabel());
    clusters.setLabel(constants.hostClusterVmPopup());
    message1.setText(messages.migrateHostDisabledVMsInServerClusters());
    message2.setText(messages.migrateSomeVmsAlreadyRunningOnHost());
    message3.setText(messages.migrateNoAvailableHost());
}
#method_after
void localize(ApplicationConstants constants, ApplicationMessages messages) {
    selectHostAutomaticallyEditor.setLabel(constants.vmMigratePopupSelectHostAutomaticallyLabel());
    selectDestinationHostEditor.setLabel(constants.vmMigratePopupSelectDestinationHostLabel());
    hostsListEditor.setLabel(constants.vmMigratePopupHostsListLabel());
    clustersEditor.setLabel(constants.hostClusterVmPopup());
    message1.setText(messages.migrateHostDisabledVMsInServerClusters());
    message2.setText(messages.migrateSomeVmsAlreadyRunningOnHost());
    message3.setText(messages.migrateNoAvailableHost());
}
#end_block

#method_before
@Override
public Guid getMasterStorageDomainIdForPool(Guid pool) {
    return getStorageDomainId(pool, StorageDomainType.Master);
}
#method_after
@Override
public Guid getMasterStorageDomainIdForPool(Guid poolId) {
    return getStorageDomainId(poolId, StorageDomainType.Master);
}
#end_block

#method_before
@Override
public StorageDomain getStorageDomain(Guid pool, StorageDomainType type) {
    return getCallsHandler().executeRead("Getstorage_domain_by_type_and_storagePoolId", StorageDomainRowMapper.instance, getCustomMapSqlParameterSource().addValue("storage_pool_id", pool).addValue("storage_domain_type", type.getValue()));
}
#method_after
@Override
public StorageDomain getStorageDomain(Guid poolId, StorageDomainType type) {
    return getCallsHandler().executeRead("Getstorage_domain_by_type_and_storagePoolId", StorageDomainRowMapper.instance, getCustomMapSqlParameterSource().addValue("storage_pool_id", poolId).addValue("storage_domain_type", type.getValue()));
}
#end_block

#method_before
@Override
public Guid getIsoStorageDomainIdForPool(Guid pool) {
    return getStorageDomainId(pool, StorageDomainType.ISO);
}
#method_after
@Override
public Guid getIsoStorageDomainIdForPool(Guid poolId) {
    return getStorageDomainId(poolId, StorageDomainType.ISO);
}
#end_block

#method_before
@Override
public StorageDomain getStorageDomain(Guid pool, StorageDomainType type) {
    return getCallsHandler().executeRead("Getstorage_domain_by_type_and_storagePoolId", StorageDomainRowMapper.instance, getCustomMapSqlParameterSource().addValue("storage_pool_id", pool).addValue("storage_domain_type", type.getValue()));
}
#method_after
@Override
public StorageDomain getStorageDomain(Guid poolId, StorageDomainType type) {
    return getCallsHandler().executeRead("Getstorage_domain_by_type_and_storagePoolId", StorageDomainRowMapper.instance, getCustomMapSqlParameterSource().addValue("storage_pool_id", poolId).addValue("storage_domain_type", type.getValue()));
}
#end_block

#method_before
private boolean initTrustedService() {
    List<String> hosts = new ArrayList<String>();
    if (AttestThread.isTrustedVds(getVds().getId())) {
        return true;
    }
    hosts.add(getVds().getHostName());
    List<AttestationValue> value = new ArrayList<AttestationValue>();
    try {
        value = AttestationService.getInstance().attestHosts(hosts);
    } catch (Exception e) {
        log.errorFormat("Encounter an exception while attesting host's trustworthiness for Host {0}, Error is {1}", hosts, e);
    }
    if (value.size() > 0 && value.get(0).getTrustLevel() == AttestationResultEnum.TRUSTED) {
        return true;
    } else {
        setNonOperational(NonOperationalReason.UNTRUSTED, null);
        return false;
    }
}
#method_after
private boolean initTrustedService() {
    List<String> hosts = new ArrayList<String>();
    if (AttestThread.isTrustedVds(getVds().getId())) {
        return true;
    }
    hosts.add(getVds().getHostName());
    List<AttestationValue> value = new ArrayList<AttestationValue>();
    try {
        value = AttestationService.getInstance().attestHosts(hosts);
    } catch (Exception e) {
        log.error("Encounter an exception while attesting host's trustworthiness for Host '{}': {}", hosts, e.getMessage());
        log.debug("Exception", e);
    }
    if (value.size() > 0 && value.get(0).getTrustLevel() == AttestationResultEnum.TRUSTED) {
        return true;
    } else {
        setNonOperational(NonOperationalReason.UNTRUSTED, null);
        return false;
    }
}
#end_block

#method_before
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomain(storagePoolId, StorageDomainType.Master);
    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(storagePoolId);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.Inactive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomain.getId(), storagePoolIsoMap));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (VdcBLLException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != VdcBllErrors.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.infoFormat("Could not connect host {0} to pool {1}, as the master domain is in inactive/unknown status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.errorFormat("Could not connect host {0} to pool {1} with the message: {2}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        Pair<Boolean, List<StorageDomainStatic>> vdsStatsResults = proceedVdsStats(!masterDomainInactiveOrUnknown);
        result.setSuccess(vdsStatsResults.getFirst());
        if (!result.isSuccess()) {
            result.setResultData(vdsStatsResults.getSecond());
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#method_after
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomain(storagePoolId, StorageDomainType.Master);
    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(storagePoolId);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.Inactive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomain.getId(), storagePoolIsoMap));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (VdcBLLException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != VdcBllErrors.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.info("Could not connect host '{}' to pool '{}', as the master domain is in inactive/unknown" + " status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.error("Could not connect host '{}' to pool '{}': {}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        Pair<Boolean, List<StorageDomainStatic>> vdsStatsResults = proceedVdsStats(!masterDomainInactiveOrUnknown);
        result.setSuccess(vdsStatsResults.getFirst());
        if (!result.isSuccess()) {
            result.setResultData(vdsStatsResults.getSecond());
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#end_block

#method_before
private VDSReturnValue runUpdateMomPolicy(final VDSGroup cluster, final VDS vds) {
    VDSReturnValue returnValue = new VDSReturnValue();
    if (cluster.getcompatibility_version().compareTo(Version.v3_3) >= 0) {
        try {
            returnValue = runVdsCommand(VDSCommandType.SetMOMPolicyParameters, new MomPolicyVDSParameters(vds, cluster.isEnableBallooning(), cluster.isEnableKsm()));
        } catch (VdcBLLException e) {
            log.errorFormat("Could not update MoM policy on host {0}", vds.getName());
            returnValue.setSucceeded(false);
        }
    }
    return returnValue;
}
#method_after
private VDSReturnValue runUpdateMomPolicy(final VDSGroup cluster, final VDS vds) {
    VDSReturnValue returnValue = new VDSReturnValue();
    if (cluster.getcompatibility_version().compareTo(Version.v3_3) >= 0) {
        try {
            returnValue = runVdsCommand(VDSCommandType.SetMOMPolicyParameters, new MomPolicyVDSParameters(vds, cluster.isEnableBallooning(), cluster.isEnableKsm()));
        } catch (VdcBLLException e) {
            log.error("Could not update MoM policy on host '{}'", vds.getName());
            returnValue.setSucceeded(false);
        }
    }
    return returnValue;
}
#end_block

#method_before
private Pair<Boolean, List<StorageDomainStatic>> proceedVdsStats(boolean shouldCheckReportedDomains) {
    Pair<Boolean, List<StorageDomainStatic>> returnValue = new Pair<>(true, null);
    try {
        runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
        if (shouldCheckReportedDomains) {
            List<Guid> problematicDomainsIds = IrsBrokerCommand.fetchDomainsReportedAsProblematic(getVds().getStoragePoolId(), getVds().getDomains());
            for (Guid domainId : problematicDomainsIds) {
                StorageDomainStatic domainInfo = getStorageDomainStaticDAO().get(domainId);
                log.errorFormat("Storage Domain {0} of pool {1} is in problem in host {2}", domainInfo != null ? domainInfo.getStorageName() : domainId, getStoragePool().getName(), getVds().getName());
                if (domainInfo == null || domainInfo.getStorageDomainType().isDataDomain()) {
                    returnValue.setFirst(false);
                    if (returnValue.getSecond() == null) {
                        returnValue.setSecond(new ArrayList<StorageDomainStatic>());
                    }
                    returnValue.getSecond().add(domainInfo);
                }
            }
        }
    } catch (VdcBLLException e) {
        log.errorFormat("Could not get Host statistics for Host {0}, Error is {1}", getVds().getName(), e);
        returnValue.setFirst(false);
    }
    return returnValue;
}
#method_after
private Pair<Boolean, List<StorageDomainStatic>> proceedVdsStats(boolean shouldCheckReportedDomains) {
    Pair<Boolean, List<StorageDomainStatic>> returnValue = new Pair<>(true, null);
    try {
        runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
        if (shouldCheckReportedDomains) {
            List<Guid> problematicDomainsIds = IrsBrokerCommand.fetchDomainsReportedAsProblematic(getVds().getStoragePoolId(), getVds().getDomains());
            for (Guid domainId : problematicDomainsIds) {
                StorageDomainStatic domainInfo = getStorageDomainStaticDAO().get(domainId);
                log.error("Storage Domain '{}' of pool '{}' is in problem in host '{}'", domainInfo != null ? domainInfo.getStorageName() : domainId, getStoragePool().getName(), getVds().getName());
                if (domainInfo == null || domainInfo.getStorageDomainType().isDataDomain()) {
                    returnValue.setFirst(false);
                    if (returnValue.getSecond() == null) {
                        returnValue.setSecond(new ArrayList<StorageDomainStatic>());
                    }
                    returnValue.getSecond().add(domainInfo);
                }
            }
        }
    } catch (VdcBLLException e) {
        log.error("Could not get Host statistics for Host '{}': {}", getVds().getName(), e.getMessage());
        log.debug("Exception", e);
        returnValue.setFirst(false);
    }
    return returnValue;
}
#end_block

#method_before
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!getGlusterUtil().isHostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < getMaxRetriesGlusterProbeStatus()) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!getGlusterUtil().isHostExists(newGlusterServers, getVds())) {
                            log.infoFormat("Failed to find host {0} in gluster peer list from {1} on attempt {2}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == getMaxRetriesGlusterProbeStatus()) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#method_after
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!getGlusterUtil().isHostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < getMaxRetriesGlusterProbeStatus()) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!getGlusterUtil().isHostExists(newGlusterServers, getVds())) {
                            log.info("Failed to find host '{}' in gluster peer list from '{}' on attempt {}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == getMaxRetriesGlusterProbeStatus()) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#end_block

#method_before
private boolean glusterPeerProbe(Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            AuditLogableBase logable = new AuditLogableBase(getVdsId());
            logable.updateCallStackFromThrowable(returnValue.getExceptionObject());
            AuditLogDirector.log(logable, AuditLogType.GLUSTER_SERVER_ADD_FAILED);
            glusterPeerProbeSucceeded = false;
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.errorFormat("Could not peer probe the gluster server {0}. Error: {1}", getVds().getHostName(), e.getMessage());
        glusterPeerProbeSucceeded = false;
        return false;
    }
}
#method_after
private boolean glusterPeerProbe(Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            AuditLogableBase logable = new AuditLogableBase(getVdsId());
            logable.updateCallStackFromThrowable(returnValue.getExceptionObject());
            AuditLogDirector.log(logable, AuditLogType.GLUSTER_SERVER_ADD_FAILED);
            glusterPeerProbeSucceeded = false;
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.error("Could not peer probe the gluster server '{}': {}", getVds().getHostName(), e.getMessage());
        log.debug("Exception", e);
        glusterPeerProbeSucceeded = false;
        return false;
    }
}
#end_block

#method_before
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#method_after
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChainText, new ProviderQueryParameters(provider), aQuery);
}
#end_block

#method_before
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        if (!isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion) || // no guest agent nor acpi enabled
        (StringHelper.isNullOrEmpty(vm.getVmIp()) && Boolean.FALSE.equals(vm.getAcpiEnable()))) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        boolean compatibleCluster = isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion);
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getVmIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(compatibleCluster && (guestAgentPresent || acpiEnabled))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void refreshGeoRepDataInCluster(VDSGroup cluster) {
    if (!supportsGlusterGeoRepFeature(cluster)) {
        return;
    }
    List<GlusterGeoRepSession> sessions = getSessionsForCluster(cluster);
    // for each geo-rep session, find session in database and update details.
    for (GlusterGeoRepSession session : sessions) {
        session.setMasterVolumeId(getVolumeId(cluster, session.getMasterVolumeName()));
        // update consolidated status
        updateGeoRepStatus(session);
        // check if session exists in database
        if (getGeoRepDao().getById(session.getId()) == null) {
            // save the session in database first.
            getGeoRepDao().save(session);
        } else {
            getGeoRepDao().updateSession(session);
        }
        getGeoRepDao().saveOrUpdateDetailsInBatch(session.getSessionDetails());
    }
}
#method_after
public void refreshGeoRepDataInCluster(VDSGroup cluster) {
    if (!supportsGlusterGeoRepFeature(cluster)) {
        return;
    }
    Map<String, GlusterGeoRepSession> sessionsMap = getSessionsForCluster(cluster);
    if (sessionsMap == null) {
        log.debug("Error in retrieving sessions for cluster '{}' from CLI, nothing to do", cluster.getName());
        return;
    }
    removeDeletedSessions(cluster.getId(), sessionsMap);
    // for each geo-rep session, find session in database and update details.
    for (GlusterGeoRepSession session : sessionsMap.values()) {
        GlusterVolumeEntity masterVolume = getVolume(cluster, session.getMasterVolumeName());
        if (masterVolume == null) {
            log.info("Could not find corresponding volume for geo-rep session '{}' and volume '{}' - status will not be updated.", session.getSessionKey(), session.getMasterVolumeName());
        } else {
            session.setMasterVolumeId(masterVolume.getId());
            // update consolidated status
            updateGeoRepStatus(masterVolume, session);
        }
        // check if session exists in database
        GlusterGeoRepSession sessionInDb = getGeoRepDao().getGeoRepSession(session.getSessionKey());
        if (sessionInDb == null) {
            // save the session in database first.
            log.debug("detected new geo-rep session '{}' for volume '{}'", session.getSessionKey(), session.getMasterVolumeName());
            if (Guid.isNullOrEmpty(session.getId())) {
                session.setId(Guid.newGuid());
            }
            getGeoRepDao().save(session);
            logGeoRepMessage(AuditLogType.GLUSTER_GEOREP_SESSION_DETECTED_FROM_CLI, cluster.getId(), session);
        } else {
            session.setId(sessionInDb.getId());
            getGeoRepDao().updateSession(session);
        }
        // update the session details object with session id.
        for (GlusterGeoRepSessionDetails sessDetails : session.getSessionDetails()) {
            sessDetails.setSessionId(session.getId());
        }
        getGeoRepDao().saveOrUpdateDetailsInBatch(session.getSessionDetails());
    }
}
#end_block

#method_before
private void updateGeoRepStatus(GlusterGeoRepSession session) {
    GlusterVolumeEntity volume = getVolumeDao().getById(session.getMasterVolumeId());
    List<HashMap<Guid, GeoRepSessionStatus>> list = new ArrayList<>();
    // grouped node status
    for (int i = 0; i < volume.getBricks().size(); i = i + volume.getReplicaCount()) {
        HashMap<Guid, GeoRepSessionStatus> nodeStatus = new HashMap<>();
        int j = 0;
        while (j < volume.getReplicaCount()) {
            Guid brickId = volume.getBricks().get(i + j).getId();
            nodeStatus.put(brickId, getStatusForBrickFromSession(session, brickId));
            j++;
        }
        list.add(nodeStatus);
    }
    session.setStatus(GeoRepSessionStatus.ACTIVE);
    // iterate through grouped status to set consolidated status
    for (HashMap<Guid, GeoRepSessionStatus> nodeStatusMap : list) {
        if (nodeStatusMap.containsValue(GeoRepSessionStatus.ACTIVE)) {
            // healthy
            continue;
        } else if (CollectionUtils.countMatches(nodeStatusMap.values(), PredicateUtils.equalPredicate(GeoRepSessionStatus.FAULTY)) > 0) {
            session.setStatus(GeoRepSessionStatus.FAULTY);
            continue;
        }
        // if not active or faulty - has to be in one of Initialising, Stopped, Not Started
        GeoRepSessionStatus nodeStatus = (GeoRepSessionStatus) nodeStatusMap.values().toArray()[0];
        if (CollectionUtils.countMatches(nodeStatusMap.values(), PredicateUtils.equalPredicate(nodeStatus)) == nodeStatusMap.size() && GeoRepSessionStatus.ACTIVE.equals(session.getStatus())) {
            session.setStatus(nodeStatus);
        }
    }
}
#method_after
private void updateGeoRepStatus(GlusterVolumeEntity volume, GlusterGeoRepSession session) {
    List<HashSet<GeoRepSessionStatus>> list = new ArrayList<>();
    // grouped node status
    int replicaCount = volume.getReplicaCount() == 0 ? 1 : volume.getReplicaCount();
    for (int i = 0; i < volume.getBricks().size(); i = i + replicaCount) {
        HashSet<GeoRepSessionStatus> subVolumeStatusSet = new HashSet<>();
        int j = 0;
        while (j < replicaCount) {
            Guid brickId = volume.getBricks().get(i + j).getId();
            subVolumeStatusSet.add(getStatusForBrickFromSession(session, brickId));
            j++;
        }
        list.add(subVolumeStatusSet);
    }
    session.setStatus(GeoRepSessionStatus.ACTIVE);
    // iterate through grouped status to set consolidated status
    for (HashSet<GeoRepSessionStatus> subVolumeStatusValues : list) {
        if (subVolumeStatusValues.contains(GeoRepSessionStatus.ACTIVE)) {
            // healthy
            continue;
        } else if (subVolumeStatusValues.contains(GeoRepSessionStatus.FAULTY)) {
            session.setStatus(GeoRepSessionStatus.FAULTY);
            // if any one of the sub-volume is faulty, the overall session status if faulty
            return;
        }
        // override status in case of these values
        if (ArrayUtils.contains(overridableStatuses, session.getStatus())) {
            if (subVolumeStatusValues.size() == 1) {
                session.setStatus((GeoRepSessionStatus) subVolumeStatusValues.toArray()[0]);
            } else {
                // if status values in sub-volume are not the same, what do we do?
                // this should not happen, so we'll log it for now
                log.info("Multiple status values found in volume '{}'", session.getMasterVolumeName());
            }
        }
    }
}
#end_block

#method_before
private GeoRepSessionStatus getStatusForBrickFromSession(GlusterGeoRepSession session, Guid masterBrickId) {
    for (GlusterGeoRepSessionDetails sessionDetail : session.getSessionDetails()) {
        if (sessionDetail.getMasterBrickId().equals(masterBrickId)) {
            return sessionDetail.getStatus();
        }
    }
    return GeoRepSessionStatus.UNKNOWN;
}
#method_after
private GeoRepSessionStatus getStatusForBrickFromSession(GlusterGeoRepSession session, Guid masterBrickId) {
    if (session.getSessionDetails() == null) {
        return null;
    }
    for (GlusterGeoRepSessionDetails sessionDetail : session.getSessionDetails()) {
        if (sessionDetail.getMasterBrickId().equals(masterBrickId)) {
            return sessionDetail.getStatus();
        }
    }
    return GeoRepSessionStatus.UNKNOWN;
}
#end_block

#method_before
private List<GlusterGeoRepSession> getSessionsForCluster(VDSGroup cluster) {
    VDS upServer = ClusterUtils.getInstance().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No up server found in cluster {0} for geo-rep monitoring", cluster.getName());
        return null;
    }
    // get details of geo-rep sessions in cluster
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeGeoRepStatus, new GlusterVolumeGeoRepSessionVDSParameters(upServer.getId(), null));
    if (returnValue.getSucceeded()) {
        List<GlusterGeoRepSession> sessions = (List<GlusterGeoRepSession>) returnValue.getReturnValue();
        return sessions;
    } else {
        log.error(returnValue.getVdsError());
        return null;
    }
}
#method_after
private Map<String, GlusterGeoRepSession> getSessionsForCluster(VDSGroup cluster) {
    VDS upServer = getClusterUtils().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debug("No UP server found in cluster '{}' for geo-rep monitoring", cluster.getName());
        return null;
    }
    // get details of geo-rep sessions in cluster
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeGeoRepStatus, new GlusterVolumeGeoRepSessionVDSParameters(upServer.getId(), null));
    if (returnValue.getSucceeded()) {
        List<GlusterGeoRepSession> sessions = (List<GlusterGeoRepSession>) returnValue.getReturnValue();
        HashMap<String, GlusterGeoRepSession> sessionsMap = new HashMap<>();
        if (sessions == null) {
            return sessionsMap;
        }
        for (GlusterGeoRepSession session : sessions) {
            sessionsMap.put(session.getSessionKey(), session);
        }
        return sessionsMap;
    } else {
        log.error("VDS error {}", returnValue.getVdsError().getMessage());
        log.debug("VDS error", returnValue.getVdsError());
        return null;
    }
}
#end_block

#method_before
public static void init() {
    if (!glusterModeSupported()) {
        log.debug("Gluster mode not supported. Will not schedule jobs for refreshing Gluster data.");
        return;
    }
    log.debug("Initializing Gluster Jobs Manager");
    SchedulerUtil scheduler = SchedulerUtilQuartzImpl.getInstance();
    scheduler.scheduleAFixedDelayJob(GlusterSyncJob.getInstance(), "refreshLightWeightData", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateLight), getRefreshRate(ConfigValues.GlusterRefreshRateLight), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterSyncJob.getInstance(), "refreshHeavyWeightData", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateHeavy), getRefreshRate(ConfigValues.GlusterRefreshRateHeavy), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterHookSyncJob.getInstance(), "refreshHooks", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateHooks), getRefreshRate(ConfigValues.GlusterRefreshRateHooks), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterServiceSyncJob.getInstance(), "refreshGlusterServices", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateLight), getRefreshRate(ConfigValues.GlusterRefreshRateLight), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterTasksSyncJob.getInstance(), "gluster_async_task_poll_event", new Class[0], new Class[0], getRefreshRate(ConfigValues.GlusterRefreshRateTasks), getRefreshRate(ConfigValues.GlusterRefreshRateTasks), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterGeoRepSyncJob.getInstance(), "gluster_georep_poll_event", new Class[0], new Class[0], getRefreshRate(ConfigValues.GlusterRefreshRateTasks), getRefreshRate(ConfigValues.GlusterRefreshRateTasks), TimeUnit.SECONDS);
}
#method_after
public static void init() {
    if (!glusterModeSupported()) {
        log.debug("Gluster mode not supported. Will not schedule jobs for refreshing Gluster data.");
        return;
    }
    log.debug("Initializing Gluster Jobs Manager");
    SchedulerUtil scheduler = SchedulerUtilQuartzImpl.getInstance();
    scheduler.scheduleAFixedDelayJob(GlusterSyncJob.getInstance(), "refreshLightWeightData", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateLight), getRefreshRate(ConfigValues.GlusterRefreshRateLight), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterSyncJob.getInstance(), "refreshHeavyWeightData", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateHeavy), getRefreshRate(ConfigValues.GlusterRefreshRateHeavy), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterHookSyncJob.getInstance(), "refreshHooks", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateHooks), getRefreshRate(ConfigValues.GlusterRefreshRateHooks), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterServiceSyncJob.getInstance(), "refreshGlusterServices", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateLight), getRefreshRate(ConfigValues.GlusterRefreshRateLight), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterTasksSyncJob.getInstance(), "gluster_async_task_poll_event", new Class[0], new Class[0], getRefreshRate(ConfigValues.GlusterRefreshRateTasks), getRefreshRate(ConfigValues.GlusterRefreshRateTasks), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterGeoRepSyncJob.getInstance(), "gluster_georep_poll_event", new Class[0], new Class[0], getRefreshRate(ConfigValues.GlusterRefreshRateGeoRepDiscovery), getRefreshRate(ConfigValues.GlusterRefreshRateGeoRepDiscovery), TimeUnit.SECONDS);
}
#end_block

#method_before
@Override
public void updateSession(GlusterGeoRepSession geoRepSession) {
    getCallsHandler().executeModification("UpdateGlusterGeoRepSessionStatus", createIdParameterMapper(geoRepSession.getId()).addValue("status", geoRepSession.getStatus()));
}
#method_after
@Override
public void updateSession(GlusterGeoRepSession geoRepSession) {
    getCallsHandler().executeModification("UpdateGlusterGeoRepSessionStatus", createIdParameterMapper(geoRepSession.getId()).addValue("status", EnumUtils.nameOrNull(geoRepSession.getStatus())));
}
#end_block

#method_before
@Override
public void saveDetailsInBatch(List<GlusterGeoRepSessionDetails> geoRepSessionDetailsObjs) {
    getCallsHandler().executeStoredProcAsBatch("InsertGlusterGeoRepSessionDetail", geoRepSessionDetailsObjs, getDetailsBatchMapper());
}
#method_after
@Override
public void saveDetailsInBatch(List<GlusterGeoRepSessionDetails> geoRepSessionDetailsList) {
    getCallsHandler().executeStoredProcAsBatch("InsertGlusterGeoRepSessionDetail", geoRepSessionDetailsList, getDetailsBatchMapper());
}
#end_block

#method_before
public void getGlusterVolumeGeoRepStatusForMasterVolume(AsyncQuery aQuery, Guid masterVolumeId, Guid masterVolumeClusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery asyncQuery) {
            return source != null ? source : new ArrayList<GlusterGeoRepSession>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeGeoRepSessions, new IdQueryParameters(masterVolumeId), aQuery);
}
#method_after
public void getGlusterVolumeGeoRepStatusForMasterVolume(AsyncQuery aQuery, Guid masterVolumeId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery asyncQuery) {
            return source != null ? source : new ArrayList<GlusterGeoRepSession>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeGeoRepSessions, new IdQueryParameters(masterVolumeId), aQuery);
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    GlusterVolumeEntity selectedVolume = (GlusterVolumeEntity) provideDetailModelEntity(getSelectedItem());
    getBrickListModel().setVolumeEntity(selectedVolume);
    getGeoRepListModel().setVolumeEntity(selectedVolume);
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    GlusterVolumeEntity selectedVolume = (GlusterVolumeEntity) provideDetailModelEntity(getSelectedItem());
    getBrickListModel().setVolumeEntity(selectedVolume);
    getGeoRepListModel().setEntity(selectedVolume);
}
#end_block

#method_before
private void onCreateVolume() {
    VolumeModel volumeModel = (VolumeModel) getWindow();
    if (!volumeModel.validate()) {
        return;
    }
    Guid clusterId = ((VDSGroup) volumeModel.getCluster().getSelectedItem()).getId();
    final GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setName((String) volumeModel.getName().getEntity());
    GlusterVolumeType type = (GlusterVolumeType) volumeModel.getTypeList().getSelectedItem();
    if (type.isStripedType()) {
        volume.setStripeCount(volumeModel.getStripeCountValue());
    }
    if (type.isReplicatedType()) {
        volume.setReplicaCount(volumeModel.getReplicaCountValue());
    }
    volume.setVolumeType(type);
    if ((Boolean) volumeModel.getTcpTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.TCP);
    }
    if ((Boolean) volumeModel.getRdmaTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.RDMA);
    }
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object model : volumeModel.getBricks().getItems()) {
        brickList.add((GlusterBrickEntity) ((EntityModel) model).getEntity());
    }
    volume.setBricks(brickList);
    if ((Boolean) volumeModel.getNfs_accecssProtocol().getEntity()) {
        volume.enableNFS();
    } else {
        volume.disableNFS();
    }
    if ((Boolean) volumeModel.getCifs_accecssProtocol().getEntity()) {
        volume.enableCifs();
    } else {
        volume.disableCifs();
    }
    volume.setAccessControlList((String) volumeModel.getAllowAccess().getEntity());
    volumeModel.startProgress(null);
    CreateGlusterVolumeParameters parameter = new CreateGlusterVolumeParameters(volume, volumeModel.isForceAddBricks());
    Frontend.getInstance().runAction(VdcActionType.CreateGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VolumeListModel localModel = (VolumeListModel) result.getState();
            localModel.postOnCreateVolume(result.getReturnValue(), volume);
        }
    }, this);
}
#method_after
private void onCreateVolume() {
    VolumeModel volumeModel = (VolumeModel) getWindow();
    if (!volumeModel.validate()) {
        return;
    }
    Guid clusterId = volumeModel.getCluster().getSelectedItem().getId();
    final GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setName(volumeModel.getName().getEntity());
    GlusterVolumeType type = volumeModel.getTypeList().getSelectedItem();
    if (type.isStripedType()) {
        volume.setStripeCount(volumeModel.getStripeCountValue());
    }
    if (type.isReplicatedType()) {
        volume.setReplicaCount(volumeModel.getReplicaCountValue());
    }
    volume.setVolumeType(type);
    if (volumeModel.getTcpTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.TCP);
    }
    if (volumeModel.getRdmaTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.RDMA);
    }
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object model : volumeModel.getBricks().getItems()) {
        brickList.add((GlusterBrickEntity) ((EntityModel) model).getEntity());
    }
    volume.setBricks(brickList);
    if (volumeModel.getNfs_accecssProtocol().getEntity()) {
        volume.enableNFS();
    } else {
        volume.disableNFS();
    }
    if (volumeModel.getCifs_accecssProtocol().getEntity()) {
        volume.enableCifs();
    } else {
        volume.disableCifs();
    }
    volume.setAccessControlList(volumeModel.getAllowAccess().getEntity());
    volumeModel.startProgress(null);
    CreateGlusterVolumeParameters parameter = new CreateGlusterVolumeParameters(volume, volumeModel.isForceAddBricks());
    Frontend.getInstance().runAction(VdcActionType.CreateGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VolumeListModel localModel = (VolumeListModel) result.getState();
            localModel.postOnCreateVolume(result.getReturnValue(), volume);
        }
    }, this);
}
#end_block

#method_before
public void postOnCreateVolume(VdcReturnValueBase returnValue, GlusterVolumeEntity volume) {
    VolumeModel model = (VolumeModel) getWindow();
    model.stopProgress();
    if (returnValue != null && returnValue.getSucceeded()) {
        cancel();
        if ((Boolean) model.getOptimizeForVirtStore().getEntity()) {
            optimizeVolumesForVirtStore(Arrays.asList(volume));
        }
    }
}
#method_after
public void postOnCreateVolume(VdcReturnValueBase returnValue, GlusterVolumeEntity volume) {
    VolumeModel model = (VolumeModel) getWindow();
    model.stopProgress();
    if (returnValue != null && returnValue.getSucceeded()) {
        cancel();
        if (model.getOptimizeForVirtStore().getEntity()) {
            optimizeVolumesForVirtStore(Arrays.asList(volume));
        }
    }
}
#end_block

#method_before
@Override
protected void selectedItemsChanged() {
    super.selectedItemsChanged();
    updateActionAvailability((GlusterVolumeEntity) getEntity());
}
#method_after
@Override
protected void selectedItemsChanged() {
    super.selectedItemsChanged();
    updateActionAvailability(getEntity());
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() != null) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) getEntity();
        AsyncDataProvider.getInstance().getGlusterVolumeGeoRepStatusForMasterVolume(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<GlusterGeoRepSession> geoRepSessions = (ArrayList<GlusterGeoRepSession>) returnValue;
                if (getItems() == geoRepSessions) {
                    getItemsChangedEvent().raise(this, EventArgs.EMPTY);
                } else {
                    Collections.sort(geoRepSessions, new Linq.GlusterVolumeGeoRepSessionComparer());
                    setItems(geoRepSessions);
                }
            }
        }), volume.getId(), volume.getClusterId());
    } else {
        setItems(null);
    }
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    AsyncDataProvider.getInstance().getGlusterVolumeGeoRepStatusForMasterVolume(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<GlusterGeoRepSession> geoRepSessions = (ArrayList<GlusterGeoRepSession>) returnValue;
            Collections.sort(geoRepSessions, new Linq.GlusterVolumeGeoRepSessionComparer());
            setItems(geoRepSessions);
        }
    }), getEntity().getId());
}
#end_block

#method_before
private void updateActionAvailability(GlusterVolumeEntity volumeEntity) {
    if (volumeEntity == null) {
        return;
    }
    boolean isNewSessionAvailable = true;
    boolean isRemoveSessionCommandAvailable = false;
    boolean isStartSessionCommandAvailable = false;
    boolean isStopSessionCommandAvailable = false;
    boolean sessionOptionsCommandAvailable = true;
    boolean isViewSessionDetailsCommandAvailable = false;
    if (getSelectedItems() != null) {
        isStopSessionCommandAvailable = true;
        isViewSessionDetailsCommandAvailable = true;
        isStartSessionCommandAvailable = true;
        isRemoveSessionCommandAvailable = true;
    }
    getNewSessionCommand().setIsAvailable(isNewSessionAvailable);
    getRemoveSessionCommand().setIsAvailable(isRemoveSessionCommandAvailable);
    getStartSessionCommand().setIsAvailable(isStartSessionCommandAvailable);
    getStopSessionCommand().setIsAvailable(isStopSessionCommandAvailable);
    getSessionOptionsCommand().setIsAvailable(sessionOptionsCommandAvailable);
    getViewSessionDetailsCommand().setIsAvailable(isViewSessionDetailsCommandAvailable);
}
#method_after
private void updateActionAvailability(GlusterVolumeEntity volumeEntity) {
    if (volumeEntity == null) {
        return;
    }
    getNewSessionCommand().setIsAvailable(true);
    getRemoveSessionCommand().setIsAvailable(false);
    getStartSessionCommand().setIsAvailable(false);
    getStopSessionCommand().setIsAvailable(false);
    getSessionOptionsCommand().setIsAvailable(false);
    getViewSessionDetailsCommand().setIsAvailable(false);
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    getTable().addColumn(new TextColumnWithTooltip<GlusterGeoRepSession>() {

        @Override
        public String getValue(GlusterGeoRepSession object) {
            return object.getSlaveHostName();
        }
    }, constants.volumeSubTabGeoRepSlaveClusterHostColumn());
    getTable().addColumn(new TextColumnWithTooltip<GlusterGeoRepSession>() {

        @Override
        public String getValue(GlusterGeoRepSession object) {
            return object.getSlaveVolumeName();
        }
    }, constants.volumeSubTabGeoRepSlaveVolumeColumn());
    getTable().addColumn(new TextColumnWithTooltip<GlusterGeoRepSession>() {

        @Override
        public String getValue(GlusterGeoRepSession object) {
            return object.getStatus().toString();
        }
    }, constants.volumeSubTabGeoRepStatusColumn());
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterGeoRepSession>(constants.newGeoRepSession()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewSessionCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterGeoRepSession>(constants.removeGeoRepSession()) {

        @Override
        protected UICommand resolveCommand() {
            return null;
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterGeoRepSession>(constants.startGeoRepSession()) {

        @Override
        protected UICommand resolveCommand() {
            return null;
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterGeoRepSession>(constants.stopGeoRepSession()) {

        @Override
        protected UICommand resolveCommand() {
            return null;
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterGeoRepSession>(constants.geoRepSessionsOptions()) {

        @Override
        protected UICommand resolveCommand() {
            return null;
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterGeoRepSession>(constants.geoRepSessionDetails()) {

        @Override
        protected UICommand resolveCommand() {
            return null;
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    getTable().addColumn(new TextColumnWithTooltip<GlusterGeoRepSession>() {

        @Override
        public String getValue(GlusterGeoRepSession object) {
            return object.getSlaveHostName();
        }
    }, constants.volumeSubTabGeoRepSlaveClusterHostColumn(), // $NON-NLS-1$
    "220px");
    getTable().addColumn(new TextColumnWithTooltip<GlusterGeoRepSession>() {

        @Override
        public String getValue(GlusterGeoRepSession object) {
            return object.getSlaveVolumeName();
        }
    }, constants.volumeSubTabGeoRepSlaveVolumeColumn(), // $NON-NLS-1$
    "220px");
    getTable().addColumn(new TextColumnWithTooltip<GlusterGeoRepSession>() {

        @Override
        public String getValue(GlusterGeoRepSession object) {
            return object.getStatus().toString();
        }
    }, constants.volumeSubTabGeoRepStatusColumn(), // $NON-NLS-1$
    "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterGeoRepSession>(constants.newGeoRepSession()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewSessionCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterGeoRepSession>(constants.removeGeoRepSession()) {

        @Override
        protected UICommand resolveCommand() {
            return null;
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterGeoRepSession>(constants.startGeoRepSession()) {

        @Override
        protected UICommand resolveCommand() {
            return null;
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterGeoRepSession>(constants.stopGeoRepSession()) {

        @Override
        protected UICommand resolveCommand() {
            return null;
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterGeoRepSession>(constants.geoRepSessionsOptions()) {

        @Override
        protected UICommand resolveCommand() {
            return null;
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterGeoRepSession>(constants.geoRepSessionDetails()) {

        @Override
        protected UICommand resolveCommand() {
            return null;
        }
    });
}
#end_block

#method_before
@Test
public void testGetThemeStyleSheet() {
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "User portal style sheet: 'user_portal.css'", // $NON-NLS-1$ //$NON-NLS-2$
    "user_portal.css", testTheme.getThemeStylesheets("userportal").get(0));
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "User portal style sheet: 'user_portal.css'", // $NON-NLS-1$ //$NON-NLS-2$
    "abc.css", testTheme.getThemeStylesheets("userportal").get(1));
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Wedadmin style sheet: 'web_admin.css'", // $NON-NLS-1$ //$NON-NLS-2$
    "web_admin.css", testTheme.getThemeStylesheets("webadmin").get(0));
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Wedadmin style sheet: 'web_admin.css'", // $NON-NLS-1$ //$NON-NLS-2$
    "123.css", testTheme.getThemeStylesheets("webadmin").get(1));
}
#method_after
@Test
public void testGetThemeStyleSheet() {
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "User portal style sheet: 'user_portal.css'", // $NON-NLS-1$ //$NON-NLS-2$
    "user_portal.css", testTheme.getThemeStylesheets("userportal").get(0));
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "User portal style sheet: 'abc.css'", // $NON-NLS-1$ //$NON-NLS-2$
    "abc.css", testTheme.getThemeStylesheets("userportal").get(1));
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Wedadmin style sheet: 'web_admin.css'", // $NON-NLS-1$ //$NON-NLS-2$
    "web_admin.css", testTheme.getThemeStylesheets("webadmin").get(0));
    assertEquals(// $NON-NLS-1$ //$NON-NLS-2$
    "Wedadmin style sheet: '123.css'", // $NON-NLS-1$ //$NON-NLS-2$
    "123.css", testTheme.getThemeStylesheets("webadmin").get(1));
}
#end_block

#method_before
private void handleMultipleConcurrentAgents(VDSStatus lastStatus, VDSReturnValue vdsReturnValue) {
    primaryExecutor = createFenceExecutor(getParameters().getAction());
    secondaryExecutor = createFenceExecutor(getParameters().getAction());
    if (primaryExecutor.findProxyHost() && secondaryExecutor.findProxyHost()) {
        primaryResult = new FenceInvocationResult();
        secondaryResult = new FenceInvocationResult();
        List<Callable<FenceInvocationResult>> tasks = new ArrayList<Callable<FenceInvocationResult>>();
        Future<FenceInvocationResult> f1 = null;
        Future<FenceInvocationResult> f2 = null;
        tasks.add(new Callable<FenceInvocationResult>() {

            @Override
            public FenceInvocationResult call() {
                return run(primaryExecutor, FenceAgentOrder.Primary);
            }
        });
        tasks.add(new Callable<FenceInvocationResult>() {

            @Override
            public FenceInvocationResult call() {
                return run(secondaryExecutor, FenceAgentOrder.Secondary);
            }
        });
        try {
            ExecutorCompletionService<FenceInvocationResult> ecs = ThreadPoolUtil.createCompletionService(tasks);
            switch(getParameters().getAction()) {
                case Start:
                    try {
                        f1 = ecs.take();
                        setResult(f1);
                        if (primaryResult.isSucceeded() || secondaryResult.isSucceeded()) {
                            handleSpecificCommandActions();
                            setFenceSucceeded(true);
                        } else {
                            tryOtherConcurrentAgent(lastStatus, ecs);
                        }
                    } catch (InterruptedException | ExecutionException e) {
                        tryOtherConcurrentAgent(lastStatus, ecs);
                    }
                    break;
                case Stop:
                    f1 = ecs.take();
                    f2 = ecs.take();
                    if (f1.get().getOrder() == FenceAgentOrder.Primary) {
                        primaryResult = f1.get();
                        secondaryResult = f2.get();
                    } else {
                        primaryResult = f2.get();
                        secondaryResult = f1.get();
                    }
                    if (primaryResult.isSucceeded() && secondaryResult.isSucceeded()) {
                        boolean primarySkipped = wasSkippedDueToPolicy(primaryResult.getValue());
                        boolean secondarySkipped = wasSkippedDueToPolicy(secondaryResult.getValue());
                        if (primarySkipped && secondarySkipped) {
                            // fencing execution was skipped due to fencing policy
                            handleFencingSkippedDueToPolicy(vdsReturnValue);
                            return;
                        } else if (primarySkipped || secondarySkipped) {
                            // fence execution on one agents was skipped and on the other executed
                            handleError(lastStatus, primarySkipped ? primaryResult.getValue() : secondaryResult.getValue(), primarySkipped ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
                        } else {
                            handleSpecificCommandActions();
                            setFenceSucceeded(true);
                        }
                    } else {
                        handleError(lastStatus, !primaryResult.isSucceeded() ? primaryResult.getValue() : secondaryResult.getValue(), !primaryResult.isSucceeded() ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
                    }
                    break;
                default:
                    setFenceSucceeded(true);
                    break;
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error(e);
        }
    } else {
        setFenceSucceeded(false);
        vdsReturnValue.setSucceeded(false);
    }
}
#method_after
private void handleMultipleConcurrentAgents(VDSStatus lastStatus, VDSReturnValue vdsReturnValue) {
    primaryExecutor = createFenceExecutor(getParameters().getAction());
    secondaryExecutor = createFenceExecutor(getParameters().getAction());
    if (primaryExecutor.findProxyHost() && secondaryExecutor.findProxyHost()) {
        primaryResult = new FenceInvocationResult();
        secondaryResult = new FenceInvocationResult();
        List<Callable<FenceInvocationResult>> tasks = new ArrayList<Callable<FenceInvocationResult>>();
        Future<FenceInvocationResult> f1 = null;
        Future<FenceInvocationResult> f2 = null;
        tasks.add(new Callable<FenceInvocationResult>() {

            @Override
            public FenceInvocationResult call() {
                return run(primaryExecutor, FenceAgentOrder.Primary);
            }
        });
        tasks.add(new Callable<FenceInvocationResult>() {

            @Override
            public FenceInvocationResult call() {
                return run(secondaryExecutor, FenceAgentOrder.Secondary);
            }
        });
        try {
            ExecutorCompletionService<FenceInvocationResult> ecs = ThreadPoolUtil.createCompletionService(tasks);
            switch(getParameters().getAction()) {
                case Start:
                    try {
                        f1 = ecs.take();
                        setResult(f1);
                        if (primaryResult.isSucceeded() || secondaryResult.isSucceeded()) {
                            handleSpecificCommandActions();
                            setFenceSucceeded(true);
                        } else {
                            tryOtherConcurrentAgent(lastStatus, ecs);
                        }
                    } catch (InterruptedException | ExecutionException e) {
                        tryOtherConcurrentAgent(lastStatus, ecs);
                    }
                    break;
                case Stop:
                    f1 = ecs.take();
                    f2 = ecs.take();
                    if (f1.get().getOrder() == FenceAgentOrder.Primary) {
                        primaryResult = f1.get();
                        secondaryResult = f2.get();
                    } else {
                        primaryResult = f2.get();
                        secondaryResult = f1.get();
                    }
                    if (primaryResult.isSucceeded() && secondaryResult.isSucceeded()) {
                        boolean primarySkipped = wasSkippedDueToPolicy(primaryResult.getValue());
                        boolean secondarySkipped = wasSkippedDueToPolicy(secondaryResult.getValue());
                        if (primarySkipped && secondarySkipped) {
                            // fencing execution was skipped due to fencing policy
                            handleFencingSkippedDueToPolicy(vdsReturnValue);
                            return;
                        } else if (primarySkipped || secondarySkipped) {
                            // fence execution on one agents was skipped and on the other executed
                            handleError(lastStatus, primarySkipped ? primaryResult.getValue() : secondaryResult.getValue(), primarySkipped ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
                        } else {
                            handleSpecificCommandActions();
                            setFenceSucceeded(true);
                        }
                    } else {
                        handleError(lastStatus, !primaryResult.isSucceeded() ? primaryResult.getValue() : secondaryResult.getValue(), !primaryResult.isSucceeded() ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
                    }
                    break;
                default:
                    setFenceSucceeded(true);
                    break;
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("Exception", e);
        }
    } else {
        setFenceSucceeded(false);
        vdsReturnValue.setSucceeded(false);
    }
}
#end_block

#method_before
private void handleError(VDSStatus lastStatus, final VDSReturnValue vdsReturnValue, FenceAgentOrder order) {
    if (!((FenceStatusReturnValue) (vdsReturnValue.getReturnValue())).getIsSkipped()) {
        // Since this is a non-transactive command , restore last status
        setSucceeded(false);
        log.errorFormat("Failed to {0} VDS using {1} Power Management agent", getParameters().getAction().name().toLowerCase(), order.name());
        AlertIfPowerManagementOperationSkipped(getParameters().getAction().name(), vdsReturnValue.getExceptionObject());
        throw new VdcBLLException(VdcBllErrors.VDS_FENCE_OPERATION_FAILED);
    } else {
        // Fence operation was skipped because Host is already in the requested state.
        setStatus(lastStatus);
    }
}
#method_after
private void handleError(VDSStatus lastStatus, final VDSReturnValue vdsReturnValue, FenceAgentOrder order) {
    if (!((FenceStatusReturnValue) (vdsReturnValue.getReturnValue())).getIsSkipped()) {
        // Since this is a non-transactive command , restore last status
        setSucceeded(false);
        log.error("Failed to {} VDS using {} Power Management agent", getParameters().getAction().name().toLowerCase(), order.name());
        AlertIfPowerManagementOperationSkipped(getParameters().getAction().name(), vdsReturnValue.getExceptionObject());
        throw new VdcBLLException(VdcBllErrors.VDS_FENCE_OPERATION_FAILED);
    } else {
        // Fence operation was skipped because Host is already in the requested state.
        setStatus(lastStatus);
    }
}
#end_block

#method_before
protected boolean waitForStatus(String vdsName, FenceActionType actionType, FenceAgentOrder order) {
    final String FENCE_CMD = (actionType == FenceActionType.Start) ? "on" : "off";
    final String ACTION_NAME = actionType.name().toLowerCase();
    final int UNKNOWN_RESULT_ALLOWED = 3;
    int i = 1;
    int j = 1;
    boolean statusReached = false;
    log.infoFormat("Waiting for vds {0} to {1}", vdsName, ACTION_NAME);
    // Waiting before first attempt to check the host status.
    // This is done because if we will attempt to get host status immediately
    // in most cases it will not turn from on/off to off/on and we will need
    // to wait a full cycle for it.
    ThreadUtils.sleep(getSleep(actionType, order));
    // a potential preferred proxy host has connectivity problems and can not access the fenced host PM card
    if (executor.findProxyHost()) {
        while (!statusReached && i <= getRerties()) {
            log.infoFormat("Attempt {0} to get vds {1} status", i, vdsName);
            VDSReturnValue returnValue = executor.fence(order);
            if (returnValue != null && returnValue.getReturnValue() != null) {
                FenceStatusReturnValue value = (FenceStatusReturnValue) returnValue.getReturnValue();
                if (value.getStatus().equalsIgnoreCase("unknown")) {
                    // Allow command to fail temporarily
                    if (j <= UNKNOWN_RESULT_ALLOWED && i <= getRerties()) {
                        ThreadUtils.sleep(getDelayInSeconds() * 1000);
                        i++;
                        j++;
                    } else {
                        // No need to retry , agent definitions are corrupted
                        log.warnFormat("Host {0} {1} PM Agent definitions are corrupted, Waiting for Host to {2} aborted.", vdsName, order.name(), actionType.name());
                        break;
                    }
                } else {
                    if (FENCE_CMD.equalsIgnoreCase(value.getStatus())) {
                        statusReached = true;
                        log.infoFormat("vds {0} status is {1}", vdsName, FENCE_CMD);
                    } else {
                        i++;
                        if (i <= getRerties())
                            ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    }
                }
            } else {
                log.errorFormat("Failed to get host {0} status.", vdsName);
                break;
            }
        }
    }
    if (!statusReached) {
        // Send an Alert
        String actionName = (getParameters().getParentCommand() == VdcActionType.RestartVds) ? FenceActionType.Restart.name() : ACTION_NAME;
        AuditLogableBase auditLogable = new AuditLogableBase();
        auditLogable.addCustomValue("Host", vdsName);
        auditLogable.addCustomValue("Status", actionName);
        auditLogable.setVdsId(getVds().getId());
        AuditLogDirector.log(auditLogable, AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED);
        log.errorFormat("Failed to verify host {0} {1} status. Have retried {2} times with delay of {3} seconds between each retry.", vdsName, ACTION_NAME, getRerties(), getDelayInSeconds());
    }
    return statusReached;
}
#method_after
protected boolean waitForStatus(String vdsName, FenceActionType actionType, FenceAgentOrder order) {
    final String FENCE_CMD = (actionType == FenceActionType.Start) ? "on" : "off";
    final String ACTION_NAME = actionType.name().toLowerCase();
    final int UNKNOWN_RESULT_ALLOWED = 3;
    int i = 1;
    int j = 1;
    boolean statusReached = false;
    log.info("Waiting for vds '{}' to {}", vdsName, ACTION_NAME);
    // Waiting before first attempt to check the host status.
    // This is done because if we will attempt to get host status immediately
    // in most cases it will not turn from on/off to off/on and we will need
    // to wait a full cycle for it.
    ThreadUtils.sleep(getSleep(actionType, order));
    // a potential preferred proxy host has connectivity problems and can not access the fenced host PM card
    if (executor.findProxyHost()) {
        while (!statusReached && i <= getRerties()) {
            log.info("Attempt {} to get vds '{}' status", i, vdsName);
            VDSReturnValue returnValue = executor.fence(order);
            if (returnValue != null && returnValue.getReturnValue() != null) {
                FenceStatusReturnValue value = (FenceStatusReturnValue) returnValue.getReturnValue();
                if (value.getStatus().equalsIgnoreCase("unknown")) {
                    // Allow command to fail temporarily
                    if (j <= UNKNOWN_RESULT_ALLOWED && i <= getRerties()) {
                        ThreadUtils.sleep(getDelayInSeconds() * 1000);
                        i++;
                        j++;
                    } else {
                        // No need to retry , agent definitions are corrupted
                        log.warn("Host '{}' {} PM Agent definitions are corrupted, Waiting for Host to" + " {} aborted.", vdsName, order.name(), actionType.name());
                        break;
                    }
                } else {
                    if (FENCE_CMD.equalsIgnoreCase(value.getStatus())) {
                        statusReached = true;
                        log.info("Vds '{}' status is {}", vdsName, FENCE_CMD);
                    } else {
                        i++;
                        if (i <= getRerties())
                            ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    }
                }
            } else {
                log.error("Failed to get host '{}' status.", vdsName);
                break;
            }
        }
    }
    if (!statusReached) {
        // Send an Alert
        String actionName = (getParameters().getParentCommand() == VdcActionType.RestartVds) ? FenceActionType.Restart.name() : ACTION_NAME;
        AuditLogableBase auditLogable = new AuditLogableBase();
        auditLogable.addCustomValue("Host", vdsName);
        auditLogable.addCustomValue("Status", actionName);
        auditLogable.setVdsId(getVds().getId());
        AuditLogDirector.log(auditLogable, AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED);
        log.error("Failed to verify host '{}' {} status. Have retried {} times with delay of {} seconds" + " between each retry.", vdsName, ACTION_NAME, getRerties(), getDelayInSeconds());
    }
    return statusReached;
}
#end_block

#method_before
private int getSleep(FenceActionType actionType, FenceAgentOrder order) {
    if (actionType != FenceActionType.Stop) {
        return SLEEP_BEFORE_FIRST_ATTEMPT;
    }
    boolean isPPC = (getVdsGroup().getArchitecture() == ArchitectureType.ppc64);
    // We have to find out if power off delay was used and add this to the wait time
    // since otherwise the command will return immediately with 'off' status and
    // subsequent 'on' command issued during this delay will be overridden by the actual shutdown
    String agent = (order == FenceAgentOrder.Primary) ? getVds().getPmType() : getVds().getPmSecondaryType();
    String options = (order == FenceAgentOrder.Primary) ? getVds().getPmOptions() : getVds().getPmSecondaryOptions();
    options = VdsFenceOptions.getDefaultAgentOptions(agent, options, isPPC);
    HashMap<String, String> optionsMap = VdsStatic.pmOptionsStringToMap(options);
    String powerWaitParamSettings = FenceConfigHelper.getFenceConfigurationValue(ConfigValues.FencePowerWaitParam.name(), ConfigCommon.defaultConfigurationVersion);
    String powerWaitParam = VdsFenceOptions.getAgentPowerWaitParam(agent, powerWaitParamSettings);
    if (powerWaitParam == null) {
        // no power wait for this agent
        return SLEEP_BEFORE_FIRST_ATTEMPT;
    }
    if (optionsMap.containsKey(powerWaitParam)) {
        try {
            Integer powerWaitValueInSec = Integer.parseInt(optionsMap.get(powerWaitParam));
            return SLEEP_BEFORE_FIRST_ATTEMPT + (int) TimeUnit.SECONDS.toMillis(powerWaitValueInSec);
        } catch (NumberFormatException nfe) {
            // illegal value
            return SLEEP_BEFORE_FIRST_ATTEMPT;
        }
    }
    return SLEEP_BEFORE_FIRST_ATTEMPT;
}
#method_after
private int getSleep(FenceActionType actionType, FenceAgentOrder order) {
    if (actionType != FenceActionType.Stop) {
        return SLEEP_BEFORE_FIRST_ATTEMPT;
    }
    // We have to find out if power off delay was used and add this to the wait time
    // since otherwise the command will return immediately with 'off' status and
    // subsequent 'on' command issued during this delay will be overridden by the actual shutdown
    String agent = (order == FenceAgentOrder.Primary) ? getVds().getPmType() : getVds().getPmSecondaryType();
    String options = (order == FenceAgentOrder.Primary) ? getVds().getPmOptions() : getVds().getPmSecondaryOptions();
    ArchitectureType architectureType = (getVds().getCpuName() != null) ? getVds().getCpuName().getArchitecture() : null;
    options = VdsFenceOptions.getDefaultAgentOptions(agent, options, architectureType);
    HashMap<String, String> optionsMap = VdsStatic.pmOptionsStringToMap(options);
    String powerWaitParamSettings = FenceConfigHelper.getFenceConfigurationValue(ConfigValues.FencePowerWaitParam.name(), ConfigCommon.defaultConfigurationVersion);
    String powerWaitParam = VdsFenceOptions.getAgentPowerWaitParam(agent, powerWaitParamSettings);
    if (powerWaitParam == null) {
        // no power wait for this agent
        return SLEEP_BEFORE_FIRST_ATTEMPT;
    }
    if (optionsMap.containsKey(powerWaitParam)) {
        try {
            Integer powerWaitValueInSec = Integer.parseInt(optionsMap.get(powerWaitParam));
            return SLEEP_BEFORE_FIRST_ATTEMPT + (int) TimeUnit.SECONDS.toMillis(powerWaitValueInSec);
        } catch (NumberFormatException nfe) {
            // illegal value
            return SLEEP_BEFORE_FIRST_ATTEMPT;
        }
    }
    return SLEEP_BEFORE_FIRST_ATTEMPT;
}
#end_block

#method_before
private void CacheFencingAgentsOptionMapping() {
    String localFencingOptionMapping = FenceConfigHelper.getFenceConfigurationValue(ConfigValues.VdsFenceOptionMapping.name(), version);
    String[] agentsOptionsStr = localFencingOptionMapping.split(Pattern.quote(SEMICOLON), -1);
    for (String agentOptionsStr : agentsOptionsStr) {
        String[] parts = agentOptionsStr.split(Pattern.quote(COLON), -1);
        if (parts.length == 2) {
            String agent = parts[0];
            HashMap<String, String> agentOptions = new HashMap<String, String>();
            // check for empty options
            if (StringUtils.isNotEmpty(parts[1])) {
                String[] options = parts[1].split(Pattern.quote(COMMA), -1);
                for (String option : options) {
                    String[] optionKeyVal = option.split(Pattern.quote(EQUAL), -1);
                    agentOptions.put(optionKeyVal[0], optionKeyVal[1]);
                    // add mapped keys to special params
                    fencingSpecialParams.add(optionKeyVal[1]);
                }
            }
            fencingOptionMapping.put(agent, agentOptions);
        } else {
            log.errorFormat(MAPPING_FORMAT_ERROR, agentOptionsStr);
            break;
        }
    }
}
#method_after
private void CacheFencingAgentsOptionMapping() {
    String localFencingOptionMapping = FenceConfigHelper.getFenceConfigurationValue(ConfigValues.VdsFenceOptionMapping.name(), version);
    String[] agentsOptionsStr = localFencingOptionMapping.split(Pattern.quote(SEMICOLON), -1);
    for (String agentOptionsStr : agentsOptionsStr) {
        String[] parts = agentOptionsStr.split(Pattern.quote(COLON), -1);
        if (parts.length == 2) {
            String agent = parts[0];
            HashMap<String, String> agentOptions = new HashMap<String, String>();
            // check for empty options
            if (StringUtils.isNotEmpty(parts[1])) {
                String[] options = parts[1].split(Pattern.quote(COMMA), -1);
                for (String option : options) {
                    String[] optionKeyVal = option.split(Pattern.quote(EQUAL), -1);
                    agentOptions.put(optionKeyVal[0], optionKeyVal[1]);
                    // add mapped keys to special params
                    fencingSpecialParams.add(optionKeyVal[1]);
                }
            }
            fencingOptionMapping.put(agent, agentOptions);
        } else {
            log.error(MAPPING_FORMAT_ERROR, agentOptionsStr);
            break;
        }
    }
}
#end_block

#method_before
private String GetRealKey(String agent, String displayedKey) {
    String result = "";
    if (StringUtils.isNotEmpty(agent) && StringUtils.isNotEmpty(displayedKey)) {
        if (fencingOptionMapping.containsKey(agent)) {
            HashMap<String, String> agentOptions = fencingOptionMapping.get(agent);
            result = agentOptions.containsKey(displayedKey) ? agentOptions.get(displayedKey) : displayedKey;
        } else {
            log.errorFormat(AGENT_ERROR, agent);
        }
    }
    return result;
}
#method_after
private String GetRealKey(String agent, String displayedKey) {
    String result = "";
    if (StringUtils.isNotEmpty(agent) && StringUtils.isNotEmpty(displayedKey)) {
        if (fencingOptionMapping.containsKey(agent)) {
            HashMap<String, String> agentOptions = fencingOptionMapping.get(agent);
            result = agentOptions.containsKey(displayedKey) ? agentOptions.get(displayedKey) : displayedKey;
        } else {
            log.error(AGENT_ERROR, agent);
        }
    }
    return result;
}
#end_block

#method_before
private String GetDisplayedKey(String agent, String realKey) {
    String result = "";
    if (StringUtils.isNotEmpty(agent) && StringUtils.isNotEmpty(realKey)) {
        if (fencingOptionMapping.containsKey(agent)) {
            HashMap<String, String> agentOptions = fencingOptionMapping.get(agent);
            if (agentOptions.containsValue(realKey)) {
                for (Map.Entry<String, String> pair : agentOptions.entrySet()) {
                    if (StringUtils.equals(pair.getValue(), realKey)) {
                        result = pair.getKey();
                        break;
                    }
                }
            } else {
                // assume that a legal flag that not exists in mapping was
                // used
                result = realKey;
            }
        } else {
            log.errorFormat(AGENT_ERROR, agent);
        }
    }
    return result;
}
#method_after
private String GetDisplayedKey(String agent, String realKey) {
    String result = "";
    if (StringUtils.isNotEmpty(agent) && StringUtils.isNotEmpty(realKey)) {
        if (fencingOptionMapping.containsKey(agent)) {
            HashMap<String, String> agentOptions = fencingOptionMapping.get(agent);
            if (agentOptions.containsValue(realKey)) {
                for (Map.Entry<String, String> pair : agentOptions.entrySet()) {
                    if (StringUtils.equals(pair.getValue(), realKey)) {
                        result = pair.getKey();
                        break;
                    }
                }
            } else {
                // assume that a legal flag that not exists in mapping was
                // used
                result = realKey;
            }
        } else {
            log.error(AGENT_ERROR, agent);
        }
    }
    return result;
}
#end_block

#method_before
public static String getDefaultAgentOptions(String agent, String fenceOptions, boolean isPPC) {
    String agentDefaultParams = isPPC ? FenceConfigHelper.getFenceConfigurationValue(ConfigValues.FenceAgentDefaultParamsForPPC.name(), ConfigCommon.defaultConfigurationVersion) : FenceConfigHelper.getFenceConfigurationValue(ConfigValues.FenceAgentDefaultParams.name(), ConfigCommon.defaultConfigurationVersion);
    StringBuilder realOptions = new StringBuilder(fenceOptions);
    // result has the format [<agent>:param=value[,]...;]*
    String[] params = agentDefaultParams.split(Pattern.quote(SEMICOLON), -1);
    for (String agentOptionsStr : params) {
        String[] parts = agentOptionsStr.split(Pattern.quote(COLON), -1);
        if (parts.length == 2) {
            if (agent.equalsIgnoreCase(parts[0])) {
                // check for empty options
                if (StringUtils.isNotEmpty(parts[1])) {
                    String[] options = parts[1].split(Pattern.quote(COMMA), -1);
                    for (String option : options) {
                        String[] optionKeyVal = option.split(Pattern.quote(EQUAL), -1);
                        // we respect that value and not use the default value
                        if (!fenceOptions.contains(optionKeyVal[0])) {
                            if (realOptions.length() > 0) {
                                realOptions.append(COMMA);
                            }
                            realOptions.append(optionKeyVal[0]);
                            if (optionKeyVal.length == 2) {
                                String val = (optionKeyVal[1] == null) ? "" : optionKeyVal[1];
                                realOptions.append(EQUAL);
                                realOptions.append(val);
                            }
                        }
                    }
                }
                break;
            }
        }
    }
    return realOptions.toString();
}
#method_after
public static String getDefaultAgentOptions(String agent, String fenceOptions, ArchitectureType architectureType) {
    String agentDefaultParams = (architectureType != null && architectureType == ArchitectureType.ppc64) ? FenceConfigHelper.getFenceConfigurationValue(ConfigValues.FenceAgentDefaultParamsForPPC.name(), ConfigCommon.defaultConfigurationVersion) : FenceConfigHelper.getFenceConfigurationValue(ConfigValues.FenceAgentDefaultParams.name(), ConfigCommon.defaultConfigurationVersion);
    StringBuilder realOptions = new StringBuilder(fenceOptions);
    // result has the format [<agent>:param=value[,]...;]*
    String[] params = agentDefaultParams.split(Pattern.quote(SEMICOLON), -1);
    for (String agentOptionsStr : params) {
        String[] parts = agentOptionsStr.split(Pattern.quote(COLON), -1);
        if (parts.length == 2) {
            if (agent.equalsIgnoreCase(parts[0])) {
                // check for empty options
                if (StringUtils.isNotEmpty(parts[1])) {
                    String[] options = parts[1].split(Pattern.quote(COMMA), -1);
                    for (String option : options) {
                        String[] optionKeyVal = option.split(Pattern.quote(EQUAL), -1);
                        // we respect that value and not use the default value
                        if (!fenceOptions.contains(optionKeyVal[0])) {
                            if (realOptions.length() > 0) {
                                realOptions.append(COMMA);
                            }
                            realOptions.append(optionKeyVal[0]);
                            if (optionKeyVal.length == 2) {
                                String val = (optionKeyVal[1] == null) ? "" : optionKeyVal[1];
                                realOptions.append(EQUAL);
                                realOptions.append(val);
                            }
                        }
                    }
                }
                break;
            }
        }
    }
    return realOptions.toString();
}
#end_block

#method_before
/**
 * Determines whether the specified agent key is supported.
 *
 * @param agent
 *            The agent.
 * @param key
 *            The key.
 * @return <c>true</c> if the specified agent is supported; otherwise, <c>false</c>.
 */
public boolean IsSupported(String agent, String key) {
    boolean result = false;
    if (StringUtils.isNotEmpty(agent) && StringUtils.isNotEmpty(key) && fencingOptionMapping.containsKey(agent)) {
        HashMap<String, String> agentOptions = fencingOptionMapping.get(agent);
        result = (agentOptions == null) ? false : agentOptions.containsKey(key);
    } else {
        log.errorFormat(AGENT_ERROR, agent);
    }
    return result;
}
#method_after
/**
 * Determines whether the specified agent key is supported.
 *
 * @param agent
 *            The agent.
 * @param key
 *            The key.
 * @return <c>true</c> if the specified agent is supported; otherwise, <c>false</c>.
 */
public boolean IsSupported(String agent, String key) {
    boolean result = false;
    if (StringUtils.isNotEmpty(agent) && StringUtils.isNotEmpty(key) && fencingOptionMapping.containsKey(agent)) {
        HashMap<String, String> agentOptions = fencingOptionMapping.get(agent);
        result = (agentOptions == null) ? false : agentOptions.containsKey(key);
    } else {
        log.error(AGENT_ERROR, agent);
    }
    return result;
}
#end_block

#method_before
/**
 * Gets the agent supported options.
 *
 * @param agent
 *            The agent.
 * @return
 */
public ArrayList<String> GetSupportedOptions(String agent) {
    ArrayList<String> agentOptions = new ArrayList<String>();
    if (fencingOptionMapping.containsKey(agent)) {
        HashMap<String, String> options = fencingOptionMapping.get(agent);
        for (Map.Entry<String, String> pair : options.entrySet()) {
            agentOptions.add(pair.getKey());
        }
    } else {
        log.errorFormat(AGENT_ERROR, agent);
    }
    return agentOptions;
}
#method_after
/**
 * Gets the agent supported options.
 *
 * @param agent
 *            The agent.
 * @return
 */
public ArrayList<String> GetSupportedOptions(String agent) {
    ArrayList<String> agentOptions = new ArrayList<String>();
    if (fencingOptionMapping.containsKey(agent)) {
        HashMap<String, String> options = fencingOptionMapping.get(agent);
        for (Map.Entry<String, String> pair : options.entrySet()) {
            agentOptions.add(pair.getKey());
        }
    } else {
        log.error(AGENT_ERROR, agent);
    }
    return agentOptions;
}
#end_block

#method_before
private static void init() {
    if (!initialized) {
        log = LogFactory.getLog(FenceConfigHelper.class);
        keyValidatorMap = new HashMap<String, String>();
        keyValidatorMap.put("FenceAgentMapping", FenceAgentMappingExpr);
        keyValidatorMap.put("FenceAgentDefaultParams", FenceAgentDefaultParamsExpr);
        keyValidatorMap.put("FenceAgentDefaultParamsForPPC", FenceAgentDefaultParamsExpr);
        keyValidatorMap.put("VdsFenceOptionMapping", VdsFenceOptionMappingExpr);
        keyValidatorMap.put("VdsFenceType", CustomVdsFenceTypeExpr);
        keyValidatorMap.put("FencePowerWaitParam", FencePowerWaitParamExpr);
        keyValidatorMap.put("CustomFenceAgentMapping", FenceAgentMappingExpr);
        keyValidatorMap.put("CustomFenceAgentDefaultParams", FenceAgentDefaultParamsExpr);
        keyValidatorMap.put("CustomFenceAgentDefaultParamsForPPC", FenceAgentDefaultParamsExpr);
        keyValidatorMap.put("CustomVdsFenceOptionMapping", VdsFenceOptionMappingExpr);
        keyValidatorMap.put("CustomVdsFenceType", CustomVdsFenceTypeExpr);
        keyValidatorMap.put("CustomFencePowerWaitParam", FencePowerWaitParamExpr);
        keyValidatorExampleMap = new HashMap<String, String>();
        keyValidatorExampleMap.put("CustomFenceAgentMapping", "agent1=agent2,agent3=agent4");
        keyValidatorExampleMap.put("CustomFenceAgentDefaultParams", "agent1=key1=val1,flag;key2=val2");
        keyValidatorExampleMap.put("CustomFenceAgentDefaultParamsForPPC", "agent1=key1=val1,flag;key2=val2");
        keyValidatorExampleMap.put("CustomVdsFenceOptionMapping", "agent1:secure=secure;agent2:port=ipport,slot=slot");
        keyValidatorExampleMap.put("CustomVdsFenceType", "agent1,agent2");
        keyValidatorExampleMap.put("CustomFencePowerWaitParam", "agent1=power_wait,agent2=delay");
        keySeparatorMap = new HashMap<String, String>();
        keySeparatorMap.put("FenceAgentMapping", COMMA);
        keySeparatorMap.put("FenceAgentDefaultParams", SEMICOLON);
        keySeparatorMap.put("FenceAgentDefaultParamsForPPC", SEMICOLON);
        keySeparatorMap.put("VdsFenceOptionMapping", SEMICOLON);
        keySeparatorMap.put("VdsFenceType", COMMA);
        keySeparatorMap.put("FencePowerWaitParam", COMMA);
        initialized = true;
    }
}
#method_after
private static void init() {
    if (!initialized) {
        keyValidatorMap = new HashMap<String, String>();
        keyValidatorMap.put("FenceAgentMapping", FenceAgentMappingExpr);
        keyValidatorMap.put("FenceAgentDefaultParams", FenceAgentDefaultParamsExpr);
        keyValidatorMap.put("FenceAgentDefaultParamsForPPC", FenceAgentDefaultParamsExpr);
        keyValidatorMap.put("VdsFenceOptionMapping", VdsFenceOptionMappingExpr);
        keyValidatorMap.put("VdsFenceType", CustomVdsFenceTypeExpr);
        keyValidatorMap.put("FencePowerWaitParam", FencePowerWaitParamExpr);
        keyValidatorMap.put("CustomFenceAgentMapping", FenceAgentMappingExpr);
        keyValidatorMap.put("CustomFenceAgentDefaultParams", FenceAgentDefaultParamsExpr);
        keyValidatorMap.put("CustomFenceAgentDefaultParamsForPPC", FenceAgentDefaultParamsExpr);
        keyValidatorMap.put("CustomVdsFenceOptionMapping", VdsFenceOptionMappingExpr);
        keyValidatorMap.put("CustomVdsFenceType", CustomVdsFenceTypeExpr);
        keyValidatorMap.put("CustomFencePowerWaitParam", FencePowerWaitParamExpr);
        keyValidatorExampleMap = new HashMap<String, String>();
        keyValidatorExampleMap.put("CustomFenceAgentMapping", "agent1=agent2,agent3=agent4");
        keyValidatorExampleMap.put("CustomFenceAgentDefaultParams", "agent1=key1=val1,flag;key2=val2");
        keyValidatorExampleMap.put("CustomFenceAgentDefaultParamsForPPC", "agent1=key1=val1,flag;key2=val2");
        keyValidatorExampleMap.put("CustomVdsFenceOptionMapping", "agent1:secure=secure;agent2:port=ipport,slot=slot");
        keyValidatorExampleMap.put("CustomVdsFenceType", "agent1,agent2");
        keyValidatorExampleMap.put("CustomFencePowerWaitParam", "agent1=power_wait,agent2=delay");
        keySeparatorMap = new HashMap<String, String>();
        keySeparatorMap.put("FenceAgentMapping", COMMA);
        keySeparatorMap.put("FenceAgentDefaultParams", SEMICOLON);
        keySeparatorMap.put("FenceAgentDefaultParamsForPPC", SEMICOLON);
        keySeparatorMap.put("VdsFenceOptionMapping", SEMICOLON);
        keySeparatorMap.put("VdsFenceType", COMMA);
        keySeparatorMap.put("FencePowerWaitParam", COMMA);
        initialized = true;
    }
}
#end_block

#method_before
private static String merge(String key, String value, String customValue) {
    init();
    StringBuilder sb = new StringBuilder();
    sb.append(value);
    if (StringUtils.isNotEmpty(value) && StringUtils.isNotEmpty(customValue)) {
        if (isValid(key, customValue)) {
            sb.append(keySeparatorMap.get(key));
            sb.append(customValue);
        } else {
            log.errorFormat("Configuration key {0} has illegal value {1}. Expression should match {2}", key, customValue, keyValidatorMap.get(key));
        }
    }
    return sb.toString();
}
#method_after
private static String merge(String key, String value, String customValue) {
    init();
    StringBuilder sb = new StringBuilder();
    sb.append(value);
    if (StringUtils.isNotEmpty(value) && StringUtils.isNotEmpty(customValue)) {
        if (isValid(key, customValue)) {
            sb.append(keySeparatorMap.get(key));
            sb.append(customValue);
        } else {
            log.error("Configuration key '{}' has illegal value '{}'. Expression should match '{}'", key, customValue, keyValidatorMap.get(key));
        }
    }
    return sb.toString();
}
#end_block

#method_before
public boolean findProxyHost() {
    PMProxyOptions proxyOption = null;
    final Guid NO_VDS = Guid.Empty;
    int count;
    // make sure that loop is executed at least once , no matter what is the
    // value in config
    int retries = Math.max(Config.<Integer>getValue(ConfigValues.FindFenceProxyRetries), 1);
    int delayInMs = 1000 * Config.<Integer>getValue(ConfigValues.FindFenceProxyDelayBetweenRetriesInSec);
    proxyHostId = NO_VDS;
    VDS proxyHost = null;
    boolean proxyFound = false;
    // get PM Proxy preferences or use defaults if not defined
    String pmProxyPreferences = (StringUtils.isEmpty(_vds.getPmProxyPreferences())) ? Config.<String>getValue(ConfigValues.FenceProxyDefaultPreferences) : _vds.getPmProxyPreferences();
    String[] pmProxyOptions = pmProxyPreferences.split(",");
    for (String pmProxyOption : pmProxyOptions) {
        count = 0;
        if (pmProxyOption.equalsIgnoreCase(PMProxyOptions.CLUSTER.name())) {
            proxyOption = PMProxyOptions.CLUSTER;
        } else if (pmProxyOption.equalsIgnoreCase(PMProxyOptions.DC.name())) {
            proxyOption = PMProxyOptions.DC;
        } else if (pmProxyOption.equalsIgnoreCase(PMProxyOptions.OTHER_DC.name())) {
            proxyOption = PMProxyOptions.OTHER_DC;
        } else {
            log.errorFormat("Illegal value in PM Proxy Preferences string {0}, skipped.", pmProxyOption);
            continue;
        }
        // available on new host.
        if (_vds.getId().equals(NO_VDS)) {
            // try first to find a Host in UP status
            proxyHost = getFenceProxy(true, false, proxyOption);
            // trying other Hosts that are not in UP since they can be a proxy for fence operations
            if (proxyHost == null) {
                proxyHost = getFenceProxy(false, false, proxyOption);
            }
            if (proxyHost != null) {
                proxyHostId = proxyHost.getId();
                proxyHostName = proxyHost.getName();
                proxyFound = true;
            }
        } else {
            // as configured.
            while (count < retries) {
                proxyHost = getFenceProxy(true, true, proxyOption);
                if (proxyHost == null) {
                    proxyHost = getFenceProxy(false, true, proxyOption);
                }
                if (proxyHost != null) {
                    proxyHostId = proxyHost.getId();
                    proxyHostName = proxyHost.getName();
                    proxyFound = true;
                    break;
                }
                // do not retry getting proxy for Status operation.
                if (_action == FenceActionType.Status)
                    break;
                log.infoFormat("Attempt {0} to find fence proxy host failed...", ++count);
                try {
                    Thread.sleep(delayInMs);
                } catch (Exception e) {
                    log.error(e.getMessage());
                    break;
                }
            }
        }
        if (proxyFound) {
            break;
        }
    }
    if (NO_VDS.equals(proxyHostId)) {
        log.errorFormat("Failed to run Power Management command on Host {0}, no running proxy Host was found.", _vds.getName());
    } else {
        logProxySelection(proxyHost.getName(), proxyOption.createLogEntry(proxyHost), _action.name());
    }
    return !NO_VDS.equals(proxyHostId);
}
#method_after
public boolean findProxyHost() {
    PMProxyOptions proxyOption = null;
    final Guid NO_VDS = Guid.Empty;
    int count;
    // make sure that loop is executed at least once , no matter what is the
    // value in config
    int retries = Math.max(Config.<Integer>getValue(ConfigValues.FindFenceProxyRetries), 1);
    int delayInMs = 1000 * Config.<Integer>getValue(ConfigValues.FindFenceProxyDelayBetweenRetriesInSec);
    proxyHostId = NO_VDS;
    VDS proxyHost = null;
    boolean proxyFound = false;
    // get PM Proxy preferences or use defaults if not defined
    String pmProxyPreferences = (StringUtils.isEmpty(_vds.getPmProxyPreferences())) ? Config.<String>getValue(ConfigValues.FenceProxyDefaultPreferences) : _vds.getPmProxyPreferences();
    String[] pmProxyOptions = pmProxyPreferences.split(",");
    for (String pmProxyOption : pmProxyOptions) {
        count = 0;
        if (pmProxyOption.equalsIgnoreCase(PMProxyOptions.CLUSTER.name())) {
            proxyOption = PMProxyOptions.CLUSTER;
        } else if (pmProxyOption.equalsIgnoreCase(PMProxyOptions.DC.name())) {
            proxyOption = PMProxyOptions.DC;
        } else if (pmProxyOption.equalsIgnoreCase(PMProxyOptions.OTHER_DC.name())) {
            proxyOption = PMProxyOptions.OTHER_DC;
        } else {
            log.error("Illegal value in PM Proxy Preferences string '{}', skipped.", pmProxyOption);
            continue;
        }
        // available on new host.
        if (_vds.getId().equals(NO_VDS)) {
            // try first to find a Host in UP status
            proxyHost = getFenceProxy(true, false, proxyOption);
            // trying other Hosts that are not in UP since they can be a proxy for fence operations
            if (proxyHost == null) {
                proxyHost = getFenceProxy(false, false, proxyOption);
            }
            if (proxyHost != null) {
                proxyHostId = proxyHost.getId();
                proxyHostName = proxyHost.getName();
                proxyFound = true;
            }
        } else {
            // as configured.
            while (count < retries) {
                proxyHost = getFenceProxy(true, true, proxyOption);
                if (proxyHost == null) {
                    proxyHost = getFenceProxy(false, true, proxyOption);
                }
                if (proxyHost != null) {
                    proxyHostId = proxyHost.getId();
                    proxyHostName = proxyHost.getName();
                    proxyFound = true;
                    break;
                }
                // do not retry getting proxy for Status operation.
                if (_action == FenceActionType.Status)
                    break;
                log.info("Attempt {} to find fence proxy host failed...", ++count);
                try {
                    Thread.sleep(delayInMs);
                } catch (Exception e) {
                    log.error("Exception: {}", e.getMessage());
                    log.debug("Exception", e);
                    break;
                }
            }
        }
        if (proxyFound) {
            break;
        }
    }
    if (NO_VDS.equals(proxyHostId)) {
        log.error("Failed to run Power Management command on Host '{}', no running proxy Host was found.", _vds.getName());
    } else {
        logProxySelection(proxyHost.getName(), proxyOption.createLogEntry(proxyHost), _action.name());
    }
    return !NO_VDS.equals(proxyHostId);
}
#end_block

#method_before
private void logProxySelection(String proxy, String origin, String command) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("Proxy", proxy);
    logable.addCustomValue("Origin", origin);
    logable.addCustomValue("Command", command);
    logable.setVdsId(_vds.getId());
    AuditLogDirector.log(logable, AuditLogType.PROXY_HOST_SELECTION);
    log.infoFormat("Using Host {0} from {1} as proxy to execute {2} command on Host {3}", proxy, origin, command, _vds.getName());
}
#method_after
private void logProxySelection(String proxy, String origin, String command) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("Proxy", proxy);
    logable.addCustomValue("Origin", origin);
    logable.addCustomValue("Command", command);
    logable.setVdsId(_vds.getId());
    AuditLogDirector.log(logable, AuditLogType.PROXY_HOST_SELECTION);
    log.info("Using Host '{}' from '{}' as proxy to execute '{}' command on Host '{}'", proxy, origin, command, _vds.getName());
}
#end_block

#method_before
public VDSReturnValue fence(FenceAgentOrder order) {
    VDSReturnValue retValue = null;
    try {
        // skip following code in case of testing a new host status
        if (_vds.getId() != null && !_vds.getId().equals(Guid.Empty)) {
            // get the host spm status again from the database in order to test it's current state.
            _vds.setSpmStatus((DbFacade.getInstance().getVdsDao().get(_vds.getId()).getSpmStatus()));
            // try to stop SPM if action is Restart or Stop and the vds is SPM
            if ((_action == FenceActionType.Restart || _action == FenceActionType.Stop) && (_vds.getSpmStatus() != VdsSpmStatus.None)) {
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(_vds.getId(), _vds.getStoragePoolId()));
            }
        }
        retValue = runFenceAction(_action, order);
        // if fence failed, retry with another proxy
        if (!retValue.getSucceeded()) {
            log.warnFormat("Fencing operation failed with proxy host {0}, trying another proxy...", proxyHostId);
            if (!findProxyHostExcluding(proxyHostId)) {
                log.warnFormat("Failed to find other proxy to re-run failed fence operation, retrying with the same proxy...");
                findProxyHost();
            }
            retValue = runFenceAction(_action, order);
        }
    } catch (VdcBLLException e) {
        retValue = new VDSReturnValue();
        retValue.setReturnValue(new FenceStatusReturnValue("unknown", e.getMessage()));
        retValue.setExceptionString(e.getMessage());
        retValue.setSucceeded(false);
    }
    return retValue;
}
#method_after
public VDSReturnValue fence(FenceAgentOrder order) {
    VDSReturnValue retValue = null;
    try {
        // skip following code in case of testing a new host status
        if (_vds.getId() != null && !_vds.getId().equals(Guid.Empty)) {
            // get the host spm status again from the database in order to test it's current state.
            _vds.setSpmStatus((DbFacade.getInstance().getVdsDao().get(_vds.getId()).getSpmStatus()));
            // try to stop SPM if action is Restart or Stop and the vds is SPM
            if ((_action == FenceActionType.Restart || _action == FenceActionType.Stop) && (_vds.getSpmStatus() != VdsSpmStatus.None)) {
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(_vds.getId(), _vds.getStoragePoolId()));
            }
        }
        retValue = runFenceAction(_action, order);
        // if fence failed, retry with another proxy
        if (!retValue.getSucceeded()) {
            log.warn("Fencing operation failed with proxy host '{}', trying another proxy...", proxyHostId);
            if (!findProxyHostExcluding(proxyHostId)) {
                log.warn("Failed to find other proxy to re-run failed fence operation, retrying with the same proxy...");
                findProxyHost();
            }
            retValue = runFenceAction(_action, order);
        }
    } catch (VdcBLLException e) {
        retValue = new VDSReturnValue();
        retValue.setReturnValue(new FenceStatusReturnValue("unknown", e.getMessage()));
        retValue.setExceptionString(e.getMessage());
        retValue.setSucceeded(false);
    }
    return retValue;
}
#end_block

#method_before
private VDSReturnValue runFenceAction(FenceActionType actionType, FenceAgentOrder order) {
    String managementIp = getManagementIp(order);
    String managementPort = getManagementPort(order);
    String managementAgent = getManagementAgent(order);
    String managementUser = getManagementUser(order);
    String managementPassword = getManagementPassword(order);
    String managementOptions = getManagementOptions(order);
    log.infoFormat("Executing <{0}> Power Management command, Proxy Host:{1}, " + "Agent:{2}, Target Host:{3}, Management IP:{4}, User:{5}, Options:{6}, Fencing policy:{7}", actionType, proxyHostName, managementAgent, _vds.getName(), managementIp, managementUser, managementOptions, fencingPolicy);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FenceVds, new FenceVdsVDSCommandParameters(proxyHostId, _vds.getId(), managementIp, managementPort, managementAgent, managementUser, managementPassword, managementOptions, actionType, fencingPolicy));
}
#method_after
private VDSReturnValue runFenceAction(FenceActionType actionType, FenceAgentOrder order) {
    String managementIp = getManagementIp(order);
    String managementPort = getManagementPort(order);
    String managementAgent = getManagementAgent(order);
    String managementUser = getManagementUser(order);
    String managementPassword = getManagementPassword(order);
    String managementOptions = getManagementOptions(order);
    log.info("Executing <{}> Power Management command, Proxy Host '{}', " + "Agent '{}', Target Host '{}', Management IP '{}', User '{}', Options '{}', Fencing policy '{}'", actionType, proxyHostName, managementAgent, _vds.getName(), managementIp, managementUser, managementOptions, fencingPolicy);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FenceVds, new FenceVdsVDSCommandParameters(proxyHostId, _vds.getId(), managementIp, managementPort, managementAgent, managementUser, managementPassword, managementOptions, actionType, fencingPolicy));
}
#end_block

#method_before
private String getManagementOptions(FenceAgentOrder order) {
    String managementOptions = "";
    VDSGroup cluster = DbFacade.getInstance().getVdsGroupDao().get(_vds.getVdsGroupId());
    boolean isPPC = (cluster.getArchitecture() == ArchitectureType.ppc64);
    if (order == FenceAgentOrder.Primary) {
        managementOptions = VdsFenceOptions.getDefaultAgentOptions(_vds.getPmType(), _vds.getPmOptions(), isPPC);
    } else if (order == FenceAgentOrder.Secondary) {
        managementOptions = VdsFenceOptions.getDefaultAgentOptions(_vds.getPmSecondaryType(), _vds.getPmSecondaryOptions(), isPPC);
    }
    return managementOptions;
}
#method_after
private String getManagementOptions(FenceAgentOrder order) {
    String managementOptions = "";
    ArchitectureType architectureType = null;
    if (_vds.getCpuName() != null) {
        architectureType = _vds.getCpuName().getArchitecture();
    }
    if (order == FenceAgentOrder.Primary) {
        managementOptions = VdsFenceOptions.getDefaultAgentOptions(_vds.getPmType(), _vds.getPmOptions(), architectureType);
    } else if (order == FenceAgentOrder.Secondary) {
        managementOptions = VdsFenceOptions.getDefaultAgentOptions(_vds.getPmSecondaryType(), _vds.getPmSecondaryOptions(), architectureType);
    }
    return managementOptions;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.infoFormat("Cancelling current running update for vms for base template id {0}", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warnFormat("Failed deleting job {0} at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    // Check that all the template's allocated disk's aliases are not an empty string.
    Iterator<DiskImage> it = diskInfoDestinationMap.values().iterator();
    while (it.hasNext()) {
        if (it.next().getDiskAlias().isEmpty()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_CANNOT_BE_CREATED_WITH_EMPTY_DISK_ALIAS);
        }
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#end_block

#method_before
public Features getFeatures(Version version) {
    Features features = new Features();
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_0)) {
        addFeatureTransparentHugePages(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_1)) {
        addFeatureGluster(features);
        addFeaturePosixDevice(features);
        addFeaturePortMirroring(features);
        addFeatureServerTime(features);
        addFeatureHostMemory(features);
        addFeatureHostSockets(features, version);
        addFeatureIgnoreCase(features);
        addFeatureMaxResults(features);
        addFeatureJSONContentType(features);
        addFeatureCorrelationId(features);
        addFeatureDiskActivation(features);
        addFeatureNicActivation(features);
        addFeatureSnapshotsRefactoring(features);
        addFeatureRemoveTemplateFromSD(features);
        addFeatureFloatingDisks(features);
        addFeatureAsyncDelete(features);
        addFeatureSessionBasedAuthentication(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_3)) {
        addFeatureVmApplications(features);
        addFeatureVirtioScsi(features);
        addFeatureComment(features);
        addFeatureRefreshHostCapabilities(features);
        addFeatureMemorySnapshot(features);
        addWatchdogFeature(features);
        addSshAuthenticationFeature(features);
        addForceSelectSpmFeature(features);
        addConsoleFeature(features);
        addFeatureStorageServerConnections(features);
        addFeatureStorageServerConnectionsForDomain(features);
        addFeatureAttachDetachStorageServerConnectionsForDomain(features);
        addSingleQxlPciFeature(features);
        addFeatureAddVmFromOvf(features);
        addVnicProfilesFeature(features);
        addStorageDomainImageFeature(features);
        addGlusterHooksFeature(features);
        addFeatureReportVmFQDN(features);
        addFeatureAttachDiskSnapshot(features);
        addFeatureCloudInit(features);
        addFeatureSchedulingPolicy(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_4)) {
        addGlusterBricksFeature(features);
        addFeatureCopyMoveDiskInAdditionalContext(features);
        addNetworkLabelsFeature(features);
        addRebootFeature(features);
        addMaintenanceFeature(features);
        addIscsiBondFeature(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_5)) {
        addBookmarksFeature(features);
        addNetworkCustomPropertiesFeature(features);
        addFeatureRemoveDiskFromVmSnapshot(features);
        addFeatureDiskSnapshotsResourceInStorageDomainContext(features);
        addInstanceTypesFeature(features);
        addNumaNodesFeature(features);
        addMacPoolsFeature(features);
        addDiskProfilesFeature(features);
        addCpuProfilesFeature(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_6)) {
        addForemanHostProvidersFeature(features);
    }
    return features;
}
#method_after
public Features getFeatures(Version version) {
    Features features = new Features();
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_0)) {
        addFeatureTransparentHugePages(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_1)) {
        addFeatureGluster(features);
        addFeaturePosixDevice(features);
        addFeaturePortMirroring(features);
        addFeatureServerTime(features);
        addFeatureHostMemory(features);
        addFeatureHostSockets(features, version);
        addFeatureIgnoreCase(features);
        addFeatureMaxResults(features);
        addFeatureJSONContentType(features);
        addFeatureCorrelationId(features);
        addFeatureDiskActivation(features);
        addFeatureNicActivation(features);
        addFeatureSnapshotsRefactoring(features);
        addFeatureRemoveTemplateFromSD(features);
        addFeatureFloatingDisks(features);
        addFeatureAsyncDelete(features);
        addFeatureSessionBasedAuthentication(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_3)) {
        addFeatureVmApplications(features);
        addFeatureVirtioScsi(features);
        addFeatureComment(features);
        addFeatureRefreshHostCapabilities(features);
        addFeatureMemorySnapshot(features);
        addWatchdogFeature(features);
        addSshAuthenticationFeature(features);
        addForceSelectSpmFeature(features);
        addConsoleFeature(features);
        addFeatureStorageServerConnections(features);
        addFeatureStorageServerConnectionsForDomain(features);
        addFeatureAttachDetachStorageServerConnectionsForDomain(features);
        addSingleQxlPciFeature(features);
        addFeatureAddVmFromOvf(features);
        addVnicProfilesFeature(features);
        addStorageDomainImageFeature(features);
        addGlusterHooksFeature(features);
        addFeatureReportVmFQDN(features);
        addFeatureAttachDiskSnapshot(features);
        addFeatureCloudInit(features);
        addFeatureSchedulingPolicy(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_4)) {
        addGlusterBricksFeature(features);
        addFeatureCopyMoveDiskInAdditionalContext(features);
        addNetworkLabelsFeature(features);
        addRebootFeature(features);
        addMaintenanceFeature(features);
        addIscsiBondFeature(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_5)) {
        addBookmarksFeature(features);
        addNetworkCustomPropertiesFeature(features);
        addFeatureRemoveDiskFromVmSnapshot(features);
        addFeatureDiskSnapshotsResourceInStorageDomainContext(features);
        addInstanceTypesFeature(features);
        addNumaNodesFeature(features);
        addMacPoolsFeature(features);
        addDiskProfilesFeature(features);
        addCpuProfilesFeature(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_6)) {
        addExternalHostProvidersFeature(features);
    }
    return features;
}
#end_block

#method_before
public static Collection<DetailedLink> getLinks(String baseUri) {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities", baseUri));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("datacenters", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams(), baseUri));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("networks", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("roles", baseUri));
    links.add(createLink("storagedomains", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("tags", baseUri));
    links.add(createLink("bookmarks", baseUri));
    links.add(createLink("templates", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("instancetypes", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("users", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("groups", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("domains", baseUri));
    links.add(createLink("vmpools", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("vms", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("disks", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("jobs", baseUri));
    links.add(createLink("storageconnections", baseUri));
    links.add(createLink("vnicprofiles", baseUri));
    links.add(createLink("diskprofiles", baseUri));
    links.add(createLink("cpuprofiles", baseUri));
    links.add(createLink("schedulingpolicyunits", baseUri));
    links.add(createLink("schedulingpolicies", baseUri));
    links.add(createLink("permissions", baseUri));
    links.add(createLink("macpools", baseUri));
    links.add(createLink("foremanhostproviders", baseUri));
    return links;
}
#method_after
public static Collection<DetailedLink> getLinks(String baseUri) {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities", baseUri));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("datacenters", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams(), baseUri));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("networks", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("roles", baseUri));
    links.add(createLink("storagedomains", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("tags", baseUri));
    links.add(createLink("bookmarks", baseUri));
    links.add(createLink("templates", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("instancetypes", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("users", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("groups", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("domains", baseUri));
    links.add(createLink("vmpools", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("vms", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("disks", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("jobs", baseUri));
    links.add(createLink("storageconnections", baseUri));
    links.add(createLink("vnicprofiles", baseUri));
    links.add(createLink("diskprofiles", baseUri));
    links.add(createLink("cpuprofiles", baseUri));
    links.add(createLink("schedulingpolicyunits", baseUri));
    links.add(createLink("schedulingpolicies", baseUri));
    links.add(createLink("permissions", baseUri));
    links.add(createLink("macpools", baseUri));
    links.add(createLink("operatingsystems", baseUri));
    links.add(createLink("externalhostproviders", baseUri));
    return links;
}
#end_block

#method_before
public boolean populate(Object xmlRpcRawResult) {
    try {
        if (!(xmlRpcRawResult instanceof HashMap)) {
            log.error("External scheduler error, malformed discover results");
            return false;
        }
        @SuppressWarnings("unchecked")
        HashMap<String, HashMap<String, Object[]>> castedResult = (HashMap<String, HashMap<String, Object[]>>) xmlRpcRawResult;
        // keys will be filter, score and balance
        for (Map.Entry<String, HashMap<String, Object[]>> entry : castedResult.entrySet()) {
            String type = entry.getKey();
            HashMap<String, Object[]> typeMap = entry.getValue();
            List<ExternalSchedulerDiscoveryUnit> currentList = getRelevantList(type);
            if (currentList == null) {
                log.error("External scheduler error, got unknown type");
                return false;
            }
            // list of module names as keys and [description, regex] as value
            for (Map.Entry<String, Object[]> module : typeMap.entrySet()) {
                String moduleName = module.getKey();
                Object[] singleModule = module.getValue();
                // check custom properties format.
                String customPropertiesRegex = singleModule[1].toString();
                if (!StringUtils.isEmpty(customPropertiesRegex) && SimpleCustomPropertiesUtil.getInstance().syntaxErrorInProperties(customPropertiesRegex)) {
                    log.error("module " + moduleName + " will not be loaded, wrong custom properties format (" + customPropertiesRegex + ")");
                    continue;
                }
                ExternalSchedulerDiscoveryUnit currentUnit = new ExternalSchedulerDiscoveryUnit(moduleName, singleModule[0].toString(), customPropertiesRegex);
                currentList.add(currentUnit);
            }
        }
        return true;
    } catch (Exception e) {
        log.error("External scheduler error, exception why parsing discovery results: {}", e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#method_after
public boolean populate(Object xmlRpcRawResult) {
    try {
        if (!(xmlRpcRawResult instanceof HashMap)) {
            log.error("External scheduler error, malformed discover results");
            return false;
        }
        @SuppressWarnings("unchecked")
        HashMap<String, HashMap<String, Object[]>> castedResult = (HashMap<String, HashMap<String, Object[]>>) xmlRpcRawResult;
        // keys will be filter, score and balance
        for (Map.Entry<String, HashMap<String, Object[]>> entry : castedResult.entrySet()) {
            String type = entry.getKey();
            HashMap<String, Object[]> typeMap = entry.getValue();
            List<ExternalSchedulerDiscoveryUnit> currentList = getRelevantList(type);
            if (currentList == null) {
                log.error("External scheduler error, got unknown type");
                return false;
            }
            // list of module names as keys and [description, regex] as value
            for (Map.Entry<String, Object[]> module : typeMap.entrySet()) {
                String moduleName = module.getKey();
                Object[] singleModule = module.getValue();
                // check custom properties format.
                String customPropertiesRegex = singleModule[1].toString();
                if (!StringUtils.isEmpty(customPropertiesRegex) && SimpleCustomPropertiesUtil.getInstance().syntaxErrorInProperties(customPropertiesRegex)) {
                    log.error("module " + moduleName + " will not be loaded, wrong custom properties format (" + customPropertiesRegex + ")");
                    continue;
                }
                ExternalSchedulerDiscoveryUnit currentUnit = new ExternalSchedulerDiscoveryUnit(moduleName, singleModule[0].toString(), customPropertiesRegex);
                currentList.add(currentUnit);
            }
        }
        return true;
    } catch (Exception e) {
        log.error("External scheduler error, exception while parsing discovery results: {}", e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#end_block

#method_before
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Semaphore(1));
    try {
        log.debug("Scheduling started");
        checkAllowOverbooking(cluster);
        clusterLockMap.get(cluster.getId()).acquire();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.isEmpty()) {
            return null;
        }
        Guid bestHost = selectBestHost(cluster, vm, destHostId, vdsList, policy, parameters);
        getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), 0, 0);
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        // ensuring setting the semaphore permits to 1
        synchronized (clusterLockMap.get(cluster.getId())) {
            clusterLockMap.get(cluster.getId()).drainPermits();
            clusterLockMap.get(cluster.getId()).release();
        }
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#method_after
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Semaphore(1));
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        clusterLockMap.get(cluster.getId()).acquire();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.isEmpty()) {
            return null;
        }
        Guid bestHost = selectBestHost(cluster, vm, destHostId, vdsList, policy, parameters);
        getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), 0, 0);
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        // ensuring setting the semaphore permits to 1
        synchronized (clusterLockMap.get(cluster.getId())) {
            clusterLockMap.get(cluster.getId()).drainPermits();
            clusterLockMap.get(cluster.getId()).release();
        }
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#end_block

#method_before
private void logFilterActions(List<VDS> oldList, Set<Guid> newSet, VdcBllMessages actionName, String filterName, SchedulingResult result, String correlationId) {
    for (VDS host : oldList) {
        if (!newSet.contains(host.getId())) {
            result.addReason(host.getId(), host.getName(), actionName, filterName);
            log.info("Candidate host '{}' ('{}') was filtered out by '{}' filter '{}'", host.getName(), host.getId(), actionName.name(), filterName);
        }
    }
}
#method_after
private void logFilterActions(List<VDS> oldList, Set<Guid> newSet, VdcBllMessages actionName, String filterName, SchedulingResult result, String correlationId) {
    for (VDS host : oldList) {
        if (!newSet.contains(host.getId())) {
            result.addReason(host.getId(), host.getName(), actionName, filterName);
            log.info("Candidate host '{}' ('{}') was filtered out by '{}' filter '{}' (correlation id: {})", host.getName(), host.getId(), actionName.name(), filterName, correlationId);
        }
    }
}
#end_block

#method_before
public static List<VDS> getAcceptableHosts(boolean enforcing, List<VDS> hosts, VM vm, PerHostMessages messages) {
    List<AffinityGroup> affinityGroups = getAffinityGroupDao().getAllAffinityGroupsByVmId(vm.getId());
    // no affinity groups found for VM return all hosts
    if (affinityGroups.isEmpty()) {
        return hosts;
    }
    Set<Guid> allVmIdsPositive = new HashSet<>();
    Set<Guid> allVmIdsNegative = new HashSet<>();
    // Group by all vms in affinity groups per positive or negative
    for (AffinityGroup affinityGroup : affinityGroups) {
        if (affinityGroup.isEnforcing() == enforcing) {
            for (Guid entityId : affinityGroup.getEntityIds()) {
                // Skip current VM
                if (entityId.equals(vm.getId())) {
                    continue;
                }
                if (affinityGroup.isPositive()) {
                    allVmIdsPositive.add(entityId);
                } else {
                    allVmIdsNegative.add(entityId);
                }
            }
        }
    }
    // No entities, all hosts are valid
    if (allVmIdsPositive.isEmpty() && allVmIdsNegative.isEmpty()) {
        return hosts;
    }
    // Get all running VMs in cluster
    Map<Guid, VM> runningVMsMap = new HashMap<>();
    for (VM iter : getVmDao().getAllRunningByCluster(vm.getVdsGroupId())) {
        runningVMsMap.put(iter.getId(), iter);
    }
    Map<Guid, VDS> hostMap = new HashMap<>();
    for (VDS host : hosts) {
        hostMap.put(host.getId(), host);
    }
    Set<Guid> acceptableHosts = new HashSet<>();
    // Group all hosts for VMs with positive affinity
    for (Guid id : allVmIdsPositive) {
        VM runVm = runningVMsMap.get(id);
        if (runVm != null && runVm.getRunOnVds() != null && hostMap.get(runVm.getRunOnVds()) != null && // can't migrate).
        hostMap.get(runVm.getRunOnVds()).getStatus() != VDSStatus.PreparingForMaintenance) {
            acceptableHosts.add(runVm.getRunOnVds());
        }
    }
    Set<Guid> unacceptableHosts = new HashSet<>();
    // Group all hosts for VMs with negative affinity
    for (Guid id : allVmIdsNegative) {
        VM runVm = runningVMsMap.get(id);
        if (runVm != null && runVm.getRunOnVds() != null) {
            unacceptableHosts.add(runVm.getRunOnVds());
        }
    }
    // Compute the intersection of hosts with positive and negative affinity and report that
    // contradicting rules to the log
    unacceptableHosts.retainAll(acceptableHosts);
    for (Guid id : unacceptableHosts) {
        log.warn("Host '{}' ({}) belongs to both positive and negative affinity list" + " while scheduling VM '{}' ({})", hostMap.get(id).getName(), id.toString(), vm.getName(), vm.getId());
    }
    // No hosts associated with positive affinity, all hosts are applicable.
    if (acceptableHosts.isEmpty()) {
        acceptableHosts.addAll(hostMap.keySet());
    } else if (acceptableHosts.size() > 1) {
        log.warn("Invalid affinity situation was detected while scheduling VM '{}' ({})." + " VMs belonging to the same affinity groups are running on more than one host.", vm.getName(), vm.getId());
    }
    // Report hosts that were removed because of violating the positive affinity rules
    for (VDS host : hosts) {
        if (!acceptableHosts.contains(host.getId())) {
            messages.addMessage(host.getId(), // TODO compute the affinity rule names
            String.format("$affinityRules %1$s", ""));
            messages.addMessage(host.getId(), VdcBllMessages.VAR__DETAIL__AFFINITY_FAILED_POSITIVE.toString());
        }
    }
    // Remove hosts that contain VMs with negaive affinity to the currently scheduled Vm
    for (Guid id : allVmIdsNegative) {
        VM runVm = runningVMsMap.get(id);
        if (runVm != null && runVm.getRunOnVds() != null && acceptableHosts.contains(runVm.getRunOnVds())) {
            acceptableHosts.remove(runVm.getRunOnVds());
            messages.addMessage(runVm.getRunOnVds(), // TODO compute the affinity rule names
            String.format("$affinityRules %1$s", ""));
            messages.addMessage(runVm.getRunOnVds(), VdcBllMessages.VAR__DETAIL__AFFINITY_FAILED_NEGATIVE.toString());
        }
    }
    List<VDS> retList = new ArrayList<>();
    for (VDS host : hosts) {
        if (acceptableHosts.contains(host.getId())) {
            retList.add(host);
        }
    }
    return retList;
}
#method_after
public static List<VDS> getAcceptableHosts(boolean enforcing, List<VDS> hosts, VM vm, PerHostMessages messages) {
    List<AffinityGroup> affinityGroups = getAffinityGroupDao().getAllAffinityGroupsByVmId(vm.getId());
    // no affinity groups found for VM return all hosts
    if (affinityGroups.isEmpty()) {
        return hosts;
    }
    Set<Guid> allVmIdsPositive = new HashSet<>();
    Set<Guid> allVmIdsNegative = new HashSet<>();
    // Group by all vms in affinity groups per positive or negative
    for (AffinityGroup affinityGroup : affinityGroups) {
        if (affinityGroup.isEnforcing() == enforcing) {
            for (Guid entityId : affinityGroup.getEntityIds()) {
                // Skip current VM
                if (entityId.equals(vm.getId())) {
                    continue;
                }
                if (affinityGroup.isPositive()) {
                    allVmIdsPositive.add(entityId);
                } else {
                    allVmIdsNegative.add(entityId);
                }
            }
        }
    }
    // No entities, all hosts are valid
    if (allVmIdsPositive.isEmpty() && allVmIdsNegative.isEmpty()) {
        return hosts;
    }
    // Get all running VMs in cluster
    Map<Guid, VM> runningVMsMap = new HashMap<>();
    for (VM iter : getVmDao().getAllRunningByCluster(vm.getVdsGroupId())) {
        runningVMsMap.put(iter.getId(), iter);
    }
    Set<Guid> acceptableHosts = new HashSet<>();
    // Group all hosts for VMs with positive affinity
    for (Guid id : allVmIdsPositive) {
        VM runVm = runningVMsMap.get(id);
        if (runVm != null && runVm.getRunOnVds() != null) {
            acceptableHosts.add(runVm.getRunOnVds());
        }
    }
    Set<Guid> unacceptableHosts = new HashSet<>();
    // Group all hosts for VMs with negative affinity
    for (Guid id : allVmIdsNegative) {
        VM runVm = runningVMsMap.get(id);
        if (runVm != null && runVm.getRunOnVds() != null) {
            unacceptableHosts.add(runVm.getRunOnVds());
        }
    }
    Map<Guid, VDS> hostMap = new HashMap<>();
    for (VDS host : hosts) {
        hostMap.put(host.getId(), host);
    }
    // Compute the intersection of hosts with positive and negative affinity and report that
    // contradicting rules to the log
    unacceptableHosts.retainAll(acceptableHosts);
    for (Guid id : unacceptableHosts) {
        log.warn("Host '{}' ({}) belongs to both positive and negative affinity list" + " while scheduling VM '{}' ({})", hostMap.get(id).getName(), id, vm.getName(), vm.getId());
    }
    // No hosts associated with positive affinity, all hosts are applicable.
    if (acceptableHosts.isEmpty()) {
        acceptableHosts.addAll(hostMap.keySet());
    } else if (acceptableHosts.size() > 1) {
        log.warn("Invalid affinity situation was detected while scheduling VM '{}' ({})." + " VMs belonging to the same affinity groups are running on more than one host.", vm.getName(), vm.getId());
    }
    // Report hosts that were removed because of violating the positive affinity rules
    for (VDS host : hosts) {
        if (!acceptableHosts.contains(host.getId())) {
            messages.addMessage(host.getId(), // TODO compute the affinity rule names
            String.format("$affinityRules %1$s", ""));
            messages.addMessage(host.getId(), VdcBllMessages.VAR__DETAIL__AFFINITY_FAILED_POSITIVE.toString());
        }
    }
    // Remove hosts that contain VMs with negaive affinity to the currently scheduled Vm
    for (Guid id : allVmIdsNegative) {
        VM runVm = runningVMsMap.get(id);
        if (runVm != null && runVm.getRunOnVds() != null && acceptableHosts.contains(runVm.getRunOnVds())) {
            acceptableHosts.remove(runVm.getRunOnVds());
            messages.addMessage(runVm.getRunOnVds(), // TODO compute the affinity rule names
            String.format("$affinityRules %1$s", ""));
            messages.addMessage(runVm.getRunOnVds(), VdcBllMessages.VAR__DETAIL__AFFINITY_FAILED_NEGATIVE.toString());
        }
    }
    List<VDS> retList = new ArrayList<>();
    for (VDS host : hosts) {
        if (acceptableHosts.contains(host.getId())) {
            retList.add(host);
        }
    }
    return retList;
}
#end_block

#method_before
@Override
public Pair<List<Guid>, Guid> runBalance(String balanceName, List<Guid> hostIDs, Map<String, String> propertiesMap) {
    try {
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(BALANCE, createBalanceArgs(balanceName, hostIDs, propertiesMap));
        return ExternalSchedulerBrokerObjectBuilder.getBalanceResults(result).getResult();
    } catch (XmlRpcException e) {
        log.error("Error communicate with the external scheduler while balancing: {}", e.getMessage());
        log.debug("Exception", e);
        auditLogFailedToConnect();
        return null;
    }
}
#method_after
@Override
public Pair<List<Guid>, Guid> runBalance(String balanceName, List<Guid> hostIDs, Map<String, String> propertiesMap) {
    try {
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(BALANCE, createBalanceArgs(balanceName, hostIDs, propertiesMap));
        return ExternalSchedulerBrokerObjectBuilder.getBalanceResults(result).getResult();
    } catch (XmlRpcException e) {
        log.error("Error communicating with the external scheduler while balancing: {}", e.getMessage());
        log.debug("Exception", e);
        auditLogFailedToConnect();
        return null;
    }
}
#end_block

#method_before
private void getAffinityGroupByVdsIdHelper(Guid vdsId, int count) {
    List<AffinityGroup> affinityGroups = dao.getEnforcingAffinityGroupsByRunningVmsOnVdsId(vdsId);
    assertNotNull(affinityGroups);
    assertEquals(count, affinityGroups.size());
}
#method_after
private void getAffinityGroupByVdsIdHelper(Guid vdsId, int count) {
    List<AffinityGroup> affinityGroups = dao.getPositiveEnforcingAffinityGroupsByRunningVmsOnVdsId(vdsId);
    assertNotNull(affinityGroups);
    assertEquals(count, affinityGroups.size());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    } else {
                        if (!vms.isEmpty()) {
                            List<AffinityGroup> affinityGroups = getDbFacade().getAffinityGroupDao().getEnforcingAffinityGroupsByRunningVmsOnVdsId(vdsId);
                            if (!affinityGroups.isEmpty()) {
                                List<Object> items = new ArrayList<>();
                                for (AffinityGroup affinityGroup : affinityGroups) {
                                    items.add(String.format("%1$s (%2$s)", affinityGroup.getName(), StringUtils.join(affinityGroup.getEntityNames(), " ,").replaceAll(" ,$", "")));
                                }
                                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_HAS_AFFINITY_VMS);
                                getReturnValue().getCanDoActionMessages().addAll(ReplacementUtils.replaceWith("AFFINITY_GROUPS_VMS", items));
                                result = false;
                            }
                        }
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    } else {
                        result = handlePositiveEnforcingAffinityGroup(vdsId, vms);
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getMissingServerHooks().isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_HOOK_NO_CONFLICT_SERVERS);
        return false;
    }
    for (GlusterServerHook serverHook : getMissingServerHooks()) {
        VDS vds = getVdsDAO().get(serverHook.getServerId());
        if (vds == null || vds.getStatus() != VDSStatus.Up) {
            String vdsName = vds != null ? vds.getName() : "NO SERVER";
            setVdsName(vdsName);
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SERVER_STATUS_NOT_UP);
            if (vds != null) {
                addCanDoActionMessage(String.format("$%1$s %2$s", "VdsName", vdsName));
            }
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getMissingServerHooks().isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_HOOK_NO_CONFLICT_SERVERS);
        return false;
    }
    for (GlusterServerHook serverHook : getMissingServerHooks()) {
        VDS vds = getVdsDAO().get(serverHook.getServerId());
        if (vds == null || vds.getStatus() != VDSStatus.Up) {
            String vdsName = vds != null ? vds.getName() : GlusterConstants.NO_SERVER;
            setVdsName(vdsName);
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SERVER_STATUS_NOT_UP);
            addCanDoActionMessage(String.format("$%1$s %2$s", "VdsName", vdsName));
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getContentConflictServerHooks().isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_HOOK_NO_CONFLICT_SERVERS);
        return false;
    }
    for (GlusterServerHook serverHook : getContentConflictServerHooks()) {
        VDS vds = getVdsDAO().get(serverHook.getServerId());
        if (vds == null || vds.getStatus() != VDSStatus.Up) {
            String vdsName = vds != null ? vds.getName() : "NO SERVER";
            setVdsName(vdsName);
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SERVER_STATUS_NOT_UP);
            if (vds != null) {
                addCanDoActionMessage(String.format("$%1$s %2$s", "VdsName", vdsName));
            }
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getContentConflictServerHooks().isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_HOOK_NO_CONFLICT_SERVERS);
        return false;
    }
    for (GlusterServerHook serverHook : getContentConflictServerHooks()) {
        VDS vds = getVdsDAO().get(serverHook.getServerId());
        if (vds == null || vds.getStatus() != VDSStatus.Up) {
            String vdsName = vds != null ? vds.getName() : GlusterConstants.NO_SERVER;
            setVdsName(vdsName);
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SERVER_STATUS_NOT_UP);
            addCanDoActionMessage(String.format("$%1$s %2$s", "VdsName", vdsName));
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private List<StorageServerConnections> parseFullTargets(List<String> iqnList) {
    ArrayList<StorageServerConnections> connections = new ArrayList<StorageServerConnections>(iqnList.size());
    for (String fullTarget : iqnList) {
        StorageServerConnections con = StorageServerConnections.copyOf(getParameters().getConnection());
        // fullTarget format: <ip>:<port>, <portal> <targetName>
        // e.g 10.35.104.8:3600,1 blue-20G
        String[] tokens = fullTarget.split(",");
        String[] address = tokens[0].split(":");
        String[] literals = tokens[1].split(" ");
        con.setport(address[1]);
        con.setportal(literals[0]);
        con.setiqn(literals[1]);
        // address[0] is the IP address of the target as returned from VDSM.
        // Since we want to use the original address from the user's input (which can also be a DNS name),
        // and since VDSM always returns the IP address of the target, we don't want to override it
        // by calling con.setconnection(address[0]).
        log.infoFormat("Connection to {0} requested, VDSM returned {1}.", con.getconnection(), address[0]);
        connections.add(con);
    }
    return connections;
}
#method_after
private List<StorageServerConnections> parseFullTargets(List<String> iqnList) {
    ArrayList<StorageServerConnections> connections = new ArrayList<StorageServerConnections>(iqnList.size());
    for (String fullTarget : iqnList) {
        StorageServerConnections con = StorageServerConnections.copyOf(getParameters().getConnection());
        // fullTarget format: <ip>:<port>, <portal> <targetName>
        // e.g 10.35.104.8:3600,1 blue-20G
        String[] tokens = fullTarget.split(",");
        String[] address = tokens[0].split(":");
        String[] literals = tokens[1].split(" ");
        con.setport(address[1]);
        con.setportal(literals[0]);
        con.setiqn(literals[1]);
        // address[0] is the IP address of the target as returned from VDSM.
        // Since we want to use the original address from the user's input (which can also be a host name),
        // and since VDSM always returns the IP address of the target, we don't want to override it
        // by calling con.setconnection(address[0]).
        log.info("Connection to {} requested, VDSM returned {}.", con.getconnection(), address[0]);
        connections.add(con);
    }
    return connections;
}
#end_block

#method_before
public void run() {
    MessageContext context = null;
    ObjectMapper mapper = new ObjectMapper();
    while (true) {
        try {
            context = this.queue.take();
            if (context.getClient() == null) {
                break;
            }
            if (log.isDebugEnabled()) {
                log.debug("Message received: " + new String(context.getMessage(), UTF8));
            }
            JsonNode rootNode = mapper.readTree(context.getMessage());
            if (!rootNode.isArray()) {
                processIncomingObject(context.getClient(), rootNode);
            } else {
                final Iterator<JsonNode> iter = rootNode.getElements();
                while (iter.hasNext()) {
                    final JsonNode node = iter.next();
                    processIncomingObject(context.getClient(), node);
                }
            }
        } catch (Exception e) {
            log.warn("Exception thrown during message processing");
            continue;
        }
    }
}
#method_after
public void run() {
    MessageContext context = null;
    ObjectMapper mapper = new ObjectMapper();
    while (true) {
        try {
            context = this.queue.take();
            if (context.getClient() == null) {
                break;
            }
            if (log.isDebugEnabled()) {
                log.debug("Message received: " + new String(context.getMessage(), UTF8));
            }
            JsonNode rootNode = mapper.readTree(context.getMessage());
            if (!rootNode.isArray()) {
                processIncomingObject(context.getClient(), rootNode);
            } else {
                final Iterator<JsonNode> iter = rootNode.getElements();
                while (iter.hasNext()) {
                    final JsonNode node = iter.next();
                    processIncomingObject(context.getClient(), node);
                }
            }
        } catch (Exception e) {
            log.warn("Exception thrown during message processing");
            if (log.isDebugEnabled()) {
                log.debug(e.getMessage(), e);
            }
            continue;
        }
    }
}
#end_block

#method_before
public T call() throws Exception {
    while (true) {
        try {
            return this.callable.call();
        } catch (Exception e) {
            log.warn("Retry failed");
            if (this.context.isExceptionRetryable(e)) {
                log.warn("Retry failed");
                this.context.decreaseAttempts();
                if (this.context.getNumberOfAttempts() <= 0) {
                    throw e;
                }
                this.context.waitOperation();
                continue;
            } else {
                throw e;
            }
        }
    }
}
#method_after
public T call() throws Exception {
    while (true) {
        try {
            return this.callable.call();
        } catch (Exception e) {
            log.warn("Retry failed");
            if (log.isDebugEnabled()) {
                log.debug(e.getMessage(), e);
            }
            if (this.context.isExceptionRetryable(e)) {
                this.context.decreaseAttempts();
                if (this.context.getNumberOfAttempts() <= 0) {
                    throw e;
                }
                this.context.waitOperation();
                continue;
            } else {
                throw e;
            }
        }
    }
}
#end_block

#method_before
@Override
public C list() {
    // This query is loading the collection of containers of the devices, not the devices themselves. For example,
    // when requesting the CDROMs of a VM this query will actually load a collection contain the VM, not the CDROMs.
    // The result will be null if there is no such VM (if the user provided an incorrect id, or if the VM has been
    // removed) and in that case we need to respond with the 404 error code.
    List<Q> collection = getBackendCollection(queryType, queryParams);
    if (collection == null || collection.isEmpty()) {
        throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
    return mapCollection(collection);
}
#method_after
@Override
public C list() {
    // This query is loading the collection of containers of the devices, not the devices themselves. For example,
    // when requesting the CDROMs of a VM this query will actually load a collection contain the VM, not the CDROMs.
    // The result will be null if there is no such VM (if the user provided an incorrect id, or if the VM has been
    // removed) and in that case we need to respond with the 404 error code.
    List<Q> collection = getBackendCollection(queryType, queryParams);
    if (CollectionUtils.isEmpty(collection)) {
        throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
    return mapCollection(collection);
}
#end_block

#method_before
public Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    } else if (entity instanceof DiskProfile) {
        return ((DiskProfile) entity).getId();
    } else if (entity instanceof CpuProfile) {
        return ((CpuProfile) entity).getId();
    }
    return Guid.Empty;
}
#method_after
public <T extends Guid> T getEntityGuid(BusinessEntity<T> entity) {
    return entity.getId();
}
#end_block

#method_before
public Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    } else if (entity instanceof DiskProfile) {
        return ((DiskProfile) entity).getId();
    } else if (entity instanceof CpuProfile) {
        return ((CpuProfile) entity).getId();
    }
    return Guid.Empty;
}
#method_after
public Guid getEntityGuid(Object entity) {
    if (entity instanceof BusinessEntity) {
        // BusinessEntity can have lot of different ID types, but from this context it cannot be determined.
        Object id = ((BusinessEntity<?>) entity).getId();
        // check whether result can be casted to Guid, otherwise continue with explicit rules.
        if (id instanceof Guid) {
            return (Guid) id;
        }
    }
    if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else {
        return Guid.Empty;
    }
}
#end_block

#method_before
private static boolean isBalloonEnabled(VmManagementParametersBase params) {
    Boolean balloonEnabled = params.isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : VmDeviceUtils.isBalloonEnabled(params.getVmStaticData().getId());
}
#method_after
private static boolean isBalloonEnabled(VmManagementParametersBase params) {
    Boolean balloonEnabled = params.isBalloonEnabled();
    return (balloonEnabled != null) ? balloonEnabled : isBalloonEnabled(params.getVmStaticData().getId());
}
#end_block

#method_before
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    // as the sorted list is being saved in the parameters.
    if (isFirstTaskHandler()) {
        // Retrieve and sort the entire chain of images
        List<DiskImage> images = getAllImages();
        ImagesHandler.sortImageList(images);
        // Get a sorted list of the selected images
        List<DiskImage> sortedImages = LinqUtils.filter(images, new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage image) {
                return getImages().contains(image);
            }
        });
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(sortedImages)));
    }
    for (Guid imageId : getParameters().getImageIds()) {
        taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
    }
    return taskHandlers;
}
#method_after
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    // as the sorted list is being saved in the parameters.
    if (isFirstTaskHandler()) {
        // Retrieve and sort the entire chain of images
        List<DiskImage> images = getAllImagesForDisk();
        ImagesHandler.sortImageList(images);
        // Get a sorted list of the selected images
        List<DiskImage> sortedImages = LinqUtils.filter(images, new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage image) {
                return getImages().contains(image);
            }
        });
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(sortedImages)));
    }
    for (Guid imageId : getParameters().getImageIds()) {
        taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
    }
    return taskHandlers;
}
#end_block

#method_before
@Before
public void setUp() {
    RemoveDiskSnapshotsParameters params = new RemoveDiskSnapshotsParameters(new ArrayList<>(Arrays.asList(IMAGE_ID_1, IMAGE_ID_2)));
    Guid vmGuid = Guid.newGuid();
    params.setContainerId(vmGuid);
    cmd = spy(new RemoveDiskSnapshotsCommand<RemoveDiskSnapshotsParameters>(params) {

        protected List<DiskImage> getImages() {
            return mockImages();
        }

        protected List<DiskImage> getAllImages() {
            return mockAllImages();
        }
    });
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    doReturn(spDao).when(cmd).getStoragePoolDAO();
    doReturn(vmTemplateDAO).when(cmd).getVmTemplateDAO();
    doReturn(diskImageDAO).when(cmd).getDiskImageDao();
    doReturn(diskDao).when(cmd).getDiskDao();
    doReturn(sdDAO).when(cmd).getStorageDomainDAO();
    doReturn(vmDeviceDao).when(cmd).getVmDeviceDao();
    doReturn(snapshotsValidator).when(cmd).getSnapshotsValidator();
    doReturn(STORAGE_POOLD_ID).when(cmd).getStoragePoolId();
    doReturn(mockImages()).when(cmd).getImages();
    mockVm();
    vmValidator = spy(new VmValidator(cmd.getVm()));
    doReturn(vmValidator).when(cmd).createVmValidator(any(VM.class));
    diskImagesValidator = spy(new DiskImagesValidator(mockImages()));
    doReturn(diskImagesValidator).when(cmd).createDiskImageValidator(any(List.class));
    doReturn(ValidationResult.VALID).when(diskImagesValidator).diskImagesNotExist();
    doReturn(ValidationResult.VALID).when(diskImagesValidator).diskImagesSnapshotsNotAttachedToOtherVms(false);
    diskSnapshotsValidator = spy(new DiskSnapshotsValidator(mockImages()));
    doReturn(diskSnapshotsValidator).when(cmd).createDiskSnapshotsValidator(any(List.class));
}
#method_after
@Before
public void setUp() {
    RemoveDiskSnapshotsParameters params = new RemoveDiskSnapshotsParameters(new ArrayList<>(Arrays.asList(IMAGE_ID_1, IMAGE_ID_2)));
    Guid vmGuid = Guid.newGuid();
    params.setContainerId(vmGuid);
    cmd = spy(new RemoveDiskSnapshotsCommand<RemoveDiskSnapshotsParameters>(params) {

        protected List<DiskImage> getImages() {
            return mockImages();
        }

        protected List<DiskImage> getAllImagesForDisk() {
            return mockAllImages();
        }
    });
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    doReturn(spDao).when(cmd).getStoragePoolDAO();
    doReturn(vmTemplateDAO).when(cmd).getVmTemplateDAO();
    doReturn(diskImageDAO).when(cmd).getDiskImageDao();
    doReturn(diskDao).when(cmd).getDiskDao();
    doReturn(sdDAO).when(cmd).getStorageDomainDAO();
    doReturn(vmDeviceDao).when(cmd).getVmDeviceDao();
    doReturn(snapshotsValidator).when(cmd).getSnapshotsValidator();
    doReturn(STORAGE_POOLD_ID).when(cmd).getStoragePoolId();
    doReturn(mockImages()).when(cmd).getImages();
    mockVm();
    vmValidator = spy(new VmValidator(cmd.getVm()));
    doReturn(vmValidator).when(cmd).createVmValidator(any(VM.class));
    diskImagesValidator = spy(new DiskImagesValidator(mockImages()));
    doReturn(diskImagesValidator).when(cmd).createDiskImageValidator(any(List.class));
    doReturn(ValidationResult.VALID).when(diskImagesValidator).diskImagesNotExist();
    doReturn(ValidationResult.VALID).when(diskImagesValidator).diskImagesSnapshotsNotAttachedToOtherVms(false);
    diskSnapshotsValidator = spy(new DiskSnapshotsValidator(mockImages()));
    doReturn(diskSnapshotsValidator).when(cmd).createDiskSnapshotsValidator(any(List.class));
}
#end_block

#method_before
public boolean attemptConnection() {
    boolean connected = false;
    try {
        for (int i = 0; i < NUMBER_OF_ATTEMPTS; i++) {
            long timeout = Config.<Integer>getValue(ConfigValues.SetupNetworksPollingTimeout);
            FutureVDSCall<VDSReturnValue> task = Backend.getInstance().getResourceManager().runFutureVdsCommand(FutureVDSCommandType.TimeBoundPoll, new TimeBoundPollVDSCommandParameters(vds.getId(), timeout, TimeUnit.SECONDS));
            VDSReturnValue returnValue = task.get(timeout, TimeUnit.SECONDS);
            connected = returnValue.getSucceeded();
            if (connected) {
                break;
            }
            Thread.sleep(CONNECT_WAIT);
        }
    } catch (TimeoutException | InterruptedException ignored) {
    }
    return connected;
}
#method_after
public boolean attemptConnection() {
    boolean connected = false;
    try {
        for (int i = 0; i < this.retryAttempts; i++) {
            long timeout = Config.<Integer>getValue(ConfigValues.SetupNetworksPollingTimeout);
            FutureVDSCall<VDSReturnValue> task = Backend.getInstance().getResourceManager().runFutureVdsCommand(FutureVDSCommandType.TimeBoundPoll, new TimeBoundPollVDSCommandParameters(vds.getId(), timeout, TimeUnit.SECONDS));
            VDSReturnValue returnValue = task.get(timeout, TimeUnit.SECONDS);
            connected = returnValue.getSucceeded();
            if (connected) {
                break;
            }
            Thread.sleep(this.connectionTimeout);
        }
    } catch (TimeoutException | InterruptedException ignored) {
    }
    return connected;
}
#end_block

#method_before
private void installHost() {
    try (final VdsDeploy installer = new VdsDeploy(getVds())) {
        log.infoFormat("Before Installation host {0}, {1}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        installer.setCorrelationId(getCorrelationId());
        boolean configureNetworkUsingHostDeploy = !FeatureSupported.setupManagementNetwork(getVds().getVdsGroupCompatibilityVersion());
        installer.setReboot(parameters.isRebootAfterInstallation() && configureNetworkUsingHostDeploy);
        if (configureNetworkUsingHostDeploy) {
            installer.setManagementNetwork(NetworkUtils.getEngineNetwork());
        }
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = getDbFacade().getProviderDao().get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                installer.setOpenStackAgentProperties(agentProperties);
            }
        }
        switch(getVds().getVdsType()) {
            case VDS:
                installer.setFirewall(parameters.getOverrideFirewall());
                break;
            case oVirtNode:
                if (parameters.getOverrideFirewall()) {
                    log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getName(), getVds().getVdsType().name());
                }
                break;
            default:
                throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
        }
        switch(getParameters().getAuthMethod()) {
            case Password:
                installer.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                installer.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        installer.execute();
        switch(installer.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                setVdsStatus(VDSStatus.Reboot);
                RunSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                if (checkProtocolTofallback(getVds())) {
                    // we need to check whether we are connecting to vdsm which supports xmlrpc only
                    ProtocolDetector detector = new ProtocolDetector(getVds());
                    if (!detector.attemptConnection()) {
                        detector.stopConnection();
                        if (detector.attemptFallbackProtocol()) {
                            detector.setFallbackProtocol();
                        } else {
                            throw new VdsInstallException(VDSStatus.InstallFailed, "Host not reachable");
                        }
                    }
                }
                if (!configureNetworkUsingHostDeploy) {
                    configureManagementNetwork();
                }
                if (!getParameters().getActivateHost() && VDSStatus.Maintenance.equals(vdsInitialStatus)) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.infoFormat("After Installation host {0}, {1}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#method_after
private void installHost() {
    try (final VdsDeploy installer = new VdsDeploy(getVds())) {
        log.info("Before Installation host {}, {}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        installer.setCorrelationId(getCorrelationId());
        boolean configureNetworkUsingHostDeploy = !FeatureSupported.setupManagementNetwork(getVds().getVdsGroupCompatibilityVersion());
        installer.setReboot(parameters.isRebootAfterInstallation() && configureNetworkUsingHostDeploy);
        if (configureNetworkUsingHostDeploy) {
            installer.setManagementNetwork(NetworkUtils.getEngineNetwork());
        }
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = getDbFacade().getProviderDao().get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                installer.setOpenStackAgentProperties(agentProperties);
            }
        }
        switch(getVds().getVdsType()) {
            case VDS:
                installer.setFirewall(parameters.getOverrideFirewall());
                break;
            case oVirtNode:
                if (parameters.getOverrideFirewall()) {
                    log.warn("Installation of Host {} will ignore Firewall Override option, since it is not supported for Host type {}", getVds().getName(), getVds().getVdsType().name());
                }
                break;
            default:
                throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
        }
        switch(getParameters().getAuthMethod()) {
            case Password:
                installer.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                installer.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        installer.execute();
        switch(installer.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                setVdsStatus(VDSStatus.Reboot);
                RunSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                if (checkProtocolTofallback(getVds())) {
                    // we need to check whether we are connecting to vdsm which supports xmlrpc only
                    ProtocolDetector detector = new ProtocolDetector(getVds());
                    if (!detector.attemptConnection()) {
                        detector.stopConnection();
                        if (detector.attemptFallbackProtocol()) {
                            detector.setFallbackProtocol();
                        } else {
                            throw new VdsInstallException(VDSStatus.InstallFailed, "Host not reachable");
                        }
                    }
                }
                if (!configureNetworkUsingHostDeploy) {
                    configureManagementNetwork();
                }
                if (!getParameters().getActivateHost() && VDSStatus.Maintenance.equals(vdsInitialStatus)) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.info("After Installation host {}, {}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#end_block

#method_before
public boolean attemptConnection() {
    boolean connected = false;
    try {
        for (int i = 0; i < 3; i++) {
            long timeout = Config.<Integer>getValue(ConfigValues.SetupNetworksPollingTimeout);
            FutureVDSCall<VDSReturnValue> task = Backend.getInstance().getResourceManager().runFutureVdsCommand(FutureVDSCommandType.TimeBoundPoll, new TimeBoundPollVDSCommandParameters(vds.getId(), timeout, TimeUnit.SECONDS));
            VDSReturnValue returnValue = task.get(timeout, TimeUnit.SECONDS);
            connected = returnValue.getSucceeded();
            if (connected) {
                break;
            }
            Thread.sleep(CONNECT_WAIT);
        }
    } catch (TimeoutException | InterruptedException ignored) {
    }
    return connected;
}
#method_after
public boolean attemptConnection() {
    boolean connected = false;
    try {
        for (int i = 0; i < this.retryAttempts; i++) {
            long timeout = Config.<Integer>getValue(ConfigValues.SetupNetworksPollingTimeout);
            FutureVDSCall<VDSReturnValue> task = Backend.getInstance().getResourceManager().runFutureVdsCommand(FutureVDSCommandType.TimeBoundPoll, new TimeBoundPollVDSCommandParameters(vds.getId(), timeout, TimeUnit.SECONDS));
            VDSReturnValue returnValue = task.get(timeout, TimeUnit.SECONDS);
            connected = returnValue.getSucceeded();
            if (connected) {
                break;
            }
            Thread.sleep(this.connectionTimeout);
        }
    } catch (TimeoutException | InterruptedException ignored) {
    }
    return connected;
}
#end_block

#method_before
@SuppressWarnings("serial")
private void removeDeletedBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (final GlusterBrickEntity existingBrick : existingVolume.getBricks()) {
        if (!GlusterCoreUtil.containsBrick(fetchedBricks, existingBrick)) {
            idsToRemove.add(existingBrick.getId());
            log.info("Detected brick '{}' removed from volume '{}'. Removing it from engine DB as well.", existingBrick.getQualifiedName(), existingVolume.getName());
            logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, new HashMap<String, String>() {

                {
                    put(GlusterConstants.BRICK, existingBrick.getQualifiedName());
                }
            });
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getBrickDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing bricks from database!", e);
        }
    }
}
#method_after
@SuppressWarnings("serial")
private void removeDeletedBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (final GlusterBrickEntity existingBrick : existingVolume.getBricks()) {
        if (!GlusterCoreUtil.containsBrick(fetchedBricks, existingBrick)) {
            idsToRemove.add(existingBrick.getId());
            log.info("Detected brick '{}' removed from volume '{}'. Removing it from engine DB as well.", existingBrick.getQualifiedName(), existingVolume.getName());
            logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, new HashMap<String, String>() {

                {
                    put(GlusterConstants.BRICK, existingBrick.getQualifiedName());
                }
            });
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getBrickDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.error("Error while removing bricks from database: {}", e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation(DWH_HEART_BEAT_METHOD)
public void engineIsRunningNotification() {
    try {
        heartBeatVar.setDateTime(new Date());
        DbFacade.getInstance().getDwhHistoryTimekeepingDao().save(heartBeatVar);
    } catch (Exception ex) {
        log.error("Error updating DWH Heart Beat: ", ex);
    }
}
#method_after
@OnTimerMethodAnnotation(DWH_HEART_BEAT_METHOD)
public void engineIsRunningNotification() {
    try {
        heartBeatVar.setDateTime(new Date());
        DbFacade.getInstance().getDwhHistoryTimekeepingDao().save(heartBeatVar);
    } catch (Exception ex) {
        log.error("Error updating DWH Heart Beat: {}", ex.getMessage());
        log.debug("Exception", ex);
    }
}
#end_block

#method_before
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        ArrayList<DiskImage> images = new ArrayList<DiskImage>();
        ArrayList<VmNetworkInterface> interfaces = new ArrayList<VmNetworkInterface>();
        new OvfManager().ImportVm(configuration, tempVM, images, interfaces);
        for (DiskImage diskImage : images) {
            DiskImage dbImage = getDiskImageDao().getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        vm.setImages(images);
        vm.setInterfaces(interfaces);
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setDedicatedVmForVds(oldVmStatic.getDedicatedVmForVds());
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setVdsGroupId(oldVmStatic.getVdsGroupId());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = getVmStaticDao().get(vm.getId());
        if (vmStaticFromDb != null) {
            VDSGroup vdsGroup = getVdsGroupDao().get(vmStaticFromDb.getVdsGroupId());
            if (vdsGroup != null) {
                vm.setStoragePoolId(vdsGroup.getStoragePoolId());
                vm.setVdsGroupCompatibilityVersion(vdsGroup.getcompatibility_version());
                vm.setVdsGroupName(vdsGroup.getName());
                vm.setVdsGroupCpuName(vdsGroup.getcpu_name());
            }
        }
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}'.", configuration);
        log.error("Exception", e);
        return false;
    }
}
#method_after
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        ArrayList<DiskImage> images = new ArrayList<DiskImage>();
        ArrayList<VmNetworkInterface> interfaces = new ArrayList<VmNetworkInterface>();
        new OvfManager().ImportVm(configuration, tempVM, images, interfaces);
        for (DiskImage diskImage : images) {
            DiskImage dbImage = getDiskImageDao().getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        vm.setImages(images);
        vm.setInterfaces(interfaces);
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setDedicatedVmForVds(oldVmStatic.getDedicatedVmForVds());
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setVdsGroupId(oldVmStatic.getVdsGroupId());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = getVmStaticDao().get(vm.getId());
        if (vmStaticFromDb != null) {
            VDSGroup vdsGroup = getVdsGroupDao().get(vmStaticFromDb.getVdsGroupId());
            if (vdsGroup != null) {
                vm.setStoragePoolId(vdsGroup.getStoragePoolId());
                vm.setVdsGroupCompatibilityVersion(vdsGroup.getcompatibility_version());
                vm.setVdsGroupName(vdsGroup.getName());
                vm.setVdsGroupCpuName(vdsGroup.getcpu_name());
            }
        }
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}': {}", configuration, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#end_block

#method_before
public static void init() {
    File trustStoreFile = new File(getTrustStorePath());
    if (!trustStoreFile.exists()) {
        try (OutputStream out = new FileOutputStream(trustStoreFile)) {
            String password = EngineLocalConfig.getInstance().getPKITrustStorePassword();
            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
            // Passing null stream will create a new empty trust store
            trustStore.load(null, password.toCharArray());
            trustStore.store(out, password.toCharArray());
        } catch (Exception e) {
            log.error("Creation of the external trust store failed.", e);
        }
    }
}
#method_after
public static void init() {
    File trustStoreFile = new File(getTrustStorePath());
    if (!trustStoreFile.exists()) {
        try (OutputStream out = new FileOutputStream(trustStoreFile)) {
            String password = EngineLocalConfig.getInstance().getPKITrustStorePassword();
            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
            // Passing null stream will create a new empty trust store
            trustStore.load(null, password.toCharArray());
            trustStore.store(out, password.toCharArray());
        } catch (Exception e) {
            log.error("Creation of the external trust store failed: {}", e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@Override
public EventResult submitEventSync(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = submitTaskInternal(event, callable);
    if (task != null) {
        try {
            return task.get();
        } catch (CancellationException e) {
            // CancellationException is normal here, as we cancel future tasks when reconstruct is running
            // This cancellation is also being reported to the log
            // Currently ignoring that exception, writing a debug message, in case other scenario of canceling an exception will be introduced
            log.debug("Failed to submit event using submitEventSync (the event was cancelled)- pool '{}'", event.getStoragePoolId());
            log.debug("Exception", e);
        } catch (Exception e) {
            log.error("Failed at submitEventSync, for pool '{}'", event.getStoragePoolId());
            log.error("Exception", e);
        }
    }
    return null;
}
#method_after
@Override
public EventResult submitEventSync(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = submitTaskInternal(event, callable);
    if (task != null) {
        try {
            return task.get();
        } catch (CancellationException e) {
            // CancellationException is normal here, as we cancel future tasks when reconstruct is running
            // This cancellation is also being reported to the log
            // Currently ignoring that exception, writing a debug message, in case other scenario of canceling an exception will be introduced
            log.debug("Failed to submit event using submitEventSync (the event was cancelled)- pool '{}'", event.getStoragePoolId());
            log.debug("Exception", e);
        } catch (Exception e) {
            log.error("Failed at submitEventSync, for pool '{}': {}", event.getStoragePoolId(), e.getMessage());
            log.debug("Exception", e);
        }
    }
    return null;
}
#end_block

#method_before
@Override
public void run() {
    while (true) {
        Pair<Event, FutureTask<EventResult>> pair;
        lock.lock();
        try {
            pair = poolsEventsMap.get(storagePoolId).poll();
            if (pair != null) {
                poolCurrentEventMap.put(storagePoolId, pair.getFirst());
            } else {
                poolCurrentEventMap.remove(storagePoolId);
                poolsEventsMap.remove(storagePoolId);
                log.debug("All task for event query were executed pool '{}'", storagePoolId);
                break;
            }
        } finally {
            lock.unlock();
        }
        Future<EventResult> futureResult = ThreadPoolUtil.execute(pair.getSecond());
        try {
            if (futureResult.get() == null) {
                EventResult result = pair.getSecond().get();
                if (result != null && result.getEventType() == EventType.RECONSTRUCT) {
                    log.info("Finished reconstruct for pool '{}'. Clearing event queue", storagePoolId);
                    lock.lock();
                    try {
                        LinkedList<Pair<Event, FutureTask<EventResult>>> queue = new LinkedList<Pair<Event, FutureTask<EventResult>>>();
                        for (Pair<Event, FutureTask<EventResult>> task : poolsEventsMap.get(storagePoolId)) {
                            EventType eventType = task.getFirst().getEventType();
                            if (eventType == EventType.VDSCONNECTTOPOOL || ((eventType == EventType.RECOVERY || eventType == EventType.DOMAINFAILOVER || eventType == EventType.VDSCLEARCACHE) && !result.isSuccess())) {
                                queue.add(task);
                            } else {
                                log.info("The following operation '{}' was cancelled, because of reconstruct was run before", task.getFirst());
                                task.getSecond().cancel(true);
                            }
                        }
                        if (queue.isEmpty()) {
                            poolCurrentEventMap.remove(storagePoolId);
                            poolsEventsMap.remove(storagePoolId);
                            break;
                        } else {
                            poolsEventsMap.put(storagePoolId, queue);
                        }
                    } finally {
                        lock.unlock();
                    }
                }
            }
        } catch (Exception e) {
            log.error("Exception during process of events for pool '{}'", storagePoolId);
            log.error("Exception", e);
        }
    }
}
#method_after
@Override
public void run() {
    while (true) {
        Pair<Event, FutureTask<EventResult>> pair;
        lock.lock();
        try {
            pair = poolsEventsMap.get(storagePoolId).poll();
            if (pair != null) {
                poolCurrentEventMap.put(storagePoolId, pair.getFirst());
            } else {
                poolCurrentEventMap.remove(storagePoolId);
                poolsEventsMap.remove(storagePoolId);
                log.debug("All task for event query were executed pool '{}'", storagePoolId);
                break;
            }
        } finally {
            lock.unlock();
        }
        Future<EventResult> futureResult = ThreadPoolUtil.execute(pair.getSecond());
        try {
            if (futureResult.get() == null) {
                EventResult result = pair.getSecond().get();
                if (result != null && result.getEventType() == EventType.RECONSTRUCT) {
                    log.info("Finished reconstruct for pool '{}'. Clearing event queue", storagePoolId);
                    lock.lock();
                    try {
                        LinkedList<Pair<Event, FutureTask<EventResult>>> queue = new LinkedList<Pair<Event, FutureTask<EventResult>>>();
                        for (Pair<Event, FutureTask<EventResult>> task : poolsEventsMap.get(storagePoolId)) {
                            EventType eventType = task.getFirst().getEventType();
                            if (eventType == EventType.VDSCONNECTTOPOOL || ((eventType == EventType.RECOVERY || eventType == EventType.DOMAINFAILOVER || eventType == EventType.VDSCLEARCACHE) && !result.isSuccess())) {
                                queue.add(task);
                            } else {
                                log.info("The following operation '{}' was cancelled, because of reconstruct was run before", task.getFirst());
                                task.getSecond().cancel(true);
                            }
                        }
                        if (queue.isEmpty()) {
                            poolCurrentEventMap.remove(storagePoolId);
                            poolsEventsMap.remove(storagePoolId);
                            break;
                        } else {
                            poolsEventsMap.put(storagePoolId, queue);
                        }
                    } finally {
                        lock.unlock();
                    }
                }
            }
        } catch (Exception e) {
            log.error("Exception during process of events for pool '{}': {}", storagePoolId, e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
public void initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    succeededJobTime = Config.<Integer>getValue(ConfigValues.SucceededJobCleanupTimeInMinutes).intValue();
    failedJobTime = Config.<Integer>getValue(ConfigValues.FailedJobCleanupTimeInMinutes).intValue();
    Integer cleanupFrequency = Config.<Integer>getValue(ConfigValues.JobCleanupRateInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "completed_jobs_cleanup", new Class[] {}, new Object[] {}, cleanupFrequency, cleanupFrequency, TimeUnit.MINUTES);
    log.info("Finished initializing " + getClass().getSimpleName());
}
#method_after
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    succeededJobTime = Config.<Integer>getValue(ConfigValues.SucceededJobCleanupTimeInMinutes).intValue();
    failedJobTime = Config.<Integer>getValue(ConfigValues.FailedJobCleanupTimeInMinutes).intValue();
    Integer cleanupFrequency = Config.<Integer>getValue(ConfigValues.JobCleanupRateInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "completed_jobs_cleanup", new Class[] {}, new Object[] {}, cleanupFrequency, cleanupFrequency, TimeUnit.MINUTES);
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
@OnTimerMethodAnnotation("completed_jobs_cleanup")
public void cleanCompletedJob() {
    Date succeededJobsDeleteTime = new Date(System.currentTimeMillis() - TimeUnit.MILLISECONDS.convert(succeededJobTime, TimeUnit.MINUTES));
    Date failedJobsDeleteTime = new Date(System.currentTimeMillis() - TimeUnit.MILLISECONDS.convert(failedJobTime, TimeUnit.MINUTES));
    try {
        DbFacade.getInstance().getJobDao().deleteCompletedJobs(succeededJobsDeleteTime, failedJobsDeleteTime);
    } catch (RuntimeException e) {
        log.error("Failed to delete completed jobs", e);
    }
}
#method_after
@OnTimerMethodAnnotation("completed_jobs_cleanup")
public void cleanCompletedJob() {
    Date succeededJobsDeleteTime = new Date(System.currentTimeMillis() - TimeUnit.MILLISECONDS.convert(succeededJobTime, TimeUnit.MINUTES));
    Date failedJobsDeleteTime = new Date(System.currentTimeMillis() - TimeUnit.MILLISECONDS.convert(failedJobTime, TimeUnit.MINUTES));
    try {
        DbFacade.getInstance().getJobDao().deleteCompletedJobs(succeededJobsDeleteTime, failedJobsDeleteTime);
    } catch (RuntimeException e) {
        log.error("Failed to delete completed jobs: {}", e.getMessage());
        log.debug("Exception", e);
    }
}
#end_block

#method_before
@Override
public void saveStep(final Step step) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            try {
                jobDao.updateJobLastUpdateTime(step.getJobId(), new Date());
                stepDao.save(step);
            } catch (Exception e) {
                log.error("Failed to save step '{}', '{}'.", step.getId(), step.getStepName());
                log.error("Exception", e);
            }
            return null;
        }
    });
}
#method_after
@Override
public void saveStep(final Step step) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            try {
                jobDao.updateJobLastUpdateTime(step.getJobId(), new Date());
                stepDao.save(step);
            } catch (Exception e) {
                log.error("Failed to save step '{}', '{}': {}", step.getId(), step.getStepName(), e.getMessage());
                log.debug("Exception", e);
            }
            return null;
        }
    });
}
#end_block

#method_before
@Override
public void updateStep(final Step step) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            try {
                jobDao.updateJobLastUpdateTime(step.getJobId(), new Date());
                stepDao.update(step);
            } catch (Exception e) {
                log.errorFormat("Failed to update step {0}, {1}.", step.getId(), step.getStepName(), e);
            }
            return null;
        }
    });
}
#method_after
@Override
public void updateStep(final Step step) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            try {
                jobDao.updateJobLastUpdateTime(step.getJobId(), new Date());
                stepDao.update(step);
            } catch (Exception e) {
                log.error("Failed to update step '{}', '{}': {}", step.getId(), step.getStepName(), e.getMessage());
                log.debug("Exception", e);
            }
            return null;
        }
    });
}
#end_block

#method_before
public static void endTaskStep(Guid stepId, JobExecutionStatus exitStatus) {
    try {
        if (stepId != null) {
            Step step = JobRepositoryFactory.getJobRepository().getStep(stepId);
            if (step != null) {
                step.markStepEnded(exitStatus);
                JobRepositoryFactory.getJobRepository().updateStep(step);
            }
        }
    } catch (Exception e) {
        log.error("Failed to terminate step '{}' with status '{}'", stepId, exitStatus);
        log.error("Exception", e);
    }
}
#method_after
public static void endTaskStep(Guid stepId, JobExecutionStatus exitStatus) {
    try {
        if (stepId != null) {
            Step step = JobRepositoryFactory.getJobRepository().getStep(stepId);
            if (step != null) {
                step.markStepEnded(exitStatus);
                JobRepositoryFactory.getJobRepository().updateStep(step);
            }
        }
    } catch (Exception e) {
        log.error("Failed to terminate step '{}' with status '{}': {}", stepId, exitStatus, e.getMessage());
        log.debug("Exception", e);
    }
}
#end_block

#method_before
public static void prepareCommandForMonitoring(CommandBase<?> command, VdcActionType actionType, boolean runAsInternal) {
    ExecutionContext context = command.getExecutionContext();
    if (context == null) {
        context = new ExecutionContext();
    }
    try {
        boolean isMonitored = shouldMonitorCommand(actionType, runAsInternal);
        // A monitored job is created for monitored external flows
        if (isMonitored || context.isJobRequired()) {
            Job job = getJob(command, actionType);
            context.setExecutionMethod(ExecutionMethod.AsJob);
            context.setJob(job);
            command.setExecutionContext(context);
            command.setJobId(job.getId());
            context.setMonitored(true);
        }
    } catch (Exception e) {
        log.error("Failed to prepare command of type '{}' for monitoring due to error '{}'", actionType.name(), ExceptionUtils.getMessage(e));
        log.error("Exception", e);
    }
}
#method_after
public static void prepareCommandForMonitoring(CommandBase<?> command, VdcActionType actionType, boolean runAsInternal) {
    ExecutionContext context = command.getExecutionContext();
    if (context == null) {
        context = new ExecutionContext();
    }
    try {
        boolean isMonitored = shouldMonitorCommand(actionType, runAsInternal);
        // A monitored job is created for monitored external flows
        if (isMonitored || context.isJobRequired()) {
            Job job = getJob(command, actionType);
            context.setExecutionMethod(ExecutionMethod.AsJob);
            context.setJob(job);
            command.setExecutionContext(context);
            command.setJobId(job.getId());
            context.setMonitored(true);
        }
    } catch (Exception e) {
        log.error("Failed to prepare command of type '{}' for monitoring due to error '{}'", actionType.name(), e.getMessage());
        log.debug("Exception", e);
    }
}
#end_block

#method_before
public static Step addStep(ExecutionContext context, StepEnum stepName, String description, boolean isExternal) {
    if (context == null) {
        return null;
    }
    Step step = null;
    if (context.isMonitored()) {
        if (description == null) {
            description = ExecutionMessageDirector.getInstance().getStepMessage(stepName);
        }
        try {
            Job job = context.getJob();
            if (context.getExecutionMethod() == ExecutionMethod.AsJob && job != null) {
                step = job.addStep(stepName, description);
                try {
                    step.setExternal(isExternal);
                    JobRepositoryFactory.getJobRepository().saveStep(step);
                } catch (Exception e) {
                    log.error("Failed to save new step '{}' for job '{}', '{}'.", stepName.name(), job.getId(), job.getActionType().name());
                    log.error("Exception", e);
                    job.getSteps().remove(step);
                    step = null;
                }
            } else {
                Step contextStep = context.getStep();
                if (context.getExecutionMethod() == ExecutionMethod.AsStep && contextStep != null) {
                    step = addSubStep(contextStep, stepName, description);
                    step.setExternal(isExternal);
                }
            }
        } catch (Exception e) {
            log.error("Exception", e);
        }
    }
    return step;
}
#method_after
public static Step addStep(ExecutionContext context, StepEnum stepName, String description, boolean isExternal) {
    if (context == null) {
        return null;
    }
    Step step = null;
    if (context.isMonitored()) {
        if (description == null) {
            description = ExecutionMessageDirector.getInstance().getStepMessage(stepName);
        }
        try {
            Job job = context.getJob();
            if (context.getExecutionMethod() == ExecutionMethod.AsJob && job != null) {
                step = job.addStep(stepName, description);
                try {
                    step.setExternal(isExternal);
                    JobRepositoryFactory.getJobRepository().saveStep(step);
                } catch (Exception e) {
                    log.error("Failed to save new step '{}' for job '{}', '{}': {}", stepName.name(), job.getId(), job.getActionType().name(), e.getMessage());
                    log.debug("Exception", e);
                    job.getSteps().remove(step);
                    step = null;
                }
            } else {
                Step contextStep = context.getStep();
                if (context.getExecutionMethod() == ExecutionMethod.AsStep && contextStep != null) {
                    step = addSubStep(contextStep, stepName, description);
                    step.setExternal(isExternal);
                }
            }
        } catch (Exception e) {
            log.error("Exception", e);
        }
    }
    return step;
}
#end_block

#method_before
private static Step addSubStep(Step parentStep, StepEnum stepName, String description) {
    Step step = null;
    if (parentStep != null) {
        if (description == null) {
            description = ExecutionMessageDirector.getInstance().getStepMessage(stepName);
        }
        step = parentStep.addStep(stepName, description);
        try {
            JobRepositoryFactory.getJobRepository().saveStep(step);
        } catch (Exception e) {
            log.error("Failed to save new step '{}' for step '{}', '{}'.", stepName.name(), parentStep.getId(), parentStep.getStepType().name());
            log.error("Exception", e);
            parentStep.getSteps().remove(step);
            step = null;
        }
    }
    return step;
}
#method_after
private static Step addSubStep(Step parentStep, StepEnum stepName, String description) {
    Step step = null;
    if (parentStep != null) {
        if (description == null) {
            description = ExecutionMessageDirector.getInstance().getStepMessage(stepName);
        }
        step = parentStep.addStep(stepName, description);
        try {
            JobRepositoryFactory.getJobRepository().saveStep(step);
        } catch (Exception e) {
            log.error("Failed to save new step '{}' for step '{}', '{}': {}", stepName.name(), parentStep.getId(), parentStep.getStepType().name(), e.getMessage());
            log.debug("Exception", e);
            parentStep.getSteps().remove(step);
            step = null;
        }
    }
    return step;
}
#end_block

#method_before
private static void endJob(boolean exitStatus, Job job) {
    job.markJobEnded(exitStatus);
    try {
        JobRepositoryFactory.getJobRepository().updateCompletedJobAndSteps(job);
    } catch (Exception e) {
        log.error("Failed to end Job '{}', '{}'", job.getId(), job.getActionType().name());
        log.error("Exception", e);
    }
}
#method_after
private static void endJob(boolean exitStatus, Job job) {
    job.markJobEnded(exitStatus);
    try {
        JobRepositoryFactory.getJobRepository().updateCompletedJobAndSteps(job);
    } catch (Exception e) {
        log.error("Failed to end Job '{}', '{}': {}", job.getId(), job.getActionType().name(), e.getMessage());
        log.debug("Exception", e);
    }
}
#end_block

#method_before
public static void updateStepExternalId(Step step, Guid externalId, ExternalSystemType systemType) {
    if (step != null) {
        step.getExternalSystem().setId(externalId);
        step.getExternalSystem().setType(systemType);
        try {
            JobRepositoryFactory.getJobRepository().updateStep(step);
        } catch (Exception e) {
            log.error("Failed to save step '{}', '{}' for system-type '{}' with id '{}'", step.getId(), step.getStepType().name(), systemType.name(), externalId);
            log.error("Exception", e);
        }
    }
}
#method_after
public static void updateStepExternalId(Step step, Guid externalId, ExternalSystemType systemType) {
    if (step != null) {
        step.getExternalSystem().setId(externalId);
        step.getExternalSystem().setType(systemType);
        try {
            JobRepositoryFactory.getJobRepository().updateStep(step);
        } catch (Exception e) {
            log.error("Failed to save step '{}', '{}' for system-type '{}' with id '{}': {}", step.getId(), step.getStepType().name(), systemType.name(), externalId, e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
private void addPayload(PDU v2pdu, AuditLogEvent event, Profile profile) {
    // { [baseoid] notifications(1) compliance(0) audit(1) }
    v2pdu.add(new VariableBinding(SnmpConstants.snmpTrapOID, new OID(profile.oid).append(1).append(0).append(1)));
    v2pdu.add(new VariableBinding(SnmpConstants.sysUpTime, new TimeTicks((System.nanoTime() - nanoStart) / 10000000)));
    int auditLogId = AuditLogType.UNASSIGNED.getValue();
    try {
        auditLogId = AuditLogType.valueOf(event.getName()).getValue();
    } catch (IllegalArgumentException e) {
        log.warn("Could not find event: " + event.getName() + " in auditLogTypes");
    }
    // { [baseoid] objects(2) audit(1) }
    OID auditObjects = new OID(profile.oid).append(2).append(1);
    v2pdu.add(new VariableBinding(new OID(auditObjects).append(1), new OctetString(event.getName())));
    v2pdu.add(new VariableBinding(new OID(auditObjects).append(2), new Integer32(auditLogId)));
    v2pdu.add(new VariableBinding(new OID(auditObjects).append(3), new Integer32(event.getSeverity().getValue())));
    v2pdu.add(new VariableBinding(new OID(auditObjects).append(4), new OctetString(event.getMessage())));
    v2pdu.add(new VariableBinding(new OID(auditObjects).append(5), new Integer32(event.getType().getValue())));
    v2pdu.add(new VariableBinding(new OID(auditObjects).append(6), new OctetString(ISO8601.format(event.getLogTime()))));
    // Optional pdu:
    if (!StringUtils.isEmpty(event.getUserName())) {
        v2pdu.add(new VariableBinding(new OID(auditObjects).append(7), new OctetString(event.getUserName())));
    }
    if (event.getUserId() != null && !event.getUserId().equals(Guid.Empty)) {
        v2pdu.add(new VariableBinding(new OID(auditObjects).append(8), new OctetString(event.getUserId().toString())));
    }
    if (!StringUtils.isEmpty(event.getVmName())) {
        v2pdu.add(new VariableBinding(new OID(auditObjects).append(9), new OctetString(event.getVmName())));
    }
    if (event.getVmId() != null && !event.getVmId().equals(Guid.Empty)) {
        v2pdu.add(new VariableBinding(new OID(auditObjects).append(10), new OctetString(event.getVmId().toString())));
    }
    if (!StringUtils.isEmpty(event.getVdsName())) {
        v2pdu.add(new VariableBinding(new OID(auditObjects).append(11), new OctetString(event.getVdsName())));
    }
    if (event.getVdsId() != null && !event.getVdsId().equals(Guid.Empty)) {
        v2pdu.add(new VariableBinding(new OID(auditObjects).append(12), new OctetString(event.getVdsId().toString())));
    }
    if (!StringUtils.isEmpty(event.getVmTemplateName())) {
        v2pdu.add(new VariableBinding(new OID(auditObjects).append(13), new OctetString(event.getVmTemplateName())));
    }
    if (event.getVmTemplateId() != null && !event.getVmTemplateId().equals(Guid.Empty)) {
        v2pdu.add(new VariableBinding(new OID(auditObjects).append(14), new OctetString(event.getVmTemplateId().toString())));
    }
    if (!StringUtils.isEmpty(event.getStoragePoolName())) {
        v2pdu.add(new VariableBinding(new OID(auditObjects).append(15), new OctetString(event.getStoragePoolName())));
    }
    if (event.getStoragePoolId() != null && !event.getStoragePoolId().equals(Guid.Empty)) {
        v2pdu.add(new VariableBinding(new OID(auditObjects).append(16), new OctetString(event.getStoragePoolId().toString())));
    }
    if (!StringUtils.isEmpty(event.getStorageDomainName())) {
        v2pdu.add(new VariableBinding(new OID(auditObjects).append(17), new OctetString(event.getStorageDomainName())));
    }
    if (event.getStorageDomainId() != null && !event.getStorageDomainId().equals(Guid.Empty)) {
        v2pdu.add(new VariableBinding(new OID(auditObjects).append(18), new OctetString(event.getStorageDomainId().toString())));
    }
}
#method_after
private void addPayload(PDU v2pdu, AuditLogEvent event, Profile profile) {
    v2pdu.add(new VariableBinding(SnmpConstants.sysUpTime, new TimeTicks((System.nanoTime() - nanoStart) / 10000000)));
    // { [baseoid] notifications(0) audit(1) }
    v2pdu.add(new VariableBinding(SnmpConstants.snmpTrapOID, SnmpConstants.getTrapOID(new OID(profile.oid), ENTERPRISE_SPECIFIC, AUDIT)));
    int auditLogId = AuditLogType.UNASSIGNED.getValue();
    try {
        auditLogId = AuditLogType.valueOf(event.getName()).getValue();
    } catch (IllegalArgumentException e) {
        log.warn("Could not find event: " + event.getName() + " in auditLogTypes");
    }
    // { [baseoid] objects(2) audit(1) }
    OID auditObjects = new OID(profile.oid).append(OBJECTS_AUDIT);
    addInt(v2pdu, auditObjects, INSTANCE_ID, auditLogId, true);
    addString(v2pdu, auditObjects, NAME, event.getName(), true);
    addInt(v2pdu, auditObjects, ID, auditLogId, true);
    addInt(v2pdu, auditObjects, SEVERITY, event.getSeverity().getValue(), true);
    addString(v2pdu, auditObjects, MESSAGE, event.getMessage(), true);
    addInt(v2pdu, auditObjects, STATUS, event.getType().getValue(), true);
    addString(v2pdu, auditObjects, DATETIME, new SimpleDateFormat(ISO8601).format(event.getLogTime()), true);
    // Optional pdu:
    addString(v2pdu, auditObjects, USERNAME, event.getUserName(), false);
    addUuid(v2pdu, auditObjects, USER_ID, event.getUserId());
    addString(v2pdu, auditObjects, VM_NAME, event.getVmName(), false);
    addUuid(v2pdu, auditObjects, VM_ID, event.getVmId());
    addString(v2pdu, auditObjects, VDS_NAME, event.getVdsName(), false);
    addUuid(v2pdu, auditObjects, VDS_ID, event.getVdsId());
    addString(v2pdu, auditObjects, VM_TEMPLATE_NAME, event.getVmTemplateName(), false);
    addUuid(v2pdu, auditObjects, VM_TEMPLATE_ID, event.getVmTemplateId());
    addString(v2pdu, auditObjects, STORAGE_POOL_NAME, event.getStoragePoolName(), false);
    addUuid(v2pdu, auditObjects, STORAGE_POOL_ID, event.getStoragePoolId());
    addString(v2pdu, auditObjects, STORAGE_DOMAIN_NAME, event.getStorageDomainName(), false);
    addUuid(v2pdu, auditObjects, STORAGE_DOMAIN_ID, event.getStorageDomainId());
}
#end_block

#method_before
@Mapping(from = ActionGroup.class, to = PermitType.class)
public static PermitType map(ActionGroup entity, PermitType template) {
    try {
        return PermitType.valueOf(entity);
    } catch (IllegalArgumentException e) {
        log.error("Missing mapping '{}' --> '{}': {}", entity, PermitType.class.getName(), e.getMessage());
        log.debug("Exception", e);
        return null;
    }
}
#method_after
@Mapping(from = ActionGroup.class, to = PermitType.class)
public static PermitType map(ActionGroup entity, PermitType template) {
    try {
        return PermitType.valueOf(entity);
    } catch (IllegalArgumentException e) {
        log.error("Missing mapping '{}' --> '{}': {}", entity, PermitType.class.getName(), e.getMessage());
        log.error("Exception", e);
        return null;
    }
}
#end_block

#method_before
private Response getSchema() {
    ByteArrayOutputStream baos = null;
    InputStream is = null;
    byte[] buffer = new byte[4096];
    try {
        baos = new ByteArrayOutputStream();
        is = Thread.currentThread().getContextClassLoader().getResourceAsStream(API_SCHEMA);
        int count;
        while ((count = is.read(buffer)) != -1) {
            baos.write(buffer, 0, count);
        }
        baos.flush();
        return Response.ok(baos.toByteArray(), MediaType.APPLICATION_OCTET_STREAM).header("content-disposition", "attachment; filename = " + SCHEMA_NAME).build();
    } catch (IOException e) {
        log.error("Loading api.xsd file failed: {}", e.getMessage());
        log.debug("Exception", e);
        return Response.serverError().build();
    } finally {
        try {
            if (baos != null)
                baos.close();
            if (is != null)
                is.close();
        } catch (IOException ignored) {
        }
    }
}
#method_after
private Response getSchema() {
    ByteArrayOutputStream baos = null;
    InputStream is = null;
    byte[] buffer = new byte[4096];
    try {
        baos = new ByteArrayOutputStream();
        is = Thread.currentThread().getContextClassLoader().getResourceAsStream(API_SCHEMA);
        int count;
        while ((count = is.read(buffer)) != -1) {
            baos.write(buffer, 0, count);
        }
        baos.flush();
        return Response.ok(baos.toByteArray(), MediaType.APPLICATION_OCTET_STREAM).header("content-disposition", "attachment; filename = " + SCHEMA_NAME).build();
    } catch (IOException e) {
        log.error("Loading api.xsd file failed.", e);
        return Response.serverError().build();
    } finally {
        try {
            if (baos != null)
                baos.close();
            if (is != null)
                is.close();
        } catch (IOException ignored) {
        }
    }
}
#end_block

#method_before
protected Object getEntity() {
    try {
        Method m = resolveGet();
        if (m == null) {
            return null;
        }
        Object entity = m.invoke(this);
        return getEntityWithIdAndHref(entity);
    } catch (Exception e) {
        log.error("Getting resource after action failed: {}", e.getMessage());
        log.debug("Exception", e);
        return null;
    }
}
#method_after
protected Object getEntity() {
    try {
        Method m = resolveGet();
        if (m == null) {
            return null;
        }
        Object entity = m.invoke(this);
        return getEntityWithIdAndHref(entity);
    } catch (Exception e) {
        log.error("Getting resource after action failed.", e);
        return null;
    }
}
#end_block

#method_before
protected void setActionItem(Action action, Object result) {
    if (result == null) {
        return;
    }
    String name = result.getClass().getSimpleName().toLowerCase();
    for (Method m : action.getClass().getMethods()) {
        if (m.getName().startsWith("set") && m.getName().replace("set", "").toLowerCase().equals(name)) {
            try {
                m.invoke(action, result);
                break;
            } catch (Exception e) {
                // should not happen
                log.error("Resource to action asignment failure: ", e.getMessage());
                log.debug("Exception", e);
                break;
            }
        }
    }
}
#method_after
protected void setActionItem(Action action, Object result) {
    if (result == null) {
        return;
    }
    String name = result.getClass().getSimpleName().toLowerCase();
    for (Method m : action.getClass().getMethods()) {
        if (m.getName().startsWith("set") && m.getName().replace("set", "").toLowerCase().equals(name)) {
            try {
                m.invoke(action, result);
                break;
            } catch (Exception e) {
                // should not happen
                log.error("Resource to action assignment failure.", e);
                break;
            }
        }
    }
}
#end_block

#method_before
protected <P extends VdcActionParametersBase> P sessionize(P parameters) {
    return sessionHelper.sessionize(parameters);
}
#method_after
protected <P extends VdcQueryParametersBase> P sessionize(P parameters) {
    return sessionHelper.sessionize(parameters);
}
#end_block

#method_before
protected <T> T handleError(Class<T> clz, Exception e, boolean notFoundAs404) {
    if ((e instanceof EntityNotFoundException) && (notFoundAs404)) {
        throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).build());
    } else if ((e instanceof BackendFailureException) && (!StringUtils.isEmpty(e.getMessage()))) {
        log.error(localize(Messages.BACKEND_FAILED_TEMPLATE), e.getMessage());
        BackendFailureException e2 = (BackendFailureException) e;
        throw new WebFaultException(null, e.getMessage(), e2.getHttpStatus() != null ? e2.getHttpStatus() : Response.Status.BAD_REQUEST);
    } else if (e instanceof WebFaultException) {
        WebFaultException e2 = (WebFaultException) e;
        log.error(localize(Messages.BACKEND_FAILED_TEMPLATE), e2.getMessage());
        log.debug("Exception", e2);
        throw e2;
    } else {
        log.error(localize(Messages.BACKEND_FAILED_TEMPLATE), e.getMessage());
        log.debug("Exception", e);
        throw new WebFaultException(e, detail(e), Response.Status.INTERNAL_SERVER_ERROR);
    }
}
#method_after
protected <T> T handleError(Class<T> clz, Exception e, boolean notFoundAs404) {
    if ((e instanceof EntityNotFoundException) && (notFoundAs404)) {
        throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).build());
    } else if ((e instanceof BackendFailureException) && (!StringUtils.isEmpty(e.getMessage()))) {
        log.error(localize(Messages.BACKEND_FAILED_TEMPLATE), e.getMessage());
        BackendFailureException e2 = (BackendFailureException) e;
        throw new WebFaultException(null, e.getMessage(), e2.getHttpStatus() != null ? e2.getHttpStatus() : Response.Status.BAD_REQUEST);
    } else if (e instanceof WebFaultException) {
        WebFaultException e2 = (WebFaultException) e;
        log.error(localize(Messages.BACKEND_FAILED_TEMPLATE), e2.getMessage());
        log.error("Exception", e2);
        throw e2;
    } else {
        log.error(localize(Messages.BACKEND_FAILED_TEMPLATE), e.getMessage());
        log.error("Exception", e);
        throw new WebFaultException(e, detail(e), Response.Status.INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
private static DatatypeFactory getDatatypeFactory() {
    if (datatypeFactory == null) {
        try {
            datatypeFactory = DatatypeFactory.newInstance();
        } catch (DatatypeConfigurationException dce) {
            log.warn(DATATYPE_FACTORY_CREATION_FAILED, dce.getMessage());
            log.debug("Exception", dce);
        }
    }
    return datatypeFactory;
}
#method_after
private static DatatypeFactory getDatatypeFactory() {
    if (datatypeFactory == null) {
        try {
            datatypeFactory = DatatypeFactory.newInstance();
        } catch (DatatypeConfigurationException dce) {
            log.warn(DATATYPE_FACTORY_CREATION_FAILED, dce);
        }
    }
    return datatypeFactory;
}
#end_block

#method_before
private SearchParameters getSearchParameters(SearchType searchType, String constraint) {
    SearchParameters searchParams = new SearchParameters(constraint, searchType);
    HashMap<String, String> matrixConstraints = QueryHelper.getMatrixConstraints(getUriInfo(), CASE_SENSITIVE_CONSTRAINT_PARAMETER, FROM_CONSTRAINT_PARAMETER);
    // preserved in sake if backward compatibility until 4.0
    HashMap<String, String> queryConstraints = QueryHelper.getQueryConstraints(getUriInfo(), FROM_CONSTRAINT_PARAMETER);
    if (matrixConstraints.containsKey(FROM_CONSTRAINT_PARAMETER)) {
        try {
            searchParams.setSearchFrom(Long.parseLong(matrixConstraints.get(FROM_CONSTRAINT_PARAMETER)));
        } catch (Exception ex) {
            log.error("Unwrapping of '{}' matrix search parameter failed: {}", FROM_CONSTRAINT_PARAMETER, ex.getMessage());
            log.debug("Exception", ex);
        }
    } else if (queryConstraints.containsKey(FROM_CONSTRAINT_PARAMETER)) {
        // preserved in sake if backward compatibility until 4.0
        try {
            searchParams.setSearchFrom(Long.parseLong(queryConstraints.get(FROM_CONSTRAINT_PARAMETER)));
        } catch (Exception ex) {
            log.error("Unwrapping of '{}' query search parameter failed: {}", FROM_CONSTRAINT_PARAMETER, ex.getMessage());
            log.debug("Exception", ex);
        }
    }
    if (matrixConstraints.containsKey(CASE_SENSITIVE_CONSTRAINT_PARAMETER)) {
        try {
            searchParams.setCaseSensitive(Boolean.parseBoolean(matrixConstraints.get(CASE_SENSITIVE_CONSTRAINT_PARAMETER)));
        } catch (Exception ex) {
            log.error("Unwrapping of '{}' search parameter failed: {}", CASE_SENSITIVE_CONSTRAINT_PARAMETER, ex.getMessage());
            log.debug("Exception", ex);
        }
    }
    try {
        if (QueryHelper.hasMatrixParam(getUriInfo(), MAX) && getMaxResults() != NO_LIMIT) {
            searchParams.setMaxCount(getMaxResults());
        }
    } catch (MalformedNumberException ex) {
        handleError(ex, false);
    }
    return searchParams;
}
#method_after
private SearchParameters getSearchParameters(SearchType searchType, String constraint) {
    SearchParameters searchParams = new SearchParameters(constraint, searchType);
    HashMap<String, String> matrixConstraints = QueryHelper.getMatrixConstraints(getUriInfo(), CASE_SENSITIVE_CONSTRAINT_PARAMETER, FROM_CONSTRAINT_PARAMETER);
    // preserved in sake if backward compatibility until 4.0
    HashMap<String, String> queryConstraints = QueryHelper.getQueryConstraints(getUriInfo(), FROM_CONSTRAINT_PARAMETER);
    if (matrixConstraints.containsKey(FROM_CONSTRAINT_PARAMETER)) {
        try {
            searchParams.setSearchFrom(Long.parseLong(matrixConstraints.get(FROM_CONSTRAINT_PARAMETER)));
        } catch (Exception ex) {
            log.error("Unwrapping of '{}' matrix search parameter failed: {}", FROM_CONSTRAINT_PARAMETER, ex.getMessage());
            log.error("Exception", ex);
        }
    } else if (queryConstraints.containsKey(FROM_CONSTRAINT_PARAMETER)) {
        // preserved in sake if backward compatibility until 4.0
        try {
            searchParams.setSearchFrom(Long.parseLong(queryConstraints.get(FROM_CONSTRAINT_PARAMETER)));
        } catch (Exception ex) {
            log.error("Unwrapping of '{}' query search parameter failed: {}", FROM_CONSTRAINT_PARAMETER, ex.getMessage());
            log.error("Exception", ex);
        }
    }
    if (matrixConstraints.containsKey(CASE_SENSITIVE_CONSTRAINT_PARAMETER)) {
        try {
            searchParams.setCaseSensitive(Boolean.parseBoolean(matrixConstraints.get(CASE_SENSITIVE_CONSTRAINT_PARAMETER)));
        } catch (Exception ex) {
            log.error("Unwrapping of '{}' search parameter failed: {}", CASE_SENSITIVE_CONSTRAINT_PARAMETER, ex.getMessage());
            log.error("Exception", ex);
        }
    }
    try {
        if (QueryHelper.hasMatrixParam(getUriInfo(), MAX) && getMaxResults() != NO_LIMIT) {
            searchParams.setMaxCount(getMaxResults());
        }
    } catch (MalformedNumberException ex) {
        handleError(ex, false);
    }
    return searchParams;
}
#end_block

#method_before
@Override
public Response toResponse(MappingException exception) {
    LOGGER.error("Exception", exception);
    final Fault fault = new Fault();
    fault.setReason("Operation Failed");
    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(fault).build();
}
#method_after
@Override
public Response toResponse(MappingException exception) {
    log.error("Exception", exception);
    final Fault fault = new Fault();
    fault.setReason("Operation Failed");
    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(fault).build();
}
#end_block

#method_before
private static DatatypeFactory getDatatypeFactory() {
    if (datatypeFactory == null) {
        try {
            datatypeFactory = DatatypeFactory.newInstance();
        } catch (DatatypeConfigurationException dce) {
            log.warn(DATATYPE_FACTORY_CREATION_FAILED, dce.getMessage());
            log.debug("Exception", dce);
        }
    }
    return datatypeFactory;
}
#method_after
private static DatatypeFactory getDatatypeFactory() {
    if (datatypeFactory == null) {
        try {
            datatypeFactory = DatatypeFactory.newInstance();
        } catch (DatatypeConfigurationException dce) {
            log.warn(DATATYPE_FACTORY_CREATION_FAILED, dce);
        }
    }
    return datatypeFactory;
}
#end_block

#method_before
private Message getMessage(ByteBuffer buffer, int read) {
    if (read > BUFFER_SIZE) {
        read = BUFFER_SIZE;
    }
    byte[] array = new byte[read];
    buffer.rewind();
    buffer.get(array);
    return Message.parse(array);
}
#method_after
private Message getMessage(ByteBuffer buffer, int read) throws ClientConnectionException {
    if (read > BUFFER_SIZE) {
        read = BUFFER_SIZE;
    }
    byte[] array = new byte[read];
    buffer.rewind();
    buffer.get(array);
    return Message.parse(array);
}
#end_block

#method_before
public final void disconnect(String message) {
    postDisconnect();
    closeChannel();
    emitOnMessageReceived(buildNetowkResponse(message));
}
#method_after
public final void disconnect(String message) {
    postDisconnect();
    closeChannel();
    emitOnMessageReceived(buildNetworkResponse(message));
}
#end_block

#method_before
private void processChannels() {
    for (final SelectionKey key : this.selector.selectedKeys()) {
        if (!key.isValid()) {
            continue;
        }
        if (key.isAcceptable()) {
            final ReactorListener obj = (ReactorListener) key.attachment();
            final ReactorClient client = obj.accept();
            if (client == null) {
                continue;
            }
        }
        if (key.isValid() && (key.isReadable() || key.isWritable())) {
            final ReactorClient client = (ReactorClient) key.attachment();
            try {
                client.process();
            } catch (IOException | ClientConnectionException ex) {
                LOG.error("Unable to process messages", ex);
                client.disconnect(ex.getMessage());
            }
        }
        if (!key.channel().isOpen()) {
            key.cancel();
        }
    }
}
#method_after
private void processChannels() {
    for (final SelectionKey key : this.selector.selectedKeys()) {
        if (!key.isValid()) {
            continue;
        }
        if (key.isAcceptable()) {
            final ReactorListener obj = (ReactorListener) key.attachment();
            final ReactorClient client = obj.accept();
            if (client == null) {
                continue;
            }
        }
        if (key.isValid() && (key.isReadable() || key.isWritable())) {
            final ReactorClient client = (ReactorClient) key.attachment();
            try {
                client.process();
            } catch (IOException | ClientConnectionException ex) {
                LOG.error("Unable to process messages", ex);
                client.disconnect(ex.getMessage());
            } catch (Throwable e) {
                LOG.error("Internal server error", e);
                client.disconnect(e.getMessage());
            }
        }
        if (!key.channel().isOpen()) {
            key.cancel();
        }
    }
}
#end_block

#method_before
public static Properties loadProperties(Class<?> cls, String name) throws IOException {
    final String ERR_MSG = "Failed to locate resource file: " + name;
    InputStream is = cls.getClassLoader().getResourceAsStream(name);
    if (is == null) {
        log.error(ERR_MSG);
        throw new FileNotFoundException(ERR_MSG);
    }
    try {
        Properties props = new Properties();
        props.load(is);
        return props;
    } finally {
        try {
            is.close();
        } catch (Exception e) {
            String msg = (e.getMessage() != null) ? e.getMessage() : "";
            log.error("Failed to close input stream: {}", msg);
            log.debug("Exception", e);
        }
    }
}
#method_after
public static Properties loadProperties(Class<?> cls, String name) throws IOException {
    final String ERR_MSG = "Failed to locate resource file: " + name;
    InputStream is = cls.getClassLoader().getResourceAsStream(name);
    if (is == null) {
        log.error(ERR_MSG);
        throw new FileNotFoundException(ERR_MSG);
    }
    try {
        Properties props = new Properties();
        props.load(is);
        return props;
    } finally {
        try {
            is.close();
        } catch (Exception e) {
            log.error("Failed to close input stream: {}", e.getMessage());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@Override
protected void beforeExecute(Thread t, Runnable r) {
    super.beforeExecute(t, r);
    String threadName = t.getName();
    if (!threadName.startsWith("org.ovirt.thread.")) {
        t.setName("org.ovirt.thread." + threadName);
    }
    if (log.isDebugEnabled()) {
        log.debug(String.format("About to run task '%s' from {}", r.getClass().getName()), new Exception());
    }
    if (getQueue().size() > 5) {
        log.warn("Executing a command '{}', but note that there are {} tasks in the queue.", r.getClass().getName(), getQueue().size());
    }
}
#method_after
@Override
protected void beforeExecute(Thread t, Runnable r) {
    super.beforeExecute(t, r);
    String threadName = t.getName();
    if (!threadName.startsWith("org.ovirt.thread.")) {
        t.setName("org.ovirt.thread." + threadName);
    }
    if (log.isDebugEnabled()) {
        log.debug(String.format("About to run task '%s' from", r.getClass().getName()), new Exception());
    }
    if (getQueue().size() > 5) {
        log.warn("Executing a command '{}', but note that there are {} tasks in the queue.", r.getClass().getName(), getQueue().size());
    }
}
#end_block

#method_before
private Map<String, String> retrieveByLocale(Locale locale, String messageSource, Map<String, String> messages) {
    try {
        ResourceBundle bundle = ResourceBundle.getBundle(messageSource, locale);
        for (String key : bundle.keySet()) {
            if (!messages.containsKey(key)) {
                messages.put(key, bundle.getString(key));
            } else {
                log.warn("Code '{}' appears more than once in string table.", key);
            }
        }
    } catch (RuntimeException e) {
        log.error("File: '{}' could not be loaded: {}", messageSource, e.toString());
        log.debug("Exception", e);
    }
    return messages;
}
#method_after
private Map<String, String> retrieveByLocale(Locale locale, String messageSource, Map<String, String> messages) {
    try {
        ResourceBundle bundle = ResourceBundle.getBundle(messageSource, locale);
        for (String key : bundle.keySet()) {
            if (!messages.containsKey(key)) {
                messages.put(key, bundle.getString(key));
            } else {
                log.warn("Code '{}' appears more than once in string table.", key);
            }
        }
    } catch (RuntimeException e) {
        log.error("File: '{}' could not be loaded: {}", messageSource, e.getMessage());
        log.debug("Exception", e);
    }
    return messages;
}
#end_block

#method_before
@Override
public void starting(Description description) {
    String seedProperty = System.getProperty(RANDOM_SEED_PROPERTY);
    Long seed;
    try {
        seed = Long.parseLong(seedProperty);
    } catch (NumberFormatException e) {
        log.info("Property '{}' was not set, using System.currentTimeMillis() as a seed.", RANDOM_SEED_PROPERTY);
        seed = System.currentTimeMillis();
    }
    RandomUtils.instance().setSeed(seed);
    log.info("Running test with random seed: {}", RandomUtils.instance().getSeed());
}
#method_after
@Override
public void starting(Description description) {
    String seedProperty = System.getProperty(RANDOM_SEED_PROPERTY);
    Long seed;
    try {
        seed = Long.parseLong(seedProperty);
    } catch (NumberFormatException e) {
        log.info("Property '{}' was not set, using System.currentTimeMillis() as a seed.", RANDOM_SEED_PROPERTY);
        seed = System.currentTimeMillis();
    }
    log.info("Running test with random seed '{}'", seed);
    RandomUtils.instance().setSeed(seed);
}
#end_block

#method_before
public static String decryptPassword(String password) {
    try {
        return EngineEncryptionUtils.decrypt(password);
    } catch (Exception e) {
        log.debug("Failed to decrypt password, error message: {}", e.getMessage());
        return password;
    }
}
#method_after
public static String decryptPassword(String password) {
    try {
        return EngineEncryptionUtils.decrypt(password);
    } catch (Exception e) {
        log.debug("Failed to decrypt password", e);
        return password;
    }
}
#end_block

#method_before
private static void checkMessages() {
    AuditLogType[] values = AuditLogType.values();
    if (values.length != messages.size()) {
        for (AuditLogType value : values) {
            if (!messages.containsKey(value)) {
                log.info("AuditLogType: '{}' not exist in string table", value.toString());
            }
        }
    }
}
#method_after
private static void checkMessages() {
    AuditLogType[] values = AuditLogType.values();
    if (values.length != messages.size()) {
        for (AuditLogType value : values) {
            if (!messages.containsKey(value)) {
                log.info("AuditLogType: '{}' not exist in string table", value);
            }
        }
    }
}
#end_block

#method_before
@Override
public DataType createDataType(int sqlType, String sqlTypeName) throws DataTypeException {
    log.debug("createDataType(sqlType='{}', sqlTypeName='{}')", String.valueOf(sqlType), sqlTypeName);
    if (sqlType == Types.OTHER)
        // Treat Postgresql UUID types as VARCHARS
        if ("uuid".equals(sqlTypeName))
            return new UuidType();
        else // Intervals are custom types
        if ("interval".equals(sqlTypeName))
            return new IntervalType();
        else if ("inet".equals(sqlTypeName))
            return new InetType();
        else {
            // Finally check whether the user defined a custom datatype
            if (isEnumType(sqlTypeName)) {
                log.debug("Custom enum type used for sqlTypeName '{}' (sqlType '{}')", new Object[] { sqlTypeName, Integer.valueOf(sqlType) });
                return new GenericEnumType(sqlTypeName);
            }
        }
    return super.createDataType(sqlType, sqlTypeName);
}
#method_after
@Override
public DataType createDataType(int sqlType, String sqlTypeName) throws DataTypeException {
    log.debug("createDataType(sqlType='{}', sqlTypeName='{}')", sqlType, sqlTypeName);
    if (sqlType == Types.OTHER)
        // Treat Postgresql UUID types as VARCHARS
        if ("uuid".equals(sqlTypeName))
            return new UuidType();
        else // Intervals are custom types
        if ("interval".equals(sqlTypeName))
            return new IntervalType();
        else if ("inet".equals(sqlTypeName))
            return new InetType();
        else {
            // Finally check whether the user defined a custom datatype
            if (isEnumType(sqlTypeName)) {
                log.debug("Custom enum type used for sqlTypeName '{}' (sqlType '{}')", sqlTypeName, Integer.valueOf(sqlType));
                return new GenericEnumType(sqlTypeName);
            }
        }
    return super.createDataType(sqlType, sqlTypeName);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    final VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(VMStatus.NotResponding));
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.vmNotHavingPluggedDiskSnapshots(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
        return false;
    }
    if (getDestinationVds() != null && getDestinationVds().getStatus() != VDSStatus.Up) {
        addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP);
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && SchedulingManager.getInstance().canSchedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), getDestinationVdsId(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    final VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(VMStatus.NotResponding));
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.vmNotHavingPluggedDiskSnapshots(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
        return false;
    }
    if (getDestinationVds() != null && getDestinationVds().getStatus() != VDSStatus.Up) {
        addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP);
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && SchedulingManager.getInstance().canSchedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), getDestinationVdsId(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected void determineMigrationFailureForAuditLog() {
    if (getVm() != null && getVm().getStatus() == VMStatus.Up) {
        try {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MigrateStatus, new MigrateStatusVDSCommandParameters(getVdsId(), getVmId()));
        } catch (VdcBLLException e) {
            migrationErrorCode = e.getErrorCode();
        }
    }
}
#method_after
protected void determineMigrationFailureForAuditLog() {
    if (getVm() != null && getVm().getStatus() == VMStatus.Up) {
        try {
            runVdsCommand(VDSCommandType.MigrateStatus, new MigrateStatusVDSCommandParameters(getVdsId(), getVmId()));
        } catch (VdcBLLException e) {
            migrationErrorCode = e.getErrorCode();
        }
    }
}
#end_block

#method_before
public String getDuration() {
    // return time in seconds
    return String.valueOf((new Date().getTime() - getParameters().getStartTime().getTime()) / 1000);
}
#method_after
public String getDuration() {
    return DurationFormatUtils.formatDurationWords(new Date().getTime() - getParameters().getStartTime().getTime(), true, true);
}
#end_block

#method_before
@Override
protected AuditLogType getAuditLogForMigrationFailure() {
    if (getDestinationVds() == null) {
        return AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON;
    }
    return AuditLogType.VM_MIGRATION_TO_SERVER_FAILED;
}
#method_after
@Override
protected AuditLogType getAuditLogForMigrationFailure() {
    return AuditLogType.VM_MIGRATION_TO_SERVER_FAILED;
}
#end_block

#method_before
@Override
public void render(Cell.Context context, VM value, SafeHtmlBuilder sb) {
    // $NON-NLS-1$
    sb.appendHtmlConstant("<div id=\"");
    sb.appendEscaped(ElementIdUtils.createTableCellElementId(getElementIdPrefix(), getColumnId(), context));
    // $NON-NLS-1$
    sb.appendHtmlConstant("\">");
    // TODO use my element id and column index
    for (HasCell<VM, ?> hasCell : hasCells) {
        render(context, value, sb, hasCell);
    }
    // $NON-NLS-1$
    sb.appendHtmlConstant("</div>");
}
#method_after
@Override
public void render(Cell.Context context, VM value, SafeHtmlBuilder sb) {
    // $NON-NLS-1$
    sb.appendHtmlConstant("<div id=\"");
    sb.appendEscaped(ElementIdUtils.createTableCellElementId(getElementIdPrefix(), getColumnId(), context));
    // $NON-NLS-1$
    sb.appendHtmlConstant("\">");
    for (HasCell<VM, ?> hasCell : hasCells) {
        render(context, value, sb, hasCell);
    }
    // $NON-NLS-1$
    sb.appendHtmlConstant("</div>");
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    GlusterVolumeGeoRepSessionVDSParameters parameter = getParameters();
    if (parameter.getVolumeName() == null) {
        result = getBroker().glusterVolumeGeoRepStatus();
    } else if (parameter.getVolumeName() != null && (parameter.getSlaveHost() == null || parameter.getSlaveVolume() == null)) {
        result = getBroker().glusterVolumeGeoRepStatus(parameter.getVolumeName());
    } else {
        result = getBroker().glusterVolumeGeoRepStatus(parameter.getVolumeName(), parameter.getSlaveHost(), parameter.getSlaveVolume());
    }
    proceedProxyReturnValue();
    if (getVDSReturnValue().getSucceeded()) {
        setReturnValue(result.getGeoRepSessions());
    }
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    GlusterVolumeGeoRepSessionVDSParameters parameter = getParameters();
    if (parameter.getVolumeName() == null) {
        result = getBroker().glusterVolumeGeoRepStatus();
    } else if (parameter.getSlaveHost() == null || parameter.getSlaveVolume() == null) {
        result = getBroker().glusterVolumeGeoRepStatus(parameter.getVolumeName());
    } else {
        result = getBroker().glusterVolumeGeoRepStatus(parameter.getVolumeName(), parameter.getSlaveHost(), parameter.getSlaveVolume());
    }
    proceedProxyReturnValue();
    if (getVDSReturnValue().getSucceeded()) {
        setReturnValue(result.getGeoRepSessions());
    }
}
#end_block

#method_before
public void close() {
    this.client.close();
}
#method_after
@Override
public void close() {
    XmlRpcUtils.shutDownConnection(this.httpClient);
    this.client.close();
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("status");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#end_block

#method_before
private void updateHeartbeatPolicy(boolean isheartbeat) {
    RetryPolicy policy = client.getRetryPolicy();
    policy.setHeartbeat(isheartbeat);
    client.setRetryPolicy(policy);
}
#method_after
private void updateHeartbeatPolicy(boolean isheartbeat) {
    RetryPolicy policy = client.getClientRetryPolicy();
    policy.setHeartbeat(isheartbeat);
    client.setClientRetryPolicy(policy);
}
#end_block

#method_before
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("fencingPolicy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("power").withResponseType(String.class);
    return new FenceStatusReturnForXmlRpc(response);
}
#method_after
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("policy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new FenceStatusReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public FutureTask<Map<String, Object>> poll() {
    final JsonRpcRequest request = new RequestBuilder("Host.ping").build();
    final FutureCallable callable = new FutureCallable(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            return new FutureMap(client, request);
        }
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            return callable.isDone();
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@Override
public FutureTask<Map<String, Object>> poll() {
    return timeBoundPoll(0, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("vmID", (String) params.get("vmId")).withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
protected GlusterGeoRepSessionDetails getSessionDetails(Map<String, Object> innerMap, GlusterGeoRepSession session) {
    GlusterGeoRepSessionDetails details = new GlusterGeoRepSessionDetails();
    details.setSessionId(session.getId());
    Guid masterNodeGlusterId;
    if (innerMap.containsKey(MASTER_NODE_UUID)) {
        masterNodeGlusterId = new Guid(innerMap.get(MASTER_NODE_UUID).toString());
    } else {
        log.error("Host Node Id is not available");
        return null;
    }
    String masterBrickDir = (innerMap.containsKey(MASTER_BRICK)) ? innerMap.get(MASTER_BRICK).toString() : null;
    GlusterServer glusterServer = getDbUtils().getServerByUuid(masterNodeGlusterId);
    if (glusterServer != null) {
        GlusterBrickEntity brick = getDbUtils().getGlusterBrickByServerUuidAndBrickDir(glusterServer.getId(), masterBrickDir);
        if (brick != null) {
            details.setMasterBrickId(brick.getId());
        }
    }
    if (details.getMasterBrickId() == null) {
        log.errorFormat("Brick information could not be retrieved for gluster host id %1 and brick dir %2", masterNodeGlusterId, masterBrickDir);
    }
    String slave = innerMap.containsKey(SLAVE) ? innerMap.get(SLAVE).toString() : null;
    String[] slaveSplit = (slave != null) ? slave.split("([://]+)") : null;
    if (slaveSplit != null && slaveSplit.length >= 2) {
        details.setSlaveHostName(slaveSplit[slaveSplit.length - 2]);
    }
    details.setStatus(GeoRepSessionStatus.from((String) innerMap.get(STATUS)));
    details.setCrawlStatus(GeoRepCrawlStatus.from((String) innerMap.get(CRAWL_STATUS)));
    details.setCheckPointStatus((String) innerMap.get(CHECK_POINT_STATUS));
    return details;
}
#method_after
protected GlusterGeoRepSessionDetails getSessionDetails(Map<String, Object> innerMap, GlusterGeoRepSession session) {
    GlusterGeoRepSessionDetails details = new GlusterGeoRepSessionDetails();
    details.setSessionId(session.getId());
    Guid masterNodeGlusterId;
    if (innerMap.containsKey(MASTER_NODE_UUID)) {
        masterNodeGlusterId = new Guid(innerMap.get(MASTER_NODE_UUID).toString());
    } else {
        log.error("Master node uuid is not available");
        return null;
    }
    String masterBrickDir = (innerMap.containsKey(MASTER_BRICK)) ? innerMap.get(MASTER_BRICK).toString() : null;
    GlusterServer glusterServer = getDbUtils().getServerByUuid(masterNodeGlusterId);
    if (glusterServer != null) {
        GlusterBrickEntity brick = getDbUtils().getGlusterBrickByServerUuidAndBrickDir(glusterServer.getId(), masterBrickDir);
        if (brick != null) {
            details.setMasterBrickId(brick.getId());
        }
    }
    if (details.getMasterBrickId() == null) {
        log.errorFormat("Brick information could not be retrieved for gluster host id %1 and brick dir %2", masterNodeGlusterId, masterBrickDir);
    }
    String slave = innerMap.containsKey(SLAVE) ? innerMap.get(SLAVE).toString() : null;
    String[] slaveSplit = (slave != null) ? slave.split("([://]+)") : null;
    if (slaveSplit != null && slaveSplit.length >= 2) {
        details.setSlaveHostName(slaveSplit[slaveSplit.length - 2]);
    }
    details.setStatus(GeoRepSessionStatus.from((String) innerMap.get(STATUS)));
    details.setCrawlStatus(GeoRepCrawlStatus.from((String) innerMap.get(CRAWL_STATUS)));
    details.setCheckPointStatus((String) innerMap.get(CHECK_POINT_STATUS));
    return details;
}
#end_block

#method_before
protected GlusterGeoRepSession getSession(String masterVolumeName, Map<String, Object> innerMap) {
    GlusterGeoRepSession geoRepSession = new GlusterGeoRepSession();
    // sessionslave in the form -  <session_slave>11ae7a03-e793-4270-8fc4-b42def8b3051:ssh://192.168.122.14::slave2</session_slave>
    String sessionKey = (String) innerMap.get(SESSION_SLAVE);
    String[] sessSplit = sessionKey.split("([://]+)");
    String sessionId = sessSplit[0];
    String slaveNode = sessSplit[sessSplit.length - 2];
    String slaveVolume = sessSplit[sessSplit.length - 1];
    geoRepSession.setId(Guid.createGuidFromString(sessionId));
    geoRepSession.setSlaveHostName(slaveNode);
    geoRepSession.setSlaveVolumeName(slaveVolume);
    geoRepSession.setSessionKey(sessionKey);
    geoRepSession.setMasterVolumeName(masterVolumeName);
    return geoRepSession;
}
#method_after
protected GlusterGeoRepSession getSession(String masterVolumeName, Map<String, Object> innerMap) {
    GlusterGeoRepSession geoRepSession = new GlusterGeoRepSession();
    // sessionslave in the form -
    // <session_slave>11ae7a03-e793-4270-8fc4-b42def8b3051:ssh://192.168.122.14::slave2</session_slave>
    String sessionKey = (String) innerMap.get(SESSION_SLAVE);
    String[] sessSplit = sessionKey.split("([://]+)");
    String sessionId = sessSplit[0];
    String slaveNode = sessSplit[sessSplit.length - 2];
    String slaveVolume = sessSplit[sessSplit.length - 1];
    geoRepSession.setId(Guid.createGuidFromString(sessionId));
    geoRepSession.setSlaveHostName(slaveNode);
    geoRepSession.setSlaveVolumeName(slaveVolume);
    geoRepSession.setSessionKey(sessionKey);
    geoRepSession.setMasterVolumeName(masterVolumeName);
    return geoRepSession;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionDelete(volumeName, remoteVolumeName, remoteVolumeName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionDelete(volumeName, remoteHost, remoteVolumeName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStop(volumeName, remoteVolumeName, remoteVolumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStop(volumeName, remoteHost, remoteVolumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    status = getBroker().glusterVolumeGeoRepSessionDelete(getParameters().getVolumeName(), getParameters().getSlaveHost(), getParameters().getVolumeName());
    // Handle errors if any
    proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    status = getBroker().glusterVolumeGeoRepSessionDelete(getParameters().getVolumeName(), getParameters().getSlaveHost(), getParameters().getSlaveVolume());
    // Handle errors if any
    proceedProxyReturnValue();
}
#end_block

#method_before
public void close() {
    this.client.close();
}
#method_after
@Override
public void close() {
    XmlRpcUtils.shutDownConnection(this.httpClient);
    this.client.close();
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("status");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#end_block

#method_before
private void updateHeartbeatPolicy(boolean isheartbeat) {
    RetryPolicy policy = client.getRetryPolicy();
    policy.setHeartbeat(isheartbeat);
    client.setRetryPolicy(policy);
}
#method_after
private void updateHeartbeatPolicy(boolean isheartbeat) {
    RetryPolicy policy = client.getClientRetryPolicy();
    policy.setHeartbeat(isheartbeat);
    client.setClientRetryPolicy(policy);
}
#end_block

#method_before
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("fencingPolicy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("power").withResponseType(String.class);
    return new FenceStatusReturnForXmlRpc(response);
}
#method_after
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("policy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new FenceStatusReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public FutureTask<Map<String, Object>> poll() {
    final JsonRpcRequest request = new RequestBuilder("Host.ping").build();
    final FutureCallable callable = new FutureCallable(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            return new FutureMap(client, request);
        }
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            return callable.isDone();
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@Override
public FutureTask<Map<String, Object>> poll() {
    return timeBoundPoll(0, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("vmID", (String) params.get("vmId")).withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    status = getBroker().glusterVolumeGeoRepSessionStop(getParameters().getVolumeName(), getParameters().getSlaveHost(), getParameters().getVolumeName(), getParameters().getForce());
    // Handle errors if any
    proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    status = getBroker().glusterVolumeGeoRepSessionStop(getParameters().getVolumeName(), getParameters().getSlaveHost(), getParameters().getSlaveVolume(), getParameters().getForce());
    // Handle errors if any
    proceedProxyReturnValue();
}
#end_block

#method_before
JsonNode readJsonNode(File file) {
    JsonNode node = null;
    try {
        node = mapper.readValue(file, JsonNode.class);
    } catch (IOException e) {
        // $NON-NLS-1$
        log.warn("Cannot read/parse JSON file '{}'", file.getAbsolutePath());
        // $NON-NLS-1$
        log.warn("Exception", e);
    }
    return node;
}
#method_after
JsonNode readJsonNode(File file) {
    JsonNode node = null;
    try {
        node = mapper.readValue(file, JsonNode.class);
    } catch (IOException e) {
        // $NON-NLS-1$
        log.warn("Cannot read/parse JSON file '{}': {}", file.getAbsolutePath(), e.getMessage());
        // $NON-NLS-1$
        log.debug("Exception", e);
    }
    return node;
}
#end_block

#method_before
private void debugQuery(VdcQueryType queryType, VdcQueryParametersBase parameters) {
    if (log.isDebugEnabled()) {
        // $NON-NLS-1$
        log.debug("Query type '{}', Parameters '{}'", queryType, parameters);
    }
}
#method_after
private void debugQuery(VdcQueryType queryType, VdcQueryParametersBase parameters) {
    // $NON-NLS-1$
    log.debug("Query type '{}', Parameters '{}'", queryType, parameters);
}
#end_block

#method_before
private void debugAction(VdcActionType actionType, VdcActionParametersBase params) {
    if (log.isDebugEnabled()) {
        // $NON-NLS-1$
        log.debug("Action type '{}', Parameters '{}'", actionType, params);
    }
}
#method_after
private void debugAction(VdcActionType actionType, VdcActionParametersBase params) {
    // $NON-NLS-1$
    log.debug("Action type '{}', Parameters '{}'", actionType, params);
}
#end_block

#method_before
public static boolean isSane(String path) {
    // Check that the path is not too long:
    final int length = path.length();
    if (length > PATH_MAX) {
        log.error("The path is {} characters long, which is longer than the maximum allowed {}.", length, PATH_MAX);
        return false;
    }
    // Check that there aren't potentially dangerous directory navigation sequences:
    if (path.contains("..") || path.contains("//") || path.contains("./")) {
        log.error("The path contains potentially dangerous directory navigation sequences.");
        return false;
    }
    // All checks passed, the path is sane:
    return true;
}
#method_after
public static boolean isSane(String path) {
    // Check that the path is not too long:
    final int length = path.length();
    if (length > PATH_MAX) {
        log.error("The path '{}' is {} characters long, which is longer than the maximum allowed {}.", path, length, PATH_MAX);
        return false;
    }
    // Check that there aren't potentially dangerous directory navigation sequences:
    if (path.contains("..") || path.contains("//") || path.contains("./")) {
        log.error("The path contains potentially dangerous directory navigation sequences.");
        return false;
    }
    // All checks passed, the path is sane:
    return true;
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String resourceStr = getMyParameter("resource", request);
    String formatStr = getMyParameter("format", request);
    String alias = getMyParameter("alias", request);
    try {
        if (resourceStr == null) {
            throw new IllegalArgumentException("Missing resource name");
        }
        PKIResources.Resource resource = resources.get(resourceStr);
        if (resource == null) {
            throw new IllegalArgumentException(String.format("Resource '%1$s' is invalid", resourceStr));
        }
        PKIResources.Format format = null;
        if (formatStr != null) {
            format = formats.get(formatStr);
            if (format == null) {
                throw new IllegalArgumentException(String.format("Format '%1$s' is invalid", formatStr));
            }
        }
        try (PrintWriter out = response.getWriter()) {
            response.setContentType(resource.getContentType(format));
            out.print(resource.toString(format, alias));
        }
    } catch (Exception e) {
        log.error("Cannot send public key resource '{}' format '{}'", resourceStr, formatStr);
        log.error("Exception", e);
        response.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String resourceStr = getMyParameter("resource", request);
    String formatStr = getMyParameter("format", request);
    String alias = getMyParameter("alias", request);
    try {
        if (resourceStr == null) {
            throw new IllegalArgumentException("Missing resource name");
        }
        PKIResources.Resource resource = resources.get(resourceStr);
        if (resource == null) {
            throw new IllegalArgumentException(String.format("Resource '%1$s' is invalid", resourceStr));
        }
        PKIResources.Format format = null;
        if (formatStr != null) {
            format = formats.get(formatStr);
            if (format == null) {
                throw new IllegalArgumentException(String.format("Format '%1$s' is invalid", formatStr));
            }
        }
        try (PrintWriter out = response.getWriter()) {
            response.setContentType(resource.getContentType(format));
            out.print(resource.toString(format, alias));
        }
    } catch (Exception e) {
        log.error("Cannot send public key resource '{}' format '{}': {}", resourceStr, formatStr, e.getMessage());
        log.debug("Exception", e);
        response.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (!copyData(getVmTemplate(), getVm().getStaticData())) {
        return;
    }
    getParameters().setPreviousDiskOperatorUserId(getIdOfDiskOperator());
    getParameters().setVmStaticData(getVm().getStaticData());
    if (getVm().getVmPoolId() != null) {
        getParameters().setVmPoolId(getVm().getVmPoolId());
        RemoveVmFromPoolParameters removeVmFromPoolParas = new RemoveVmFromPoolParameters(getVmId(), false);
        removeVmFromPoolParas.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.RemoveVmFromPool, removeVmFromPoolParas, getLock());
        if (!result.getSucceeded()) {
            log.errorFormat("Could not detach vm {0} ({1}) from vm-pool {2}.", getVm().getName(), getVmId(), getVm().getVmPoolName());
            return;
        }
    }
    RemoveVmParameters removeParams = new RemoveVmParameters(getVmId(), false);
    removeParams.setParentCommand(getActionType());
    removeParams.setParentParameters(getParameters());
    removeParams.setEntityInfo(getParameters().getEntityInfo());
    VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.RemoveVm, removeParams, getLock());
    if (result.getSucceeded()) {
        if (result.getHasAsyncTasks()) {
            getReturnValue().getVdsmTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        } else {
            endVmCommand();
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeVmCommand() {
    if (!copyData(getVmTemplate(), getVm().getStaticData())) {
        return;
    }
    getParameters().setPreviousDiskOperatorAuthzPrincipalDbId(getIdOfDiskOperator());
    getParameters().setVmStaticData(getVm().getStaticData());
    if (getVm().getVmPoolId() != null) {
        getParameters().setVmPoolId(getVm().getVmPoolId());
        RemoveVmFromPoolParameters removeVmFromPoolParas = new RemoveVmFromPoolParameters(getVmId(), false);
        removeVmFromPoolParas.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.RemoveVmFromPool, removeVmFromPoolParas, getLock());
        if (!result.getSucceeded()) {
            log.errorFormat("Could not detach vm {0} ({1}) from vm-pool {2}.", getVm().getName(), getVmId(), getVm().getVmPoolName());
            return;
        }
    }
    RemoveVmParameters removeParams = new RemoveVmParameters(getVmId(), false);
    removeParams.setParentCommand(getActionType());
    removeParams.setParentParameters(getParameters());
    removeParams.setEntityInfo(getParameters().getEntityInfo());
    VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.RemoveVm, removeParams, getLock());
    if (result.getSucceeded()) {
        if (result.getHasAsyncTasks()) {
            getReturnValue().getVdsmTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        } else {
            endVmCommand();
        }
        setSucceeded(true);
    }
}
#end_block

#method_before
private void addUpdatedVm() {
    AddVmParameters addVmParams;
    VdcActionType action;
    if (getParameters().getVmPoolId() != null) {
        addVmParams = new AddVmAndAttachToPoolParameters(getParameters().getVmStaticData(), getParameters().getVmPoolId(), getParameters().getVmStaticData().getName(), new HashMap<Guid, DiskImage>());
        action = VdcActionType.AddVmAndAttachToPool;
    } else {
        addVmParams = new AddVmParameters(getParameters().getVmStaticData());
        action = VdcActionType.AddVm;
    }
    addVmParams.setDiskInfoDestinationMap(new HashMap<Guid, DiskImage>());
    addVmParams.setConsoleEnabled(deviceExists(VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE));
    addVmParams.setBalloonEnabled(deviceExists(VmDeviceGeneralType.BALLOON, VmDeviceType.BALLOON));
    addVmParams.setSoundDeviceEnabled(deviceExists(VmDeviceGeneralType.SOUND, VmDeviceType.SOUND));
    addVmParams.setVirtioScsiEnabled(deviceExists(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI));
    List<VmWatchdog> watchdogs = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVmTemplateId())).getReturnValue();
    if (!watchdogs.isEmpty()) {
        addVmParams.setWatchdog(watchdogs.get(0));
    }
    if (!StringUtils.isEmpty(getParameters().getSessionId())) {
        VmPayload payload = runInternalQuery(VdcQueryType.GetVmPayload, new IdQueryParameters(getVmTemplateId())).getReturnValue();
        if (payload != null) {
            addVmParams.setVmPayload(payload);
        }
    }
    // then there is no session, so using the current user.
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        addVmParams.setParametersCurrentUser(getCurrentUser());
    } else {
        addVmParams.setSessionId(getParameters().getSessionId());
    }
    addVmParams.setDiskOperatorUserId(getParameters().getPreviousDiskOperatorUserId());
    runInternalAction(action, addVmParams, ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
}
#method_after
private void addUpdatedVm() {
    AddVmParameters addVmParams;
    VdcActionType action;
    if (getParameters().getVmPoolId() != null) {
        addVmParams = new AddVmAndAttachToPoolParameters(getParameters().getVmStaticData(), getParameters().getVmPoolId(), getParameters().getVmStaticData().getName(), new HashMap<Guid, DiskImage>());
        action = VdcActionType.AddVmAndAttachToPool;
    } else {
        addVmParams = new AddVmParameters(getParameters().getVmStaticData());
        action = VdcActionType.AddVm;
    }
    addVmParams.setDiskInfoDestinationMap(new HashMap<Guid, DiskImage>());
    addVmParams.setConsoleEnabled(deviceExists(VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE));
    addVmParams.setBalloonEnabled(deviceExists(VmDeviceGeneralType.BALLOON, VmDeviceType.BALLOON));
    addVmParams.setSoundDeviceEnabled(deviceExists(VmDeviceGeneralType.SOUND, VmDeviceType.SOUND));
    addVmParams.setVirtioScsiEnabled(deviceExists(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI));
    List<VmWatchdog> watchdogs = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVmTemplateId())).getReturnValue();
    if (!watchdogs.isEmpty()) {
        addVmParams.setWatchdog(watchdogs.get(0));
    }
    if (!StringUtils.isEmpty(getParameters().getSessionId())) {
        VmPayload payload = runInternalQuery(VdcQueryType.GetVmPayload, new IdQueryParameters(getVmTemplateId())).getReturnValue();
        if (payload != null) {
            addVmParams.setVmPayload(payload);
        }
    }
    // then there is no session, so using the current user.
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        addVmParams.setParametersCurrentUser(getCurrentUser());
    } else {
        addVmParams.setSessionId(getParameters().getSessionId());
    }
    addVmParams.setDiskOperatorAuthzPrincipalDbId(getParameters().getPreviousDiskOperatorAuthzPrincipalDbId());
    runInternalAction(action, addVmParams, ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    Permissions[] permsArray = new Permissions[newDiskImageIds.size()];
    Guid diskOperatorUserIdFromParams = getParameters().getDiskOperatorUserId();
    Guid diskOperatorUserId = diskOperatorUserIdFromParams != null ? diskOperatorUserIdFromParams : getCurrentUser().getId();
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new Permissions(diskOperatorUserId, PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#method_after
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    Permissions[] permsArray = new Permissions[newDiskImageIds.size()];
    Guid diskOperatorIdFromParams = getParameters().getDiskOperatorAuthzPrincipalDbId();
    Guid diskOperatorId = diskOperatorIdFromParams != null ? diskOperatorIdFromParams : getCurrentUser().getId();
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new Permissions(diskOperatorId, PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#end_block

#method_before
private VdcReturnValueBase addVmFromScratch(VmStatic vmStatic) {
    AddVmParameters parameters = new AddVmParameters(vmStatic);
    parameters.setDiskInfoList(getParameters().getDiskInfoList());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setSessionId(getParameters().getSessionId());
    parameters.setDontAttachToDefaultTag(true);
    parameters.setDiskOperatorUserId(getParameters().getDiskOperatorUserId());
    return runInternalActionWithTasksContext(VdcActionType.AddVmFromScratch, parameters);
}
#method_after
private VdcReturnValueBase addVmFromScratch(VmStatic vmStatic) {
    AddVmParameters parameters = new AddVmParameters(vmStatic);
    parameters.setDiskInfoList(getParameters().getDiskInfoList());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setSessionId(getParameters().getSessionId());
    parameters.setDontAttachToDefaultTag(true);
    parameters.setDiskOperatorAuthzPrincipalDbId(getParameters().getDiskOperatorAuthzPrincipalDbId());
    return runInternalActionWithTasksContext(VdcActionType.AddVmFromScratch, parameters);
}
#end_block

#method_before
private VdcReturnValueBase addVm(VmStatic vmStatic) {
    AddVmParameters parameters = new AddVmParameters(vmStatic);
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        parameters.setParametersCurrentUser(getCurrentUser());
    } else {
        parameters.setSessionId(getParameters().getSessionId());
    }
    parameters.setDiskOperatorUserId(getParameters().getDiskOperatorUserId());
    parameters.setDontAttachToDefaultTag(true);
    parameters.setDiskInfoDestinationMap(diskInfoDestinationMap);
    parameters.setSoundDeviceEnabled(getParameters().isSoundDeviceEnabled());
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    if (getParameters().isUpdateRngDevice()) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(getParameters().getRngDevice());
    }
    return runInternalActionWithTasksContext(VdcActionType.AddVm, parameters);
}
#method_after
private VdcReturnValueBase addVm(VmStatic vmStatic) {
    AddVmParameters parameters = new AddVmParameters(vmStatic);
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        parameters.setParametersCurrentUser(getCurrentUser());
    } else {
        parameters.setSessionId(getParameters().getSessionId());
    }
    parameters.setDiskOperatorAuthzPrincipalDbId(getParameters().getDiskOperatorAuthzPrincipalDbId());
    parameters.setDontAttachToDefaultTag(true);
    parameters.setDiskInfoDestinationMap(diskInfoDestinationMap);
    parameters.setSoundDeviceEnabled(getParameters().isSoundDeviceEnabled());
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    if (getParameters().isUpdateRngDevice()) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(getParameters().getRngDevice());
    }
    return runInternalActionWithTasksContext(VdcActionType.AddVm, parameters);
}
#end_block

#method_before
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    if (isFirstTaskHandler()) {
        // Sort images from parent to leaf (active)
        ImagesHandler.sortImageList(getImages());
        // Update parameters with sorted list
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(getImages())));
    }
    for (Guid imageId : getParameters().getImageIds()) {
        taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
    }
    return taskHandlers;
}
#method_after
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    // as the sorted list is being saved in the parameters.
    if (isFirstTaskHandler()) {
        ImagesHandler.sortImageList(getImages());
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(getImages())));
    }
    for (Guid imageId : getParameters().getImageIds()) {
        taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
    }
    return taskHandlers;
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String fetchResultText = object.getFetchResult().getEntity();
            if (ConstantsManager.getInstance().getConstants().errorLoadingFingerprint().equals(fetchResultText)) {
                fetchResult.setStyleName(style.fetchResultErrorLabel());
            } else {
                fetchResult.setStyleName(style.fetchResultLabel());
            }
            fetchResult.setText(fetchResultText);
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    object.getProviders().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            object.updateHosts();
        }
    });
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
            providersEditor.setVisible(showForemanProviders);
            provisionedHostSection.setVisible(showForemanProviders);
            discoveredHostSection.setVisible(showForemanProviders);
            if (showForemanProviders) {
                object.updateHosts();
            } else {
                object.cleanHostParametersFields();
                hideProviderWidgets(object);
            }
        }
    });
    object.getIsDiscoveredHosts().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (Boolean.TRUE.equals(object.getIsDiscoveredHosts().getEntity())) {
                rbDiscoveredHost.setValue(true);
                showDiscoveredHostsWidgets(true);
            } else {
                rbProvisionedHost.setValue(true);
                showProvisionedHostsWidgets(true);
            }
        }
    });
    rbPassword.setValue(true);
    rbPassword.setFocus(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List<String> items = (List<String>) object.getPmProxyPreferencesList().getItems();
            String selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#method_after
@Override
@SuppressWarnings("unchecked")
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            String fetchResultText = object.getFetchResult().getEntity();
            if (ConstantsManager.getInstance().getConstants().errorLoadingFingerprint().equals(fetchResultText)) {
                fetchResult.addStyleName(style.fetchResultErrorLabel());
            } else {
                fetchResult.removeStyleName(style.fetchResultErrorLabel());
            }
            fetchResult.setText(fetchResultText);
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    object.getProviders().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            object.updateHosts();
        }
    });
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
            providersEditor.setVisible(showForemanProviders);
            provisionedHostSection.setVisible(showForemanProviders);
            discoveredHostSection.setVisible(showForemanProviders);
            if (showForemanProviders) {
                object.updateHosts();
            } else {
                object.cleanHostParametersFields();
                hideProviderWidgets(object);
            }
        }
    });
    object.getIsDiscoveredHosts().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (Boolean.TRUE.equals(object.getIsDiscoveredHosts().getEntity())) {
                rbDiscoveredHost.setValue(true);
                showDiscoveredHostsWidgets(true);
            } else {
                rbProvisionedHost.setValue(true);
                showProvisionedHostsWidgets(true);
            }
        }
    });
    rbPassword.setValue(true);
    rbPassword.setFocus(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List<String> items = (List<String>) object.getPmProxyPreferencesList().getItems();
            String selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener<EventArgs> spmListener = new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#end_block

#method_before
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    if (model.getIsSubTemplate().getEntity()) {
        addVmTemplateParameters.setBaseTemplateId(model.getBaseTemplate().getSelectedItem().getId());
        addVmTemplateParameters.setTemplateVersionName(model.getTemplateVersionName().getEntity());
    }
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#method_after
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setBalloonEnabled(balloonEnabled(model));
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    if (model.getIsSubTemplate().getEntity()) {
        addVmTemplateParameters.setBaseTemplateId(model.getBaseTemplate().getSelectedItem().getId());
        addVmTemplateParameters.setTemplateVersionName(model.getTemplateVersionName().getEntity());
    }
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#end_block

#method_before
private void saveNewVm(final UnitVmModel model) {
    if (model.getProgress() != null) {
        return;
    }
    if (model.getProvisioning().getEntity()) {
        model.startProgress(null);
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model1, Object result1) {
                VmListModel vmListModel = (VmListModel) model1;
                UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                VM vm = vmListModel.getcurrentVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase param = new VmManagementParametersBase(vm);
                param.setDiskInfoDestinationMap(unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap());
                param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                param.setBalloonEnabled(balloonEnabled(model));
                param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                setRngDeviceToParams(model, param);
                Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
            }
        };
        AsyncDataProvider.getInstance().getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
    } else {
        if (model.getProgress() != null) {
            return;
        }
        model.startProgress(null);
        VM vm = getcurrentVm();
        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        VmManagementParametersBase params = new VmManagementParametersBase(vm);
        params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
        params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
        params.setBalloonEnabled(balloonEnabled(model));
        params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
        params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
        params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
        setVmWatchdogToParams(model, params);
        setRngDeviceToParams(model, params);
        Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
    }
}
#method_after
private void saveNewVm(final UnitVmModel model) {
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress(null);
    VM vm = getcurrentVm();
    vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
    AddVmParameters parameters = new AddVmParameters(vm);
    parameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    parameters.setBalloonEnabled(balloonEnabled(model));
    parameters.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    setRngDeviceToParams(model, parameters);
    Frontend.getInstance().runAction(model.getProvisioning().getEntity() ? VdcActionType.AddVmFromTemplate : VdcActionType.AddVm, parameters, createUnitVmModelNetworkAsyncCallback(vm, model), this);
}
#end_block

#method_before
public Event getSearchCompletedEvent() {
    return privateSearchCompletedEvent;
}
#method_after
public Event<EventArgs> getSearchCompletedEvent() {
    return privateSearchCompletedEvent;
}
#end_block

#method_before
private void setSearchCompletedEvent(Event value) {
    privateSearchCompletedEvent = value;
}
#method_after
private void setSearchCompletedEvent(Event<EventArgs> value) {
    privateSearchCompletedEvent = value;
}
#end_block

#method_before
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    BuilderExecutor.build(model, tempVar.getStaticData(), new CommonUnitToVmBaseBuilder());
    BuilderExecutor.build(vm.getStaticData(), tempVar.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder());
    return tempVar;
}
#method_after
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    BuilderExecutor.build(model, tempVar.getStaticData(), new CommonUnitToVmBaseBuilder<VmStatic>());
    BuilderExecutor.build(vm.getStaticData(), tempVar.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder());
    return tempVar;
}
#end_block

#method_before
public void postVmNameUniqueCheck(final UserPortalListModel userPortalListModel) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        setstorageDomain(model.getStorageDomain().getSelectedItem());
        if (model.getProvisioning().getEntity()) {
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object result) {
                    UserPortalListModel userPortalListModel1 = (UserPortalListModel) model;
                    final UnitVmModel unitVmModel = (UnitVmModel) userPortalListModel1.getWindow();
                    VM vm = gettempVm();
                    vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                    VmManagementParametersBase param = new VmManagementParametersBase(vm);
                    param.setDiskInfoDestinationMap(unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap());
                    param.setMakeCreatorExplicitOwner(true);
                    param.setCopyTemplatePermissions(unitVmModel.getCopyPermissions().getEntity());
                    param.setSoundDeviceEnabled(unitVmModel.getIsSoundcardEnabled().getEntity());
                    param.setConsoleEnabled(unitVmModel.getIsConsoleDeviceEnabled().getEntity());
                    setRngDeviceToParams(unitVmModel, param);
                    Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(unitVmModel, defaultNetworkCreatingManager), this);
                }
            };
            AsyncDataProvider.getInstance().getTemplateDiskList(_asyncQuery, gettempVm().getVmtGuid());
        } else {
            VM vm = gettempVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase param = new VmManagementParametersBase(vm);
            param.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
            param.setMakeCreatorExplicitOwner(true);
            param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
            param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            setRngDeviceToParams(model, param);
            Frontend.getInstance().runAction(VdcActionType.AddVm, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
        }
    } else {
        final VM selectedItem = (VM) ((UserPortalItemModel) userPortalListModel.getSelectedItem()).getEntity();
        gettempVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(userPortalListModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(userPortalListModel, false);
        }
    }
}
#method_after
public void postVmNameUniqueCheck(final UserPortalListModel userPortalListModel) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) ((UserPortalItemModel) userPortalListModel.getSelectedItem()).getEntity();
        gettempVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(userPortalListModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(userPortalListModel, false);
        }
    }
}
#end_block

#method_before
protected static void buildVmOnSave(UnitVmModel model, VM vm) {
    BuilderExecutor.build(model, vm.getStaticData(), new FullUnitToVmBaseBuilder());
    BuilderExecutor.build(model, vm, new VmSpecificUnitToVmBuilder());
}
#method_after
protected static void buildVmOnSave(UnitVmModel model, VM vm) {
    BuilderExecutor.build(model, vm.getStaticData(), new FullUnitToVmBaseBuilder<VmStatic>());
    BuilderExecutor.build(model, vm, new VmSpecificUnitToVmBuilder());
}
#end_block

#method_before
public static boolean copyNonEditableFieldsToDestination(VmStatic source, VmStatic destination, boolean hotsetEnabled) {
    return mUpdateVmsStatic.copyNonEditableFieldsToDestination(source, destination, hotsetEnabled);
}
#method_after
public static boolean copyNonEditableFieldsToDestination(VmStatic source, VmStatic destination, boolean hotSetEnabled) {
    return mUpdateVmsStatic.copyNonEditableFieldsToDestination(source, destination, hotSetEnabled);
}
#end_block

#method_before
public boolean IsFieldUpdatable(Enum<?> status, String name, Object fieldContainer, boolean hotsetEnabled) {
    boolean returnValue = true;
    if (!IsFieldUpdatable(name)) {
        if (fieldContainer != null && container != null && !container.canUpdateField(fieldContainer, name, status)) {
            returnValue = false;
        } else {
            Set<String> values = dictionary.get(status);
            returnValue = values != null ? values.contains(name) : false;
            // if field is not updateable in this status, check if hotset request and its an hotset allowed field
            if (!returnValue && hotsetEnabled) {
                returnValue = isHotsetField(name);
            }
        }
        if (!returnValue) {
            log.warnFormat("Field {0} can not be updated when status is {1}", name, status);
        }
    }
    return returnValue;
}
#method_after
public boolean IsFieldUpdatable(Enum<?> status, String name, Object fieldContainer, boolean hotsetEnabled) {
    boolean returnValue = true;
    if (!IsFieldUpdatable(name)) {
        if (fieldContainer != null && container != null && !container.canUpdateField(fieldContainer, name, status)) {
            returnValue = false;
        } else {
            Set<String> values = dictionary.get(status);
            returnValue = values != null ? values.contains(name) : false;
            // if field is not updateable in this status, check if hotset request and its an hotset allowed field
            if (!returnValue && hotsetEnabled) {
                returnValue = isHotSetField(name);
            }
        }
        if (!returnValue) {
            log.warnFormat("Field {0} can not be updated when status is {1}", name, status);
        }
    }
    return returnValue;
}
#end_block

#method_before
public boolean copyNonEditableFieldsToDestination(Object source, Object destination, boolean hotsetEnabled) {
    Class<?> cls = source.getClass();
    while (!cls.equals(Object.class)) {
        for (Field srcFld : cls.getDeclaredFields()) {
            try {
                // copy fields that are non final, and not-editable and not a hotset field or it is but this is not hotset case
                if (!Modifier.isFinal(srcFld.getModifiers()) && !IsFieldUpdatable(srcFld.getName()) && (!isHotsetField(srcFld.getName()) || (isHotsetField(srcFld.getName()) && !hotsetEnabled))) {
                    srcFld.setAccessible(true);
                    Field dstFld = cls.getDeclaredField(srcFld.getName());
                    dstFld.setAccessible(true);
                    dstFld.set(destination, srcFld.get(source));
                }
            } catch (Exception exp) {
                log.errorFormat("Failed to copy non editable field {0}, error: {1}", srcFld.getName(), exp.getMessage());
                return false;
            }
        }
        cls = cls.getSuperclass();
    }
    return true;
}
#method_after
public boolean copyNonEditableFieldsToDestination(Object source, Object destination, boolean hotSetEnabled) {
    Class<?> cls = source.getClass();
    while (!cls.equals(Object.class)) {
        for (Field srcFld : cls.getDeclaredFields()) {
            try {
                // copy fields that are non final, and not-editable and not a hotset field or it is but this is not hotset case
                if (!Modifier.isFinal(srcFld.getModifiers()) && !IsFieldUpdatable(srcFld.getName()) && (!isHotSetField(srcFld.getName()) || !hotSetEnabled)) {
                    srcFld.setAccessible(true);
                    Field dstFld = cls.getDeclaredField(srcFld.getName());
                    dstFld.setAccessible(true);
                    dstFld.set(destination, srcFld.get(source));
                }
            } catch (Exception exp) {
                log.errorFormat("Failed to copy non editable field {0}, error: {1}", srcFld.getName(), exp.getMessage());
                return false;
            }
        }
        cls = cls.getSuperclass();
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotsetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotsetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotsetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#end_block

